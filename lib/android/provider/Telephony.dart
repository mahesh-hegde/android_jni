// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../net/Uri.dart" as uri_;

import "../content/Context.dart" as context_;

import "../content/Intent.dart" as intent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.Telephony
///
/// The Telephony provider contains data related to phone operation, specifically SMS and MMS
/// messages, access to the APN list, including the MMSC to use, and the service state.
///
/// <p class="note"><strong>Note:</strong> These APIs are not available on all Android-powered
/// devices. If your app depends on telephony features such as for managing SMS messages, include
/// a <a href="{@docRoot}guide/topics/manifest/uses-feature-element.html">{@code <uses-feature>}
/// </a> element in your manifest that declares the {@code "android.hardware.telephony"} hardware
/// feature. Alternatively, you can check for telephony availability at runtime using either
/// android.content.pm.PackageManager\#hasSystemFeature hasSystemFeature(PackageManager.FEATURE_TELEPHONY) or android.telephony.TelephonyManager\#getPhoneType.
///
///
/// <h3>Creating an SMS app</h3>
///
/// Only the default SMS app (selected by the user in system settings) is able to write to the
/// SMS Provider (the tables defined within the {@code Telephony} class) and only the default SMS
/// app receives the android.provider.Telephony.Sms.Intents\#SMS_DELIVER_ACTION broadcast
/// when the user receives an SMS or the android.provider.Telephony.Sms.Intents\#WAP_PUSH_DELIVER_ACTION broadcast when the user
/// receives an MMS.
///
///
/// Any app that wants to behave as the user's default SMS app must handle the following intents:
/// <ul>
/// <li>In a broadcast receiver, include an intent filter for Sms.Intents\#SMS_DELIVER_ACTION
/// (<code>"android.provider.Telephony.SMS_DELIVER"</code>). The broadcast receiver must also
/// require the android.Manifest.permission\#BROADCAST_SMS permission.
/// This allows your app to directly receive incoming SMS messages.
///</li>
/// <li>In a broadcast receiver, include an intent filter for Sms.Intents\#WAP_PUSH_DELIVER_ACTION} ({@code "android.provider.Telephony.WAP_PUSH_DELIVER"})
/// with the MIME type <code>"application/vnd.wap.mms-message"</code>.
/// The broadcast receiver must also require the android.Manifest.permission\#BROADCAST_WAP_PUSH permission.
/// This allows your app to directly receive incoming MMS messages.
///</li>
/// <li>In your activity that delivers new messages, include an intent filter for
/// android.content.Intent\#ACTION_SENDTO (<code>"android.intent.action.SENDTO"
/// </code>) with schemas, <code>sms:</code>, <code>smsto:</code>, <code>mms:</code>, and
/// <code>mmsto:</code>.
/// This allows your app to receive intents from other apps that want to deliver a
/// message.
///</li>
/// <li>In a service, include an intent filter for android.telephony.TelephonyManager\#ACTION_RESPOND_VIA_MESSAGE
/// (<code>"android.intent.action.RESPOND_VIA_MESSAGE"</code>) with schemas,
/// <code>sms:</code>, <code>smsto:</code>, <code>mms:</code>, and <code>mmsto:</code>.
/// This service must also require the android.Manifest.permission\#SEND_RESPOND_VIA_MESSAGE permission.
/// This allows users to respond to incoming phone calls with an immediate text message
/// using your app.
///</li>
/// </ul>
///
/// Other apps that are not selected as the default SMS app can only _read_ the SMS
/// Provider, but may also be notified when a new SMS arrives by listening for the Sms.Intents\#SMS_RECEIVED_ACTION
/// broadcast, which is a non-abortable broadcast that may be delivered to multiple apps. This
/// broadcast is intended for apps that&mdash;while not selected as the default SMS app&mdash;need to
/// read special incoming messages such as to perform phone number verification.
///
///
/// For more information about building SMS apps, read the blog post, <a href="http://android-developers.blogspot.com/2013/10/getting-your-sms-apps-ready-for-kitkat.html">Getting Your SMS Apps Ready for KitKat</a>.
///
class Telephony extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony");
  Telephony.fromRef(jni.JObject ref) : super.fromRef(ref);
}

/// from: android.provider.Telephony$ThreadsColumns
///
/// Columns for the "threads" table used by MMS and SMS.
class Telephony_ThreadsColumns extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$ThreadsColumns");
  Telephony_ThreadsColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ARCHIVED
  ///
  /// If the thread is archived
  /// <P>Type: INTEGER (boolean)</P>
  static const ARCHIVED = "archived";

  /// from: static public final java.lang.String DATE
  ///
  /// The date at which the thread was created.
  /// <P>Type: INTEGER (long)</P>
  static const DATE = "date";

  /// from: static public final java.lang.String ERROR
  ///
  /// Indicates whether there is a transmission error in the thread.
  /// <P>Type: INTEGER</P>
  static const ERROR = "error";

  /// from: static public final java.lang.String HAS_ATTACHMENT
  ///
  /// Indicates whether this thread contains any attachments.
  /// <P>Type: INTEGER</P>
  static const HAS_ATTACHMENT = "has_attachment";

  /// from: static public final java.lang.String MESSAGE_COUNT
  ///
  /// The message count of the thread.
  /// <P>Type: INTEGER</P>
  static const MESSAGE_COUNT = "message_count";

  /// from: static public final java.lang.String READ
  ///
  /// Indicates whether all messages of the thread have been read.
  /// <P>Type: INTEGER</P>
  static const READ = "read";

  /// from: static public final java.lang.String RECIPIENT_IDS
  ///
  /// A string encoding of the recipient IDs of the recipients of
  /// the message, in numerical order and separated by spaces.
  /// <P>Type: TEXT</P>
  static const RECIPIENT_IDS = "recipient_ids";

  /// from: static public final java.lang.String SNIPPET
  ///
  /// The snippet of the latest message in the thread.
  /// <P>Type: TEXT</P>
  static const SNIPPET = "snippet";

  /// from: static public final java.lang.String SNIPPET_CHARSET
  ///
  /// The charset of the snippet.
  /// <P>Type: INTEGER</P>
  static const SNIPPET_CHARSET = "snippet_cs";

  /// from: static public final java.lang.String TYPE
  ///
  /// Type of the thread, either Threads\#COMMON_THREAD or
  /// Threads\#BROADCAST_THREAD.
  /// <P>Type: INTEGER</P>
  static const TYPE = "type";
}

/// from: android.provider.Telephony$Threads
///
/// Helper functions for the "threads" table used by MMS and SMS.
class Telephony_Threads extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Threads");
  Telephony_Threads.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BROADCAST_THREAD
  ///
  /// Thread type: broadcast thread.
  static const BROADCAST_THREAD = 1;

  /// from: static public final int COMMON_THREAD
  ///
  /// Thread type: common thread.
  static const COMMON_THREAD = 0;

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table, by conversation.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_OBSOLETE_THREADS_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "OBSOLETE_THREADS_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri OBSOLETE_THREADS_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table, for obsolete threads.
  static uri_.Uri get OBSOLETE_THREADS_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_OBSOLETE_THREADS_URI, jni.JniType.objectType)
      .object);

  static final _id_getOrCreateThreadId = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getOrCreateThreadId",
      "(Landroid/content/Context;Ljava/lang/String;)J");

  /// from: static public long getOrCreateThreadId(android.content.Context context, java.lang.String recipient)
  ///
  /// This is a single-recipient version of {@code getOrCreateThreadId}.
  /// It's convenient for use with SMS messages.
  ///@param context the context object to use.
  ///@param recipient the recipient to send to.
  static int getOrCreateThreadId(
          context_.Context context, jni.JniString recipient) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getOrCreateThreadId,
          jni.JniType.longType, [context.reference, recipient.reference]).long;

  static final _id_getOrCreateThreadId1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getOrCreateThreadId",
      "(Landroid/content/Context;Ljava/util/Set;)J");

  /// from: static public long getOrCreateThreadId(android.content.Context context, java.util.Set<java.lang.String> recipients)
  ///
  /// Given the recipients list and subject of an unsaved message,
  /// return its thread ID.  If the message starts a new thread,
  /// allocate a new thread ID.  Otherwise, use the appropriate
  /// existing thread ID.
  ///
  /// Find the thread ID of the same set of recipients (in any order,
  /// without any additions). If one is found, return it. Otherwise,
  /// return a unique thread ID.
  ///
  static int getOrCreateThreadId1(
          context_.Context context, jni.JniObject recipients) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getOrCreateThreadId1,
          jni.JniType.longType, [context.reference, recipients.reference]).long;
}

/// from: android.provider.Telephony$TextBasedSmsColumns
///
/// Base columns for tables that contain text-based SMSs.
class Telephony_TextBasedSmsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/Telephony\$TextBasedSmsColumns");
  Telephony_TextBasedSmsColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ADDRESS
  ///
  /// The address of the other party.
  /// <P>Type: TEXT</P>
  static const ADDRESS = "address";

  /// from: static public final java.lang.String BODY
  ///
  /// The body of the message.
  /// <P>Type: TEXT</P>
  static const BODY = "body";

  /// from: static public final java.lang.String CREATOR
  ///
  /// The identity of the sender of a sent message. It is
  /// usually the package name of the app which sends the message.
  /// <p class="note"><strong>Note:</strong>
  /// This column is read-only. It is set by the provider and can not be changed by apps.
  /// Type: TEXT
  ///
  static const CREATOR = "creator";

  /// from: static public final java.lang.String DATE
  ///
  /// The date the message was received.
  /// <P>Type: INTEGER (long)</P>
  static const DATE = "date";

  /// from: static public final java.lang.String DATE_SENT
  ///
  /// The date the message was sent.
  /// <P>Type: INTEGER (long)</P>
  static const DATE_SENT = "date_sent";

  /// from: static public final java.lang.String ERROR_CODE
  ///
  /// Error code associated with sending or receiving this message
  /// <P>Type: INTEGER</P>
  static const ERROR_CODE = "error_code";

  /// from: static public final java.lang.String LOCKED
  ///
  /// Is the message locked?
  /// <P>Type: INTEGER (boolean)</P>
  static const LOCKED = "locked";

  /// from: static public final int MESSAGE_TYPE_ALL
  ///
  /// Message type: all messages.
  static const MESSAGE_TYPE_ALL = 0;

  /// from: static public final int MESSAGE_TYPE_DRAFT
  ///
  /// Message type: drafts.
  static const MESSAGE_TYPE_DRAFT = 3;

  /// from: static public final int MESSAGE_TYPE_FAILED
  ///
  /// Message type: failed outgoing message.
  static const MESSAGE_TYPE_FAILED = 5;

  /// from: static public final int MESSAGE_TYPE_INBOX
  ///
  /// Message type: inbox.
  static const MESSAGE_TYPE_INBOX = 1;

  /// from: static public final int MESSAGE_TYPE_OUTBOX
  ///
  /// Message type: outbox.
  static const MESSAGE_TYPE_OUTBOX = 4;

  /// from: static public final int MESSAGE_TYPE_QUEUED
  ///
  /// Message type: queued to send later.
  static const MESSAGE_TYPE_QUEUED = 6;

  /// from: static public final int MESSAGE_TYPE_SENT
  ///
  /// Message type: sent messages.
  static const MESSAGE_TYPE_SENT = 2;

  /// from: static public final java.lang.String PERSON
  ///
  /// The ID of the sender of the conversation, if present.
  /// <P>Type: INTEGER (reference to item in {@code content://contacts/people})</P>
  static const PERSON = "person";

  /// from: static public final java.lang.String PROTOCOL
  ///
  /// The protocol identifier code.
  /// <P>Type: INTEGER</P>
  static const PROTOCOL = "protocol";

  /// from: static public final java.lang.String READ
  ///
  /// Has the message been read?
  /// <P>Type: INTEGER (boolean)</P>
  static const READ = "read";

  /// from: static public final java.lang.String REPLY_PATH_PRESENT
  ///
  /// Is the {@code TP-Reply-Path} flag set?
  /// <P>Type: BOOLEAN</P>
  static const REPLY_PATH_PRESENT = "reply_path_present";

  /// from: static public final java.lang.String SEEN
  ///
  /// Has the message been seen by the user? The "seen" flag determines
  /// whether we need to show a notification.
  /// <P>Type: INTEGER (boolean)</P>
  static const SEEN = "seen";

  /// from: static public final java.lang.String SERVICE_CENTER
  ///
  /// The service center (SC) through which to send the message, if present.
  /// <P>Type: TEXT</P>
  static const SERVICE_CENTER = "service_center";

  /// from: static public final java.lang.String STATUS
  ///
  /// {@code TP-Status} value for the message, or -1 if no status has been received.
  /// <P>Type: INTEGER</P>
  static const STATUS = "status";

  /// from: static public final int STATUS_COMPLETE
  ///
  /// TP-Status: complete.
  static const STATUS_COMPLETE = 0;

  /// from: static public final int STATUS_FAILED
  ///
  /// TP-Status: failed.
  static const STATUS_FAILED = 64;

  /// from: static public final int STATUS_NONE
  ///
  /// TP-Status: no status received.
  static const STATUS_NONE = -1;

  /// from: static public final int STATUS_PENDING
  ///
  /// TP-Status: pending.
  static const STATUS_PENDING = 32;

  /// from: static public final java.lang.String SUBJECT
  ///
  /// The subject of the message, if present.
  /// <P>Type: TEXT</P>
  static const SUBJECT = "subject";

  /// from: static public final java.lang.String SUBSCRIPTION_ID
  ///
  /// The subscription to which the message belongs to. Its value will be
  /// < 0 if the sub id cannot be determined.
  /// Type: INTEGER (long)
  ///
  static const SUBSCRIPTION_ID = "sub_id";

  /// from: static public final java.lang.String THREAD_ID
  ///
  /// The thread ID of the message.
  /// <P>Type: INTEGER</P>
  static const THREAD_ID = "thread_id";

  /// from: static public final java.lang.String TYPE
  ///
  /// The type of message.
  /// <P>Type: INTEGER</P>
  static const TYPE = "type";
}

/// from: android.provider.Telephony$Sms
///
/// Contains all text-based SMS messages.
class Telephony_Sms extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Sms");
  Telephony_Sms.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";

  static final _id_getDefaultSmsPackage = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDefaultSmsPackage",
      "(Landroid/content/Context;)Ljava/lang/String;");

  /// from: static public java.lang.String getDefaultSmsPackage(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to determine the currently configured default SMS package.
  ///@param context context of the requesting application
  ///@return package name for the default SMS package or null
  static jni.JniString getDefaultSmsPackage(context_.Context context) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDefaultSmsPackage,
          jni.JniType.objectType,
          [context.reference]).object);
}

/// from: android.provider.Telephony$Sms$Sent
///
/// Contains all sent text-based SMS messages in the SMS app.
class Telephony_Sms_Sent extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Sms\$Sent");
  Telephony_Sms_Sent.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";
}

/// from: android.provider.Telephony$Sms$Outbox
///
/// Contains all pending outgoing text-based SMS messages.
class Telephony_Sms_Outbox extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Sms\$Outbox");
  Telephony_Sms_Outbox.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";
}

/// from: android.provider.Telephony$Sms$Intents
///
/// Contains constants for SMS related Intents that are broadcast.
class Telephony_Sms_Intents extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Sms\$Intents");
  Telephony_Sms_Intents.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CHANGE_DEFAULT
  ///
  /// Activity action: Ask the user to change the default
  /// SMS application. This will show a dialog that asks the
  /// user whether they want to replace the current default
  /// SMS application with the one specified in
  /// \#EXTRA_PACKAGE_NAME.
  static const ACTION_CHANGE_DEFAULT =
      "android.provider.Telephony.ACTION_CHANGE_DEFAULT";

  /// from: static public final java.lang.String ACTION_DEFAULT_SMS_PACKAGE_CHANGED
  ///
  /// Broadcast action: When the default SMS package changes,
  /// the previous default SMS package and the new default SMS
  /// package are sent this broadcast to notify them of the change.
  /// A boolean is specified in \#EXTRA_IS_DEFAULT_SMS_APP to
  /// indicate whether the package is the new default SMS package.
  static const ACTION_DEFAULT_SMS_PACKAGE_CHANGED =
      "android.provider.action.DEFAULT_SMS_PACKAGE_CHANGED";

  /// from: static public final java.lang.String ACTION_EXTERNAL_PROVIDER_CHANGE
  ///
  /// Broadcast action: When a change is made to the SmsProvider or
  /// MmsProvider by a process other than the default SMS application,
  /// this intent is broadcast to the default SMS application so it can
  /// re-sync or update the change. The uri that was used to call the provider
  /// can be retrieved from the intent with getData(). The actual affected uris
  /// (which would depend on the selection specified) are not included.
  static const ACTION_EXTERNAL_PROVIDER_CHANGE =
      "android.provider.action.EXTERNAL_PROVIDER_CHANGE";

  /// from: static public final java.lang.String DATA_SMS_RECEIVED_ACTION
  ///
  /// Broadcast Action: A new data based SMS message has been received
  /// by the device. This intent will be delivered to all registered
  /// receivers as a notification. The intent will have the following extra
  /// values:
  ///
  ///
  /// <ul>
  ///   <li>_"pdus"_ - An Object[] of byte[]s containing the PDUs
  ///   that make up the message.</li>
  /// </ul>
  ///
  /// The extra values can be extracted using
  /// \#getMessagesFromIntent(Intent).
  ///
  ///
  /// If a BroadcastReceiver encounters an error while processing
  /// this intent it should set the result code appropriately.
  ///
  ///
  /// Requires android.Manifest.permission\#RECEIVE_SMS to receive.
  ///
  static const DATA_SMS_RECEIVED_ACTION =
      "android.intent.action.DATA_SMS_RECEIVED";

  /// from: static public final java.lang.String EXTRA_IS_DEFAULT_SMS_APP
  ///
  /// The IsDefaultSmsApp boolean passed as an
  /// extra for \#ACTION_DEFAULT_SMS_PACKAGE_CHANGED to indicate whether the
  /// SMS app is becoming the default SMS app or is no longer the default.
  ///@see \#ACTION_DEFAULT_SMS_PACKAGE_CHANGED
  static const EXTRA_IS_DEFAULT_SMS_APP =
      "android.provider.extra.IS_DEFAULT_SMS_APP";

  /// from: static public final java.lang.String EXTRA_PACKAGE_NAME
  ///
  /// The PackageName string passed in as an
  /// extra for \#ACTION_CHANGE_DEFAULT
  ///@see \#ACTION_CHANGE_DEFAULT
  static const EXTRA_PACKAGE_NAME = "package";

  /// from: static public final int RESULT_SMS_DUPLICATED
  ///
  /// Set by BroadcastReceiver to indicate a duplicate incoming message.
  static const RESULT_SMS_DUPLICATED = 5;

  /// from: static public final int RESULT_SMS_GENERIC_ERROR
  ///
  /// Set by BroadcastReceiver to indicate a generic error while
  /// processing the message.
  static const RESULT_SMS_GENERIC_ERROR = 2;

  /// from: static public final int RESULT_SMS_HANDLED
  ///
  /// Set by BroadcastReceiver to indicate that the message was handled
  /// successfully.
  static const RESULT_SMS_HANDLED = 1;

  /// from: static public final int RESULT_SMS_OUT_OF_MEMORY
  ///
  /// Set by BroadcastReceiver to indicate insufficient memory to store
  /// the message.
  static const RESULT_SMS_OUT_OF_MEMORY = 3;

  /// from: static public final int RESULT_SMS_UNSUPPORTED
  ///
  /// Set by BroadcastReceiver to indicate that the message, while
  /// possibly valid, is of a format or encoding that is not
  /// supported.
  static const RESULT_SMS_UNSUPPORTED = 4;

  /// from: static public final java.lang.String SECRET_CODE_ACTION
  ///
  /// Broadcast Action: A debug code has been entered in the dialer. This intent is
  /// broadcast by the system and OEM telephony apps may need to receive these broadcasts.
  /// These "secret codes" are used to activate developer menus by dialing certain codes.
  /// And they are of the form {@code *\#*\#&lt;code&gt;\#*\#*}. The intent will have the data
  /// URI: {@code android_secret_code://&lt;code&gt;}. It is possible that a manifest
  /// receiver would be woken up even if it is not currently running.
  ///
  /// Requires {@code android.Manifest.permission\#CONTROL_INCALL_EXPERIENCE} to
  /// send and receive.
  ///
  static const SECRET_CODE_ACTION = "android.provider.Telephony.SECRET_CODE";

  /// from: static public final java.lang.String SIM_FULL_ACTION
  ///
  /// Broadcast Action: The SIM storage for SMS messages is full.  If
  /// space is not freed, messages targeted for the SIM (class 2) may
  /// not be saved.
  ///
  /// Requires android.Manifest.permission\#RECEIVE_SMS to receive.
  ///
  static const SIM_FULL_ACTION = "android.provider.Telephony.SIM_FULL";

  /// from: static public final java.lang.String SMS_CB_RECEIVED_ACTION
  ///
  /// Broadcast Action: A new Cell Broadcast message has been received
  /// by the device. The intent will have the following extra
  /// values:
  ///
  ///
  /// <ul>
  ///   <li>_"message"_ - An SmsCbMessage object containing the broadcast message
  ///   data. This is not an emergency alert, so ETWS and CMAS data will be null.</li>
  /// </ul>
  ///
  /// The extra values can be extracted using
  /// \#getMessagesFromIntent(Intent).
  ///
  ///
  /// If a BroadcastReceiver encounters an error while processing
  /// this intent it should set the result code appropriately.
  ///
  ///
  /// Requires android.Manifest.permission\#RECEIVE_SMS to receive.
  ///
  static const SMS_CB_RECEIVED_ACTION =
      "android.provider.Telephony.SMS_CB_RECEIVED";

  /// from: static public final java.lang.String SMS_DELIVER_ACTION
  ///
  /// Broadcast Action: A new text-based SMS message has been received
  /// by the device. This intent will only be delivered to the default
  /// sms app. That app is responsible for writing the message and notifying
  /// the user. The intent will have the following extra values:
  ///
  ///
  /// <ul>
  ///   <li>_"pdus"_ - An Object[] of byte[]s containing the PDUs
  ///   that make up the message.</li>
  ///   <li>_"format"_ - A String describing the format of the PDUs. It can
  ///   be either "3gpp" or "3gpp2".</li>
  ///   <li>_"subscription"_ - An optional long value of the subscription id which
  ///   received the message.</li>
  ///   <li>_"slot"_ - An optional int value of the SIM slot containing the
  ///   subscription.</li>
  ///   <li>_"phone"_ - An optional int value of the phone id associated with the
  ///   subscription.</li>
  ///   <li>_"errorCode"_ - An optional int error code associated with receiving
  ///   the message.</li>
  /// </ul>
  ///
  /// The extra values can be extracted using
  /// \#getMessagesFromIntent(Intent).
  ///
  ///
  /// If a BroadcastReceiver encounters an error while processing
  /// this intent it should set the result code appropriately.
  ///
  ///
  /// <p class="note"><strong>Note:</strong>
  /// The broadcast receiver that filters for this intent must declare
  /// android.Manifest.permission\#BROADCAST_SMS as a required permission in
  /// the <a href="{@docRoot}guide/topics/manifest/receiver-element.html">{@code
  /// <receiver>}</a> tag.
  ///
  /// Requires android.Manifest.permission\#RECEIVE_SMS to receive.
  ///
  static const SMS_DELIVER_ACTION = "android.provider.Telephony.SMS_DELIVER";

  /// from: static public final java.lang.String SMS_RECEIVED_ACTION
  ///
  /// Broadcast Action: A new text-based SMS message has been received
  /// by the device. This intent will be delivered to all registered
  /// receivers as a notification. These apps are not expected to write the
  /// message or notify the user. The intent will have the following extra
  /// values:
  ///
  ///
  /// <ul>
  ///   <li>_"pdus"_ - An Object[] of byte[]s containing the PDUs
  ///   that make up the message.</li>
  /// </ul>
  ///
  /// The extra values can be extracted using
  /// \#getMessagesFromIntent(Intent).
  ///
  ///
  /// If a BroadcastReceiver encounters an error while processing
  /// this intent it should set the result code appropriately.
  ///
  ///
  /// Requires android.Manifest.permission\#RECEIVE_SMS to receive.
  ///
  static const SMS_RECEIVED_ACTION = "android.provider.Telephony.SMS_RECEIVED";

  /// from: static public final java.lang.String SMS_REJECTED_ACTION
  ///
  /// Broadcast Action: An incoming SMS has been rejected by the
  /// telephony framework.  This intent is sent in lieu of any
  /// of the RECEIVED_ACTION intents.  The intent will have the
  /// following extra value:
  ///
  ///
  /// <ul>
  ///   <li>_"result"_ - An int result code, e.g. \#RESULT_SMS_OUT_OF_MEMORY
  ///   indicating the error returned to the network.</li>
  /// </ul>
  ///
  /// Requires android.Manifest.permission\#RECEIVE_SMS to receive.
  ///
  static const SMS_REJECTED_ACTION = "android.provider.Telephony.SMS_REJECTED";

  /// from: static public final java.lang.String SMS_SERVICE_CATEGORY_PROGRAM_DATA_RECEIVED_ACTION
  ///
  /// Broadcast Action: A new CDMA SMS has been received containing Service Category
  /// Program Data (updates the list of enabled broadcast channels). The intent will
  /// have the following extra values:
  ///
  ///
  /// <ul>
  ///   <li>_"operations"_ - An array of CdmaSmsCbProgramData objects containing
  ///   the service category operations (add/delete/clear) to perform.</li>
  /// </ul>
  ///
  /// The extra values can be extracted using
  /// \#getMessagesFromIntent(Intent).
  ///
  ///
  /// If a BroadcastReceiver encounters an error while processing
  /// this intent it should set the result code appropriately.
  ///
  ///
  /// Requires android.Manifest.permission\#RECEIVE_SMS to receive.
  ///
  static const SMS_SERVICE_CATEGORY_PROGRAM_DATA_RECEIVED_ACTION =
      "android.provider.Telephony.SMS_SERVICE_CATEGORY_PROGRAM_DATA_RECEIVED";

  /// from: static public final java.lang.String WAP_PUSH_DELIVER_ACTION
  ///
  /// Broadcast Action: A new WAP PUSH message has been received by the
  /// device. This intent will only be delivered to the default
  /// sms app. That app is responsible for writing the message and notifying
  /// the user. The intent will have the following extra values:
  ///
  ///
  /// <ul>
  ///   <li>_"transactionId"_ - (Integer) The WAP transaction ID</li>
  ///   <li>_"pduType"_ - (Integer) The WAP PDU type</li>
  ///   <li>_"header"_ - (byte[]) The header of the message</li>
  ///   <li>_"data"_ - (byte[]) The data payload of the message</li>
  ///   <li>_"contentTypeParameters" _
  ///   -(HashMap&lt;String,String&gt;) Any parameters associated with the content type
  ///   (decoded from the WSP Content-Type header)</li>
  ///   <li>_"subscription"_ - An optional long value of the subscription id which
  ///   received the message.</li>
  ///   <li>_"slot"_ - An optional int value of the SIM slot containing the
  ///   subscription.</li>
  ///   <li>_"phone"_ - An optional int value of the phone id associated with the
  ///   subscription.</li>
  /// </ul>
  ///
  /// If a BroadcastReceiver encounters an error while processing
  /// this intent it should set the result code appropriately.
  ///
  ///
  /// The contentTypeParameters extra value is map of content parameters keyed by
  /// their names.
  ///
  ///
  /// If any unassigned well-known parameters are encountered, the key of the map will
  /// be 'unassigned/0x...', where '...' is the hex value of the unassigned parameter.  If
  /// a parameter has No-Value the value in the map will be null.
  ///
  ///
  /// Requires android.Manifest.permission\#RECEIVE_MMS or
  /// android.Manifest.permission\#RECEIVE_WAP_PUSH (depending on WAP PUSH type) to
  /// receive.
  ///
  ///
  /// <p class="note"><strong>Note:</strong>
  /// The broadcast receiver that filters for this intent must declare
  /// android.Manifest.permission\#BROADCAST_WAP_PUSH as a required permission in
  /// the <a href="{@docRoot}guide/topics/manifest/receiver-element.html">{@code
  /// <receiver>}</a> tag.
  static const WAP_PUSH_DELIVER_ACTION =
      "android.provider.Telephony.WAP_PUSH_DELIVER";

  /// from: static public final java.lang.String WAP_PUSH_RECEIVED_ACTION
  ///
  /// Broadcast Action: A new WAP PUSH message has been received by the
  /// device. This intent will be delivered to all registered
  /// receivers as a notification. These apps are not expected to write the
  /// message or notify the user. The intent will have the following extra
  /// values:
  ///
  ///
  /// <ul>
  ///   <li>_"transactionId"_ - (Integer) The WAP transaction ID</li>
  ///   <li>_"pduType"_ - (Integer) The WAP PDU type</li>
  ///   <li>_"header"_ - (byte[]) The header of the message</li>
  ///   <li>_"data"_ - (byte[]) The data payload of the message</li>
  ///   <li>_"contentTypeParameters"_
  ///   - (HashMap&lt;String,String&gt;) Any parameters associated with the content type
  ///   (decoded from the WSP Content-Type header)</li>
  /// </ul>
  ///
  /// If a BroadcastReceiver encounters an error while processing
  /// this intent it should set the result code appropriately.
  ///
  ///
  /// The contentTypeParameters extra value is map of content parameters keyed by
  /// their names.
  ///
  ///
  /// If any unassigned well-known parameters are encountered, the key of the map will
  /// be 'unassigned/0x...', where '...' is the hex value of the unassigned parameter.  If
  /// a parameter has No-Value the value in the map will be null.
  ///
  ///
  /// Requires android.Manifest.permission\#RECEIVE_MMS or
  /// android.Manifest.permission\#RECEIVE_WAP_PUSH (depending on WAP PUSH type) to
  /// receive.
  ///
  static const WAP_PUSH_RECEIVED_ACTION =
      "android.provider.Telephony.WAP_PUSH_RECEIVED";

  static final _id_getMessagesFromIntent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getMessagesFromIntent",
      "(Landroid/content/Intent;)[Landroid/telephony/SmsMessage;");

  /// from: static public android.telephony.SmsMessage[] getMessagesFromIntent(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read the PDUs out of an \#SMS_RECEIVED_ACTION or a
  /// \#DATA_SMS_RECEIVED_ACTION intent.
  ///@param intent the intent to read from
  ///@return an array of SmsMessages for the PDUs
  static jni.JniObject getMessagesFromIntent(intent_.Intent intent) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getMessagesFromIntent,
          jni.JniType.objectType,
          [intent.reference]).object);
}

/// from: android.provider.Telephony$Sms$Inbox
///
/// Contains all text-based SMS messages in the SMS app inbox.
class Telephony_Sms_Inbox extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Sms\$Inbox");
  Telephony_Sms_Inbox.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";
}

/// from: android.provider.Telephony$Sms$Draft
///
/// Contains all sent text-based SMS messages in the SMS app.
class Telephony_Sms_Draft extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Sms\$Draft");
  Telephony_Sms_Draft.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";
}

/// from: android.provider.Telephony$Sms$Conversations
///
/// Contains all sent text-based SMS messages in the SMS app.
class Telephony_Sms_Conversations extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Sms\$Conversations");
  Telephony_Sms_Conversations.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";

  /// from: static public final java.lang.String MESSAGE_COUNT
  ///
  /// The number of messages in the conversation.
  /// <P>Type: INTEGER</P>
  static const MESSAGE_COUNT = "msg_count";

  /// from: static public final java.lang.String SNIPPET
  ///
  /// The first 45 characters of the body of the message.
  /// <P>Type: TEXT</P>
  static const SNIPPET = "snippet";
}

/// from: android.provider.Telephony$ServiceStateTable
///
/// Constants for interfacing with the ServiceStateProvider and the different fields of the
/// ServiceState class accessible through the provider.
class Telephony_ServiceStateTable extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$ServiceStateTable");
  Telephony_ServiceStateTable.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String AUTHORITY
  ///
  /// The authority string for the ServiceStateProvider
  static const AUTHORITY = "service-state";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for the ServiceStateProvider
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String IS_MANUAL_NETWORK_SELECTION
  ///
  /// The current network selection mode.
  ///
  /// This is the same as ServiceState\#getIsManualSelection().
  static const IS_MANUAL_NETWORK_SELECTION = "is_manual_network_selection";

  /// from: static public final java.lang.String VOICE_OPERATOR_NUMERIC
  ///
  /// The current registered operator numeric id.
  ///
  /// In GSM/UMTS, numeric format is 3 digit country code plus 2 or 3 digit
  /// network code.
  ///
  /// This is the same as ServiceState\#getOperatorNumeric().
  static const VOICE_OPERATOR_NUMERIC = "voice_operator_numeric";

  /// from: static public final java.lang.String VOICE_REG_STATE
  ///
  /// An integer value indicating the current voice service state.
  ///
  /// Valid values: ServiceState\#STATE_IN_SERVICE,
  /// ServiceState\#STATE_OUT_OF_SERVICE, ServiceState\#STATE_EMERGENCY_ONLY,
  /// ServiceState\#STATE_POWER_OFF.
  ///
  /// This is the same as ServiceState\#getState().
  static const VOICE_REG_STATE = "voice_reg_state";

  static final _id_getUriForSubscriptionIdAndField =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "getUriForSubscriptionIdAndField",
          "(ILjava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getUriForSubscriptionIdAndField(int subscriptionId, java.lang.String field)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generates a content Uri used to receive updates on a specific field in the
  /// ServiceState provider.
  ///
  /// Use this Uri with a ContentObserver to be notified of changes to the
  /// ServiceState while your app is running.  You can also use a JobService to
  /// ensure your app is notified of changes to the Uri even when it is not running.
  /// Note, however, that using a JobService does not guarantee timely delivery of
  /// updates to the Uri.
  ///@param subscriptionId the subscriptionId to receive updates on
  ///@param field the ServiceState field to receive updates on
  ///@return the Uri used to observe ServiceState changes
  static uri_.Uri getUriForSubscriptionIdAndField(
          int subscriptionId, jni.JniString field) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getUriForSubscriptionIdAndField,
          jni.JniType.objectType,
          [subscriptionId, field.reference]).object);

  static final _id_getUriForSubscriptionId = jniAccessors.getStaticMethodIDOf(
      _classRef, "getUriForSubscriptionId", "(I)Landroid/net/Uri;");

  /// from: static public android.net.Uri getUriForSubscriptionId(int subscriptionId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generates a content Uri used to receive updates on every field in the
  /// ServiceState provider.
  ///
  /// Use this Uri with a ContentObserver to be notified of changes to the
  /// ServiceState while your app is running.  You can also use a JobService to
  /// ensure your app is notified of changes to the Uri even when it is not running.
  /// Note, however, that using a JobService does not guarantee timely delivery of
  /// updates to the Uri.
  ///@param subscriptionId the subscriptionId to receive updates on
  ///@return the Uri used to observe ServiceState changes
  static uri_.Uri getUriForSubscriptionId(int subscriptionId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getUriForSubscriptionId,
          jni.JniType.objectType,
          [subscriptionId]).object);
}

/// from: android.provider.Telephony$MmsSms
///
/// Contains all MMS and SMS messages.
class Telephony_MmsSms extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$MmsSms");
  Telephony_MmsSms.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_CONVERSATIONS_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_CONVERSATIONS_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_CONVERSATIONS_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table, by conversation.
  static uri_.Uri get CONTENT_CONVERSATIONS_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_CONVERSATIONS_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_DRAFT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_DRAFT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_DRAFT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for draft messages in this table.
  static uri_.Uri get CONTENT_DRAFT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_DRAFT_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_FILTER_BYPHONE_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FILTER_BYPHONE_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FILTER_BYPHONE_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table, by phone number.
  static uri_.Uri get CONTENT_FILTER_BYPHONE_URI =>
      uri_.Uri.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTENT_FILTER_BYPHONE_URI, jni.JniType.objectType)
          .object);

  static final _id_CONTENT_LOCKED_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_LOCKED_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_LOCKED_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for locked messages in this table.
  static uri_.Uri get CONTENT_LOCKED_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_LOCKED_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_UNDELIVERED_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_UNDELIVERED_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_UNDELIVERED_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for undelivered messages in this table.
  static uri_.Uri get CONTENT_UNDELIVERED_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_UNDELIVERED_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final int ERR_TYPE_GENERIC
  ///
  /// Error type: generic transient error.
  static const ERR_TYPE_GENERIC = 1;

  /// from: static public final int ERR_TYPE_GENERIC_PERMANENT
  ///
  /// Error type: permanent error (along with all higher error values).
  static const ERR_TYPE_GENERIC_PERMANENT = 10;

  /// from: static public final int ERR_TYPE_MMS_PROTO_PERMANENT
  ///
  /// Error type: MMS protocol permanent error.
  static const ERR_TYPE_MMS_PROTO_PERMANENT = 12;

  /// from: static public final int ERR_TYPE_MMS_PROTO_TRANSIENT
  ///
  /// Error type: MMS protocol transient error.
  static const ERR_TYPE_MMS_PROTO_TRANSIENT = 3;

  /// from: static public final int ERR_TYPE_SMS_PROTO_PERMANENT
  ///
  /// Error type: SMS protocol permanent error.
  static const ERR_TYPE_SMS_PROTO_PERMANENT = 11;

  /// from: static public final int ERR_TYPE_SMS_PROTO_TRANSIENT
  ///
  /// Error type: SMS protocol transient error.
  static const ERR_TYPE_SMS_PROTO_TRANSIENT = 2;

  /// from: static public final int ERR_TYPE_TRANSPORT_FAILURE
  ///
  /// Error type: transport failure.
  static const ERR_TYPE_TRANSPORT_FAILURE = 4;

  /// from: static public final int MMS_PROTO
  ///
  /// MMS protocol type.
  static const MMS_PROTO = 1;

  /// from: static public final int NO_ERROR
  ///
  /// Error type: no error.
  static const NO_ERROR = 0;

  static final _id_SEARCH_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "SEARCH_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri SEARCH_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Pass in a query parameter called "pattern" which is the text to search for.
  /// The sort order is fixed to be: {@code thread_id ASC, date DESC}.
  static uri_.Uri get SEARCH_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_SEARCH_URI, jni.JniType.objectType)
      .object);

  /// from: static public final int SMS_PROTO
  ///
  /// SMS protocol type.
  static const SMS_PROTO = 0;

  /// from: static public final java.lang.String TYPE_DISCRIMINATOR_COLUMN
  ///
  /// The column to distinguish SMS and MMS messages in query results.
  static const TYPE_DISCRIMINATOR_COLUMN = "transport_type";
}

/// from: android.provider.Telephony$MmsSms$PendingMessages
///
/// Contains pending messages info.
class Telephony_MmsSms_PendingMessages extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/Telephony\$MmsSms\$PendingMessages");
  Telephony_MmsSms_PendingMessages.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DUE_TIME
  ///
  /// The time to do next retry.
  /// <P>Type: INTEGER (long)</P>
  static const DUE_TIME = "due_time";

  /// from: static public final java.lang.String ERROR_CODE
  ///
  /// The error code of sending/retrieving process.
  /// <P>Type: INTEGER</P>
  static const ERROR_CODE = "err_code";

  /// from: static public final java.lang.String ERROR_TYPE
  ///
  /// The type of the error code.
  /// <P>Type: INTEGER</P>
  static const ERROR_TYPE = "err_type";

  /// from: static public final java.lang.String LAST_TRY
  ///
  /// The time we last tried to send or download the message.
  /// <P>Type: INTEGER (long)</P>
  static const LAST_TRY = "last_try";

  /// from: static public final java.lang.String MSG_ID
  ///
  /// The ID of the message to be sent or downloaded.
  /// <P>Type: INTEGER (long)</P>
  static const MSG_ID = "msg_id";

  /// from: static public final java.lang.String MSG_TYPE
  ///
  /// The type of the message to be sent or downloaded.
  /// This field is only valid for MM. For SM, its value is always set to 0.
  /// <P>Type: INTEGER</P>
  static const MSG_TYPE = "msg_type";

  /// from: static public final java.lang.String PROTO_TYPE
  ///
  /// The type of transport protocol (MMS or SMS).
  /// <P>Type: INTEGER</P>
  static const PROTO_TYPE = "proto_type";

  /// from: static public final java.lang.String RETRY_INDEX
  ///
  /// How many times we tried to send or download the message.
  /// <P>Type: INTEGER</P>
  static const RETRY_INDEX = "retry_index";

  /// from: static public final java.lang.String SUBSCRIPTION_ID
  ///
  /// The subscription to which the message belongs to. Its value will be
  /// < 0 if the sub id cannot be determined.
  /// Type: INTEGER (long)
  ///
  static const SUBSCRIPTION_ID = "pending_sub_id";
}

/// from: android.provider.Telephony$Mms
///
/// Contains all MMS messages.
class Telephony_Mms extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms");
  Telephony_Mms.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} URI for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";

  static final _id_REPORT_REQUEST_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "REPORT_REQUEST_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri REPORT_REQUEST_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Content URI for getting MMS report requests.
  static uri_.Uri get REPORT_REQUEST_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_REPORT_REQUEST_URI, jni.JniType.objectType)
      .object);

  static final _id_REPORT_STATUS_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "REPORT_STATUS_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri REPORT_STATUS_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Content URI for getting MMS report status.
  static uri_.Uri get REPORT_STATUS_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_REPORT_STATUS_URI, jni.JniType.objectType)
      .object);
}

/// from: android.provider.Telephony$Mms$Sent
///
/// Contains all MMS messages in the MMS app sent folder.
class Telephony_Mms_Sent extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms\$Sent");
  Telephony_Mms_Sent.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";
}

/// from: android.provider.Telephony$Mms$Rate
///
/// Message send rate table.
class Telephony_Mms_Rate extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms\$Rate");
  Telephony_Mms_Rate.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String SENT_TIME
  ///
  /// When a message was successfully sent.
  /// <P>Type: INTEGER (long)</P>
  static const SENT_TIME = "sent_time";
}

/// from: android.provider.Telephony$Mms$Part
///
/// Contains message parts.
class Telephony_Mms_Part extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms\$Part");
  Telephony_Mms_Part.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CHARSET
  ///
  /// The charset of the part.
  /// <P>Type: TEXT</P>
  static const CHARSET = "chset";

  /// from: static public final java.lang.String CONTENT_DISPOSITION
  ///
  /// The content disposition of the part.
  /// <P>Type: TEXT</P>
  static const CONTENT_DISPOSITION = "cd";

  /// from: static public final java.lang.String CONTENT_ID
  ///
  /// The content ID of the part.
  /// <P>Type: INTEGER</P>
  static const CONTENT_ID = "cid";

  /// from: static public final java.lang.String CONTENT_LOCATION
  ///
  /// The content location of the part.
  /// <P>Type: INTEGER</P>
  static const CONTENT_LOCATION = "cl";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The content type of the part.
  /// <P>Type: TEXT</P>
  static const CONTENT_TYPE = "ct";

  /// from: static public final java.lang.String CT_START
  ///
  /// The start of content-type of the message.
  /// <P>Type: INTEGER</P>
  static const CT_START = "ctt_s";

  /// from: static public final java.lang.String CT_TYPE
  ///
  /// The type of content-type of the message.
  /// <P>Type: TEXT</P>
  static const CT_TYPE = "ctt_t";

  /// from: static public final java.lang.String FILENAME
  ///
  /// The file name of the part.
  /// <P>Type: TEXT</P>
  static const FILENAME = "fn";

  /// from: static public final java.lang.String MSG_ID
  ///
  /// The identifier of the message which this part belongs to.
  /// <P>Type: INTEGER</P>
  static const MSG_ID = "mid";

  /// from: static public final java.lang.String NAME
  ///
  /// The name of the part.
  /// <P>Type: TEXT</P>
  static const NAME = "name";

  /// from: static public final java.lang.String SEQ
  ///
  /// The order of the part.
  /// <P>Type: INTEGER</P>
  static const SEQ = "seq";

  /// from: static public final java.lang.String TEXT
  ///
  /// The message text.
  /// <P>Type: TEXT</P>
  static const TEXT = "text";
}

/// from: android.provider.Telephony$Mms$Outbox
///
/// Contains all MMS messages in the MMS app outbox.
class Telephony_Mms_Outbox extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms\$Outbox");
  Telephony_Mms_Outbox.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";
}

/// from: android.provider.Telephony$Mms$Intents
///
/// Intents class.
class Telephony_Mms_Intents extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms\$Intents");
  Telephony_Mms_Intents.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_CHANGED_ACTION
  ///
  /// Indicates that the contents of specified URIs were changed.
  /// The application which is showing or caching these contents
  /// should be updated.
  static const CONTENT_CHANGED_ACTION = "android.intent.action.CONTENT_CHANGED";

  /// from: static public final java.lang.String DELETED_CONTENTS
  ///
  /// An extra field which stores the URI of deleted contents.
  static const DELETED_CONTENTS = "deleted_contents";
}

/// from: android.provider.Telephony$Mms$Inbox
///
/// Contains all MMS messages in the MMS app inbox.
class Telephony_Mms_Inbox extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms\$Inbox");
  Telephony_Mms_Inbox.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";
}

/// from: android.provider.Telephony$Mms$Draft
///
/// Contains all MMS messages in the MMS app drafts folder.
class Telephony_Mms_Draft extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms\$Draft");
  Telephony_Mms_Draft.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "date DESC";
}

/// from: android.provider.Telephony$Mms$Addr
///
/// Contains address information for an MMS message.
class Telephony_Mms_Addr extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Mms\$Addr");
  Telephony_Mms_Addr.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ADDRESS
  ///
  /// The address text.
  /// <P>Type: TEXT</P>
  static const ADDRESS = "address";

  /// from: static public final java.lang.String CHARSET
  ///
  /// Character set of this entry (MMS charset value).
  /// <P>Type: INTEGER</P>
  static const CHARSET = "charset";

  /// from: static public final java.lang.String CONTACT_ID
  ///
  /// The ID of contact entry in Phone Book.
  /// <P>Type: INTEGER (long)</P>
  static const CONTACT_ID = "contact_id";

  /// from: static public final java.lang.String MSG_ID
  ///
  /// The ID of MM which this address entry belongs to.
  /// <P>Type: INTEGER (long)</P>
  static const MSG_ID = "msg_id";

  /// from: static public final java.lang.String TYPE
  ///
  /// Type of address: must be one of {@code PduHeaders.BCC},
  /// {@code PduHeaders.CC}, {@code PduHeaders.FROM}, {@code PduHeaders.TO}.
  /// <P>Type: INTEGER</P>
  static const TYPE = "type";
}

/// from: android.provider.Telephony$Carriers
///
/// Carriers class contains information about APNs, including MMSC information.
class Telephony_Carriers extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$Carriers");
  Telephony_Carriers.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String APN
  ///
  /// APN name.
  /// <P>Type: TEXT</P>
  static const APN = "apn";

  /// from: static public final java.lang.String AUTH_TYPE
  ///
  /// Authentication type.
  /// <P>Type:  INTEGER</P>
  static const AUTH_TYPE = "authtype";

  /// from: static public final java.lang.String BEARER
  ///
  /// Radio Access Technology info.
  /// To check what values are allowed, refer to android.telephony.ServiceState.
  /// This should be spread to other technologies,
  /// but is currently only used for LTE (14) and eHRPD (13).
  /// <P>Type: INTEGER</P>
  ///@deprecated this column is no longer supported, use \#NETWORK_TYPE_BITMASK instead
  static const BEARER = "bearer";

  /// from: static public final java.lang.String CARRIER_ENABLED
  ///
  /// Is this APN enabled?
  /// <P>Type: INTEGER (boolean)</P>
  static const CARRIER_ENABLED = "carrier_enabled";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URL for this table.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CURRENT
  ///
  /// Is this the current APN?
  /// <P>Type: INTEGER (boolean)</P>
  static const CURRENT = "current";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "name ASC";

  /// from: static public final java.lang.String MCC
  ///
  /// Mobile Country Code (MCC).
  /// <P>Type: TEXT</P>
  static const MCC = "mcc";

  /// from: static public final java.lang.String MMSC
  ///
  /// MMSC URL.
  /// <P>Type: TEXT</P>
  static const MMSC = "mmsc";

  /// from: static public final java.lang.String MMSPORT
  ///
  /// MMS proxy port.
  /// <P>Type: TEXT</P>
  static const MMSPORT = "mmsport";

  /// from: static public final java.lang.String MMSPROXY
  ///
  /// MMS proxy address.
  /// <P>Type: TEXT</P>
  static const MMSPROXY = "mmsproxy";

  /// from: static public final java.lang.String MNC
  ///
  /// Mobile Network Code (MNC).
  /// <P>Type: TEXT</P>
  static const MNC = "mnc";

  /// from: static public final java.lang.String MVNO_MATCH_DATA
  ///
  /// MVNO data.
  /// Use the following examples.
  /// <ul>
  ///     <li>SPN: A MOBILE, BEN NL, ...</li>
  ///     <li>IMSI: 302720x94, 2060188, ...</li>
  ///     <li>GID: 4E, 33, ...</li>
  /// </ul>
  /// <P>Type: TEXT</P>
  static const MVNO_MATCH_DATA = "mvno_match_data";

  /// from: static public final java.lang.String MVNO_TYPE
  ///
  /// MVNO type:
  /// {@code SPN (Service Provider Name), IMSI, GID (Group Identifier Level 1)}.
  /// <P>Type: TEXT</P>
  static const MVNO_TYPE = "mvno_type";

  /// from: static public final java.lang.String NAME
  ///
  /// Entry name.
  /// <P>Type: TEXT</P>
  static const NAME = "name";

  /// from: static public final java.lang.String NETWORK_TYPE_BITMASK
  ///
  /// Radio technology (network type) bitmask.
  /// To check what values can be contained, refer to the NETWORK_TYPE_ constants in
  /// android.telephony.TelephonyManager.
  /// Bitmask for a radio tech R is (1 << (R - 1))
  /// <P>Type: INTEGER</P>
  static const NETWORK_TYPE_BITMASK = "network_type_bitmask";

  /// from: static public final java.lang.String NUMERIC
  ///
  /// Numeric operator ID (as String). Usually {@code MCC + MNC}.
  /// <P>Type: TEXT</P>
  static const NUMERIC = "numeric";

  /// from: static public final java.lang.String PASSWORD
  ///
  /// APN password.
  /// <P>Type: TEXT</P>
  static const PASSWORD = "password";

  /// from: static public final java.lang.String PORT
  ///
  /// Proxy port.
  /// <P>Type: TEXT</P>
  static const PORT = "port";

  /// from: static public final java.lang.String PROTOCOL
  ///
  /// The protocol to use to connect to this APN.
  ///
  /// One of the {@code PDP_type} values in TS 27.007 section 10.1.1.
  /// For example: {@code IP}, {@code IPV6}, {@code IPV4V6}, or {@code PPP}.
  /// <P>Type: TEXT</P>
  static const PROTOCOL = "protocol";

  /// from: static public final java.lang.String PROXY
  ///
  /// Proxy address.
  /// <P>Type: TEXT</P>
  static const PROXY = "proxy";

  /// from: static public final java.lang.String ROAMING_PROTOCOL
  ///
  /// The protocol to use to connect to this APN when roaming.
  /// The syntax is the same as protocol.
  /// <P>Type: TEXT</P>
  static const ROAMING_PROTOCOL = "roaming_protocol";

  /// from: static public final java.lang.String SERVER
  ///
  /// Server address.
  /// <P>Type: TEXT</P>
  static const SERVER = "server";

  /// from: static public final java.lang.String SUBSCRIPTION_ID
  ///
  /// The subscription to which the APN belongs to
  /// Type: INTEGER (long)
  ///
  static const SUBSCRIPTION_ID = "sub_id";

  /// from: static public final java.lang.String TYPE
  ///
  /// Comma-delimited list of APN types.
  /// <P>Type: TEXT</P>
  static const TYPE = "type";

  /// from: static public final java.lang.String USER
  ///
  /// APN username.
  /// <P>Type: TEXT</P>
  static const USER = "user";
}

/// from: android.provider.Telephony$CarrierId
///
/// Contains carrier identification information for the current subscriptions.
///@see SubscriptionManager\#getActiveSubscriptionIdList()
class Telephony_CarrierId extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$CarrierId");
  Telephony_CarrierId.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CARRIER_ID
  ///
  /// A unique carrier id
  ///@see TelephonyManager\#getSimCarrierId() <P>Type: INTEGER </P>
  static const CARRIER_ID = "carrier_id";

  /// from: static public final java.lang.String CARRIER_NAME
  ///
  /// A user facing carrier name.
  ///@see TelephonyManager\#getSimCarrierIdName() <P>Type: TEXT </P>
  static const CARRIER_NAME = "carrier_name";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The {@code content://} style URI for this provider.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_getUriForSubscriptionId = jniAccessors.getStaticMethodIDOf(
      _classRef, "getUriForSubscriptionId", "(I)Landroid/net/Uri;");

  /// from: static public android.net.Uri getUriForSubscriptionId(int subscriptionId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generates a content Uri used to receive updates on carrier identity change
  /// on the given subscriptionId
  ///
  /// Use this Uri with a ContentObserver to be notified of changes to the
  /// carrier identity TelephonyManager\#getSimCarrierId()
  /// while your app is running. You can also use a JobService to ensure your app
  /// is notified of changes to the Uri even when it is not running.
  /// Note, however, that using a JobService does not guarantee timely delivery of
  /// updates to the Uri.
  ///@param subscriptionId the subscriptionId to receive updates on
  ///@return the Uri used to observe carrier identity changes
  static uri_.Uri getUriForSubscriptionId(int subscriptionId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getUriForSubscriptionId,
          jni.JniType.objectType,
          [subscriptionId]).object);
}

/// from: android.provider.Telephony$CanonicalAddressesColumns
///
/// Columns for the "canonical_addresses" table used by MMS and SMS.
class Telephony_CanonicalAddressesColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/Telephony\$CanonicalAddressesColumns");
  Telephony_CanonicalAddressesColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String ADDRESS
  ///
  /// An address used in MMS or SMS.  Email addresses are
  /// converted to lower case and are compared by string
  /// equality.  Other addresses are compared using
  /// PHONE_NUMBERS_EQUAL.
  /// <P>Type: TEXT</P>
  static const ADDRESS = "address";
}

/// from: android.provider.Telephony$BaseMmsColumns
///
/// Base columns for tables that contain MMSs.
class Telephony_BaseMmsColumns extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/Telephony\$BaseMmsColumns");
  Telephony_BaseMmsColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_CLASS
  ///
  /// The {@code content-class} of the message.
  /// <P>Type: INTEGER</P>
  static const CONTENT_CLASS = "ct_cls";

  /// from: static public final java.lang.String CONTENT_LOCATION
  ///
  /// The {@code Content-Location} of the message.
  /// <P>Type: TEXT</P>
  static const CONTENT_LOCATION = "ct_l";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The {@code Content-Type} of the message.
  /// <P>Type: TEXT</P>
  static const CONTENT_TYPE = "ct_t";

  /// from: static public final java.lang.String CREATOR
  ///
  /// The identity of the sender of a sent message. It is
  /// usually the package name of the app which sends the message.
  /// <p class="note"><strong>Note:</strong>
  /// This column is read-only. It is set by the provider and can not be changed by apps.
  /// Type: TEXT
  ///
  static const CREATOR = "creator";

  /// from: static public final java.lang.String DATE
  ///
  /// The date the message was received.
  /// <P>Type: INTEGER (long)</P>
  static const DATE = "date";

  /// from: static public final java.lang.String DATE_SENT
  ///
  /// The date the message was sent.
  /// <P>Type: INTEGER (long)</P>
  static const DATE_SENT = "date_sent";

  /// from: static public final java.lang.String DELIVERY_REPORT
  ///
  /// The {@code delivery-report} of the message.
  /// <P>Type: INTEGER</P>
  static const DELIVERY_REPORT = "d_rpt";

  /// from: static public final java.lang.String DELIVERY_TIME
  ///
  /// The {@code delivery-time} of the message.
  /// <P>Type: INTEGER</P>
  static const DELIVERY_TIME = "d_tm";

  /// from: static public final java.lang.String EXPIRY
  ///
  /// The expiry time of the message.
  /// <P>Type: INTEGER (long)</P>
  static const EXPIRY = "exp";

  /// from: static public final java.lang.String LOCKED
  ///
  /// Is the message locked?
  /// <P>Type: INTEGER (boolean)</P>
  static const LOCKED = "locked";

  /// from: static public final java.lang.String MESSAGE_BOX
  ///
  /// The box which the message belongs to, e.g.&nbsp;\#MESSAGE_BOX_INBOX.
  /// <P>Type: INTEGER</P>
  static const MESSAGE_BOX = "msg_box";

  /// from: static public final int MESSAGE_BOX_ALL
  ///
  /// Message box: all messages.
  static const MESSAGE_BOX_ALL = 0;

  /// from: static public final int MESSAGE_BOX_DRAFTS
  ///
  /// Message box: drafts.
  static const MESSAGE_BOX_DRAFTS = 3;

  /// from: static public final int MESSAGE_BOX_FAILED
  ///
  /// Message box: failed.
  static const MESSAGE_BOX_FAILED = 5;

  /// from: static public final int MESSAGE_BOX_INBOX
  ///
  /// Message box: inbox.
  static const MESSAGE_BOX_INBOX = 1;

  /// from: static public final int MESSAGE_BOX_OUTBOX
  ///
  /// Message box: outbox.
  static const MESSAGE_BOX_OUTBOX = 4;

  /// from: static public final int MESSAGE_BOX_SENT
  ///
  /// Message box: sent messages.
  static const MESSAGE_BOX_SENT = 2;

  /// from: static public final java.lang.String MESSAGE_CLASS
  ///
  /// The class of the message.
  /// <P>Type: TEXT</P>
  static const MESSAGE_CLASS = "m_cls";

  /// from: static public final java.lang.String MESSAGE_ID
  ///
  /// The {@code Message-ID} of the message.
  /// <P>Type: TEXT</P>
  static const MESSAGE_ID = "m_id";

  /// from: static public final java.lang.String MESSAGE_SIZE
  ///
  /// The size of the message.
  /// <P>Type: INTEGER</P>
  static const MESSAGE_SIZE = "m_size";

  /// from: static public final java.lang.String MESSAGE_TYPE
  ///
  /// The type of the message defined by MMS spec.
  /// <P>Type: INTEGER</P>
  static const MESSAGE_TYPE = "m_type";

  /// from: static public final java.lang.String MMS_VERSION
  ///
  /// The version of the specification that this message conforms to.
  /// <P>Type: INTEGER</P>
  static const MMS_VERSION = "v";

  /// from: static public final java.lang.String PRIORITY
  ///
  /// The priority of the message.
  /// <P>Type: INTEGER</P>
  static const PRIORITY = "pri";

  /// from: static public final java.lang.String READ
  ///
  /// Has the message been read?
  /// <P>Type: INTEGER (boolean)</P>
  static const READ = "read";

  /// from: static public final java.lang.String READ_REPORT
  ///
  /// The {@code read-report} of the message.
  /// <P>Type: INTEGER (boolean)</P>
  static const READ_REPORT = "rr";

  /// from: static public final java.lang.String READ_STATUS
  ///
  /// The {@code read-status} of the message.
  /// <P>Type: INTEGER</P>
  static const READ_STATUS = "read_status";

  /// from: static public final java.lang.String REPORT_ALLOWED
  ///
  /// Is read report allowed?
  /// <P>Type: INTEGER (boolean)</P>
  static const REPORT_ALLOWED = "rpt_a";

  /// from: static public final java.lang.String RESPONSE_STATUS
  ///
  /// The {@code response-status} of the message.
  /// <P>Type: INTEGER</P>
  static const RESPONSE_STATUS = "resp_st";

  /// from: static public final java.lang.String RESPONSE_TEXT
  ///
  /// The {@code response-text} of the message.
  /// <P>Type: TEXT</P>
  static const RESPONSE_TEXT = "resp_txt";

  /// from: static public final java.lang.String RETRIEVE_STATUS
  ///
  /// The {@code retrieve-status} of the message.
  /// <P>Type: INTEGER</P>
  static const RETRIEVE_STATUS = "retr_st";

  /// from: static public final java.lang.String RETRIEVE_TEXT
  ///
  /// The {@code retrieve-text} of the message.
  /// <P>Type: TEXT</P>
  static const RETRIEVE_TEXT = "retr_txt";

  /// from: static public final java.lang.String RETRIEVE_TEXT_CHARSET
  ///
  /// The character set of the retrieve-text.
  /// <P>Type: INTEGER</P>
  static const RETRIEVE_TEXT_CHARSET = "retr_txt_cs";

  /// from: static public final java.lang.String SEEN
  ///
  /// Has the message been seen by the user? The "seen" flag determines
  /// whether we need to show a new message notification.
  /// <P>Type: INTEGER (boolean)</P>
  static const SEEN = "seen";

  /// from: static public final java.lang.String STATUS
  ///
  /// The {@code status} of the message.
  /// <P>Type: INTEGER</P>
  static const STATUS = "st";

  /// from: static public final java.lang.String SUBJECT
  ///
  /// The subject of the message, if present.
  /// <P>Type: TEXT</P>
  static const SUBJECT = "sub";

  /// from: static public final java.lang.String SUBJECT_CHARSET
  ///
  /// The character set of the subject, if present.
  /// <P>Type: INTEGER</P>
  static const SUBJECT_CHARSET = "sub_cs";

  /// from: static public final java.lang.String SUBSCRIPTION_ID
  ///
  /// The subscription to which the message belongs to. Its value will be
  /// < 0 if the sub id cannot be determined.
  /// Type: INTEGER (long)
  ///
  static const SUBSCRIPTION_ID = "sub_id";

  /// from: static public final java.lang.String TEXT_ONLY
  ///
  /// Does the message have only a text part (can also have a subject) with
  /// no picture, slideshow, sound, etc. parts?
  /// <P>Type: INTEGER (boolean)</P>
  static const TEXT_ONLY = "text_only";

  /// from: static public final java.lang.String THREAD_ID
  ///
  /// The thread ID of the message.
  /// <P>Type: INTEGER (long)</P>
  static const THREAD_ID = "thread_id";

  /// from: static public final java.lang.String TRANSACTION_ID
  ///
  /// The {@code transaction-id} of the message.
  /// <P>Type: TEXT</P>
  static const TRANSACTION_ID = "tr_id";
}
