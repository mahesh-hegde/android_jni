// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../net/Uri.dart" as uri_;

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.BlockedNumberContract
///
///
/// The contract between the blockednumber provider and applications. Contains definitions for
/// the supported URIs and columns.
///
///
///
/// <h3> Overview </h3>
///
/// The content provider exposes a table containing blocked numbers. The columns and URIs for
/// accessing this table are defined by the BlockedNumbers class. Messages, and calls from
/// blocked numbers are discarded by the platform. Notifications upon provider changes can be
/// received using a android.database.ContentObserver.
///
///
///
/// The platform will not block messages, and calls from emergency numbers as defined by
/// android.telephony.PhoneNumberUtils\#isEmergencyNumber(String). If the user contacts
/// emergency services, number blocking is disabled by the platform for a duration defined by
/// android.telephony.CarrierConfigManager\#KEY_DURATION_BLOCKING_DISABLED_AFTER_EMERGENCY_INT.
///
///
///
/// <h3> Permissions </h3>
///
/// Only the system, the default SMS application, and the default phone app
/// (See android.telecom.TelecomManager\#getDefaultDialerPackage()), and carrier apps
/// (See android.service.carrier.CarrierService) can read, and write to the blockednumber
/// provider. However, \#canCurrentUserBlockNumbers(Context) can be accessed by any
/// application.
///
///
///
/// <h3> Data </h3>
///
/// Other than regular phone numbers, the blocked number provider can also store addresses (such
/// as email) from which a user can receive messages, and calls. The blocked numbers are stored
/// in the BlockedNumbers\#COLUMN_ORIGINAL_NUMBER column. A normalized version of phone
/// numbers (if normalization is possible) is stored in BlockedNumbers\#COLUMN_E164_NUMBER
/// column. The platform blocks calls, and messages from an address if it is present in in the
/// BlockedNumbers\#COLUMN_ORIGINAL_NUMBER column or if the E164 version of the address
/// matches the BlockedNumbers\#COLUMN_E164_NUMBER column.
///
///
///
/// <h3> Operations </h3>
/// <dl>
/// <dt>__Insert__</dt>
/// <dd>
///
/// BlockedNumbers\#COLUMN_ORIGINAL_NUMBER is a required column that needs to be populated.
/// Apps can optionally provide the BlockedNumbers\#COLUMN_E164_NUMBER which is the phone
/// number's E164 representation. The provider automatically populates this column if the app does
/// not provide it. Note that this column is not populated if normalization fails or if the address
/// is not a phone number (eg: email).
///
/// Attempting to insert an existing blocked number (same
/// BlockedNumbers\#COLUMN_ORIGINAL_NUMBER column) will result in replacing the existing
/// blocked number.
///
/// Examples:
/// <pre>
/// ContentValues values = new ContentValues();
/// values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER, "1234567890");
/// Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI, values);
/// </pre>
/// <pre>
/// ContentValues values = new ContentValues();
/// values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER, "1234567890");
/// values.put(BlockedNumbers.COLUMN_E164_NUMBER, "+11234567890");
/// Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI, values);
/// </pre>
/// <pre>
/// ContentValues values = new ContentValues();
/// values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER, "12345@abdcde.com");
/// Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI, values);
/// </pre>
///
///
/// </dd>
/// <dt>__Update__</dt>
/// <dd>
///
/// Updates are not supported. Use Delete, and Insert instead.
///
///
/// </dd>
/// <dt>__Delete__</dt>
/// <dd>
///
/// Deletions can be performed as follows:
/// <pre>
/// ContentValues values = new ContentValues();
/// values.put(BlockedNumbers.COLUMN_ORIGINAL_NUMBER, "1234567890");
/// Uri uri = getContentResolver().insert(BlockedNumbers.CONTENT_URI, values);
/// getContentResolver().delete(uri, null, null);
/// </pre>
/// To check if a particular number is blocked, use the method
/// \#isBlocked(Context, String).
///
///
/// </dd>
/// <dt>__Query__</dt>
/// <dd>
///
/// All blocked numbers can be enumerated as follows:
/// <pre>
/// Cursor c = getContentResolver().query(BlockedNumbers.CONTENT_URI,
///          new String[]{BlockedNumbers.COLUMN_ID, BlockedNumbers.COLUMN_ORIGINAL_NUMBER,
///          BlockedNumbers.COLUMN_E164_NUMBER}, null, null, null);
/// </pre>
///
///
/// </dd>
/// <dt>__Unblock__</dt>
/// <dd>
///
/// Use the method \#unblock(Context, String) to unblock numbers.
///
///
/// </dd>
///
/// <h3> Multi-user </h3>
///
/// Apps must use the method \#canCurrentUserBlockNumbers(Context) before performing any
/// operation on the blocked number provider. If \#canCurrentUserBlockNumbers(Context) returns
/// {@code false}, all operations on the provider will fail with a SecurityException. The
/// platform will block calls, and messages from numbers in the provider independent of the current
/// user.
///
///
class BlockedNumberContract extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/BlockedNumberContract");
  BlockedNumberContract.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String AUTHORITY
  ///
  /// The authority for the blocked number provider
  static const AUTHORITY = "com.android.blockednumber";

  static final _id_AUTHORITY_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "AUTHORITY_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri AUTHORITY_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A content:// style uri to the authority for the blocked number provider
  static uri_.Uri get AUTHORITY_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_AUTHORITY_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BlockedNumberContract()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_isBlocked = jniAccessors.getStaticMethodIDOf(
      _classRef, "isBlocked", "(Landroid/content/Context;Ljava/lang/String;)Z");

  /// from: static public boolean isBlocked(android.content.Context context, java.lang.String phoneNumber)
  ///
  /// Returns whether a given number is in the blocked list.
  ///
  ///  This matches the {@code phoneNumber} against the
  /// BlockedNumbers\#COLUMN_ORIGINAL_NUMBER column, and the E164 representation of the
  /// {@code phoneNumber} with the BlockedNumbers\#COLUMN_E164_NUMBER column.
  ///
  ///  Note that if the \#canCurrentUserBlockNumbers is {@code false} for the user
  /// context {@code context}, this method will throw a SecurityException.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@return {@code true} if the {@code phoneNumber} is blocked.
  static bool isBlocked(context_.Context context, jni.JniString phoneNumber) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isBlocked,
          jni.JniType.booleanType,
          [context.reference, phoneNumber.reference]).boolean;

  static final _id_unblock = jniAccessors.getStaticMethodIDOf(
      _classRef, "unblock", "(Landroid/content/Context;Ljava/lang/String;)I");

  /// from: static public int unblock(android.content.Context context, java.lang.String phoneNumber)
  ///
  /// Unblocks the {@code phoneNumber} if it is blocked.
  ///
  ///  This deletes all rows where the {@code phoneNumber} matches the
  /// BlockedNumbers\#COLUMN_ORIGINAL_NUMBER column or the E164 representation of the
  /// {@code phoneNumber} matches the BlockedNumbers\#COLUMN_E164_NUMBER column.
  ///
  /// To delete rows based on exact match with specific columns such as
  /// BlockedNumbers\#COLUMN_ID use
  /// android.content.ContentProvider\#delete(Uri, String, String[]) with
  /// BlockedNumbers\#CONTENT_URI URI.
  ///
  ///  Note that if the \#canCurrentUserBlockNumbers is {@code false} for the user
  /// context {@code context}, this method will throw a SecurityException.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@return the number of rows deleted in the blocked number provider as a result of unblock.
  static int unblock(context_.Context context, jni.JniString phoneNumber) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_unblock,
          jni.JniType.intType,
          [context.reference, phoneNumber.reference]).integer;

  static final _id_canCurrentUserBlockNumbers =
      jniAccessors.getStaticMethodIDOf(_classRef, "canCurrentUserBlockNumbers",
          "(Landroid/content/Context;)Z");

  /// from: static public boolean canCurrentUserBlockNumbers(android.content.Context context)
  ///
  /// Checks if blocking numbers is supported for the current user.
  ///  Typically, blocking numbers is only supported for one user at a time.
  ///@return {@code true} if the current user can block numbers.
  static bool canCurrentUserBlockNumbers(context_.Context context) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_canCurrentUserBlockNumbers,
          jni.JniType.booleanType,
          [context.reference]).boolean;
}

/// from: android.provider.BlockedNumberContract$BlockedNumbers
///
/// Constants to interact with the blocked numbers list.
class BlockedNumberContract_BlockedNumbers extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/BlockedNumberContract\$BlockedNumbers");
  BlockedNumberContract_BlockedNumbers.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String COLUMN_E164_NUMBER
  ///
  /// Phone number to block.  The system generates it from \#COLUMN_ORIGINAL_NUMBER
  /// by removing all formatting characters.
  /// Optional in {@code insert}.  When not specified, the system tries to generate it
  /// assuming the current country. (Which will still be null if the number is not valid.)
  /// TYPE: String
  ///
  static const COLUMN_E164_NUMBER = "e164_number";

  /// from: static public final java.lang.String COLUMN_ID
  ///
  /// Auto-generated ID field which monotonically increases.
  /// TYPE: long
  ///
  static const COLUMN_ID = "_id";

  /// from: static public final java.lang.String COLUMN_ORIGINAL_NUMBER
  ///
  /// Phone number to block.
  /// Must be specified in {@code insert}.
  /// TYPE: String
  ///
  static const COLUMN_ORIGINAL_NUMBER = "original_number";

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME type of a blocked phone number under \#CONTENT_URI.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/blocked_number";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI itself providing a directory of blocked phone
  /// numbers.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/blocked_number";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Content URI for the blocked numbers.
  /// <h3> Supported operations </h3>
  ///  blocked
  /// <ul>
  /// <li> query
  /// <li> delete
  /// <li> insert
  /// </ul>
  ///  blocked/ID
  /// <ul>
  /// <li> query (selection is not supported)
  /// <li> delete (selection is not supported)
  /// </ul>
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BlockedNumberContract_BlockedNumbers()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
