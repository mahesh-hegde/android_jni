// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../net/Uri.dart" as uri_;

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.CallLog
///
/// The CallLog provider contains information about placed and received calls.
class CallLog extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/provider/CallLog");
  CallLog.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String AUTHORITY
  static const AUTHORITY = "call_log";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for this provider
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CallLog()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.CallLog$Calls
///
/// Contains the recent calls.
class CallLog_Calls extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CallLog\$Calls");
  CallLog_Calls.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ANSWERED_EXTERNALLY_TYPE
  ///
  /// Call log type for a call which was answered on another device.  Used in situations where
  /// a call rings on multiple devices simultaneously and it ended up being answered on a
  /// device other than the current one.
  static const ANSWERED_EXTERNALLY_TYPE = 7;

  /// from: static public final int BLOCKED_TYPE
  ///
  /// Call log type for calls blocked automatically.
  static const BLOCKED_TYPE = 6;

  /// from: static public final java.lang.String CACHED_FORMATTED_NUMBER
  ///
  /// The cached phone number, formatted with formatting rules based on the country the
  /// user was in when the call was made or received.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: TEXT</P>
  static const CACHED_FORMATTED_NUMBER = "formatted_number";

  /// from: static public final java.lang.String CACHED_LOOKUP_URI
  ///
  /// The cached URI to look up the contact associated with the phone number, if it exists.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: TEXT</P>
  static const CACHED_LOOKUP_URI = "lookup_uri";

  /// from: static public final java.lang.String CACHED_MATCHED_NUMBER
  ///
  /// The cached phone number of the contact which matches this entry, if it exists.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: TEXT</P>
  static const CACHED_MATCHED_NUMBER = "matched_number";

  /// from: static public final java.lang.String CACHED_NAME
  ///
  /// The cached name associated with the phone number, if it exists.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: TEXT</P>
  static const CACHED_NAME = "name";

  /// from: static public final java.lang.String CACHED_NORMALIZED_NUMBER
  ///
  /// The cached normalized(E164) version of the phone number, if it exists.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: TEXT</P>
  static const CACHED_NORMALIZED_NUMBER = "normalized_number";

  /// from: static public final java.lang.String CACHED_NUMBER_LABEL
  ///
  /// The cached number label, for a custom number type, associated with the
  /// phone number, if it exists.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: TEXT</P>
  static const CACHED_NUMBER_LABEL = "numberlabel";

  /// from: static public final java.lang.String CACHED_NUMBER_TYPE
  ///
  /// The cached number type (Home, Work, etc) associated with the
  /// phone number, if it exists.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: INTEGER</P>
  static const CACHED_NUMBER_TYPE = "numbertype";

  /// from: static public final java.lang.String CACHED_PHOTO_ID
  ///
  /// The cached photo id of the picture associated with the phone number, if it exists.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: INTEGER (long)</P>
  static const CACHED_PHOTO_ID = "photo_id";

  /// from: static public final java.lang.String CACHED_PHOTO_URI
  ///
  /// The cached photo URI of the picture associated with the phone number, if it exists.
  ///
  /// This value is typically filled in by the dialer app for the caching purpose,
  /// so it's not guaranteed to be present, and may not be current if the contact
  /// information associated with this number has changed.
  /// <P>Type: TEXT (URI)</P>
  static const CACHED_PHOTO_URI = "photo_uri";

  static final _id_CONTENT_FILTER_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for filtering this table on phone numbers
  static uri_.Uri get CONTENT_FILTER_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_FILTER_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME type of a \#CONTENT_URI sub-directory of a single
  /// call.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/calls";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI and \#CONTENT_FILTER_URI
  /// providing a directory of calls.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/calls";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_URI_WITH_VOICEMAIL = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI_WITH_VOICEMAIL", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI_WITH_VOICEMAIL
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Content uri used to access call log entries, including voicemail records. You must have
  /// the READ_CALL_LOG and WRITE_CALL_LOG permissions to read and write to the call log, as
  /// well as READ_VOICEMAIL and WRITE_VOICEMAIL permissions to read and write voicemails.
  static uri_.Uri get CONTENT_URI_WITH_VOICEMAIL =>
      uri_.Uri.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTENT_URI_WITH_VOICEMAIL, jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String COUNTRY_ISO
  ///
  /// The ISO 3166-1 two letters country code of the country where the
  /// user received or made the call.
  /// <P>
  /// Type: TEXT
  /// </P>
  static const COUNTRY_ISO = "countryiso";

  /// from: static public final java.lang.String DATA_USAGE
  ///
  /// The data usage of the call in bytes.
  /// <P>Type: INTEGER (long)</P>
  static const DATA_USAGE = "data_usage";

  /// from: static public final java.lang.String DATE
  ///
  /// The date the call occured, in milliseconds since the epoch
  /// <P>Type: INTEGER (long)</P>
  static const DATE = "date";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "date DESC";

  /// from: static public final java.lang.String DURATION
  ///
  /// The duration of the call in seconds
  /// <P>Type: INTEGER (long)</P>
  static const DURATION = "duration";

  /// from: static public final java.lang.String EXTRA_CALL_TYPE_FILTER
  ///
  /// An optional extra used with \#CONTENT_TYPE Calls.CONTENT_TYPE and
  /// Intent\#ACTION_VIEW to specify that the presented list of calls should be
  /// filtered for a particular call type.
  ///
  /// Applications implementing a call log UI should check for this extra, and display a
  /// filtered list of calls based on the specified call type. If not applicable within the
  /// application's UI, it should be silently ignored.
  ///
  ///
  /// The following example brings up the call log, showing only missed calls.
  /// <pre>
  /// Intent intent = new Intent(Intent.ACTION_VIEW);
  /// intent.setType(CallLog.Calls.CONTENT_TYPE);
  /// intent.putExtra(CallLog.Calls.EXTRA_CALL_TYPE_FILTER, CallLog.Calls.MISSED_TYPE);
  /// startActivity(intent);
  /// </pre>
  ///
  ///
  static const EXTRA_CALL_TYPE_FILTER =
      "android.provider.extra.CALL_TYPE_FILTER";

  /// from: static public final java.lang.String FEATURES
  ///
  /// Bit-mask describing features of the call (e.g.&nbsp;video).
  ///
  /// <P>Type: INTEGER (int)</P>
  static const FEATURES = "features";

  /// from: static public final int FEATURES_HD_CALL
  ///
  /// Call was HD.
  static const FEATURES_HD_CALL = 4;

  /// from: static public final int FEATURES_PULLED_EXTERNALLY
  ///
  /// Call was pulled externally.
  static const FEATURES_PULLED_EXTERNALLY = 2;

  /// from: static public final int FEATURES_RTT
  ///
  /// Call was on RTT at some point
  static const FEATURES_RTT = 32;

  /// from: static public final int FEATURES_VIDEO
  ///
  /// Call had video.
  static const FEATURES_VIDEO = 1;

  /// from: static public final int FEATURES_WIFI
  ///
  /// Call was WIFI call.
  static const FEATURES_WIFI = 8;

  /// from: static public final java.lang.String GEOCODED_LOCATION
  ///
  /// A geocoded location for the number associated with this call.
  ///
  /// The string represents a city, state, or country associated with the number.
  /// <P>Type: TEXT</P>
  static const GEOCODED_LOCATION = "geocoded_location";

  /// from: static public final int INCOMING_TYPE
  ///
  /// Call log type for incoming calls.
  static const INCOMING_TYPE = 1;

  /// from: static public final java.lang.String IS_READ
  ///
  /// Whether this item has been read or otherwise consumed by the user.
  ///
  /// Unlike the \#NEW field, which requires the user to have acknowledged the
  /// existence of the entry, this implies the user has interacted with the entry.
  /// <P>Type: INTEGER (boolean)</P>
  static const IS_READ = "is_read";

  /// from: static public final java.lang.String LAST_MODIFIED
  ///
  /// The date the row is last inserted, updated, or marked as deleted, in milliseconds
  /// since the epoch. Read only.
  /// <P>Type: INTEGER (long)</P>
  static const LAST_MODIFIED = "last_modified";

  /// from: static public final java.lang.String LIMIT_PARAM_KEY
  ///
  /// Query parameter used to limit the number of call logs returned.
  ///
  /// TYPE: integer
  static const LIMIT_PARAM_KEY = "limit";

  /// from: static public final int MISSED_TYPE
  ///
  /// Call log type for missed calls.
  static const MISSED_TYPE = 3;

  /// from: static public final java.lang.String NEW
  ///
  /// Whether or not the call has been acknowledged
  /// <P>Type: INTEGER (boolean)</P>
  static const NEW = "new";

  /// from: static public final java.lang.String NUMBER
  ///
  /// The phone number as the user entered it.
  /// <P>Type: TEXT</P>
  static const NUMBER = "number";

  /// from: static public final java.lang.String NUMBER_PRESENTATION
  ///
  /// The number presenting rules set by the network.
  ///
  ///
  /// Allowed values:
  /// <ul>
  /// <li>\#PRESENTATION_ALLOWED</li>
  /// <li>\#PRESENTATION_RESTRICTED</li>
  /// <li>\#PRESENTATION_UNKNOWN</li>
  /// <li>\#PRESENTATION_PAYPHONE</li>
  /// </ul>
  ///
  ///
  ///
  /// <P>Type: INTEGER</P>
  static const NUMBER_PRESENTATION = "presentation";

  /// from: static public final java.lang.String OFFSET_PARAM_KEY
  ///
  /// Query parameter used to specify the starting record to return.
  ///
  /// TYPE: integer
  static const OFFSET_PARAM_KEY = "offset";

  /// from: static public final int OUTGOING_TYPE
  ///
  /// Call log type for outgoing calls.
  static const OUTGOING_TYPE = 2;

  /// from: static public final java.lang.String PHONE_ACCOUNT_COMPONENT_NAME
  ///
  /// The component name of the account used to place or receive the call; in string form.
  /// <P>Type: TEXT</P>
  static const PHONE_ACCOUNT_COMPONENT_NAME = "subscription_component_name";

  /// from: static public final java.lang.String PHONE_ACCOUNT_ID
  ///
  /// The identifier for the account used to place or receive the call.
  /// <P>Type: TEXT</P>
  static const PHONE_ACCOUNT_ID = "subscription_id";

  /// from: static public final java.lang.String POST_DIAL_DIGITS
  ///
  /// The post-dial portion of a dialed number, including any digits dialed after a
  /// TelecomManager\#DTMF_CHARACTER_PAUSE or a TelecomManager\#DTMF_CHARACTER_WAIT and these characters themselves.
  /// <P>Type: TEXT</P>
  static const POST_DIAL_DIGITS = "post_dial_digits";

  /// from: static public final int PRESENTATION_ALLOWED
  ///
  /// Number is allowed to display for caller id.
  static const PRESENTATION_ALLOWED = 1;

  /// from: static public final int PRESENTATION_PAYPHONE
  ///
  /// Number is a pay phone.
  static const PRESENTATION_PAYPHONE = 4;

  /// from: static public final int PRESENTATION_RESTRICTED
  ///
  /// Number is blocked by user.
  static const PRESENTATION_RESTRICTED = 2;

  /// from: static public final int PRESENTATION_UNKNOWN
  ///
  /// Number is not specified or unknown by network.
  static const PRESENTATION_UNKNOWN = 3;

  /// from: static public final int REJECTED_TYPE
  ///
  /// Call log type for calls rejected by direct user action.
  static const REJECTED_TYPE = 5;

  /// from: static public final java.lang.String TRANSCRIPTION
  ///
  /// Transcription of the call or voicemail entry. This will only be populated for call log
  /// entries of type \#VOICEMAIL_TYPE that have valid transcriptions.
  static const TRANSCRIPTION = "transcription";

  /// from: static public final java.lang.String TYPE
  ///
  /// The type of the call (incoming, outgoing or missed).
  /// <P>Type: INTEGER (int)</P>
  ///
  ///
  /// Allowed values:
  /// <ul>
  /// <li>\#INCOMING_TYPE</li>
  /// <li>\#OUTGOING_TYPE</li>
  /// <li>\#MISSED_TYPE</li>
  /// <li>\#VOICEMAIL_TYPE</li>
  /// <li>\#REJECTED_TYPE</li>
  /// <li>\#BLOCKED_TYPE</li>
  /// <li>\#ANSWERED_EXTERNALLY_TYPE</li>
  /// </ul>
  ///
  ///
  static const TYPE = "type";

  /// from: static public final java.lang.String VIA_NUMBER
  ///
  /// For an incoming call, the secondary line number the call was received via.
  /// When a SIM card has multiple phone numbers associated with it, the via number indicates
  /// which of the numbers associated with the SIM was called.
  static const VIA_NUMBER = "via_number";

  /// from: static public final int VOICEMAIL_TYPE
  ///
  /// Call log type for voicemails.
  static const VOICEMAIL_TYPE = 4;

  /// from: static public final java.lang.String VOICEMAIL_URI
  ///
  /// URI of the voicemail entry. Populated only for \#VOICEMAIL_TYPE.
  /// <P>Type: TEXT</P>
  static const VOICEMAIL_URI = "voicemail_uri";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CallLog_Calls()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getLastOutgoingCall = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getLastOutgoingCall",
      "(Landroid/content/Context;)Ljava/lang/String;");

  /// from: static public java.lang.String getLastOutgoingCall(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the call log database for the last dialed number.
  ///@param context Used to get the content resolver.
  ///@return The last phone number dialed (outgoing) or an empty
  /// string if none exist yet.
  static jni.JniString getLastOutgoingCall(context_.Context context) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getLastOutgoingCall,
          jni.JniType.objectType,
          [context.reference]).object);
}
