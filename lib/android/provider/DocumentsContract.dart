// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../net/Uri.dart" as uri_;

import "../content/Context.dart" as context_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../content/ContentResolver.dart" as contentresolver_;

import "../graphics/Point.dart" as point_;

import "../os/CancellationSignal.dart" as cancellationsignal_;

import "../content/IntentSender.dart" as intentsender_;

import "../os/Bundle.dart" as bundle_;

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.DocumentsContract
///
/// Defines the contract between a documents provider and the platform.
///
/// To create a document provider, extend DocumentsProvider, which
/// provides a foundational implementation of this contract.
///
/// All client apps must hold a valid URI permission grant to access documents,
/// typically issued when a user makes a selection through
/// Intent\#ACTION_OPEN_DOCUMENT, Intent\#ACTION_CREATE_DOCUMENT,
/// Intent\#ACTION_OPEN_DOCUMENT_TREE, or
/// StorageVolume\#createAccessIntent(String) StorageVolume.createAccessIntent.
///@see DocumentsProvider
class DocumentsContract extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/DocumentsContract");
  DocumentsContract.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_DOCUMENT_SETTINGS
  ///
  /// Action of intent issued by DocumentsUI when user wishes to open/configure/manage a particular
  /// document in the provider application.
  ///
  /// When issued, the intent will include the URI of the document as the intent data.
  ///
  /// A provider wishing to provide support for this action should do two things.
  /// <li>Add an {@code <intent-filter>} matching this action.
  /// <li>When supplying information in DocumentsProvider\#queryChildDocuments, include
  /// Document\#FLAG_SUPPORTS_SETTINGS in the flags for each document that supports
  /// settings.
  ///@see DocumentsContact\#Document\#FLAG_SUPPORTS_SETTINGS
  static const ACTION_DOCUMENT_SETTINGS =
      "android.provider.action.DOCUMENT_SETTINGS";

  /// from: static public final java.lang.String EXTRA_ERROR
  ///
  /// Optional string included in a directory Cursor\#getExtras()
  /// providing an error message that should be shown to a user. For example, a
  /// provider may wish to indicate that a network error occurred. The user may
  /// choose to retry, resulting in a new query.
  static const EXTRA_ERROR = "error";

  /// from: static public final java.lang.String EXTRA_EXCLUDE_SELF
  ///
  /// Set this in a DocumentsUI intent to cause a package's own roots to be
  /// excluded from the roots list.
  static const EXTRA_EXCLUDE_SELF = "android.provider.extra.EXCLUDE_SELF";

  /// from: static public final java.lang.String EXTRA_INFO
  ///
  /// Optional string included in a directory Cursor\#getExtras()
  /// providing an informational message that should be shown to a user. For
  /// example, a provider may wish to indicate that not all documents are
  /// available.
  static const EXTRA_INFO = "info";

  /// from: static public final java.lang.String EXTRA_INITIAL_URI
  ///
  /// Sets the desired initial location visible to user when file chooser is shown.
  ///
  /// Applicable to Intent with actions:
  /// <ul>
  ///      <li>Intent\#ACTION_OPEN_DOCUMENT</li>
  ///      <li>Intent\#ACTION_CREATE_DOCUMENT</li>
  ///      <li>Intent\#ACTION_OPEN_DOCUMENT_TREE</li>
  /// </ul>
  ///
  /// Location should specify a document URI or a tree URI with document ID. If
  /// this URI identifies a non-directory, document navigator will attempt to use the parent
  /// of the document as the initial location.
  ///
  /// The initial location is system specific if this extra is missing or document navigator
  /// failed to locate the desired initial location.
  static const EXTRA_INITIAL_URI = "android.provider.extra.INITIAL_URI";

  /// from: static public final java.lang.String EXTRA_LOADING
  ///
  /// Optional boolean flag included in a directory Cursor\#getExtras()
  /// indicating that a document provider is still loading data. For example, a
  /// provider has returned some results, but is still waiting on an
  /// outstanding network request. The provider must send a content changed
  /// notification when loading is finished.
  ///@see ContentResolver\#notifyChange(Uri, android.database.ContentObserver,
  ///      boolean)
  static const EXTRA_LOADING = "loading";

  /// from: static public final java.lang.String EXTRA_ORIENTATION
  ///
  /// Included in AssetFileDescriptor\#getExtras() when returned
  /// thumbnail should be rotated.
  ///@see MediaStore.Images.ImageColumns\#ORIENTATION
  static const EXTRA_ORIENTATION = "android.provider.extra.ORIENTATION";

  /// from: static public final java.lang.String EXTRA_PROMPT
  ///
  /// Overrides the default prompt text in DocumentsUI when set in an intent.
  static const EXTRA_PROMPT = "android.provider.extra.PROMPT";

  /// from: static public final java.lang.String PROVIDER_INTERFACE
  ///
  /// Intent action used to identify DocumentsProvider instances. This
  /// is used in the {@code <intent-filter>} of a {@code <provider>}.
  static const PROVIDER_INTERFACE = "android.content.action.DOCUMENTS_PROVIDER";

  static final _id_buildRootsUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "buildRootsUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildRootsUri(java.lang.String authority)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing the roots of a document provider. When queried, a
  /// provider will return one or more rows with columns defined by
  /// Root.
  ///@see DocumentsProvider\#queryRoots(String[])
  static uri_.Uri buildRootsUri(jni.JniString authority) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildRootsUri,
          jni.JniType.objectType,
          [authority.reference]).object);

  static final _id_buildRootUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "buildRootUri",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildRootUri(java.lang.String authority, java.lang.String rootId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing the given Root\#COLUMN_ROOT_ID in a
  /// document provider.
  ///@see \#getRootId(Uri)
  static uri_.Uri buildRootUri(jni.JniString authority, jni.JniString rootId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildRootUri,
          jni.JniType.objectType,
          [authority.reference, rootId.reference]).object);

  static final _id_buildRecentDocumentsUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "buildRecentDocumentsUri",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildRecentDocumentsUri(java.lang.String authority, java.lang.String rootId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing the recently modified documents of a specific root
  /// in a document provider. When queried, a provider will return zero or more
  /// rows with columns defined by Document.
  ///@see DocumentsProvider\#queryRecentDocuments(String, String[])
  ///@see \#getRootId(Uri)
  static uri_.Uri buildRecentDocumentsUri(
          jni.JniString authority, jni.JniString rootId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildRecentDocumentsUri,
          jni.JniType.objectType,
          [authority.reference, rootId.reference]).object);

  static final _id_buildTreeDocumentUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "buildTreeDocumentUri",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildTreeDocumentUri(java.lang.String authority, java.lang.String documentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing access to descendant documents of the given
  /// Document\#COLUMN_DOCUMENT_ID.
  ///@see \#getTreeDocumentId(Uri)
  static uri_.Uri buildTreeDocumentUri(
          jni.JniString authority, jni.JniString documentId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildTreeDocumentUri,
          jni.JniType.objectType,
          [authority.reference, documentId.reference]).object);

  static final _id_buildDocumentUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "buildDocumentUri",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildDocumentUri(java.lang.String authority, java.lang.String documentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing the target Document\#COLUMN_DOCUMENT_ID in
  /// a document provider. When queried, a provider will return a single row
  /// with columns defined by Document.
  ///@see DocumentsProvider\#queryDocument(String, String[])
  ///@see \#getDocumentId(Uri)
  static uri_.Uri buildDocumentUri(
          jni.JniString authority, jni.JniString documentId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildDocumentUri,
          jni.JniType.objectType,
          [authority.reference, documentId.reference]).object);

  static final _id_buildDocumentUriUsingTree = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "buildDocumentUriUsingTree",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildDocumentUriUsingTree(android.net.Uri treeUri, java.lang.String documentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing the target Document\#COLUMN_DOCUMENT_ID in
  /// a document provider. When queried, a provider will return a single row
  /// with columns defined by Document.
  ///
  /// However, instead of directly accessing the target document, the returned
  /// URI will leverage access granted through a subtree URI, typically
  /// returned by Intent\#ACTION_OPEN_DOCUMENT_TREE. The target document
  /// must be a descendant (child, grandchild, etc) of the subtree.
  ///
  /// This is typically used to access documents under a user-selected
  /// directory tree, since it doesn't require the user to separately confirm
  /// each new document access.
  ///@param treeUri the subtree to leverage to gain access to the target
  ///            document. The target directory must be a descendant of this
  ///            subtree.
  ///@param documentId the target document, which the caller may not have
  ///            direct access to.
  ///@see Intent\#ACTION_OPEN_DOCUMENT_TREE
  ///@see DocumentsProvider\#isChildDocument(String, String)
  ///@see \#buildDocumentUri(String, String)
  static uri_.Uri buildDocumentUriUsingTree(
          uri_.Uri treeUri, jni.JniString documentId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildDocumentUriUsingTree,
          jni.JniType.objectType,
          [treeUri.reference, documentId.reference]).object);

  static final _id_buildChildDocumentsUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "buildChildDocumentsUri",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildChildDocumentsUri(java.lang.String authority, java.lang.String parentDocumentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing the children of the target directory in a document
  /// provider. When queried, a provider will return zero or more rows with
  /// columns defined by Document.
  ///@param parentDocumentId the document to return children for, which must
  ///            be a directory with MIME type of
  ///            Document\#MIME_TYPE_DIR.
  ///@see DocumentsProvider\#queryChildDocuments(String, String[], String)
  ///@see \#getDocumentId(Uri)
  static uri_.Uri buildChildDocumentsUri(
          jni.JniString authority, jni.JniString parentDocumentId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildChildDocumentsUri,
          jni.JniType.objectType,
          [authority.reference, parentDocumentId.reference]).object);

  static final _id_buildChildDocumentsUriUsingTree =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "buildChildDocumentsUriUsingTree",
          "(Landroid/net/Uri;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildChildDocumentsUriUsingTree(android.net.Uri treeUri, java.lang.String parentDocumentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing the children of the target directory in a document
  /// provider. When queried, a provider will return zero or more rows with
  /// columns defined by Document.
  ///
  /// However, instead of directly accessing the target directory, the returned
  /// URI will leverage access granted through a subtree URI, typically
  /// returned by Intent\#ACTION_OPEN_DOCUMENT_TREE. The target
  /// directory must be a descendant (child, grandchild, etc) of the subtree.
  ///
  /// This is typically used to access documents under a user-selected
  /// directory tree, since it doesn't require the user to separately confirm
  /// each new document access.
  ///@param treeUri the subtree to leverage to gain access to the target
  ///            document. The target directory must be a descendant of this
  ///            subtree.
  ///@param parentDocumentId the document to return children for, which the
  ///            caller may not have direct access to, and which must be a
  ///            directory with MIME type of Document\#MIME_TYPE_DIR.
  ///@see Intent\#ACTION_OPEN_DOCUMENT_TREE
  ///@see DocumentsProvider\#isChildDocument(String, String)
  ///@see \#buildChildDocumentsUri(String, String)
  static uri_.Uri buildChildDocumentsUriUsingTree(
          uri_.Uri treeUri, jni.JniString parentDocumentId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildChildDocumentsUriUsingTree,
          jni.JniType.objectType,
          [treeUri.reference, parentDocumentId.reference]).object);

  static final _id_buildSearchDocumentsUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "buildSearchDocumentsUri",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri buildSearchDocumentsUri(java.lang.String authority, java.lang.String rootId, java.lang.String query)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build URI representing a search for matching documents under a specific
  /// root in a document provider. When queried, a provider will return zero or
  /// more rows with columns defined by Document.
  ///@see DocumentsProvider\#querySearchDocuments(String, String, String[])
  ///@see \#getRootId(Uri)
  ///@see \#getSearchDocumentsQuery(Uri)
  static uri_.Uri buildSearchDocumentsUri(
          jni.JniString authority, jni.JniString rootId, jni.JniString query) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_buildSearchDocumentsUri,
          jni.JniType.objectType,
          [authority.reference, rootId.reference, query.reference]).object);

  static final _id_isDocumentUri = jniAccessors.getStaticMethodIDOf(_classRef,
      "isDocumentUri", "(Landroid/content/Context;Landroid/net/Uri;)Z");

  /// from: static public boolean isDocumentUri(android.content.Context context, android.net.Uri uri)
  ///
  /// Test if the given URI represents a Document backed by a
  /// DocumentsProvider.
  ///@see \#buildDocumentUri(String, String)
  ///@see \#buildDocumentUriUsingTree(Uri, String)
  ///@param uri This value may be {@code null}.
  static bool isDocumentUri(context_.Context context, uri_.Uri uri) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isDocumentUri,
          jni.JniType.booleanType, [context.reference, uri.reference]).boolean;

  static final _id_isTreeUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "isTreeUri", "(Landroid/net/Uri;)Z");

  /// from: static public boolean isTreeUri(android.net.Uri uri)
  ///
  /// Test if the given URI represents a Document tree.
  ///@see \#buildTreeDocumentUri(String, String)
  ///@see \#getTreeDocumentId(Uri)
  static bool isTreeUri(uri_.Uri uri) => jniAccessors.callStaticMethodWithArgs(
      _classRef,
      _id_isTreeUri,
      jni.JniType.booleanType,
      [uri.reference]).boolean;

  static final _id_getRootId = jniAccessors.getStaticMethodIDOf(
      _classRef, "getRootId", "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: static public java.lang.String getRootId(android.net.Uri rootUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Extract the Root\#COLUMN_ROOT_ID from the given URI.
  static jni.JniString getRootId(uri_.Uri rootUri) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getRootId, jni.JniType.objectType, [rootUri.reference]).object);

  static final _id_getDocumentId = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDocumentId", "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: static public java.lang.String getDocumentId(android.net.Uri documentUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Extract the Document\#COLUMN_DOCUMENT_ID from the given URI.
  ///@see \#isDocumentUri(Context, Uri)
  static jni.JniString getDocumentId(uri_.Uri documentUri) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDocumentId,
          jni.JniType.objectType,
          [documentUri.reference]).object);

  static final _id_getTreeDocumentId = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTreeDocumentId", "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: static public java.lang.String getTreeDocumentId(android.net.Uri documentUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Extract the via Document\#COLUMN_DOCUMENT_ID from the given URI.
  static jni.JniString getTreeDocumentId(uri_.Uri documentUri) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTreeDocumentId,
          jni.JniType.objectType,
          [documentUri.reference]).object);

  static final _id_getSearchDocumentsQuery = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getSearchDocumentsQuery",
      "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: static public java.lang.String getSearchDocumentsQuery(android.net.Uri searchDocumentsUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Extract the search query from a URI built by
  /// \#buildSearchDocumentsUri(String, String, String).
  static jni.JniString getSearchDocumentsQuery(uri_.Uri searchDocumentsUri) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getSearchDocumentsQuery,
          jni.JniType.objectType,
          [searchDocumentsUri.reference]).object);

  static final _id_getDocumentThumbnail = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDocumentThumbnail",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/graphics/Point;Landroid/os/CancellationSignal;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap getDocumentThumbnail(android.content.ContentResolver resolver, android.net.Uri documentUri, android.graphics.Point size, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return thumbnail representing the document at the given URI. Callers are
  /// responsible for their own in-memory caching.
  ///@param documentUri document to return thumbnail for, which must have
  ///            Document\#FLAG_SUPPORTS_THUMBNAIL set.
  ///@param size optimal thumbnail size desired. A provider may return a
  ///            thumbnail of a different size, but never more than double the
  ///            requested size.
  ///@param signal signal used to indicate if caller is no longer interested
  ///            in the thumbnail.
  ///@return decoded thumbnail, or {@code null} if problem was encountered.
  ///@see DocumentsProvider\#openDocumentThumbnail(String, Point,
  ///      android.os.CancellationSignal)
  static bitmap_.Bitmap getDocumentThumbnail(
          contentresolver_.ContentResolver resolver,
          uri_.Uri documentUri,
          point_.Point size,
          cancellationsignal_.CancellationSignal signal) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getDocumentThumbnail, jni.JniType.objectType, [
        resolver.reference,
        documentUri.reference,
        size.reference,
        signal.reference
      ]).object);

  static final _id_createDocument = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createDocument",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri createDocument(android.content.ContentResolver resolver, android.net.Uri parentDocumentUri, java.lang.String mimeType, java.lang.String displayName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new document with given MIME type and display name.
  ///@param parentDocumentUri directory with Document\#FLAG_DIR_SUPPORTS_CREATE
  ///@param mimeType MIME type of new document
  ///@param displayName name of new document
  ///@return newly created document, or {@code null} if failed
  static uri_.Uri createDocument(
          contentresolver_.ContentResolver resolver,
          uri_.Uri parentDocumentUri,
          jni.JniString mimeType,
          jni.JniString displayName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createDocument, jni.JniType.objectType, [
        resolver.reference,
        parentDocumentUri.reference,
        mimeType.reference,
        displayName.reference
      ]).object);

  static final _id_renameDocument = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "renameDocument",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri renameDocument(android.content.ContentResolver resolver, android.net.Uri documentUri, java.lang.String displayName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the display name of an existing document.
  ///
  /// If the underlying provider needs to create a new
  /// Document\#COLUMN_DOCUMENT_ID to represent the updated display
  /// name, that new document is returned and the original document is no
  /// longer valid. Otherwise, the original document is returned.
  ///@param documentUri document with Document\#FLAG_SUPPORTS_RENAME
  ///@param displayName updated name for document
  ///@return the existing or new document after the rename, or {@code null} if
  ///         failed.
  static uri_.Uri renameDocument(contentresolver_.ContentResolver resolver,
          uri_.Uri documentUri, jni.JniString displayName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_renameDocument, jni.JniType.objectType, [
        resolver.reference,
        documentUri.reference,
        displayName.reference
      ]).object);

  static final _id_deleteDocument = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "deleteDocument",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Z");

  /// from: static public boolean deleteDocument(android.content.ContentResolver resolver, android.net.Uri documentUri)
  ///
  /// Delete the given document.
  ///@param documentUri document with Document\#FLAG_SUPPORTS_DELETE
  ///@return if the document was deleted successfully.
  static bool deleteDocument(
          contentresolver_.ContentResolver resolver, uri_.Uri documentUri) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_deleteDocument,
          jni.JniType.booleanType,
          [resolver.reference, documentUri.reference]).boolean;

  static final _id_copyDocument = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "copyDocument",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: static public android.net.Uri copyDocument(android.content.ContentResolver resolver, android.net.Uri sourceDocumentUri, android.net.Uri targetParentDocumentUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copies the given document.
  ///@param sourceDocumentUri document with Document\#FLAG_SUPPORTS_COPY
  ///@param targetParentDocumentUri document which will become a parent of the source
  ///         document's copy.
  ///@return the copied document, or {@code null} if failed.
  static uri_.Uri copyDocument(contentresolver_.ContentResolver resolver,
          uri_.Uri sourceDocumentUri, uri_.Uri targetParentDocumentUri) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_copyDocument, jni.JniType.objectType, [
        resolver.reference,
        sourceDocumentUri.reference,
        targetParentDocumentUri.reference
      ]).object);

  static final _id_moveDocument = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "moveDocument",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/net/Uri;Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: static public android.net.Uri moveDocument(android.content.ContentResolver resolver, android.net.Uri sourceDocumentUri, android.net.Uri sourceParentDocumentUri, android.net.Uri targetParentDocumentUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Moves the given document under a new parent.
  ///@param sourceDocumentUri document with Document\#FLAG_SUPPORTS_MOVE
  ///@param sourceParentDocumentUri parent document of the document to move.
  ///@param targetParentDocumentUri document which will become a new parent of the source
  ///         document.
  ///@return the moved document, or {@code null} if failed.
  static uri_.Uri moveDocument(
          contentresolver_.ContentResolver resolver,
          uri_.Uri sourceDocumentUri,
          uri_.Uri sourceParentDocumentUri,
          uri_.Uri targetParentDocumentUri) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_moveDocument, jni.JniType.objectType, [
        resolver.reference,
        sourceDocumentUri.reference,
        sourceParentDocumentUri.reference,
        targetParentDocumentUri.reference
      ]).object);

  static final _id_removeDocument = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "removeDocument",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/net/Uri;)Z");

  /// from: static public boolean removeDocument(android.content.ContentResolver resolver, android.net.Uri documentUri, android.net.Uri parentDocumentUri)
  ///
  /// Removes the given document from a parent directory.
  ///
  /// In contrast to \#deleteDocument it requires specifying the parent.
  /// This method is especially useful if the document can be in multiple parents.
  ///@param documentUri document with Document\#FLAG_SUPPORTS_REMOVE
  ///@param parentDocumentUri parent document of the document to remove.
  ///@return true if the document was removed successfully.
  static bool removeDocument(contentresolver_.ContentResolver resolver,
          uri_.Uri documentUri, uri_.Uri parentDocumentUri) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_removeDocument, jni.JniType.booleanType, [
        resolver.reference,
        documentUri.reference,
        parentDocumentUri.reference
      ]).boolean;

  static final _id_ejectRoot = jniAccessors.getStaticMethodIDOf(_classRef,
      "ejectRoot", "(Landroid/content/ContentResolver;Landroid/net/Uri;)V");

  /// from: static public void ejectRoot(android.content.ContentResolver resolver, android.net.Uri rootUri)
  ///
  /// Ejects the given root. It throws IllegalStateException when ejection failed.
  ///@param rootUri root with Root\#FLAG_SUPPORTS_EJECT to be ejected
  static void ejectRoot(
          contentresolver_.ContentResolver resolver, uri_.Uri rootUri) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_ejectRoot,
          jni.JniType.voidType,
          [resolver.reference, rootUri.reference]).check();

  static final _id_findDocumentPath = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "findDocumentPath",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/provider/DocumentsContract\$Path;");

  /// from: static public android.provider.DocumentsContract.Path findDocumentPath(android.content.ContentResolver resolver, android.net.Uri treeUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds the canonical path from the top of the document tree.
  ///
  /// The Path\#getPath() of the return value contains the document ID
  /// of all documents along the path from the top the document tree to the
  /// requested document, both inclusive.
  ///
  /// The Path\#getRootId() of the return value returns {@code null}.
  ///@param treeUri treeUri of the document which path is requested.
  ///@return the path of the document, or {@code null} if failed.
  ///@see DocumentsProvider\#findDocumentPath(String, String)
  static DocumentsContract_Path findDocumentPath(
          contentresolver_.ContentResolver resolver, uri_.Uri treeUri) =>
      DocumentsContract_Path.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_findDocumentPath,
          jni.JniType.objectType,
          [resolver.reference, treeUri.reference]).object);

  static final _id_createWebLinkIntent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createWebLinkIntent",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/os/Bundle;)Landroid/content/IntentSender;");

  /// from: static public android.content.IntentSender createWebLinkIntent(android.content.ContentResolver resolver, android.net.Uri uri, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an intent for obtaining a web link for the specified document.
  ///
  /// Note, that due to internal limitations, if there is already a web link
  /// intent created for the specified document but with different options,
  /// then it may be overriden.
  ///
  /// Providers are required to show confirmation UI for all new permissions granted
  /// for the linked document.
  ///
  /// If list of recipients is known, then it should be passed in options as
  /// Intent\#EXTRA_EMAIL as a list of email addresses. Note, that
  /// this is just a hint for the provider, which can ignore the list. In either
  /// case the provider is required to show a UI for letting the user confirm
  /// any new permission grants.
  ///
  /// Note, that the entire <code>options</code> bundle will be sent to the provider
  /// backing the passed <code>uri</code>. Make sure that you trust the provider
  /// before passing any sensitive information.
  ///
  /// Since this API may show a UI, it cannot be called from background.
  ///
  /// In order to obtain the Web Link use code like this:
  /// <pre><code>
  /// void onSomethingHappened() {
  ///   IntentSender sender = DocumentsContract.createWebLinkIntent(<i>...</i>);
  ///   if (sender != null) {
  ///     startIntentSenderForResult(
  ///         sender,
  ///         WEB_LINK_REQUEST_CODE,
  ///         null, 0, 0, 0, null);
  ///   }
  /// }
  ///
  /// <i>(...)</i>
  ///
  /// void onActivityResult(int requestCode, int resultCode, Intent data) {
  ///   if (requestCode == WEB_LINK_REQUEST_CODE && resultCode == RESULT_OK) {
  ///     Uri weblinkUri = data.getData();
  ///     <i>...</i>
  ///   }
  /// }
  /// </code></pre>
  ///@param uri uri for the document to create a link to.
  ///@param options Extra information for generating the link.
  ///@return an intent sender to obtain the web link, or null if the document
  ///      is not linkable, or creating the intent sender failed.
  ///@see DocumentsProvider\#createWebLinkIntent(String, Bundle)
  ///@see Intent\#EXTRA_EMAIL
  static intentsender_.IntentSender createWebLinkIntent(
          contentresolver_.ContentResolver resolver,
          uri_.Uri uri,
          bundle_.Bundle options) =>
      intentsender_.IntentSender.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createWebLinkIntent,
          jni.JniType.objectType,
          [resolver.reference, uri.reference, options.reference]).object);
}

/// from: android.provider.DocumentsContract$Root
///
/// Constants related to a root of documents, including Cursor column
/// names and flags. A root is the start of a tree of documents, such as a
/// physical storage device, or an account. Each root starts at the directory
/// referenced by Root\#COLUMN_DOCUMENT_ID, which can recursively
/// contain both documents and directories.
///
/// All columns are _read-only_ to client applications.
class DocumentsContract_Root extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/DocumentsContract\$Root");
  DocumentsContract_Root.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String COLUMN_AVAILABLE_BYTES
  ///
  /// Number of bytes available in this root. This column is optional, and
  /// may be {@code null} if unknown or unbounded.
  ///
  /// Type: INTEGER (long)
  static const COLUMN_AVAILABLE_BYTES = "available_bytes";

  /// from: static public final java.lang.String COLUMN_CAPACITY_BYTES
  ///
  /// Capacity of a root in bytes. This column is optional, and may be
  /// {@code null} if unknown or unbounded.
  ///
  /// Type: INTEGER (long)
  static const COLUMN_CAPACITY_BYTES = "capacity_bytes";

  /// from: static public final java.lang.String COLUMN_DOCUMENT_ID
  ///
  /// Document which is a directory that represents the top directory of
  /// this root. This column is required.
  ///
  /// Type: STRING
  ///@see Document\#COLUMN_DOCUMENT_ID
  static const COLUMN_DOCUMENT_ID = "document_id";

  /// from: static public final java.lang.String COLUMN_FLAGS
  ///
  /// Flags that apply to a root. This column is required.
  ///
  /// Type: INTEGER (int)
  ///@see \#FLAG_LOCAL_ONLY
  ///@see \#FLAG_SUPPORTS_CREATE
  ///@see \#FLAG_SUPPORTS_RECENTS
  ///@see \#FLAG_SUPPORTS_SEARCH
  static const COLUMN_FLAGS = "flags";

  /// from: static public final java.lang.String COLUMN_ICON
  ///
  /// Icon resource ID for a root. This column is required.
  ///
  /// Type: INTEGER (int)
  static const COLUMN_ICON = "icon";

  /// from: static public final java.lang.String COLUMN_MIME_TYPES
  ///
  /// MIME types supported by this root. This column is optional, and if
  /// {@code null} the root is assumed to support all MIME types. Multiple
  /// MIME types can be separated by a newline. For example, a root
  /// supporting audio might return "audio/*\napplication/x-flac".
  ///
  /// Type: STRING
  static const COLUMN_MIME_TYPES = "mime_types";

  /// from: static public final java.lang.String COLUMN_ROOT_ID
  ///
  /// Unique ID of a root. This ID is both provided by and interpreted by a
  /// DocumentsProvider, and should be treated as an opaque value
  /// by client applications. This column is required.
  ///
  /// Type: STRING
  static const COLUMN_ROOT_ID = "root_id";

  /// from: static public final java.lang.String COLUMN_SUMMARY
  ///
  /// Summary for this root, which may be shown to a user. This column is
  /// optional, and may be {@code null}. For a single storage service
  /// surfacing multiple accounts as different roots, this summary should
  /// be the name of the account.
  ///
  /// Type: STRING
  static const COLUMN_SUMMARY = "summary";

  /// from: static public final java.lang.String COLUMN_TITLE
  ///
  /// Title for a root, which will be shown to a user. This column is
  /// required. For a single storage service surfacing multiple accounts as
  /// different roots, this title should be the name of the service.
  ///
  /// Type: STRING
  static const COLUMN_TITLE = "title";

  /// from: static public final int FLAG_LOCAL_ONLY
  ///
  /// Flag indicating that this root offers content that is strictly local
  /// on the device. That is, no network requests are made for the content.
  ///@see \#COLUMN_FLAGS
  ///@see Intent\#EXTRA_LOCAL_ONLY
  static const FLAG_LOCAL_ONLY = 2;

  /// from: static public final int FLAG_SUPPORTS_CREATE
  ///
  /// Flag indicating that at least one directory under this root supports
  /// creating content. Roots with this flag will be shown when an
  /// application interacts with Intent\#ACTION_CREATE_DOCUMENT.
  ///@see \#COLUMN_FLAGS
  static const FLAG_SUPPORTS_CREATE = 1;

  /// from: static public final int FLAG_SUPPORTS_EJECT
  ///
  /// Flag indicating that this root can be ejected.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#ejectRoot(ContentResolver, Uri)
  ///@see DocumentsProvider\#ejectRoot(String)
  static const FLAG_SUPPORTS_EJECT = 32;

  /// from: static public final int FLAG_SUPPORTS_IS_CHILD
  ///
  /// Flag indicating that this root supports testing parent child
  /// relationships.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsProvider\#isChildDocument(String, String)
  static const FLAG_SUPPORTS_IS_CHILD = 16;

  /// from: static public final int FLAG_SUPPORTS_RECENTS
  ///
  /// Flag indicating that this root can be queried to provide recently
  /// modified documents.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#buildRecentDocumentsUri(String, String)
  ///@see DocumentsProvider\#queryRecentDocuments(String, String[])
  static const FLAG_SUPPORTS_RECENTS = 4;

  /// from: static public final int FLAG_SUPPORTS_SEARCH
  ///
  /// Flag indicating that this root supports search.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#buildSearchDocumentsUri(String, String,
  ///      String)
  ///@see DocumentsProvider\#querySearchDocuments(String, String,
  ///      String[])
  static const FLAG_SUPPORTS_SEARCH = 8;

  /// from: static public final java.lang.String MIME_TYPE_ITEM
  ///
  /// MIME type for a root.
  static const MIME_TYPE_ITEM = "vnd.android.document/root";
}

/// from: android.provider.DocumentsContract$Path
///
/// Holds a path from a document to a particular document under it. It
/// may also contains the root ID where the path resides.
class DocumentsContract_Path extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/DocumentsContract\$Path");
  DocumentsContract_Path.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.provider.DocumentsContract.Path> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Ljava/util/List;)V");

  /// from: public void <init>(java.lang.String rootId, java.util.List<java.lang.String> path)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a Path.
  ///@param rootId the ID of the root. May be null.
  /// This value may be {@code null}.
  ///@param path the list of document ID from the parent document at
  ///          position 0 to the child document.
  DocumentsContract_Path(jni.JniString rootId, jni.JniObject path)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [rootId.reference, path.reference]).object);

  static final _id_getRootId = jniAccessors.getMethodIDOf(
      _classRef, "getRootId", "()Ljava/lang/String;");

  /// from: public java.lang.String getRootId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the root id or null if the calling package doesn't have
  /// permission to access root information.
  jni.JniString getRootId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRootId, jni.JniType.objectType, []).object);

  static final _id_getPath =
      jniAccessors.getMethodIDOf(_classRef, "getPath", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getPath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the path. The path is trimmed to the top of tree if
  /// calling package doesn't have permission to access those
  /// documents.
  jni.JniObject getPath() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPath, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;
}

/// from: android.provider.DocumentsContract$Document
///
/// Constants related to a document, including Cursor column names
/// and flags.
///
/// A document can be either an openable stream (with a specific MIME type),
/// or a directory containing additional documents (with the
/// \#MIME_TYPE_DIR MIME type). A directory represents the top of a
/// subtree containing zero or more documents, which can recursively contain
/// even more documents and directories.
///
/// All columns are _read-only_ to client applications.
class DocumentsContract_Document extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/DocumentsContract\$Document");
  DocumentsContract_Document.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String COLUMN_DISPLAY_NAME
  ///
  /// Display name of a document, used as the primary title displayed to a
  /// user. This column is required.
  ///
  /// Type: STRING
  static const COLUMN_DISPLAY_NAME = "_display_name";

  /// from: static public final java.lang.String COLUMN_DOCUMENT_ID
  ///
  /// Unique ID of a document. This ID is both provided by and interpreted
  /// by a DocumentsProvider, and should be treated as an opaque
  /// value by client applications. This column is required.
  ///
  /// Each document must have a unique ID within a provider, but that
  /// single document may be included as a child of multiple directories.
  ///
  /// A provider must always return durable IDs, since they will be used to
  /// issue long-term URI permission grants when an application interacts
  /// with Intent\#ACTION_OPEN_DOCUMENT and
  /// Intent\#ACTION_CREATE_DOCUMENT.
  ///
  /// Type: STRING
  static const COLUMN_DOCUMENT_ID = "document_id";

  /// from: static public final java.lang.String COLUMN_FLAGS
  ///
  /// Flags that apply to a document. This column is required.
  ///
  /// Type: INTEGER (int)
  ///@see \#FLAG_SUPPORTS_WRITE
  ///@see \#FLAG_SUPPORTS_DELETE
  ///@see \#FLAG_SUPPORTS_THUMBNAIL
  ///@see \#FLAG_DIR_PREFERS_GRID
  ///@see \#FLAG_DIR_PREFERS_LAST_MODIFIED
  ///@see \#FLAG_VIRTUAL_DOCUMENT
  ///@see \#FLAG_SUPPORTS_COPY
  ///@see \#FLAG_SUPPORTS_MOVE
  ///@see \#FLAG_SUPPORTS_REMOVE
  static const COLUMN_FLAGS = "flags";

  /// from: static public final java.lang.String COLUMN_ICON
  ///
  /// Specific icon resource ID for a document. This column is optional,
  /// and may be {@code null} to use a platform-provided default icon based
  /// on \#COLUMN_MIME_TYPE.
  ///
  /// Type: INTEGER (int)
  static const COLUMN_ICON = "icon";

  /// from: static public final java.lang.String COLUMN_LAST_MODIFIED
  ///
  /// Timestamp when a document was last modified, in milliseconds since
  /// January 1, 1970 00:00:00.0 UTC. This column is required, and may be
  /// {@code null} if unknown. A DocumentsProvider can update this
  /// field using events from OnCloseListener or other reliable
  /// ParcelFileDescriptor transports.
  ///
  /// Type: INTEGER (long)
  ///@see System\#currentTimeMillis()
  static const COLUMN_LAST_MODIFIED = "last_modified";

  /// from: static public final java.lang.String COLUMN_MIME_TYPE
  ///
  /// Concrete MIME type of a document. For example, "image/png" or
  /// "application/pdf" for openable files. A document can also be a
  /// directory containing additional documents, which is represented with
  /// the \#MIME_TYPE_DIR MIME type. This column is required.
  ///
  /// Type: STRING
  ///@see \#MIME_TYPE_DIR
  static const COLUMN_MIME_TYPE = "mime_type";

  /// from: static public final java.lang.String COLUMN_SIZE
  ///
  /// Size of a document, in bytes, or {@code null} if unknown. This column
  /// is required.
  ///
  /// Type: INTEGER (long)
  static const COLUMN_SIZE = "_size";

  /// from: static public final java.lang.String COLUMN_SUMMARY
  ///
  /// Summary of a document, which may be shown to a user. This column is
  /// optional, and may be {@code null}.
  ///
  /// Type: STRING
  static const COLUMN_SUMMARY = "summary";

  /// from: static public final int FLAG_DIR_PREFERS_GRID
  ///
  /// Flag indicating that a directory prefers its contents be shown in a
  /// larger format grid. Usually suitable when a directory contains mostly
  /// pictures. Only valid when \#COLUMN_MIME_TYPE is
  /// \#MIME_TYPE_DIR.
  ///@see \#COLUMN_FLAGS
  static const FLAG_DIR_PREFERS_GRID = 16;

  /// from: static public final int FLAG_DIR_PREFERS_LAST_MODIFIED
  ///
  /// Flag indicating that a directory prefers its contents be sorted by
  /// \#COLUMN_LAST_MODIFIED. Only valid when
  /// \#COLUMN_MIME_TYPE is \#MIME_TYPE_DIR.
  ///@see \#COLUMN_FLAGS
  static const FLAG_DIR_PREFERS_LAST_MODIFIED = 32;

  /// from: static public final int FLAG_DIR_SUPPORTS_CREATE
  ///
  /// Flag indicating that a document is a directory that supports creation
  /// of new files within it. Only valid when \#COLUMN_MIME_TYPE is
  /// \#MIME_TYPE_DIR.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsProvider\#createDocument(String, String, String)
  static const FLAG_DIR_SUPPORTS_CREATE = 8;

  /// from: static public final int FLAG_SUPPORTS_COPY
  ///
  /// Flag indicating that a document can be copied to another location
  /// within the same document provider.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#copyDocument(ContentResolver, Uri, Uri)
  ///@see DocumentsProvider\#copyDocument(String, String)
  static const FLAG_SUPPORTS_COPY = 128;

  /// from: static public final int FLAG_SUPPORTS_DELETE
  ///
  /// Flag indicating that a document is deletable.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#deleteDocument(ContentResolver, Uri)
  ///@see DocumentsProvider\#deleteDocument(String)
  static const FLAG_SUPPORTS_DELETE = 4;

  /// from: static public final int FLAG_SUPPORTS_MOVE
  ///
  /// Flag indicating that a document can be moved to another location
  /// within the same document provider.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#moveDocument(ContentResolver, Uri, Uri, Uri)
  ///@see DocumentsProvider\#moveDocument(String, String, String)
  static const FLAG_SUPPORTS_MOVE = 256;

  /// from: static public final int FLAG_SUPPORTS_REMOVE
  ///
  /// Flag indicating that a document can be removed from a parent.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#removeDocument(ContentResolver, Uri, Uri)
  ///@see DocumentsProvider\#removeDocument(String, String)
  static const FLAG_SUPPORTS_REMOVE = 1024;

  /// from: static public final int FLAG_SUPPORTS_RENAME
  ///
  /// Flag indicating that a document can be renamed.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#renameDocument(ContentResolver, Uri,
  ///      String)
  ///@see DocumentsProvider\#renameDocument(String, String)
  static const FLAG_SUPPORTS_RENAME = 64;

  /// from: static public final int FLAG_SUPPORTS_SETTINGS
  ///
  /// Flag indicating that a document has settings that can be configured by user.
  ///@see \#COLUMN_FLAGS
  ///@see \#ACTION_DOCUMENT_SETTINGS
  static const FLAG_SUPPORTS_SETTINGS = 2048;

  /// from: static public final int FLAG_SUPPORTS_THUMBNAIL
  ///
  /// Flag indicating that a document can be represented as a thumbnail.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#getDocumentThumbnail(ContentResolver, Uri,
  ///      Point, CancellationSignal)
  ///@see DocumentsProvider\#openDocumentThumbnail(String, Point,
  ///      android.os.CancellationSignal)
  static const FLAG_SUPPORTS_THUMBNAIL = 1;

  /// from: static public final int FLAG_SUPPORTS_WRITE
  ///
  /// Flag indicating that a document supports writing.
  ///
  /// When a document is opened with Intent\#ACTION_OPEN_DOCUMENT,
  /// the calling application is granted both
  /// Intent\#FLAG_GRANT_READ_URI_PERMISSION and
  /// Intent\#FLAG_GRANT_WRITE_URI_PERMISSION. However, the actual
  /// writability of a document may change over time, for example due to
  /// remote access changes. This flag indicates that a document client can
  /// expect ContentResolver\#openOutputStream(Uri) to succeed.
  ///@see \#COLUMN_FLAGS
  static const FLAG_SUPPORTS_WRITE = 2;

  /// from: static public final int FLAG_VIRTUAL_DOCUMENT
  ///
  /// Flag indicating that a document is virtual, and doesn't have byte
  /// representation in the MIME type specified as \#COLUMN_MIME_TYPE.
  ///
  /// _Virtual documents must have at least one alternative streamable
  /// format via DocumentsProvider\#openTypedDocument_
  ///@see \#COLUMN_FLAGS
  ///@see \#COLUMN_MIME_TYPE
  ///@see DocumentsProvider\#openTypedDocument(String, String, Bundle,
  ///      android.os.CancellationSignal)
  ///@see DocumentsProvider\#getDocumentStreamTypes(String, String)
  static const FLAG_VIRTUAL_DOCUMENT = 512;

  /// from: static public final int FLAG_WEB_LINKABLE
  ///
  /// Flag indicating that a Web link can be obtained for the document.
  ///@see \#COLUMN_FLAGS
  ///@see DocumentsContract\#createWebLinkIntent(PackageManager, Uri, Bundle)
  static const FLAG_WEB_LINKABLE = 4096;

  /// from: static public final java.lang.String MIME_TYPE_DIR
  ///
  /// MIME type of a document which is a directory that may contain
  /// additional documents.
  ///@see \#COLUMN_MIME_TYPE
  static const MIME_TYPE_DIR = "vnd.android.document/directory";
}
