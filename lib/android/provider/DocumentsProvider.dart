// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/ContentProvider.dart" as contentprovider_;

import "../content/Context.dart" as context_;

import "../content/pm/ProviderInfo.dart" as providerinfo_;

import "DocumentsContract.dart" as documentscontract_;

import "../content/IntentSender.dart" as intentsender_;

import "../os/Bundle.dart" as bundle_;

import "../database/Cursor.dart" as cursor_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;

import "../os/CancellationSignal.dart" as cancellationsignal_;

import "../content/res/AssetFileDescriptor.dart" as assetfiledescriptor_;

import "../graphics/Point.dart" as point_;

import "../net/Uri.dart" as uri_;

import "../content/ContentValues.dart" as contentvalues_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.DocumentsProvider
///
/// Base class for a document provider. A document provider offers read and write
/// access to durable files, such as files stored on a local disk, or files in a
/// cloud storage service. To create a document provider, extend this class,
/// implement the abstract methods, and add it to your manifest like this:
///
/// <pre class="prettyprint">&lt;manifest&gt;
///    ...
///    &lt;application&gt;
///        ...
///        &lt;provider
///            android:name="com.example.MyCloudProvider"
///            android:authorities="com.example.mycloudprovider"
///            android:exported="true"
///            android:grantUriPermissions="true"
///            android:permission="android.permission.MANAGE_DOCUMENTS"
///            android:enabled="@bool/isAtLeastKitKat"&gt;
///            &lt;intent-filter&gt;
///                &lt;action android:name="android.content.action.DOCUMENTS_PROVIDER" /&gt;
///            &lt;/intent-filter&gt;
///        &lt;/provider&gt;
///        ...
///    &lt;/application&gt;
///&lt;/manifest&gt;</pre>
///
/// When defining your provider, you must protect it with
/// android.Manifest.permission\#MANAGE_DOCUMENTS, which is a permission
/// only the system can obtain. Applications cannot use a documents provider
/// directly; they must go through Intent\#ACTION_OPEN_DOCUMENT or
/// Intent\#ACTION_CREATE_DOCUMENT which requires a user to actively
/// navigate and select documents. When a user selects documents through that UI,
/// the system issues narrow URI permission grants to the requesting application.
///
///
/// <h3>Documents</h3>
///
/// A document can be either an openable stream (with a specific MIME type), or a
/// directory containing additional documents (with the
/// Document\#MIME_TYPE_DIR MIME type). Each directory represents the top
/// of a subtree containing zero or more documents, which can recursively contain
/// even more documents and directories.
///
///
///
/// Each document can have different capabilities, as described by
/// Document\#COLUMN_FLAGS. For example, if a document can be represented
/// as a thumbnail, your provider can set
/// Document\#FLAG_SUPPORTS_THUMBNAIL and implement
/// \#openDocumentThumbnail(String, Point, CancellationSignal) to return
/// that thumbnail.
///
///
///
/// Each document under a provider is uniquely referenced by its
/// Document\#COLUMN_DOCUMENT_ID, which must not change once returned. A
/// single document can be included in multiple directories when responding to
/// \#queryChildDocuments(String, String[], String). For example, a
/// provider might surface a single photo in multiple locations: once in a
/// directory of geographic locations, and again in a directory of dates.
///
///
/// <h3>Roots</h3>
///
/// All documents are surfaced through one or more "roots." Each root represents
/// the top of a document tree that a user can navigate. For example, a root
/// could represent an account or a physical storage device. Similar to
/// documents, each root can have capabilities expressed through
/// Root\#COLUMN_FLAGS.
///
///
///@see Intent\#ACTION_OPEN_DOCUMENT
///@see Intent\#ACTION_OPEN_DOCUMENT_TREE
///@see Intent\#ACTION_CREATE_DOCUMENT
class DocumentsProvider extends contentprovider_.ContentProvider {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/DocumentsProvider");
  DocumentsProvider.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DocumentsProvider()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_attachInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "attachInfo",
      "(Landroid/content/Context;Landroid/content/pm/ProviderInfo;)V");

  /// from: public void attachInfo(android.content.Context context, android.content.pm.ProviderInfo info)
  ///
  /// Implementation is provided by the parent class.
  void attachInfo(context_.Context context, providerinfo_.ProviderInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_attachInfo,
          jni.JniType.voidType, [context.reference, info.reference]).check();

  static final _id_isChildDocument = jniAccessors.getMethodIDOf(
      _classRef, "isChildDocument", "(Ljava/lang/String;Ljava/lang/String;)Z");

  /// from: public boolean isChildDocument(java.lang.String parentDocumentId, java.lang.String documentId)
  ///
  /// Test if a document is descendant (child, grandchild, etc) from the given
  /// parent. For example, providers must implement this to support
  /// Intent\#ACTION_OPEN_DOCUMENT_TREE. You should avoid making network
  /// requests to keep this request fast.
  ///@param parentDocumentId parent to verify against.
  ///@param documentId child to verify.
  ///@return if given document is a descendant of the given parent.
  ///@see DocumentsContract.Root\#FLAG_SUPPORTS_IS_CHILD
  bool isChildDocument(
          jni.JniString parentDocumentId, jni.JniString documentId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isChildDocument,
          jni.JniType.booleanType,
          [parentDocumentId.reference, documentId.reference]).boolean;

  static final _id_createDocument = jniAccessors.getMethodIDOf(
      _classRef,
      "createDocument",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String createDocument(java.lang.String parentDocumentId, java.lang.String mimeType, java.lang.String displayName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new document and return its newly generated
  /// Document\#COLUMN_DOCUMENT_ID. You must allocate a new
  /// Document\#COLUMN_DOCUMENT_ID to represent the document, which must
  /// not change once returned.
  ///@param parentDocumentId the parent directory to create the new document
  ///            under.
  ///@param mimeType the concrete MIME type associated with the new document.
  ///            If the MIME type is not supported, the provider must throw.
  ///@param displayName the display name of the new document. The provider may
  ///            alter this name to meet any internal constraints, such as
  ///            avoiding conflicting names.
  ///@throws AuthenticationRequiredException If authentication is required from the user (such as
  ///             login credentials), but it is not guaranteed that the client will handle this
  ///             properly.
  jni.JniString createDocument(jni.JniString parentDocumentId,
          jni.JniString mimeType, jni.JniString displayName) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createDocument, jni.JniType.objectType, [
        parentDocumentId.reference,
        mimeType.reference,
        displayName.reference
      ]).object);

  static final _id_renameDocument = jniAccessors.getMethodIDOf(
      _classRef,
      "renameDocument",
      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String renameDocument(java.lang.String documentId, java.lang.String displayName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Rename an existing document.
  ///
  /// If a different Document\#COLUMN_DOCUMENT_ID must be used to
  /// represent the renamed document, generate and return it. Any outstanding
  /// URI permission grants will be updated to point at the new document. If
  /// the original Document\#COLUMN_DOCUMENT_ID is still valid after the
  /// rename, return {@code null}.
  ///@param documentId the document to rename.
  ///@param displayName the updated display name of the document. The provider
  ///            may alter this name to meet any internal constraints, such as
  ///            avoiding conflicting names.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  jni.JniString renameDocument(
          jni.JniString documentId, jni.JniString displayName) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_renameDocument,
          jni.JniType.objectType,
          [documentId.reference, displayName.reference]).object);

  static final _id_deleteDocument = jniAccessors.getMethodIDOf(
      _classRef, "deleteDocument", "(Ljava/lang/String;)V");

  /// from: public void deleteDocument(java.lang.String documentId)
  ///
  /// Delete the requested document.
  ///
  /// Upon returning, any URI permission grants for the given document will be
  /// revoked. If additional documents were deleted as a side effect of this
  /// call (such as documents inside a directory) the implementor is
  /// responsible for revoking those permissions using
  /// \#revokeDocumentPermission(String).
  ///@param documentId the document to delete.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  void deleteDocument(jni.JniString documentId) =>
      jniAccessors.callMethodWithArgs(reference, _id_deleteDocument,
          jni.JniType.voidType, [documentId.reference]).check();

  static final _id_copyDocument = jniAccessors.getMethodIDOf(
      _classRef,
      "copyDocument",
      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String copyDocument(java.lang.String sourceDocumentId, java.lang.String targetParentDocumentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy the requested document or a document tree.
  ///
  /// Copies a document including all child documents to another location within
  /// the same document provider. Upon completion returns the document id of
  /// the copied document at the target destination. {@code null} must never
  /// be returned.
  ///@param sourceDocumentId the document to copy.
  ///@param targetParentDocumentId the target document to be copied into as a child.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  jni.JniString copyDocument(jni.JniString sourceDocumentId,
          jni.JniString targetParentDocumentId) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_copyDocument, jni.JniType.objectType, [
        sourceDocumentId.reference,
        targetParentDocumentId.reference
      ]).object);

  static final _id_moveDocument = jniAccessors.getMethodIDOf(
      _classRef,
      "moveDocument",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String moveDocument(java.lang.String sourceDocumentId, java.lang.String sourceParentDocumentId, java.lang.String targetParentDocumentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Move the requested document or a document tree.
  ///
  /// Moves a document including all child documents to another location within
  /// the same document provider. Upon completion returns the document id of
  /// the copied document at the target destination. {@code null} must never
  /// be returned.
  ///
  /// It's the responsibility of the provider to revoke grants if the document
  /// is no longer accessible using <code>sourceDocumentId</code>.
  ///@param sourceDocumentId the document to move.
  ///@param sourceParentDocumentId the parent of the document to move.
  ///@param targetParentDocumentId the target document to be a new parent of the
  ///     source document.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  jni.JniString moveDocument(
          jni.JniString sourceDocumentId,
          jni.JniString sourceParentDocumentId,
          jni.JniString targetParentDocumentId) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_moveDocument, jni.JniType.objectType, [
        sourceDocumentId.reference,
        sourceParentDocumentId.reference,
        targetParentDocumentId.reference
      ]).object);

  static final _id_removeDocument = jniAccessors.getMethodIDOf(
      _classRef, "removeDocument", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void removeDocument(java.lang.String documentId, java.lang.String parentDocumentId)
  ///
  /// Removes the requested document or a document tree.
  ///
  /// In contrast to \#deleteDocument it requires specifying the parent.
  /// This method is especially useful if the document can be in multiple parents.
  ///
  /// It's the responsibility of the provider to revoke grants if the document is
  /// removed from the last parent, and effectively the document is deleted.
  ///@param documentId the document to remove.
  ///@param parentDocumentId the parent of the document to move.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  void removeDocument(
          jni.JniString documentId, jni.JniString parentDocumentId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeDocument,
          jni.JniType.voidType,
          [documentId.reference, parentDocumentId.reference]).check();

  static final _id_findDocumentPath = jniAccessors.getMethodIDOf(
      _classRef,
      "findDocumentPath",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/provider/DocumentsContract\$Path;");

  /// from: public android.provider.DocumentsContract.Path findDocumentPath(java.lang.String parentDocumentId, java.lang.String childDocumentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds the canonical path for the requested document. The path must start
  /// from the parent document if parentDocumentId is not null or the root document
  /// if parentDocumentId is null. If there are more than one path to this document,
  /// return the most typical one. Include both the parent document or root document
  /// and the requested document in the returned path.
  ///
  /// This API assumes that document ID has enough info to infer the root.
  /// Different roots should use different document ID to refer to the same
  /// document.
  ///@param parentDocumentId the document from which the path starts if not null,
  ///     or null to indicate a path from the root is requested.
  /// This value may be {@code null}.
  ///@param childDocumentId the document which path is requested.
  ///@return the path of the requested document. If parentDocumentId is null
  ///     returned root ID must not be null. If parentDocumentId is not null
  ///     returned root ID must be null.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  documentscontract_.DocumentsContract_Path findDocumentPath(
          jni.JniString parentDocumentId, jni.JniString childDocumentId) =>
      documentscontract_.DocumentsContract_Path.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_findDocumentPath,
              jni.JniType.objectType,
              [parentDocumentId.reference, childDocumentId.reference]).object);

  static final _id_createWebLinkIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "createWebLinkIntent",
      "(Ljava/lang/String;Landroid/os/Bundle;)Landroid/content/IntentSender;");

  /// from: public android.content.IntentSender createWebLinkIntent(java.lang.String documentId, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an intent sender for a web link, if the document is web linkable.
  ///
  /// AuthenticationRequiredException can be thrown if user does not have
  /// sufficient permission for the linked document. Before any new permissions
  /// are granted for the linked document, a visible UI must be shown, so the
  /// user can explicitly confirm whether the permission grants are expected.
  /// The user must be able to cancel the operation.
  ///
  /// Options passed as an argument may include a list of recipients, such
  /// as email addresses. The provider should reflect these options if possible,
  /// but it's acceptable to ignore them. In either case, confirmation UI must
  /// be shown before any new permission grants are granted.
  ///
  /// It is all right to generate a web link without granting new permissions,
  /// if opening the link would result in a page for requesting permission
  /// access. If it's impossible then the operation must fail by throwing an exception.
  ///@param documentId the document to create a web link intent for.
  ///@param options additional information, such as list of recipients. Optional.
  /// This value may be {@code null}.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  ///@see DocumentsContract.Document\#FLAG_WEB_LINKABLE
  ///@see android.app.PendingIntent\#getIntentSender
  intentsender_.IntentSender createWebLinkIntent(
          jni.JniString documentId, bundle_.Bundle options) =>
      intentsender_.IntentSender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createWebLinkIntent,
          jni.JniType.objectType,
          [documentId.reference, options.reference]).object);

  static final _id_queryRoots = jniAccessors.getMethodIDOf(_classRef,
      "queryRoots", "([Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public abstract android.database.Cursor queryRoots(java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return all roots currently provided. To display to users, you must define
  /// at least one root. You should avoid making network requests to keep this
  /// request fast.
  ///
  /// Each root is defined by the metadata columns described in Root,
  /// including Root\#COLUMN_DOCUMENT_ID which points to a directory
  /// representing a tree of documents to display under that root.
  ///
  /// If this set of roots changes, you must call ContentResolver\#notifyChange(Uri,
  /// android.database.ContentObserver, boolean) with
  /// DocumentsContract\#buildRootsUri(String) to notify the system.
  ///
  ///@param projection list of Root columns to put into the cursor. If
  ///            {@code null} all supported columns should be included.
  cursor_.Cursor queryRoots(jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryRoots,
          jni.JniType.objectType,
          [projection.reference]).object);

  static final _id_queryRecentDocuments = jniAccessors.getMethodIDOf(
      _classRef,
      "queryRecentDocuments",
      "(Ljava/lang/String;[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor queryRecentDocuments(java.lang.String rootId, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return recently modified documents under the requested root. This will
  /// only be called for roots that advertise
  /// Root\#FLAG_SUPPORTS_RECENTS. The returned documents should be
  /// sorted by Document\#COLUMN_LAST_MODIFIED in descending order, and
  /// limited to only return the 64 most recently modified documents.
  ///
  /// Recent documents do not support change notifications.
  ///@param projection list of Document columns to put into the
  ///            cursor. If {@code null} all supported columns should be
  ///            included.
  ///@see DocumentsContract\#EXTRA_LOADING
  cursor_.Cursor queryRecentDocuments(
          jni.JniString rootId, jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryRecentDocuments,
          jni.JniType.objectType,
          [rootId.reference, projection.reference]).object);

  static final _id_queryDocument = jniAccessors.getMethodIDOf(
      _classRef,
      "queryDocument",
      "(Ljava/lang/String;[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public abstract android.database.Cursor queryDocument(java.lang.String documentId, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return metadata for the single requested document. You should avoid
  /// making network requests to keep this request fast.
  ///@param documentId the document to return.
  ///@param projection list of Document columns to put into the
  ///            cursor. If {@code null} all supported columns should be
  ///            included.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  cursor_.Cursor queryDocument(
          jni.JniString documentId, jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryDocument,
          jni.JniType.objectType,
          [documentId.reference, projection.reference]).object);

  static final _id_queryChildDocuments = jniAccessors.getMethodIDOf(
      _classRef,
      "queryChildDocuments",
      "(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public abstract android.database.Cursor queryChildDocuments(java.lang.String parentDocumentId, java.lang.String[] projection, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the children documents contained in the requested directory. This
  /// must only return immediate descendants, as additional queries will be
  /// issued to recursively explore the tree.
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher
  /// should override \#queryChildDocuments(String, String[], Bundle).
  ///
  /// If your provider is cloud-based, and you have some data cached or pinned
  /// locally, you may return the local data immediately, setting
  /// DocumentsContract\#EXTRA_LOADING on the Cursor to indicate that
  /// you are still fetching additional data. Then, when the network data is
  /// available, you can send a change notification to trigger a requery and
  /// return the complete contents. To return a Cursor with extras, you need to
  /// extend and override Cursor\#getExtras().
  ///
  /// To support change notifications, you must
  /// Cursor\#setNotificationUri(ContentResolver, Uri) with a relevant
  /// Uri, such as
  /// DocumentsContract\#buildChildDocumentsUri(String, String). Then
  /// you can call ContentResolver\#notifyChange(Uri,
  /// android.database.ContentObserver, boolean) with that Uri to send change
  /// notifications.
  ///@param parentDocumentId the directory to return children for.
  ///@param projection list of Document columns to put into the
  ///            cursor. If {@code null} all supported columns should be
  ///            included.
  ///@param sortOrder how to order the rows, formatted as an SQL
  ///            {@code ORDER BY} clause (excluding the ORDER BY itself).
  ///            Passing {@code null} will use the default sort order, which
  ///            may be unordered. This ordering is a hint that can be used to
  ///            prioritize how data is fetched from the network, but UI may
  ///            always enforce a specific ordering.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  ///@see DocumentsContract\#EXTRA_LOADING
  ///@see DocumentsContract\#EXTRA_INFO
  ///@see DocumentsContract\#EXTRA_ERROR
  cursor_.Cursor queryChildDocuments(jni.JniString parentDocumentId,
          jni.JniObject projection, jni.JniString sortOrder) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_queryChildDocuments, jni.JniType.objectType, [
        parentDocumentId.reference,
        projection.reference,
        sortOrder.reference
      ]).object);

  static final _id_queryChildDocuments1 = jniAccessors.getMethodIDOf(
      _classRef,
      "queryChildDocuments",
      "(Ljava/lang/String;[Ljava/lang/String;Landroid/os/Bundle;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor queryChildDocuments(java.lang.String parentDocumentId, java.lang.String[] projection, android.os.Bundle queryArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override this method to return the children documents contained
  /// in the requested directory. This must return immediate descendants only.
  ///
  /// If your provider is cloud-based, and you have data cached
  /// locally, you may return the local data immediately, setting
  /// DocumentsContract\#EXTRA_LOADING on Cursor extras to indicate that
  /// you are still fetching additional data. Then, when the network data is
  /// available, you can send a change notification to trigger a requery and
  /// return the complete contents. To return a Cursor with extras, you need to
  /// extend and override Cursor\#getExtras().
  ///
  /// To support change notifications, you must
  /// Cursor\#setNotificationUri(ContentResolver, Uri) with a relevant
  /// Uri, such as
  /// DocumentsContract\#buildChildDocumentsUri(String, String). Then
  /// you can call ContentResolver\#notifyChange(Uri,
  /// android.database.ContentObserver, boolean) with that Uri to send change
  /// notifications.
  ///@param parentDocumentId the directory to return children for.
  ///@param projection list of Document columns to put into the
  ///            cursor. If {@code null} all supported columns should be
  ///            included.
  /// This value may be {@code null}.
  ///@param queryArgs Bundle containing sorting information or other
  ///            argument useful to the provider. If no sorting
  ///            information is available, default sorting
  ///            will be used, which may be unordered. See
  ///            ContentResolver\#QUERY_ARG_SORT_COLUMNS for
  ///            details.
  /// This value may be {@code null}.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  ///@see DocumentsContract\#EXTRA_LOADING
  ///@see DocumentsContract\#EXTRA_INFO
  ///@see DocumentsContract\#EXTRA_ERROR
  cursor_.Cursor queryChildDocuments1(jni.JniString parentDocumentId,
          jni.JniObject projection, bundle_.Bundle queryArgs) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_queryChildDocuments1, jni.JniType.objectType, [
        parentDocumentId.reference,
        projection.reference,
        queryArgs.reference
      ]).object);

  static final _id_querySearchDocuments = jniAccessors.getMethodIDOf(
      _classRef,
      "querySearchDocuments",
      "(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor querySearchDocuments(java.lang.String rootId, java.lang.String query, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return documents that match the given query under the requested
  /// root. The returned documents should be sorted by relevance in descending
  /// order. How documents are matched against the query string is an
  /// implementation detail left to each provider, but it's suggested that at
  /// least Document\#COLUMN_DISPLAY_NAME be matched in a
  /// case-insensitive fashion.
  ///
  /// If your provider is cloud-based, and you have some data cached or pinned
  /// locally, you may return the local data immediately, setting
  /// DocumentsContract\#EXTRA_LOADING on the Cursor to indicate that
  /// you are still fetching additional data. Then, when the network data is
  /// available, you can send a change notification to trigger a requery and
  /// return the complete contents.
  ///
  /// To support change notifications, you must
  /// Cursor\#setNotificationUri(ContentResolver, Uri) with a relevant
  /// Uri, such as DocumentsContract\#buildSearchDocumentsUri(String,
  /// String, String). Then you can call ContentResolver\#notifyChange(Uri,
  /// android.database.ContentObserver, boolean) with that Uri to send change
  /// notifications.
  ///@param rootId the root to search under.
  ///@param query string to match documents against.
  ///@param projection list of Document columns to put into the
  ///            cursor. If {@code null} all supported columns should be
  ///            included.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  ///@see DocumentsContract\#EXTRA_LOADING
  ///@see DocumentsContract\#EXTRA_INFO
  ///@see DocumentsContract\#EXTRA_ERROR
  cursor_.Cursor querySearchDocuments(jni.JniString rootId, jni.JniString query,
          jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_querySearchDocuments,
          jni.JniType.objectType,
          [rootId.reference, query.reference, projection.reference]).object);

  static final _id_ejectRoot = jniAccessors.getMethodIDOf(
      _classRef, "ejectRoot", "(Ljava/lang/String;)V");

  /// from: public void ejectRoot(java.lang.String rootId)
  ///
  /// Ejects the root. Throws IllegalStateException if ejection failed.
  ///@param rootId the root to be ejected.
  ///@see Root\#FLAG_SUPPORTS_EJECT
  void ejectRoot(jni.JniString rootId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_ejectRoot,
      jni.JniType.voidType,
      [rootId.reference]).check();

  static final _id_getDocumentType = jniAccessors.getMethodIDOf(
      _classRef, "getDocumentType", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getDocumentType(java.lang.String documentId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return concrete MIME type of the requested document. Must match the value
  /// of Document\#COLUMN_MIME_TYPE for this document. The default
  /// implementation queries \#queryDocument(String, String[]), so
  /// providers may choose to override this as an optimization.
  ///
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  jni.JniString getDocumentType(jni.JniString documentId) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDocumentType,
          jni.JniType.objectType,
          [documentId.reference]).object);

  static final _id_openDocument = jniAccessors.getMethodIDOf(
      _classRef,
      "openDocument",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/os/ParcelFileDescriptor;");

  /// from: public abstract android.os.ParcelFileDescriptor openDocument(java.lang.String documentId, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open and return the requested document.
  ///
  /// Your provider should return a reliable ParcelFileDescriptor to
  /// detect when the remote caller has finished reading or writing the
  /// document.
  ///
  /// Mode "r" should always be supported. Provider should throw
  /// UnsupportedOperationException if the passing mode is not supported.
  /// You may return a pipe or socket pair if the mode is exclusively "r" or
  /// "w", but complex modes like "rw" imply a normal file on disk that
  /// supports seeking.
  ///
  /// If you block while downloading content, you should periodically check
  /// CancellationSignal\#isCanceled() to abort abandoned open requests.
  ///@param documentId the document to return.
  ///@param mode the mode to open with, such as 'r', 'w', or 'rw'.
  ///@param signal used by the caller to signal if the request should be
  ///            cancelled. May be null.
  /// This value may be {@code null}.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  ///@see ParcelFileDescriptor\#open(java.io.File, int, android.os.Handler,
  ///      OnCloseListener)
  ///@see ParcelFileDescriptor\#createReliablePipe()
  ///@see ParcelFileDescriptor\#createReliableSocketPair()
  ///@see ParcelFileDescriptor\#parseMode(String)
  parcelfiledescriptor_.ParcelFileDescriptor openDocument(
          jni.JniString documentId,
          jni.JniString mode,
          cancellationsignal_.CancellationSignal signal) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_openDocument,
              jni.JniType.objectType,
              [documentId.reference, mode.reference, signal.reference]).object);

  static final _id_openDocumentThumbnail = jniAccessors.getMethodIDOf(
      _classRef,
      "openDocumentThumbnail",
      "(Ljava/lang/String;Landroid/graphics/Point;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openDocumentThumbnail(java.lang.String documentId, android.graphics.Point sizeHint, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open and return a thumbnail of the requested document.
  ///
  /// A provider should return a thumbnail closely matching the hinted size,
  /// attempting to serve from a local cache if possible. A provider should
  /// never return images more than double the hinted size.
  ///
  /// If you perform expensive operations to download or generate a thumbnail,
  /// you should periodically check CancellationSignal\#isCanceled() to
  /// abort abandoned thumbnail requests.
  ///@param documentId the document to return.
  ///@param sizeHint hint of the optimal thumbnail dimensions.
  ///@param signal used by the caller to signal if the request should be
  ///            cancelled. May be null.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  ///@see Document\#FLAG_SUPPORTS_THUMBNAIL
  assetfiledescriptor_.AssetFileDescriptor openDocumentThumbnail(
          jni.JniString documentId,
          point_.Point sizeHint,
          cancellationsignal_.CancellationSignal signal) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_openDocumentThumbnail, jni.JniType.objectType, [
        documentId.reference,
        sizeHint.reference,
        signal.reference
      ]).object);

  static final _id_openTypedDocument = jniAccessors.getMethodIDOf(
      _classRef,
      "openTypedDocument",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openTypedDocument(java.lang.String documentId, java.lang.String mimeTypeFilter, android.os.Bundle opts, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open and return the document in a format matching the specified MIME
  /// type filter.
  ///
  /// A provider may perform a conversion if the documents's MIME type is not
  /// matching the specified MIME type filter.
  ///
  /// Virtual documents must have at least one streamable format.
  ///@param documentId the document to return.
  ///@param mimeTypeFilter the MIME type filter for the requested format. May
  ///            be *\/*, which matches any MIME type.
  ///@param opts extra options from the client. Specific to the content
  ///            provider.
  ///@param signal used by the caller to signal if the request should be
  ///            cancelled. May be null.
  ///@throws AuthenticationRequiredException If authentication is required from
  ///            the user (such as login credentials), but it is not guaranteed
  ///            that the client will handle this properly.
  ///@see \#getDocumentStreamTypes(String, String)
  assetfiledescriptor_.AssetFileDescriptor openTypedDocument(
          jni.JniString documentId,
          jni.JniString mimeTypeFilter,
          bundle_.Bundle opts,
          cancellationsignal_.CancellationSignal signal) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_openTypedDocument, jni.JniType.objectType, [
        documentId.reference,
        mimeTypeFilter.reference,
        opts.reference,
        signal.reference
      ]).object);

  static final _id_query = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  cursor_.Cursor query(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference
      ]).object);

  static final _id_query1 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// WARNING: Sub-classes should not override this method. This method is non-final
  /// solely for the purposes of backwards compatibility.
  ///@see \#queryChildDocuments(String, String[], Bundle),
  ///      \#queryDocument(String, String[]),
  ///      \#queryRecentDocuments(String, String[]),
  ///      \#queryRoots(String[]), and
  ///      \#querySearchDocuments(String, String, String[]).
  cursor_.Cursor query1(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query1, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_query2 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, android.os.Bundle queryArgs, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Cannot be overriden.
  ///@see \#queryRoots(String[])
  ///@see \#queryRecentDocuments(String, String[])
  ///@see \#queryDocument(String, String[])
  ///@see \#queryChildDocuments(String, String[], String)
  ///@see \#querySearchDocuments(String, String, String[])
  cursor_.Cursor query2(
          uri_.Uri uri,
          jni.JniObject projection,
          bundle_.Bundle queryArgs,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query2, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        queryArgs.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_getType = jniAccessors.getMethodIDOf(
      _classRef, "getType", "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: public final java.lang.String getType(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Cannot be overriden.
  ///@see \#getDocumentType(String)
  jni.JniString getType(uri_.Uri uri) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getType, jni.JniType.objectType, [uri.reference]).object);

  static final _id_canonicalize = jniAccessors.getMethodIDOf(
      _classRef, "canonicalize", "(Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: public android.net.Uri canonicalize(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Can be overridden to
  /// provide additional functionality, but subclasses _must_ always
  /// call the superclass. If the superclass returns {@code null}, the subclass
  /// may implement custom behavior.
  ///
  /// This is typically used to resolve a subtree URI into a concrete document
  /// reference, issuing a narrower single-document URI permission grant along
  /// the way.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see DocumentsContract\#buildDocumentUriUsingTree(Uri, String)
  uri_.Uri canonicalize(uri_.Uri uri) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_canonicalize, jni.JniType.objectType, [uri.reference]).object);

  static final _id_insert = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(Landroid/net/Uri;Landroid/content/ContentValues;)Landroid/net/Uri;");

  /// from: public final android.net.Uri insert(android.net.Uri uri, android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Throws by default, and
  /// cannot be overriden.
  ///@see \#createDocument(String, String, String)
  uri_.Uri insert(uri_.Uri uri, contentvalues_.ContentValues values) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference, _id_insert,
          jni.JniType.objectType, [uri.reference, values.reference]).object);

  static final _id_delete1 = jniAccessors.getMethodIDOf(_classRef, "delete",
      "(Landroid/net/Uri;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public final int delete(android.net.Uri uri, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// Implementation is provided by the parent class. Throws by default, and
  /// cannot be overriden.
  ///@see \#deleteDocument(String)
  int delete1(
          uri_.Uri uri, jni.JniString selection, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_delete1, jni.JniType.intType, [
        uri.reference,
        selection.reference,
        selectionArgs.reference
      ]).integer;

  static final _id_update = jniAccessors.getMethodIDOf(_classRef, "update",
      "(Landroid/net/Uri;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public final int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// Implementation is provided by the parent class. Throws by default, and
  /// cannot be overriden.
  int update(uri_.Uri uri, contentvalues_.ContentValues values,
          jni.JniString selection, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_update, jni.JniType.intType, [
        uri.reference,
        values.reference,
        selection.reference,
        selectionArgs.reference
      ]).integer;

  static final _id_call = jniAccessors.getMethodIDOf(_classRef, "call",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle call(java.lang.String method, java.lang.String arg, android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Can be overridden to
  /// provide additional functionality, but subclasses _must_ always
  /// call the superclass. If the superclass returns {@code null}, the subclass
  /// may implement custom behavior.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  bundle_.Bundle call(
          jni.JniString method, jni.JniString arg, bundle_.Bundle extras) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_call,
          jni.JniType.objectType,
          [method.reference, arg.reference, extras.reference]).object);

  static final _id_revokeDocumentPermission = jniAccessors.getMethodIDOf(
      _classRef, "revokeDocumentPermission", "(Ljava/lang/String;)V");

  /// from: public final void revokeDocumentPermission(java.lang.String documentId)
  ///
  /// Revoke any active permission grants for the given
  /// Document\#COLUMN_DOCUMENT_ID, usually called when a document
  /// becomes invalid. Follows the same semantics as
  /// Context\#revokeUriPermission(Uri, int).
  void revokeDocumentPermission(jni.JniString documentId) =>
      jniAccessors.callMethodWithArgs(reference, _id_revokeDocumentPermission,
          jni.JniType.voidType, [documentId.reference]).check();

  static final _id_openFile = jniAccessors.getMethodIDOf(_classRef, "openFile",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;");

  /// from: public final android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Cannot be overriden.
  ///@see \#openDocument(String, String, CancellationSignal)
  parcelfiledescriptor_.ParcelFileDescriptor openFile(
          uri_.Uri uri, jni.JniString mode) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openFile, jni.JniType.objectType,
              [uri.reference, mode.reference]).object);

  static final _id_openFile1 = jniAccessors.getMethodIDOf(_classRef, "openFile",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/os/ParcelFileDescriptor;");

  /// from: public final android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Cannot be overriden.
  ///@see \#openDocument(String, String, CancellationSignal)
  parcelfiledescriptor_.ParcelFileDescriptor openFile1(uri_.Uri uri,
          jni.JniString mode, cancellationsignal_.CancellationSignal signal) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openFile1, jni.JniType.objectType,
              [uri.reference, mode.reference, signal.reference]).object);

  static final _id_openAssetFile = jniAccessors.getMethodIDOf(
      _classRef,
      "openAssetFile",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public final android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Cannot be overriden.
  ///@see \#openDocument(String, String, CancellationSignal)
  assetfiledescriptor_.AssetFileDescriptor openAssetFile(
          uri_.Uri uri, jni.JniString mode) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openAssetFile,
              jni.JniType.objectType, [uri.reference, mode.reference]).object);

  static final _id_openAssetFile1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openAssetFile",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public final android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Cannot be overriden.
  ///@see \#openDocument(String, String, CancellationSignal)
  assetfiledescriptor_.AssetFileDescriptor openAssetFile1(uri_.Uri uri,
          jni.JniString mode, cancellationsignal_.CancellationSignal signal) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_openAssetFile1,
              jni.JniType.objectType,
              [uri.reference, mode.reference, signal.reference]).object);

  static final _id_openTypedAssetFile = jniAccessors.getMethodIDOf(
      _classRef,
      "openTypedAssetFile",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFile(android.net.Uri uri, java.lang.String mimeTypeFilter, android.os.Bundle opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Cannot be overriden.
  ///@see \#openDocumentThumbnail(String, Point, CancellationSignal)
  ///@see \#openTypedDocument(String, String, Bundle, CancellationSignal)
  ///@see \#getDocumentStreamTypes(String, String)
  assetfiledescriptor_.AssetFileDescriptor openTypedAssetFile(
          uri_.Uri uri, jni.JniString mimeTypeFilter, bundle_.Bundle opts) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_openTypedAssetFile, jni.JniType.objectType, [
        uri.reference,
        mimeTypeFilter.reference,
        opts.reference
      ]).object);

  static final _id_openTypedAssetFile1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openTypedAssetFile",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFile(android.net.Uri uri, java.lang.String mimeTypeFilter, android.os.Bundle opts, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementation is provided by the parent class. Cannot be overriden.
  ///@see \#openDocumentThumbnail(String, Point, CancellationSignal)
  ///@see \#openTypedDocument(String, String, Bundle, CancellationSignal)
  ///@see \#getDocumentStreamTypes(String, String)
  assetfiledescriptor_.AssetFileDescriptor openTypedAssetFile1(
          uri_.Uri uri,
          jni.JniString mimeTypeFilter,
          bundle_.Bundle opts,
          cancellationsignal_.CancellationSignal signal) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_openTypedAssetFile1, jni.JniType.objectType, [
        uri.reference,
        mimeTypeFilter.reference,
        opts.reference,
        signal.reference
      ]).object);

  static final _id_getDocumentStreamTypes = jniAccessors.getMethodIDOf(
      _classRef,
      "getDocumentStreamTypes",
      "(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getDocumentStreamTypes(java.lang.String documentId, java.lang.String mimeTypeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of streamable MIME types matching the filter, which can be passed to
  /// \#openTypedDocument(String, String, Bundle, CancellationSignal).
  ///
  /// The default implementation returns a MIME type provided by
  /// \#queryDocument(String, String[]) as long as it matches the filter and the document
  /// does not have the Document\#FLAG_VIRTUAL_DOCUMENT flag set.
  ///
  /// Virtual documents must have at least one streamable format.
  ///@see \#getStreamTypes(Uri, String)
  ///@see \#openTypedDocument(String, String, Bundle, CancellationSignal)
  jni.JniObject getDocumentStreamTypes(
          jni.JniString documentId, jni.JniString mimeTypeFilter) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDocumentStreamTypes,
          jni.JniType.objectType,
          [documentId.reference, mimeTypeFilter.reference]).object);

  static final _id_getStreamTypes = jniAccessors.getMethodIDOf(
      _classRef,
      "getStreamTypes",
      "(Landroid/net/Uri;Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getStreamTypes(android.net.Uri uri, java.lang.String mimeTypeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a client to determine the types of data streams that this content provider
  /// support for the given URI.
  ///
  /// Overriding this method is deprecated. Override \#openTypedDocument instead.
  ///@see \#getDocumentStreamTypes(String, String)
  jni.JniObject getStreamTypes(uri_.Uri uri, jni.JniString mimeTypeFilter) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStreamTypes,
          jni.JniType.objectType,
          [uri.reference, mimeTypeFilter.reference]).object);
}
