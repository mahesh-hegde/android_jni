// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../content/ContentResolver.dart" as contentresolver_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.SearchRecentSuggestions
///
/// This is a utility class providing access to
/// android.content.SearchRecentSuggestionsProvider.
///
/// Unlike some utility classes, this one must be instantiated and properly initialized, so that
/// it can be configured to operate with the search suggestions provider that you have created.
///
/// Typically, you will do this in your searchable activity, each time you receive an incoming
/// android.content.Intent\#ACTION_SEARCH ACTION_SEARCH Intent.  The code to record each
/// incoming query is as follows:
/// <pre class="prettyprint">
///      SearchSuggestions suggestions = new SearchSuggestions(this,
///              MySuggestionsProvider.AUTHORITY, MySuggestionsProvider.MODE);
///      suggestions.saveRecentQuery(queryString, null);
/// </pre>
///
/// For a working example, see SearchSuggestionSampleProvider and SearchQueryResults in
/// samples/ApiDemos/app.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about using search suggestions in your application, read the
/// <a href="{@docRoot}guide/topics/search/adding-recent-query-suggestions.html">Adding Recent Query
/// Suggestions</a> developer guide.
///
/// </div>
class SearchRecentSuggestions extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/SearchRecentSuggestions");
  SearchRecentSuggestions.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_QUERIES_PROJECTION_1LINE = jniAccessors.getStaticFieldIDOf(
      _classRef, "QUERIES_PROJECTION_1LINE", "[Ljava/lang/String;");

  /// from: static public final java.lang.String[] QUERIES_PROJECTION_1LINE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is the database projection that can be used to view saved queries, when
  /// configured for one-line operation.
  static jni.JniObject get QUERIES_PROJECTION_1LINE =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_QUERIES_PROJECTION_1LINE, jni.JniType.objectType)
          .object);

  static final _id_QUERIES_PROJECTION_2LINE = jniAccessors.getStaticFieldIDOf(
      _classRef, "QUERIES_PROJECTION_2LINE", "[Ljava/lang/String;");

  /// from: static public final java.lang.String[] QUERIES_PROJECTION_2LINE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is the database projection that can be used to view saved queries, when
  /// configured for two-line operation.
  static jni.JniObject get QUERIES_PROJECTION_2LINE =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_QUERIES_PROJECTION_2LINE, jni.JniType.objectType)
          .object);

  /// from: static public final int QUERIES_PROJECTION_DATE_INDEX
  ///
  /// Index into the provided query projections.  For use with Cursor.update methods.
  static const QUERIES_PROJECTION_DATE_INDEX = 1;

  /// from: static public final int QUERIES_PROJECTION_DISPLAY1_INDEX
  ///
  /// Index into the provided query projections.  For use with Cursor.update methods.
  static const QUERIES_PROJECTION_DISPLAY1_INDEX = 3;

  /// from: static public final int QUERIES_PROJECTION_DISPLAY2_INDEX
  ///
  /// Index into the provided query projections.  For use with Cursor.update methods.
  static const QUERIES_PROJECTION_DISPLAY2_INDEX = 4;

  /// from: static public final int QUERIES_PROJECTION_QUERY_INDEX
  ///
  /// Index into the provided query projections.  For use with Cursor.update methods.
  static const QUERIES_PROJECTION_QUERY_INDEX = 2;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Ljava/lang/String;I)V");

  /// from: public void <init>(android.content.Context context, java.lang.String authority, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Although provider utility classes are typically static, this one must be constructed
  /// because it needs to be initialized using the same values that you provided in your
  /// android.content.SearchRecentSuggestionsProvider.
  ///@param authority This must match the authority that you've declared in your manifest.
  ///@param mode You can use mode flags here to determine certain functional aspects of your
  /// database.  Note, this value should not change from run to run, because when it does change,
  /// your suggestions database may be wiped.
  ///@see android.content.SearchRecentSuggestionsProvider
  ///@see android.content.SearchRecentSuggestionsProvider\#setupSuggestions
  SearchRecentSuggestions(
      context_.Context context, jni.JniString authority, int mode)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [context.reference, authority.reference, mode]).object);

  static final _id_saveRecentQuery = jniAccessors.getMethodIDOf(
      _classRef, "saveRecentQuery", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void saveRecentQuery(java.lang.String queryString, java.lang.String line2)
  ///
  /// Add a query to the recent queries list.  Returns immediately, performing the save
  /// in the background.
  ///@param queryString The string as typed by the user.  This string will be displayed as
  /// the suggestion, and if the user clicks on the suggestion, this string will be sent to your
  /// searchable activity (as a new search query).
  ///@param line2 If you have configured your recent suggestions provider with
  /// android.content.SearchRecentSuggestionsProvider\#DATABASE_MODE_2LINES, you can
  /// pass a second line of text here.  It will be shown in a smaller font, below the primary
  /// suggestion.  When typing, matches in either line of text will be displayed in the list.
  /// If you did not configure two-line mode, or if a given suggestion does not have any
  /// additional text to display, you can pass null here.
  void saveRecentQuery(jni.JniString queryString, jni.JniString line2) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_saveRecentQuery,
          jni.JniType.voidType,
          [queryString.reference, line2.reference]).check();

  static final _id_clearHistory =
      jniAccessors.getMethodIDOf(_classRef, "clearHistory", "()V");

  /// from: public void clearHistory()
  ///
  /// Completely delete the history.  Use this call to implement a "clear history" UI.
  ///
  /// Any application that implements search suggestions based on previous actions (such as
  /// recent queries, page/items viewed, etc.) should provide a way for the user to clear the
  /// history.  This gives the user a measure of privacy, if they do not wish for their recent
  /// searches to be replayed by other users of the device (via suggestions).
  void clearHistory() => jniAccessors.callMethodWithArgs(
      reference, _id_clearHistory, jni.JniType.voidType, []).check();

  static final _id_truncateHistory = jniAccessors.getMethodIDOf(
      _classRef, "truncateHistory", "(Landroid/content/ContentResolver;I)V");

  /// from: protected void truncateHistory(android.content.ContentResolver cr, int maxEntries)
  ///
  /// Reduces the length of the history table, to prevent it from growing too large.
  ///@param cr Convenience copy of the content resolver.
  ///@param maxEntries Max entries to leave in the table. 0 means remove all entries.
  void truncateHistory(contentresolver_.ContentResolver cr, int maxEntries) =>
      jniAccessors.callMethodWithArgs(reference, _id_truncateHistory,
          jni.JniType.voidType, [cr.reference, maxEntries]).check();
}
