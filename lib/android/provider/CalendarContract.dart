// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../net/Uri.dart" as uri_;

import "../database/Cursor.dart" as cursor_;

import "../content/ContentResolver.dart" as contentresolver_;

import "../content/EntityIterator.dart" as entityiterator_;

import "../content/ContentProviderClient.dart" as contentproviderclient_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.CalendarContract
///
///
/// The contract between the calendar provider and applications. Contains
/// definitions for the supported URIs and data columns.
///
///
/// <h3>Overview</h3>
///
/// CalendarContract defines the data model of calendar and event related
/// information. This data is stored in a number of tables:
///
///
/// <ul>
/// <li>The Calendars table holds the calendar specific information. Each
/// row in this table contains the details for a single calendar, such as the
/// name, color, sync info, etc.</li>
/// <li>The Events table holds the event specific information. Each row
/// in this table has the info for a single event. It contains information such
/// as event title, location, start time, end time, etc. The event can occur
/// one-time or can recur multiple times. Attendees, reminders, and extended
/// properties are stored on separate tables and reference the Events\#_ID
/// to link them with the event.</li>
/// <li>The Instances table holds the start and end time for occurrences
/// of an event. Each row in this table represents a single occurrence. For
/// one-time events there will be a 1:1 mapping of instances to events. For
/// recurring events, multiple rows will automatically be generated which
/// correspond to multiple occurrences of that event.</li>
/// <li>The Attendees table holds the event attendee or guest
/// information. Each row represents a single guest of an event. It specifies the
/// type of guest they are and their attendance response for the event.</li>
/// <li>The Reminders table holds the alert/notification data. Each row
/// represents a single alert for an event. An event can have multiple reminders.
/// The number of reminders per event is specified in
/// Calendars\#MAX_REMINDERS which is set by the Sync Adapter that owns
/// the given calendar. Reminders are specified in minutes before the event and
/// have a type.</li>
/// <li>The ExtendedProperties table holds opaque data fields used by the
/// sync adapter. The provider takes no action with items in this table except to
/// delete them when their related events are deleted.</li>
/// </ul>
///
/// Other tables include:
///
///
/// <ul>
/// <li>
/// SyncState, which contains free-form data maintained by the sync
/// adapters</li>
/// </ul>
class CalendarContract extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract");
  CalendarContract.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACCOUNT_TYPE_LOCAL
  ///
  /// A special account type for calendars not associated with any account.
  /// Normally calendars that do not match an account on the device will be
  /// removed. Setting the account_type on a calendar to this will prevent it
  /// from being wiped if it does not match an existing account.
  ///@see SyncColumns\#ACCOUNT_TYPE
  static const ACCOUNT_TYPE_LOCAL = "LOCAL";

  /// from: static public final java.lang.String ACTION_EVENT_REMINDER
  ///
  /// Broadcast Action: This is the intent that gets fired when an alarm
  /// notification needs to be posted for a reminder.
  static const ACTION_EVENT_REMINDER = "android.intent.action.EVENT_REMINDER";

  /// from: static public final java.lang.String ACTION_HANDLE_CUSTOM_EVENT
  ///
  /// Activity Action: Display the event to the user in the custom app as
  /// specified in EventsColumns\#CUSTOM_APP_PACKAGE. The custom app
  /// will be started via Activity\#startActivityForResult(Intent, int)
  /// and it should call Activity\#setResult(int) with
  /// Activity\#RESULT_OK or Activity\#RESULT_CANCELED to
  /// acknowledge whether the action was handled or not.
  ///
  /// The custom app should have an intent filter like the following:
  /// <pre>
  /// &lt;intent-filter&gt;
  ///    &lt;action android:name="android.provider.calendar.action.HANDLE_CUSTOM_EVENT" /&gt;
  ///    &lt;category android:name="android.intent.category.DEFAULT" /&gt;
  ///    &lt;data android:mimeType="vnd.android.cursor.item/event" /&gt;
  /// &lt;/intent-filter&gt;</pre>
  ///
  /// Input: Intent\#getData has the event URI. The extra
  /// \#EXTRA_EVENT_BEGIN_TIME has the start time of the instance. The
  /// extra \#EXTRA_CUSTOM_APP_URI will have the
  /// EventsColumns\#CUSTOM_APP_URI.
  ///
  /// Output: Activity\#RESULT_OK if this was handled; otherwise
  /// Activity\#RESULT_CANCELED.
  static const ACTION_HANDLE_CUSTOM_EVENT =
      "android.provider.calendar.action.HANDLE_CUSTOM_EVENT";

  /// from: static public final java.lang.String AUTHORITY
  ///
  /// This authority is used for writing to or querying from the calendar
  /// provider. Note: This is set at first run and cannot be changed without
  /// breaking apps that access the provider.
  static const AUTHORITY = "com.android.calendar";

  /// from: static public final java.lang.String CALLER_IS_SYNCADAPTER
  ///
  /// An optional insert, update or delete URI parameter that allows the caller
  /// to specify that it is a sync adapter. The default value is false. If set
  /// to true, the modified row is not marked as "dirty" (needs to be synced)
  /// and when the provider calls
  /// ContentResolver\#notifyChange(android.net.Uri, android.database.ContentObserver, boolean)
  /// , the third parameter "syncToNetwork" is set to false. Furthermore, if
  /// set to true, the caller must also include
  /// Calendars\#ACCOUNT_NAME and Calendars\#ACCOUNT_TYPE as
  /// query parameters.
  ///@see Uri.Builder\#appendQueryParameter(java.lang.String, java.lang.String)
  static const CALLER_IS_SYNCADAPTER = "caller_is_syncadapter";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for the top-level calendar authority
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String EXTRA_CUSTOM_APP_URI
  ///
  /// Intent Extras key: EventsColumns\#CUSTOM_APP_URI for the event in
  /// the \#ACTION_HANDLE_CUSTOM_EVENT intent
  static const EXTRA_CUSTOM_APP_URI = "customAppUri";

  /// from: static public final java.lang.String EXTRA_EVENT_ALL_DAY
  ///
  /// Intent Extras key: When creating an event, set this to true to create an
  /// all-day event by default
  static const EXTRA_EVENT_ALL_DAY = "allDay";

  /// from: static public final java.lang.String EXTRA_EVENT_BEGIN_TIME
  ///
  /// Intent Extras key: The start time of an event or an instance of a
  /// recurring event. (milliseconds since epoch)
  static const EXTRA_EVENT_BEGIN_TIME = "beginTime";

  /// from: static public final java.lang.String EXTRA_EVENT_END_TIME
  ///
  /// Intent Extras key: The end time of an event or an instance of a recurring
  /// event. (milliseconds since epoch)
  static const EXTRA_EVENT_END_TIME = "endTime";
}

/// from: android.provider.CalendarContract$SyncState
///
/// A table provided for sync adapters to use for storing private sync state data.
///@see SyncStateContract
class CalendarContract_SyncState extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$SyncState");
  CalendarContract_SyncState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);
}

/// from: android.provider.CalendarContract$SyncColumns
///
/// Columns for Sync information used by Calendars and Events tables. These
/// have specific uses which are expected to be consistent by the app and
/// sync adapter.
class CalendarContract_SyncColumns extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$SyncColumns");
  CalendarContract_SyncColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACCOUNT_NAME
  ///
  /// The account that was used to sync the entry to the device. If the
  /// account_type is not \#ACCOUNT_TYPE_LOCAL then the name and
  /// type must match an account on the device or the calendar will be
  /// deleted.
  /// <P>Type: TEXT</P>
  static const ACCOUNT_NAME = "account_name";

  /// from: static public final java.lang.String ACCOUNT_TYPE
  ///
  /// The type of the account that was used to sync the entry to the
  /// device. A type of \#ACCOUNT_TYPE_LOCAL will keep this event
  /// form being deleted if there are no matching accounts on the device.
  /// <P>Type: TEXT</P>
  static const ACCOUNT_TYPE = "account_type";

  /// from: static public final java.lang.String CAN_PARTIALLY_UPDATE
  ///
  /// If set to 1 this causes events on this calendar to be duplicated with
  /// Events\#LAST_SYNCED set to 1 whenever the event
  /// transitions from non-dirty to dirty. The duplicated event will not be
  /// expanded in the instances table and will only show up in sync adapter
  /// queries of the events table. It will also be deleted when the
  /// originating event has its dirty flag cleared by the sync adapter.
  /// <P>Type: INTEGER (boolean)</P>
  static const CAN_PARTIALLY_UPDATE = "canPartiallyUpdate";

  /// from: static public final java.lang.String DELETED
  ///
  /// Whether the row has been deleted but not synced to the server. A
  /// deleted row should be ignored.
  /// <P>
  /// Type: INTEGER (boolean)
  /// </P>
  static const DELETED = "deleted";

  /// from: static public final java.lang.String DIRTY
  ///
  /// Used to indicate that local, unsynced, changes are present.
  /// <P>Type: INTEGER (long)</P>
  static const DIRTY = "dirty";

  /// from: static public final java.lang.String MUTATORS
  ///
  /// Used in conjunction with \#DIRTY to indicate what packages wrote local changes.
  /// <P>Type: TEXT</P>
  static const MUTATORS = "mutators";
}

/// from: android.provider.CalendarContract$RemindersColumns
class CalendarContract_RemindersColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$RemindersColumns");
  CalendarContract_RemindersColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String EVENT_ID
  ///
  /// The event the reminder belongs to. Column name.
  /// <P>Type: INTEGER (foreign key to the Events table)</P>
  static const EVENT_ID = "event_id";

  /// from: static public final java.lang.String METHOD
  ///
  /// The alarm method, as set on the server. \#METHOD_DEFAULT,
  /// \#METHOD_ALERT, \#METHOD_EMAIL, \#METHOD_SMS and
  /// \#METHOD_ALARM are possible values; the device will only
  /// process \#METHOD_DEFAULT and \#METHOD_ALERT reminders
  /// (the other types are simply stored so we can send the same reminder
  /// info back to the server when we make changes).
  static const METHOD = "method";

  /// from: static public final int METHOD_ALARM
  static const METHOD_ALARM = 4;

  /// from: static public final int METHOD_ALERT
  static const METHOD_ALERT = 1;

  /// from: static public final int METHOD_DEFAULT
  static const METHOD_DEFAULT = 0;

  /// from: static public final int METHOD_EMAIL
  static const METHOD_EMAIL = 2;

  /// from: static public final int METHOD_SMS
  static const METHOD_SMS = 3;

  /// from: static public final java.lang.String MINUTES
  ///
  /// The minutes prior to the event that the alarm should ring.  -1
  /// specifies that we should use the default value for the system.
  /// Column name.
  /// <P>Type: INTEGER</P>
  static const MINUTES = "minutes";

  /// from: static public final int MINUTES_DEFAULT
  ///
  /// Passing this as a minutes value will use the default reminder
  /// minutes.
  static const MINUTES_DEFAULT = -1;
}

/// from: android.provider.CalendarContract$Reminders
///
/// Fields and helpers for accessing reminders for an event. Each row of this
/// table represents a single reminder for an event. Calling
/// \#query(ContentResolver, long, String[]) will return a list of reminders for
/// the event with the given eventId. Both apps and sync adapters may write
/// to this table. There are three writable fields and all of them must be
/// included when inserting a new reminder. They are:
/// <ul>
/// <li>\#EVENT_ID</li>
/// <li>\#MINUTES</li>
/// <li>\#METHOD</li>
/// </ul>
class CalendarContract_Reminders extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$Reminders");
  CalendarContract_Reminders.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_query = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;J[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, long eventId, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Queries all reminders associated with the given event. This is a
  /// blocking call and should not be done on the UI thread.
  ///@param cr The content resolver to use for the query
  ///@param eventId The id of the event to retrieve reminders for
  ///@param projection the columns to return in the cursor
  ///@return A Cursor containing all reminders for the event
  static cursor_.Cursor query(contentresolver_.ContentResolver cr, int eventId,
          jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_query,
          jni.JniType.objectType,
          [cr.reference, eventId, projection.reference]).object);
}

/// from: android.provider.CalendarContract$Instances
///
/// Fields and helpers for interacting with Instances. An instance is a
/// single occurrence of an event including time zone specific start and end
/// days and minutes. The instances table is not writable and only provides a
/// way to query event occurrences.
class CalendarContract_Instances extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$Instances");
  CalendarContract_Instances.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String BEGIN
  ///
  /// The beginning time of the instance, in UTC milliseconds. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const BEGIN = "begin";

  static final _id_CONTENT_BY_DAY_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_BY_DAY_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_BY_DAY_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for querying an instance range by Julian
  /// Day. The start and end day should be added as path segments if this
  /// is used directly.
  static uri_.Uri get CONTENT_BY_DAY_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_BY_DAY_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_SEARCH_BY_DAY_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_SEARCH_BY_DAY_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_SEARCH_BY_DAY_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for querying an instance range with a search
  /// term. The start day, end day, and search string should be appended as
  /// path segments if this is used directly.
  static uri_.Uri get CONTENT_SEARCH_BY_DAY_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_SEARCH_BY_DAY_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_SEARCH_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_SEARCH_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_SEARCH_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for querying an instance range with a search
  /// term. The begin, end, and search string should be appended as path
  /// segments if this is used directly.
  static uri_.Uri get CONTENT_SEARCH_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_SEARCH_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for querying an instance range. The begin
  /// and end of the range to query should be added as path segments if
  /// this is used directly.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String END
  ///
  /// The ending time of the instance, in UTC milliseconds. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const END = "end";

  /// from: static public final java.lang.String END_DAY
  ///
  /// The Julian end day of the instance, relative to the local time
  /// zone. Column name.
  /// <P>Type: INTEGER (int)</P>
  static const END_DAY = "endDay";

  /// from: static public final java.lang.String END_MINUTE
  ///
  /// The end minute of the instance measured from midnight in the
  /// local time zone. Column name.
  /// <P>Type: INTEGER (int)</P>
  static const END_MINUTE = "endMinute";

  /// from: static public final java.lang.String EVENT_ID
  ///
  /// The _id of the event for this instance. Column name.
  /// <P>Type: INTEGER (long, foreign key to the Events table)</P>
  static const EVENT_ID = "event_id";

  /// from: static public final java.lang.String START_DAY
  ///
  /// The Julian start day of the instance, relative to the local time
  /// zone. Column name.
  /// <P>Type: INTEGER (int)</P>
  static const START_DAY = "startDay";

  /// from: static public final java.lang.String START_MINUTE
  ///
  /// The start minute of the instance measured from midnight in the
  /// local time zone. Column name.
  /// <P>Type: INTEGER (int)</P>
  static const START_MINUTE = "startMinute";

  static final _id_query = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;[Ljava/lang/String;JJ)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, java.lang.String[] projection, long begin, long end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Performs a query to return all visible instances in the given range.
  /// This is a blocking function and should not be done on the UI thread.
  /// This will cause an expansion of recurring events to fill this time
  /// range if they are not already expanded and will slow down for larger
  /// time ranges with many recurring events.
  ///@param cr The ContentResolver to use for the query
  ///@param projection The columns to return
  ///@param begin The start of the time range to query in UTC millis since
  ///            epoch
  ///@param end The end of the time range to query in UTC millis since
  ///            epoch
  ///@return A Cursor containing all instances in the given range
  static cursor_.Cursor query(contentresolver_.ContentResolver cr,
          jni.JniObject projection, int begin, int end) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_query,
          jni.JniType.objectType,
          [cr.reference, projection.reference, begin, end]).object);

  static final _id_query1 = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;[Ljava/lang/String;JJLjava/lang/String;)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, java.lang.String[] projection, long begin, long end, java.lang.String searchQuery)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Performs a query to return all visible instances in the given range
  /// that match the given query. This is a blocking function and should
  /// not be done on the UI thread. This will cause an expansion of
  /// recurring events to fill this time range if they are not already
  /// expanded and will slow down for larger time ranges with many
  /// recurring events.
  ///@param cr The ContentResolver to use for the query
  ///@param projection The columns to return
  ///@param begin The start of the time range to query in UTC millis since
  ///            epoch
  ///@param end The end of the time range to query in UTC millis since
  ///            epoch
  ///@param searchQuery A string of space separated search terms. Segments
  ///            enclosed by double quotes will be treated as a single
  ///            term.
  ///@return A Cursor of instances matching the search terms in the given
  ///         time range
  static cursor_.Cursor query1(
          contentresolver_.ContentResolver cr,
          jni.JniObject projection,
          int begin,
          int end,
          jni.JniString searchQuery) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_query1, jni.JniType.objectType, [
        cr.reference,
        projection.reference,
        begin,
        end,
        searchQuery.reference
      ]).object);
}

/// from: android.provider.CalendarContract$ExtendedPropertiesColumns
class CalendarContract_ExtendedPropertiesColumns extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/CalendarContract\$ExtendedPropertiesColumns");
  CalendarContract_ExtendedPropertiesColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String EVENT_ID
  ///
  /// The event the extended property belongs to. Column name.
  /// <P>Type: INTEGER (foreign key to the Events table)</P>
  static const EVENT_ID = "event_id";

  /// from: static public final java.lang.String NAME
  ///
  /// The name of the extended property.  This is a uri of the form
  /// {scheme}\#{local-name} convention. Column name.
  /// <P>Type: TEXT</P>
  static const NAME = "name";

  /// from: static public final java.lang.String VALUE
  ///
  /// The value of the extended property. Column name.
  /// <P>Type: TEXT</P>
  static const VALUE = "value";
}

/// from: android.provider.CalendarContract$ExtendedProperties
///
/// Fields for accessing the Extended Properties. This is a generic set of
/// name/value pairs for use by sync adapters to add extra
/// information to events. There are three writable columns and all three
/// must be present when inserting a new value. They are:
/// <ul>
/// <li>\#EVENT_ID</li>
/// <li>\#NAME</li>
/// <li>\#VALUE</li>
/// </ul>
class CalendarContract_ExtendedProperties extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$ExtendedProperties");
  CalendarContract_ExtendedProperties.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);
}

/// from: android.provider.CalendarContract$EventsEntity
///
/// Class that represents an Event Entity. There is one entry per event.
/// Recurring events show up as a single entry. This is a helper class to
/// make batch operations easier. A ContentResolver or
/// ContentProviderClient is required as the helper does additional
/// queries to add reminders and attendees to each entry.
class CalendarContract_EventsEntity extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$EventsEntity");
  CalendarContract_EventsEntity.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_newEntityIterator = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newEntityIterator",
      "(Landroid/database/Cursor;Landroid/content/ContentResolver;)Landroid/content/EntityIterator;");

  /// from: static public android.content.EntityIterator newEntityIterator(android.database.Cursor cursor, android.content.ContentResolver resolver)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new iterator for events
  ///@param cursor An event query
  ///@param resolver For performing additional queries
  ///@return an EntityIterator containing one entity per event in the
  ///         cursor
  static entityiterator_.EntityIterator newEntityIterator(
          cursor_.Cursor cursor, contentresolver_.ContentResolver resolver) =>
      entityiterator_.EntityIterator.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_newEntityIterator,
              jni.JniType.objectType,
              [cursor.reference, resolver.reference]).object);

  static final _id_newEntityIterator1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newEntityIterator",
      "(Landroid/database/Cursor;Landroid/content/ContentProviderClient;)Landroid/content/EntityIterator;");

  /// from: static public android.content.EntityIterator newEntityIterator(android.database.Cursor cursor, android.content.ContentProviderClient provider)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new iterator for events
  ///@param cursor An event query
  ///@param provider For performing additional queries
  ///@return an EntityIterator containing one entity per event in the
  ///         cursor
  static entityiterator_.EntityIterator newEntityIterator1(
          cursor_.Cursor cursor,
          contentproviderclient_.ContentProviderClient provider) =>
      entityiterator_.EntityIterator.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_newEntityIterator1,
              jni.JniType.objectType,
              [cursor.reference, provider.reference]).object);
}

/// from: android.provider.CalendarContract$EventsColumns
///
/// Columns from the Events table that other tables join into themselves.
class CalendarContract_EventsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$EventsColumns");
  CalendarContract_EventsColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ACCESS_CONFIDENTIAL
  ///
  /// Confidential is not used by the app.
  static const ACCESS_CONFIDENTIAL = 1;

  /// from: static public final int ACCESS_DEFAULT
  ///
  /// Default access is controlled by the server and will be treated as
  /// public on the device.
  static const ACCESS_DEFAULT = 0;

  /// from: static public final java.lang.String ACCESS_LEVEL
  ///
  /// Defines how the event shows up for others when the calendar is
  /// shared. Column name.
  /// <P>Type: INTEGER (One of \#ACCESS_DEFAULT, ...)</P>
  static const ACCESS_LEVEL = "accessLevel";

  /// from: static public final int ACCESS_PRIVATE
  ///
  /// Private shares the event as a free/busy slot with no details.
  static const ACCESS_PRIVATE = 2;

  /// from: static public final int ACCESS_PUBLIC
  ///
  /// Public makes the contents visible to anyone with access to the
  /// calendar.
  static const ACCESS_PUBLIC = 3;

  /// from: static public final java.lang.String ALL_DAY
  ///
  /// Is the event all day (time zone independent). Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const ALL_DAY = "allDay";

  /// from: static public final java.lang.String AVAILABILITY
  ///
  /// If this event counts as busy time or is still free time that can be
  /// scheduled over. Column name.
  /// <P>
  /// Type: INTEGER (One of \#AVAILABILITY_BUSY,
  /// \#AVAILABILITY_FREE, \#AVAILABILITY_TENTATIVE)
  /// </P>
  static const AVAILABILITY = "availability";

  /// from: static public final int AVAILABILITY_BUSY
  ///
  /// Indicates that this event takes up time and will conflict with other
  /// events.
  static const AVAILABILITY_BUSY = 0;

  /// from: static public final int AVAILABILITY_FREE
  ///
  /// Indicates that this event is free time and will not conflict with
  /// other events.
  static const AVAILABILITY_FREE = 1;

  /// from: static public final int AVAILABILITY_TENTATIVE
  ///
  /// Indicates that the owner's availability may change, but should be
  /// considered busy time that will conflict.
  static const AVAILABILITY_TENTATIVE = 2;

  /// from: static public final java.lang.String CALENDAR_ID
  ///
  /// The Calendars\#_ID of the calendar the event belongs to.
  /// Column name.
  /// <P>Type: INTEGER</P>
  static const CALENDAR_ID = "calendar_id";

  /// from: static public final java.lang.String CAN_INVITE_OTHERS
  ///
  /// Whether the user can invite others to the event. The
  /// GUESTS_CAN_INVITE_OTHERS is a setting that applies to an arbitrary
  /// guest, while CAN_INVITE_OTHERS indicates if the user can invite
  /// others (either through GUESTS_CAN_INVITE_OTHERS or because the user
  /// has modify access to the event). Column name.
  /// <P>Type: INTEGER (boolean, readonly)</P>
  static const CAN_INVITE_OTHERS = "canInviteOthers";

  /// from: static public final java.lang.String CUSTOM_APP_PACKAGE
  ///
  /// The package name of the custom app that can provide a richer
  /// experience for the event. See the ACTION TYPE
  /// CalendarContract\#ACTION_HANDLE_CUSTOM_EVENT for details.
  /// Column name.
  /// <P> Type: TEXT </P>
  static const CUSTOM_APP_PACKAGE = "customAppPackage";

  /// from: static public final java.lang.String CUSTOM_APP_URI
  ///
  /// The URI used by the custom app for the event. Column name.
  /// <P>Type: TEXT</P>
  static const CUSTOM_APP_URI = "customAppUri";

  /// from: static public final java.lang.String DESCRIPTION
  ///
  /// The description of the event. Column name.
  /// <P>Type: TEXT</P>
  static const DESCRIPTION = "description";

  /// from: static public final java.lang.String DISPLAY_COLOR
  ///
  /// This will be \#EVENT_COLOR if it is not null; otherwise, this will be
  /// Calendars\#CALENDAR_COLOR.
  /// Read-only value. To modify, write to \#EVENT_COLOR or
  /// Calendars\#CALENDAR_COLOR directly.
  ///<P>
  ///     Type: INTEGER
  ///</P>
  static const DISPLAY_COLOR = "displayColor";

  /// from: static public final java.lang.String DTEND
  ///
  /// The time the event ends in UTC millis since epoch. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const DTEND = "dtend";

  /// from: static public final java.lang.String DTSTART
  ///
  /// The time the event starts in UTC millis since epoch. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const DTSTART = "dtstart";

  /// from: static public final java.lang.String DURATION
  ///
  /// The duration of the event in RFC2445 format. Column name.
  /// <P>Type: TEXT (duration in RFC2445 format)</P>
  static const DURATION = "duration";

  /// from: static public final java.lang.String EVENT_COLOR
  ///
  /// A secondary color for the individual event. This should only be
  /// updated by the sync adapter for a given account.
  /// <P>Type: INTEGER</P>
  static const EVENT_COLOR = "eventColor";

  /// from: static public final java.lang.String EVENT_COLOR_KEY
  ///
  /// A secondary color key for the individual event. NULL or an empty
  /// string are reserved for indicating that the event does not use a key
  /// for looking up the color. The provider will update
  /// \#EVENT_COLOR automatically when a valid key is written to
  /// this column. The key must reference an existing row of the
  /// Colors table. @see Colors
  /// <P>
  /// Type: TEXT
  /// </P>
  static const EVENT_COLOR_KEY = "eventColor_index";

  /// from: static public final java.lang.String EVENT_END_TIMEZONE
  ///
  /// The timezone for the end time of the event. Column name.
  /// <P>Type: TEXT</P>
  static const EVENT_END_TIMEZONE = "eventEndTimezone";

  /// from: static public final java.lang.String EVENT_LOCATION
  ///
  /// Where the event takes place. Column name.
  /// <P>Type: TEXT</P>
  static const EVENT_LOCATION = "eventLocation";

  /// from: static public final java.lang.String EVENT_TIMEZONE
  ///
  /// The timezone for the event. Column name.
  /// <P>Type: TEXT</P>
  static const EVENT_TIMEZONE = "eventTimezone";

  /// from: static public final java.lang.String EXDATE
  ///
  /// The recurrence exception dates for the event. Column name.
  /// <P>Type: TEXT</P>
  static const EXDATE = "exdate";

  /// from: static public final java.lang.String EXRULE
  ///
  /// The recurrence exception rule for the event. Column name.
  /// <P>Type: TEXT</P>
  static const EXRULE = "exrule";

  /// from: static public final java.lang.String GUESTS_CAN_INVITE_OTHERS
  ///
  /// Whether guests can invite other guests. Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const GUESTS_CAN_INVITE_OTHERS = "guestsCanInviteOthers";

  /// from: static public final java.lang.String GUESTS_CAN_MODIFY
  ///
  /// Whether guests can modify the event. Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const GUESTS_CAN_MODIFY = "guestsCanModify";

  /// from: static public final java.lang.String GUESTS_CAN_SEE_GUESTS
  ///
  /// Whether guests can see the list of attendees. Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const GUESTS_CAN_SEE_GUESTS = "guestsCanSeeGuests";

  /// from: static public final java.lang.String HAS_ALARM
  ///
  /// Whether the event has an alarm or not. Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const HAS_ALARM = "hasAlarm";

  /// from: static public final java.lang.String HAS_ATTENDEE_DATA
  ///
  /// Whether the event has attendee information.  True if the event
  /// has full attendee data, false if the event has information about
  /// self only. Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const HAS_ATTENDEE_DATA = "hasAttendeeData";

  /// from: static public final java.lang.String HAS_EXTENDED_PROPERTIES
  ///
  /// Whether the event has extended properties or not. Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const HAS_EXTENDED_PROPERTIES = "hasExtendedProperties";

  /// from: static public final java.lang.String IS_ORGANIZER
  ///
  /// Are we the organizer of this event. If this column is not explicitly set, the provider
  /// will return 1 if \#ORGANIZER is equal to Calendars\#OWNER_ACCOUNT.
  /// Column name.
  /// <P>Type: STRING</P>
  static const IS_ORGANIZER = "isOrganizer";

  /// from: static public final java.lang.String LAST_DATE
  ///
  /// The last date this event repeats on, or NULL if it never ends. Column
  /// name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const LAST_DATE = "lastDate";

  /// from: static public final java.lang.String LAST_SYNCED
  ///
  /// Used to indicate that a row is not a real event but an original copy of a locally
  /// modified event. A copy is made when an event changes from non-dirty to dirty and the
  /// event is on a calendar with Calendars\#CAN_PARTIALLY_UPDATE set to 1. This copy
  /// does not get expanded in the instances table and is only visible in queries made by a
  /// sync adapter. The copy gets removed when the event is changed back to non-dirty by a
  /// sync adapter.
  /// <P>Type: INTEGER (boolean)</P>
  static const LAST_SYNCED = "lastSynced";

  /// from: static public final java.lang.String ORGANIZER
  ///
  /// Email of the organizer (owner) of the event. Column name.
  /// <P>Type: STRING</P>
  static const ORGANIZER = "organizer";

  /// from: static public final java.lang.String ORIGINAL_ALL_DAY
  ///
  /// The allDay status (true or false) of the original recurring event
  /// for which this event is an exception. Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const ORIGINAL_ALL_DAY = "originalAllDay";

  /// from: static public final java.lang.String ORIGINAL_ID
  ///
  /// The Events\#_ID of the original recurring event for which this
  /// event is an exception. Column name.
  /// <P>Type: TEXT</P>
  static const ORIGINAL_ID = "original_id";

  /// from: static public final java.lang.String ORIGINAL_INSTANCE_TIME
  ///
  /// The original instance time of the recurring event for which this
  /// event is an exception. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const ORIGINAL_INSTANCE_TIME = "originalInstanceTime";

  /// from: static public final java.lang.String ORIGINAL_SYNC_ID
  ///
  /// The _sync_id of the original recurring event for which this event is
  /// an exception. The provider should keep the original_id in sync when
  /// this is updated. Column name.
  /// <P>Type: TEXT</P>
  static const ORIGINAL_SYNC_ID = "original_sync_id";

  /// from: static public final java.lang.String RDATE
  ///
  /// The recurrence dates for the event. Column name.
  /// <P>Type: TEXT</P>
  static const RDATE = "rdate";

  /// from: static public final java.lang.String RRULE
  ///
  /// The recurrence rule for the event. Column name.
  /// <P>Type: TEXT</P>
  static const RRULE = "rrule";

  /// from: static public final java.lang.String SELF_ATTENDEE_STATUS
  ///
  /// This is a copy of the attendee status for the owner of this event.
  /// This field is copied here so that we can efficiently filter out
  /// events that are declined without having to look in the Attendees
  /// table. Column name.
  ///
  /// <P>Type: INTEGER (int)</P>
  static const SELF_ATTENDEE_STATUS = "selfAttendeeStatus";

  /// from: static public final java.lang.String STATUS
  ///
  /// The event status. Column name.
  /// <P>Type: INTEGER (one of \#STATUS_TENTATIVE...)</P>
  static const STATUS = "eventStatus";

  /// from: static public final int STATUS_CANCELED
  static const STATUS_CANCELED = 2;

  /// from: static public final int STATUS_CONFIRMED
  static const STATUS_CONFIRMED = 1;

  /// from: static public final int STATUS_TENTATIVE
  static const STATUS_TENTATIVE = 0;

  /// from: static public final java.lang.String SYNC_DATA1
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA1 = "sync_data1";

  /// from: static public final java.lang.String SYNC_DATA10
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA10 = "sync_data10";

  /// from: static public final java.lang.String SYNC_DATA2
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA2 = "sync_data2";

  /// from: static public final java.lang.String SYNC_DATA3
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA3 = "sync_data3";

  /// from: static public final java.lang.String SYNC_DATA4
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA4 = "sync_data4";

  /// from: static public final java.lang.String SYNC_DATA5
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA5 = "sync_data5";

  /// from: static public final java.lang.String SYNC_DATA6
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA6 = "sync_data6";

  /// from: static public final java.lang.String SYNC_DATA7
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA7 = "sync_data7";

  /// from: static public final java.lang.String SYNC_DATA8
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA8 = "sync_data8";

  /// from: static public final java.lang.String SYNC_DATA9
  ///
  /// This column is available for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const SYNC_DATA9 = "sync_data9";

  /// from: static public final java.lang.String TITLE
  ///
  /// The title of the event. Column name.
  /// <P>Type: TEXT</P>
  static const TITLE = "title";

  /// from: static public final java.lang.String UID_2445
  ///
  /// The UID for events added from the RFC 2445 iCalendar format.
  /// Column name.
  /// <P>Type: TEXT</P>
  static const UID_2445 = "uid2445";
}

/// from: android.provider.CalendarContract$Events
///
/// Constants and helpers for the Events table, which contains details for
/// individual events. <h3>Operations</h3> All operations can be done either
/// as an app or as a sync adapter. To perform an operation as a sync adapter
/// \#CALLER_IS_SYNCADAPTER should be set to true and
/// \#ACCOUNT_NAME and \#ACCOUNT_TYPE must be set in the Uri
/// parameters. See
/// Uri.Builder\#appendQueryParameter(java.lang.String, java.lang.String)
/// for details on adding parameters. Sync adapters have write access to more
/// columns but are restricted to a single account at a time.
/// <dl>
/// <dt>__Insert__</dt>
/// <dd>When inserting a new event the following fields must be included:
/// <ul>
/// <li>dtstart</li>
/// <li>dtend if the event is non-recurring</li>
/// <li>duration if the event is recurring</li>
/// <li>rrule or rdate if the event is recurring</li>
/// <li>eventTimezone</li>
/// <li>a calendar_id</li>
/// </ul>
/// There are also further requirements when inserting or updating an event.
/// See the section on Writing to Events.</dd>
/// <dt>__Update__</dt>
/// <dd>To perform an update of an Event the Events\#_ID of the event
/// should be provided either as an appended id to the Uri (
/// ContentUris\#withAppendedId) or as the first selection item--the
/// selection should start with "_id=?" and the first selectionArg should be
/// the _id of the event. Updates may also be done using a selection and no
/// id. Updating an event must respect the same rules as inserting and is
/// further restricted in the fields that can be written. See the section on
/// Writing to Events.</dd>
/// <dt>__Delete__</dt>
/// <dd>Events can be deleted either by the Events\#_ID as an appended
/// id on the Uri or using any standard selection. If an appended id is used
/// a selection is not allowed. There are two versions of delete: as an app
/// and as a sync adapter. An app delete will set the deleted column on an
/// event and remove all instances of that event. A sync adapter delete will
/// remove the event from the database and all associated data.</dd>
/// <dt>__Query__</dt>
/// <dd>Querying the Events table will get you all information about a set of
/// events except their reminders, attendees, and extended properties. There
/// will be one row returned for each event that matches the query selection,
/// or at most a single row if the Events\#_ID is appended to the Uri.
/// Recurring events will only return a single row regardless of the number
/// of times that event repeats.</dd>
/// </dl>
/// <h3>Writing to Events</h3> There are further restrictions on all Updates
/// and Inserts in the Events table:
/// <ul>
/// <li>If allDay is set to 1 eventTimezone must be Time\#TIMEZONE_UTC
/// and the time must correspond to a midnight boundary.</li>
/// <li>Exceptions are not allowed to recur. If rrule or rdate is not empty,
/// original_id and original_sync_id must be empty.</li>
/// <li>In general a calendar_id should not be modified after insertion. This
/// is not explicitly forbidden but many sync adapters will not behave in an
/// expected way if the calendar_id is modified.</li>
/// </ul>
/// The following Events columns are writable by both an app and a sync
/// adapter.
/// <ul>
/// <li>\#CALENDAR_ID</li>
/// <li>\#ORGANIZER</li>
/// <li>\#TITLE</li>
/// <li>\#EVENT_LOCATION</li>
/// <li>\#DESCRIPTION</li>
/// <li>\#EVENT_COLOR</li>
/// <li>\#DTSTART</li>
/// <li>\#DTEND</li>
/// <li>\#EVENT_TIMEZONE</li>
/// <li>\#EVENT_END_TIMEZONE</li>
/// <li>\#DURATION</li>
/// <li>\#ALL_DAY</li>
/// <li>\#RRULE</li>
/// <li>\#RDATE</li>
/// <li>\#EXRULE</li>
/// <li>\#EXDATE</li>
/// <li>\#ORIGINAL_ID</li>
/// <li>\#ORIGINAL_SYNC_ID</li>
/// <li>\#ORIGINAL_INSTANCE_TIME</li>
/// <li>\#ORIGINAL_ALL_DAY</li>
/// <li>\#ACCESS_LEVEL</li>
/// <li>\#AVAILABILITY</li>
/// <li>\#GUESTS_CAN_MODIFY</li>
/// <li>\#GUESTS_CAN_INVITE_OTHERS</li>
/// <li>\#GUESTS_CAN_SEE_GUESTS</li>
/// <li>\#CUSTOM_APP_PACKAGE</li>
/// <li>\#CUSTOM_APP_URI</li>
/// <li>\#UID_2445</li>
/// </ul>
/// The following Events columns are writable only by a sync adapter
/// <ul>
/// <li>\#DIRTY</li>
/// <li>\#MUTATORS</li>
/// <li>\#_SYNC_ID</li>
/// <li>\#SYNC_DATA1</li>
/// <li>\#SYNC_DATA2</li>
/// <li>\#SYNC_DATA3</li>
/// <li>\#SYNC_DATA4</li>
/// <li>\#SYNC_DATA5</li>
/// <li>\#SYNC_DATA6</li>
/// <li>\#SYNC_DATA7</li>
/// <li>\#SYNC_DATA8</li>
/// <li>\#SYNC_DATA9</li>
/// <li>\#SYNC_DATA10</li>
/// </ul>
/// The remaining columns are either updated by the provider only or are
/// views into other tables and cannot be changed through the Events table.
class CalendarContract_Events extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$Events");
  CalendarContract_Events.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_EXCEPTION_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_EXCEPTION_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_EXCEPTION_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for recurring event exceptions.  Insertions require an
  /// appended event ID.  Deletion of exceptions requires both the original event ID and
  /// the exception event ID (see Uri.Builder\#appendPath).
  static uri_.Uri get CONTENT_EXCEPTION_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_EXCEPTION_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for interacting with events. Appending an
  /// event id using ContentUris\#withAppendedId(Uri, long) will
  /// specify a single event.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);
}

/// from: android.provider.CalendarContract$EventDaysColumns
class CalendarContract_EventDaysColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$EventDaysColumns");
  CalendarContract_EventDaysColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String ENDDAY
  ///
  /// The Julian ending day number. Column name.
  /// <P>Type: INTEGER (int)</P>
  static const ENDDAY = "endDay";

  /// from: static public final java.lang.String STARTDAY
  ///
  /// The Julian starting day number. Column name.
  /// <P>Type: INTEGER (int)</P>
  static const STARTDAY = "startDay";
}

/// from: android.provider.CalendarContract$EventDays
///
/// Fields and helpers for querying for a list of days that contain events.
class CalendarContract_EventDays extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$EventDays");
  CalendarContract_EventDays.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_query = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;II[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, int startDay, int numDays, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the days with events for the Julian days starting at
  /// "startDay" for "numDays". It returns a cursor containing startday and
  /// endday representing the max range of days for all events beginning on
  /// each startday.This is a blocking function and should not be done on
  /// the UI thread.
  ///@param cr the ContentResolver
  ///@param startDay the first Julian day in the range
  ///@param numDays the number of days to load (must be at least 1)
  ///@param projection the columns to return in the cursor
  ///@return a database cursor containing a list of start and end days for
  ///         events
  static cursor_.Cursor query(contentresolver_.ContentResolver cr, int startDay,
          int numDays, jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_query,
          jni.JniType.objectType,
          [cr.reference, startDay, numDays, projection.reference]).object);
}

/// from: android.provider.CalendarContract$ColorsColumns
class CalendarContract_ColorsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$ColorsColumns");
  CalendarContract_ColorsColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String COLOR
  ///
  /// The color as an 8-bit ARGB integer value. Colors should specify alpha
  /// as fully opaque (eg 0xFF993322) as the alpha may be ignored or
  /// modified for display. It is reccomended that colors be usable with
  /// light (near white) text. Apps should not depend on that assumption,
  /// however. Column name.
  /// <P>
  /// Type: INTEGER (NOT NULL)
  /// </P>
  static const COLOR = "color";

  /// from: static public final java.lang.String COLOR_KEY
  ///
  /// The key used to reference this color. This can be any non-empty
  /// string, but must be unique for a given \#ACCOUNT_TYPE and
  /// \#ACCOUNT_NAME. Column name.
  /// <P>
  /// Type: TEXT
  /// </P>
  static const COLOR_KEY = "color_index";

  /// from: static public final java.lang.String COLOR_TYPE
  ///
  /// The type of color, which describes how it should be used. Valid types
  /// are \#TYPE_CALENDAR and \#TYPE_EVENT. Column name.
  /// <P>
  /// Type: INTEGER (NOT NULL)
  /// </P>
  static const COLOR_TYPE = "color_type";

  /// from: static public final int TYPE_CALENDAR
  ///
  /// This indicateds a color that can be used for calendars.
  static const TYPE_CALENDAR = 0;

  /// from: static public final int TYPE_EVENT
  ///
  /// This indicates a color that can be used for events.
  static const TYPE_EVENT = 1;
}

/// from: android.provider.CalendarContract$Colors
///
/// Fields for accessing colors available for a given account. Colors are
/// referenced by \#COLOR_KEY which must be unique for a given
/// account name/type. These values can only be updated by the sync
/// adapter. Only \#COLOR may be updated after the initial insert. In
/// addition, a row can only be deleted once all references to that color
/// have been removed from the Calendars or Events tables.
class CalendarContract_Colors extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$Colors");
  CalendarContract_Colors.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The Uri for querying color information
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);
}

/// from: android.provider.CalendarContract$Calendars
///
/// Constants and helpers for the Calendars table, which contains details for
/// individual calendars. <h3>Operations</h3> All operations can be done
/// either as an app or as a sync adapter. To perform an operation as a sync
/// adapter \#CALLER_IS_SYNCADAPTER should be set to true and
/// \#ACCOUNT_NAME and \#ACCOUNT_TYPE must be set in the Uri
/// parameters. See
/// Uri.Builder\#appendQueryParameter(java.lang.String, java.lang.String)
/// for details on adding parameters. Sync adapters have write access to more
/// columns but are restricted to a single account at a time. Calendars are
/// designed to be primarily managed by a sync adapter and inserting new
/// calendars should be done as a sync adapter. For the most part, apps
/// should only update calendars (such as changing the color or display
/// name). If a local calendar is required an app can do so by inserting as a
/// sync adapter and using an \#ACCOUNT_TYPE of
/// \#ACCOUNT_TYPE_LOCAL .
/// <dl>
/// <dt>__Insert__</dt>
/// <dd>When inserting a new calendar the following fields must be included:
/// <ul>
/// <li>\#ACCOUNT_NAME</li>
/// <li>\#ACCOUNT_TYPE</li>
/// <li>\#NAME</li>
/// <li>\#CALENDAR_DISPLAY_NAME</li>
/// <li>\#CALENDAR_COLOR</li>
/// <li>\#CALENDAR_ACCESS_LEVEL</li>
/// <li>\#OWNER_ACCOUNT</li>
/// </ul>
/// The following fields are not required when inserting a Calendar but are
/// generally a good idea to include:
/// <ul>
/// <li>\#SYNC_EVENTS set to 1</li>
/// <li>\#CALENDAR_TIME_ZONE</li>
/// <li>\#ALLOWED_REMINDERS</li>
/// <li>\#ALLOWED_AVAILABILITY</li>
/// <li>\#ALLOWED_ATTENDEE_TYPES</li>
/// </ul>
/// <dt>__Update__</dt>
/// <dd>To perform an update on a calendar the \#_ID of the calendar
/// should be provided either as an appended id to the Uri (
/// ContentUris\#withAppendedId) or as the first selection item--the
/// selection should start with "_id=?" and the first selectionArg should be
/// the _id of the calendar. Calendars may also be updated using a selection
/// without the id. In general, the \#ACCOUNT_NAME and
/// \#ACCOUNT_TYPE should not be changed after a calendar is created
/// as this can cause issues for sync adapters.
/// <dt>__Delete__</dt>
/// <dd>Calendars can be deleted either by the \#_ID as an appended id
/// on the Uri or using any standard selection. Deleting a calendar should
/// generally be handled by a sync adapter as it will remove the calendar
/// from the database and all associated data (aka events).</dd>
/// <dt>__Query__</dt>
/// <dd>Querying the Calendars table will get you all information about a set
/// of calendars. There will be one row returned for each calendar that
/// matches the query selection, or at most a single row if the \#_ID
/// is appended to the Uri.</dd>
/// </dl>
/// <h3>Calendar Columns</h3> The following Calendar columns are writable by
/// both an app and a sync adapter.
/// <ul>
/// <li>\#NAME</li>
/// <li>\#CALENDAR_DISPLAY_NAME</li>
/// <li>\#VISIBLE</li>
/// <li>\#SYNC_EVENTS</li>
/// </ul>
/// The following Calendars columns are writable only by a sync adapter
/// <ul>
/// <li>\#ACCOUNT_NAME</li>
/// <li>\#ACCOUNT_TYPE</li>
/// <li>\#CALENDAR_COLOR</li>
/// <li>\#_SYNC_ID</li>
/// <li>\#DIRTY</li>
/// <li>\#MUTATORS</li>
/// <li>\#OWNER_ACCOUNT</li>
/// <li>\#MAX_REMINDERS</li>
/// <li>\#ALLOWED_REMINDERS</li>
/// <li>\#ALLOWED_AVAILABILITY</li>
/// <li>\#ALLOWED_ATTENDEE_TYPES</li>
/// <li>\#CAN_MODIFY_TIME_ZONE</li>
/// <li>\#CAN_ORGANIZER_RESPOND</li>
/// <li>\#CAN_PARTIALLY_UPDATE</li>
/// <li>\#CALENDAR_LOCATION</li>
/// <li>\#CALENDAR_TIME_ZONE</li>
/// <li>\#CALENDAR_ACCESS_LEVEL</li>
/// <li>\#DELETED</li>
/// <li>\#CAL_SYNC1</li>
/// <li>\#CAL_SYNC2</li>
/// <li>\#CAL_SYNC3</li>
/// <li>\#CAL_SYNC4</li>
/// <li>\#CAL_SYNC5</li>
/// <li>\#CAL_SYNC6</li>
/// <li>\#CAL_SYNC7</li>
/// <li>\#CAL_SYNC8</li>
/// <li>\#CAL_SYNC9</li>
/// <li>\#CAL_SYNC10</li>
/// </ul>
class CalendarContract_Calendars extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$Calendars");
  CalendarContract_Calendars.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CALENDAR_LOCATION
  ///
  /// The default location for the calendar. Column name.
  /// <P>Type: TEXT</P>
  static const CALENDAR_LOCATION = "calendar_location";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for accessing Calendars
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "calendar_displayName";

  /// from: static public final java.lang.String NAME
  ///
  /// The name of the calendar. Column name.
  /// <P>Type: TEXT</P>
  static const NAME = "name";
}

/// from: android.provider.CalendarContract$CalendarSyncColumns
///
/// Generic columns for use by sync adapters. The specific functions of these
/// columns are private to the sync adapter. Other clients of the API should
/// not attempt to either read or write this column. These columns are
/// editable as part of the Calendars Uri, but can only be read if accessed
/// through any other Uri.
class CalendarContract_CalendarSyncColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$CalendarSyncColumns");
  CalendarContract_CalendarSyncColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CAL_SYNC1
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC1 = "cal_sync1";

  /// from: static public final java.lang.String CAL_SYNC10
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC10 = "cal_sync10";

  /// from: static public final java.lang.String CAL_SYNC2
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC2 = "cal_sync2";

  /// from: static public final java.lang.String CAL_SYNC3
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC3 = "cal_sync3";

  /// from: static public final java.lang.String CAL_SYNC4
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC4 = "cal_sync4";

  /// from: static public final java.lang.String CAL_SYNC5
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC5 = "cal_sync5";

  /// from: static public final java.lang.String CAL_SYNC6
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC6 = "cal_sync6";

  /// from: static public final java.lang.String CAL_SYNC7
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC7 = "cal_sync7";

  /// from: static public final java.lang.String CAL_SYNC8
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC8 = "cal_sync8";

  /// from: static public final java.lang.String CAL_SYNC9
  ///
  /// Generic column for use by sync adapters. Column name.
  /// <P>Type: TEXT</P>
  static const CAL_SYNC9 = "cal_sync9";
}

/// from: android.provider.CalendarContract$CalendarEntity
///
/// Class that represents a Calendar Entity. There is one entry per calendar.
/// This is a helper class to make batch operations easier.
class CalendarContract_CalendarEntity extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$CalendarEntity");
  CalendarContract_CalendarEntity.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default Uri used when creating a new calendar EntityIterator.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_newEntityIterator = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newEntityIterator",
      "(Landroid/database/Cursor;)Landroid/content/EntityIterator;");

  /// from: static public android.content.EntityIterator newEntityIterator(android.database.Cursor cursor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an entity iterator for the given cursor. It assumes the
  /// cursor contains a calendars query.
  ///@param cursor query on \#CONTENT_URI
  ///@return an EntityIterator of calendars
  static entityiterator_.EntityIterator newEntityIterator(
          cursor_.Cursor cursor) =>
      entityiterator_.EntityIterator.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_newEntityIterator,
              jni.JniType.objectType, [cursor.reference]).object);
}

/// from: android.provider.CalendarContract$CalendarColumns
///
/// Columns specific to the Calendars Uri that other Uris can query.
class CalendarContract_CalendarColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$CalendarColumns");
  CalendarContract_CalendarColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String ALLOWED_ATTENDEE_TYPES
  ///
  /// A comma separated list of attendee types supported for this calendar
  /// in the format "\#,\#,\#". Valid types are Attendees\#TYPE_NONE,
  /// Attendees\#TYPE_OPTIONAL, Attendees\#TYPE_REQUIRED,
  /// Attendees\#TYPE_RESOURCE. Setting this field to only
  /// Attendees\#TYPE_NONE should be used to indicate that changing
  /// the attendee type is not supported.
  static const ALLOWED_ATTENDEE_TYPES = "allowedAttendeeTypes";

  /// from: static public final java.lang.String ALLOWED_AVAILABILITY
  ///
  /// A comma separated list of availability types supported for this
  /// calendar in the format "\#,\#,\#". Valid types are
  /// Events\#AVAILABILITY_BUSY, Events\#AVAILABILITY_FREE,
  /// Events\#AVAILABILITY_TENTATIVE. Setting this field to only
  /// Events\#AVAILABILITY_BUSY should be used to indicate that
  /// changing the availability is not supported.
  static const ALLOWED_AVAILABILITY = "allowedAvailability";

  /// from: static public final java.lang.String ALLOWED_REMINDERS
  ///
  /// A comma separated list of reminder methods supported for this
  /// calendar in the format "\#,\#,\#". Valid types are
  /// Reminders\#METHOD_DEFAULT, Reminders\#METHOD_ALERT,
  /// Reminders\#METHOD_EMAIL, Reminders\#METHOD_SMS,
  /// Reminders\#METHOD_ALARM. Column name.
  /// <P>Type: TEXT</P>
  static const ALLOWED_REMINDERS = "allowedReminders";

  /// from: static public final java.lang.String CALENDAR_ACCESS_LEVEL
  ///
  /// The level of access that the user has for the calendar
  /// <P>Type: INTEGER (one of the values below)</P>
  static const CALENDAR_ACCESS_LEVEL = "calendar_access_level";

  /// from: static public final java.lang.String CALENDAR_COLOR
  ///
  /// The color of the calendar. This should only be updated by the sync
  /// adapter, not other apps, as changing a calendar's color can adversely
  /// affect its display.
  /// <P>Type: INTEGER (color value)</P>
  static const CALENDAR_COLOR = "calendar_color";

  /// from: static public final java.lang.String CALENDAR_COLOR_KEY
  ///
  /// A key for looking up a color from the Colors table. NULL or
  /// an empty string are reserved for indicating that the calendar does
  /// not use a key for looking up the color. The provider will update
  /// \#CALENDAR_COLOR automatically when a valid key is written to
  /// this column. The key must reference an existing row of the
  /// Colors table. @see Colors
  /// <P>
  /// Type: TEXT
  /// </P>
  static const CALENDAR_COLOR_KEY = "calendar_color_index";

  /// from: static public final java.lang.String CALENDAR_DISPLAY_NAME
  ///
  /// The display name of the calendar. Column name.
  /// <P>
  /// Type: TEXT
  /// </P>
  static const CALENDAR_DISPLAY_NAME = "calendar_displayName";

  /// from: static public final java.lang.String CALENDAR_TIME_ZONE
  ///
  /// The time zone the calendar is associated with.
  /// <P>Type: TEXT</P>
  static const CALENDAR_TIME_ZONE = "calendar_timezone";

  /// from: static public final int CAL_ACCESS_CONTRIBUTOR
  ///
  /// Full access to modify the calendar, but not the access control
  /// settings
  static const CAL_ACCESS_CONTRIBUTOR = 500;

  /// from: static public final int CAL_ACCESS_EDITOR
  ///
  /// Full access to modify the calendar, but not the access control
  /// settings
  static const CAL_ACCESS_EDITOR = 600;

  /// from: static public final int CAL_ACCESS_FREEBUSY
  ///
  /// Can only see free/busy information about the calendar
  static const CAL_ACCESS_FREEBUSY = 100;

  /// from: static public final int CAL_ACCESS_NONE
  ///
  /// Cannot access the calendar
  static const CAL_ACCESS_NONE = 0;

  /// from: static public final int CAL_ACCESS_OVERRIDE
  ///
  /// not used
  static const CAL_ACCESS_OVERRIDE = 400;

  /// from: static public final int CAL_ACCESS_OWNER
  ///
  /// Full access to the calendar
  static const CAL_ACCESS_OWNER = 700;

  /// from: static public final int CAL_ACCESS_READ
  ///
  /// Can read all event details
  static const CAL_ACCESS_READ = 200;

  /// from: static public final int CAL_ACCESS_RESPOND
  ///
  /// Can reply yes/no/maybe to an event
  static const CAL_ACCESS_RESPOND = 300;

  /// from: static public final int CAL_ACCESS_ROOT
  ///
  /// Domain admin
  static const CAL_ACCESS_ROOT = 800;

  /// from: static public final java.lang.String CAN_MODIFY_TIME_ZONE
  ///
  /// Can the organizer modify the time zone of the event? Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const CAN_MODIFY_TIME_ZONE = "canModifyTimeZone";

  /// from: static public final java.lang.String CAN_ORGANIZER_RESPOND
  ///
  /// Can the organizer respond to the event?  If no, the status of the
  /// organizer should not be shown by the UI.  Defaults to 1. Column name.
  /// <P>Type: INTEGER (boolean)</P>
  static const CAN_ORGANIZER_RESPOND = "canOrganizerRespond";

  /// from: static public final java.lang.String IS_PRIMARY
  ///
  /// Is this the primary calendar for this account. If this column is not explicitly set, the
  /// provider will return 1 if Calendars\#ACCOUNT_NAME is equal to
  /// Calendars\#OWNER_ACCOUNT.
  static const IS_PRIMARY = "isPrimary";

  /// from: static public final java.lang.String MAX_REMINDERS
  ///
  /// The maximum number of reminders allowed for an event. Column name.
  /// <P>Type: INTEGER</P>
  static const MAX_REMINDERS = "maxReminders";

  /// from: static public final java.lang.String OWNER_ACCOUNT
  ///
  /// The owner account for this calendar, based on the calendar feed.
  /// This will be different from the _SYNC_ACCOUNT for delegated calendars.
  /// Column name.
  /// <P>Type: String</P>
  static const OWNER_ACCOUNT = "ownerAccount";

  /// from: static public final java.lang.String SYNC_EVENTS
  ///
  /// Is this calendar synced and are its events stored on the device?
  /// 0 - Do not sync this calendar or store events for this calendar.
  /// 1 - Sync down events for this calendar.
  /// Type: INTEGER (boolean)
  ///
  static const SYNC_EVENTS = "sync_events";

  /// from: static public final java.lang.String VISIBLE
  ///
  /// Is the calendar selected to be displayed?
  /// 0 - do not show events associated with this calendar.
  /// 1 - show events associated with this calendar
  /// <P>Type: INTEGER (boolean)</P>
  static const VISIBLE = "visible";
}

/// from: android.provider.CalendarContract$CalendarCacheColumns
class CalendarContract_CalendarCacheColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$CalendarCacheColumns");
  CalendarContract_CalendarCacheColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String KEY
  ///
  /// The key for the setting. Keys are defined in CalendarCache.
  static const KEY = "key";

  /// from: static public final java.lang.String VALUE
  ///
  /// The value of the given setting.
  static const VALUE = "value";
}

/// from: android.provider.CalendarContract$CalendarCache
///
/// CalendarCache stores some settings for calendar including the current
/// time zone for the instances. These settings are stored using a key/value
/// scheme. A \#KEY must be specified when updating these values.
class CalendarContract_CalendarCache extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$CalendarCache");
  CalendarContract_CalendarCache.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String KEY_TIMEZONE_INSTANCES
  ///
  /// The key for updating the time zone used by the provider when it
  /// generates the instances table. This should only be written if the
  /// type is set to \#TIMEZONE_TYPE_HOME. A valid time zone id
  /// should be written to this field.
  static const KEY_TIMEZONE_INSTANCES = "timezoneInstances";

  /// from: static public final java.lang.String KEY_TIMEZONE_INSTANCES_PREVIOUS
  ///
  /// The key for reading the last time zone set by the user. This should
  /// only be read by apps and it will be automatically updated whenever
  /// \#KEY_TIMEZONE_INSTANCES is updated with
  /// \#TIMEZONE_TYPE_HOME set.
  static const KEY_TIMEZONE_INSTANCES_PREVIOUS = "timezoneInstancesPrevious";

  /// from: static public final java.lang.String KEY_TIMEZONE_TYPE
  ///
  /// They key for updating the use of auto/home time zones in Calendar.
  /// Valid values are \#TIMEZONE_TYPE_AUTO or
  /// \#TIMEZONE_TYPE_HOME.
  static const KEY_TIMEZONE_TYPE = "timezoneType";

  /// from: static public final java.lang.String TIMEZONE_TYPE_AUTO
  ///
  /// The value to write to \#KEY_TIMEZONE_TYPE if the provider
  /// should stay in sync with the device's time zone.
  static const TIMEZONE_TYPE_AUTO = "auto";

  /// from: static public final java.lang.String TIMEZONE_TYPE_HOME
  ///
  /// The value to write to \#KEY_TIMEZONE_TYPE if the provider
  /// should use a fixed time zone set by the user.
  static const TIMEZONE_TYPE_HOME = "home";

  static final _id_URI =
      jniAccessors.getStaticFieldIDOf(_classRef, "URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The URI to use for retrieving the properties from the Calendar db.
  static uri_.Uri get URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_URI, jni.JniType.objectType)
      .object);
}

/// from: android.provider.CalendarContract$CalendarAlertsColumns
class CalendarContract_CalendarAlertsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$CalendarAlertsColumns");
  CalendarContract_CalendarAlertsColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String ALARM_TIME
  ///
  /// The alarm time of the event, in UTC. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const ALARM_TIME = "alarmTime";

  /// from: static public final java.lang.String BEGIN
  ///
  /// The start time of the event, in UTC. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const BEGIN = "begin";

  /// from: static public final java.lang.String CREATION_TIME
  ///
  /// The creation time of this database entry, in UTC.
  /// Useful for debugging missed reminders. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const CREATION_TIME = "creationTime";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this alerts queries
  static const DEFAULT_SORT_ORDER = "begin ASC,title ASC";

  /// from: static public final java.lang.String END
  ///
  /// The end time of the event, in UTC. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const END = "end";

  /// from: static public final java.lang.String EVENT_ID
  ///
  /// The event that the alert belongs to. Column name.
  /// <P>Type: INTEGER (foreign key to the Events table)</P>
  static const EVENT_ID = "event_id";

  /// from: static public final java.lang.String MINUTES
  ///
  /// The number of minutes that this alarm precedes the start time. Column
  /// name.
  /// <P>Type: INTEGER</P>
  static const MINUTES = "minutes";

  /// from: static public final java.lang.String NOTIFY_TIME
  ///
  /// The time that the notification was created by the Calendar app,
  /// in UTC. Useful for debugging missed reminders. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const NOTIFY_TIME = "notifyTime";

  /// from: static public final java.lang.String RECEIVED_TIME
  ///
  /// The time that the alarm broadcast was received by the Calendar app,
  /// in UTC. Useful for debugging missed reminders. Column name.
  /// <P>Type: INTEGER (long; millis since epoch)</P>
  static const RECEIVED_TIME = "receivedTime";

  /// from: static public final java.lang.String STATE
  ///
  /// The state of this alert. It starts out as \#STATE_SCHEDULED, then
  /// when the alarm goes off, it changes to \#STATE_FIRED, and then when
  /// the user dismisses the alarm it changes to \#STATE_DISMISSED. Column
  /// name.
  /// <P>Type: INTEGER</P>
  static const STATE = "state";

  /// from: static public final int STATE_DISMISSED
  ///
  /// Once the user has dismissed the notification the alert's state should
  /// be set to dismissed so it is not fired again.
  static const STATE_DISMISSED = 2;

  /// from: static public final int STATE_FIRED
  ///
  /// After a notification for an alert has been created it should be
  /// updated to fired.
  static const STATE_FIRED = 1;

  /// from: static public final int STATE_SCHEDULED
  ///
  /// An alert begins in this state when it is first created.
  static const STATE_SCHEDULED = 0;
}

/// from: android.provider.CalendarContract$CalendarAlerts
///
/// Fields and helpers for accessing calendar alerts information. These
/// fields are for tracking which alerts have been fired. Scheduled alarms
/// will generate an intent using \#ACTION_EVENT_REMINDER. Apps that
/// receive this action may update the \#STATE for the reminder when
/// they have finished handling it. Apps that have their notifications
/// disabled should not modify the table to ensure that they do not conflict
/// with another app that is generating a notification. In general, apps
/// should not need to write to this table directly except to update the
/// state of a reminder.
class CalendarContract_CalendarAlerts extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$CalendarAlerts");
  CalendarContract_CalendarAlerts.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The Uri for querying calendar alert information
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_URI_BY_INSTANCE = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI_BY_INSTANCE", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI_BY_INSTANCE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This URI is for grouping the query results by event_id and begin
  /// time.  This will return one result per instance of an event.  So
  /// events with multiple alarms will appear just once, but multiple
  /// instances of a repeating event will show up multiple times.
  static uri_.Uri get CONTENT_URI_BY_INSTANCE => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_URI_BY_INSTANCE, jni.JniType.objectType)
      .object);
}

/// from: android.provider.CalendarContract$AttendeesColumns
///
/// Columns from the Attendees table that other tables join into themselves.
class CalendarContract_AttendeesColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/CalendarContract\$AttendeesColumns");
  CalendarContract_AttendeesColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String ATTENDEE_EMAIL
  ///
  /// The email address of the attendee. Column name.
  /// <P>Type: STRING</P>
  static const ATTENDEE_EMAIL = "attendeeEmail";

  /// from: static public final java.lang.String ATTENDEE_IDENTITY
  ///
  /// The identity of the attendee as referenced in
  /// ContactsContract.CommonDataKinds.Identity\#IDENTITY.
  /// This is required only if \#ATTENDEE_ID_NAMESPACE is present. Column name.
  /// <P>Type: STRING</P>
  static const ATTENDEE_IDENTITY = "attendeeIdentity";

  /// from: static public final java.lang.String ATTENDEE_ID_NAMESPACE
  ///
  /// The identity name space of the attendee as referenced in
  /// ContactsContract.CommonDataKinds.Identity\#NAMESPACE.
  /// This is required only if \#ATTENDEE_IDENTITY is present. Column name.
  /// <P>Type: STRING</P>
  static const ATTENDEE_ID_NAMESPACE = "attendeeIdNamespace";

  /// from: static public final java.lang.String ATTENDEE_NAME
  ///
  /// The name of the attendee. Column name.
  /// <P>Type: STRING</P>
  static const ATTENDEE_NAME = "attendeeName";

  /// from: static public final java.lang.String ATTENDEE_RELATIONSHIP
  ///
  /// The relationship of the attendee to the user. Column name.
  /// <P>Type: INTEGER (one of \#RELATIONSHIP_ATTENDEE, ...}.</P>
  static const ATTENDEE_RELATIONSHIP = "attendeeRelationship";

  /// from: static public final java.lang.String ATTENDEE_STATUS
  ///
  /// The attendance status of the attendee. Column name.
  /// <P>Type: Integer (one of \#ATTENDEE_STATUS_ACCEPTED, ...).</P>
  static const ATTENDEE_STATUS = "attendeeStatus";

  /// from: static public final int ATTENDEE_STATUS_ACCEPTED
  static const ATTENDEE_STATUS_ACCEPTED = 1;

  /// from: static public final int ATTENDEE_STATUS_DECLINED
  static const ATTENDEE_STATUS_DECLINED = 2;

  /// from: static public final int ATTENDEE_STATUS_INVITED
  static const ATTENDEE_STATUS_INVITED = 3;

  /// from: static public final int ATTENDEE_STATUS_NONE
  static const ATTENDEE_STATUS_NONE = 0;

  /// from: static public final int ATTENDEE_STATUS_TENTATIVE
  static const ATTENDEE_STATUS_TENTATIVE = 4;

  /// from: static public final java.lang.String ATTENDEE_TYPE
  ///
  /// The type of attendee. Column name.
  /// <P>
  /// Type: Integer (one of \#TYPE_NONE, \#TYPE_REQUIRED,
  /// \#TYPE_OPTIONAL, \#TYPE_RESOURCE)
  /// </P>
  static const ATTENDEE_TYPE = "attendeeType";

  /// from: static public final java.lang.String EVENT_ID
  ///
  /// The id of the event. Column name.
  /// <P>Type: INTEGER</P>
  static const EVENT_ID = "event_id";

  /// from: static public final int RELATIONSHIP_ATTENDEE
  static const RELATIONSHIP_ATTENDEE = 1;

  /// from: static public final int RELATIONSHIP_NONE
  static const RELATIONSHIP_NONE = 0;

  /// from: static public final int RELATIONSHIP_ORGANIZER
  static const RELATIONSHIP_ORGANIZER = 2;

  /// from: static public final int RELATIONSHIP_PERFORMER
  static const RELATIONSHIP_PERFORMER = 3;

  /// from: static public final int RELATIONSHIP_SPEAKER
  static const RELATIONSHIP_SPEAKER = 4;

  /// from: static public final int TYPE_NONE
  static const TYPE_NONE = 0;

  /// from: static public final int TYPE_OPTIONAL
  static const TYPE_OPTIONAL = 2;

  /// from: static public final int TYPE_REQUIRED
  static const TYPE_REQUIRED = 1;

  /// from: static public final int TYPE_RESOURCE
  ///
  /// This specifies that an attendee is a resource, like a room, a
  /// cabbage, or something and not an actual person.
  static const TYPE_RESOURCE = 3;
}

/// from: android.provider.CalendarContract$Attendees
///
/// Fields and helpers for interacting with Attendees. Each row of this table
/// represents a single attendee or guest of an event. Calling
/// \#query(ContentResolver, long, String[]) will return a list of attendees for
/// the event with the given eventId. Both apps and sync adapters may write
/// to this table. There are six writable fields and all of them except
/// \#ATTENDEE_NAME must be included when inserting a new attendee.
/// They are:
/// <ul>
/// <li>\#EVENT_ID</li>
/// <li>\#ATTENDEE_NAME</li>
/// <li>\#ATTENDEE_EMAIL</li>
/// <li>\#ATTENDEE_RELATIONSHIP</li>
/// <li>\#ATTENDEE_TYPE</li>
/// <li>\#ATTENDEE_STATUS</li>
/// <li>\#ATTENDEE_IDENTITY</li>
/// <li>\#ATTENDEE_ID_NAMESPACE</li>
/// </ul>
class CalendarContract_Attendees extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/CalendarContract\$Attendees");
  CalendarContract_Attendees.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for accessing Attendees data
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_query = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;J[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, long eventId, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Queries all attendees associated with the given event. This is a
  /// blocking call and should not be done on the UI thread.
  ///@param cr The content resolver to use for the query
  ///@param eventId The id of the event to retrieve attendees for
  ///@param projection the columns to return in the cursor
  ///@return A Cursor containing all attendees for the event
  static cursor_.Cursor query(contentresolver_.ContentResolver cr, int eventId,
          jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_query,
          jni.JniType.objectType,
          [cr.reference, eventId, projection.reference]).object);
}
