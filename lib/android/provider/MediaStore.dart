// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../net/Uri.dart" as uri_;

import "../content/Context.dart" as context_;

import "../database/Cursor.dart" as cursor_;

import "../content/ContentResolver.dart" as contentresolver_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../graphics/BitmapFactory.dart" as bitmapfactory_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.MediaStore
///
/// The Media provider contains meta data for all available media on both internal
/// and external storage devices.
class MediaStore extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore");
  MediaStore.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_IMAGE_CAPTURE
  ///
  /// Standard Intent action that can be sent to have the camera application
  /// capture an image and return it.
  ///
  /// The caller may pass an extra EXTRA_OUTPUT to control where this image will be written.
  /// If the EXTRA_OUTPUT is not present, then a small sized image is returned as a Bitmap
  /// object in the extra field. This is useful for applications that only need a small image.
  /// If the EXTRA_OUTPUT is present, then the full-sized image will be written to the Uri
  /// value of EXTRA_OUTPUT.
  /// As of android.os.Build.VERSION_CODES\#LOLLIPOP, this uri can also be supplied through
  /// android.content.Intent\#setClipData(ClipData). If using this approach, you still must
  /// supply the uri through the EXTRA_OUTPUT field for compatibility with old applications.
  /// If you don't set a ClipData, it will be copied there for you when calling
  /// Context\#startActivity(Intent).
  ///
  /// Note: if you app targets android.os.Build.VERSION_CODES\#M M and above
  /// and declares as using the android.Manifest.permission\#CAMERA permission which
  /// is not granted, then attempting to use this action will result in a java.lang.SecurityException.
  ///@see \#EXTRA_OUTPUT
  static const ACTION_IMAGE_CAPTURE = "android.media.action.IMAGE_CAPTURE";

  /// from: static public final java.lang.String ACTION_IMAGE_CAPTURE_SECURE
  ///
  /// Intent action that can be sent to have the camera application capture an image and return
  /// it when the device is secured (e.g.&nbsp;with a pin, password, pattern, or face unlock).
  /// Applications responding to this intent must not expose any personal content like existing
  /// photos or videos on the device. The applications should be careful not to share any photo
  /// or video with other applications or internet. The activity should use android.view.WindowManager.LayoutParams\#FLAG_SHOW_WHEN_LOCKED to display on top of the
  /// lock screen while secured. There is no activity stack when this flag is used, so
  /// launching more than one activity is strongly discouraged.
  ///
  /// The caller may pass an extra EXTRA_OUTPUT to control where this image will be written.
  /// If the EXTRA_OUTPUT is not present, then a small sized image is returned as a Bitmap
  /// object in the extra field. This is useful for applications that only need a small image.
  /// If the EXTRA_OUTPUT is present, then the full-sized image will be written to the Uri
  /// value of EXTRA_OUTPUT.
  /// As of android.os.Build.VERSION_CODES\#LOLLIPOP, this uri can also be supplied through
  /// android.content.Intent\#setClipData(ClipData). If using this approach, you still must
  /// supply the uri through the EXTRA_OUTPUT field for compatibility with old applications.
  /// If you don't set a ClipData, it will be copied there for you when calling
  /// Context\#startActivity(Intent).
  ///@see \#ACTION_IMAGE_CAPTURE
  ///@see \#EXTRA_OUTPUT
  static const ACTION_IMAGE_CAPTURE_SECURE =
      "android.media.action.IMAGE_CAPTURE_SECURE";

  /// from: static public final java.lang.String ACTION_VIDEO_CAPTURE
  ///
  /// Standard Intent action that can be sent to have the camera application
  /// capture a video and return it.
  ///
  /// The caller may pass in an extra EXTRA_VIDEO_QUALITY to control the video quality.
  ///
  /// The caller may pass in an extra EXTRA_OUTPUT to control
  /// where the video is written. If EXTRA_OUTPUT is not present the video will be
  /// written to the standard location for videos, and the Uri of that location will be
  /// returned in the data field of the Uri.
  /// As of android.os.Build.VERSION_CODES\#LOLLIPOP, this uri can also be supplied through
  /// android.content.Intent\#setClipData(ClipData). If using this approach, you still must
  /// supply the uri through the EXTRA_OUTPUT field for compatibility with old applications.
  /// If you don't set a ClipData, it will be copied there for you when calling
  /// Context\#startActivity(Intent).
  ///
  /// Note: if you app targets android.os.Build.VERSION_CODES\#M M and above
  /// and declares as using the android.Manifest.permission\#CAMERA permission which
  /// is not granted, then atempting to use this action will result in a java.lang.SecurityException.
  ///@see \#EXTRA_OUTPUT
  ///@see \#EXTRA_VIDEO_QUALITY
  ///@see \#EXTRA_SIZE_LIMIT
  ///@see \#EXTRA_DURATION_LIMIT
  static const ACTION_VIDEO_CAPTURE = "android.media.action.VIDEO_CAPTURE";

  /// from: static public final java.lang.String AUTHORITY
  static const AUTHORITY = "media";

  /// from: static public final java.lang.String EXTRA_DURATION_LIMIT
  ///
  /// Specify the maximum allowed recording duration in seconds.
  static const EXTRA_DURATION_LIMIT = "android.intent.extra.durationLimit";

  /// from: static public final java.lang.String EXTRA_FINISH_ON_COMPLETION
  ///
  /// The name of the Intent-extra used to control the onCompletion behavior of a MovieView.
  /// This is a boolean property that specifies whether or not to finish the MovieView activity
  /// when the movie completes playing. The default value is true, which means to automatically
  /// exit the movie player activity when the movie completes playing.
  static const EXTRA_FINISH_ON_COMPLETION =
      "android.intent.extra.finishOnCompletion";

  /// from: static public final java.lang.String EXTRA_FULL_SCREEN
  ///
  /// The name of an Intent-extra used to control the UI of a ViewImage.
  /// This is a boolean property that overrides the activity's default fullscreen state.
  static const EXTRA_FULL_SCREEN = "android.intent.extra.fullScreen";

  /// from: static public final java.lang.String EXTRA_MEDIA_ALBUM
  ///
  /// The name of the Intent-extra used to define the album
  static const EXTRA_MEDIA_ALBUM = "android.intent.extra.album";

  /// from: static public final java.lang.String EXTRA_MEDIA_ARTIST
  ///
  /// The name of the Intent-extra used to define the artist
  static const EXTRA_MEDIA_ARTIST = "android.intent.extra.artist";

  /// from: static public final java.lang.String EXTRA_MEDIA_FOCUS
  ///
  /// The name of the Intent-extra used to define the search focus. The search focus
  /// indicates whether the search should be for things related to the artist, album
  /// or song that is identified by the other extras.
  static const EXTRA_MEDIA_FOCUS = "android.intent.extra.focus";

  /// from: static public final java.lang.String EXTRA_MEDIA_GENRE
  ///
  /// The name of the Intent-extra used to define the genre.
  static const EXTRA_MEDIA_GENRE = "android.intent.extra.genre";

  /// from: static public final java.lang.String EXTRA_MEDIA_PLAYLIST
  ///
  /// The name of the Intent-extra used to define the playlist.
  static const EXTRA_MEDIA_PLAYLIST = "android.intent.extra.playlist";

  /// from: static public final java.lang.String EXTRA_MEDIA_RADIO_CHANNEL
  ///
  /// The name of the Intent-extra used to define the radio channel.
  static const EXTRA_MEDIA_RADIO_CHANNEL = "android.intent.extra.radio_channel";

  /// from: static public final java.lang.String EXTRA_MEDIA_TITLE
  ///
  /// The name of the Intent-extra used to define the song title
  static const EXTRA_MEDIA_TITLE = "android.intent.extra.title";

  /// from: static public final java.lang.String EXTRA_OUTPUT
  ///
  /// The name of the Intent-extra used to indicate a content resolver Uri to be used to
  /// store the requested image or video.
  static const EXTRA_OUTPUT = "output";

  /// from: static public final java.lang.String EXTRA_SCREEN_ORIENTATION
  ///
  /// The name of the Intent-extra used to control the orientation of a ViewImage or a MovieView.
  /// This is an int property that overrides the activity's requestedOrientation.
  ///@see android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
  static const EXTRA_SCREEN_ORIENTATION =
      "android.intent.extra.screenOrientation";

  /// from: static public final java.lang.String EXTRA_SHOW_ACTION_ICONS
  ///
  /// The name of an Intent-extra used to control the UI of a ViewImage.
  /// This is a boolean property that specifies whether or not to show action icons.
  static const EXTRA_SHOW_ACTION_ICONS = "android.intent.extra.showActionIcons";

  /// from: static public final java.lang.String EXTRA_SIZE_LIMIT
  ///
  /// Specify the maximum allowed size.
  static const EXTRA_SIZE_LIMIT = "android.intent.extra.sizeLimit";

  /// from: static public final java.lang.String EXTRA_VIDEO_QUALITY
  ///
  /// The name of the Intent-extra used to control the quality of a recorded video. This is an
  /// integer property. Currently value 0 means low quality, suitable for MMS messages, and
  /// value 1 means high quality. In the future other quality levels may be added.
  static const EXTRA_VIDEO_QUALITY = "android.intent.extra.videoQuality";

  /// from: static public final java.lang.String INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
  ///
  /// An intent to perform a search for music media and automatically play content from the
  /// result when possible. This can be fired, for example, by the result of a voice recognition
  /// command to listen to music.
  /// This intent always includes the android.provider.MediaStore\#EXTRA_MEDIA_FOCUS
  /// and android.app.SearchManager\#QUERY extras. The
  /// android.provider.MediaStore\#EXTRA_MEDIA_FOCUS extra determines the search mode, and
  /// the value of the android.app.SearchManager\#QUERY extra depends on the search mode.
  /// For more information about the search modes for this intent, see
  /// <a href="{@docRoot}guide/components/intents-common.html\#PlaySearch">Play music based
  /// on a search query</a> in <a href="{@docRoot}guide/components/intents-common.html">Common
  /// Intents</a>.
  ///
  ///
  /// This intent makes the most sense for apps that can support large-scale search of music,
  /// such as services connected to an online database of music which can be streamed and played
  /// on the device.
  ///
  static const INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH =
      "android.media.action.MEDIA_PLAY_FROM_SEARCH";

  /// from: static public final java.lang.String INTENT_ACTION_MEDIA_SEARCH
  ///
  /// Activity Action: Perform a search for media.
  /// Contains at least the android.app.SearchManager\#QUERY extra.
  /// May also contain any combination of the following extras:
  /// EXTRA_MEDIA_ARTIST, EXTRA_MEDIA_ALBUM, EXTRA_MEDIA_TITLE, EXTRA_MEDIA_FOCUS
  ///@see android.provider.MediaStore\#EXTRA_MEDIA_ARTIST
  ///@see android.provider.MediaStore\#EXTRA_MEDIA_ALBUM
  ///@see android.provider.MediaStore\#EXTRA_MEDIA_TITLE
  ///@see android.provider.MediaStore\#EXTRA_MEDIA_FOCUS
  static const INTENT_ACTION_MEDIA_SEARCH =
      "android.intent.action.MEDIA_SEARCH";

  /// from: static public final java.lang.String INTENT_ACTION_MUSIC_PLAYER
  ///
  /// Activity Action: Launch a music player.
  /// The activity should be able to play, browse, or manipulate music files stored on the device.
  ///@deprecated Use android.content.Intent\#CATEGORY_APP_MUSIC instead.
  static const INTENT_ACTION_MUSIC_PLAYER =
      "android.intent.action.MUSIC_PLAYER";

  /// from: static public final java.lang.String INTENT_ACTION_STILL_IMAGE_CAMERA
  ///
  /// The name of the Intent action used to launch a camera in still image mode.
  static const INTENT_ACTION_STILL_IMAGE_CAMERA =
      "android.media.action.STILL_IMAGE_CAMERA";

  /// from: static public final java.lang.String INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE
  ///
  /// The name of the Intent action used to launch a camera in still image mode
  /// for use when the device is secured (e.g.&nbsp;with a pin, password, pattern,
  /// or face unlock). Applications responding to this intent must not expose
  /// any personal content like existing photos or videos on the device. The
  /// applications should be careful not to share any photo or video with other
  /// applications or internet. The activity should use android.view.WindowManager.LayoutParams\#FLAG_SHOW_WHEN_LOCKED to display
  /// on top of the lock screen while secured. There is no activity stack when
  /// this flag is used, so launching more than one activity is strongly
  /// discouraged.
  static const INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE =
      "android.media.action.STILL_IMAGE_CAMERA_SECURE";

  /// from: static public final java.lang.String INTENT_ACTION_TEXT_OPEN_FROM_SEARCH
  ///
  /// An intent to perform a search for readable media and automatically play content from the
  /// result when possible. This can be fired, for example, by the result of a voice recognition
  /// command to read a book or magazine.
  ///
  /// Contains the android.app.SearchManager\#QUERY extra, which is a string that can
  /// contain any type of unstructured text search, like the name of a book or magazine, an author
  /// a genre, a publisher, or any combination of these.
  ///
  /// Because this intent includes an open-ended unstructured search string, it makes the most
  /// sense for apps that can support large-scale search of text media, such as services connected
  /// to an online database of books and/or magazines which can be read on the device.
  static const INTENT_ACTION_TEXT_OPEN_FROM_SEARCH =
      "android.media.action.TEXT_OPEN_FROM_SEARCH";

  /// from: static public final java.lang.String INTENT_ACTION_VIDEO_CAMERA
  ///
  /// The name of the Intent action used to launch a camera in video mode.
  static const INTENT_ACTION_VIDEO_CAMERA = "android.media.action.VIDEO_CAMERA";

  /// from: static public final java.lang.String INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH
  ///
  /// An intent to perform a search for video media and automatically play content from the
  /// result when possible. This can be fired, for example, by the result of a voice recognition
  /// command to play movies.
  ///
  /// Contains the android.app.SearchManager\#QUERY extra, which is a string that can
  /// contain any type of unstructured video search, like the name of a movie, one or more actors,
  /// a genre, or any combination of these.
  ///
  /// Because this intent includes an open-ended unstructured search string, it makes the most
  /// sense for apps that can support large-scale search of video, such as services connected to an
  /// online database of videos which can be streamed and played on the device.
  static const INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH =
      "android.media.action.VIDEO_PLAY_FROM_SEARCH";

  /// from: static public final java.lang.String MEDIA_IGNORE_FILENAME
  ///
  /// Name of the file signaling the media scanner to ignore media in the containing directory
  /// and its subdirectories. Developers should use this to avoid application graphics showing
  /// up in the Gallery and likewise prevent application sounds and music from showing up in
  /// the Music app.
  static const MEDIA_IGNORE_FILENAME = ".nomedia";

  /// from: static public final java.lang.String MEDIA_SCANNER_VOLUME
  ///
  /// Name of current volume being scanned by the media scanner.
  static const MEDIA_SCANNER_VOLUME = "volume";

  /// from: static public final java.lang.String META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE
  ///
  /// Name under which an activity handling \#INTENT_ACTION_STILL_IMAGE_CAMERA or
  /// \#INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE publishes the service name for its prewarm
  /// service.
  ///
  /// This meta-data should reference the fully qualified class name of the prewarm service
  /// extending CameraPrewarmService.
  ///
  /// The prewarm service will get bound and receive a prewarm signal
  /// CameraPrewarmService\#onPrewarm() when a camera launch intent fire might be imminent.
  /// An application implementing a prewarm service should do the absolute minimum amount of work
  /// to initialize the camera in order to reduce startup time in likely case that shortly after a
  /// camera launch intent would be sent.
  static const META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE =
      "android.media.still_image_camera_preview_service";

  /// from: static public final java.lang.String UNKNOWN_STRING
  ///
  /// The string that is used when a media attribute is not known. For example,
  /// if an audio file does not have any meta data, the artist and album columns
  /// will be set to this value.
  static const UNKNOWN_STRING = "<unknown>";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getMediaScannerUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMediaScannerUri", "()Landroid/net/Uri;");

  /// from: static public android.net.Uri getMediaScannerUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Uri for querying the state of the media scanner.
  static uri_.Uri getMediaScannerUri() =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getMediaScannerUri, jni.JniType.objectType, []).object);

  static final _id_getVersion = jniAccessors.getStaticMethodIDOf(
      _classRef, "getVersion", "(Landroid/content/Context;)Ljava/lang/String;");

  /// from: static public java.lang.String getVersion(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the media provider's version.
  /// Applications that import data from the media provider into their own caches
  /// can use this to detect that the media provider changed, and reimport data
  /// as needed. No other assumptions should be made about the meaning of the version.
  ///@param context Context to use for performing the query.
  ///@return A version string, or null if the version could not be determined.
  static jni.JniString getVersion(context_.Context context) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getVersion, jni.JniType.objectType, [context.reference]).object);

  static final _id_getDocumentUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDocumentUri",
      "(Landroid/content/Context;Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getDocumentUri(android.content.Context context, android.net.Uri mediaUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a URI backed by a DocumentsProvider that points to the same media
  /// file as the specified mediaUri. This allows apps who have permissions to access
  /// media files in Storage Access Framework to perform file operations through that
  /// on media files.
  ///
  /// Note: this method doesn't grant any URI permission. Callers need to obtain
  /// permission before calling this method. One way to obtain permission is through
  /// a 3-step process:
  /// <ol>
  ///     <li>Call android.os.storage.StorageManager\#getStorageVolume(File) to
  ///     obtain the android.os.storage.StorageVolume of a media file;</li>
  ///
  ///     <li>Invoke the intent returned by
  ///     android.os.storage.StorageVolume\#createAccessIntent(String) to
  ///     obtain the access of the volume or one of its specific subdirectories;</li>
  ///
  ///     <li>Check whether permission is granted and take persistent permission.</li>
  /// </ol>
  ///@param mediaUri the media URI which document URI is requested
  ///@return the document URI
  static uri_.Uri getDocumentUri(context_.Context context, uri_.Uri mediaUri) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDocumentUri,
          jni.JniType.objectType,
          [context.reference, mediaUri.reference]).object);
}

/// from: android.provider.MediaStore$Video
class MediaStore_Video extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Video");
  MediaStore_Video.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table.
  static const DEFAULT_SORT_ORDER = "_display_name";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Video()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_query = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, android.net.Uri uri, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static cursor_.Cursor query(contentresolver_.ContentResolver cr, uri_.Uri uri,
          jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_query,
          jni.JniType.objectType,
          [cr.reference, uri.reference, projection.reference]).object);
}

/// from: android.provider.MediaStore$Video$VideoColumns
class MediaStore_Video_VideoColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Video\$VideoColumns");
  MediaStore_Video_VideoColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ALBUM
  ///
  /// The album the video file is from, if any
  /// <P>Type: TEXT</P>
  static const ALBUM = "album";

  /// from: static public final java.lang.String ARTIST
  ///
  /// The artist who created the video file, if any
  /// <P>Type: TEXT</P>
  static const ARTIST = "artist";

  /// from: static public final java.lang.String BOOKMARK
  ///
  /// The bookmark for the video. Time in ms. Represents the location in the video that the
  /// video should start playing at the next time it is opened. If the value is null or
  /// out of the range 0..DURATION-1 then the video should start playing from the
  /// beginning.
  /// <P>Type: INTEGER</P>
  static const BOOKMARK = "bookmark";

  /// from: static public final java.lang.String BUCKET_DISPLAY_NAME
  ///
  /// The bucket display name of the video. This is a read-only property that
  /// is automatically computed from the DATA column.
  /// <P>Type: TEXT</P>
  static const BUCKET_DISPLAY_NAME = "bucket_display_name";

  /// from: static public final java.lang.String BUCKET_ID
  ///
  /// The bucket id of the video. This is a read-only property that
  /// is automatically computed from the DATA column.
  /// <P>Type: TEXT</P>
  static const BUCKET_ID = "bucket_id";

  /// from: static public final java.lang.String CATEGORY
  ///
  /// The YouTube category of the video
  /// <P>Type: TEXT</P>
  static const CATEGORY = "category";

  /// from: static public final java.lang.String DATE_TAKEN
  ///
  /// The date & time that the video was taken in units
  /// of milliseconds since jan 1, 1970.
  /// <P>Type: INTEGER</P>
  static const DATE_TAKEN = "datetaken";

  /// from: static public final java.lang.String DESCRIPTION
  ///
  /// The description of the video recording
  /// <P>Type: TEXT</P>
  static const DESCRIPTION = "description";

  /// from: static public final java.lang.String DURATION
  ///
  /// The duration of the video file, in ms
  /// <P>Type: INTEGER (long)</P>
  static const DURATION = "duration";

  /// from: static public final java.lang.String IS_PRIVATE
  ///
  /// Whether the video should be published as public or private
  /// <P>Type: INTEGER</P>
  static const IS_PRIVATE = "isprivate";

  /// from: static public final java.lang.String LANGUAGE
  ///
  /// The language of the video
  /// <P>Type: TEXT</P>
  static const LANGUAGE = "language";

  /// from: static public final java.lang.String LATITUDE
  ///
  /// The latitude where the video was captured.
  /// <P>Type: DOUBLE</P>
  static const LATITUDE = "latitude";

  /// from: static public final java.lang.String LONGITUDE
  ///
  /// The longitude where the video was captured.
  /// <P>Type: DOUBLE</P>
  static const LONGITUDE = "longitude";

  /// from: static public final java.lang.String MINI_THUMB_MAGIC
  ///
  /// The mini thumb id.
  /// <P>Type: INTEGER</P>
  static const MINI_THUMB_MAGIC = "mini_thumb_magic";

  /// from: static public final java.lang.String RESOLUTION
  ///
  /// The resolution of the video file, formatted as "XxY"
  /// <P>Type: TEXT</P>
  static const RESOLUTION = "resolution";

  /// from: static public final java.lang.String TAGS
  ///
  /// The user-added tags associated with a video
  /// <P>Type: TEXT</P>
  static const TAGS = "tags";
}

/// from: android.provider.MediaStore$Video$Thumbnails
///
/// This class allows developers to query and get two kinds of thumbnails:
/// MINI_KIND: 512 x 384 thumbnail
/// MICRO_KIND: 96 x 96 thumbnail
class MediaStore_Video_Thumbnails extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Video\$Thumbnails");
  MediaStore_Video_Thumbnails.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String DATA
  ///
  /// Path to the thumbnail file on disk.
  ///
  /// Note that apps may not have filesystem permissions to directly
  /// access this path. Instead of trying to open this path directly,
  /// apps should use
  /// ContentResolver\#openFileDescriptor(Uri, String) to gain
  /// access.
  ///
  /// Type: TEXT
  static const DATA = "_data";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "video_id ASC";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final int FULL_SCREEN_KIND
  static const FULL_SCREEN_KIND = 2;

  /// from: static public final java.lang.String HEIGHT
  ///
  /// The height of the thumbnail
  /// <P>Type: INTEGER (long)</P>
  static const HEIGHT = "height";

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String KIND
  ///
  /// The kind of the thumbnail
  /// <P>Type: INTEGER (One of the values below)</P>
  static const KIND = "kind";

  /// from: static public final int MICRO_KIND
  static const MICRO_KIND = 3;

  /// from: static public final int MINI_KIND
  static const MINI_KIND = 1;

  /// from: static public final java.lang.String VIDEO_ID
  ///
  /// The original image for the thumbnal
  /// <P>Type: INTEGER (ID from Video table)</P>
  static const VIDEO_ID = "video_id";

  /// from: static public final java.lang.String WIDTH
  ///
  /// The width of the thumbnal
  /// <P>Type: INTEGER (long)</P>
  static const WIDTH = "width";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Video_Thumbnails()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_cancelThumbnailRequest = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cancelThumbnailRequest",
      "(Landroid/content/ContentResolver;J)V");

  /// from: static public void cancelThumbnailRequest(android.content.ContentResolver cr, long origId)
  ///
  /// This method cancels the thumbnail request so clients waiting for getThumbnail will be
  /// interrupted and return immediately. Only the original process which made the getThumbnail
  /// requests can cancel their own requests.
  ///@param cr ContentResolver
  ///@param origId original video id
  static void cancelThumbnailRequest(
          contentresolver_.ContentResolver cr, int origId) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cancelThumbnailRequest,
          jni.JniType.voidType,
          [cr.reference, origId]).check();

  static final _id_getThumbnail = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getThumbnail",
      "(Landroid/content/ContentResolver;JILandroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap getThumbnail(android.content.ContentResolver cr, long origId, int kind, android.graphics.BitmapFactory.Options options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method checks if the thumbnails of the specified image (origId) has been created.
  /// It will be blocked until the thumbnails are generated.
  ///@param cr ContentResolver used to dispatch queries to MediaProvider.
  ///@param origId Original image id associated with thumbnail of interest.
  ///@param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
  ///@param options this is only used for MINI_KIND when decoding the Bitmap
  ///@return A Bitmap instance. It could be null if the original image
  ///         associated with origId doesn't exist or memory is not enough.
  static bitmap_.Bitmap getThumbnail(contentresolver_.ContentResolver cr,
          int origId, int kind, bitmapfactory_.BitmapFactory_Options options) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getThumbnail,
          jni.JniType.objectType,
          [cr.reference, origId, kind, options.reference]).object);

  static final _id_getThumbnail1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getThumbnail",
      "(Landroid/content/ContentResolver;JJILandroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap getThumbnail(android.content.ContentResolver cr, long origId, long groupId, int kind, android.graphics.BitmapFactory.Options options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method checks if the thumbnails of the specified image (origId) has been created.
  /// It will be blocked until the thumbnails are generated.
  ///@param cr ContentResolver used to dispatch queries to MediaProvider.
  ///@param origId Original image id associated with thumbnail of interest.
  ///@param groupId the id of group to which this request belongs
  ///@param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND
  ///@param options this is only used for MINI_KIND when decoding the Bitmap
  ///@return A Bitmap instance. It could be null if the original image associated with
  ///         origId doesn't exist or memory is not enough.
  static bitmap_.Bitmap getThumbnail1(
          contentresolver_.ContentResolver cr,
          int origId,
          int groupId,
          int kind,
          bitmapfactory_.BitmapFactory_Options options) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getThumbnail1,
          jni.JniType.objectType,
          [cr.reference, origId, groupId, kind, options.reference]).object);

  static final _id_cancelThumbnailRequest1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cancelThumbnailRequest",
      "(Landroid/content/ContentResolver;JJ)V");

  /// from: static public void cancelThumbnailRequest(android.content.ContentResolver cr, long origId, long groupId)
  ///
  /// This method cancels the thumbnail request so clients waiting for getThumbnail will be
  /// interrupted and return immediately. Only the original process which made the getThumbnail
  /// requests can cancel their own requests.
  ///@param cr ContentResolver
  ///@param origId original video id
  ///@param groupId the same groupId used in getThumbnail.
  static void cancelThumbnailRequest1(
          contentresolver_.ContentResolver cr, int origId, int groupId) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cancelThumbnailRequest1,
          jni.JniType.voidType,
          [cr.reference, origId, groupId]).check();

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the image media table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the image media table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);
}

/// from: android.provider.MediaStore$Video$Media
class MediaStore_Video_Media extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Video\$Media");
  MediaStore_Video_Media.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type for this table.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/video";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "title";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Video_Media()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the video media table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the video media table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);
}

/// from: android.provider.MediaStore$MediaColumns
///
/// Common fields for most MediaProvider tables
class MediaStore_MediaColumns extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$MediaColumns");
  MediaStore_MediaColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String DATA
  ///
  /// Path to the file on disk.
  ///
  /// Note that apps may not have filesystem permissions to directly access
  /// this path. Instead of trying to open this path directly, apps should
  /// use ContentResolver\#openFileDescriptor(Uri, String) to gain
  /// access.
  ///
  /// Type: TEXT
  static const DATA = "_data";

  /// from: static public final java.lang.String DATE_ADDED
  ///
  /// The time the file was added to the media provider
  /// Units are seconds since 1970.
  /// <P>Type: INTEGER (long)</P>
  static const DATE_ADDED = "date_added";

  /// from: static public final java.lang.String DATE_MODIFIED
  ///
  /// The time the file was last modified
  /// Units are seconds since 1970.
  /// NOTE: This is for internal use by the media scanner.  Do not modify this field.
  /// <P>Type: INTEGER (long)</P>
  static const DATE_MODIFIED = "date_modified";

  /// from: static public final java.lang.String DISPLAY_NAME
  ///
  /// The display name of the file
  /// <P>Type: TEXT</P>
  static const DISPLAY_NAME = "_display_name";

  /// from: static public final java.lang.String HEIGHT
  ///
  /// The height of the image/video in pixels.
  static const HEIGHT = "height";

  /// from: static public final java.lang.String MIME_TYPE
  ///
  /// The MIME type of the file
  /// <P>Type: TEXT</P>
  static const MIME_TYPE = "mime_type";

  /// from: static public final java.lang.String SIZE
  ///
  /// The size of the file in bytes
  /// <P>Type: INTEGER (long)</P>
  static const SIZE = "_size";

  /// from: static public final java.lang.String TITLE
  ///
  /// The title of the content
  /// <P>Type: TEXT</P>
  static const TITLE = "title";

  /// from: static public final java.lang.String WIDTH
  ///
  /// The width of the image/video in pixels.
  static const WIDTH = "width";
}

/// from: android.provider.MediaStore$Images
///
/// Contains meta data for all available images.
class MediaStore_Images extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Images");
  MediaStore_Images.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Images()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.MediaStore$Images$Thumbnails
///
/// This class allows developers to query and get two kinds of thumbnails:
/// MINI_KIND: 512 x 384 thumbnail
/// MICRO_KIND: 96 x 96 thumbnail
class MediaStore_Images_Thumbnails extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Images\$Thumbnails");
  MediaStore_Images_Thumbnails.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String DATA
  ///
  /// Path to the thumbnail file on disk.
  ///
  /// Note that apps may not have filesystem permissions to directly
  /// access this path. Instead of trying to open this path directly,
  /// apps should use
  /// ContentResolver\#openFileDescriptor(Uri, String) to gain
  /// access.
  ///
  /// Type: TEXT
  static const DATA = "_data";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "image_id ASC";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final int FULL_SCREEN_KIND
  static const FULL_SCREEN_KIND = 2;

  /// from: static public final java.lang.String HEIGHT
  ///
  /// The height of the thumbnail
  /// <P>Type: INTEGER (long)</P>
  static const HEIGHT = "height";

  /// from: static public final java.lang.String IMAGE_ID
  ///
  /// The original image for the thumbnal
  /// <P>Type: INTEGER (ID from Images table)</P>
  static const IMAGE_ID = "image_id";

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String KIND
  ///
  /// The kind of the thumbnail
  /// <P>Type: INTEGER (One of the values below)</P>
  static const KIND = "kind";

  /// from: static public final int MICRO_KIND
  static const MICRO_KIND = 3;

  /// from: static public final int MINI_KIND
  static const MINI_KIND = 1;

  /// from: static public final java.lang.String THUMB_DATA
  ///
  /// The blob raw data of thumbnail
  /// <P>Type: DATA STREAM</P>
  static const THUMB_DATA = "thumb_data";

  /// from: static public final java.lang.String WIDTH
  ///
  /// The width of the thumbnal
  /// <P>Type: INTEGER (long)</P>
  static const WIDTH = "width";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Images_Thumbnails()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_query = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public final android.database.Cursor query(android.content.ContentResolver cr, android.net.Uri uri, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static cursor_.Cursor query(contentresolver_.ContentResolver cr, uri_.Uri uri,
          jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_query,
          jni.JniType.objectType,
          [cr.reference, uri.reference, projection.reference]).object);

  static final _id_queryMiniThumbnails = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "queryMiniThumbnails",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;I[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public final android.database.Cursor queryMiniThumbnails(android.content.ContentResolver cr, android.net.Uri uri, int kind, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static cursor_.Cursor queryMiniThumbnails(contentresolver_.ContentResolver cr,
          uri_.Uri uri, int kind, jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_queryMiniThumbnails,
          jni.JniType.objectType,
          [cr.reference, uri.reference, kind, projection.reference]).object);

  static final _id_queryMiniThumbnail = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "queryMiniThumbnail",
      "(Landroid/content/ContentResolver;JI[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public final android.database.Cursor queryMiniThumbnail(android.content.ContentResolver cr, long origId, int kind, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static cursor_.Cursor queryMiniThumbnail(contentresolver_.ContentResolver cr,
          int origId, int kind, jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_queryMiniThumbnail,
          jni.JniType.objectType,
          [cr.reference, origId, kind, projection.reference]).object);

  static final _id_cancelThumbnailRequest = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cancelThumbnailRequest",
      "(Landroid/content/ContentResolver;J)V");

  /// from: static public void cancelThumbnailRequest(android.content.ContentResolver cr, long origId)
  ///
  /// This method cancels the thumbnail request so clients waiting for getThumbnail will be
  /// interrupted and return immediately. Only the original process which made the getThumbnail
  /// requests can cancel their own requests.
  ///@param cr ContentResolver
  ///@param origId original image id
  static void cancelThumbnailRequest(
          contentresolver_.ContentResolver cr, int origId) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cancelThumbnailRequest,
          jni.JniType.voidType,
          [cr.reference, origId]).check();

  static final _id_getThumbnail = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getThumbnail",
      "(Landroid/content/ContentResolver;JILandroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap getThumbnail(android.content.ContentResolver cr, long origId, int kind, android.graphics.BitmapFactory.Options options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method checks if the thumbnails of the specified image (origId) has been created.
  /// It will be blocked until the thumbnails are generated.
  ///@param cr ContentResolver used to dispatch queries to MediaProvider.
  ///@param origId Original image id associated with thumbnail of interest.
  ///@param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
  ///@param options this is only used for MINI_KIND when decoding the Bitmap
  ///@return A Bitmap instance. It could be null if the original image
  ///         associated with origId doesn't exist or memory is not enough.
  static bitmap_.Bitmap getThumbnail(contentresolver_.ContentResolver cr,
          int origId, int kind, bitmapfactory_.BitmapFactory_Options options) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getThumbnail,
          jni.JniType.objectType,
          [cr.reference, origId, kind, options.reference]).object);

  static final _id_cancelThumbnailRequest1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cancelThumbnailRequest",
      "(Landroid/content/ContentResolver;JJ)V");

  /// from: static public void cancelThumbnailRequest(android.content.ContentResolver cr, long origId, long groupId)
  ///
  /// This method cancels the thumbnail request so clients waiting for getThumbnail will be
  /// interrupted and return immediately. Only the original process which made the getThumbnail
  /// requests can cancel their own requests.
  ///@param cr ContentResolver
  ///@param origId original image id
  ///@param groupId the same groupId used in getThumbnail.
  static void cancelThumbnailRequest1(
          contentresolver_.ContentResolver cr, int origId, int groupId) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cancelThumbnailRequest1,
          jni.JniType.voidType,
          [cr.reference, origId, groupId]).check();

  static final _id_getThumbnail1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getThumbnail",
      "(Landroid/content/ContentResolver;JJILandroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap getThumbnail(android.content.ContentResolver cr, long origId, long groupId, int kind, android.graphics.BitmapFactory.Options options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method checks if the thumbnails of the specified image (origId) has been created.
  /// It will be blocked until the thumbnails are generated.
  ///@param cr ContentResolver used to dispatch queries to MediaProvider.
  ///@param origId Original image id associated with thumbnail of interest.
  ///@param groupId the id of group to which this request belongs
  ///@param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
  ///@param options this is only used for MINI_KIND when decoding the Bitmap
  ///@return A Bitmap instance. It could be null if the original image
  ///         associated with origId doesn't exist or memory is not enough.
  static bitmap_.Bitmap getThumbnail1(
          contentresolver_.ContentResolver cr,
          int origId,
          int groupId,
          int kind,
          bitmapfactory_.BitmapFactory_Options options) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getThumbnail1,
          jni.JniType.objectType,
          [cr.reference, origId, groupId, kind, options.reference]).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the image media table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the image media table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);
}

/// from: android.provider.MediaStore$Images$Media
class MediaStore_Images_Media extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Images\$Media");
  MediaStore_Images_Media.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of of this directory of
  /// images.  Note that each entry in this directory will have a standard
  /// image MIME type as appropriate -- for example, image/jpeg.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/image";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "bucket_display_name";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Images_Media()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_query = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, android.net.Uri uri, java.lang.String[] projection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static cursor_.Cursor query(contentresolver_.ContentResolver cr, uri_.Uri uri,
          jni.JniObject projection) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_query,
          jni.JniType.objectType,
          [cr.reference, uri.reference, projection.reference]).object);

  static final _id_query1 = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, android.net.Uri uri, java.lang.String[] projection, java.lang.String where, java.lang.String orderBy)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static cursor_.Cursor query1(
          contentresolver_.ContentResolver cr,
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString where,
          jni.JniString orderBy) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_query1, jni.JniType.objectType, [
        cr.reference,
        uri.reference,
        projection.reference,
        where.reference,
        orderBy.reference
      ]).object);

  static final _id_query2 = jniAccessors.getStaticMethodIDOf(_classRef, "query",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: static public android.database.Cursor query(android.content.ContentResolver cr, android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String orderBy)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static cursor_.Cursor query2(
          contentresolver_.ContentResolver cr,
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString orderBy) =>
      cursor_.Cursor.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_query2, jni.JniType.objectType, [
        cr.reference,
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        orderBy.reference
      ]).object);

  static final _id_getBitmap = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getBitmap",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap getBitmap(android.content.ContentResolver cr, android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves an image for the given url as a Bitmap.
  ///@param cr The content resolver to use
  ///@param url The url of the image
  ///@throws FileNotFoundException
  ///@throws IOException
  static bitmap_.Bitmap getBitmap(
          contentresolver_.ContentResolver cr, uri_.Uri url) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getBitmap,
          jni.JniType.objectType,
          [cr.reference, url.reference]).object);

  static final _id_insertImage = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "insertImage",
      "(Landroid/content/ContentResolver;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String insertImage(android.content.ContentResolver cr, java.lang.String imagePath, java.lang.String name, java.lang.String description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Insert an image and create a thumbnail for it.
  ///@param cr The content resolver to use
  ///@param imagePath The path to the image to insert
  ///@param name The name of the image
  ///@param description The description of the image
  ///@return The URL to the newly created image
  ///@throws FileNotFoundException
  static jni.JniString insertImage(
          contentresolver_.ContentResolver cr,
          jni.JniString imagePath,
          jni.JniString name,
          jni.JniString description) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_insertImage, jni.JniType.objectType, [
        cr.reference,
        imagePath.reference,
        name.reference,
        description.reference
      ]).object);

  static final _id_insertImage1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "insertImage",
      "(Landroid/content/ContentResolver;Landroid/graphics/Bitmap;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String insertImage(android.content.ContentResolver cr, android.graphics.Bitmap source, java.lang.String title, java.lang.String description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Insert an image and create a thumbnail for it.
  ///@param cr The content resolver to use
  ///@param source The stream to use for the image
  ///@param title The name of the image
  ///@param description The description of the image
  ///@return The URL to the newly created image, or <code>null</code> if the image failed to be stored
  ///              for any reason.
  static jni.JniString insertImage1(
          contentresolver_.ContentResolver cr,
          bitmap_.Bitmap source,
          jni.JniString title,
          jni.JniString description) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_insertImage1, jni.JniType.objectType, [
        cr.reference,
        source.reference,
        title.reference,
        description.reference
      ]).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the image media table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the image media table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);
}

/// from: android.provider.MediaStore$Images$ImageColumns
class MediaStore_Images_ImageColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Images\$ImageColumns");
  MediaStore_Images_ImageColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String BUCKET_DISPLAY_NAME
  ///
  /// The bucket display name of the image. This is a read-only property that
  /// is automatically computed from the DATA column.
  /// <P>Type: TEXT</P>
  static const BUCKET_DISPLAY_NAME = "bucket_display_name";

  /// from: static public final java.lang.String BUCKET_ID
  ///
  /// The bucket id of the image. This is a read-only property that
  /// is automatically computed from the DATA column.
  /// <P>Type: TEXT</P>
  static const BUCKET_ID = "bucket_id";

  /// from: static public final java.lang.String DATE_TAKEN
  ///
  /// The date & time that the image was taken in units
  /// of milliseconds since jan 1, 1970.
  /// <P>Type: INTEGER</P>
  static const DATE_TAKEN = "datetaken";

  /// from: static public final java.lang.String DESCRIPTION
  ///
  /// The description of the image
  /// <P>Type: TEXT</P>
  static const DESCRIPTION = "description";

  /// from: static public final java.lang.String IS_PRIVATE
  ///
  /// Whether the video should be published as public or private
  /// <P>Type: INTEGER</P>
  static const IS_PRIVATE = "isprivate";

  /// from: static public final java.lang.String LATITUDE
  ///
  /// The latitude where the image was captured.
  /// <P>Type: DOUBLE</P>
  static const LATITUDE = "latitude";

  /// from: static public final java.lang.String LONGITUDE
  ///
  /// The longitude where the image was captured.
  /// <P>Type: DOUBLE</P>
  static const LONGITUDE = "longitude";

  /// from: static public final java.lang.String MINI_THUMB_MAGIC
  ///
  /// The mini thumb id.
  /// <P>Type: INTEGER</P>
  static const MINI_THUMB_MAGIC = "mini_thumb_magic";

  /// from: static public final java.lang.String ORIENTATION
  ///
  /// The orientation for the image expressed as degrees.
  /// Only degrees 0, 90, 180, 270 will work.
  /// <P>Type: INTEGER</P>
  static const ORIENTATION = "orientation";

  /// from: static public final java.lang.String PICASA_ID
  ///
  /// The picasa id of the image
  /// <P>Type: TEXT</P>
  static const PICASA_ID = "picasa_id";
}

/// from: android.provider.MediaStore$Files
///
/// Media provider table containing an index of all files in the media storage,
/// including non-media files.  This should be used by applications that work with
/// non-media file types (text, HTML, PDF, etc) as well as applications that need to
/// work with multiple media file types in a single query.
class MediaStore_Files extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Files");
  MediaStore_Files.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Files()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the files table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the files table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);

  static final _id_getContentUri1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;J)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName, long rowId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for a single row in the files table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@param rowId the file to get the URI for
  ///@return the URI to the files table on the given volume
  static uri_.Uri getContentUri1(jni.JniString volumeName, int rowId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri1,
          jni.JniType.objectType,
          [volumeName.reference, rowId]).object);
}

/// from: android.provider.MediaStore$Files$FileColumns
///
/// Fields for master table for all media files.
/// Table also contains MediaColumns._ID, DATA, SIZE and DATE_MODIFIED.
class MediaStore_Files_FileColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Files\$FileColumns");
  MediaStore_Files_FileColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String MEDIA_TYPE
  ///
  /// The media type (audio, video, image or playlist)
  /// of the file, or 0 for not a media file
  /// <P>Type: TEXT</P>
  static const MEDIA_TYPE = "media_type";

  /// from: static public final int MEDIA_TYPE_AUDIO
  ///
  /// Constant for the \#MEDIA_TYPE column indicating that file is an audio file.
  static const MEDIA_TYPE_AUDIO = 2;

  /// from: static public final int MEDIA_TYPE_IMAGE
  ///
  /// Constant for the \#MEDIA_TYPE column indicating that file is an image file.
  static const MEDIA_TYPE_IMAGE = 1;

  /// from: static public final int MEDIA_TYPE_NONE
  ///
  /// Constant for the \#MEDIA_TYPE column indicating that file
  /// is not an audio, image, video or playlist file.
  static const MEDIA_TYPE_NONE = 0;

  /// from: static public final int MEDIA_TYPE_PLAYLIST
  ///
  /// Constant for the \#MEDIA_TYPE column indicating that file is a playlist file.
  static const MEDIA_TYPE_PLAYLIST = 4;

  /// from: static public final int MEDIA_TYPE_VIDEO
  ///
  /// Constant for the \#MEDIA_TYPE column indicating that file is a video file.
  static const MEDIA_TYPE_VIDEO = 3;

  /// from: static public final java.lang.String MIME_TYPE
  ///
  /// The MIME type of the file
  /// <P>Type: TEXT</P>
  static const MIME_TYPE = "mime_type";

  /// from: static public final java.lang.String PARENT
  ///
  /// The index of the parent directory of the file
  /// <P>Type: INTEGER</P>
  static const PARENT = "parent";

  /// from: static public final java.lang.String TITLE
  ///
  /// The title of the content
  /// <P>Type: TEXT</P>
  static const TITLE = "title";
}

/// from: android.provider.MediaStore$Audio
///
/// Container for all audio content.
class MediaStore_Audio extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Audio");
  MediaStore_Audio.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_keyFor = jniAccessors.getStaticMethodIDOf(
      _classRef, "keyFor", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String keyFor(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a name to a "key" that can be used for grouping, sorting
  /// and searching.
  /// The rules that govern this conversion are:
  /// - remove 'special' characters like ()[]'!?.,
  /// - remove leading/trailing spaces
  /// - convert everything to lowercase
  /// - remove leading "the ", "an " and "a "
  /// - remove trailing ", the|an|a"
  /// - remove accents. This step leaves us with CollationKey data,
  ///   which is not human readable
  ///@param name The artist or album name to convert
  ///@return The "key" for the given name.
  static jni.JniString keyFor(jni.JniString name) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_keyFor, jni.JniType.objectType, [name.reference]).object);
}

/// from: android.provider.MediaStore$Audio$Radio
class MediaStore_Audio_Radio extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Audio\$Radio");
  MediaStore_Audio_Radio.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  ///
  /// The MIME type for entries in this table.
  static const ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/radio";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Radio()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.MediaStore$Audio$PlaylistsColumns
///
/// Columns representing a playlist
class MediaStore_Audio_PlaylistsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Audio\$PlaylistsColumns");
  MediaStore_Audio_PlaylistsColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String DATA
  ///
  /// Path to the playlist file on disk.
  ///
  /// Note that apps may not have filesystem permissions to directly
  /// access this path. Instead of trying to open this path directly,
  /// apps should use
  /// ContentResolver\#openFileDescriptor(Uri, String) to gain
  /// access.
  ///
  /// Type: TEXT
  static const DATA = "_data";

  /// from: static public final java.lang.String DATE_ADDED
  ///
  /// The time the file was added to the media provider
  /// Units are seconds since 1970.
  /// <P>Type: INTEGER (long)</P>
  static const DATE_ADDED = "date_added";

  /// from: static public final java.lang.String DATE_MODIFIED
  ///
  /// The time the file was last modified
  /// Units are seconds since 1970.
  /// NOTE: This is for internal use by the media scanner.  Do not modify this field.
  /// <P>Type: INTEGER (long)</P>
  static const DATE_MODIFIED = "date_modified";

  /// from: static public final java.lang.String NAME
  ///
  /// The name of the playlist
  /// <P>Type: TEXT</P>
  static const NAME = "name";
}

/// from: android.provider.MediaStore$Audio$Playlists
///
/// Contains playlists for audio files
class MediaStore_Audio_Playlists extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Audio\$Playlists");
  MediaStore_Audio_Playlists.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type for this table.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/playlist";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "name";

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  ///
  /// The MIME type for entries in this table.
  static const ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/playlist";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Playlists()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the audio playlists table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the audio playlists table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);
}

/// from: android.provider.MediaStore$Audio$Playlists$Members
///
/// Sub-directory of each playlist containing all members.
class MediaStore_Audio_Playlists_Members extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Audio\$Playlists\$Members");
  MediaStore_Audio_Playlists_Members.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String AUDIO_ID
  ///
  /// The ID of the audio file
  /// <P>Type: INTEGER (long)</P>
  static const AUDIO_ID = "audio_id";

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// A subdirectory of each playlist containing all member audio
  /// files.
  static const CONTENT_DIRECTORY = "members";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "play_order";

  /// from: static public final java.lang.String PLAYLIST_ID
  ///
  /// The ID of the playlist
  /// <P>Type: INTEGER (long)</P>
  static const PLAYLIST_ID = "playlist_id";

  /// from: static public final java.lang.String PLAY_ORDER
  ///
  /// The order of the songs in the playlist
  /// <P>Type: INTEGER (long)></P>
  static const PLAY_ORDER = "play_order";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Playlists_Members()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;J)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName, long playlistId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri getContentUri(jni.JniString volumeName, int playlistId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference, playlistId]).object);

  static final _id_moveItem = jniAccessors.getStaticMethodIDOf(
      _classRef, "moveItem", "(Landroid/content/ContentResolver;JII)Z");

  /// from: static public boolean moveItem(android.content.ContentResolver res, long playlistId, int from, int to)
  ///
  /// Convenience method to move a playlist item to a new location
  ///@param res The content resolver to use
  ///@param playlistId The numeric id of the playlist
  ///@param from The position of the item to move
  ///@param to The position to move the item to
  ///@return true on success
  static bool moveItem(contentresolver_.ContentResolver res, int playlistId,
          int from, int to) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_moveItem,
          jni.JniType.booleanType,
          [res.reference, playlistId, from, to]).boolean;
}

/// from: android.provider.MediaStore$Audio$Media
class MediaStore_Audio_Media extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Audio\$Media");
  MediaStore_Audio_Media.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type for this table.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/audio";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "title_key";

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  ///
  /// The MIME type for an audio track.
  static const ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/audio";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String EXTRA_MAX_BYTES
  ///
  /// The name of the Intent-extra used to define a maximum file size for
  /// a recording made by the SoundRecorder application.
  ///@see \#RECORD_SOUND_ACTION
  static const EXTRA_MAX_BYTES = "android.provider.MediaStore.extra.MAX_BYTES";

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String RECORD_SOUND_ACTION
  ///
  /// Activity Action: Start SoundRecorder application.
  /// Input: nothing.
  /// Output: An uri to the recorded sound stored in the Media Library
  /// if the recording was successful.
  /// May also contain the extra EXTRA_MAX_BYTES.
  ///@see \#EXTRA_MAX_BYTES
  static const RECORD_SOUND_ACTION = "android.provider.MediaStore.RECORD_SOUND";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Media()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the audio media table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the audio media table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);

  static final _id_getContentUriForPath = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getContentUriForPath",
      "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUriForPath(java.lang.String path)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri getContentUriForPath(jni.JniString path) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUriForPath,
          jni.JniType.objectType,
          [path.reference]).object);
}

/// from: android.provider.MediaStore$Audio$GenresColumns
///
/// Columns representing an audio genre
class MediaStore_Audio_GenresColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Audio\$GenresColumns");
  MediaStore_Audio_GenresColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String NAME
  ///
  /// The name of the genre
  /// <P>Type: TEXT</P>
  static const NAME = "name";
}

/// from: android.provider.MediaStore$Audio$Genres
///
/// Contains all genres for audio files
class MediaStore_Audio_Genres extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Audio\$Genres");
  MediaStore_Audio_Genres.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type for this table.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/genre";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "name";

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  ///
  /// The MIME type for entries in this table.
  static const ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/genre";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Genres()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the audio genres table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the audio genres table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);

  static final _id_getContentUriForAudioId = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getContentUriForAudioId",
      "(Ljava/lang/String;I)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUriForAudioId(java.lang.String volumeName, int audioId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for querying the genres of an audio file.
  ///@param volumeName the name of the volume to get the URI for
  ///@param audioId the ID of the audio file for which to retrieve the genres
  ///@return the URI to for querying the genres for the audio file
  /// with the given the volume and audioID
  static uri_.Uri getContentUriForAudioId(
          jni.JniString volumeName, int audioId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUriForAudioId,
          jni.JniType.objectType,
          [volumeName.reference, audioId]).object);
}

/// from: android.provider.MediaStore$Audio$Genres$Members
///
/// Sub-directory of each genre containing all members.
class MediaStore_Audio_Genres_Members extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Audio\$Genres\$Members");
  MediaStore_Audio_Genres_Members.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String AUDIO_ID
  ///
  /// The ID of the audio file
  /// <P>Type: INTEGER (long)</P>
  static const AUDIO_ID = "audio_id";

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// A subdirectory of each genre containing all member audio files.
  static const CONTENT_DIRECTORY = "members";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "title_key";

  /// from: static public final java.lang.String GENRE_ID
  ///
  /// The ID of the genre
  /// <P>Type: INTEGER (long)</P>
  static const GENRE_ID = "genre_id";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Genres_Members()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;J)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName, long genreId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri getContentUri(jni.JniString volumeName, int genreId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference, genreId]).object);
}

/// from: android.provider.MediaStore$Audio$AudioColumns
///
/// Columns for audio file that show up in multiple tables.
class MediaStore_Audio_AudioColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Audio\$AudioColumns");
  MediaStore_Audio_AudioColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ALBUM
  ///
  /// The album the audio file is from, if any
  /// <P>Type: TEXT</P>
  static const ALBUM = "album";

  /// from: static public final java.lang.String ALBUM_ID
  ///
  /// The id of the album the audio file is from, if any
  /// <P>Type: INTEGER (long)</P>
  static const ALBUM_ID = "album_id";

  /// from: static public final java.lang.String ALBUM_KEY
  ///
  /// A non human readable key calculated from the ALBUM, used for
  /// searching, sorting and grouping
  /// <P>Type: TEXT</P>
  static const ALBUM_KEY = "album_key";

  /// from: static public final java.lang.String ARTIST
  ///
  /// The artist who created the audio file, if any
  /// <P>Type: TEXT</P>
  static const ARTIST = "artist";

  /// from: static public final java.lang.String ARTIST_ID
  ///
  /// The id of the artist who created the audio file, if any
  /// <P>Type: INTEGER (long)</P>
  static const ARTIST_ID = "artist_id";

  /// from: static public final java.lang.String ARTIST_KEY
  ///
  /// A non human readable key calculated from the ARTIST, used for
  /// searching, sorting and grouping
  /// <P>Type: TEXT</P>
  static const ARTIST_KEY = "artist_key";

  /// from: static public final java.lang.String BOOKMARK
  ///
  /// The position, in ms, playback was at when playback for this file
  /// was last stopped.
  /// <P>Type: INTEGER (long)</P>
  static const BOOKMARK = "bookmark";

  /// from: static public final java.lang.String COMPOSER
  ///
  /// The composer of the audio file, if any
  /// <P>Type: TEXT</P>
  static const COMPOSER = "composer";

  /// from: static public final java.lang.String DURATION
  ///
  /// The duration of the audio file, in ms
  /// <P>Type: INTEGER (long)</P>
  static const DURATION = "duration";

  /// from: static public final java.lang.String IS_ALARM
  ///
  /// Non-zero if the audio file may be an alarm
  /// <P>Type: INTEGER (boolean)</P>
  static const IS_ALARM = "is_alarm";

  /// from: static public final java.lang.String IS_MUSIC
  ///
  /// Non-zero if the audio file is music
  /// <P>Type: INTEGER (boolean)</P>
  static const IS_MUSIC = "is_music";

  /// from: static public final java.lang.String IS_NOTIFICATION
  ///
  /// Non-zero if the audio file may be a notification sound
  /// <P>Type: INTEGER (boolean)</P>
  static const IS_NOTIFICATION = "is_notification";

  /// from: static public final java.lang.String IS_PODCAST
  ///
  /// Non-zero if the audio file is a podcast
  /// <P>Type: INTEGER (boolean)</P>
  static const IS_PODCAST = "is_podcast";

  /// from: static public final java.lang.String IS_RINGTONE
  ///
  /// Non-zero if the audio file may be a ringtone
  /// <P>Type: INTEGER (boolean)</P>
  static const IS_RINGTONE = "is_ringtone";

  /// from: static public final java.lang.String TITLE_KEY
  ///
  /// A non human readable key calculated from the TITLE, used for
  /// searching, sorting and grouping
  /// <P>Type: TEXT</P>
  static const TITLE_KEY = "title_key";

  /// from: static public final java.lang.String TRACK
  ///
  /// The track number of this song on the album, if any.
  /// This number encodes both the track number and the
  /// disc number. For multi-disc sets, this number will
  /// be 1xxx for tracks on the first disc, 2xxx for tracks
  /// on the second disc, etc.
  /// <P>Type: INTEGER</P>
  static const TRACK = "track";

  /// from: static public final java.lang.String YEAR
  ///
  /// The year the audio file was recorded, if any
  /// <P>Type: INTEGER</P>
  static const YEAR = "year";
}

/// from: android.provider.MediaStore$Audio$Artists
///
/// Contains artists for audio files
class MediaStore_Audio_Artists extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Audio\$Artists");
  MediaStore_Audio_Artists.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type for this table.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/artists";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "artist_key";

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  ///
  /// The MIME type for entries in this table.
  static const ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/artist";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Artists()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the artists table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the audio artists table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);
}

/// from: android.provider.MediaStore$Audio$Artists$Albums
///
/// Sub-directory of each artist containing all albums on which
/// a song by the artist appears.
class MediaStore_Audio_Artists_Albums extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Audio\$Artists\$Albums");
  MediaStore_Audio_Artists_Albums.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Artists_Albums()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;J)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName, long artistId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri getContentUri(jni.JniString volumeName, int artistId) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference, artistId]).object);
}

/// from: android.provider.MediaStore$Audio$ArtistColumns
///
/// Columns representing an artist
class MediaStore_Audio_ArtistColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Audio\$ArtistColumns");
  MediaStore_Audio_ArtistColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ARTIST
  ///
  /// The artist who created the audio file, if any
  /// <P>Type: TEXT</P>
  static const ARTIST = "artist";

  /// from: static public final java.lang.String ARTIST_KEY
  ///
  /// A non human readable key calculated from the ARTIST, used for
  /// searching, sorting and grouping
  /// <P>Type: TEXT</P>
  static const ARTIST_KEY = "artist_key";

  /// from: static public final java.lang.String NUMBER_OF_ALBUMS
  ///
  /// The number of albums in the database for this artist
  static const NUMBER_OF_ALBUMS = "number_of_albums";

  /// from: static public final java.lang.String NUMBER_OF_TRACKS
  ///
  /// The number of albums in the database for this artist
  static const NUMBER_OF_TRACKS = "number_of_tracks";
}

/// from: android.provider.MediaStore$Audio$Albums
///
/// Contains artists for audio files
class MediaStore_Audio_Albums extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/MediaStore\$Audio\$Albums");
  MediaStore_Audio_Albums.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type for this table.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/albums";

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  ///
  /// The default sort order for this table
  static const DEFAULT_SORT_ORDER = "album_key";

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  ///
  /// The MIME type for entries in this table.
  static const ENTRY_CONTENT_TYPE = "vnd.android.cursor.item/album";

  static final _id_EXTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the "primary" external storage
  /// volume.
  static uri_.Uri get EXTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_EXTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_INTERNAL_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTERNAL_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for the internal storage.
  static uri_.Uri get INTERNAL_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_INTERNAL_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaStore_Audio_Albums()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContentUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "getContentUri", "(Ljava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContentUri(java.lang.String volumeName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the content:// style URI for the albums table on the
  /// given volume.
  ///@param volumeName the name of the volume to get the URI for
  ///@return the URI to the audio albums table on the given volume
  static uri_.Uri getContentUri(jni.JniString volumeName) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContentUri,
          jni.JniType.objectType,
          [volumeName.reference]).object);
}

/// from: android.provider.MediaStore$Audio$AlbumColumns
///
/// Columns representing an album
class MediaStore_Audio_AlbumColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/MediaStore\$Audio\$AlbumColumns");
  MediaStore_Audio_AlbumColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ALBUM
  ///
  /// The album on which the audio file appears, if any
  /// <P>Type: TEXT</P>
  static const ALBUM = "album";

  /// from: static public final java.lang.String ALBUM_ART
  ///
  /// Cached album art.
  /// <P>Type: TEXT</P>
  static const ALBUM_ART = "album_art";

  /// from: static public final java.lang.String ALBUM_ID
  ///
  /// The id for the album
  /// <P>Type: INTEGER</P>
  static const ALBUM_ID = "album_id";

  /// from: static public final java.lang.String ALBUM_KEY
  ///
  /// A non human readable key calculated from the ALBUM, used for
  /// searching, sorting and grouping
  /// <P>Type: TEXT</P>
  static const ALBUM_KEY = "album_key";

  /// from: static public final java.lang.String ARTIST
  ///
  /// The artist whose songs appear on this album
  /// <P>Type: TEXT</P>
  static const ARTIST = "artist";

  /// from: static public final java.lang.String FIRST_YEAR
  ///
  /// The year in which the earliest songs
  /// on this album were released. This will often
  /// be the same as \#LAST_YEAR, but for compilation albums
  /// they might differ.
  /// <P>Type: INTEGER</P>
  static const FIRST_YEAR = "minyear";

  /// from: static public final java.lang.String LAST_YEAR
  ///
  /// The year in which the latest songs
  /// on this album were released. This will often
  /// be the same as \#FIRST_YEAR, but for compilation albums
  /// they might differ.
  /// <P>Type: INTEGER</P>
  static const LAST_YEAR = "maxyear";

  /// from: static public final java.lang.String NUMBER_OF_SONGS
  ///
  /// The number of songs on this album
  /// <P>Type: INTEGER</P>
  static const NUMBER_OF_SONGS = "numsongs";

  /// from: static public final java.lang.String NUMBER_OF_SONGS_FOR_ARTIST
  ///
  /// This column is available when getting album info via artist,
  /// and indicates the number of songs on the album by the given
  /// artist.
  /// <P>Type: INTEGER</P>
  static const NUMBER_OF_SONGS_FOR_ARTIST = "numsongs_by_artist";
}
