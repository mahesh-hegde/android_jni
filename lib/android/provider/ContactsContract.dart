// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../net/Uri.dart" as uri_;

import "../content/ContentProviderClient.dart" as contentproviderclient_;

import "../accounts/Account.dart" as account_;

import "../util/Pair.dart" as pair_;

import "../content/ContentProviderOperation.dart" as contentprovideroperation_;

import "../content/ContentResolver.dart" as contentresolver_;

import "../content/EntityIterator.dart" as entityiterator_;

import "../database/Cursor.dart" as cursor_;

import "../content/Context.dart" as context_;

import "../view/View.dart" as view_;

import "../graphics/Rect.dart" as rect_;

import "../content/res/Resources.dart" as resources_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.provider.ContactsContract
///
///
/// The contract between the contacts provider and applications. Contains
/// definitions for the supported URIs and columns. These APIs supersede
/// Contacts.
///
///
/// <h3>Overview</h3>
///
/// ContactsContract defines an extensible database of contact-related
/// information. Contact information is stored in a three-tier data model:
///
///
/// <ul>
/// <li>
/// A row in the Data table can store any kind of personal data, such
/// as a phone number or email addresses.  The set of data kinds that can be
/// stored in this table is open-ended. There is a predefined set of common
/// kinds, but any application can add its own data kinds.
/// </li>
/// <li>
/// A row in the RawContacts table represents a set of data describing a
/// person and associated with a single account (for example, one of the user's
/// Gmail accounts).
/// </li>
/// <li>
/// A row in the Contacts table represents an aggregate of one or more
/// RawContacts presumably describing the same person.  When data in or associated with
/// the RawContacts table is changed, the affected aggregate contacts are updated as
/// necessary.
/// </li>
/// </ul>
///
/// Other tables include:
///
///
/// <ul>
/// <li>
/// Groups, which contains information about raw contact groups
/// such as Gmail contact groups.  The
/// current API does not support the notion of groups spanning multiple accounts.
/// </li>
/// <li>
/// StatusUpdates, which contains social status updates including IM
/// availability.
/// </li>
/// <li>
/// AggregationExceptions, which is used for manual aggregation and
/// disaggregation of raw contacts
/// </li>
/// <li>
/// Settings, which contains visibility and sync settings for accounts
/// and groups.
/// </li>
/// <li>
/// SyncState, which contains free-form data maintained on behalf of sync
/// adapters
/// </li>
/// <li>
/// PhoneLookup, which is used for quick caller-ID lookup</li>
/// </ul>
class ContactsContract extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract");
  ContactsContract.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String AUTHORITY
  ///
  /// The authority for the contacts provider
  static const AUTHORITY = "com.android.contacts";

  static final _id_AUTHORITY_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "AUTHORITY_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri AUTHORITY_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A content:// style uri to the authority for the contacts provider
  static uri_.Uri get AUTHORITY_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_AUTHORITY_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CALLER_IS_SYNCADAPTER
  ///
  /// An optional URI parameter for insert, update, or delete queries
  /// that allows the caller
  /// to specify that it is a sync adapter. The default value is false. If true
  /// RawContacts\#DIRTY is not automatically set and the
  /// "syncToNetwork" parameter is set to false when calling
  /// ContentResolver\#notifyChange(android.net.Uri, android.database.ContentObserver, boolean).
  /// This prevents an unnecessary extra synchronization, see the discussion of
  /// the delete operation in RawContacts.
  static const CALLER_IS_SYNCADAPTER = "caller_is_syncadapter";

  /// from: static public final java.lang.String DEFERRED_SNIPPETING
  ///
  /// A key to a boolean in the "extras" bundle of the cursor.
  /// The boolean indicates that the provider did not create a snippet and that the client asking
  /// for the snippet should do it (true means the snippeting was deferred to the client).
  ///@see SearchSnippets
  static const DEFERRED_SNIPPETING = "deferred_snippeting";

  /// from: static public final java.lang.String DEFERRED_SNIPPETING_QUERY
  ///
  /// Key to retrieve the original deferred snippeting from the cursor on the client side.
  ///@see SearchSnippets
  ///@see \#DEFERRED_SNIPPETING
  static const DEFERRED_SNIPPETING_QUERY = "deferred_snippeting_query";

  /// from: static public final java.lang.String DIRECTORY_PARAM_KEY
  ///
  /// Query parameter that should be used by the client to access a specific
  /// Directory. The parameter value should be the _ID of the corresponding
  /// directory, e.g.
  /// {@code content://com.android.contacts/data/emails/filter/acme?directory=3}
  static const DIRECTORY_PARAM_KEY = "directory";

  /// from: static public final java.lang.String LIMIT_PARAM_KEY
  ///
  /// A query parameter that limits the number of results returned for supported URIs. The
  /// parameter value should be an integer.
  ///
  /// This parameter is not supported by all URIs.  Supported URIs include, but not limited to,
  /// Contacts\#CONTENT_URI,
  /// RawContacts\#CONTENT_URI,
  /// Data\#CONTENT_URI,
  /// CommonDataKinds.Phone\#CONTENT_URI,
  /// CommonDataKinds.Callable\#CONTENT_URI,
  /// CommonDataKinds.Email\#CONTENT_URI,
  /// CommonDataKinds.Contactables\#CONTENT_URI,
  ///
  /// In order to limit the number of rows returned by a non-supported URI, you can implement a
  /// CursorWrapper and override the CursorWrapper\#getCount() methods.
  static const LIMIT_PARAM_KEY = "limit";

  /// from: static public final java.lang.String PRIMARY_ACCOUNT_NAME
  ///
  /// A query parameter specifing a primary account. This parameter should be used with
  /// \#PRIMARY_ACCOUNT_TYPE. The contacts provider handling a query may rely on
  /// this information to optimize its query results.
  ///
  /// For example, in an email composition screen, its implementation can specify an account when
  /// obtaining possible recipients, letting the provider know which account is selected during
  /// the composition. The provider may use the "primary account" information to optimize
  /// the search result.
  static const PRIMARY_ACCOUNT_NAME = "name_for_primary_account";

  /// from: static public final java.lang.String PRIMARY_ACCOUNT_TYPE
  ///
  /// A query parameter specifing a primary account. This parameter should be used with
  /// \#PRIMARY_ACCOUNT_NAME. See the doc in \#PRIMARY_ACCOUNT_NAME.
  static const PRIMARY_ACCOUNT_TYPE = "type_for_primary_account";

  /// from: static public final java.lang.String REMOVE_DUPLICATE_ENTRIES
  ///
  /// A boolean parameter for CommonDataKinds.Phone\#CONTENT_URI Phone.CONTENT_URI,
  /// CommonDataKinds.Email\#CONTENT_URI Email.CONTENT_URI, and
  /// CommonDataKinds.StructuredPostal\#CONTENT_URI StructuredPostal.CONTENT_URI.
  /// This enables a content provider to remove duplicate entries in results.
  static const REMOVE_DUPLICATE_ENTRIES = "remove_duplicate_entries";

  /// from: static public final java.lang.String STREQUENT_PHONE_ONLY
  ///
  /// A boolean parameter for Contacts\#CONTENT_STREQUENT_URI and
  /// Contacts\#CONTENT_STREQUENT_FILTER_URI, which requires the ContactsProvider to
  /// return only phone-related results. For example, frequently contacted person list should
  /// include persons contacted via phone (not email, sms, etc.)
  static const STREQUENT_PHONE_ONLY = "strequent_phone_only";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_isProfileId =
      jniAccessors.getStaticMethodIDOf(_classRef, "isProfileId", "(J)Z");

  /// from: static public boolean isProfileId(long id)
  ///
  /// This method can be used to identify whether the given ID is associated with profile
  /// data.  It does not necessarily indicate that the ID is tied to valid data, merely
  /// that accessing data using this ID will result in profile access checks and will only
  /// return data from the profile.
  ///@param id The ID to check.
  ///@return Whether the ID is associated with profile data.
  static bool isProfileId(int id) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isProfileId, jni.JniType.booleanType, [id]).boolean;
}

/// from: android.provider.ContactsContract$SyncState
///
/// A table provided for sync adapters to use for storing private sync state data for contacts.
///@see SyncStateContract
class ContactsContract_SyncState extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$SyncState");
  ContactsContract_SyncState.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  static const CONTENT_DIRECTORY = "syncstate";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_get0 = jniAccessors.getStaticMethodIDOf(_classRef, "get",
      "(Landroid/content/ContentProviderClient;Landroid/accounts/Account;)[B");

  /// from: static public byte[] get(android.content.ContentProviderClient provider, android.accounts.Account account)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see android.provider.SyncStateContract.Helpers\#get
  static jni.JniObject get0(
          contentproviderclient_.ContentProviderClient provider,
          account_.Account account) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_get0,
          jni.JniType.objectType,
          [provider.reference, account.reference]).object);

  static final _id_getWithUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getWithUri",
      "(Landroid/content/ContentProviderClient;Landroid/accounts/Account;)Landroid/util/Pair;");

  /// from: static public android.util.Pair<android.net.Uri,byte[]> getWithUri(android.content.ContentProviderClient provider, android.accounts.Account account)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see android.provider.SyncStateContract.Helpers\#get
  static pair_.Pair getWithUri(
          contentproviderclient_.ContentProviderClient provider,
          account_.Account account) =>
      pair_.Pair.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getWithUri,
          jni.JniType.objectType,
          [provider.reference, account.reference]).object);

  static final _id_set0 = jniAccessors.getStaticMethodIDOf(_classRef, "set",
      "(Landroid/content/ContentProviderClient;Landroid/accounts/Account;[B)V");

  /// from: static public void set(android.content.ContentProviderClient provider, android.accounts.Account account, byte[] data)
  ///
  /// @see android.provider.SyncStateContract.Helpers\#set
  static void set0(contentproviderclient_.ContentProviderClient provider,
          account_.Account account, jni.JniObject data) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_set0,
          jni.JniType.voidType,
          [provider.reference, account.reference, data.reference]).check();

  static final _id_newSetOperation = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newSetOperation",
      "(Landroid/accounts/Account;[B)Landroid/content/ContentProviderOperation;");

  /// from: static public android.content.ContentProviderOperation newSetOperation(android.accounts.Account account, byte[] data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see android.provider.SyncStateContract.Helpers\#newSetOperation
  static contentprovideroperation_.ContentProviderOperation newSetOperation(
          account_.Account account, jni.JniObject data) =>
      contentprovideroperation_.ContentProviderOperation.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_newSetOperation,
              jni.JniType.objectType,
              [account.reference, data.reference]).object);
}

/// from: android.provider.ContactsContract$SyncColumns
///
/// Columns that appear when each row of a table belongs to a specific
/// account, including sync information that an account may need.
///@see RawContacts
///@see Groups
class ContactsContract_SyncColumns extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$SyncColumns");
  ContactsContract_SyncColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACCOUNT_NAME
  ///
  /// The name of the account instance to which this row belongs, which when paired with
  /// \#ACCOUNT_TYPE identifies a specific account.
  /// <P>Type: TEXT</P>
  static const ACCOUNT_NAME = "account_name";

  /// from: static public final java.lang.String ACCOUNT_TYPE
  ///
  /// The type of account to which this row belongs, which when paired with
  /// \#ACCOUNT_NAME identifies a specific account.
  /// <P>Type: TEXT</P>
  static const ACCOUNT_TYPE = "account_type";

  /// from: static public final java.lang.String DIRTY
  ///
  /// Flag indicating that \#VERSION has changed, and this row needs
  /// to be synchronized by its owning account.
  /// <P>Type: INTEGER (boolean)</P>
  static const DIRTY = "dirty";

  /// from: static public final java.lang.String SOURCE_ID
  ///
  /// String that uniquely identifies this row to its source account.
  /// <P>Type: TEXT</P>
  static const SOURCE_ID = "sourceid";

  /// from: static public final java.lang.String VERSION
  ///
  /// Version number that is updated whenever this row or its related data
  /// changes.
  /// <P>Type: INTEGER</P>
  static const VERSION = "version";
}

/// from: android.provider.ContactsContract$StatusUpdates
///
///
/// A status update is linked to a ContactsContract.Data row and captures
/// the user's latest status update via the corresponding source, e.g.
/// "Having lunch" via "Google Talk".
///
///
///
/// There are two ways a status update can be inserted: by explicitly linking
/// it to a Data row using \#DATA_ID or indirectly linking it to a data row
/// using a combination of \#PROTOCOL (or \#CUSTOM_PROTOCOL) and
/// \#IM_HANDLE.  There is no difference between insert and update, you can use
/// either.
///
///
///
/// Inserting or updating a status update for the user's profile requires either using
/// the \#DATA_ID to identify the data row to attach the update to, or
/// StatusUpdates\#PROFILE_CONTENT_URI to ensure that the change is scoped to the
/// profile.
///
///
///
/// You cannot use ContentResolver\#update to change a status, but
/// ContentResolver\#insert will replace the latests status if it already
/// exists.
///
///
///
/// Use ContentResolver\#bulkInsert(Uri, ContentValues[]) to insert/update statuses
/// for multiple contacts at once.
///
///
///
/// <h3>Columns</h3>
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>StatusUpdates</th>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#DATA_ID</td>
/// <td>read/write</td>
/// <td>Reference to the Data\#_ID entry that owns this presence. If this
/// field is <i>not</i> specified, the provider will attempt to find a data row
/// that matches the \#PROTOCOL (or \#CUSTOM_PROTOCOL) and
/// \#IM_HANDLE columns.
/// </td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#PROTOCOL</td>
/// <td>read/write</td>
/// <td>See CommonDataKinds.Im for a list of defined protocol constants.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CUSTOM_PROTOCOL</td>
/// <td>read/write</td>
/// <td>Name of the custom protocol.  Should be supplied along with the \#PROTOCOL value
/// ContactsContract.CommonDataKinds.Im\#PROTOCOL_CUSTOM.  Should be null or
/// omitted if \#PROTOCOL value is not
/// ContactsContract.CommonDataKinds.Im\#PROTOCOL_CUSTOM.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#IM_HANDLE</td>
/// <td>read/write</td>
/// <td> The IM handle the presence item is for. The handle is scoped to
/// \#PROTOCOL.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#IM_ACCOUNT</td>
/// <td>read/write</td>
/// <td>The IM account for the local user that the presence data came from.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#PRESENCE</td>
/// <td>read/write</td>
/// <td>Contact IM presence status. The allowed values are:
///
/// <ul>
/// <li>\#OFFLINE</li>
/// <li>\#INVISIBLE</li>
/// <li>\#AWAY</li>
/// <li>\#IDLE</li>
/// <li>\#DO_NOT_DISTURB</li>
/// <li>\#AVAILABLE</li>
/// </ul>
///
///
///
/// Since presence status is inherently volatile, the content provider
/// may choose not to store this field in long-term storage.
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#CHAT_CAPABILITY</td>
/// <td>read/write</td>
/// <td>Contact IM chat compatibility value. The allowed values combinations of the following
/// flags. If None of these flags is set, the device can only do text messaging.
///
/// <ul>
/// <li>\#CAPABILITY_HAS_VIDEO</li>
/// <li>\#CAPABILITY_HAS_VOICE</li>
/// <li>\#CAPABILITY_HAS_CAMERA</li>
/// </ul>
///
///
///
/// Since chat compatibility is inherently volatile as the contact's availability moves from
/// one device to another, the content provider may choose not to store this field in long-term
/// storage.
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#STATUS</td>
/// <td>read/write</td>
/// <td>Contact's latest status update, e.g. "having toast for breakfast"</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#STATUS_TIMESTAMP</td>
/// <td>read/write</td>
/// <td>The absolute time in milliseconds when the status was
/// entered by the user. If this value is not provided, the provider will follow
/// this logic: if there was no prior status update, the value will be left as null.
/// If there was a prior status update, the provider will default this field
/// to the current time.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#STATUS_RES_PACKAGE</td>
/// <td>read/write</td>
/// <td> The package containing resources for this status: label and icon.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#STATUS_LABEL</td>
/// <td>read/write</td>
/// <td>The resource ID of the label describing the source of contact status,
/// e.g. "Google Talk". This resource is scoped by the
/// \#STATUS_RES_PACKAGE.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#STATUS_ICON</td>
/// <td>read/write</td>
/// <td>The resource ID of the icon for the source of contact status. This
/// resource is scoped by the \#STATUS_RES_PACKAGE.</td>
/// </tr>
/// </table>
class ContactsContract_StatusUpdates extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$StatusUpdates");
  ContactsContract_StatusUpdates.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME type of a \#CONTENT_URI subdirectory of a single
  /// status update detail.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/status-update";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI providing a directory of
  /// status update details.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/status-update";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_PROFILE_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "PROFILE_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri PROFILE_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table, specific to the user's profile.
  static uri_.Uri get PROFILE_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_PROFILE_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_getPresenceIconResourceId = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPresenceIconResourceId", "(I)I");

  /// from: static public final int getPresenceIconResourceId(int status)
  ///
  /// Gets the resource ID for the proper presence icon.
  ///@param status the status to get the icon for
  ///@return the resource ID for the proper presence icon
  static int getPresenceIconResourceId(int status) =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getPresenceIconResourceId, jni.JniType.intType, [status]).integer;

  static final _id_getPresencePrecedence = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPresencePrecedence", "(I)I");

  /// from: static public final int getPresencePrecedence(int status)
  ///
  /// Returns the precedence of the status code the higher number being the higher precedence.
  ///@param status The status code.
  ///@return An integer representing the precedence, 0 being the lowest.
  static int getPresencePrecedence(int status) =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getPresencePrecedence, jni.JniType.intType, [status]).integer;
}

/// from: android.provider.ContactsContract$StatusColumns
///
/// Social status update columns.
///@see StatusUpdates
///@see ContactsContract.Data
class ContactsContract_StatusColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$StatusColumns");
  ContactsContract_StatusColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AVAILABLE
  ///
  /// An allowed value of \#PRESENCE.
  static const AVAILABLE = 5;

  /// from: static public final int AWAY
  ///
  /// An allowed value of \#PRESENCE.
  static const AWAY = 2;

  /// from: static public final int CAPABILITY_HAS_CAMERA
  ///
  /// An allowed flag of \#CHAT_CAPABILITY. Indicates that the contact's device has a
  /// camera that can be used for video chat (e.g. a front-facing camera on a phone).
  static const CAPABILITY_HAS_CAMERA = 4;

  /// from: static public final int CAPABILITY_HAS_VIDEO
  ///
  /// An allowed flag of \#CHAT_CAPABILITY. Indicates that the contact's device can
  /// display a video feed.
  static const CAPABILITY_HAS_VIDEO = 2;

  /// from: static public final int CAPABILITY_HAS_VOICE
  ///
  /// An allowed flag of \#CHAT_CAPABILITY. Indicates audio-chat capability (microphone
  /// and speaker)
  static const CAPABILITY_HAS_VOICE = 1;

  /// from: static public final java.lang.String CHAT_CAPABILITY
  ///
  /// Contact's audio/video chat capability level.
  /// <P>Type: INTEGER (one of the values below)</P>
  static const CHAT_CAPABILITY = "chat_capability";

  /// from: static public final int DO_NOT_DISTURB
  ///
  /// An allowed value of \#PRESENCE.
  static const DO_NOT_DISTURB = 4;

  /// from: static public final int IDLE
  ///
  /// An allowed value of \#PRESENCE.
  static const IDLE = 3;

  /// from: static public final int INVISIBLE
  ///
  /// An allowed value of \#PRESENCE.
  static const INVISIBLE = 1;

  /// from: static public final int OFFLINE
  ///
  /// An allowed value of \#PRESENCE.
  static const OFFLINE = 0;

  /// from: static public final java.lang.String PRESENCE
  ///
  /// Contact's latest presence level.
  /// <P>Type: INTEGER (one of the values below)</P>
  static const PRESENCE = "mode";

  /// from: static public final java.lang.String PRESENCE_CUSTOM_STATUS
  ///
  /// @deprecated use \#STATUS
  static const PRESENCE_CUSTOM_STATUS = "status";

  /// from: static public final java.lang.String PRESENCE_STATUS
  ///
  /// @deprecated use \#PRESENCE
  static const PRESENCE_STATUS = "mode";

  /// from: static public final java.lang.String STATUS
  ///
  /// Contact latest status update.
  /// Type: TEXT
  ///
  static const STATUS = "status";

  /// from: static public final java.lang.String STATUS_ICON
  ///
  /// The resource ID of the icon for the source of the status update.
  /// This resource should be scoped by the \#STATUS_RES_PACKAGE.
  /// Type: NUMBER
  ///
  static const STATUS_ICON = "status_icon";

  /// from: static public final java.lang.String STATUS_LABEL
  ///
  /// The resource ID of the label describing the source of the status update, e.g.&nbsp;"Google
  /// Talk".  This resource should be scoped by the \#STATUS_RES_PACKAGE.
  /// Type: NUMBER
  ///
  static const STATUS_LABEL = "status_label";

  /// from: static public final java.lang.String STATUS_RES_PACKAGE
  ///
  /// The package containing resources for this status: label and icon.
  /// Type: TEXT
  ///
  static const STATUS_RES_PACKAGE = "status_res_package";

  /// from: static public final java.lang.String STATUS_TIMESTAMP
  ///
  /// The absolute time in milliseconds when the latest status was inserted/updated.
  /// Type: NUMBER
  ///
  static const STATUS_TIMESTAMP = "status_ts";
}

/// from: android.provider.ContactsContract$SettingsColumns
///
/// @see Settings
class ContactsContract_SettingsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$SettingsColumns");
  ContactsContract_SettingsColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String ACCOUNT_NAME
  ///
  /// The name of the account instance to which this row belongs.
  /// <P>Type: TEXT</P>
  static const ACCOUNT_NAME = "account_name";

  /// from: static public final java.lang.String ACCOUNT_TYPE
  ///
  /// The type of account to which this row belongs, which when paired with
  /// \#ACCOUNT_NAME identifies a specific account.
  /// <P>Type: TEXT</P>
  static const ACCOUNT_TYPE = "account_type";

  /// from: static public final java.lang.String ANY_UNSYNCED
  ///
  /// Read-only flag indicating if this \#SHOULD_SYNC or any
  /// Groups\#SHOULD_SYNC under this account have been marked as
  /// unsynced.
  static const ANY_UNSYNCED = "any_unsynced";

  /// from: static public final java.lang.String DATA_SET
  ///
  /// The data set within the account that this row belongs to.  This allows
  /// multiple sync adapters for the same account type to distinguish between
  /// each others' data.
  ///
  /// This is empty by default, and is completely optional.  It only needs to
  /// be populated if multiple sync adapters are entering distinct data for
  /// the same account type and account name.
  /// <P>Type: TEXT</P>
  static const DATA_SET = "data_set";

  /// from: static public final java.lang.String SHOULD_SYNC
  ///
  /// Depending on the mode defined by the sync-adapter, this flag controls
  /// the top-level sync behavior for this data source.
  ///
  /// Type: INTEGER (boolean)
  static const SHOULD_SYNC = "should_sync";

  /// from: static public final java.lang.String UNGROUPED_COUNT
  ///
  /// Read-only count of Contacts from a specific source that have
  /// no CommonDataKinds.GroupMembership entries.
  ///
  /// Type: INTEGER
  static const UNGROUPED_COUNT = "summ_count";

  /// from: static public final java.lang.String UNGROUPED_VISIBLE
  ///
  /// Flag indicating if contacts without any CommonDataKinds.GroupMembership
  /// entries should be visible in any user interface.
  ///
  /// Type: INTEGER (boolean)
  static const UNGROUPED_VISIBLE = "ungrouped_visible";

  /// from: static public final java.lang.String UNGROUPED_WITH_PHONES
  ///
  /// Read-only count of Contacts from a specific source that have
  /// no CommonDataKinds.GroupMembership entries, and also have phone numbers.
  ///
  /// Type: INTEGER
  static const UNGROUPED_WITH_PHONES = "summ_phones";
}

/// from: android.provider.ContactsContract$Settings
///
///
/// Contacts-specific settings for various Account's.
///
///
/// <h2>Columns</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Settings</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#ACCOUNT_NAME</td>
/// <td>read/write-once</td>
/// <td>The name of the account instance to which this row belongs.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#ACCOUNT_TYPE</td>
/// <td>read/write-once</td>
/// <td>The type of account to which this row belongs, which when paired with
/// \#ACCOUNT_NAME identifies a specific account.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#SHOULD_SYNC</td>
/// <td>read/write</td>
/// <td>Depending on the mode defined by the sync-adapter, this flag controls
/// the top-level sync behavior for this data source.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#UNGROUPED_VISIBLE</td>
/// <td>read/write</td>
/// <td>Flag indicating if contacts without any
/// CommonDataKinds.GroupMembership entries should be visible in any
/// user interface.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#ANY_UNSYNCED</td>
/// <td>read-only</td>
/// <td>Read-only flag indicating if this \#SHOULD_SYNC or any
/// Groups\#SHOULD_SYNC under this account have been marked as
/// unsynced.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#UNGROUPED_COUNT</td>
/// <td>read-only</td>
/// <td>Read-only count of Contacts from a specific source that have
/// no CommonDataKinds.GroupMembership entries.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#UNGROUPED_WITH_PHONES</td>
/// <td>read-only</td>
/// <td>Read-only count of Contacts from a specific source that have
/// no CommonDataKinds.GroupMembership entries, and also have phone
/// numbers.</td>
/// </tr>
/// </table>
class ContactsContract_Settings extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$Settings");
  ContactsContract_Settings.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME-type of \#CONTENT_URI providing a single setting.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/setting";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME-type of \#CONTENT_URI providing a directory of
  /// settings.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/setting";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);
}

/// from: android.provider.ContactsContract$SearchSnippets
///
/// Additional column returned by
/// ContactsContract.Contacts\#CONTENT_FILTER_URI Contacts.CONTENT_FILTER_URI explaining
/// why the filter matched the contact. This column will contain extracts from the contact's
/// constituent Data Data items, formatted in a way that indicates the section of the
/// snippet that matched the filter.
///
///
/// The following example searches for all contacts that match the query "presi" and requests
/// the snippet column as well.
/// <pre>
/// Builder builder = Contacts.CONTENT_FILTER_URI.buildUpon();
/// builder.appendPath("presi");
/// // Defer snippeting to the client side if possible, for performance reasons.
/// builder.appendQueryParameter(SearchSnippets.DEFERRED_SNIPPETING_KEY,"1");
///
/// Cursor cursor = getContentResolver().query(builder.build());
///
/// Bundle extras = cursor.getExtras();
/// if (extras.getBoolean(ContactsContract.DEFERRED_SNIPPETING)) {
///     // Do our own snippet formatting.
///     // For a contact with the email address (president@organization.com), the snippet
///     // column will contain the string "president@organization.com".
/// } else {
///     // The snippet has already been pre-formatted, we can display it as is.
///     // For a contact with the email address (president@organization.com), the snippet
///     // column will contain the string "[presi]dent@organization.com".
/// }
/// </pre>
///
///
class ContactsContract_SearchSnippets extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$SearchSnippets");
  ContactsContract_SearchSnippets.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String DEFERRED_SNIPPETING_KEY
  ///
  /// The key to ask the provider to defer the formatting of the snippet to the client if
  /// possible, for performance reasons.
  /// A value of 1 indicates true, 0 indicates false. False is the default.
  /// When a cursor is returned to the client, it should check for an extra with the name
  /// ContactsContract\#DEFERRED_SNIPPETING in the cursor. If it exists, the client
  /// should do its own formatting of the snippet. If it doesn't exist, the snippet column
  /// in the cursor should already contain a formatted snippet.
  static const DEFERRED_SNIPPETING_KEY = "deferred_snippeting";

  /// from: static public final java.lang.String SNIPPET
  ///
  /// The search snippet constructed by SQLite snippeting functionality.
  ///
  /// The snippet may contain (parts of) several data elements belonging to the contact,
  /// with the matching parts optionally surrounded by special characters that indicate the
  /// start and end of matching text.
  ///
  /// For example, if a contact has an address "123 Main Street", using a filter "mai" would
  /// return the formatted snippet "123 [Mai]n street".
  ///@see <a href="http://www.sqlite.org/fts3.html\#snippet">
  ///         http://www.sqlite.org/fts3.html\#snippet</a>
  static const SNIPPET = "snippet";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_SearchSnippets()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.ContactsContract$RawContactsEntity
///
///
/// Constants for the raw contacts entities table, which can be thought of as
/// an outer join of the raw_contacts table with the data table.  It is a strictly
/// read-only table.
///
///
///
/// If a raw contact has data rows, the RawContactsEntity cursor will contain
/// a one row for each data row. If the raw contact has no data rows, the
/// cursor will still contain one row with the raw contact-level information
/// and nulls for data columns.
///
/// <pre>
/// Uri entityUri = ContentUris.withAppendedId(RawContactsEntity.CONTENT_URI, rawContactId);
/// Cursor c = getContentResolver().query(entityUri,
///          new String[]{
///              RawContactsEntity.SOURCE_ID,
///              RawContactsEntity.DATA_ID,
///              RawContactsEntity.MIMETYPE,
///              RawContactsEntity.DATA1
///          }, null, null, null);
/// try {
///     while (c.moveToNext()) {
///         String sourceId = c.getString(0);
///         if (!c.isNull(1)) {
///             String mimeType = c.getString(2);
///             String data = c.getString(3);
///             ...
///         }
///     }
/// } finally {
///     c.close();
/// }
/// </pre>
///
/// <h3>Columns</h3>
/// RawContactsEntity has a combination of RawContact and Data columns.
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>RawContacts</th>
/// </tr>
/// <tr>
/// <td style="width: 7em;">long</td>
/// <td style="width: 20em;">\#_ID</td>
/// <td style="width: 5em;">read-only</td>
/// <td>Raw contact row ID. See RawContacts.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_ID</td>
/// <td>read-only</td>
/// <td>See RawContacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#AGGREGATION_MODE</td>
/// <td>read-only</td>
/// <td>See RawContacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#DELETED</td>
/// <td>read-only</td>
/// <td>See RawContacts.</td>
/// </tr>
/// </table>
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Data</th>
/// </tr>
/// <tr>
/// <td style="width: 7em;">long</td>
/// <td style="width: 20em;">\#DATA_ID</td>
/// <td style="width: 5em;">read-only</td>
/// <td>Data row ID. It will be null if the raw contact has no data rows.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#MIMETYPE</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Data.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#IS_PRIMARY</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Data.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#IS_SUPER_PRIMARY</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Data.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#DATA_VERSION</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Data.</td>
/// </tr>
/// <tr>
/// <td>Any type</td>
/// <td>
/// \#DATA1<br>
/// \#DATA2<br>
/// \#DATA3<br>
/// \#DATA4<br>
/// \#DATA5<br>
/// \#DATA6<br>
/// \#DATA7<br>
/// \#DATA8<br>
/// \#DATA9<br>
/// \#DATA10<br>
/// \#DATA11<br>
/// \#DATA12<br>
/// \#DATA13<br>
/// \#DATA14<br>
/// \#DATA15
/// </td>
/// <td>read-only</td>
/// <td>See ContactsContract.Data.</td>
/// </tr>
/// <tr>
/// <td>Any type</td>
/// <td>
/// \#SYNC1<br>
/// \#SYNC2<br>
/// \#SYNC3<br>
/// \#SYNC4
/// </td>
/// <td>read-only</td>
/// <td>See ContactsContract.Data.</td>
/// </tr>
/// </table>
class ContactsContract_RawContactsEntity extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$RawContactsEntity");
  ContactsContract_RawContactsEntity.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI providing a directory of raw contact entities.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/raw_contact_entity";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DATA_ID
  ///
  /// The ID of the data column. The value will be null if this raw contact has no data rows.
  /// <P>Type: INTEGER</P>
  static const DATA_ID = "data_id";

  static final _id_PROFILE_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "PROFILE_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri PROFILE_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table, specific to the user's profile.
  static uri_.Uri get PROFILE_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_PROFILE_CONTENT_URI, jni.JniType.objectType)
      .object);
}

/// from: android.provider.ContactsContract$RawContactsColumns
class ContactsContract_RawContactsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$RawContactsColumns");
  ContactsContract_RawContactsColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String ACCOUNT_TYPE_AND_DATA_SET
  ///
  /// A concatenation of the account type and data set (delimited by a forward
  /// slash) - if the data set is empty, this will be the same as the account
  /// type.  For applications that need to be aware of the data set, this can
  /// be used instead of account type to distinguish sets of data.  This is
  /// never intended to be used for specifying accounts.
  ///
  /// This column does *not* escape forward slashes in the account type or the data set.
  /// If this is an issue, consider using
  /// ContactsContract.RawContacts\#ACCOUNT_TYPE and
  /// ContactsContract.RawContacts\#DATA_SET directly.
  static const ACCOUNT_TYPE_AND_DATA_SET = "account_type_and_data_set";

  /// from: static public final java.lang.String AGGREGATION_MODE
  ///
  /// The aggregation mode for this contact.
  /// <P>Type: INTEGER</P>
  static const AGGREGATION_MODE = "aggregation_mode";

  /// from: static public final java.lang.String BACKUP_ID
  ///
  /// Persistent unique id for each raw_contact within its account.
  /// This id is provided by its own data source, and can be used to backup metadata
  /// to the server.
  /// This should be unique within each set of account_name/account_type/data_set
  static const BACKUP_ID = "backup_id";

  /// from: static public final java.lang.String CONTACT_ID
  ///
  /// A reference to the ContactsContract.Contacts\#_ID that this
  /// data belongs to.
  /// <P>Type: INTEGER</P>
  static const CONTACT_ID = "contact_id";

  /// from: static public final java.lang.String DATA_SET
  ///
  /// The data set within the account that this row belongs to.  This allows
  /// multiple sync adapters for the same account type to distinguish between
  /// each others' data.
  ///
  /// This is empty by default, and is completely optional.  It only needs to
  /// be populated if multiple sync adapters are entering distinct data for
  /// the same account type and account name.
  /// <P>Type: TEXT</P>
  static const DATA_SET = "data_set";

  /// from: static public final java.lang.String DELETED
  ///
  /// The "deleted" flag: "0" by default, "1" if the row has been marked
  /// for deletion. When android.content.ContentResolver\#delete is
  /// called on a raw contact, it is marked for deletion and removed from its
  /// aggregate contact. The sync adaptor deletes the raw contact on the server and
  /// then calls ContactResolver.delete once more, this time passing the
  /// ContactsContract\#CALLER_IS_SYNCADAPTER query parameter to finalize
  /// the data removal.
  /// <P>Type: INTEGER</P>
  static const DELETED = "deleted";

  /// from: static public final java.lang.String METADATA_DIRTY
  ///
  /// Flag indicating that a raw contact's metadata has changed, and its metadata
  /// needs to be synchronized by the server.
  /// <P>Type: INTEGER (boolean)</P>
  static const METADATA_DIRTY = "metadata_dirty";

  /// from: static public final java.lang.String RAW_CONTACT_IS_READ_ONLY
  ///
  /// The "read-only" flag: "0" by default, "1" if the row cannot be modified or
  /// deleted except by a sync adapter.  See ContactsContract\#CALLER_IS_SYNCADAPTER.
  /// <P>Type: INTEGER</P>
  static const RAW_CONTACT_IS_READ_ONLY = "raw_contact_is_read_only";

  /// from: static public final java.lang.String RAW_CONTACT_IS_USER_PROFILE
  ///
  /// Flag that reflects whether this raw contact belongs to the user's
  /// personal profile entry.
  static const RAW_CONTACT_IS_USER_PROFILE = "raw_contact_is_user_profile";
}

/// from: android.provider.ContactsContract$RawContacts
///
/// Constants for the raw contacts table, which contains one row of contact
/// information for each person in each synced account. Sync adapters and
/// contact management apps
/// are the primary consumers of this API.
///
/// <h3>Aggregation</h3>
///
/// As soon as a raw contact is inserted or whenever its constituent data
/// changes, the provider will check if the raw contact matches other
/// existing raw contacts and if so will aggregate it with those. The
/// aggregation is reflected in the RawContacts table by the change of the
/// \#CONTACT_ID field, which is the reference to the aggregate contact.
///
///
///
/// Changes to the structured name, organization, phone number, email address,
/// or nickname trigger a re-aggregation.
///
///
///
/// See also AggregationExceptions for a mechanism to control
/// aggregation programmatically.
///
///
///
/// <h3>Operations</h3>
/// <dl>
/// <dt>__Insert__</dt>
/// <dd>
///
/// Raw contacts can be inserted incrementally or in a batch.
/// The incremental method is more traditional but less efficient.
/// It should be used
/// only if no Data values are available at the time the raw contact is created:
/// <pre>
/// ContentValues values = new ContentValues();
/// values.put(RawContacts.ACCOUNT_TYPE, accountType);
/// values.put(RawContacts.ACCOUNT_NAME, accountName);
/// Uri rawContactUri = getContentResolver().insert(RawContacts.CONTENT_URI, values);
/// long rawContactId = ContentUris.parseId(rawContactUri);
/// </pre>
///
///
///
/// Once Data values become available, insert those.
/// For example, here's how you would insert a name:
///
/// <pre>
/// values.clear();
/// values.put(Data.RAW_CONTACT_ID, rawContactId);
/// values.put(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);
/// values.put(StructuredName.DISPLAY_NAME, &quot;Mike Sullivan&quot;);
/// getContentResolver().insert(Data.CONTENT_URI, values);
/// </pre>
///
///
///
/// The batch method is by far preferred.  It inserts the raw contact and its
/// constituent data rows in a single database transaction
/// and causes at most one aggregation pass.
/// <pre>
/// ArrayList&lt;ContentProviderOperation&gt; ops =
///          new ArrayList&lt;ContentProviderOperation&gt;();
/// ...
/// int rawContactInsertIndex = ops.size();
/// ops.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI)
///          .withValue(RawContacts.ACCOUNT_TYPE, accountType)
///          .withValue(RawContacts.ACCOUNT_NAME, accountName)
///          .build());
///
/// ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
///          .withValueBackReference(Data.RAW_CONTACT_ID, rawContactInsertIndex)
///          .withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE)
///          .withValue(StructuredName.DISPLAY_NAME, &quot;Mike Sullivan&quot;)
///          .build());
///
/// getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);
/// </pre>
///
///
///
/// Note the use of ContentProviderOperation.Builder\#withValueBackReference(String, int)
/// to refer to the as-yet-unknown index value of the raw contact inserted in the
/// first operation.
///
///
///
/// <dt>__Update__</dt>
/// <dd>
/// Raw contacts can be updated incrementally or in a batch.
/// Batch mode should be used whenever possible.
/// The procedures and considerations are analogous to those documented above for inserts.
///
///</dd>
/// <dt>__Delete__</dt>
/// <dd>When a raw contact is deleted, all of its Data rows as well as StatusUpdates,
/// AggregationExceptions, PhoneLookup rows are deleted automatically. When all raw
/// contacts associated with a Contacts row are deleted, the Contacts row
/// itself is also deleted automatically.
///
///
///
/// The invocation of {@code resolver.delete(...)}, does not immediately delete
/// a raw contacts row.
/// Instead, it sets the \#DELETED flag on the raw contact and
/// removes the raw contact from its aggregate contact.
/// The sync adapter then deletes the raw contact from the server and
/// finalizes phone-side deletion by calling {@code resolver.delete(...)}
/// again and passing the ContactsContract\#CALLER_IS_SYNCADAPTER query parameter.
/// Some sync adapters are read-only, meaning that they only sync server-side
/// changes to the phone, but not the reverse.  If one of those raw contacts
/// is marked for deletion, it will remain on the phone.  However it will be
/// effectively invisible, because it will not be part of any aggregate contact.
/// </dd>
///
/// <dt>__Query__</dt>
/// <dd>
///
/// It is easy to find all raw contacts in a Contact:
/// <pre>
/// Cursor c = getContentResolver().query(RawContacts.CONTENT_URI,
///          new String[]{RawContacts._ID},
///          RawContacts.CONTACT_ID + "=?",
///          new String[]{String.valueOf(contactId)}, null);
/// </pre>
///
///
///
/// To find raw contacts within a specific account,
/// you can either put the account name and type in the selection or pass them as query
/// parameters.  The latter approach is preferable, especially when you can reuse the
/// URI:
/// <pre>
/// Uri rawContactUri = RawContacts.CONTENT_URI.buildUpon()
///          .appendQueryParameter(RawContacts.ACCOUNT_NAME, accountName)
///          .appendQueryParameter(RawContacts.ACCOUNT_TYPE, accountType)
///          .build();
/// Cursor c1 = getContentResolver().query(rawContactUri,
///          RawContacts.STARRED + "&lt;&gt;0", null, null, null);
/// ...
/// Cursor c2 = getContentResolver().query(rawContactUri,
///          RawContacts.DELETED + "&lt;&gt;0", null, null, null);
/// </pre>
///
///
/// The best way to read a raw contact along with all the data associated with it is
/// by using the Entity directory. If the raw contact has data rows,
/// the Entity cursor will contain a row for each data row.  If the raw contact has no
/// data rows, the cursor will still contain one row with the raw contact-level information.
/// <pre>
/// Uri rawContactUri = ContentUris.withAppendedId(RawContacts.CONTENT_URI, rawContactId);
/// Uri entityUri = Uri.withAppendedPath(rawContactUri, Entity.CONTENT_DIRECTORY);
/// Cursor c = getContentResolver().query(entityUri,
///          new String[]{RawContacts.SOURCE_ID, Entity.DATA_ID, Entity.MIMETYPE, Entity.DATA1},
///          null, null, null);
/// try {
///     while (c.moveToNext()) {
///         String sourceId = c.getString(0);
///         if (!c.isNull(1)) {
///             String mimeType = c.getString(2);
///             String data = c.getString(3);
///             ...
///         }
///     }
/// } finally {
///     c.close();
/// }
/// </pre>
///
///
/// </dd>
/// </dl>
/// <h2>Columns</h2>
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>RawContacts</th>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#_ID</td>
/// <td>read-only</td>
/// <td>Row ID. Sync adapters should try to preserve row IDs during updates. In other words,
/// it is much better for a sync adapter to update a raw contact rather than to delete and
/// re-insert it.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_ID</td>
/// <td>read-only</td>
/// <td>The ID of the row in the ContactsContract.Contacts table
/// that this raw contact belongs
/// to. Raw contacts are linked to contacts by the aggregation process, which can be controlled
/// by the \#AGGREGATION_MODE field and AggregationExceptions.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#AGGREGATION_MODE</td>
/// <td>read/write</td>
/// <td>A mechanism that allows programmatic control of the aggregation process. The allowed
/// values are \#AGGREGATION_MODE_DEFAULT, \#AGGREGATION_MODE_DISABLED
/// and \#AGGREGATION_MODE_SUSPENDED. See also AggregationExceptions.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#DELETED</td>
/// <td>read/write</td>
/// <td>The "deleted" flag: "0" by default, "1" if the row has been marked
/// for deletion. When android.content.ContentResolver\#delete is
/// called on a raw contact, it is marked for deletion and removed from its
/// aggregate contact. The sync adaptor deletes the raw contact on the server and
/// then calls ContactResolver.delete once more, this time passing the
/// ContactsContract\#CALLER_IS_SYNCADAPTER query parameter to finalize
/// the data removal.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TIMES_CONTACTED</td>
/// <td>read/write</td>
/// <td>The number of times the contact has been contacted. To have an effect
/// on the corresponding value of the aggregate contact, this field
/// should be set at the time the raw contact is inserted.
/// After that, this value is typically updated via
/// ContactsContract.Contacts\#markAsContacted.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#LAST_TIME_CONTACTED</td>
/// <td>read/write</td>
/// <td>The timestamp of the last time the contact was contacted. To have an effect
/// on the corresponding value of the aggregate contact, this field
/// should be set at the time the raw contact is inserted.
/// After that, this value is typically updated via
/// ContactsContract.Contacts\#markAsContacted.
/// </td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#STARRED</td>
/// <td>read/write</td>
/// <td>An indicator for favorite contacts: '1' if favorite, '0' otherwise.
/// Changing this field immediately affects the corresponding aggregate contact:
/// if any raw contacts in that aggregate contact are starred, then the contact
/// itself is marked as starred.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CUSTOM_RINGTONE</td>
/// <td>read/write</td>
/// <td>A custom ringtone associated with a raw contact. Typically this is the
/// URI returned by an activity launched with the
/// android.media.RingtoneManager\#ACTION_RINGTONE_PICKER intent.
/// To have an effect on the corresponding value of the aggregate contact, this field
/// should be set at the time the raw contact is inserted. To set a custom
/// ringtone on a contact, use the field ContactsContract.Contacts\#CUSTOM_RINGTONE Contacts.CUSTOM_RINGTONE
/// instead.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#SEND_TO_VOICEMAIL</td>
/// <td>read/write</td>
/// <td>An indicator of whether calls from this raw contact should be forwarded
/// directly to voice mail ('1') or not ('0'). To have an effect
/// on the corresponding value of the aggregate contact, this field
/// should be set at the time the raw contact is inserted.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#ACCOUNT_NAME</td>
/// <td>read/write-once</td>
/// <td>The name of the account instance to which this row belongs, which when paired with
/// \#ACCOUNT_TYPE identifies a specific account.
/// For example, this will be the Gmail address if it is a Google account.
/// It should be set at the time the raw contact is inserted and never
/// changed afterwards.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#ACCOUNT_TYPE</td>
/// <td>read/write-once</td>
/// <td>
///
/// The type of account to which this row belongs, which when paired with
/// \#ACCOUNT_NAME identifies a specific account.
/// It should be set at the time the raw contact is inserted and never
/// changed afterwards.
///
///
///
/// To ensure uniqueness, new account types should be chosen according to the
/// Java package naming convention.  Thus a Google account is of type "com.google".
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#DATA_SET</td>
/// <td>read/write-once</td>
/// <td>
///
/// The data set within the account that this row belongs to.  This allows
/// multiple sync adapters for the same account type to distinguish between
/// each others' data.  The combination of \#ACCOUNT_TYPE,
/// \#ACCOUNT_NAME, and \#DATA_SET identifies a set of data
/// that is associated with a single sync adapter.
///
///
///
/// This is empty by default, and is completely optional.  It only needs to
/// be populated if multiple sync adapters are entering distinct data for
/// the same account type and account name.
///
///
///
/// It should be set at the time the raw contact is inserted and never
/// changed afterwards.
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SOURCE_ID</td>
/// <td>read/write</td>
/// <td>String that uniquely identifies this row to its source account.
/// Typically it is set at the time the raw contact is inserted and never
/// changed afterwards. The one notable exception is a new raw contact: it
/// will have an account name and type (and possibly a data set), but no
/// source id. This indicates to the sync adapter that a new contact needs
/// to be created server-side and its ID stored in the corresponding
/// SOURCE_ID field on the phone.
/// </td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#VERSION</td>
/// <td>read-only</td>
/// <td>Version number that is updated whenever this row or its related data
/// changes. This field can be used for optimistic locking of a raw contact.
/// </td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#DIRTY</td>
/// <td>read/write</td>
/// <td>Flag indicating that \#VERSION has changed, and this row needs
/// to be synchronized by its owning account.  The value is set to "1" automatically
/// whenever the raw contact changes, unless the URI has the
/// ContactsContract\#CALLER_IS_SYNCADAPTER query parameter specified.
/// The sync adapter should always supply this query parameter to prevent
/// unnecessary synchronization: user changes some data on the server,
/// the sync adapter updates the contact on the phone (without the
/// CALLER_IS_SYNCADAPTER flag) flag, which sets the DIRTY flag,
/// which triggers a sync to bring the changes to the server.
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SYNC1</td>
/// <td>read/write</td>
/// <td>Generic column provided for arbitrary use by sync adapters.
/// The content provider
/// stores this information on behalf of the sync adapter but does not
/// interpret it in any way.
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SYNC2</td>
/// <td>read/write</td>
/// <td>Generic column for use by sync adapters.
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SYNC3</td>
/// <td>read/write</td>
/// <td>Generic column for use by sync adapters.
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SYNC4</td>
/// <td>read/write</td>
/// <td>Generic column for use by sync adapters.
/// </td>
/// </tr>
/// </table>
class ContactsContract_RawContacts extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$RawContacts");
  ContactsContract_RawContacts.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AGGREGATION_MODE_DEFAULT
  ///
  /// Aggregation mode: aggregate immediately after insert or update operation(s) are complete.
  static const AGGREGATION_MODE_DEFAULT = 0;

  /// from: static public final int AGGREGATION_MODE_DISABLED
  ///
  ///
  /// Aggregation mode: never aggregate this raw contact.  The raw contact will not
  /// have a corresponding Contacts aggregate and therefore will not be included in
  /// Contacts query results.
  ///
  ///
  ///
  /// For example, this mode can be used for a raw contact that is marked for deletion while
  /// waiting for the deletion to occur on the server side.
  ///
  ///
  ///@see \#AGGREGATION_MODE_SUSPENDED
  static const AGGREGATION_MODE_DISABLED = 3;

  /// from: static public final int AGGREGATION_MODE_IMMEDIATE
  ///
  /// Aggregation mode: aggregate at the time the raw contact is inserted/updated.
  ///@deprecated Aggregation is synchronous, this historic value is a no-op
  static const AGGREGATION_MODE_IMMEDIATE = 1;

  /// from: static public final int AGGREGATION_MODE_SUSPENDED
  ///
  ///
  /// Aggregation mode: aggregation suspended temporarily, and is likely to be resumed later.
  /// Changes to the raw contact will update the associated aggregate contact but will not
  /// result in any change in how the contact is aggregated. Similar to
  /// \#AGGREGATION_MODE_DISABLED, but maintains a link to the corresponding
  /// Contacts aggregate.
  ///
  ///
  ///
  /// This can be used to postpone aggregation until after a series of updates, for better
  /// performance and/or user experience.
  ///
  ///
  ///
  /// Note that changing
  /// \#AGGREGATION_MODE from \#AGGREGATION_MODE_SUSPENDED to
  /// \#AGGREGATION_MODE_DEFAULT does not trigger an aggregation pass, but any
  /// subsequent
  /// change to the raw contact's data will.
  ///
  ///
  static const AGGREGATION_MODE_SUSPENDED = 2;

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME type of the results when a raw contact ID is appended to \#CONTENT_URI,
  /// yielding a subdirectory of a single person.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/raw_contact";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of the results from \#CONTENT_URI when a specific
  /// ID value is not provided, and multiple raw contacts may be returned.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/raw_contact";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table, which requests a directory of
  /// raw contact rows matching the selection criteria.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_getContactLookupUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getContactLookupUri",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContactLookupUri(android.content.ContentResolver resolver, android.net.Uri rawContactUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build a android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI
  /// style Uri for the parent android.provider.ContactsContract.Contacts
  /// entry of the given RawContacts entry.
  static uri_.Uri getContactLookupUri(
          contentresolver_.ContentResolver resolver, uri_.Uri rawContactUri) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContactLookupUri,
          jni.JniType.objectType,
          [resolver.reference, rawContactUri.reference]).object);

  static final _id_newEntityIterator = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newEntityIterator",
      "(Landroid/database/Cursor;)Landroid/content/EntityIterator;");

  /// from: static public android.content.EntityIterator newEntityIterator(android.database.Cursor cursor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// TODO: javadoc
  ///@param cursor
  ///@return
  static entityiterator_.EntityIterator newEntityIterator(
          cursor_.Cursor cursor) =>
      entityiterator_.EntityIterator.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_newEntityIterator,
              jni.JniType.objectType, [cursor.reference]).object);
}

/// from: android.provider.ContactsContract$RawContacts$Entity
///
///
/// A sub-directory of a single raw contact that contains all of its
/// ContactsContract.Data rows. To access this directory append
/// RawContacts.Entity\#CONTENT_DIRECTORY to the raw contact URI. See
/// RawContactsEntity for a stand-alone table containing the same
/// data.
///
///
///
/// Entity has two ID fields: \#_ID for the raw contact
/// and \#DATA_ID for the data rows.
/// Entity always contains at least one row, even if there are no
/// actual data rows. In this case the \#DATA_ID field will be
/// null.
///
///
///
/// Using Entity should be preferred to using two separate queries:
/// RawContacts followed by Data. The reason is that Entity reads all
/// data for a raw contact in one transaction, so there is no possibility
/// of the data changing between the two queries.
class ContactsContract_RawContacts_Entity extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$RawContacts\$Entity");
  ContactsContract_RawContacts_Entity.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// The directory twig for this sub-table
  static const CONTENT_DIRECTORY = "entity";

  /// from: static public final java.lang.String DATA_ID
  ///
  /// The ID of the data row. The value will be null if this raw contact has no
  /// data rows.
  /// <P>Type: INTEGER</P>
  static const DATA_ID = "data_id";
}

/// from: android.provider.ContactsContract$RawContacts$DisplayPhoto
///
///
/// A sub-directory of a single raw contact that represents its primary
/// display photo.  To access this directory append
/// RawContacts.DisplayPhoto\#CONTENT_DIRECTORY to the raw contact URI.
/// The resulting URI represents an image file, and should be interacted with
/// using ContentResolver.openAssetFileDescriptor.
///
///
/// Note that this sub-directory also supports opening the photo as an asset file
/// in write mode.  Callers can create or replace the primary photo associated
/// with this raw contact by opening the asset file and writing the full-size
/// photo contents into it.  When the file is closed, the image will be parsed,
/// sized down if necessary for the full-size display photo and thumbnail
/// dimensions, and stored.
///
///
///
/// Usage example:
/// <pre>
/// public void writeDisplayPhoto(long rawContactId, byte[] photo) {
///     Uri rawContactPhotoUri = Uri.withAppendedPath(
///             ContentUris.withAppendedId(RawContacts.CONTENT_URI, rawContactId),
///             RawContacts.DisplayPhoto.CONTENT_DIRECTORY);
///     try {
///         AssetFileDescriptor fd =
///             getContentResolver().openAssetFileDescriptor(rawContactPhotoUri, "rw");
///         OutputStream os = fd.createOutputStream();
///         os.write(photo);
///         os.close();
///         fd.close();
///     } catch (IOException e) {
///         // Handle error cases.
///     }
/// }
/// </pre>
///
///
class ContactsContract_RawContacts_DisplayPhoto extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$RawContacts\$DisplayPhoto");
  ContactsContract_RawContacts_DisplayPhoto.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// The directory twig for this sub-table
  static const CONTENT_DIRECTORY = "display_photo";
}

/// from: android.provider.ContactsContract$RawContacts$Data
///
/// A sub-directory of a single raw contact that contains all of its
/// ContactsContract.Data rows. To access this directory
/// append Data\#CONTENT_DIRECTORY to the raw contact URI.
class ContactsContract_RawContacts_Data extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$RawContacts\$Data");
  ContactsContract_RawContacts_Data.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// The directory twig for this sub-table
  static const CONTENT_DIRECTORY = "data";
}

/// from: android.provider.ContactsContract$QuickContact
///
/// Helper methods to display QuickContact dialogs that display all the information belonging to
/// a specific Contacts entry.
class ContactsContract_QuickContact extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$QuickContact");
  ContactsContract_QuickContact.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_QUICK_CONTACT
  ///
  /// Action used to launch the system contacts application and bring up a QuickContact dialog
  /// for the provided Contacts entry.
  static const ACTION_QUICK_CONTACT = "android.provider.action.QUICK_CONTACT";

  /// from: static public final java.lang.String EXTRA_EXCLUDE_MIMES
  ///
  /// Extra used to indicate a list of specific MIME-types to exclude and not display in the
  /// QuickContacts dialog. Stored as a String array.
  static const EXTRA_EXCLUDE_MIMES = "android.provider.extra.EXCLUDE_MIMES";

  /// from: static public final java.lang.String EXTRA_MODE
  ///
  /// Extra used to specify size of QuickContacts. Not all implementations of QuickContacts
  /// will respect this extra's value.
  ///
  /// One of \#MODE_SMALL, \#MODE_MEDIUM, or \#MODE_LARGE.
  static const EXTRA_MODE = "android.provider.extra.MODE";

  /// from: static public final java.lang.String EXTRA_PRIORITIZED_MIMETYPE
  ///
  /// Extra used to specify which mimetype should be prioritized in the QuickContacts UI.
  /// For example, passing the value CommonDataKinds.Phone\#CONTENT_ITEM_TYPE can
  /// cause phone numbers to be displayed more prominently in QuickContacts.
  static const EXTRA_PRIORITIZED_MIMETYPE =
      "android.provider.extra.PRIORITIZED_MIMETYPE";

  /// from: static public final int MODE_LARGE
  ///
  /// Large QuickContact mode, includes actions and larger, card-like summary
  /// of the Contacts entry being shown. This may include detailed
  /// information, such as a photo.
  static const MODE_LARGE = 3;

  /// from: static public final int MODE_MEDIUM
  ///
  /// Medium QuickContact mode, includes actions and light summary describing
  /// the Contacts entry being shown. This may include social
  /// status and presence details.
  static const MODE_MEDIUM = 2;

  /// from: static public final int MODE_SMALL
  ///
  /// Small QuickContact mode, usually presented with minimal actions.
  static const MODE_SMALL = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_QuickContact()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_showQuickContact = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "showQuickContact",
      "(Landroid/content/Context;Landroid/view/View;Landroid/net/Uri;I[Ljava/lang/String;)V");

  /// from: static public void showQuickContact(android.content.Context context, android.view.View target, android.net.Uri lookupUri, int mode, java.lang.String[] excludeMimes)
  ///
  /// Trigger a dialog that lists the various methods of interacting with
  /// the requested Contacts entry. This may be based on available
  /// ContactsContract.Data rows under that contact, and may also
  /// include social status and presence details.
  ///@param context The parent Context that may be used as the
  ///            parent for this dialog.
  ///@param target Specific View from your layout that this dialog
  ///            should be centered around. In particular, if the dialog
  ///            has a "callout" arrow, it will be pointed and centered
  ///            around this View.
  ///@param lookupUri A ContactsContract.Contacts\#CONTENT_LOOKUP_URI style
  ///            Uri that describes a specific contact to feature
  ///            in this dialog. A work lookup uri is supported here,
  ///            see CommonDataKinds.Email\#ENTERPRISE_CONTENT_LOOKUP_URI and
  ///            PhoneLookup\#ENTERPRISE_CONTENT_FILTER_URI.
  ///@param mode Any of \#MODE_SMALL, \#MODE_MEDIUM, or
  ///            \#MODE_LARGE, indicating the desired dialog size,
  ///            when supported.
  ///@param excludeMimes Optional list of Data\#MIMETYPE MIME-types
  ///            to exclude when showing this dialog. For example, when
  ///            already viewing the contact details card, this can be used
  ///            to omit the details entry from the dialog.
  static void showQuickContact(context_.Context context, view_.View target,
          uri_.Uri lookupUri, int mode, jni.JniObject excludeMimes) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_showQuickContact, jni.JniType.voidType, [
        context.reference,
        target.reference,
        lookupUri.reference,
        mode,
        excludeMimes.reference
      ]).check();

  static final _id_showQuickContact1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "showQuickContact",
      "(Landroid/content/Context;Landroid/graphics/Rect;Landroid/net/Uri;I[Ljava/lang/String;)V");

  /// from: static public void showQuickContact(android.content.Context context, android.graphics.Rect target, android.net.Uri lookupUri, int mode, java.lang.String[] excludeMimes)
  ///
  /// Trigger a dialog that lists the various methods of interacting with
  /// the requested Contacts entry. This may be based on available
  /// ContactsContract.Data rows under that contact, and may also
  /// include social status and presence details.
  ///@param context The parent Context that may be used as the
  ///            parent for this dialog.
  ///@param target Specific Rect that this dialog should be
  ///            centered around, in screen coordinates. In particular, if
  ///            the dialog has a "callout" arrow, it will be pointed and
  ///            centered around this Rect. If you are running at a
  ///            non-native density, you need to manually adjust using
  ///            DisplayMetrics\#density before calling.
  ///@param lookupUri A
  ///            ContactsContract.Contacts\#CONTENT_LOOKUP_URI style
  ///            Uri that describes a specific contact to feature
  ///            in this dialog. A work lookup uri is supported here,
  ///            see CommonDataKinds.Email\#ENTERPRISE_CONTENT_LOOKUP_URI and
  ///            PhoneLookup\#ENTERPRISE_CONTENT_FILTER_URI.
  ///@param mode Any of \#MODE_SMALL, \#MODE_MEDIUM, or
  ///            \#MODE_LARGE, indicating the desired dialog size,
  ///            when supported.
  ///@param excludeMimes Optional list of Data\#MIMETYPE MIME-types
  ///            to exclude when showing this dialog. For example, when
  ///            already viewing the contact details card, this can be used
  ///            to omit the details entry from the dialog.
  static void showQuickContact1(context_.Context context, rect_.Rect target,
          uri_.Uri lookupUri, int mode, jni.JniObject excludeMimes) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_showQuickContact1, jni.JniType.voidType, [
        context.reference,
        target.reference,
        lookupUri.reference,
        mode,
        excludeMimes.reference
      ]).check();

  static final _id_showQuickContact2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "showQuickContact",
      "(Landroid/content/Context;Landroid/view/View;Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;)V");

  /// from: static public void showQuickContact(android.content.Context context, android.view.View target, android.net.Uri lookupUri, java.lang.String[] excludeMimes, java.lang.String prioritizedMimeType)
  ///
  /// Trigger a dialog that lists the various methods of interacting with
  /// the requested Contacts entry. This may be based on available
  /// ContactsContract.Data rows under that contact, and may also
  /// include social status and presence details.
  ///@param context The parent Context that may be used as the
  ///            parent for this dialog.
  ///@param target Specific View from your layout that this dialog
  ///            should be centered around. In particular, if the dialog
  ///            has a "callout" arrow, it will be pointed and centered
  ///            around this View.
  ///@param lookupUri A
  ///            ContactsContract.Contacts\#CONTENT_LOOKUP_URI style
  ///            Uri that describes a specific contact to feature
  ///            in this dialog. A work lookup uri is supported here,
  ///            see CommonDataKinds.Email\#ENTERPRISE_CONTENT_LOOKUP_URI and
  ///            PhoneLookup\#ENTERPRISE_CONTENT_FILTER_URI.
  ///@param excludeMimes Optional list of Data\#MIMETYPE MIME-types
  ///            to exclude when showing this dialog. For example, when
  ///            already viewing the contact details card, this can be used
  ///            to omit the details entry from the dialog.
  ///@param prioritizedMimeType This mimetype should be prioritized in the QuickContacts UI.
  ///             For example, passing the value
  ///             CommonDataKinds.Phone\#CONTENT_ITEM_TYPE can cause phone numbers to be
  ///             displayed more prominently in QuickContacts.
  static void showQuickContact2(
          context_.Context context,
          view_.View target,
          uri_.Uri lookupUri,
          jni.JniObject excludeMimes,
          jni.JniString prioritizedMimeType) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_showQuickContact2, jni.JniType.voidType, [
        context.reference,
        target.reference,
        lookupUri.reference,
        excludeMimes.reference,
        prioritizedMimeType.reference
      ]).check();

  static final _id_showQuickContact3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "showQuickContact",
      "(Landroid/content/Context;Landroid/graphics/Rect;Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;)V");

  /// from: static public void showQuickContact(android.content.Context context, android.graphics.Rect target, android.net.Uri lookupUri, java.lang.String[] excludeMimes, java.lang.String prioritizedMimeType)
  ///
  /// Trigger a dialog that lists the various methods of interacting with
  /// the requested Contacts entry. This may be based on available
  /// ContactsContract.Data rows under that contact, and may also
  /// include social status and presence details.
  ///@param context The parent Context that may be used as the
  ///            parent for this dialog.
  ///@param target Specific Rect that this dialog should be
  ///            centered around, in screen coordinates. In particular, if
  ///            the dialog has a "callout" arrow, it will be pointed and
  ///            centered around this Rect. If you are running at a
  ///            non-native density, you need to manually adjust using
  ///            DisplayMetrics\#density before calling.
  ///@param lookupUri A
  ///            ContactsContract.Contacts\#CONTENT_LOOKUP_URI style
  ///            Uri that describes a specific contact to feature
  ///            in this dialog. A work lookup uri is supported here,
  ///            see CommonDataKinds.Email\#ENTERPRISE_CONTENT_LOOKUP_URI and
  ///            PhoneLookup\#ENTERPRISE_CONTENT_FILTER_URI.
  ///@param excludeMimes Optional list of Data\#MIMETYPE MIME-types
  ///            to exclude when showing this dialog. For example, when
  ///            already viewing the contact details card, this can be used
  ///            to omit the details entry from the dialog.
  ///@param prioritizedMimeType This mimetype should be prioritized in the QuickContacts UI.
  ///             For example, passing the value
  ///             CommonDataKinds.Phone\#CONTENT_ITEM_TYPE can cause phone numbers to be
  ///             displayed more prominently in QuickContacts.
  static void showQuickContact3(
          context_.Context context,
          rect_.Rect target,
          uri_.Uri lookupUri,
          jni.JniObject excludeMimes,
          jni.JniString prioritizedMimeType) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_showQuickContact3, jni.JniType.voidType, [
        context.reference,
        target.reference,
        lookupUri.reference,
        excludeMimes.reference,
        prioritizedMimeType.reference
      ]).check();
}

/// from: android.provider.ContactsContract$ProviderStatus
///
/// API for inquiring about the general status of the provider.
class ContactsContract_ProviderStatus extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$ProviderStatus");
  ContactsContract_ProviderStatus.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME-type of \#CONTENT_URI providing a directory of
  /// settings.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/provider_status";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table.  Requests to this URI can be
  /// performed on the UI thread because they are always unblocking.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DATABASE_CREATION_TIMESTAMP
  ///
  /// Timestamp (milliseconds since epoch) of when the provider's database was created.
  ///
  /// <P>Type: long
  static const DATABASE_CREATION_TIMESTAMP = "database_creation_timestamp";

  /// from: static public final java.lang.String STATUS
  ///
  /// An integer representing the current status of the provider.
  static const STATUS = "status";

  /// from: static public final int STATUS_BUSY
  ///
  /// The provider won't respond to queries. It is in the middle of a long running task, such
  /// as a database upgrade or locale change.
  static const STATUS_BUSY = 1;

  /// from: static public final int STATUS_EMPTY
  ///
  /// The status that indicates that there are no accounts and no contacts
  /// on the device.
  static const STATUS_EMPTY = 2;

  /// from: static public final int STATUS_NORMAL
  ///
  /// Default status of the provider.
  static const STATUS_NORMAL = 0;
}

/// from: android.provider.ContactsContract$ProfileSyncState
///
/// A table provided for sync adapters to use for storing private sync state data for the
/// user's personal profile.
///@see SyncStateContract
class ContactsContract_ProfileSyncState extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$ProfileSyncState");
  ContactsContract_ProfileSyncState.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  static const CONTENT_DIRECTORY = "syncstate";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_get0 = jniAccessors.getStaticMethodIDOf(_classRef, "get",
      "(Landroid/content/ContentProviderClient;Landroid/accounts/Account;)[B");

  /// from: static public byte[] get(android.content.ContentProviderClient provider, android.accounts.Account account)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see android.provider.SyncStateContract.Helpers\#get
  static jni.JniObject get0(
          contentproviderclient_.ContentProviderClient provider,
          account_.Account account) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_get0,
          jni.JniType.objectType,
          [provider.reference, account.reference]).object);

  static final _id_getWithUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getWithUri",
      "(Landroid/content/ContentProviderClient;Landroid/accounts/Account;)Landroid/util/Pair;");

  /// from: static public android.util.Pair<android.net.Uri,byte[]> getWithUri(android.content.ContentProviderClient provider, android.accounts.Account account)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see android.provider.SyncStateContract.Helpers\#get
  static pair_.Pair getWithUri(
          contentproviderclient_.ContentProviderClient provider,
          account_.Account account) =>
      pair_.Pair.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getWithUri,
          jni.JniType.objectType,
          [provider.reference, account.reference]).object);

  static final _id_set0 = jniAccessors.getStaticMethodIDOf(_classRef, "set",
      "(Landroid/content/ContentProviderClient;Landroid/accounts/Account;[B)V");

  /// from: static public void set(android.content.ContentProviderClient provider, android.accounts.Account account, byte[] data)
  ///
  /// @see android.provider.SyncStateContract.Helpers\#set
  static void set0(contentproviderclient_.ContentProviderClient provider,
          account_.Account account, jni.JniObject data) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_set0,
          jni.JniType.voidType,
          [provider.reference, account.reference, data.reference]).check();

  static final _id_newSetOperation = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newSetOperation",
      "(Landroid/accounts/Account;[B)Landroid/content/ContentProviderOperation;");

  /// from: static public android.content.ContentProviderOperation newSetOperation(android.accounts.Account account, byte[] data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see android.provider.SyncStateContract.Helpers\#newSetOperation
  static contentprovideroperation_.ContentProviderOperation newSetOperation(
          account_.Account account, jni.JniObject data) =>
      contentprovideroperation_.ContentProviderOperation.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_newSetOperation,
              jni.JniType.objectType,
              [account.reference, data.reference]).object);
}

/// from: android.provider.ContactsContract$Profile
///
///
/// Constants for the user's profile data, which is represented as a single contact on
/// the device that represents the user.  The profile contact is not aggregated
/// together automatically in the same way that normal contacts are; instead, each
/// account (including data set, if applicable) on the device may contribute a single
/// raw contact representing the user's personal profile data from that source.
///
///
///
/// Access to the profile entry through these URIs (or incidental access to parts of
/// the profile if retrieved directly via ID) requires additional permissions beyond
/// the read/write contact permissions required by the provider.  Querying for profile
/// data requires android.permission.READ_PROFILE permission, and inserting or
/// updating profile data requires android.permission.WRITE_PROFILE permission.
///
///
/// <h3>Operations</h3>
/// <dl>
/// <dt>__Insert__</dt>
/// <dd>The user's profile entry cannot be created explicitly (attempting to do so
/// will throw an exception). When a raw contact is inserted into the profile, the
/// provider will check for the existence of a profile on the device.  If one is
/// found, the raw contact's RawContacts\#CONTACT_ID column gets the _ID of
/// the profile Contact. If no match is found, the profile Contact is created and
/// its _ID is put into the RawContacts\#CONTACT_ID column of the newly
/// inserted raw contact.</dd>
/// <dt>__Update__</dt>
/// <dd>The profile Contact has the same update restrictions as Contacts in general,
/// but requires the android.permission.WRITE_PROFILE permission.</dd>
/// <dt>__Delete__</dt>
/// <dd>The profile Contact cannot be explicitly deleted.  It will be removed
/// automatically if all of its constituent raw contact entries are deleted.</dd>
/// <dt>__Query__</dt>
/// <dd>
/// <ul>
/// <li>The \#CONTENT_URI for profiles behaves in much the same way as
/// retrieving a contact by ID, except that it will only ever return the user's
/// profile contact.
/// </li>
/// <li>
/// The profile contact supports all of the same sub-paths as an individual contact
/// does - the content of the profile contact can be retrieved as entities or
/// data rows.  Similarly, specific raw contact entries can be retrieved by appending
/// the desired raw contact ID within the profile.
/// </li>
/// </ul>
/// </dd>
/// </dl>
class ContactsContract_Profile extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$Profile");
  ContactsContract_Profile.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_RAW_CONTACTS_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_RAW_CONTACTS_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_RAW_CONTACTS_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Uri for referencing the raw contacts that make up the user's profile
  /// Contacts entry.  An individual raw contact entry within the profile
  /// can be addressed by appending the raw contact ID.  The entities or data within
  /// that specific raw contact can be requested by appending the entity or data
  /// path as well.
  static uri_.Uri get CONTENT_RAW_CONTACTS_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_RAW_CONTACTS_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table, which requests the contact entry
  /// representing the user's personal profile data.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_VCARD_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_VCARD_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_VCARD_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Uri for referencing the user's profile Contacts entry,
  /// Provides OpenableColumns columns when queried, or returns the
  /// user's profile contact formatted as a vCard when opened through
  /// ContentResolver\#openAssetFileDescriptor(Uri, String).
  static uri_.Uri get CONTENT_VCARD_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_VCARD_URI, jni.JniType.objectType)
      .object);

  /// from: static public final long MIN_ID
  ///
  /// The minimum ID for any entity that belongs to the profile.  This essentially
  /// defines an ID-space in which profile data is stored, and is used by the provider
  /// to determine whether a request via a non-profile-specific URI should be directed
  /// to the profile data rather than general contacts data, along with all the special
  /// permission checks that entails.
  ///
  /// Callers may use \#isProfileId to check whether a specific ID falls into
  /// the set of data intended for the profile.
  static const MIN_ID = 9223372034707292160;
}

/// from: android.provider.ContactsContract$PresenceColumns
///
/// Additional data mixed in with StatusColumns to link
/// back to specific ContactsContract.Data\#_ID entries.
///@see StatusUpdates
class ContactsContract_PresenceColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$PresenceColumns");
  ContactsContract_PresenceColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CUSTOM_PROTOCOL
  ///
  /// Name of the custom protocol.  Should be supplied along with the \#PROTOCOL value
  /// ContactsContract.CommonDataKinds.Im\#PROTOCOL_CUSTOM.  Should be null or
  /// omitted if \#PROTOCOL value is not
  /// ContactsContract.CommonDataKinds.Im\#PROTOCOL_CUSTOM.
  ///
  /// Type: NUMBER
  ///
  static const CUSTOM_PROTOCOL = "custom_protocol";

  /// from: static public final java.lang.String DATA_ID
  ///
  /// Reference to the Data\#_ID entry that owns this presence.
  /// <P>Type: INTEGER</P>
  static const DATA_ID = "presence_data_id";

  /// from: static public final java.lang.String IM_ACCOUNT
  ///
  /// The IM account for the local user that the presence data came from.
  /// <P>Type: TEXT</P>
  static const IM_ACCOUNT = "im_account";

  /// from: static public final java.lang.String IM_HANDLE
  ///
  /// The IM handle the presence item is for. The handle is scoped to
  /// \#PROTOCOL.
  /// <P>Type: TEXT</P>
  static const IM_HANDLE = "im_handle";

  /// from: static public final java.lang.String PROTOCOL
  ///
  /// See CommonDataKinds.Im for a list of defined protocol constants.
  /// Type: NUMBER
  ///
  static const PROTOCOL = "protocol";
}

/// from: android.provider.ContactsContract$Presence
///
/// @deprecated This old name was never meant to be made public. Do not use.
class ContactsContract_Presence extends ContactsContract_StatusUpdates {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$Presence");
  ContactsContract_Presence.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_Presence()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.ContactsContract$PinnedPositions
///
///
/// Contact-specific information about whether or not a contact has been pinned by the user
/// at a particular position within the system contact application's user interface.
///
///
///
///
/// This pinning information can be used by individual applications to customize how
/// they order particular pinned contacts. For example, a Dialer application could
/// use pinned information to order user-pinned contacts in a top row of favorites.
///
///
///
///
/// It is possible for two or more contacts to occupy the same pinned position (due
/// to aggregation and sync), so this pinning information should be used on a best-effort
/// basis to order contacts in-application rather than an absolute guide on where a contact
/// should be positioned. Contacts returned by the ContactsProvider will not be ordered based
/// on this information, so it is up to the client application to reorder these contacts within
/// their own UI adhering to (or ignoring as appropriate) information stored in the pinned
/// column.
///
///
///
///
/// By default, unpinned contacts will have a pinned position of
/// PinnedPositions\#UNPINNED. Client-provided pinned positions can be positive
/// integers that are greater than 1.
///
///
class ContactsContract_PinnedPositions extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$PinnedPositions");
  ContactsContract_PinnedPositions.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int DEMOTED
  ///
  /// Value of pinned position for a contact that a user has indicated should be considered
  /// of the lowest priority. It is up to the client application to determine how to present
  /// such a contact - for example all the way at the bottom of a contact list, or simply
  /// just hidden from view.
  static const DEMOTED = -1;

  /// from: static public final int UNPINNED
  ///
  /// Default value for the pinned position of an unpinned contact.
  static const UNPINNED = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_PinnedPositions()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_undemote = jniAccessors.getStaticMethodIDOf(
      _classRef, "undemote", "(Landroid/content/ContentResolver;J)V");

  /// from: static public void undemote(android.content.ContentResolver contentResolver, long contactId)
  ///
  /// Undemotes a formerly demoted contact. If the contact was not previously demoted, nothing
  /// will be done.
  ///@param contentResolver to perform the undemote operation on.
  ///@param contactId the id of the contact to undemote.
  static void undemote(
          contentresolver_.ContentResolver contentResolver, int contactId) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_undemote,
          jni.JniType.voidType, [contentResolver.reference, contactId]).check();

  static final _id_pin = jniAccessors.getStaticMethodIDOf(
      _classRef, "pin", "(Landroid/content/ContentResolver;JI)V");

  /// from: static public void pin(android.content.ContentResolver contentResolver, long contactId, int pinnedPosition)
  ///
  /// Pins a contact at a provided position, or unpins a contact.
  ///@param contentResolver to perform the pinning operation on.
  ///@param pinnedPosition the position to pin the contact at. To unpin a contact, use
  ///         PinnedPositions\#UNPINNED.
  static void pin(contentresolver_.ContentResolver contentResolver,
          int contactId, int pinnedPosition) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_pin,
          jni.JniType.voidType,
          [contentResolver.reference, contactId, pinnedPosition]).check();
}

/// from: android.provider.ContactsContract$PhoneticNameStyle
///
/// Constants for various styles of capturing the pronunciation of a person's name.
class ContactsContract_PhoneticNameStyle extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$PhoneticNameStyle");
  ContactsContract_PhoneticNameStyle.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int JAPANESE
  ///
  /// Hiragana and Katakana are two common styles of writing out the pronunciation
  /// of a Japanese names.
  static const JAPANESE = 4;

  /// from: static public final int KOREAN
  ///
  /// Hangul is the Korean phonetic alphabet.
  static const KOREAN = 5;

  /// from: static public final int PINYIN
  ///
  /// Pinyin is a phonetic method of entering Chinese characters. Typically not explicitly
  /// shown in UIs, but used for searches and sorting.
  static const PINYIN = 3;

  /// from: static public final int UNDEFINED
  static const UNDEFINED = 0;
}

/// from: android.provider.ContactsContract$PhoneLookupColumns
///
/// @see PhoneLookup
class ContactsContract_PhoneLookupColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$PhoneLookupColumns");
  ContactsContract_PhoneLookupColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTACT_ID
  ///
  /// A reference to the ContactsContract.Contacts\#_ID that this
  /// data belongs to.
  /// <P>Type: INTEGER</P>
  static const CONTACT_ID = "contact_id";

  /// from: static public final java.lang.String DATA_ID
  ///
  /// The ID of the data row.
  ///  <P>Type: INTEGER</P>
  static const DATA_ID = "data_id";

  /// from: static public final java.lang.String LABEL
  ///
  /// The user defined label for the phone number.
  /// <P>Type: TEXT</P>
  static const LABEL = "label";

  /// from: static public final java.lang.String NORMALIZED_NUMBER
  ///
  /// The phone number's E164 representation.
  /// <P>Type: TEXT</P>
  static const NORMALIZED_NUMBER = "normalized_number";

  /// from: static public final java.lang.String NUMBER
  ///
  /// The phone number as the user entered it.
  /// <P>Type: TEXT</P>
  static const NUMBER = "number";

  /// from: static public final java.lang.String TYPE
  ///
  /// The type of phone number, for example Home or Work.
  /// <P>Type: INTEGER</P>
  static const TYPE = "type";
}

/// from: android.provider.ContactsContract$PhoneLookup
///
/// A table that represents the result of looking up a phone number, for
/// example for caller ID. To perform a lookup you must append the number you
/// want to find to \#CONTENT_FILTER_URI.  This query is highly
/// optimized.
/// <pre>
/// Uri uri = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, Uri.encode(phoneNumber));
/// resolver.query(uri, new String[]{PhoneLookup.DISPLAY_NAME,...
/// </pre>
///
/// <h3>Columns</h3>
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>PhoneLookup</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#NUMBER</td>
/// <td>read-only</td>
/// <td>Phone number.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#TYPE</td>
/// <td>read-only</td>
/// <td>Phone number type. See CommonDataKinds.Phone.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>read-only</td>
/// <td>Custom label for the phone number. See CommonDataKinds.Phone.</td>
/// </tr>
/// </table>
///
/// Columns from the Contacts table are also available through a join.
///
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Join with Contacts</th>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#_ID</td>
/// <td>read-only</td>
/// <td>Contact ID.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_ID</td>
/// <td>read-only</td>
/// <td>Contact ID.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#DATA_ID</td>
/// <td>read-only</td>
/// <td>Data ID.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LOOKUP_KEY</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#DISPLAY_NAME</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#PHOTO_ID</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#IN_VISIBLE_GROUP</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#HAS_PHONE_NUMBER</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TIMES_CONTACTED</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#LAST_TIME_CONTACTED</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#STARRED</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CUSTOM_RINGTONE</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#SEND_TO_VOICEMAIL</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// </table>
class ContactsContract_PhoneLookup extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$PhoneLookup");
  ContactsContract_PhoneLookup.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_FILTER_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table. Append the phone number you want to lookup
  /// to this URI and query it to perform a lookup. For example:
  /// <pre>
  /// Uri lookupUri = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,
  ///         Uri.encode(phoneNumber));
  /// </pre>
  static uri_.Uri get CONTENT_FILTER_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_FILTER_URI, jni.JniType.objectType)
      .object);

  static final _id_ENTERPRISE_CONTENT_FILTER_URI =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENTERPRISE_CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri ENTERPRISE_CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// URI used for the "enterprise caller-id".
  ///
  ///
  ///
  /// It supports the same semantics as \#CONTENT_FILTER_URI and returns the same
  /// columns.  If the device has no corp profile that is linked to the current profile, it
  /// behaves in the exact same way as \#CONTENT_FILTER_URI.  If there is a corp profile
  /// linked to the current profile, it first queries against the personal contact database,
  /// and if no matching contacts are found there, then queries against the
  /// corp contacts database.
  ///
  ///
  ///
  /// If a result is from the corp profile, it makes the following changes to the data:
  /// <ul>
  ///     <li>
  ///     \#PHOTO_THUMBNAIL_URI and \#PHOTO_URI will be rewritten to special
  ///     URIs.  Use ContentResolver\#openAssetFileDescriptor or its siblings to
  ///     load pictures from them.
  ///     \#PHOTO_ID and \#PHOTO_FILE_ID will be set to null.  Do not use them.
  ///     </li>
  ///     <li>
  ///     Corp contacts will get artificial \#_IDs.  In order to tell whether a contact
  ///     is from the corp profile, use
  ///     ContactsContract.Contacts\#isEnterpriseContactId(long).
  ///     </li>
  ///     <li>
  ///     Corp contacts will get artificial \#LOOKUP_KEYs too.
  ///     </li>
  ///     <li>
  ///     Returned work contact IDs and lookup keys are not accepted in places that not
  ///     explicitly say to accept them.
  ///     </li>
  /// </ul>
  ///
  /// A contact lookup URL built by
  /// ContactsContract.Contacts\#getLookupUri(long, String)
  /// with an \#_ID and a \#LOOKUP_KEY returned by this API can be passed to
  /// ContactsContract.QuickContact\#showQuickContact even if a contact is from the
  /// corp profile.
  ///
  ///
  ///
  /// <pre>
  /// Uri lookupUri = Uri.withAppendedPath(PhoneLookup.ENTERPRISE_CONTENT_FILTER_URI,
  ///         Uri.encode(phoneNumber));
  /// </pre>
  static uri_.Uri get ENTERPRISE_CONTENT_FILTER_URI => uri_.Uri.fromRef(
      jniAccessors
          .getStaticField(_classRef, _id_ENTERPRISE_CONTENT_FILTER_URI,
              jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String QUERY_PARAMETER_SIP_ADDRESS
  ///
  /// If this boolean parameter is set to true, then the appended query is treated as a
  /// SIP address and the lookup will be performed against SIP addresses in the user's
  /// contacts.
  static const QUERY_PARAMETER_SIP_ADDRESS = "sip";
}

/// from: android.provider.ContactsContract$Intents
///
/// Contains helper classes used to create or manage android.content.Intent Intents
/// that involve contacts.
class ContactsContract_Intents extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$Intents");
  ContactsContract_Intents.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_VOICE_SEND_MESSAGE_TO_CONTACTS
  ///
  /// Activity Action: Initiate a message to someone by voice. The message could be text,
  /// audio, video or image(photo). This action supports messaging with a specific contact
  /// regardless of the underlying messaging protocol used.
  ///
  /// The action could be originated from the Voice Assistant as a voice interaction. In such
  /// case, a receiving activity that supports android.content.Intent\#CATEGORY_VOICE
  /// could check return value of android.app.Activity\#isVoiceInteractionRoot before
  /// proceeding. By doing this check the activity verifies that the action indeed was
  /// initiated by Voice Assistant and could send a message right away, without any further
  /// input from the user. This allows for a smooth user experience when sending a message by
  /// voice. Note: this activity must also support the android.content.Intent\#CATEGORY_DEFAULT so it can be found by android.service.voice.VoiceInteractionSession\#startVoiceActivity.
  ///
  /// When the action was not initiated by Voice Assistant or when the receiving activity does
  /// not support android.content.Intent\#CATEGORY_VOICE, the activity must confirm
  /// with the user before sending the message (because in this case it is unknown which app
  /// sent the intent, it could be malicious).
  ///
  /// To allow the Voice Assistant to help users with contacts disambiguation, the messaging
  /// app may choose to integrate with the Contacts Provider. You will need to specify a new
  /// MIME type in order to store your app\u2019s unique contact IDs and optional human readable
  /// labels in the Data table. The Voice Assistant needs to know this MIME type and RawContacts\#ACCOUNT_TYPE that you are using in order to provide the smooth contact
  /// disambiguation user experience. The following convention should be met when performing
  /// such integration:
  /// <ul>
  /// <li>This activity should have a string meta-data field associated with it, \#METADATA_ACCOUNT_TYPE, which defines RawContacts\#ACCOUNT_TYPE for your Contacts
  /// Provider implementation. The account type should be globally unique, for example you can
  /// use your app package name as the account type.</li>
  /// <li>This activity should have a string meta-data field associated with it, \#METADATA_MIMETYPE, which defines DataColumns\#MIMETYPE for your Contacts
  /// Provider implementation. For example, you can use
  /// "vnd.android.cursor.item/vnd.{$app_package_name}.profile" as MIME type.</li>
  /// <li>When filling Data table row for METADATA_MIMETYPE, column DataColumns\#DATA1
  /// should store the unique contact ID as understood by the app. This value will be used in
  /// the \#EXTRA_RECIPIENT_CONTACT_CHAT_ID.</li>
  /// <li>Optionally, when filling Data table row for METADATA_MIMETYPE, column DataColumns\#DATA3 could store a human readable label for the ID. For example it could be
  /// phone number or human readable username/user_id like "a_super_cool_user_name". This label
  /// may be shown below the Contact Name by the Voice Assistant as the user completes the
  /// voice action. If DATA3 is empty, the ID in DATA1 may be shown instead.</li>
  /// <li>_Note: Do not use DATA3 to store the Contact Name. The Voice Assistant will
  /// already get the Contact Name from the RawContact\u2019s display_name._</li>
  /// <li>_Note: Some apps may choose to use phone number as the unique contact ID in DATA1.
  /// If this applies to you and you\u2019d like phone number to be shown below the Contact Name by
  /// the Voice Assistant, then you may choose to leave DATA3 empty._</li>
  /// <li>_Note: If your app also uses DATA3 to display contact details in the Contacts App,
  /// make sure it does not include prefix text such as "Message +<phone>" or "Free Message
  /// +<phone>", etc. If you must show the prefix text in the Contacts App, please use a
  /// different DATA\# column, and update your contacts.xml to point to this new column. _
  /// </li>
  /// <li>Everytime the user sends a message to a contact, your app may choose to update the
  /// ContactOptionsColumns\#TIMES_CONTACTED entry through DataUsageFeedback class.
  /// Doing this will allow Voice Assistant to bias speech recognition to contacts frequently
  /// contacted, this is particularly useful for contact names that are hard to pronounce.</li>
  /// </ul>
  /// If the app chooses not to integrate with the Contacts Provider (in particular, when
  /// either METADATA_ACCOUNT_TYPE or METADATA_MIMETYPE field is missing), Voice Assistant
  /// will use existing phone number entries as contact ID's for such app.
  ///
  /// Input: android.content.Intent\#getType is the MIME type of the data being sent.
  /// The intent sender will always put the concrete mime type in the intent type, like
  /// "text/plain" or "audio/wav" for example. If the MIME type is "text/plain", message to
  /// sent will be provided via android.content.Intent\#EXTRA_TEXT as a styled
  /// CharSequence. Otherwise, the message content will be supplied through android.content.Intent\#setClipData(ClipData) as a content provider URI(s). In the latter
  /// case, EXTRA_TEXT could still be supplied optionally; for example, for audio messages
  /// ClipData will contain URI of a recording and EXTRA_TEXT could contain the text
  /// transcription of this recording.
  ///
  /// The message can have n recipients. The n-th recipient of the message will be provided as
  /// n-th elements of \#EXTRA_RECIPIENT_CONTACT_URI, \#EXTRA_RECIPIENT_CONTACT_CHAT_ID and \#EXTRA_RECIPIENT_CONTACT_NAME (as a
  /// consequence, EXTRA_RECIPIENT_CONTACT_URI, EXTRA_RECIPIENT_CONTACT_CHAT_ID and
  /// EXTRA_RECIPIENT_CONTACT_NAME should all be of length n). If neither of these 3 elements
  /// is provided (e.g. all 3 are null) for the recipient or if the information provided is
  /// ambiguous then the activity should prompt the user for the recipient to send the message
  /// to.
  ///
  /// Output: nothing
  ///@see \#EXTRA_RECIPIENT_CONTACT_URI
  ///@see \#EXTRA_RECIPIENT_CONTACT_CHAT_ID
  ///@see \#EXTRA_RECIPIENT_CONTACT_NAME
  ///@see \#METADATA_ACCOUNT_TYPE
  ///@see \#METADATA_MIMETYPE
  static const ACTION_VOICE_SEND_MESSAGE_TO_CONTACTS =
      "android.provider.action.VOICE_SEND_MESSAGE_TO_CONTACTS";

  /// from: static public final java.lang.String ATTACH_IMAGE
  ///
  /// Starts an Activity that lets the user pick a contact to attach an image to.
  /// After picking the contact it launches the image cropper in face detection mode.
  static const ATTACH_IMAGE = "com.android.contacts.action.ATTACH_IMAGE";

  /// from: static public final java.lang.String CONTACTS_DATABASE_CREATED
  ///
  /// This is the intent that is fired when the contacts database is created.  The
  /// READ_CONTACT permission is required to receive these broadcasts.
  ///
  /// Because this is an implicit broadcast, apps targeting Android O will no longer
  /// receive this broadcast via a manifest broadcast receiver.  (Broadcast receivers
  /// registered at runtime with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) will still receive it.)
  /// Instead, an app can use ProviderStatus\#DATABASE_CREATION_TIMESTAMP to see if the
  /// contacts database has been initialized when it starts.
  static const CONTACTS_DATABASE_CREATED =
      "android.provider.Contacts.DATABASE_CREATED";

  /// from: static public final java.lang.String EXTRA_CREATE_DESCRIPTION
  ///
  /// Used with \#SHOW_OR_CREATE_CONTACT to specify an exact
  /// description to be shown when prompting user about creating a new
  /// contact.
  ///
  /// Type: STRING
  static const EXTRA_CREATE_DESCRIPTION =
      "com.android.contacts.action.CREATE_DESCRIPTION";

  /// from: static public final java.lang.String EXTRA_FORCE_CREATE
  ///
  /// Used with \#SHOW_OR_CREATE_CONTACT to force creating a new
  /// contact if no matching contact found. Otherwise, default behavior is
  /// to prompt user with dialog before creating.
  ///
  /// Type: BOOLEAN
  static const EXTRA_FORCE_CREATE = "com.android.contacts.action.FORCE_CREATE";

  /// from: static public final java.lang.String EXTRA_RECIPIENT_CONTACT_CHAT_ID
  ///
  /// This extra specifies a messaging app\u2019s unique ID(s) for the contact(s), used with \#ACTION_VOICE_SEND_MESSAGE_TO_CONTACTS to supply the recipient(s). The value of this
  /// extra is a {@code String[]}. The number of elements in the array should be equal to
  /// number of recipients (and consistent with \#EXTRA_RECIPIENT_CONTACT_URI and \#EXTRA_RECIPIENT_CONTACT_NAME). When the value of the element for the particular
  /// recipient is absent, it will be set to null.
  ///
  /// The value of the elements comes from the DataColumns\#DATA1 column in Contacts
  /// Provider with DataColumns\#MIMETYPE from \#METADATA_MIMETYPE (if both
  /// \#METADATA_ACCOUNT_TYPE and \#METADATA_MIMETYPE are specified by the app;
  /// otherwise, the value will be a phone number), and should be the unambiguous contact
  /// endpoint. This value is app-specific, it could be some proprietary ID or a phone number.
  static const EXTRA_RECIPIENT_CONTACT_CHAT_ID =
      "android.provider.extra.RECIPIENT_CONTACT_CHAT_ID";

  /// from: static public final java.lang.String EXTRA_RECIPIENT_CONTACT_NAME
  ///
  /// This extra specifies the contact name (full name from the Contacts Provider), used with
  /// \#ACTION_VOICE_SEND_MESSAGE_TO_CONTACTS to supply the recipient. The value of this
  /// extra is a {@code String[]}. The number of elements in the array should be equal to
  /// number of recipients (and consistent with \#EXTRA_RECIPIENT_CONTACT_URI and \#EXTRA_RECIPIENT_CONTACT_CHAT_ID). When the value of the element for the particular
  /// recipient is absent, it will be set to null.
  ///
  /// The value of the elements comes from RawContact's display_name column.
  ///
  /// _Example value: {"Jane Doe"}_
  static const EXTRA_RECIPIENT_CONTACT_NAME =
      "android.provider.extra.RECIPIENT_CONTACT_NAME";

  /// from: static public final java.lang.String EXTRA_RECIPIENT_CONTACT_URI
  ///
  /// This extra specifies a content provider uri(s) for the contact(s) (if the contacts were
  /// located in the Contacts Provider), used with \#ACTION_VOICE_SEND_MESSAGE_TO_CONTACTS to supply the recipient(s). The value of this
  /// extra is a {@code String[]}. The number of elements in the array should be equal to
  /// number of recipients (and consistent with \#EXTRA_RECIPIENT_CONTACT_CHAT_ID and
  /// \#EXTRA_RECIPIENT_CONTACT_NAME). When the value of the element for the particular
  /// recipient is absent, it will be set to null.
  ///
  /// _Note: one contact may have multiple accounts (e.g. Chat IDs) on a specific messaging
  /// platform, so this may be ambiguous. E.g., one contact \u201cJohn Smith\u201d could have two
  /// accounts on the same messaging app._
  ///
  /// _Example value: {"content://com.android.contacts/contacts/16"}_
  static const EXTRA_RECIPIENT_CONTACT_URI =
      "android.provider.extra.RECIPIENT_CONTACT_URI";

  /// from: static public final java.lang.String INVITE_CONTACT
  ///
  /// This is the intent that is fired when the user clicks the "invite to the network" button
  /// on a contact.  Only sent to an activity which is explicitly registered by a contact
  /// provider which supports the "invite to the network" feature.
  ///
  /// Intent\#getData() contains the lookup URI for the contact.
  static const INVITE_CONTACT = "com.android.contacts.action.INVITE_CONTACT";

  /// from: static public final java.lang.String METADATA_ACCOUNT_TYPE
  ///
  /// A string associated with an \#ACTION_VOICE_SEND_MESSAGE_TO_CONTACTS activity
  /// describing RawContacts\#ACCOUNT_TYPE for the corresponding Contacts Provider
  /// implementation.
  static const METADATA_ACCOUNT_TYPE = "android.provider.account_type";

  /// from: static public final java.lang.String METADATA_MIMETYPE
  ///
  /// A string associated with an \#ACTION_VOICE_SEND_MESSAGE_TO_CONTACTS activity
  /// describing DataColumns\#MIMETYPE for the corresponding Contacts Provider
  /// implementation.
  static const METADATA_MIMETYPE = "android.provider.mimetype";

  /// from: static public final java.lang.String SEARCH_SUGGESTION_CLICKED
  ///
  /// This is the intent that is fired when a search suggestion is clicked on.
  static const SEARCH_SUGGESTION_CLICKED =
      "android.provider.Contacts.SEARCH_SUGGESTION_CLICKED";

  /// from: static public final java.lang.String SEARCH_SUGGESTION_CREATE_CONTACT_CLICKED
  ///
  /// This is the intent that is fired when a search suggestion for creating a contact
  /// is clicked on.
  static const SEARCH_SUGGESTION_CREATE_CONTACT_CLICKED =
      "android.provider.Contacts.SEARCH_SUGGESTION_CREATE_CONTACT_CLICKED";

  /// from: static public final java.lang.String SEARCH_SUGGESTION_DIAL_NUMBER_CLICKED
  ///
  /// This is the intent that is fired when a search suggestion for dialing a number
  /// is clicked on.
  static const SEARCH_SUGGESTION_DIAL_NUMBER_CLICKED =
      "android.provider.Contacts.SEARCH_SUGGESTION_DIAL_NUMBER_CLICKED";

  /// from: static public final java.lang.String SHOW_OR_CREATE_CONTACT
  ///
  /// Takes as input a data URI with a mailto: or tel: scheme. If a single
  /// contact exists with the given data it will be shown. If no contact
  /// exists, a dialog will ask the user if they want to create a new
  /// contact with the provided details filled in. If multiple contacts
  /// share the data the user will be prompted to pick which contact they
  /// want to view.
  ///
  /// For <code>mailto:</code> URIs, the scheme specific portion must be a
  /// raw email address, such as one built using
  /// Uri\#fromParts(String, String, String).
  ///
  /// For <code>tel:</code> URIs, the scheme specific portion is compared
  /// to existing numbers using the standard caller ID lookup algorithm.
  /// The number must be properly encoded, for example using
  /// Uri\#fromParts(String, String, String).
  ///
  /// Any extras from the Insert class will be passed along to the
  /// create activity if there are no contacts to show.
  ///
  /// Passing true for the \#EXTRA_FORCE_CREATE extra will skip
  /// prompting the user when the contact doesn't exist.
  static const SHOW_OR_CREATE_CONTACT =
      "com.android.contacts.action.SHOW_OR_CREATE_CONTACT";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_Intents()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.ContactsContract$Intents$Insert
///
/// Convenience class that contains string constants used
/// to create contact android.content.Intent Intents.
class ContactsContract_Intents_Insert extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$Intents\$Insert");
  ContactsContract_Intents_Insert.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION
  ///
  /// The action code to use when adding a contact
  static const ACTION = "android.intent.action.INSERT";

  /// from: static public final java.lang.String COMPANY
  ///
  /// The extra field for the contact company.
  /// <P>Type: String</P>
  static const COMPANY = "company";

  /// from: static public final java.lang.String DATA
  ///
  /// The extra field that allows the client to supply multiple rows of
  /// arbitrary data for a single contact created using the Intent\#ACTION_INSERT
  /// or edited using Intent\#ACTION_EDIT. It is an ArrayList of
  /// ContentValues, one per data row. Supplying this extra is
  /// similar to inserting multiple rows into the Data table,
  /// except the user gets a chance to see and edit them before saving.
  /// Each ContentValues object must have a value for Data\#MIMETYPE.
  /// If supplied values are not visible in the editor UI, they will be
  /// dropped.  Duplicate data will dropped.  Some fields
  /// like CommonDataKinds.Email\#TYPE Email.TYPE may be automatically
  /// adjusted to comply with the constraints of the specific account type.
  /// For example, an Exchange contact can only have one phone numbers of type Home,
  /// so the contact editor may choose a different type for this phone number to
  /// avoid dropping the valueable part of the row, which is the phone number.
  ///
  /// Example:
  /// <pre>
  ///  ArrayList&lt;ContentValues&gt; data = new ArrayList&lt;ContentValues&gt;();
  ///
  ///  ContentValues row1 = new ContentValues();
  ///  row1.put(Data.MIMETYPE, Organization.CONTENT_ITEM_TYPE);
  ///  row1.put(Organization.COMPANY, "Android");
  ///  data.add(row1);
  ///
  ///  ContentValues row2 = new ContentValues();
  ///  row2.put(Data.MIMETYPE, Email.CONTENT_ITEM_TYPE);
  ///  row2.put(Email.TYPE, Email.TYPE_CUSTOM);
  ///  row2.put(Email.LABEL, "Green Bot");
  ///  row2.put(Email.ADDRESS, "android@android.com");
  ///  data.add(row2);
  ///
  ///  Intent intent = new Intent(Intent.ACTION_INSERT, Contacts.CONTENT_URI);
  ///  intent.putParcelableArrayListExtra(Insert.DATA, data);
  ///
  ///  startActivity(intent);
  /// </pre>
  static const DATA = "data";

  /// from: static public final java.lang.String EMAIL
  ///
  /// The extra field for the contact email address.
  /// <P>Type: String</P>
  static const EMAIL = "email";

  /// from: static public final java.lang.String EMAIL_ISPRIMARY
  ///
  /// The extra field for the email isprimary flag.
  /// <P>Type: boolean</P>
  static const EMAIL_ISPRIMARY = "email_isprimary";

  /// from: static public final java.lang.String EMAIL_TYPE
  ///
  /// The extra field for the contact email type.
  /// <P>Type: Either an integer value from
  /// CommonDataKinds.Email
  ///  or a string specifying a custom label.</P>
  static const EMAIL_TYPE = "email_type";

  /// from: static public final java.lang.String EXTRA_ACCOUNT
  ///
  /// Used to specify the account in which to create the new contact.
  ///
  /// If this value is not provided, the user is presented with a disambiguation
  /// dialog to chose an account
  ///
  /// Type: Account
  static const EXTRA_ACCOUNT = "android.provider.extra.ACCOUNT";

  /// from: static public final java.lang.String EXTRA_DATA_SET
  ///
  /// Used to specify the data set within the account in which to create the
  /// new contact.
  ///
  /// This value is optional - if it is not specified, the contact will be
  /// created in the base account, with no data set.
  ///
  /// Type: String
  static const EXTRA_DATA_SET = "android.provider.extra.DATA_SET";

  /// from: static public final java.lang.String FULL_MODE
  ///
  /// If present, forces a bypass of quick insert mode.
  static const FULL_MODE = "full_mode";

  /// from: static public final java.lang.String IM_HANDLE
  ///
  /// The extra field for an IM handle.
  /// <P>Type: String</P>
  static const IM_HANDLE = "im_handle";

  /// from: static public final java.lang.String IM_ISPRIMARY
  ///
  /// The extra field for the IM isprimary flag.
  /// <P>Type: boolean</P>
  static const IM_ISPRIMARY = "im_isprimary";

  /// from: static public final java.lang.String IM_PROTOCOL
  ///
  /// The extra field for the IM protocol
  static const IM_PROTOCOL = "im_protocol";

  /// from: static public final java.lang.String JOB_TITLE
  ///
  /// The extra field for the contact job title.
  /// <P>Type: String</P>
  static const JOB_TITLE = "job_title";

  /// from: static public final java.lang.String NAME
  ///
  /// The extra field for the contact name.
  /// <P>Type: String</P>
  static const NAME = "name";

  /// from: static public final java.lang.String NOTES
  ///
  /// The extra field for the contact notes.
  /// <P>Type: String</P>
  static const NOTES = "notes";

  /// from: static public final java.lang.String PHONE
  ///
  /// The extra field for the contact phone number.
  /// <P>Type: String</P>
  static const PHONE = "phone";

  /// from: static public final java.lang.String PHONETIC_NAME
  ///
  /// The extra field for the contact phonetic name.
  /// <P>Type: String</P>
  static const PHONETIC_NAME = "phonetic_name";

  /// from: static public final java.lang.String PHONE_ISPRIMARY
  ///
  /// The extra field for the phone isprimary flag.
  /// <P>Type: boolean</P>
  static const PHONE_ISPRIMARY = "phone_isprimary";

  /// from: static public final java.lang.String PHONE_TYPE
  ///
  /// The extra field for the contact phone number type.
  /// <P>Type: Either an integer value from
  /// CommonDataKinds.Phone,
  ///  or a string specifying a custom label.</P>
  static const PHONE_TYPE = "phone_type";

  /// from: static public final java.lang.String POSTAL
  ///
  /// The extra field for the contact postal address.
  /// <P>Type: String</P>
  static const POSTAL = "postal";

  /// from: static public final java.lang.String POSTAL_ISPRIMARY
  ///
  /// The extra field for the postal isprimary flag.
  /// <P>Type: boolean</P>
  static const POSTAL_ISPRIMARY = "postal_isprimary";

  /// from: static public final java.lang.String POSTAL_TYPE
  ///
  /// The extra field for the contact postal address type.
  /// <P>Type: Either an integer value from
  /// CommonDataKinds.StructuredPostal
  ///  or a string specifying a custom label.</P>
  static const POSTAL_TYPE = "postal_type";

  /// from: static public final java.lang.String SECONDARY_EMAIL
  ///
  /// The extra field for an optional second contact email address.
  /// <P>Type: String</P>
  static const SECONDARY_EMAIL = "secondary_email";

  /// from: static public final java.lang.String SECONDARY_EMAIL_TYPE
  ///
  /// The extra field for an optional second contact email type.
  /// <P>Type: Either an integer value from
  /// CommonDataKinds.Email
  ///  or a string specifying a custom label.</P>
  static const SECONDARY_EMAIL_TYPE = "secondary_email_type";

  /// from: static public final java.lang.String SECONDARY_PHONE
  ///
  /// The extra field for an optional second contact phone number.
  /// <P>Type: String</P>
  static const SECONDARY_PHONE = "secondary_phone";

  /// from: static public final java.lang.String SECONDARY_PHONE_TYPE
  ///
  /// The extra field for an optional second contact phone number type.
  /// <P>Type: Either an integer value from
  /// CommonDataKinds.Phone,
  ///  or a string specifying a custom label.</P>
  static const SECONDARY_PHONE_TYPE = "secondary_phone_type";

  /// from: static public final java.lang.String TERTIARY_EMAIL
  ///
  /// The extra field for an optional third contact email address.
  /// <P>Type: String</P>
  static const TERTIARY_EMAIL = "tertiary_email";

  /// from: static public final java.lang.String TERTIARY_EMAIL_TYPE
  ///
  /// The extra field for an optional third contact email type.
  /// <P>Type: Either an integer value from
  /// CommonDataKinds.Email
  ///  or a string specifying a custom label.</P>
  static const TERTIARY_EMAIL_TYPE = "tertiary_email_type";

  /// from: static public final java.lang.String TERTIARY_PHONE
  ///
  /// The extra field for an optional third contact phone number.
  /// <P>Type: String</P>
  static const TERTIARY_PHONE = "tertiary_phone";

  /// from: static public final java.lang.String TERTIARY_PHONE_TYPE
  ///
  /// The extra field for an optional third contact phone number type.
  /// <P>Type: Either an integer value from
  /// CommonDataKinds.Phone,
  ///  or a string specifying a custom label.</P>
  static const TERTIARY_PHONE_TYPE = "tertiary_phone_type";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_Intents_Insert()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.ContactsContract$GroupsColumns
///
/// @see Groups
class ContactsContract_GroupsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$GroupsColumns");
  ContactsContract_GroupsColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String AUTO_ADD
  ///
  /// Any newly created contacts will automatically be added to groups that have this
  /// flag set to true.
  ///
  /// Type: INTEGER (boolean)
  static const AUTO_ADD = "auto_add";

  /// from: static public final java.lang.String DATA_SET
  ///
  /// The data set within the account that this group belongs to.  This allows
  /// multiple sync adapters for the same account type to distinguish between
  /// each others' group data.
  ///
  /// This is empty by default, and is completely optional.  It only needs to
  /// be populated if multiple sync adapters are entering distinct group data
  /// for the same account type and account name.
  /// <P>Type: TEXT</P>
  static const DATA_SET = "data_set";

  /// from: static public final java.lang.String DELETED
  ///
  /// The "deleted" flag: "0" by default, "1" if the row has been marked
  /// for deletion. When android.content.ContentResolver\#delete is
  /// called on a group, it is marked for deletion. The sync adaptor
  /// deletes the group on the server and then calls ContactResolver.delete
  /// once more, this time setting the the
  /// ContactsContract\#CALLER_IS_SYNCADAPTER query parameter to
  /// finalize the data removal.
  /// <P>Type: INTEGER</P>
  static const DELETED = "deleted";

  /// from: static public final java.lang.String FAVORITES
  ///
  /// When a contacts is marked as a favorites it will be automatically added
  /// to the groups that have this flag set, and when it is removed from favorites
  /// it will be removed from these groups.
  ///
  /// Type: INTEGER (boolean)
  static const FAVORITES = "favorites";

  /// from: static public final java.lang.String GROUP_IS_READ_ONLY
  ///
  /// The "read-only" flag: "0" by default, "1" if the row cannot be modified or
  /// deleted except by a sync adapter.  See ContactsContract\#CALLER_IS_SYNCADAPTER.
  /// <P>Type: INTEGER</P>
  static const GROUP_IS_READ_ONLY = "group_is_read_only";

  /// from: static public final java.lang.String GROUP_VISIBLE
  ///
  /// Flag indicating if the contacts belonging to this group should be
  /// visible in any user interface.
  ///
  /// Type: INTEGER (boolean)
  static const GROUP_VISIBLE = "group_visible";

  /// from: static public final java.lang.String NOTES
  ///
  /// Notes about the group.
  ///
  /// Type: TEXT
  static const NOTES = "notes";

  /// from: static public final java.lang.String RES_PACKAGE
  ///
  /// The package name to use when creating Resources objects for
  /// this group. This value is only designed for use when building user
  /// interfaces, and should not be used to infer the owner.
  static const RES_PACKAGE = "res_package";

  /// from: static public final java.lang.String SHOULD_SYNC
  ///
  /// Whether this group should be synced if the SYNC_EVERYTHING settings
  /// is false for this group's account.
  ///
  /// Type: INTEGER (boolean)
  static const SHOULD_SYNC = "should_sync";

  /// from: static public final java.lang.String SUMMARY_COUNT
  ///
  /// The total number of Contacts that have
  /// CommonDataKinds.GroupMembership in this group. Read-only value that is only
  /// present when querying Groups\#CONTENT_SUMMARY_URI.
  ///
  /// Type: INTEGER
  static const SUMMARY_COUNT = "summ_count";

  /// from: static public final java.lang.String SUMMARY_WITH_PHONES
  ///
  /// The total number of Contacts that have both
  /// CommonDataKinds.GroupMembership in this group, and also have phone numbers.
  /// Read-only value that is only present when querying
  /// Groups\#CONTENT_SUMMARY_URI.
  ///
  /// Type: INTEGER
  static const SUMMARY_WITH_PHONES = "summ_phones";

  /// from: static public final java.lang.String SYSTEM_ID
  ///
  /// The ID of this group if it is a System Group, i.e. a group that has a special meaning
  /// to the sync adapter, null otherwise.
  /// <P>Type: TEXT</P>
  static const SYSTEM_ID = "system_id";

  /// from: static public final java.lang.String TITLE
  ///
  /// The display title of this group.
  ///
  /// Type: TEXT
  static const TITLE = "title";

  /// from: static public final java.lang.String TITLE_RES
  ///
  /// The display title of this group to load as a resource from
  /// \#RES_PACKAGE, which may be localized.
  /// <P>Type: TEXT</P>
  static const TITLE_RES = "title_res";
}

/// from: android.provider.ContactsContract$Groups
///
/// Constants for the groups table. Only per-account groups are supported.
/// <h2>Columns</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Groups</th>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#_ID</td>
/// <td>read-only</td>
/// <td>Row ID. Sync adapter should try to preserve row IDs during updates.
/// In other words, it would be a really bad idea to delete and reinsert a
/// group. A sync adapter should always do an update instead.</td>
/// </tr>
/// \# <tr>
/// <td>String</td>
/// <td>\#DATA_SET</td>
/// <td>read/write-once</td>
/// <td>
///
/// The data set within the account that this group belongs to.  This allows
/// multiple sync adapters for the same account type to distinguish between
/// each others' group data.  The combination of \#ACCOUNT_TYPE,
/// \#ACCOUNT_NAME, and \#DATA_SET identifies a set of data
/// that is associated with a single sync adapter.
///
///
///
/// This is empty by default, and is completely optional.  It only needs to
/// be populated if multiple sync adapters are entering distinct data for
/// the same account type and account name.
///
///
///
/// It should be set at the time the group is inserted and never changed
/// afterwards.
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#TITLE</td>
/// <td>read/write</td>
/// <td>The display title of this group.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#NOTES</td>
/// <td>read/write</td>
/// <td>Notes about the group.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SYSTEM_ID</td>
/// <td>read/write</td>
/// <td>The ID of this group if it is a System Group, i.e. a group that has a
/// special meaning to the sync adapter, null otherwise.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#SUMMARY_COUNT</td>
/// <td>read-only</td>
/// <td>The total number of Contacts that have
/// CommonDataKinds.GroupMembership in this group. Read-only value
/// that is only present when querying Groups\#CONTENT_SUMMARY_URI.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#SUMMARY_WITH_PHONES</td>
/// <td>read-only</td>
/// <td>The total number of Contacts that have both
/// CommonDataKinds.GroupMembership in this group, and also have
/// phone numbers. Read-only value that is only present when querying
/// Groups\#CONTENT_SUMMARY_URI.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#GROUP_VISIBLE</td>
/// <td>read-only</td>
/// <td>Flag indicating if the contacts belonging to this group should be
/// visible in any user interface. Allowed values: 0 and 1.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#DELETED</td>
/// <td>read/write</td>
/// <td>The "deleted" flag: "0" by default, "1" if the row has been marked
/// for deletion. When android.content.ContentResolver\#delete is
/// called on a group, it is marked for deletion. The sync adaptor deletes
/// the group on the server and then calls ContactResolver.delete once more,
/// this time setting the the ContactsContract\#CALLER_IS_SYNCADAPTER
/// query parameter to finalize the data removal.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#SHOULD_SYNC</td>
/// <td>read/write</td>
/// <td>Whether this group should be synced if the SYNC_EVERYTHING settings
/// is false for this group's account.</td>
/// </tr>
/// </table>
class ContactsContract_Groups extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$Groups");
  ContactsContract_Groups.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME type of a single group.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/group";

  static final _id_CONTENT_SUMMARY_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_SUMMARY_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_SUMMARY_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table joined with details data from
  /// ContactsContract.Data.
  static uri_.Uri get CONTENT_SUMMARY_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_SUMMARY_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of a directory of groups.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/group";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_newEntityIterator = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newEntityIterator",
      "(Landroid/database/Cursor;)Landroid/content/EntityIterator;");

  /// from: static public android.content.EntityIterator newEntityIterator(android.database.Cursor cursor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static entityiterator_.EntityIterator newEntityIterator(
          cursor_.Cursor cursor) =>
      entityiterator_.EntityIterator.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_newEntityIterator,
              jni.JniType.objectType, [cursor.reference]).object);
}

/// from: android.provider.ContactsContract$FullNameStyle
///
/// Constants for various styles of combining given name, family name etc into
/// a full name.  For example, the western tradition follows the pattern
/// 'given name' 'middle name' 'family name' with the alternative pattern being
/// 'family name', 'given name' 'middle name'.  The CJK tradition is
/// 'family name' 'middle name' 'given name', with Japanese favoring a space between
/// the names and Chinese omitting the space.
class ContactsContract_FullNameStyle extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$FullNameStyle");
  ContactsContract_FullNameStyle.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CHINESE
  static const CHINESE = 3;

  /// from: static public final int CJK
  ///
  /// Used if the name is written in Hanzi/Kanji/Hanja and we could not determine
  /// which specific language it belongs to: Chinese, Japanese or Korean.
  static const CJK = 2;

  /// from: static public final int JAPANESE
  static const JAPANESE = 4;

  /// from: static public final int KOREAN
  static const KOREAN = 5;

  /// from: static public final int UNDEFINED
  static const UNDEFINED = 0;

  /// from: static public final int WESTERN
  static const WESTERN = 1;
}

/// from: android.provider.ContactsContract$DisplayPhoto
///
/// Helper class for accessing full-size photos by photo file ID.
///
/// Usage example:
/// <dl>
/// <dt>Retrieving a full-size photo by photo file ID (see
/// ContactsContract.ContactsColumns\#PHOTO_FILE_ID)
/// </dt>
/// <dd>
/// <pre>
/// public InputStream openDisplayPhoto(long photoFileId) {
///     Uri displayPhotoUri = ContentUris.withAppendedId(DisplayPhoto.CONTENT_URI, photoKey);
///     try {
///         AssetFileDescriptor fd = getContentResolver().openAssetFileDescriptor(
///             displayPhotoUri, "r");
///         return fd.createInputStream();
///     } catch (IOException e) {
///         return null;
///     }
/// }
/// </pre>
/// </dd>
/// </dl>
///
///
class ContactsContract_DisplayPhoto extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$DisplayPhoto");
  ContactsContract_DisplayPhoto.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_MAX_DIMENSIONS_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_MAX_DIMENSIONS_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_MAX_DIMENSIONS_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This URI allows the caller to query for the maximum dimensions of a display photo
  /// or thumbnail.  Requests to this URI can be performed on the UI thread because
  /// they are always unblocking.
  static uri_.Uri get CONTENT_MAX_DIMENSIONS_URI =>
      uri_.Uri.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTENT_MAX_DIMENSIONS_URI, jni.JniType.objectType)
          .object);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this class, which allows access to full-size photos,
  /// given a key.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DISPLAY_MAX_DIM
  ///
  /// Queries to ContactsContract.DisplayPhoto\#CONTENT_MAX_DIMENSIONS_URI will
  /// contain this column, populated with the maximum height and width (in pixels)
  /// that will be stored for a display photo.  Larger photos will be down-sized to
  /// fit within a square of this many pixels.
  static const DISPLAY_MAX_DIM = "display_max_dim";

  /// from: static public final java.lang.String THUMBNAIL_MAX_DIM
  ///
  /// Queries to ContactsContract.DisplayPhoto\#CONTENT_MAX_DIMENSIONS_URI will
  /// contain this column, populated with the height and width (in pixels) for photo
  /// thumbnails.
  static const THUMBNAIL_MAX_DIM = "thumbnail_max_dim";
}

/// from: android.provider.ContactsContract$DisplayNameSources
///
/// Types of data used to produce the display name for a contact. In the order
/// of increasing priority: \#EMAIL, \#PHONE,
/// \#ORGANIZATION, \#NICKNAME, \#STRUCTURED_PHONETIC_NAME,
/// \#STRUCTURED_NAME.
class ContactsContract_DisplayNameSources extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$DisplayNameSources");
  ContactsContract_DisplayNameSources.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int EMAIL
  static const EMAIL = 10;

  /// from: static public final int NICKNAME
  static const NICKNAME = 35;

  /// from: static public final int ORGANIZATION
  static const ORGANIZATION = 30;

  /// from: static public final int PHONE
  static const PHONE = 20;

  /// from: static public final int STRUCTURED_NAME
  static const STRUCTURED_NAME = 40;

  /// from: static public final int STRUCTURED_PHONETIC_NAME
  ///
  /// Display name comes from a structured name that only has phonetic components.
  static const STRUCTURED_PHONETIC_NAME = 37;

  /// from: static public final int UNDEFINED
  static const UNDEFINED = 0;
}

/// from: android.provider.ContactsContract$Directory
///
/// A Directory represents a contacts corpus, e.g.&nbsp;Local contacts,
/// Google Apps Global Address List or Corporate Global Address List.
///
/// A Directory is implemented as a content provider with its unique authority and
/// the same API as the main Contacts Provider.  However, there is no expectation that
/// every directory provider will implement this Contract in its entirety.  If a
/// directory provider does not have an implementation for a specific request, it
/// should throw an UnsupportedOperationException.
///
///
///
/// The most important use case for Directories is search.  A Directory provider is
/// expected to support at least ContactsContract.Contacts\#CONTENT_FILTER_URI Contacts.CONTENT_FILTER_URI.  If a Directory provider wants to participate
/// in email and phone lookup functionalities, it should also implement
/// CommonDataKinds.Email\#CONTENT_FILTER_URI CommonDataKinds.Email.CONTENT_FILTER_URI
/// and
/// CommonDataKinds.Phone\#CONTENT_FILTER_URI CommonDataKinds.Phone.CONTENT_FILTER_URI.
///
///
///
/// A directory provider should return NULL for every projection field it does not
/// recognize, rather than throwing an exception.  This way it will not be broken
/// if ContactsContract is extended with new fields in the future.
///
///
///
/// The client interacts with a directory via Contacts Provider by supplying an
/// optional {@code directory=} query parameter.
///
///
/// When the Contacts Provider receives the request, it transforms the URI and forwards
/// the request to the corresponding directory content provider.
/// The URI is transformed in the following fashion:
/// <ul>
/// <li>The URI authority is replaced with the corresponding \#DIRECTORY_AUTHORITY.</li>
/// <li>The {@code accountName=} and {@code accountType=} parameters are added or
/// replaced using the corresponding \#ACCOUNT_TYPE and \#ACCOUNT_NAME values.</li>
/// </ul>
///
///
///
/// Clients should send directory requests to Contacts Provider and let it
/// forward them to the respective providers rather than constructing
/// directory provider URIs by themselves. This level of indirection allows
/// Contacts Provider to implement additional system-level features and
/// optimizations. Access to Contacts Provider is protected by the
/// READ_CONTACTS permission, but access to the directory provider is protected by
/// BIND_DIRECTORY_SEARCH. This permission was introduced at the API level 17, for previous
/// platform versions the provider should perform the following check to make sure the call
/// is coming from the ContactsProvider:
/// <pre>
/// private boolean isCallerAllowed() {
///   PackageManager pm = getContext().getPackageManager();
///   for (String packageName: pm.getPackagesForUid(Binder.getCallingUid())) {
///     if (packageName.equals("com.android.providers.contacts")) {
///       return true;
///     }
///   }
///   return false;
/// }
/// </pre>
///
///
///
/// The Directory table is read-only and is maintained by the Contacts Provider
/// automatically.
///
///
/// It always has at least these two rows:
/// <ul>
/// <li>
/// The local directory. It has Directory\#_ID Directory._ID =
/// Directory\#DEFAULT Directory.DEFAULT. This directory can be used to access locally
/// stored contacts. The same can be achieved by omitting the {@code directory=}
/// parameter altogether.
/// </li>
/// <li>
/// The local invisible contacts. The corresponding directory ID is
/// Directory\#LOCAL_INVISIBLE Directory.LOCAL_INVISIBLE.
/// </li>
/// </ul>
///
///
/// Custom Directories are discovered by the Contacts Provider following this procedure:
/// <ul>
/// <li>It finds all installed content providers with meta data identifying them
/// as directory providers in AndroidManifest.xml:
/// <code>
/// &lt;meta-data android:name="android.content.ContactDirectory"
///               android:value="true" /&gt;
/// </code>
///
/// This tag should be placed inside the corresponding content provider declaration.
///
///
/// </li>
/// <li>
/// Then Contacts Provider sends a Directory\#CONTENT_URI Directory.CONTENT_URI
/// query to each of the directory authorities.  A directory provider must implement
/// this query and return a list of directories.  Each directory returned by
/// the provider must have a unique combination for the \#ACCOUNT_NAME and
/// \#ACCOUNT_TYPE columns (nulls are allowed).  Since directory IDs are assigned
/// automatically, the _ID field will not be part of the query projection.
/// </li>
/// <li>Contacts Provider compiles directory lists received from all directory
/// providers into one, assigns each individual directory a globally unique ID and
/// stores all directory records in the Directory table.
/// </li>
/// </ul>
///
///
/// Contacts Provider automatically interrogates newly installed or replaced packages.
/// Thus simply installing a package containing a directory provider is sufficient
/// to have that provider registered.  A package supplying a directory provider does
/// not have to contain launchable activities.
///
///
///
/// Every row in the Directory table is automatically associated with the corresponding package
/// (apk).  If the package is later uninstalled, all corresponding directory rows
/// are automatically removed from the Contacts Provider.
///
///
///
/// When the list of directories handled by a directory provider changes
/// (for instance when the user adds a new Directory account), the directory provider
/// should call \#notifyDirectoryChange to notify the Contacts Provider of the change.
/// In response, the Contacts Provider will requery the directory provider to obtain the
/// new list of directories.
///
///
///
/// A directory row can be optionally associated with an existing account
/// (see android.accounts.AccountManager). If the account is later removed,
/// the corresponding directory rows are automatically removed from the Contacts Provider.
///
///
class ContactsContract_Directory extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$Directory");
  ContactsContract_Directory.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACCOUNT_NAME
  ///
  /// The account with which this directory is associated. If the account is later
  /// removed, the directories it owns are automatically removed from this table.
  ///
  /// TYPE: text
  ///
  static const ACCOUNT_NAME = "accountName";

  /// from: static public final java.lang.String ACCOUNT_TYPE
  ///
  /// The account type which this directory is associated.
  ///
  /// TYPE: text
  ///
  static const ACCOUNT_TYPE = "accountType";

  /// from: static public final java.lang.String CALLER_PACKAGE_PARAM_KEY
  ///
  /// A query parameter that's passed to directory providers which indicates the client
  /// package name that has made the query requests.
  static const CALLER_PACKAGE_PARAM_KEY = "callerPackage";

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME type of a \#CONTENT_URI item.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/contact_directory";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME-type of \#CONTENT_URI providing a directory of
  /// contact directories.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/contact_directories";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table.  Requests to this URI can be
  /// performed on the UI thread because they are always unblocking.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final long DEFAULT
  ///
  /// _ID of the default directory, which represents locally stored contacts.
  /// __This is only supported by ContactsContract.Contacts\#CONTENT_URI and
  /// ContactsContract.Contacts\#CONTENT_FILTER_URI.
  /// Other URLs do not support the concept of "visible" or "invisible" contacts.
  static const DEFAULT = 0;

  /// from: static public final java.lang.String DIRECTORY_AUTHORITY
  ///
  ///
  /// The authority of the Directory Provider. Contacts Provider will
  /// use this authority to forward requests to the directory provider.
  /// A directory provider can leave this column empty - Contacts Provider will fill it in.
  ///
  ///
  ///
  /// Clients of this API should not send requests directly to this authority.
  /// All directory requests must be routed through Contacts Provider.
  ///
  ///
  ///
  /// TYPE: text
  ///
  static const DIRECTORY_AUTHORITY = "authority";

  /// from: static public final java.lang.String DISPLAY_NAME
  ///
  /// An optional name that can be used in the UI to represent this directory,
  /// e.g.&nbsp;"Acme Corp"
  /// TYPE: text
  ///
  static const DISPLAY_NAME = "displayName";

  static final _id_ENTERPRISE_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "ENTERPRISE_CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri ENTERPRISE_CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// URI used for getting all directories from primary and managed profile.
  /// It supports the same semantics as \#CONTENT_URI and returns the same columns.
  /// If the device has no managed profile that is linked to the current profile, it behaves
  /// in the exact same way as \#CONTENT_URI.
  /// If there is a managed profile linked to the current profile, it will merge
  /// managed profile and current profile's results and return.
  ///
  /// Note: this query returns primary profile results before managed profile results,
  /// and this order is not affected by sorting parameter.
  static uri_.Uri get ENTERPRISE_CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_ENTERPRISE_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final long ENTERPRISE_DEFAULT
  ///
  /// _ID of the work profile default directory, which represents locally stored contacts.
  static const ENTERPRISE_DEFAULT = 1000000000;

  /// from: static public final long ENTERPRISE_LOCAL_INVISIBLE
  ///
  /// _ID of the work profile directory that represents locally stored invisible contacts.
  static const ENTERPRISE_LOCAL_INVISIBLE = 1000000001;

  /// from: static public final java.lang.String EXPORT_SUPPORT
  ///
  /// One of \#EXPORT_SUPPORT_NONE, \#EXPORT_SUPPORT_ANY_ACCOUNT,
  /// \#EXPORT_SUPPORT_SAME_ACCOUNT_ONLY. This is the expectation the
  /// directory has for data exported from it.  Clients must obey this setting.
  static const EXPORT_SUPPORT = "exportSupport";

  /// from: static public final int EXPORT_SUPPORT_ANY_ACCOUNT
  ///
  /// An \#EXPORT_SUPPORT setting that indicates that the directory
  /// allow its data copied to any contacts account.
  static const EXPORT_SUPPORT_ANY_ACCOUNT = 2;

  /// from: static public final int EXPORT_SUPPORT_NONE
  ///
  /// An \#EXPORT_SUPPORT setting that indicates that the directory
  /// does not allow any data to be copied out of it.
  static const EXPORT_SUPPORT_NONE = 0;

  /// from: static public final int EXPORT_SUPPORT_SAME_ACCOUNT_ONLY
  ///
  /// An \#EXPORT_SUPPORT setting that indicates that the directory
  /// allow its data copied only to the account specified by
  /// \#ACCOUNT_TYPE/\#ACCOUNT_NAME.
  static const EXPORT_SUPPORT_SAME_ACCOUNT_ONLY = 1;

  /// from: static public final long LOCAL_INVISIBLE
  ///
  /// _ID of the directory that represents locally stored invisible contacts.
  static const LOCAL_INVISIBLE = 1;

  /// from: static public final java.lang.String PACKAGE_NAME
  ///
  /// The name of the package that owns this directory. Contacts Provider
  /// fill it in with the name of the package containing the directory provider.
  /// If the package is later uninstalled, the directories it owns are
  /// automatically removed from this table.
  ///
  /// TYPE: TEXT
  ///
  static const PACKAGE_NAME = "packageName";

  /// from: static public final java.lang.String PHOTO_SUPPORT
  ///
  /// One of \#PHOTO_SUPPORT_NONE, \#PHOTO_SUPPORT_THUMBNAIL_ONLY,
  /// \#PHOTO_SUPPORT_FULL. This is a feature flag indicating the extent
  /// to which the directory supports contact photos.
  static const PHOTO_SUPPORT = "photoSupport";

  /// from: static public final int PHOTO_SUPPORT_FULL
  ///
  /// An \#PHOTO_SUPPORT setting that indicates that the directory
  /// can produce thumbnails as well as full-size contact photos.
  static const PHOTO_SUPPORT_FULL = 3;

  /// from: static public final int PHOTO_SUPPORT_FULL_SIZE_ONLY
  ///
  /// An \#PHOTO_SUPPORT setting that indicates that the directory
  /// has full-size contact photos, but cannot provide scaled thumbnails.
  static const PHOTO_SUPPORT_FULL_SIZE_ONLY = 2;

  /// from: static public final int PHOTO_SUPPORT_NONE
  ///
  /// An \#PHOTO_SUPPORT setting that indicates that the directory
  /// does not provide any photos.
  static const PHOTO_SUPPORT_NONE = 0;

  /// from: static public final int PHOTO_SUPPORT_THUMBNAIL_ONLY
  ///
  /// An \#PHOTO_SUPPORT setting that indicates that the directory
  /// can only produce small size thumbnails of contact photos.
  static const PHOTO_SUPPORT_THUMBNAIL_ONLY = 1;

  /// from: static public final java.lang.String SHORTCUT_SUPPORT
  ///
  /// One of \#SHORTCUT_SUPPORT_NONE, \#SHORTCUT_SUPPORT_DATA_ITEMS_ONLY,
  /// \#SHORTCUT_SUPPORT_FULL. This is the expectation the directory
  /// has for shortcuts created for its elements. Clients must obey this setting.
  static const SHORTCUT_SUPPORT = "shortcutSupport";

  /// from: static public final int SHORTCUT_SUPPORT_DATA_ITEMS_ONLY
  ///
  /// An \#SHORTCUT_SUPPORT setting that indicates that the directory
  /// allow creation of shortcuts for data items like email, phone or postal address,
  /// but not the entire contact.
  static const SHORTCUT_SUPPORT_DATA_ITEMS_ONLY = 1;

  /// from: static public final int SHORTCUT_SUPPORT_FULL
  ///
  /// An \#SHORTCUT_SUPPORT setting that indicates that the directory
  /// allow creation of shortcuts for contact as well as their constituent elements.
  static const SHORTCUT_SUPPORT_FULL = 2;

  /// from: static public final int SHORTCUT_SUPPORT_NONE
  ///
  /// An \#SHORTCUT_SUPPORT setting that indicates that the directory
  /// does not allow any shortcuts created for its contacts.
  static const SHORTCUT_SUPPORT_NONE = 0;

  /// from: static public final java.lang.String TYPE_RESOURCE_ID
  ///
  /// The type of directory captured as a resource ID in the context of the
  /// package \#PACKAGE_NAME, e.g.&nbsp;"Corporate Directory"
  ///
  /// TYPE: INTEGER
  ///
  static const TYPE_RESOURCE_ID = "typeResourceId";

  static final _id_isRemoteDirectoryId = jniAccessors.getStaticMethodIDOf(
      _classRef, "isRemoteDirectoryId", "(J)Z");

  /// from: static public boolean isRemoteDirectoryId(long directoryId)
  ///
  /// Return TRUE if it is a remote stored directory.
  static bool isRemoteDirectoryId(int directoryId) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isRemoteDirectoryId,
          jni.JniType.booleanType, [directoryId]).boolean;

  static final _id_isEnterpriseDirectoryId = jniAccessors.getStaticMethodIDOf(
      _classRef, "isEnterpriseDirectoryId", "(J)Z");

  /// from: static public boolean isEnterpriseDirectoryId(long directoryId)
  ///
  /// Return TRUE if a directory ID is from the contacts provider on the enterprise profile.
  static bool isEnterpriseDirectoryId(int directoryId) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isEnterpriseDirectoryId,
          jni.JniType.booleanType,
          [directoryId]).boolean;

  static final _id_notifyDirectoryChange = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "notifyDirectoryChange",
      "(Landroid/content/ContentResolver;)V");

  /// from: static public void notifyDirectoryChange(android.content.ContentResolver resolver)
  ///
  /// Notifies the system of a change in the list of directories handled by
  /// a particular directory provider. The Contacts provider will turn around
  /// and send a query to the directory provider for the full list of directories,
  /// which will replace the previous list.
  static void notifyDirectoryChange(
          contentresolver_.ContentResolver resolver) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_notifyDirectoryChange,
          jni.JniType.voidType,
          [resolver.reference]).check();
}

/// from: android.provider.ContactsContract$DeletedContactsColumns
class ContactsContract_DeletedContactsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$DeletedContactsColumns");
  ContactsContract_DeletedContactsColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTACT_DELETED_TIMESTAMP
  ///
  /// Time (milliseconds since epoch) that the contact was deleted.
  static const CONTACT_DELETED_TIMESTAMP = "contact_deleted_timestamp";

  /// from: static public final java.lang.String CONTACT_ID
  ///
  /// A reference to the ContactsContract.Contacts\#_ID that was deleted.
  /// <P>Type: INTEGER</P>
  static const CONTACT_ID = "contact_id";
}

/// from: android.provider.ContactsContract$DeletedContacts
///
/// Constants for the deleted contact table.  This table holds a log of deleted contacts.
///
/// Log older than \#DAYS_KEPT_MILLISECONDS may be deleted.
class ContactsContract_DeletedContacts extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$DeletedContacts");
  ContactsContract_DeletedContacts.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table, which requests a directory of raw contact rows
  /// matching the selection criteria.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final long DAYS_KEPT_MILLISECONDS
  ///
  /// Milliseconds that the delete log will be kept.  After this time, delete records may be
  /// deleted.
  static const DAYS_KEPT_MILLISECONDS = 2592000000;
}

/// from: android.provider.ContactsContract$DataUsageStatColumns
///
/// Columns in the Data_Usage_Stat table
class ContactsContract_DataUsageStatColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$DataUsageStatColumns");
  ContactsContract_DataUsageStatColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String LAST_TIME_USED
  ///
  /// The last time (in milliseconds) this Data was used.
  static const LAST_TIME_USED = "last_time_used";

  /// from: static public final java.lang.String TIMES_USED
  ///
  /// The number of times the referenced Data has been used.
  static const TIMES_USED = "times_used";
}

/// from: android.provider.ContactsContract$DataUsageFeedback
///
///
/// API allowing applications to send usage information for each Data row to the
/// Contacts Provider.  Applications can also clear all usage information.
///
///
///
/// With the feedback, Contacts Provider may return more contextually appropriate results for
/// Data listing, typically supplied with
/// ContactsContract.Contacts\#CONTENT_FILTER_URI,
/// ContactsContract.CommonDataKinds.Email\#CONTENT_FILTER_URI,
/// ContactsContract.CommonDataKinds.Phone\#CONTENT_FILTER_URI, and users can benefit
/// from better ranked (sorted) lists in applications that show auto-complete list.
///
///
///
/// There is no guarantee for how this feedback is used, or even whether it is used at all.
/// The ranking algorithm will make best efforts to use the feedback data, but the exact
/// implementation, the storage data structures as well as the resulting sort order is device
/// and version specific and can change over time.
///
///
///
/// When updating usage information, users of this API need to use
/// ContentResolver\#update(Uri, ContentValues, String, String[]) with a Uri constructed
/// from DataUsageFeedback\#FEEDBACK_URI. The Uri must contain one or more data id(s) as
/// its last path. They also need to append a query parameter to the Uri, to specify the type of
/// the communication, which enables the Contacts Provider to differentiate between kinds of
/// interactions using the same contact data field (for example a phone number can be used to
/// make phone calls or send SMS).
///
///
///
/// Selection and selectionArgs are ignored and must be set to null. To get data ids,
/// you may need to call ContentResolver\#query(Uri, String[], String, String[], String)
/// toward Data\#CONTENT_URI.
///
///
///
/// ContentResolver\#update(Uri, ContentValues, String, String[]) returns a positive
/// integer when successful, and returns 0 if no contact with that id was found.
///
///
///
/// Example:
/// <pre>
/// Uri uri = DataUsageFeedback.FEEDBACK_URI.buildUpon()
///         .appendPath(TextUtils.join(",", dataIds))
///         .appendQueryParameter(DataUsageFeedback.USAGE_TYPE,
///                 DataUsageFeedback.USAGE_TYPE_CALL)
///         .build();
/// boolean successful = resolver.update(uri, new ContentValues(), null, null) > 0;
/// </pre>
///
///
///
/// Applications can also clear all usage information with:
/// <pre>
/// boolean successful = resolver.delete(DataUsageFeedback.DELETE_USAGE_URI, null, null) > 0;
/// </pre>
///
///
class ContactsContract_DataUsageFeedback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$DataUsageFeedback");
  ContactsContract_DataUsageFeedback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_DELETE_USAGE_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "DELETE_USAGE_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri DELETE_USAGE_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for deleting all usage information.
  /// Must be used with ContentResolver\#delete(Uri, String, String[]).
  /// The {@code where} and {@code selectionArgs} parameters are ignored.
  static uri_.Uri get DELETE_USAGE_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_DELETE_USAGE_URI, jni.JniType.objectType)
      .object);

  static final _id_FEEDBACK_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "FEEDBACK_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri FEEDBACK_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for sending usage feedback.
  /// Must be used with ContentResolver\#update(Uri, ContentValues, String, String[]).
  static uri_.Uri get FEEDBACK_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_FEEDBACK_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String USAGE_TYPE
  ///
  ///
  /// Name for query parameter specifying the type of data usage.
  ///
  ///
  static const USAGE_TYPE = "type";

  /// from: static public final java.lang.String USAGE_TYPE_CALL
  ///
  ///
  /// Type of usage for voice interaction, which includes phone call, voice chat, and
  /// video chat.
  ///
  ///
  static const USAGE_TYPE_CALL = "call";

  /// from: static public final java.lang.String USAGE_TYPE_LONG_TEXT
  ///
  ///
  /// Type of usage for text interaction involving longer messages, which includes email.
  ///
  ///
  static const USAGE_TYPE_LONG_TEXT = "long_text";

  /// from: static public final java.lang.String USAGE_TYPE_SHORT_TEXT
  ///
  ///
  /// Type of usage for text interaction involving shorter messages, which includes SMS,
  /// text chat with email addresses.
  ///
  ///
  static const USAGE_TYPE_SHORT_TEXT = "short_text";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_DataUsageFeedback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.ContactsContract$DataColumnsWithJoins
///
/// Combines all columns returned by ContactsContract.Data table queries.
///@see ContactsContract.Data
class ContactsContract_DataColumnsWithJoins extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$DataColumnsWithJoins");
  ContactsContract_DataColumnsWithJoins.fromRef(jni.JObject ref)
      : super.fromRef(ref);
}

/// from: android.provider.ContactsContract$DataColumns
///
/// Columns in the Data table.
///@see ContactsContract.Data
class ContactsContract_DataColumns extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$DataColumns");
  ContactsContract_DataColumns.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CARRIER_PRESENCE
  ///
  /// Carrier presence information.
  /// <P>
  /// Type: INTEGER (A bitmask of CARRIER_PRESENCE_* fields)
  /// </P>
  static const CARRIER_PRESENCE = "carrier_presence";

  /// from: static public final int CARRIER_PRESENCE_VT_CAPABLE
  ///
  /// Indicates that the entry is Video Telephony (VT) capable on the
  /// current carrier. An allowed bitmask of \#CARRIER_PRESENCE.
  static const CARRIER_PRESENCE_VT_CAPABLE = 1;

  /// from: static public final java.lang.String DATA1
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA1 = "data1";

  /// from: static public final java.lang.String DATA10
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA10 = "data10";

  /// from: static public final java.lang.String DATA11
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA11 = "data11";

  /// from: static public final java.lang.String DATA12
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA12 = "data12";

  /// from: static public final java.lang.String DATA13
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA13 = "data13";

  /// from: static public final java.lang.String DATA14
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA14 = "data14";

  /// from: static public final java.lang.String DATA15
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific. By convention,
  /// this field is used to store BLOBs (binary data).
  static const DATA15 = "data15";

  /// from: static public final java.lang.String DATA2
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA2 = "data2";

  /// from: static public final java.lang.String DATA3
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA3 = "data3";

  /// from: static public final java.lang.String DATA4
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA4 = "data4";

  /// from: static public final java.lang.String DATA5
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA5 = "data5";

  /// from: static public final java.lang.String DATA6
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA6 = "data6";

  /// from: static public final java.lang.String DATA7
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA7 = "data7";

  /// from: static public final java.lang.String DATA8
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA8 = "data8";

  /// from: static public final java.lang.String DATA9
  ///
  /// Generic data column, the meaning is \#MIMETYPE specific
  static const DATA9 = "data9";

  /// from: static public final java.lang.String DATA_VERSION
  ///
  /// The version of this data record. This is a read-only value. The data column is
  /// guaranteed to not change without the version going up. This value is monotonically
  /// increasing.
  /// <P>Type: INTEGER</P>
  static const DATA_VERSION = "data_version";

  /// from: static public final java.lang.String IS_PRIMARY
  ///
  /// Whether this is the primary entry of its kind for the raw contact it belongs to.
  /// <P>Type: INTEGER (if set, non-0 means true)</P>
  static const IS_PRIMARY = "is_primary";

  /// from: static public final java.lang.String IS_READ_ONLY
  ///
  /// The "read-only" flag: "0" by default, "1" if the row cannot be modified or
  /// deleted except by a sync adapter.  See ContactsContract\#CALLER_IS_SYNCADAPTER.
  /// <P>Type: INTEGER</P>
  static const IS_READ_ONLY = "is_read_only";

  /// from: static public final java.lang.String IS_SUPER_PRIMARY
  ///
  /// Whether this is the primary entry of its kind for the aggregate
  /// contact it belongs to. Any data record that is "super primary" must
  /// also be "primary".
  /// <P>Type: INTEGER (if set, non-0 means true)</P>
  static const IS_SUPER_PRIMARY = "is_super_primary";

  /// from: static public final java.lang.String MIMETYPE
  ///
  /// The MIME type of the item represented by this row.
  static const MIMETYPE = "mimetype";

  /// from: static public final java.lang.String PREFERRED_PHONE_ACCOUNT_COMPONENT_NAME
  ///
  /// The flattened android.content.ComponentName of a  android.telecom.PhoneAccountHandle that is the preferred {@code PhoneAccountHandle} to
  /// call the contact with.
  ///
  ///  On a multi-SIM device this field can be used in a CommonDataKinds.Phone row
  /// to indicate the PhoneAccountHandle to call the number with, instead of using
  /// android.telecom.TelecomManager\#getDefaultOutgoingPhoneAccount(String) or asking
  /// every time.
  ///
  /// android.telecom.TelecomManager\#placeCall(Uri, android.os.Bundle)
  /// should be called with android.telecom.TelecomManager\#EXTRA_PHONE_ACCOUNT_HANDLE
  /// set to the PhoneAccountHandle using the ComponentName from this field.
  ///@see \#PREFERRED_PHONE_ACCOUNT_ID
  ///@see PhoneAccountHandle\#getComponentName()
  ///@see ComponentName\#flattenToString()
  static const PREFERRED_PHONE_ACCOUNT_COMPONENT_NAME =
      "preferred_phone_account_component_name";

  /// from: static public final java.lang.String PREFERRED_PHONE_ACCOUNT_ID
  ///
  /// The ID of a android.telecom.PhoneAccountHandle that is the preferred {@code PhoneAccountHandle} to
  /// call the contact with. Used by CommonDataKinds.Phone.
  ///
  ///  On a multi-SIM device this field can be used in a CommonDataKinds.Phone row
  /// to indicate the PhoneAccountHandle to call the number with, instead of using
  /// android.telecom.TelecomManager\#getDefaultOutgoingPhoneAccount(String) or asking
  /// every time.
  ///
  /// android.telecom.TelecomManager\#placeCall(Uri, android.os.Bundle)
  /// should be called with android.telecom.TelecomManager\#EXTRA_PHONE_ACCOUNT_HANDLE
  /// set to the PhoneAccountHandle using the id from this field.
  ///@see \#PREFERRED_PHONE_ACCOUNT_COMPONENT_NAME
  ///@see PhoneAccountHandle\#getId()
  static const PREFERRED_PHONE_ACCOUNT_ID = "preferred_phone_account_id";

  /// from: static public final java.lang.String RAW_CONTACT_ID
  ///
  /// A reference to the RawContacts\#_ID
  /// that this data belongs to.
  static const RAW_CONTACT_ID = "raw_contact_id";

  /// from: static public final java.lang.String RES_PACKAGE
  ///
  /// The package name to use when creating Resources objects for
  /// this data row. This value is only designed for use when building user
  /// interfaces, and should not be used to infer the owner.
  static const RES_PACKAGE = "res_package";

  /// from: static public final java.lang.String SYNC1
  ///
  /// Generic column for use by sync adapters.
  static const SYNC1 = "data_sync1";

  /// from: static public final java.lang.String SYNC2
  ///
  /// Generic column for use by sync adapters.
  static const SYNC2 = "data_sync2";

  /// from: static public final java.lang.String SYNC3
  ///
  /// Generic column for use by sync adapters.
  static const SYNC3 = "data_sync3";

  /// from: static public final java.lang.String SYNC4
  ///
  /// Generic column for use by sync adapters.
  static const SYNC4 = "data_sync4";
}

/// from: android.provider.ContactsContract$Data
///
///
/// Constants for the data table, which contains data points tied to a raw
/// contact.  Each row of the data table is typically used to store a single
/// piece of contact
/// information (such as a phone number) and its
/// associated metadata (such as whether it is a work or home number).
///
///
/// <h3>Data kinds</h3>
///
/// Data is a generic table that can hold any kind of contact data.
/// The kind of data stored in a given row is specified by the row's
/// \#MIMETYPE value, which determines the meaning of the
/// generic columns \#DATA1 through
/// \#DATA15.
/// For example, if the data kind is
/// CommonDataKinds.Phone Phone.CONTENT_ITEM_TYPE, then the column
/// \#DATA1 stores the
/// phone number, but if the data kind is
/// CommonDataKinds.Email Email.CONTENT_ITEM_TYPE, then \#DATA1
/// stores the email address.
/// Sync adapters and applications can introduce their own data kinds.
///
///
///
/// ContactsContract defines a small number of pre-defined data kinds, e.g.
/// CommonDataKinds.Phone, CommonDataKinds.Email etc. As a
/// convenience, these classes define data kind specific aliases for DATA1 etc.
/// For example, CommonDataKinds.Phone Phone.NUMBER is the same as
/// ContactsContract.Data Data.DATA1.
///
///
///
/// \#DATA1 is an indexed column and should be used for the data element that is
/// expected to be most frequently used in query selections. For example, in the
/// case of a row representing email addresses \#DATA1 should probably
/// be used for the email address itself, while \#DATA2 etc can be
/// used for auxiliary information like type of email address.
///
///
/// By convention, \#DATA15 is used for storing BLOBs (binary data).
///
///
///
/// The sync adapter for a given account type must correctly handle every data type
/// used in the corresponding raw contacts.  Otherwise it could result in lost or
/// corrupted data.
///
///
///
/// Similarly, you should refrain from introducing new kinds of data for an other
/// party's account types. For example, if you add a data row for
/// "favorite song" to a raw contact owned by a Google account, it will not
/// get synced to the server, because the Google sync adapter does not know
/// how to handle this data kind. Thus new data kinds are typically
/// introduced along with new account types, i.e. new sync adapters.
///
///
/// <h3>Batch operations</h3>
///
/// Data rows can be inserted/updated/deleted using the traditional
/// ContentResolver\#insert, ContentResolver\#update and
/// ContentResolver\#delete methods, however the newer mechanism based
/// on a batch of ContentProviderOperation will prove to be a better
/// choice in almost all cases. All operations in a batch are executed in a
/// single transaction, which ensures that the phone-side and server-side
/// state of a raw contact are always consistent. Also, the batch-based
/// approach is far more efficient: not only are the database operations
/// faster when executed in a single transaction, but also sending a batch of
/// commands to the content provider saves a lot of time on context switching
/// between your process and the process in which the content provider runs.
///
///
///
/// The flip side of using batched operations is that a large batch may lock
/// up the database for a long time preventing other applications from
/// accessing data and potentially causing ANRs ("Application Not Responding"
/// dialogs.)
///
///
///
/// To avoid such lockups of the database, make sure to insert "yield points"
/// in the batch. A yield point indicates to the content provider that before
/// executing the next operation it can commit the changes that have already
/// been made, yield to other requests, open another transaction and continue
/// processing operations. A yield point will not automatically commit the
/// transaction, but only if there is another request waiting on the
/// database. Normally a sync adapter should insert a yield point at the
/// beginning of each raw contact operation sequence in the batch. See
/// ContentProviderOperation.Builder\#withYieldAllowed(boolean).
///
///
/// <h3>Operations</h3>
/// <dl>
/// <dt>__Insert__</dt>
/// <dd>
///
/// An individual data row can be inserted using the traditional
/// ContentResolver\#insert(Uri, ContentValues) method. Multiple rows
/// should always be inserted as a batch.
///
///
///
/// An example of a traditional insert:
/// <pre>
/// ContentValues values = new ContentValues();
/// values.put(Data.RAW_CONTACT_ID, rawContactId);
/// values.put(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE);
/// values.put(Phone.NUMBER, "1-800-GOOG-411");
/// values.put(Phone.TYPE, Phone.TYPE_CUSTOM);
/// values.put(Phone.LABEL, "free directory assistance");
/// Uri dataUri = getContentResolver().insert(Data.CONTENT_URI, values);
/// </pre>
///
/// The same done using ContentProviderOperations:
/// <pre>
/// ArrayList&lt;ContentProviderOperation&gt; ops =
///          new ArrayList&lt;ContentProviderOperation&gt;();
///
/// ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
///          .withValue(Data.RAW_CONTACT_ID, rawContactId)
///          .withValue(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE)
///          .withValue(Phone.NUMBER, "1-800-GOOG-411")
///          .withValue(Phone.TYPE, Phone.TYPE_CUSTOM)
///          .withValue(Phone.LABEL, "free directory assistance")
///          .build());
/// getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);
/// </pre>
///
///
/// <dt>__Update__</dt>
/// <dd>
///
/// Just as with insert, update can be done incrementally or as a batch,
/// the batch mode being the preferred method:
/// <pre>
/// ArrayList&lt;ContentProviderOperation&gt; ops =
///          new ArrayList&lt;ContentProviderOperation&gt;();
///
/// ops.add(ContentProviderOperation.newUpdate(Data.CONTENT_URI)
///          .withSelection(Data._ID + "=?", new String[]{String.valueOf(dataId)})
///          .withValue(Email.DATA, "somebody@android.com")
///          .build());
/// getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);
/// </pre>
///
///
/// </dd>
/// <dt>__Delete__</dt>
/// <dd>
///
/// Just as with insert and update, deletion can be done either using the
/// ContentResolver\#delete method or using a ContentProviderOperation:
/// <pre>
/// ArrayList&lt;ContentProviderOperation&gt; ops =
///          new ArrayList&lt;ContentProviderOperation&gt;();
///
/// ops.add(ContentProviderOperation.newDelete(Data.CONTENT_URI)
///          .withSelection(Data._ID + "=?", new String[]{String.valueOf(dataId)})
///          .build());
/// getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);
/// </pre>
///
///
/// </dd>
/// <dt>__Query__</dt>
/// <dd>
///
/// <dl>
/// <dt>Finding all Data of a given type for a given contact</dt>
/// <dd>
/// <pre>
/// Cursor c = getContentResolver().query(Data.CONTENT_URI,
///          new String[] {Data._ID, Phone.NUMBER, Phone.TYPE, Phone.LABEL},
///          Data.CONTACT_ID + &quot;=?&quot; + " AND "
///                  + Data.MIMETYPE + "='" + Phone.CONTENT_ITEM_TYPE + "'",
///          new String[] {String.valueOf(contactId)}, null);
/// </pre>
///
///
///
/// </dd>
/// <dt>Finding all Data of a given type for a given raw contact</dt>
/// <dd>
/// <pre>
/// Cursor c = getContentResolver().query(Data.CONTENT_URI,
///          new String[] {Data._ID, Phone.NUMBER, Phone.TYPE, Phone.LABEL},
///          Data.RAW_CONTACT_ID + &quot;=?&quot; + " AND "
///                  + Data.MIMETYPE + "='" + Phone.CONTENT_ITEM_TYPE + "'",
///          new String[] {String.valueOf(rawContactId)}, null);
/// </pre>
/// </dd>
/// <dt>Finding all Data for a given raw contact</dt>
/// <dd>
/// Most sync adapters will want to read all data rows for a raw contact
/// along with the raw contact itself.  For that you should use the
/// RawContactsEntity. See also RawContacts.
/// </dd>
/// </dl>
///
///
/// </dd>
/// </dl>
/// <h2>Columns</h2>
///
/// Many columns are available via a Data\#CONTENT_URI query.  For best performance you
/// should explicitly specify a projection to only those columns that you need.
///
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Data</th>
/// </tr>
/// <tr>
/// <td style="width: 7em;">long</td>
/// <td style="width: 20em;">\#_ID</td>
/// <td style="width: 5em;">read-only</td>
/// <td>Row ID. Sync adapter should try to preserve row IDs during updates. In other words,
/// it would be a bad idea to delete and reinsert a data row. A sync adapter should
/// always do an update instead.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#MIMETYPE</td>
/// <td>read/write-once</td>
/// <td>
/// The MIME type of the item represented by this row. Examples of common
/// MIME types are:
/// <ul>
/// <li>CommonDataKinds.StructuredName StructuredName.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Phone Phone.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Email Email.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Photo Photo.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Organization Organization.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Im Im.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Nickname Nickname.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Note Note.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.StructuredPostal StructuredPostal.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.GroupMembership GroupMembership.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Website Website.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Event Event.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.Relation Relation.CONTENT_ITEM_TYPE</li>
/// <li>CommonDataKinds.SipAddress SipAddress.CONTENT_ITEM_TYPE</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#RAW_CONTACT_ID</td>
/// <td>read/write-once</td>
/// <td>The id of the row in the RawContacts table that this data belongs to.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#IS_PRIMARY</td>
/// <td>read/write</td>
/// <td>Whether this is the primary entry of its kind for the raw contact it belongs to.
/// "1" if true, "0" if false.
/// </td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#IS_SUPER_PRIMARY</td>
/// <td>read/write</td>
/// <td>Whether this is the primary entry of its kind for the aggregate
/// contact it belongs to. Any data record that is "super primary" must
/// also be "primary".  For example, the super-primary entry may be
/// interpreted as the default contact value of its kind (for example,
/// the default phone number to use for the contact).</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#DATA_VERSION</td>
/// <td>read-only</td>
/// <td>The version of this data record. Whenever the data row changes
/// the version goes up. This value is monotonically increasing.</td>
/// </tr>
/// <tr>
/// <td>Any type</td>
/// <td>
/// \#DATA1<br>
/// \#DATA2<br>
/// \#DATA3<br>
/// \#DATA4<br>
/// \#DATA5<br>
/// \#DATA6<br>
/// \#DATA7<br>
/// \#DATA8<br>
/// \#DATA9<br>
/// \#DATA10<br>
/// \#DATA11<br>
/// \#DATA12<br>
/// \#DATA13<br>
/// \#DATA14<br>
/// \#DATA15
/// </td>
/// <td>read/write</td>
/// <td>
///
/// Generic data columns.  The meaning of each column is determined by the
/// \#MIMETYPE.  By convention, \#DATA15 is used for storing
/// BLOBs (binary data).
///
///
///
/// Data columns whose meaning is not explicitly defined for a given MIMETYPE
/// should not be used.  There is no guarantee that any sync adapter will
/// preserve them.  Sync adapters themselves should not use such columns either,
/// but should instead use \#SYNC1-\#SYNC4.
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>Any type</td>
/// <td>
/// \#SYNC1<br>
/// \#SYNC2<br>
/// \#SYNC3<br>
/// \#SYNC4
/// </td>
/// <td>read/write</td>
/// <td>Generic columns for use by sync adapters. For example, a Photo row
/// may store the image URL in SYNC1, a status (not loaded, loading, loaded, error)
/// in SYNC2, server-side version number in SYNC3 and error code in SYNC4.</td>
/// </tr>
/// </table>
///
///
/// Some columns from the most recent associated status update are also available
/// through an implicit join.
///
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Join with StatusUpdates</th>
/// </tr>
/// <tr>
/// <td style="width: 7em;">int</td>
/// <td style="width: 20em;">\#PRESENCE</td>
/// <td style="width: 5em;">read-only</td>
/// <td>IM presence status linked to this data row. Compare with
/// \#CONTACT_PRESENCE, which contains the contact's presence across
/// all IM rows. See StatusUpdates for individual status definitions.
/// The provider may choose not to store this value
/// in persistent storage. The expectation is that presence status will be
/// updated on a regular basis.
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#STATUS</td>
/// <td>read-only</td>
/// <td>Latest status update linked with this data row.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#STATUS_TIMESTAMP</td>
/// <td>read-only</td>
/// <td>The absolute time in milliseconds when the latest status was
/// inserted/updated for this data row.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#STATUS_RES_PACKAGE</td>
/// <td>read-only</td>
/// <td>The package containing resources for this status: label and icon.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#STATUS_LABEL</td>
/// <td>read-only</td>
/// <td>The resource ID of the label describing the source of status update linked
/// to this data row. This resource is scoped by the \#STATUS_RES_PACKAGE.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#STATUS_ICON</td>
/// <td>read-only</td>
/// <td>The resource ID of the icon for the source of the status update linked
/// to this data row. This resource is scoped by the \#STATUS_RES_PACKAGE.</td>
/// </tr>
/// </table>
///
///
/// Some columns from the associated raw contact are also available through an
/// implicit join.  The other columns are excluded as uninteresting in this
/// context.
///
///
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Join with ContactsContract.RawContacts</th>
/// </tr>
/// <tr>
/// <td style="width: 7em;">long</td>
/// <td style="width: 20em;">\#CONTACT_ID</td>
/// <td style="width: 5em;">read-only</td>
/// <td>The id of the row in the Contacts table that this data belongs
/// to.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#AGGREGATION_MODE</td>
/// <td>read-only</td>
/// <td>See RawContacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#DELETED</td>
/// <td>read-only</td>
/// <td>See RawContacts.</td>
/// </tr>
/// </table>
///
///
/// The ID column for the associated aggregated contact table
/// ContactsContract.Contacts is available
/// via the implicit join to the RawContacts table, see above.
/// The remaining columns from this table are also
/// available, through an implicit join.  This
/// facilitates lookup by
/// the value of a single data element, such as the email address.
///
///
///
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Join with ContactsContract.Contacts</th>
/// </tr>
/// <tr>
/// <td style="width: 7em;">String</td>
/// <td style="width: 20em;">\#LOOKUP_KEY</td>
/// <td style="width: 5em;">read-only</td>
/// <td>See ContactsContract.Contacts</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#DISPLAY_NAME</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#PHOTO_ID</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#IN_VISIBLE_GROUP</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#HAS_PHONE_NUMBER</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TIMES_CONTACTED</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#LAST_TIME_CONTACTED</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#STARRED</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CUSTOM_RINGTONE</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#SEND_TO_VOICEMAIL</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#CONTACT_PRESENCE</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CONTACT_STATUS</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_STATUS_TIMESTAMP</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CONTACT_STATUS_RES_PACKAGE</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_STATUS_LABEL</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_STATUS_ICON</td>
/// <td>read-only</td>
/// <td>See ContactsContract.Contacts.</td>
/// </tr>
/// </table>
class ContactsContract_Data extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$Data");
  ContactsContract_Data.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of the results from \#CONTENT_URI.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/data";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table, which requests a directory
  /// of data rows matching the selection criteria.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String VISIBLE_CONTACTS_ONLY
  ///
  /// A boolean parameter for Data\#CONTENT_URI.
  /// This specifies whether or not the returned data items should be filtered to show
  /// data items belonging to visible contacts only.
  static const VISIBLE_CONTACTS_ONLY = "visible_contacts_only";

  static final _id_getContactLookupUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getContactLookupUri",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getContactLookupUri(android.content.ContentResolver resolver, android.net.Uri dataUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  /// Build a android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI
  /// style Uri for the parent android.provider.ContactsContract.Contacts
  /// entry of the given ContactsContract.Data entry.
  ///
  ///
  ///
  /// Returns the Uri for the contact in the first entry returned by
  /// ContentResolver\#query(Uri, String[], String, String[], String)
  /// for the provided {@code dataUri}.  If the query returns null or empty
  /// results, silently returns null.
  ///
  ///
  static uri_.Uri getContactLookupUri(
          contentresolver_.ContentResolver resolver, uri_.Uri dataUri) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getContactLookupUri,
          jni.JniType.objectType,
          [resolver.reference, dataUri.reference]).object);
}

/// from: android.provider.ContactsContract$ContactsColumns
///
/// Columns of ContactsContract.Contacts that refer to intrinsic
/// properties of the contact, as opposed to the user-specified options
/// found in ContactOptionsColumns.
///@see Contacts
///@see ContactsContract.Data
///@see PhoneLookup
///@see ContactsContract.Contacts.AggregationSuggestions
class ContactsContract_ContactsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$ContactsColumns");
  ContactsContract_ContactsColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTACT_LAST_UPDATED_TIMESTAMP
  ///
  /// Timestamp (milliseconds since epoch) of when this contact was last updated.  This
  /// includes updates to all data associated with this contact including raw contacts.  Any
  /// modification (including deletes and inserts) of underlying contact data are also
  /// reflected in this timestamp.
  static const CONTACT_LAST_UPDATED_TIMESTAMP =
      "contact_last_updated_timestamp";

  /// from: static public final java.lang.String DISPLAY_NAME
  ///
  /// The display name for the contact.
  /// <P>Type: TEXT</P>
  static const DISPLAY_NAME = "display_name";

  /// from: static public final java.lang.String HAS_PHONE_NUMBER
  ///
  /// An indicator of whether this contact has at least one phone number. "1" if there is
  /// at least one phone number, "0" otherwise.
  /// <P>Type: INTEGER</P>
  static const HAS_PHONE_NUMBER = "has_phone_number";

  /// from: static public final java.lang.String IN_DEFAULT_DIRECTORY
  ///
  /// Flag that reflects whether the contact exists inside the default directory.
  /// Ie, whether the contact is designed to only be visible outside search.
  static const IN_DEFAULT_DIRECTORY = "in_default_directory";

  /// from: static public final java.lang.String IN_VISIBLE_GROUP
  ///
  /// Flag that reflects the Groups\#GROUP_VISIBLE state of any
  /// CommonDataKinds.GroupMembership for this contact.
  static const IN_VISIBLE_GROUP = "in_visible_group";

  /// from: static public final java.lang.String IS_USER_PROFILE
  ///
  /// Flag that reflects whether this contact represents the user's
  /// personal profile entry.
  static const IS_USER_PROFILE = "is_user_profile";

  /// from: static public final java.lang.String LOOKUP_KEY
  ///
  /// An opaque value that contains hints on how to find the contact if
  /// its row id changed as a result of a sync or aggregation.
  static const LOOKUP_KEY = "lookup";

  /// from: static public final java.lang.String NAME_RAW_CONTACT_ID
  ///
  /// Reference to the row in the RawContacts table holding the contact name.
  /// <P>Type: INTEGER REFERENCES raw_contacts(_id)</P>
  static const NAME_RAW_CONTACT_ID = "name_raw_contact_id";

  /// from: static public final java.lang.String PHOTO_FILE_ID
  ///
  /// Photo file ID of the full-size photo.  If present, this will be used to populate
  /// \#PHOTO_URI.  The ID can also be used with
  /// ContactsContract.DisplayPhoto\#CONTENT_URI to create a URI to the photo.
  /// If this is present, \#PHOTO_ID is also guaranteed to be populated.
  ///
  /// <P>Type: INTEGER</P>
  static const PHOTO_FILE_ID = "photo_file_id";

  /// from: static public final java.lang.String PHOTO_ID
  ///
  /// Reference to the row in the data table holding the photo.  A photo can
  /// be referred to either by ID (this field) or by URI (see \#PHOTO_THUMBNAIL_URI
  /// and \#PHOTO_URI).
  /// If PHOTO_ID is null, consult \#PHOTO_URI or \#PHOTO_THUMBNAIL_URI,
  /// which is a more generic mechanism for referencing the contact photo, especially for
  /// contacts returned by non-local directories (see Directory).
  ///
  /// <P>Type: INTEGER REFERENCES data(_id)</P>
  static const PHOTO_ID = "photo_id";

  /// from: static public final java.lang.String PHOTO_THUMBNAIL_URI
  ///
  /// A URI that can be used to retrieve a thumbnail of the contact's photo.
  /// A photo can be referred to either by a URI (this field or \#PHOTO_URI)
  /// or by ID (see \#PHOTO_ID). If PHOTO_ID is not null, PHOTO_URI and
  /// PHOTO_THUMBNAIL_URI shall not be null (but not necessarily vice versa).
  /// If the content provider does not differentiate between full-size photos
  /// and thumbnail photos, PHOTO_THUMBNAIL_URI and \#PHOTO_URI can contain
  /// the same value, but either both shall be null or both not null.
  ///
  /// <P>Type: TEXT</P>
  static const PHOTO_THUMBNAIL_URI = "photo_thumb_uri";

  /// from: static public final java.lang.String PHOTO_URI
  ///
  /// A URI that can be used to retrieve the contact's full-size photo.
  /// If PHOTO_FILE_ID is not null, this will be populated with a URI based off
  /// ContactsContract.DisplayPhoto\#CONTENT_URI.  Otherwise, this will
  /// be populated with the same value as \#PHOTO_THUMBNAIL_URI.
  /// A photo can be referred to either by a URI (this field) or by ID
  /// (see \#PHOTO_ID). If either PHOTO_FILE_ID or PHOTO_ID is not null,
  /// PHOTO_URI and PHOTO_THUMBNAIL_URI shall not be null (but not necessarily
  /// vice versa).  Thus using PHOTO_URI is a more robust method of retrieving
  /// contact photos.
  ///
  /// <P>Type: TEXT</P>
  static const PHOTO_URI = "photo_uri";
}

/// from: android.provider.ContactsContract$Contacts
///
/// Constants for the contacts table, which contains a record per aggregate
/// of raw contacts representing the same person.
/// <h3>Operations</h3>
/// <dl>
/// <dt>__Insert__</dt>
/// <dd>A Contact cannot be created explicitly. When a raw contact is
/// inserted, the provider will first try to find a Contact representing the
/// same person. If one is found, the raw contact's
/// RawContacts\#CONTACT_ID column gets the _ID of the aggregate
/// Contact. If no match is found, the provider automatically inserts a new
/// Contact and puts its _ID into the RawContacts\#CONTACT_ID column
/// of the newly inserted raw contact.</dd>
/// <dt>__Update__</dt>
/// <dd>Only certain columns of Contact are modifiable:
/// \#TIMES_CONTACTED, \#LAST_TIME_CONTACTED, \#STARRED,
/// \#CUSTOM_RINGTONE, \#SEND_TO_VOICEMAIL. Changing any of
/// these columns on the Contact also changes them on all constituent raw
/// contacts.</dd>
/// <dt>__Delete__</dt>
/// <dd>Be careful with deleting Contacts! Deleting an aggregate contact
/// deletes all constituent raw contacts. The corresponding sync adapters
/// will notice the deletions of their respective raw contacts and remove
/// them from their back end storage.</dd>
/// <dt>__Query__</dt>
/// <dd>
/// <ul>
/// <li>If you need to read an individual contact, consider using
/// \#CONTENT_LOOKUP_URI instead of \#CONTENT_URI.</li>
/// <li>If you need to look up a contact by the phone number, use
/// PhoneLookup\#CONTENT_FILTER_URI PhoneLookup.CONTENT_FILTER_URI,
/// which is optimized for this purpose.</li>
/// <li>If you need to look up a contact by partial name, e.g. to produce
/// filter-as-you-type suggestions, use the \#CONTENT_FILTER_URI URI.
/// <li>If you need to look up a contact by some data element like email
/// address, nickname, etc, use a query against the ContactsContract.Data table.
/// The result will contain contact ID, name etc.
/// </ul>
/// </dd>
/// </dl>
/// <h2>Columns</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>Contacts</th>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#_ID</td>
/// <td>read-only</td>
/// <td>Row ID. Consider using \#LOOKUP_KEY instead.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LOOKUP_KEY</td>
/// <td>read-only</td>
/// <td>An opaque value that contains hints on how to find the contact if its
/// row id changed as a result of a sync or aggregation.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>NAME_RAW_CONTACT_ID</td>
/// <td>read-only</td>
/// <td>The ID of the raw contact that contributes the display name
/// to the aggregate contact. During aggregation one of the constituent
/// raw contacts is chosen using a heuristic: a longer name or a name
/// with more diacritic marks or more upper case characters is chosen.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>DISPLAY_NAME_PRIMARY</td>
/// <td>read-only</td>
/// <td>The display name for the contact. It is the display name
/// contributed by the raw contact referred to by the NAME_RAW_CONTACT_ID
/// column.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#PHOTO_ID</td>
/// <td>read-only</td>
/// <td>Reference to the row in the ContactsContract.Data table holding the photo.
/// That row has the mime type
/// CommonDataKinds.Photo\#CONTENT_ITEM_TYPE. The value of this field
/// is computed automatically based on the
/// CommonDataKinds.Photo\#IS_SUPER_PRIMARY field of the data rows of
/// that mime type.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#PHOTO_URI</td>
/// <td>read-only</td>
/// <td>A URI that can be used to retrieve the contact's full-size photo. This
/// column is the preferred method of retrieving the contact photo.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#PHOTO_THUMBNAIL_URI</td>
/// <td>read-only</td>
/// <td>A URI that can be used to retrieve the thumbnail of contact's photo.  This
/// column is the preferred method of retrieving the contact photo.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#IN_VISIBLE_GROUP</td>
/// <td>read-only</td>
/// <td>An indicator of whether this contact is supposed to be visible in the
/// UI. "1" if the contact has at least one raw contact that belongs to a
/// visible group; "0" otherwise.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#HAS_PHONE_NUMBER</td>
/// <td>read-only</td>
/// <td>An indicator of whether this contact has at least one phone number.
/// "1" if there is at least one phone number, "0" otherwise.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TIMES_CONTACTED</td>
/// <td>read/write</td>
/// <td>The number of times the contact has been contacted. See
/// \#markAsContacted. When raw contacts are aggregated, this field is
/// computed automatically as the maximum number of times contacted among all
/// constituent raw contacts. Setting this field automatically changes the
/// corresponding field on all constituent raw contacts.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#LAST_TIME_CONTACTED</td>
/// <td>read/write</td>
/// <td>The timestamp of the last time the contact was contacted. See
/// \#markAsContacted. Setting this field also automatically
/// increments \#TIMES_CONTACTED. When raw contacts are aggregated,
/// this field is computed automatically as the latest time contacted of all
/// constituent raw contacts. Setting this field automatically changes the
/// corresponding field on all constituent raw contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#STARRED</td>
/// <td>read/write</td>
/// <td>An indicator for favorite contacts: '1' if favorite, '0' otherwise.
/// When raw contacts are aggregated, this field is automatically computed:
/// if any constituent raw contacts are starred, then this field is set to
/// '1'. Setting this field automatically changes the corresponding field on
/// all constituent raw contacts.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CUSTOM_RINGTONE</td>
/// <td>read/write</td>
/// <td>A custom ringtone associated with a contact. Typically this is the
/// URI returned by an activity launched with the
/// android.media.RingtoneManager\#ACTION_RINGTONE_PICKER intent.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#SEND_TO_VOICEMAIL</td>
/// <td>read/write</td>
/// <td>An indicator of whether calls from this contact should be forwarded
/// directly to voice mail ('1') or not ('0'). When raw contacts are
/// aggregated, this field is automatically computed: if <i>all</i>
/// constituent raw contacts have SEND_TO_VOICEMAIL=1, then this field is set
/// to '1'. Setting this field automatically changes the corresponding field
/// on all constituent raw contacts.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#CONTACT_PRESENCE</td>
/// <td>read-only</td>
/// <td>Contact IM presence status. See StatusUpdates for individual
/// status definitions. Automatically computed as the highest presence of all
/// constituent raw contacts. The provider may choose not to store this value
/// in persistent storage. The expectation is that presence status will be
/// updated on a regular basis.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CONTACT_STATUS</td>
/// <td>read-only</td>
/// <td>Contact's latest status update. Automatically computed as the latest
/// of all constituent raw contacts' status updates.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_STATUS_TIMESTAMP</td>
/// <td>read-only</td>
/// <td>The absolute time in milliseconds when the latest status was
/// inserted/updated.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CONTACT_STATUS_RES_PACKAGE</td>
/// <td>read-only</td>
/// <td> The package containing resources for this status: label and icon.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_STATUS_LABEL</td>
/// <td>read-only</td>
/// <td>The resource ID of the label describing the source of contact status,
/// e.g. "Google Talk". This resource is scoped by the
/// \#CONTACT_STATUS_RES_PACKAGE.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#CONTACT_STATUS_ICON</td>
/// <td>read-only</td>
/// <td>The resource ID of the icon for the source of contact status. This
/// resource is scoped by the \#CONTACT_STATUS_RES_PACKAGE.</td>
/// </tr>
/// </table>
class ContactsContract_Contacts extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/provider/ContactsContract\$Contacts");
  ContactsContract_Contacts.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CONTENT_FILTER_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI used for "type-to-filter" functionality on the
  /// \#CONTENT_URI URI. The filter string will be used to match
  /// various parts of the contact name. The filter argument should be passed
  /// as an additional path segment after this URI.
  static uri_.Uri get CONTENT_FILTER_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_FILTER_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_FREQUENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FREQUENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FREQUENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for showing a list of frequently contacted people.
  static uri_.Uri get CONTENT_FREQUENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_FREQUENT_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_GROUP_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_GROUP_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_GROUP_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  static uri_.Uri get CONTENT_GROUP_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_GROUP_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME type of a \#CONTENT_URI subdirectory of a single
  /// person.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/contact";

  static final _id_CONTENT_LOOKUP_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_LOOKUP_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_LOOKUP_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A content:// style URI for this table that should be used to create
  /// shortcuts or otherwise create long-term links to contacts. This URI
  /// should always be followed by a "/" and the contact's \#LOOKUP_KEY.
  /// It can optionally also have a "/" and last known contact ID appended after
  /// that. This "complete" format is an important optimization and is highly recommended.
  ///
  /// As long as the contact's row ID remains the same, this URI is
  /// equivalent to \#CONTENT_URI. If the contact's row ID changes
  /// as a result of a sync or aggregation, this URI will look up the
  /// contact using indirect information (sync IDs or constituent raw
  /// contacts).
  ///
  /// Lookup key should be appended unencoded - it is stored in the encoded
  /// form, ready for use in a URI.
  static uri_.Uri get CONTENT_LOOKUP_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_LOOKUP_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_MULTI_VCARD_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_MULTI_VCARD_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_MULTI_VCARD_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Base Uri for referencing multiple Contacts entry,
  /// created by appending \#LOOKUP_KEY using
  /// Uri\#withAppendedPath(Uri, String). The lookup keys have to be
  /// joined with the colon (":") separator, and the resulting string encoded.
  ///
  /// Provides OpenableColumns columns when queried, or returns the
  /// referenced contact formatted as a vCard when opened through
  /// ContentResolver\#openAssetFileDescriptor(Uri, String).
  ///
  ///
  /// Usage example:
  /// <dl>
  /// <dt>The following code snippet creates a multi-vcard URI that references all the
  /// contacts in a user's database.</dt>
  /// <dd>
  ///
  /// <pre>
  /// public Uri getAllContactsVcardUri() {
  ///     Cursor cursor = getActivity().getContentResolver().query(Contacts.CONTENT_URI,
  ///         new String[] {Contacts.LOOKUP_KEY}, null, null, null);
  ///     if (cursor == null) {
  ///         return null;
  ///     }
  ///     try {
  ///         StringBuilder uriListBuilder = new StringBuilder();
  ///         int index = 0;
  ///         while (cursor.moveToNext()) {
  ///             if (index != 0) uriListBuilder.append(':');
  ///             uriListBuilder.append(cursor.getString(0));
  ///             index++;
  ///         }
  ///         return Uri.withAppendedPath(Contacts.CONTENT_MULTI_VCARD_URI,
  ///                 Uri.encode(uriListBuilder.toString()));
  ///     } finally {
  ///         cursor.close();
  ///     }
  /// }
  /// </pre>
  ///
  ///
  ///
  static uri_.Uri get CONTENT_MULTI_VCARD_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_MULTI_VCARD_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_STREQUENT_FILTER_URI =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "CONTENT_STREQUENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_STREQUENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI used for "type-to-filter" functionality on the
  /// \#CONTENT_STREQUENT_URI URI. The filter string will be used to match
  /// various parts of the contact name. The filter argument should be passed
  /// as an additional path segment after this URI.
  static uri_.Uri get CONTENT_STREQUENT_FILTER_URI =>
      uri_.Uri.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CONTENT_STREQUENT_FILTER_URI,
              jni.JniType.objectType)
          .object);

  static final _id_CONTENT_STREQUENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_STREQUENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_STREQUENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table joined with useful data from
  /// ContactsContract.Data, filtered to include only starred contacts
  /// and the most frequently contacted contacts.
  static uri_.Uri get CONTENT_STREQUENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_CONTENT_STREQUENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI providing a directory of
  /// people.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/contact";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CONTENT_VCARD_TYPE
  ///
  /// The MIME type of a \#CONTENT_URI subdirectory of a single
  /// person.
  static const CONTENT_VCARD_TYPE = "text/x-vcard";

  static final _id_CONTENT_VCARD_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_VCARD_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_VCARD_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Base Uri for referencing a single Contacts entry,
  /// created by appending \#LOOKUP_KEY using
  /// Uri\#withAppendedPath(Uri, String). Provides
  /// OpenableColumns columns when queried, or returns the
  /// referenced contact formatted as a vCard when opened through
  /// ContentResolver\#openAssetFileDescriptor(Uri, String).
  static uri_.Uri get CONTENT_VCARD_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_VCARD_URI, jni.JniType.objectType)
      .object);

  static final _id_ENTERPRISE_CONTENT_FILTER_URI =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENTERPRISE_CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri ENTERPRISE_CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// It supports the similar semantics as \#CONTENT_FILTER_URI and returns the same
  /// columns. This URI requires ContactsContract\#DIRECTORY_PARAM_KEY in parameters,
  /// otherwise it will throw IllegalArgumentException.
  static uri_.Uri get ENTERPRISE_CONTENT_FILTER_URI => uri_.Uri.fromRef(
      jniAccessors
          .getStaticField(_classRef, _id_ENTERPRISE_CONTENT_FILTER_URI,
              jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String QUERY_PARAMETER_VCARD_NO_PHOTO
  ///
  /// Boolean parameter that may be used with \#CONTENT_VCARD_URI
  /// and \#CONTENT_MULTI_VCARD_URI to indicate that the returned
  /// vcard should not contain a photo.
  ///
  /// This is useful for obtaining a space efficient vcard.
  static const QUERY_PARAMETER_VCARD_NO_PHOTO = "no_photo";

  static final _id_getLookupUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getLookupUri",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getLookupUri(android.content.ContentResolver resolver, android.net.Uri contactUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds a \#CONTENT_LOOKUP_URI style Uri describing the
  /// requested Contacts entry.
  ///@param contactUri A \#CONTENT_URI row, or an existing
  ///            \#CONTENT_LOOKUP_URI to attempt refreshing.
  static uri_.Uri getLookupUri(
          contentresolver_.ContentResolver resolver, uri_.Uri contactUri) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getLookupUri,
          jni.JniType.objectType,
          [resolver.reference, contactUri.reference]).object);

  static final _id_getLookupUri1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getLookupUri", "(JLjava/lang/String;)Landroid/net/Uri;");

  /// from: static public android.net.Uri getLookupUri(long contactId, java.lang.String lookupKey)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build a \#CONTENT_LOOKUP_URI lookup Uri using the
  /// given ContactsContract.Contacts\#_ID and \#LOOKUP_KEY.
  ///
  /// Returns null if unable to construct a valid lookup URI from the
  /// provided parameters.
  static uri_.Uri getLookupUri1(int contactId, jni.JniString lookupKey) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getLookupUri1,
          jni.JniType.objectType,
          [contactId, lookupKey.reference]).object);

  static final _id_lookupContact = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "lookupContact",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: static public android.net.Uri lookupContact(android.content.ContentResolver resolver, android.net.Uri lookupUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Computes a content URI (see \#CONTENT_URI) given a lookup URI.
  ///
  /// Returns null if the contact cannot be found.
  static uri_.Uri lookupContact(
          contentresolver_.ContentResolver resolver, uri_.Uri lookupUri) =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_lookupContact,
          jni.JniType.objectType,
          [resolver.reference, lookupUri.reference]).object);

  static final _id_markAsContacted = jniAccessors.getStaticMethodIDOf(
      _classRef, "markAsContacted", "(Landroid/content/ContentResolver;J)V");

  /// from: static public void markAsContacted(android.content.ContentResolver resolver, long contactId)
  ///
  /// Mark a contact as having been contacted. Updates two fields:
  /// \#TIMES_CONTACTED and \#LAST_TIME_CONTACTED. The
  /// TIMES_CONTACTED field is incremented by 1 and the LAST_TIME_CONTACTED
  /// field is populated with the current system time.
  ///@param resolver the ContentResolver to use
  ///@param contactId the person who was contacted
  ///@deprecated The class DataUsageStatUpdater of the Android support library should
  ///     be used instead.
  static void markAsContacted(
          contentresolver_.ContentResolver resolver, int contactId) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_markAsContacted,
          jni.JniType.voidType, [resolver.reference, contactId]).check();

  static final _id_isEnterpriseContactId = jniAccessors.getStaticMethodIDOf(
      _classRef, "isEnterpriseContactId", "(J)Z");

  /// from: static public boolean isEnterpriseContactId(long contactId)
  ///
  /// Return TRUE if a contact ID is from the contacts provider on the enterprise profile.
  ///
  /// PhoneLookup\#ENTERPRISE_CONTENT_FILTER_URI may return such a contact.
  static bool isEnterpriseContactId(int contactId) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isEnterpriseContactId,
          jni.JniType.booleanType,
          [contactId]).boolean;

  static final _id_openContactPhotoInputStream = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "openContactPhotoInputStream",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;Z)Ljava/io/InputStream;");

  /// from: static public java.io.InputStream openContactPhotoInputStream(android.content.ContentResolver cr, android.net.Uri contactUri, boolean preferHighres)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens an InputStream for the contacts's photo and returns the
  /// photo as a byte stream.
  ///@param cr The content resolver to use for querying
  ///@param contactUri the contact whose photo should be used. This can be used with
  /// either a \#CONTENT_URI or a \#CONTENT_LOOKUP_URI URI.
  ///@param preferHighres If this is true and the contact has a higher resolution photo
  /// available, it is returned. If false, this function always tries to get the thumbnail
  ///@return an InputStream of the photo, or null if no photo is present
  static jni.JniObject openContactPhotoInputStream(
          contentresolver_.ContentResolver cr,
          uri_.Uri contactUri,
          bool preferHighres) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_openContactPhotoInputStream,
          jni.JniType.objectType,
          [cr.reference, contactUri.reference, preferHighres]).object);

  static final _id_openContactPhotoInputStream1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "openContactPhotoInputStream",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Ljava/io/InputStream;");

  /// from: static public java.io.InputStream openContactPhotoInputStream(android.content.ContentResolver cr, android.net.Uri contactUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens an InputStream for the contacts's thumbnail photo and returns the
  /// photo as a byte stream.
  ///@param cr The content resolver to use for querying
  ///@param contactUri the contact whose photo should be used. This can be used with
  /// either a \#CONTENT_URI or a \#CONTENT_LOOKUP_URI URI.
  ///@return an InputStream of the photo, or null if no photo is present
  ///@see \#openContactPhotoInputStream(ContentResolver, Uri, boolean), if instead
  /// of the thumbnail the high-res picture is preferred
  static jni.JniObject openContactPhotoInputStream1(
          contentresolver_.ContentResolver cr, uri_.Uri contactUri) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_openContactPhotoInputStream1,
          jni.JniType.objectType,
          [cr.reference, contactUri.reference]).object);
}

/// from: android.provider.ContactsContract$Contacts$Photo
///
/// A <i>read-only</i> sub-directory of a single contact that contains
/// the contact's primary photo.  The photo may be stored in up to two ways -
/// the default "photo" is a thumbnail-sized image stored directly in the data
/// row, while the "display photo", if present, is a larger version stored as
/// a file.
///
/// Usage example:
/// <dl>
/// <dt>Retrieving the thumbnail-sized photo</dt>
/// <dd>
/// <pre>
/// public InputStream openPhoto(long contactId) {
///     Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, contactId);
///     Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
///     Cursor cursor = getContentResolver().query(photoUri,
///          new String[] {Contacts.Photo.PHOTO}, null, null, null);
///     if (cursor == null) {
///         return null;
///     }
///     try {
///         if (cursor.moveToFirst()) {
///             byte[] data = cursor.getBlob(0);
///             if (data != null) {
///                 return new ByteArrayInputStream(data);
///             }
///         }
///     } finally {
///         cursor.close();
///     }
///     return null;
/// }
/// </pre>
/// </dd>
/// <dt>Retrieving the larger photo version</dt>
/// <dd>
/// <pre>
/// public InputStream openDisplayPhoto(long contactId) {
///     Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, contactId);
///     Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
///     try {
///         AssetFileDescriptor fd =
///             getContentResolver().openAssetFileDescriptor(displayPhotoUri, "r");
///         return fd.createInputStream();
///     } catch (IOException e) {
///         return null;
///     }
/// }
/// </pre>
/// </dd>
/// </dl>
///
///
///
/// You may also consider using the convenience method
/// ContactsContract.Contacts\#openContactPhotoInputStream(ContentResolver, Uri, boolean)
/// to retrieve the raw photo contents of either the thumbnail-sized or the full-sized photo.
///
///
///
/// This directory can be used either with a \#CONTENT_URI or
/// \#CONTENT_LOOKUP_URI.
///
///
class ContactsContract_Contacts_Photo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$Contacts\$Photo");
  ContactsContract_Contacts_Photo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// The directory twig for this sub-table
  static const CONTENT_DIRECTORY = "photo";

  /// from: static public final java.lang.String DISPLAY_PHOTO
  ///
  /// The directory twig for retrieving the full-size display photo.
  static const DISPLAY_PHOTO = "display_photo";

  /// from: static public final java.lang.String PHOTO
  ///
  /// Thumbnail photo of the raw contact. This is the raw bytes of an image
  /// that could be inflated using android.graphics.BitmapFactory.
  ///
  /// Type: BLOB
  static const PHOTO = "data15";

  /// from: static public final java.lang.String PHOTO_FILE_ID
  ///
  /// Full-size photo file ID of the raw contact.
  /// See ContactsContract.DisplayPhoto.
  ///
  /// Type: NUMBER
  static const PHOTO_FILE_ID = "data14";
}

/// from: android.provider.ContactsContract$Contacts$Entity
///
///
/// A sub-directory of a contact that contains all of its
/// ContactsContract.RawContacts as well as
/// ContactsContract.Data rows. To access this directory append
/// \#CONTENT_DIRECTORY to the contact URI.
///
///
///
/// Entity has three ID fields: \#CONTACT_ID for the contact,
/// \#RAW_CONTACT_ID for the raw contact and \#DATA_ID for
/// the data rows. Entity always contains at least one row per
/// constituent raw contact, even if there are no actual data rows. In
/// this case the \#DATA_ID field will be null.
///
///
///
/// Entity reads all data for the entire contact in one transaction, to
/// guarantee consistency.  There is significant data duplication
/// in the Entity (each row repeats all Contact columns and all RawContact
/// columns), so the benefits of transactional consistency should be weighed
/// against the cost of transferring large amounts of denormalized data
/// from the Provider.
///
///
///
/// To reduce the amount of data duplication the contacts provider and directory
/// providers implementing this protocol are allowed to provide common Contacts
/// and RawContacts fields in the first row returned for each raw contact only and
/// leave them as null in subsequent rows.
///
///
class ContactsContract_Contacts_Entity extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$Contacts\$Entity");
  ContactsContract_Contacts_Entity.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// The directory twig for this sub-table
  static const CONTENT_DIRECTORY = "entities";

  /// from: static public final java.lang.String DATA_ID
  ///
  /// The ID of the data row. The value will be null if this raw contact has no
  /// data rows.
  /// <P>Type: INTEGER</P>
  static const DATA_ID = "data_id";

  /// from: static public final java.lang.String RAW_CONTACT_ID
  ///
  /// The ID of the raw contact row.
  /// <P>Type: INTEGER</P>
  static const RAW_CONTACT_ID = "raw_contact_id";
}

/// from: android.provider.ContactsContract$Contacts$Data
///
/// A sub-directory of a single contact that contains all of the constituent raw contact
/// ContactsContract.Data rows.  This directory can be used either
/// with a \#CONTENT_URI or \#CONTENT_LOOKUP_URI.
class ContactsContract_Contacts_Data extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$Contacts\$Data");
  ContactsContract_Contacts_Data.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// The directory twig for this sub-table
  static const CONTENT_DIRECTORY = "data";
}

/// from: android.provider.ContactsContract$Contacts$AggregationSuggestions
///
///
/// A <i>read-only</i> sub-directory of a single contact aggregate that
/// contains all aggregation suggestions (other contacts). The
/// aggregation suggestions are computed based on approximate data
/// matches with this contact.
///
///
///
/// <i>Note: this query may be expensive! If you need to use it in bulk,
/// make sure the user experience is acceptable when the query runs for a
/// long time.</i>
///
/// Usage example:
///
/// <pre>
/// Uri uri = Contacts.CONTENT_URI.buildUpon()
///          .appendEncodedPath(String.valueOf(contactId))
///          .appendPath(Contacts.AggregationSuggestions.CONTENT_DIRECTORY)
///          .appendQueryParameter(&quot;limit&quot;, &quot;3&quot;)
///          .build()
/// Cursor cursor = getContentResolver().query(suggestionsUri,
///          new String[] {Contacts.DISPLAY_NAME, Contacts._ID, Contacts.LOOKUP_KEY},
///          null, null, null);
/// </pre>
///
///
///
///
/// This directory can be used either with a \#CONTENT_URI or
/// \#CONTENT_LOOKUP_URI.
///
///
class ContactsContract_Contacts_AggregationSuggestions extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$Contacts\$AggregationSuggestions");
  ContactsContract_Contacts_AggregationSuggestions.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  ///
  /// The directory twig for this sub-table. The URI can be followed by an optional
  /// type-to-filter, similar to
  /// android.provider.ContactsContract.Contacts\#CONTENT_FILTER_URI.
  static const CONTENT_DIRECTORY = "suggestions";
}

/// from: android.provider.ContactsContract$Contacts$AggregationSuggestions$Builder
///
/// A convenience builder for aggregation suggestion content URIs.
class ContactsContract_Contacts_AggregationSuggestions_Builder
    extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$Contacts\$AggregationSuggestions\$Builder");
  ContactsContract_Contacts_AggregationSuggestions_Builder.fromRef(
      jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_Contacts_AggregationSuggestions_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setContactId = jniAccessors.getMethodIDOf(
      _classRef,
      "setContactId",
      "(J)Landroid/provider/ContactsContract\$Contacts\$AggregationSuggestions\$Builder;");

  /// from: public android.provider.ContactsContract.Contacts.AggregationSuggestions.Builder setContactId(long contactId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional existing contact ID.  If it is not provided, the search
  /// will be based exclusively on the values supplied with \#addNameParameter.
  ///@param contactId contact to find aggregation suggestions for
  ///@return This Builder object to allow for chaining of calls to builder methods
  ContactsContract_Contacts_AggregationSuggestions_Builder setContactId(
          int contactId) =>
      ContactsContract_Contacts_AggregationSuggestions_Builder.fromRef(
          jniAccessors.callMethodWithArgs(reference, _id_setContactId,
              jni.JniType.objectType, [contactId]).object);

  static final _id_addNameParameter = jniAccessors.getMethodIDOf(
      _classRef,
      "addNameParameter",
      "(Ljava/lang/String;)Landroid/provider/ContactsContract\$Contacts\$AggregationSuggestions\$Builder;");

  /// from: public android.provider.ContactsContract.Contacts.AggregationSuggestions.Builder addNameParameter(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a name to be used when searching for aggregation suggestions.
  ///@param name name to find aggregation suggestions for
  ///@return This Builder object to allow for chaining of calls to builder methods
  ContactsContract_Contacts_AggregationSuggestions_Builder addNameParameter(
          jni.JniString name) =>
      ContactsContract_Contacts_AggregationSuggestions_Builder.fromRef(
          jniAccessors.callMethodWithArgs(reference, _id_addNameParameter,
              jni.JniType.objectType, [name.reference]).object);

  static final _id_setLimit = jniAccessors.getMethodIDOf(_classRef, "setLimit",
      "(I)Landroid/provider/ContactsContract\$Contacts\$AggregationSuggestions\$Builder;");

  /// from: public android.provider.ContactsContract.Contacts.AggregationSuggestions.Builder setLimit(int limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the Maximum number of suggested aggregations that should be returned.
  ///@param limit The maximum number of suggested aggregations
  ///@return This Builder object to allow for chaining of calls to builder methods
  ContactsContract_Contacts_AggregationSuggestions_Builder setLimit(
          int limit) =>
      ContactsContract_Contacts_AggregationSuggestions_Builder.fromRef(
          jniAccessors.callMethodWithArgs(
              reference, _id_setLimit, jni.JniType.objectType, [limit]).object);

  static final _id_build =
      jniAccessors.getMethodIDOf(_classRef, "build", "()Landroid/net/Uri;");

  /// from: public android.net.Uri build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Combine all of the options that have been set and return a new Uri
  /// object for fetching aggregation suggestions.
  uri_.Uri build() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_build, jni.JniType.objectType, []).object);
}

/// from: android.provider.ContactsContract$ContactStatusColumns
///
/// @see Contacts
class ContactsContract_ContactStatusColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$ContactStatusColumns");
  ContactsContract_ContactStatusColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTACT_CHAT_CAPABILITY
  ///
  /// Contact Chat Capabilities. See StatusUpdates for individual
  /// definitions.
  /// Type: NUMBER
  ///
  static const CONTACT_CHAT_CAPABILITY = "contact_chat_capability";

  /// from: static public final java.lang.String CONTACT_PRESENCE
  ///
  /// Contact presence status. See StatusUpdates for individual status
  /// definitions.
  /// Type: NUMBER
  ///
  static const CONTACT_PRESENCE = "contact_presence";

  /// from: static public final java.lang.String CONTACT_STATUS
  ///
  /// Contact's latest status update.
  /// Type: TEXT
  ///
  static const CONTACT_STATUS = "contact_status";

  /// from: static public final java.lang.String CONTACT_STATUS_ICON
  ///
  /// The resource ID of the icon for the source of contact status. This
  /// resource is scoped by the \#CONTACT_STATUS_RES_PACKAGE.
  /// Type: NUMBER
  ///
  static const CONTACT_STATUS_ICON = "contact_status_icon";

  /// from: static public final java.lang.String CONTACT_STATUS_LABEL
  ///
  /// The resource ID of the label describing the source of contact
  /// status, e.g.&nbsp;"Google Talk". This resource is scoped by the
  /// \#CONTACT_STATUS_RES_PACKAGE.
  /// Type: NUMBER
  ///
  static const CONTACT_STATUS_LABEL = "contact_status_label";

  /// from: static public final java.lang.String CONTACT_STATUS_RES_PACKAGE
  ///
  /// The package containing resources for this status: label and icon.
  /// Type: TEXT
  ///
  static const CONTACT_STATUS_RES_PACKAGE = "contact_status_res_package";

  /// from: static public final java.lang.String CONTACT_STATUS_TIMESTAMP
  ///
  /// The absolute time in milliseconds when the latest status was
  /// inserted/updated.
  /// Type: NUMBER
  ///
  static const CONTACT_STATUS_TIMESTAMP = "contact_status_ts";
}

/// from: android.provider.ContactsContract$ContactOptionsColumns
///
/// Columns of ContactsContract.Contacts that track the user's
/// preferences for, or interactions with, the contact.
///@see Contacts
///@see RawContacts
///@see ContactsContract.Data
///@see PhoneLookup
///@see ContactsContract.Contacts.AggregationSuggestions
class ContactsContract_ContactOptionsColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$ContactOptionsColumns");
  ContactsContract_ContactOptionsColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CUSTOM_RINGTONE
  ///
  /// URI for a custom ringtone associated with the contact. If null or missing,
  /// the default ringtone is used.
  /// <P>Type: TEXT (URI to the ringtone)</P>
  static const CUSTOM_RINGTONE = "custom_ringtone";

  /// from: static public final java.lang.String LAST_TIME_CONTACTED
  ///
  /// The last time a contact was contacted.
  /// <P>Type: INTEGER</P>
  static const LAST_TIME_CONTACTED = "last_time_contacted";

  /// from: static public final java.lang.String PINNED
  ///
  /// The position at which the contact is pinned. If PinnedPositions\#UNPINNED,
  /// the contact is not pinned. Also see PinnedPositions.
  /// <P>Type: INTEGER </P>
  static const PINNED = "pinned";

  /// from: static public final java.lang.String SEND_TO_VOICEMAIL
  ///
  /// Whether the contact should always be sent to voicemail. If missing,
  /// defaults to false.
  /// <P>Type: INTEGER (0 for false, 1 for true)</P>
  static const SEND_TO_VOICEMAIL = "send_to_voicemail";

  /// from: static public final java.lang.String STARRED
  ///
  /// Is the contact starred?
  /// <P>Type: INTEGER (boolean)</P>
  static const STARRED = "starred";

  /// from: static public final java.lang.String TIMES_CONTACTED
  ///
  /// The number of times a contact has been contacted
  /// <P>Type: INTEGER</P>
  static const TIMES_CONTACTED = "times_contacted";
}

/// from: android.provider.ContactsContract$ContactNameColumns
///
/// Contact name and contact name metadata columns in the RawContacts table.
///@see Contacts
///@see RawContacts
class ContactsContract_ContactNameColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$ContactNameColumns");
  ContactsContract_ContactNameColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String DISPLAY_NAME_ALTERNATIVE
  ///
  ///
  /// An alternative representation of the display name, such as "family name first"
  /// instead of "given name first" for Western names.  If an alternative is not
  /// available, the values should be the same as \#DISPLAY_NAME_PRIMARY.
  ///
  ///
  ///
  /// A contacts provider is free to provide alternatives as necessary for
  /// its target market.
  /// For example the default Android Open Source Project contacts provider
  /// currently provides an
  /// alternative in a single case:  if the display name is
  /// based on the structured name and the structured name follows
  /// the Western full name style, then the field contains the "family name first"
  /// version of the full name.
  /// Other cases may be added later.
  ///
  ///
  static const DISPLAY_NAME_ALTERNATIVE = "display_name_alt";

  /// from: static public final java.lang.String DISPLAY_NAME_PRIMARY
  ///
  ///
  /// The standard text shown as the contact's display name, based on the best
  /// available information for the contact (for example, it might be the email address
  /// if the name is not available).
  /// The information actually used to compute the name is stored in
  /// \#DISPLAY_NAME_SOURCE.
  ///
  ///
  ///
  /// A contacts provider is free to choose whatever representation makes most
  /// sense for its target market.
  /// For example in the default Android Open Source Project implementation,
  /// if the display name is
  /// based on the structured name and the structured name follows
  /// the Western full-name style, then this field contains the "given name first"
  /// version of the full name.
  ///
  ///@see ContactsContract.ContactNameColumns\#DISPLAY_NAME_ALTERNATIVE
  static const DISPLAY_NAME_PRIMARY = "display_name";

  /// from: static public final java.lang.String DISPLAY_NAME_SOURCE
  ///
  /// The kind of data that is used as the display name for the contact, such as
  /// structured name or email address.  See DisplayNameSources.
  static const DISPLAY_NAME_SOURCE = "display_name_source";

  /// from: static public final java.lang.String PHONETIC_NAME
  ///
  ///
  /// Pronunciation of the full name in the phonetic alphabet specified by
  /// \#PHONETIC_NAME_STYLE.
  ///
  ///
  ///
  /// The value may be set manually by the user. This capability is of
  /// interest only in countries with commonly used phonetic alphabets,
  /// such as Japan and Korea. See PhoneticNameStyle.
  ///
  ///
  static const PHONETIC_NAME = "phonetic_name";

  /// from: static public final java.lang.String PHONETIC_NAME_STYLE
  ///
  /// The phonetic alphabet used to represent the \#PHONETIC_NAME.  See
  /// PhoneticNameStyle.
  static const PHONETIC_NAME_STYLE = "phonetic_name_style";

  /// from: static public final java.lang.String SORT_KEY_ALTERNATIVE
  ///
  /// Sort key based on the alternative representation of the full name,
  /// \#DISPLAY_NAME_ALTERNATIVE.  Thus for Western names,
  /// it is the one using the "family name first" format.
  static const SORT_KEY_ALTERNATIVE = "sort_key_alt";

  /// from: static public final java.lang.String SORT_KEY_PRIMARY
  ///
  /// Sort key that takes into account locale-based traditions for sorting
  /// names in address books.  The default
  /// sort key is \#DISPLAY_NAME_PRIMARY.  For Chinese names
  /// the sort key is the name's Pinyin spelling, and for Japanese names
  /// it is the Hiragana version of the phonetic name.
  static const SORT_KEY_PRIMARY = "sort_key";
}

/// from: android.provider.ContactsContract$CommonDataKinds
///
/// Container for definitions of common data types stored in the ContactsContract.Data
/// table.
class ContactsContract_CommonDataKinds extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$CommonDataKinds");
  ContactsContract_CommonDataKinds.fromRef(jni.JObject ref)
      : super.fromRef(ref);
}

/// from: android.provider.ContactsContract$CommonDataKinds$Website
///
///
/// A data kind representing a website related to the contact.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#URL</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_HOMEPAGE</li>
/// <li>\#TYPE_BLOG</li>
/// <li>\#TYPE_PROFILE</li>
/// <li>\#TYPE_HOME</li>
/// <li>\#TYPE_WORK</li>
/// <li>\#TYPE_FTP</li>
/// <li>\#TYPE_OTHER</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Website extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$Website");
  ContactsContract_CommonDataKinds_Website.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/website";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final int TYPE_BLOG
  static const TYPE_BLOG = 2;

  /// from: static public final int TYPE_FTP
  static const TYPE_FTP = 6;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 4;

  /// from: static public final int TYPE_HOMEPAGE
  static const TYPE_HOMEPAGE = 1;

  /// from: static public final int TYPE_OTHER
  static const TYPE_OTHER = 7;

  /// from: static public final int TYPE_PROFILE
  static const TYPE_PROFILE = 3;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 5;

  /// from: static public final java.lang.String URL
  ///
  /// The website URL string.
  /// <P>Type: TEXT</P>
  static const URL = "data1";
}

/// from: android.provider.ContactsContract$CommonDataKinds$StructuredPostal
///
///
/// A data kind representing a postal addresses.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#FORMATTED_ADDRESS</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_HOME</li>
/// <li>\#TYPE_WORK</li>
/// <li>\#TYPE_OTHER</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#STREET</td>
/// <td>\#DATA4</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#POBOX</td>
/// <td>\#DATA5</td>
/// <td>Post Office Box number</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#NEIGHBORHOOD</td>
/// <td>\#DATA6</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CITY</td>
/// <td>\#DATA7</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#REGION</td>
/// <td>\#DATA8</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#POSTCODE</td>
/// <td>\#DATA9</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#COUNTRY</td>
/// <td>\#DATA10</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_StructuredPostal extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$StructuredPostal");
  ContactsContract_CommonDataKinds_StructuredPostal.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CITY
  ///
  /// Can be city, village, town, borough, etc. This is the postal town
  /// and not necessarily the place of residence or place of business.
  ///
  /// Type: TEXT
  static const CITY = "data7";

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/postal-address_v2";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI providing a directory of
  /// postal addresses.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/postal-address_v2";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for all data records of the
  /// StructuredPostal\#CONTENT_ITEM_TYPE MIME type.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String COUNTRY
  ///
  /// The name or code of the country.
  ///
  /// Type: TEXT
  static const COUNTRY = "data10";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String FORMATTED_ADDRESS
  ///
  /// The full, unstructured postal address. <i>This field must be
  /// consistent with any structured data.</i>
  ///
  /// Type: TEXT
  static const FORMATTED_ADDRESS = "data1";

  /// from: static public final java.lang.String NEIGHBORHOOD
  ///
  /// This is used to disambiguate a street address when a city
  /// contains more than one street with the same name, or to specify a
  /// small place whose mail is routed through a larger postal town. In
  /// China it could be a county or a minor city.
  ///
  /// Type: TEXT
  static const NEIGHBORHOOD = "data6";

  /// from: static public final java.lang.String POBOX
  ///
  /// Covers actual P.O. boxes, drawers, locked bags, etc. This is
  /// usually but not always mutually exclusive with street.
  ///
  /// Type: TEXT
  static const POBOX = "data5";

  /// from: static public final java.lang.String POSTCODE
  ///
  /// Postal code. Usually country-wide, but sometimes specific to the
  /// city (e.g. "2" in "Dublin 2, Ireland" addresses).
  ///
  /// Type: TEXT
  static const POSTCODE = "data9";

  /// from: static public final java.lang.String REGION
  ///
  /// A state, province, county (in Ireland), Land (in Germany),
  /// departement (in France), etc.
  ///
  /// Type: TEXT
  static const REGION = "data8";

  /// from: static public final java.lang.String STREET
  ///
  /// Can be street, avenue, road, etc. This element also includes the
  /// house number and room/apartment/flat/floor number.
  ///
  /// Type: TEXT
  static const STREET = "data4";

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 1;

  /// from: static public final int TYPE_OTHER
  static const TYPE_OTHER = 3;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 2;

  static final _id_getTypeLabelResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTypeLabelResource", "(I)I");

  /// from: static public int getTypeLabelResource(int type)
  ///
  /// Return the string resource that best describes the given
  /// \#TYPE. Will always return a valid resource.
  static int getTypeLabelResource(int type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTypeLabelResource,
          jni.JniType.intType, [type]).integer;

  static final _id_getTypeLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getTypeLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getTypeLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given type,
  /// possibly substituting the given \#LABEL value
  /// for \#TYPE_CUSTOM.
  static jni.JniObject getTypeLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTypeLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$StructuredName
///
/// A data kind representing the contact's proper name. You can use all
/// columns defined for ContactsContract.Data as well as the following aliases.
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th><th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#DISPLAY_NAME</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#GIVEN_NAME</td>
/// <td>\#DATA2</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#FAMILY_NAME</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#PREFIX</td>
/// <td>\#DATA4</td>
/// <td>Common prefixes in English names are "Mr", "Ms", "Dr" etc.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#MIDDLE_NAME</td>
/// <td>\#DATA5</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SUFFIX</td>
/// <td>\#DATA6</td>
/// <td>Common suffixes in English names are "Sr", "Jr", "III" etc.</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#PHONETIC_GIVEN_NAME</td>
/// <td>\#DATA7</td>
/// <td>Used for phonetic spelling of the name, e.g. Pinyin, Katakana, Hiragana</td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#PHONETIC_MIDDLE_NAME</td>
/// <td>\#DATA8</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#PHONETIC_FAMILY_NAME</td>
/// <td>\#DATA9</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_StructuredName extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$StructuredName");
  ContactsContract_CommonDataKinds_StructuredName.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/name";

  /// from: static public final java.lang.String DISPLAY_NAME
  ///
  /// The name that should be used to display the contact.
  /// <i>Unstructured component of the name should be consistent with
  /// its structured representation.</i>
  ///
  /// Type: TEXT
  static const DISPLAY_NAME = "data1";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String FAMILY_NAME
  ///
  /// The family name for the contact.
  /// <P>Type: TEXT</P>
  static const FAMILY_NAME = "data3";

  /// from: static public final java.lang.String FULL_NAME_STYLE
  ///
  /// The style used for combining given/middle/family name into a full name.
  /// See ContactsContract.FullNameStyle.
  static const FULL_NAME_STYLE = "data10";

  /// from: static public final java.lang.String GIVEN_NAME
  ///
  /// The given name for the contact.
  /// <P>Type: TEXT</P>
  static const GIVEN_NAME = "data2";

  /// from: static public final java.lang.String MIDDLE_NAME
  ///
  /// The contact's middle name
  /// <P>Type: TEXT</P>
  static const MIDDLE_NAME = "data5";

  /// from: static public final java.lang.String PHONETIC_FAMILY_NAME
  ///
  /// The phonetic version of the family name for the contact.
  /// <P>Type: TEXT</P>
  static const PHONETIC_FAMILY_NAME = "data9";

  /// from: static public final java.lang.String PHONETIC_GIVEN_NAME
  ///
  /// The phonetic version of the given name for the contact.
  /// <P>Type: TEXT</P>
  static const PHONETIC_GIVEN_NAME = "data7";

  /// from: static public final java.lang.String PHONETIC_MIDDLE_NAME
  ///
  /// The phonetic version of the additional name for the contact.
  /// <P>Type: TEXT</P>
  static const PHONETIC_MIDDLE_NAME = "data8";

  /// from: static public final java.lang.String PHONETIC_NAME_STYLE
  ///
  /// The alphabet used for capturing the phonetic name.
  /// See ContactsContract.PhoneticNameStyle.
  static const PHONETIC_NAME_STYLE = "data11";

  /// from: static public final java.lang.String PREFIX
  ///
  /// The contact's honorific prefix, e.g.&nbsp;"Sir"
  /// <P>Type: TEXT</P>
  static const PREFIX = "data4";

  /// from: static public final java.lang.String SUFFIX
  ///
  /// The contact's honorific suffix, e.g.&nbsp;"Jr"
  static const SUFFIX = "data6";
}

/// from: android.provider.ContactsContract$CommonDataKinds$SipAddress
///
///
/// A data kind representing a SIP address for the contact.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SIP_ADDRESS</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_HOME</li>
/// <li>\#TYPE_WORK</li>
/// <li>\#TYPE_OTHER</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_SipAddress extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$SipAddress");
  ContactsContract_CommonDataKinds_SipAddress.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/sip_address";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String SIP_ADDRESS
  ///
  /// The SIP address.
  /// <P>Type: TEXT</P>
  static const SIP_ADDRESS = "data1";

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 1;

  /// from: static public final int TYPE_OTHER
  static const TYPE_OTHER = 3;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 2;

  static final _id_getTypeLabelResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTypeLabelResource", "(I)I");

  /// from: static public int getTypeLabelResource(int type)
  ///
  /// Return the string resource that best describes the given
  /// \#TYPE. Will always return a valid resource.
  static int getTypeLabelResource(int type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTypeLabelResource,
          jni.JniType.intType, [type]).integer;

  static final _id_getTypeLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getTypeLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getTypeLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given type,
  /// possibly substituting the given \#LABEL value
  /// for \#TYPE_CUSTOM.
  static jni.JniObject getTypeLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTypeLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$Relation
///
///
/// A data kind representing a relation.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#NAME</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_ASSISTANT</li>
/// <li>\#TYPE_BROTHER</li>
/// <li>\#TYPE_CHILD</li>
/// <li>\#TYPE_DOMESTIC_PARTNER</li>
/// <li>\#TYPE_FATHER</li>
/// <li>\#TYPE_FRIEND</li>
/// <li>\#TYPE_MANAGER</li>
/// <li>\#TYPE_MOTHER</li>
/// <li>\#TYPE_PARENT</li>
/// <li>\#TYPE_PARTNER</li>
/// <li>\#TYPE_REFERRED_BY</li>
/// <li>\#TYPE_RELATIVE</li>
/// <li>\#TYPE_SISTER</li>
/// <li>\#TYPE_SPOUSE</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Relation extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$Relation");
  ContactsContract_CommonDataKinds_Relation.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/relation";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String NAME
  ///
  /// The name of the relative as the user entered it.
  /// <P>Type: TEXT</P>
  static const NAME = "data1";

  /// from: static public final int TYPE_ASSISTANT
  static const TYPE_ASSISTANT = 1;

  /// from: static public final int TYPE_BROTHER
  static const TYPE_BROTHER = 2;

  /// from: static public final int TYPE_CHILD
  static const TYPE_CHILD = 3;

  /// from: static public final int TYPE_DOMESTIC_PARTNER
  static const TYPE_DOMESTIC_PARTNER = 4;

  /// from: static public final int TYPE_FATHER
  static const TYPE_FATHER = 5;

  /// from: static public final int TYPE_FRIEND
  static const TYPE_FRIEND = 6;

  /// from: static public final int TYPE_MANAGER
  static const TYPE_MANAGER = 7;

  /// from: static public final int TYPE_MOTHER
  static const TYPE_MOTHER = 8;

  /// from: static public final int TYPE_PARENT
  static const TYPE_PARENT = 9;

  /// from: static public final int TYPE_PARTNER
  static const TYPE_PARTNER = 10;

  /// from: static public final int TYPE_REFERRED_BY
  static const TYPE_REFERRED_BY = 11;

  /// from: static public final int TYPE_RELATIVE
  static const TYPE_RELATIVE = 12;

  /// from: static public final int TYPE_SISTER
  static const TYPE_SISTER = 13;

  /// from: static public final int TYPE_SPOUSE
  static const TYPE_SPOUSE = 14;

  static final _id_getTypeLabelResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTypeLabelResource", "(I)I");

  /// from: static public int getTypeLabelResource(int type)
  ///
  /// Return the string resource that best describes the given
  /// \#TYPE. Will always return a valid resource.
  static int getTypeLabelResource(int type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTypeLabelResource,
          jni.JniType.intType, [type]).integer;

  static final _id_getTypeLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getTypeLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getTypeLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given type,
  /// possibly substituting the given \#LABEL value
  /// for \#TYPE_CUSTOM.
  static jni.JniObject getTypeLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTypeLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$Photo
///
///
/// A data kind representing a photo for the contact.
///
///
///
/// Some sync adapters will choose to download photos in a separate
/// pass. A common pattern is to use columns ContactsContract.Data\#SYNC1
/// through ContactsContract.Data\#SYNC4 to store temporary
/// data, e.g. the image URL or ID, state of download, server-side version
/// of the image.  It is allowed for the \#PHOTO to be null.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>NUMBER</td>
/// <td>\#PHOTO_FILE_ID</td>
/// <td>\#DATA14</td>
/// <td>ID of the hi-res photo file.</td>
/// </tr>
/// <tr>
/// <td>BLOB</td>
/// <td>\#PHOTO</td>
/// <td>\#DATA15</td>
/// <td>By convention, binary data is stored in DATA15.  The thumbnail of the
/// photo is stored in this column.</td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Photo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$CommonDataKinds\$Photo");
  ContactsContract_CommonDataKinds_Photo.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/photo";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String PHOTO
  ///
  /// Thumbnail photo of the raw contact. This is the raw bytes of an image
  /// that could be inflated using android.graphics.BitmapFactory.
  ///
  /// Type: BLOB
  static const PHOTO = "data15";

  /// from: static public final java.lang.String PHOTO_FILE_ID
  ///
  /// Photo file ID for the display photo of the raw contact.
  /// See ContactsContract.DisplayPhoto.
  ///
  /// Type: NUMBER
  static const PHOTO_FILE_ID = "data14";
}

/// from: android.provider.ContactsContract$CommonDataKinds$Phone
///
///
/// A data kind representing a telephone number.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#NUMBER</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_HOME</li>
/// <li>\#TYPE_MOBILE</li>
/// <li>\#TYPE_WORK</li>
/// <li>\#TYPE_FAX_WORK</li>
/// <li>\#TYPE_FAX_HOME</li>
/// <li>\#TYPE_PAGER</li>
/// <li>\#TYPE_OTHER</li>
/// <li>\#TYPE_CALLBACK</li>
/// <li>\#TYPE_CAR</li>
/// <li>\#TYPE_COMPANY_MAIN</li>
/// <li>\#TYPE_ISDN</li>
/// <li>\#TYPE_MAIN</li>
/// <li>\#TYPE_OTHER_FAX</li>
/// <li>\#TYPE_RADIO</li>
/// <li>\#TYPE_TELEX</li>
/// <li>\#TYPE_TTY_TDD</li>
/// <li>\#TYPE_WORK_MOBILE</li>
/// <li>\#TYPE_WORK_PAGER</li>
/// <li>\#TYPE_ASSISTANT</li>
/// <li>\#TYPE_MMS</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Phone extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$CommonDataKinds\$Phone");
  ContactsContract_CommonDataKinds_Phone.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CONTENT_FILTER_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URL for phone lookup using a filter. The filter returns
  /// records of MIME type \#CONTENT_ITEM_TYPE. The filter is applied
  /// to display names as well as phone numbers. The filter argument should be passed
  /// as an additional path segment after this URI.
  static uri_.Uri get CONTENT_FILTER_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_FILTER_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/phone_v2";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI providing a directory of
  /// phones.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/phone_v2";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for all data records of the
  /// \#CONTENT_ITEM_TYPE MIME type, combined with the
  /// associated raw contact and aggregate contact data.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ENTERPRISE_CONTENT_FILTER_URI =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENTERPRISE_CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri ENTERPRISE_CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// It supports the similar semantics as \#CONTENT_FILTER_URI and returns the same
  /// columns. This URI requires ContactsContract\#DIRECTORY_PARAM_KEY in
  /// parameters, otherwise it will throw IllegalArgumentException.
  static uri_.Uri get ENTERPRISE_CONTENT_FILTER_URI => uri_.Uri.fromRef(
      jniAccessors
          .getStaticField(_classRef, _id_ENTERPRISE_CONTENT_FILTER_URI,
              jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String NORMALIZED_NUMBER
  ///
  /// The phone number's E164 representation. This value can be omitted in which
  /// case the provider will try to automatically infer it.  (It'll be left null if the
  /// provider fails to infer.)
  /// If present, \#NUMBER has to be set as well (it will be ignored otherwise).
  /// <P>Type: TEXT</P>
  static const NORMALIZED_NUMBER = "data4";

  /// from: static public final java.lang.String NUMBER
  ///
  /// The phone number as the user entered it.
  /// <P>Type: TEXT</P>
  static const NUMBER = "data1";

  /// from: static public final java.lang.String SEARCH_DISPLAY_NAME_KEY
  ///
  /// A boolean query parameter that can be used with \#CONTENT_FILTER_URI.
  /// If "1" or "true", display names are searched.  If "0" or "false", display names
  /// are not searched.  Default is "1".
  static const SEARCH_DISPLAY_NAME_KEY = "search_display_name";

  /// from: static public final java.lang.String SEARCH_PHONE_NUMBER_KEY
  ///
  /// A boolean query parameter that can be used with \#CONTENT_FILTER_URI.
  /// If "1" or "true", phone numbers are searched.  If "0" or "false", phone numbers
  /// are not searched.  Default is "1".
  static const SEARCH_PHONE_NUMBER_KEY = "search_phone_number";

  /// from: static public final int TYPE_ASSISTANT
  static const TYPE_ASSISTANT = 19;

  /// from: static public final int TYPE_CALLBACK
  static const TYPE_CALLBACK = 8;

  /// from: static public final int TYPE_CAR
  static const TYPE_CAR = 9;

  /// from: static public final int TYPE_COMPANY_MAIN
  static const TYPE_COMPANY_MAIN = 10;

  /// from: static public final int TYPE_FAX_HOME
  static const TYPE_FAX_HOME = 5;

  /// from: static public final int TYPE_FAX_WORK
  static const TYPE_FAX_WORK = 4;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 1;

  /// from: static public final int TYPE_ISDN
  static const TYPE_ISDN = 11;

  /// from: static public final int TYPE_MAIN
  static const TYPE_MAIN = 12;

  /// from: static public final int TYPE_MMS
  static const TYPE_MMS = 20;

  /// from: static public final int TYPE_MOBILE
  static const TYPE_MOBILE = 2;

  /// from: static public final int TYPE_OTHER
  static const TYPE_OTHER = 7;

  /// from: static public final int TYPE_OTHER_FAX
  static const TYPE_OTHER_FAX = 13;

  /// from: static public final int TYPE_PAGER
  static const TYPE_PAGER = 6;

  /// from: static public final int TYPE_RADIO
  static const TYPE_RADIO = 14;

  /// from: static public final int TYPE_TELEX
  static const TYPE_TELEX = 15;

  /// from: static public final int TYPE_TTY_TDD
  static const TYPE_TTY_TDD = 16;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 3;

  /// from: static public final int TYPE_WORK_MOBILE
  static const TYPE_WORK_MOBILE = 17;

  /// from: static public final int TYPE_WORK_PAGER
  static const TYPE_WORK_PAGER = 18;

  static final _id_getTypeLabelResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTypeLabelResource", "(I)I");

  /// from: static public int getTypeLabelResource(int type)
  ///
  /// Return the string resource that best describes the given
  /// \#TYPE. Will always return a valid resource.
  static int getTypeLabelResource(int type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTypeLabelResource,
          jni.JniType.intType, [type]).integer;

  static final _id_getTypeLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getTypeLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getTypeLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given type,
  /// possibly substituting the given \#LABEL value
  /// for \#TYPE_CUSTOM.
  static jni.JniObject getTypeLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTypeLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$Organization
///
///
/// A data kind representing an organization.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#COMPANY</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_WORK</li>
/// <li>\#TYPE_OTHER</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#TITLE</td>
/// <td>\#DATA4</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#DEPARTMENT</td>
/// <td>\#DATA5</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#JOB_DESCRIPTION</td>
/// <td>\#DATA6</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#SYMBOL</td>
/// <td>\#DATA7</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#PHONETIC_NAME</td>
/// <td>\#DATA8</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#OFFICE_LOCATION</td>
/// <td>\#DATA9</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>PHONETIC_NAME_STYLE</td>
/// <td>\#DATA10</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Organization extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$Organization");
  ContactsContract_CommonDataKinds_Organization.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String COMPANY
  ///
  /// The company as the user entered it.
  /// <P>Type: TEXT</P>
  static const COMPANY = "data1";

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/organization";

  /// from: static public final java.lang.String DEPARTMENT
  ///
  /// The department at this company as the user entered it.
  /// <P>Type: TEXT</P>
  static const DEPARTMENT = "data5";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String JOB_DESCRIPTION
  ///
  /// The job description at this company as the user entered it.
  /// <P>Type: TEXT</P>
  static const JOB_DESCRIPTION = "data6";

  /// from: static public final java.lang.String OFFICE_LOCATION
  ///
  /// The office location of this organization.
  /// <P>Type: TEXT</P>
  static const OFFICE_LOCATION = "data9";

  /// from: static public final java.lang.String PHONETIC_NAME
  ///
  /// The phonetic name of this company as the user entered it.
  /// <P>Type: TEXT</P>
  static const PHONETIC_NAME = "data8";

  /// from: static public final java.lang.String PHONETIC_NAME_STYLE
  ///
  /// The alphabet used for capturing the phonetic name.
  /// See ContactsContract.PhoneticNameStyle.
  static const PHONETIC_NAME_STYLE = "data10";

  /// from: static public final java.lang.String SYMBOL
  ///
  /// The symbol of this company as the user entered it.
  /// <P>Type: TEXT</P>
  static const SYMBOL = "data7";

  /// from: static public final java.lang.String TITLE
  ///
  /// The position title at this company as the user entered it.
  /// <P>Type: TEXT</P>
  static const TITLE = "data4";

  /// from: static public final int TYPE_OTHER
  static const TYPE_OTHER = 2;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  static final _id_getTypeLabelResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTypeLabelResource", "(I)I");

  /// from: static public int getTypeLabelResource(int type)
  ///
  /// Return the string resource that best describes the given
  /// \#TYPE. Will always return a valid resource.
  static int getTypeLabelResource(int type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTypeLabelResource,
          jni.JniType.intType, [type]).integer;

  static final _id_getTypeLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getTypeLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getTypeLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given type,
  /// possibly substituting the given \#LABEL value
  /// for \#TYPE_CUSTOM.
  static jni.JniObject getTypeLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTypeLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$Note
///
///
/// Notes about the contact.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#NOTE</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Note extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$CommonDataKinds\$Note");
  ContactsContract_CommonDataKinds_Note.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/note";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String NOTE
  ///
  /// The note text.
  /// <P>Type: TEXT</P>
  static const NOTE = "data1";
}

/// from: android.provider.ContactsContract$CommonDataKinds$Nickname
///
/// A data kind representing the contact's nickname. For example, for
/// Bob Parr ("Mr. Incredible"):
/// <pre>
/// ArrayList&lt;ContentProviderOperation&gt; ops =
///          new ArrayList&lt;ContentProviderOperation&gt;();
///
/// ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
///          .withValue(Data.RAW_CONTACT_ID, rawContactId)
///          .withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE)
///          .withValue(StructuredName.DISPLAY_NAME, &quot;Bob Parr&quot;)
///          .build());
///
/// ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
///          .withValue(Data.RAW_CONTACT_ID, rawContactId)
///          .withValue(Data.MIMETYPE, Nickname.CONTENT_ITEM_TYPE)
///          .withValue(Nickname.NAME, "Mr. Incredible")
///          .withValue(Nickname.TYPE, Nickname.TYPE_CUSTOM)
///          .withValue(Nickname.LABEL, "Superhero")
///          .build());
///
/// getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);
/// </pre>
///
///
///
/// You can use all columns defined for ContactsContract.Data as well as the
/// following aliases.
///
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th><th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#NAME</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>
/// Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_DEFAULT</li>
/// <li>\#TYPE_OTHER_NAME</li>
/// <li>\#TYPE_MAIDEN_NAME</li>
/// <li>\#TYPE_SHORT_NAME</li>
/// <li>\#TYPE_INITIALS</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Nickname extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$Nickname");
  ContactsContract_CommonDataKinds_Nickname.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/nickname";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String NAME
  ///
  /// The name itself
  static const NAME = "data1";

  /// from: static public final int TYPE_DEFAULT
  static const TYPE_DEFAULT = 1;

  /// from: static public final int TYPE_INITIALS
  static const TYPE_INITIALS = 5;

  /// from: static public final int TYPE_MAIDEN_NAME
  static const TYPE_MAIDEN_NAME = 3;

  /// from: static public final int TYPE_MAINDEN_NAME
  ///
  /// @deprecated Use TYPE_MAIDEN_NAME instead.
  static const TYPE_MAINDEN_NAME = 3;

  /// from: static public final int TYPE_OTHER_NAME
  static const TYPE_OTHER_NAME = 2;

  /// from: static public final int TYPE_SHORT_NAME
  static const TYPE_SHORT_NAME = 4;
}

/// from: android.provider.ContactsContract$CommonDataKinds$Im
///
///
/// A data kind representing an IM address
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#DATA</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_HOME</li>
/// <li>\#TYPE_WORK</li>
/// <li>\#TYPE_OTHER</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#PROTOCOL</td>
/// <td>\#DATA5</td>
/// <td>
///
/// Allowed values:
/// <ul>
/// <li>\#PROTOCOL_CUSTOM. Also provide the actual protocol name
/// as \#CUSTOM_PROTOCOL.</li>
/// <li>\#PROTOCOL_AIM</li>
/// <li>\#PROTOCOL_MSN</li>
/// <li>\#PROTOCOL_YAHOO</li>
/// <li>\#PROTOCOL_SKYPE</li>
/// <li>\#PROTOCOL_QQ</li>
/// <li>\#PROTOCOL_GOOGLE_TALK</li>
/// <li>\#PROTOCOL_ICQ</li>
/// <li>\#PROTOCOL_JABBER</li>
/// <li>\#PROTOCOL_NETMEETING</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#CUSTOM_PROTOCOL</td>
/// <td>\#DATA6</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Im extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$CommonDataKinds\$Im");
  ContactsContract_CommonDataKinds_Im.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/im";

  /// from: static public final java.lang.String CUSTOM_PROTOCOL
  static const CUSTOM_PROTOCOL = "data6";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String PROTOCOL
  ///
  /// This column should be populated with one of the defined
  /// constants, e.g.&nbsp;\#PROTOCOL_YAHOO. If the value of this
  /// column is \#PROTOCOL_CUSTOM, the \#CUSTOM_PROTOCOL
  /// should contain the name of the custom protocol.
  static const PROTOCOL = "data5";

  /// from: static public final int PROTOCOL_AIM
  static const PROTOCOL_AIM = 0;

  /// from: static public final int PROTOCOL_CUSTOM
  static const PROTOCOL_CUSTOM = -1;

  /// from: static public final int PROTOCOL_GOOGLE_TALK
  static const PROTOCOL_GOOGLE_TALK = 5;

  /// from: static public final int PROTOCOL_ICQ
  static const PROTOCOL_ICQ = 6;

  /// from: static public final int PROTOCOL_JABBER
  static const PROTOCOL_JABBER = 7;

  /// from: static public final int PROTOCOL_MSN
  static const PROTOCOL_MSN = 1;

  /// from: static public final int PROTOCOL_NETMEETING
  static const PROTOCOL_NETMEETING = 8;

  /// from: static public final int PROTOCOL_QQ
  static const PROTOCOL_QQ = 4;

  /// from: static public final int PROTOCOL_SKYPE
  static const PROTOCOL_SKYPE = 3;

  /// from: static public final int PROTOCOL_YAHOO
  static const PROTOCOL_YAHOO = 2;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 1;

  /// from: static public final int TYPE_OTHER
  static const TYPE_OTHER = 3;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 2;

  static final _id_getTypeLabelResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTypeLabelResource", "(I)I");

  /// from: static public int getTypeLabelResource(int type)
  ///
  /// Return the string resource that best describes the given
  /// \#TYPE. Will always return a valid resource.
  static int getTypeLabelResource(int type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTypeLabelResource,
          jni.JniType.intType, [type]).integer;

  static final _id_getTypeLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getTypeLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getTypeLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given type,
  /// possibly substituting the given \#LABEL value
  /// for \#TYPE_CUSTOM.
  static jni.JniObject getTypeLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTypeLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);

  static final _id_getProtocolLabelResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getProtocolLabelResource", "(I)I");

  /// from: static public int getProtocolLabelResource(int type)
  ///
  /// Return the string resource that best describes the given
  /// \#PROTOCOL. Will always return a valid resource.
  static int getProtocolLabelResource(int type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getProtocolLabelResource, jni.JniType.intType, [type]).integer;

  static final _id_getProtocolLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getProtocolLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getProtocolLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given
  /// protocol, possibly substituting the given
  /// \#CUSTOM_PROTOCOL value for \#PROTOCOL_CUSTOM.
  static jni.JniObject getProtocolLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getProtocolLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$Identity
///
/// A data kind representing an Identity related to the contact.
///
/// This can be used as a signal by the aggregator to combine raw contacts into
/// contacts, e.g. if two contacts have Identity rows with
/// the same NAMESPACE and IDENTITY values the aggregator can know that they refer
/// to the same person.
///
///
class ContactsContract_CommonDataKinds_Identity extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$Identity");
  ContactsContract_CommonDataKinds_Identity.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/identity";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String IDENTITY
  ///
  /// The identity string.
  /// <P>Type: TEXT</P>
  static const IDENTITY = "data1";

  /// from: static public final java.lang.String NAMESPACE
  ///
  /// The namespace of the identity string, e.g.&nbsp;"com.google"
  /// <P>Type: TEXT</P>
  static const NAMESPACE = "data2";
}

/// from: android.provider.ContactsContract$CommonDataKinds$GroupMembership
///
///
/// Group Membership.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#GROUP_ROW_ID</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#GROUP_SOURCE_ID</td>
/// <td>none</td>
/// <td>
///
/// The sourceid of the group that this group membership refers to.
/// Exactly one of this or \#GROUP_ROW_ID must be set when
/// inserting a row.
///
///
///
/// If this field is specified, the provider will first try to
/// look up a group with this Groups Groups.SOURCE_ID.  If such a group
/// is found, it will use the corresponding row id.  If the group is not
/// found, it will create one.
/// </td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_GroupMembership extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$GroupMembership");
  ContactsContract_CommonDataKinds_GroupMembership.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/group_membership";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String GROUP_ROW_ID
  ///
  /// The row id of the group that this group membership refers to. Exactly one of
  /// this or \#GROUP_SOURCE_ID must be set when inserting a row.
  /// <P>Type: INTEGER</P>
  static const GROUP_ROW_ID = "data1";

  /// from: static public final java.lang.String GROUP_SOURCE_ID
  ///
  /// The sourceid of the group that this group membership refers to.  Exactly one of
  /// this or \#GROUP_ROW_ID must be set when inserting a row.
  /// <P>Type: TEXT</P>
  static const GROUP_SOURCE_ID = "group_sourceid";
}

/// from: android.provider.ContactsContract$CommonDataKinds$Event
///
///
/// A data kind representing an event.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#START_DATE</td>
/// <td>\#DATA1</td>
/// <td></td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_ANNIVERSARY</li>
/// <li>\#TYPE_OTHER</li>
/// <li>\#TYPE_BIRTHDAY</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Event extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$CommonDataKinds\$Event");
  ContactsContract_CommonDataKinds_Event.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/contact_event";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String START_DATE
  ///
  /// The event start date as the user entered it.
  /// <P>Type: TEXT</P>
  static const START_DATE = "data1";

  /// from: static public final int TYPE_ANNIVERSARY
  static const TYPE_ANNIVERSARY = 1;

  /// from: static public final int TYPE_BIRTHDAY
  static const TYPE_BIRTHDAY = 3;

  /// from: static public final int TYPE_OTHER
  static const TYPE_OTHER = 2;

  static final _id_getTypeResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTypeResource", "(Ljava/lang/Integer;)I");

  /// from: static public int getTypeResource(java.lang.Integer type)
  ///
  /// Return the string resource that best describes the given
  /// \#TYPE. Will always return a valid resource.
  static int getTypeResource(jni.JniObject type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTypeResource,
          jni.JniType.intType, [type.reference]).integer;

  static final _id_getTypeLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getTypeLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getTypeLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given type,
  /// possibly substituting the given \#LABEL value
  /// for \#TYPE_CUSTOM.
  static jni.JniObject getTypeLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTypeLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$Email
///
///
/// A data kind representing an email address.
///
///
///
/// You can use all columns defined for ContactsContract.Data as
/// well as the following aliases.
///
///
/// <h2>Column aliases</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th>Type</th>
/// <th>Alias</th><th colspan='2'>Data column</th>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#ADDRESS</td>
/// <td>\#DATA1</td>
/// <td>Email address itself.</td>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>\#DATA2</td>
/// <td>Allowed values are:
///
/// <ul>
/// <li>\#TYPE_CUSTOM. Put the actual type in \#LABEL.</li>
/// <li>\#TYPE_HOME</li>
/// <li>\#TYPE_WORK</li>
/// <li>\#TYPE_OTHER</li>
/// <li>\#TYPE_MOBILE</li>
/// </ul>
///
///
/// </td>
/// </tr>
/// <tr>
/// <td>String</td>
/// <td>\#LABEL</td>
/// <td>\#DATA3</td>
/// <td></td>
/// </tr>
/// </table>
class ContactsContract_CommonDataKinds_Email extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$CommonDataKinds\$Email");
  ContactsContract_CommonDataKinds_Email.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String ADDRESS
  ///
  /// The email address.
  /// <P>Type: TEXT</P>
  static const ADDRESS = "data1";

  static final _id_CONTENT_FILTER_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  /// The content:// style URL for email lookup using a filter. The filter returns
  /// records of MIME type \#CONTENT_ITEM_TYPE. The filter is applied
  /// to display names as well as email addresses. The filter argument should be passed
  /// as an additional path segment after this URI.
  ///
  ///
  /// The query in the following example will return "Robert Parr (bob@incredibles.com)"
  /// as well as "Bob Parr (incredible@android.com)".
  /// <pre>
  /// Uri uri = Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode("bob"));
  /// Cursor c = getContentResolver().query(uri,
  ///          new String[]{Email.DISPLAY_NAME, Email.DATA},
  ///          null, null, null);
  /// </pre>
  ///
  ///
  static uri_.Uri get CONTENT_FILTER_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_FILTER_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// MIME type used when storing this in data table.
  static const CONTENT_ITEM_TYPE = "vnd.android.cursor.item/email_v2";

  static final _id_CONTENT_LOOKUP_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_LOOKUP_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_LOOKUP_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  /// The content:// style URL for looking up data rows by email address. The
  /// lookup argument, an email address, should be passed as an additional path segment
  /// after this URI.
  ///
  ///
  /// Example:
  /// <pre>
  /// Uri uri = Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(email));
  /// Cursor c = getContentResolver().query(uri,
  ///          new String[]{Email.CONTACT_ID, Email.DISPLAY_NAME, Email.DATA},
  ///          null, null, null);
  /// </pre>
  ///
  ///
  static uri_.Uri get CONTENT_LOOKUP_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_LOOKUP_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI providing a directory of email addresses.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/email_v2";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for all data records of the
  /// \#CONTENT_ITEM_TYPE MIME type, combined with the
  /// associated raw contact and aggregate contact data.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String DISPLAY_NAME
  ///
  /// The display name for the email address
  /// <P>Type: TEXT</P>
  static const DISPLAY_NAME = "data4";

  static final _id_ENTERPRISE_CONTENT_FILTER_URI =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENTERPRISE_CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri ENTERPRISE_CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// It supports the similar semantics as \#CONTENT_FILTER_URI and returns the same
  /// columns. This URI requires ContactsContract\#DIRECTORY_PARAM_KEY in
  /// parameters, otherwise it will throw IllegalArgumentException.
  static uri_.Uri get ENTERPRISE_CONTENT_FILTER_URI => uri_.Uri.fromRef(
      jniAccessors
          .getStaticField(_classRef, _id_ENTERPRISE_CONTENT_FILTER_URI,
              jni.JniType.objectType)
          .object);

  static final _id_ENTERPRISE_CONTENT_LOOKUP_URI =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENTERPRISE_CONTENT_LOOKUP_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri ENTERPRISE_CONTENT_LOOKUP_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// URI used for enterprise email lookup.
  ///
  ///
  ///
  /// It supports the same semantics as \#CONTENT_LOOKUP_URI and returns the same
  /// columns.  If the device has no corp profile that is linked to the current profile, it
  /// behaves in the exact same way as \#CONTENT_LOOKUP_URI.  If there is a
  /// corp profile linked to the current profile, it first queries against the personal contact database,
  /// and if no matching contacts are found there, then queries against the
  /// corp contacts database.
  ///
  ///
  ///
  /// If a result is from the corp profile, it makes the following changes to the data:
  /// <ul>
  ///     <li>
  ///     \#PHOTO_THUMBNAIL_URI and \#PHOTO_URI will be rewritten to special
  ///     URIs.  Use ContentResolver\#openAssetFileDescriptor or its siblings to
  ///     load pictures from them.
  ///     \#PHOTO_ID and \#PHOTO_FILE_ID will be set to null.  Do not
  ///     use them.
  ///     </li>
  ///     <li>
  ///     Corp contacts will get artificial \#CONTACT_IDs.  In order to tell whether
  ///     a contact
  ///     is from the corp profile, use
  ///     ContactsContract.Contacts\#isEnterpriseContactId(long).
  ///     </li>
  ///     <li>
  ///     Corp contacts will get artificial \#LOOKUP_KEYs too.
  ///     </li>
  ///     <li>
  ///     Returned work contact IDs and lookup keys are not accepted in places that not
  ///     explicitly say to accept them.
  ///     </li>
  /// </ul>
  ///
  /// A contact lookup URL built by
  /// ContactsContract.Contacts\#getLookupUri(long, String)
  /// with an \#_ID and a \#LOOKUP_KEY returned by this API can be passed to
  /// ContactsContract.QuickContact\#showQuickContact even if a contact is from the
  /// corp profile.
  ///
  ///
  ///
  /// <pre>
  /// Uri lookupUri = Uri.withAppendedPath(Email.ENTERPRISE_CONTENT_LOOKUP_URI,
  ///         Uri.encode(email));
  /// </pre>
  static uri_.Uri get ENTERPRISE_CONTENT_LOOKUP_URI => uri_.Uri.fromRef(
      jniAccessors
          .getStaticField(_classRef, _id_ENTERPRISE_CONTENT_LOOKUP_URI,
              jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 1;

  /// from: static public final int TYPE_MOBILE
  static const TYPE_MOBILE = 4;

  /// from: static public final int TYPE_OTHER
  static const TYPE_OTHER = 3;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 2;

  static final _id_getTypeLabelResource = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTypeLabelResource", "(I)I");

  /// from: static public int getTypeLabelResource(int type)
  ///
  /// Return the string resource that best describes the given
  /// \#TYPE. Will always return a valid resource.
  static int getTypeLabelResource(int type) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTypeLabelResource,
          jni.JniType.intType, [type]).integer;

  static final _id_getTypeLabel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getTypeLabel",
      "(Landroid/content/res/Resources;ILjava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getTypeLabel(android.content.res.Resources res, int type, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a CharSequence that best describes the given type,
  /// possibly substituting the given \#LABEL value
  /// for \#TYPE_CUSTOM.
  static jni.JniObject getTypeLabel(
          resources_.Resources res, int type, jni.JniObject label) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTypeLabel,
          jni.JniType.objectType,
          [res.reference, type, label.reference]).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$Contactables
///
/// A special class of data items, used to refer to types of data that can be used to attempt
/// to start communicating with a person (Phone and Email). Note that this
/// is NOT a separate data kind.
///
/// This URI allows the ContactsProvider to return a unified result for data items that users
/// can use to initiate communications with another contact. Phone and Email
/// are the current data types in this category.
class ContactsContract_CommonDataKinds_Contactables extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$Contactables");
  ContactsContract_CommonDataKinds_Contactables.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CONTENT_FILTER_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for these data items, which allows for a query parameter to
  /// be appended onto the end to filter for data items matching the query.
  static uri_.Uri get CONTENT_FILTER_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_FILTER_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for these data items, which requests a directory of data
  /// rows matching the selection criteria.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  /// from: static public final java.lang.String VISIBLE_CONTACTS_ONLY
  ///
  /// A boolean parameter for Data\#CONTENT_URI.
  /// This specifies whether or not the returned data items should be filtered to show
  /// data items belonging to visible contacts only.
  static const VISIBLE_CONTACTS_ONLY = "visible_contacts_only";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_CommonDataKinds_Contactables()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$CommonColumns
///
/// Columns common across the specific types.
class ContactsContract_CommonDataKinds_CommonColumns extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$CommonColumns");
  ContactsContract_CommonDataKinds_CommonColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String DATA
  ///
  /// The data for the contact method.
  /// <P>Type: TEXT</P>
  static const DATA = "data1";

  /// from: static public final java.lang.String LABEL
  ///
  /// The user defined label for the the contact method.
  /// <P>Type: TEXT</P>
  static const LABEL = "data3";

  /// from: static public final java.lang.String TYPE
  ///
  /// The type of data, for example Home or Work.
  /// <P>Type: INTEGER</P>
  static const TYPE = "data2";
}

/// from: android.provider.ContactsContract$CommonDataKinds$Callable
///
///
/// Convenient functionalities for "callable" data. Note that, this is NOT a separate data
/// kind.
///
///
///
/// This URI allows the ContactsProvider to return a unified result for "callable" data
/// that users can use for calling purposes. Phone and SipAddress are the
/// current examples for "callable", but may be expanded to the other types.
///
///
///
/// Each returned row may have a different MIMETYPE and thus different interpretation for
/// each column. For example the meaning for Phone's type is different than
/// SipAddress's.
///
///
class ContactsContract_CommonDataKinds_Callable extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$Callable");
  ContactsContract_CommonDataKinds_Callable.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CONTENT_FILTER_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Similar to Phone\#CONTENT_FILTER_URI, but allows users to filter callable
  /// data.
  static uri_.Uri get CONTENT_FILTER_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_FILTER_URI, jni.JniType.objectType)
      .object);

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Similar to Phone\#CONTENT_URI, but returns callable data instead of only
  /// phone numbers.
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  static final _id_ENTERPRISE_CONTENT_FILTER_URI =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENTERPRISE_CONTENT_FILTER_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri ENTERPRISE_CONTENT_FILTER_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Similar to Phone\#ENTERPRISE_CONTENT_FILTER_URI, but allows users to filter
  /// callable data. This URI requires ContactsContract\#DIRECTORY_PARAM_KEY in
  /// parameters, otherwise it will throw IllegalArgumentException.
  static uri_.Uri get ENTERPRISE_CONTENT_FILTER_URI => uri_.Uri.fromRef(
      jniAccessors
          .getStaticField(_classRef, _id_ENTERPRISE_CONTENT_FILTER_URI,
              jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX
  ///
  /// Add this query parameter to a URI to get back row counts grouped by the address book
  /// index as cursor extras. For most languages it is the first letter of the sort key. This
  /// parameter does not affect the main content of the cursor.
  ///
  ///
  /// <pre>
  /// Example:
  ///
  /// import android.provider.ContactsContract.Contacts;
  ///
  /// Uri uri = Contacts.CONTENT_URI.buildUpon()
  ///          .appendQueryParameter(Contacts.EXTRA_ADDRESS_BOOK_INDEX, "true")
  ///          .build();
  /// Cursor cursor = getContentResolver().query(uri,
  ///          new String[] {Contacts.DISPLAY_NAME},
  ///          null, null, null);
  /// Bundle bundle = cursor.getExtras();
  /// if (bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES) &&
  ///         bundle.containsKey(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS)) {
  ///     String sections[] =
  ///             bundle.getStringArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_TITLES);
  ///     int counts[] = bundle.getIntArray(Contacts.EXTRA_ADDRESS_BOOK_INDEX_COUNTS);
  /// }
  /// </pre>
  ///
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX =
      "android.provider.extra.ADDRESS_BOOK_INDEX";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_COUNTS
  ///
  /// The array of group counts for the corresponding group.  Contains the same number
  /// of elements as the EXTRA_ADDRESS_BOOK_INDEX_TITLES array.
  /// TYPE: int[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_COUNTS =
      "android.provider.extra.ADDRESS_BOOK_INDEX_COUNTS";

  /// from: static public final java.lang.String EXTRA_ADDRESS_BOOK_INDEX_TITLES
  ///
  /// The array of address book index titles, which are returned in the
  /// same order as the data in the cursor.
  /// TYPE: String[]
  ///
  static const EXTRA_ADDRESS_BOOK_INDEX_TITLES =
      "android.provider.extra.ADDRESS_BOOK_INDEX_TITLES";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContactsContract_CommonDataKinds_Callable()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.provider.ContactsContract$CommonDataKinds$BaseTypes
///
/// The base types that all "Typed" data kinds support.
class ContactsContract_CommonDataKinds_BaseTypes extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/provider/ContactsContract\$CommonDataKinds\$BaseTypes");
  ContactsContract_CommonDataKinds_BaseTypes.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int TYPE_CUSTOM
  ///
  /// A custom type. The custom label should be supplied by user.
  static const TYPE_CUSTOM = 0;
}

/// from: android.provider.ContactsContract$BaseSyncColumns
///
/// Generic columns for use by sync adapters. The specific functions of
/// these columns are private to the sync adapter. Other clients of the API
/// should not attempt to either read or write this column.
///@see RawContacts
///@see Groups
class ContactsContract_BaseSyncColumns extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$BaseSyncColumns");
  ContactsContract_BaseSyncColumns.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String SYNC1
  ///
  /// Generic column for use by sync adapters.
  static const SYNC1 = "sync1";

  /// from: static public final java.lang.String SYNC2
  ///
  /// Generic column for use by sync adapters.
  static const SYNC2 = "sync2";

  /// from: static public final java.lang.String SYNC3
  ///
  /// Generic column for use by sync adapters.
  static const SYNC3 = "sync3";

  /// from: static public final java.lang.String SYNC4
  ///
  /// Generic column for use by sync adapters.
  static const SYNC4 = "sync4";
}

/// from: android.provider.ContactsContract$AggregationExceptions
///
///
/// Constants for the contact aggregation exceptions table, which contains
/// aggregation rules overriding those used by automatic aggregation. This
/// type only supports query and update. Neither insert nor delete are
/// supported.
///
///
/// <h2>Columns</h2>
/// <table class="jd-sumtable">
/// <tr>
/// <th colspan='4'>AggregationExceptions</th>
/// </tr>
/// <tr>
/// <td>int</td>
/// <td>\#TYPE</td>
/// <td>read/write</td>
/// <td>The type of exception: \#TYPE_KEEP_TOGETHER,
/// \#TYPE_KEEP_SEPARATE or \#TYPE_AUTOMATIC.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#RAW_CONTACT_ID1</td>
/// <td>read/write</td>
/// <td>A reference to the RawContacts\#_ID of the raw contact that
/// the rule applies to.</td>
/// </tr>
/// <tr>
/// <td>long</td>
/// <td>\#RAW_CONTACT_ID2</td>
/// <td>read/write</td>
/// <td>A reference to the other RawContacts\#_ID of the raw contact
/// that the rule applies to.</td>
/// </tr>
/// </table>
class ContactsContract_AggregationExceptions extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/provider/ContactsContract\$AggregationExceptions");
  ContactsContract_AggregationExceptions.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final java.lang.String CONTENT_ITEM_TYPE
  ///
  /// The MIME type of a \#CONTENT_URI subdirectory of an aggregation exception
  static const CONTENT_ITEM_TYPE =
      "vnd.android.cursor.item/aggregation_exception";

  /// from: static public final java.lang.String CONTENT_TYPE
  ///
  /// The MIME type of \#CONTENT_URI providing a directory of data.
  static const CONTENT_TYPE = "vnd.android.cursor.dir/aggregation_exception";

  static final _id_CONTENT_URI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CONTENT_URI", "Landroid/net/Uri;");

  /// from: static public final android.net.Uri CONTENT_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The content:// style URI for this table
  static uri_.Uri get CONTENT_URI => uri_.Uri.fromRef(jniAccessors
      .getStaticField(_classRef, _id_CONTENT_URI, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String RAW_CONTACT_ID1
  ///
  /// A reference to the RawContacts\#_ID of the raw contact that the rule applies to.
  static const RAW_CONTACT_ID1 = "raw_contact_id1";

  /// from: static public final java.lang.String RAW_CONTACT_ID2
  ///
  /// A reference to the other RawContacts\#_ID of the raw contact that the rule
  /// applies to.
  static const RAW_CONTACT_ID2 = "raw_contact_id2";

  /// from: static public final java.lang.String TYPE
  ///
  /// The type of exception: \#TYPE_KEEP_TOGETHER, \#TYPE_KEEP_SEPARATE or
  /// \#TYPE_AUTOMATIC.
  ///
  /// <P>Type: INTEGER</P>
  static const TYPE = "type";

  /// from: static public final int TYPE_AUTOMATIC
  ///
  /// Allows the provider to automatically decide whether the specified raw contacts should
  /// be included in the same aggregate contact or not.
  static const TYPE_AUTOMATIC = 0;

  /// from: static public final int TYPE_KEEP_SEPARATE
  ///
  /// Makes sure that the specified raw contacts are NOT included in the same
  /// aggregate contact.
  static const TYPE_KEEP_SEPARATE = 2;

  /// from: static public final int TYPE_KEEP_TOGETHER
  ///
  /// Makes sure that the specified raw contacts are included in the same
  /// aggregate contact.
  static const TYPE_KEEP_TOGETHER = 1;
}
