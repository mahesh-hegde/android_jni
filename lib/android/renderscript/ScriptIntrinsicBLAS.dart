// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ScriptIntrinsic.dart" as scriptintrinsic_;

import "RenderScript.dart" as renderscript_;

import "Allocation.dart" as allocation_;

import "Float2.dart" as float2_;

import "Double2.dart" as double2_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.renderscript.ScriptIntrinsicBLAS
///
/// ScriptIntrinsicBLAS class provides high performance RenderScript APIs to BLAS.
///
/// The BLAS (Basic Linear Algebra Subprograms) are routines that provide standard
/// building blocks for performing basic vector and matrix operations.
///
/// For detailed description of BLAS, please refer to http://www.netlib.org/blas/
class ScriptIntrinsicBLAS extends scriptintrinsic_.ScriptIntrinsic {
  static final _classRef =
      jniAccessors.getClassOf("android/renderscript/ScriptIntrinsicBLAS");
  ScriptIntrinsicBLAS.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CONJ_TRANSPOSE
  static const CONJ_TRANSPOSE = 113;

  /// from: static public final int LEFT
  static const LEFT = 141;

  /// from: static public final int LOWER
  static const LOWER = 122;

  /// from: static public final int NON_UNIT
  static const NON_UNIT = 131;

  /// from: static public final int NO_TRANSPOSE
  static const NO_TRANSPOSE = 111;

  /// from: static public final int RIGHT
  static const RIGHT = 142;

  /// from: static public final int TRANSPOSE
  static const TRANSPOSE = 112;

  /// from: static public final int UNIT
  static const UNIT = 132;

  /// from: static public final int UPPER
  static const UPPER = 121;

  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/renderscript/RenderScript;)Landroid/renderscript/ScriptIntrinsicBLAS;");

  /// from: static public android.renderscript.ScriptIntrinsicBLAS create(android.renderscript.RenderScript rs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intrinsic to access BLAS subroutines.
  ///@param rs The RenderScript context
  ///@return ScriptIntrinsicBLAS
  static ScriptIntrinsicBLAS create(renderscript_.RenderScript rs) =>
      ScriptIntrinsicBLAS.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create,
          jni.JniType.objectType,
          [rs.reference]).object);

  static final _id_SGEMV = jniAccessors.getMethodIDOf(_classRef, "SGEMV",
      "(IFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IFLandroid/renderscript/Allocation;I)V");

  /// from: public void SGEMV(int TransA, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, float beta, android.renderscript.Allocation Y, int incY)
  ///
  /// SGEMV performs one of the matrix-vector operations
  /// y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/d58/sgemv_8f.html
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void SGEMV(
          int TransA,
          double alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SGEMV, jni.JniType.voidType, [
        TransA,
        alpha,
        A.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_DGEMV = jniAccessors.getMethodIDOf(_classRef, "DGEMV",
      "(IDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IDLandroid/renderscript/Allocation;I)V");

  /// from: public void DGEMV(int TransA, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, double beta, android.renderscript.Allocation Y, int incY)
  ///
  /// DGEMV performs one of the matrix-vector operations
  /// y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dc/da8/dgemv_8f.html
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void DGEMV(
          int TransA,
          double alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DGEMV, jni.JniType.voidType, [
        TransA,
        alpha,
        A.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_CGEMV = jniAccessors.getMethodIDOf(_classRef, "CGEMV",
      "(ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;I)V");

  /// from: public void CGEMV(int TransA, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, android.renderscript.Float2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// CGEMV performs one of the matrix-vector operations
  /// y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y   or   y := alpha*A**H*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d4/d8a/cgemv_8f.html
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void CGEMV(
          int TransA,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          float2_.Float2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CGEMV, jni.JniType.voidType, [
        TransA,
        alpha.reference,
        A.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_ZGEMV = jniAccessors.getMethodIDOf(_classRef, "ZGEMV",
      "(ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZGEMV(int TransA, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, android.renderscript.Double2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// ZGEMV performs one of the matrix-vector operations
  /// y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y   or   y := alpha*A**H*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/d40/zgemv_8f.html
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void ZGEMV(
          int TransA,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double2_.Double2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZGEMV, jni.JniType.voidType, [
        TransA,
        alpha.reference,
        A.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_SGBMV = jniAccessors.getMethodIDOf(_classRef, "SGBMV",
      "(IIIFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IFLandroid/renderscript/Allocation;I)V");

  /// from: public void SGBMV(int TransA, int KL, int KU, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, float beta, android.renderscript.Allocation Y, int incY)
  ///
  /// SGBMV performs one of the matrix-vector operations
  /// y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d6/d46/sgbmv_8f.html
  ///
  /// Note: For a M*N matrix, the input Allocation should also be of size M*N (dimY = M, dimX = N),
  ///       but only the region M*(KL+KU+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert the original matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, m):
  ///              for j in range(max(0, i-kl), min(i+ku+1, n)):
  ///                  b[i, j-i+kl] = a[i, j]
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param KL The number of sub-diagonals of the matrix A.
  ///@param KU The number of super-diagonals of the matrix A.
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains the band matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void SGBMV(
          int TransA,
          int KL,
          int KU,
          double alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SGBMV, jni.JniType.voidType, [
        TransA,
        KL,
        KU,
        alpha,
        A.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_DGBMV = jniAccessors.getMethodIDOf(_classRef, "DGBMV",
      "(IIIDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IDLandroid/renderscript/Allocation;I)V");

  /// from: public void DGBMV(int TransA, int KL, int KU, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, double beta, android.renderscript.Allocation Y, int incY)
  ///
  /// DGBMV performs one of the matrix-vector operations
  /// y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d2/d3f/dgbmv_8f.html
  ///
  /// Note: For a M*N matrix, the input Allocation should also be of size M*N (dimY = M, dimX = N),
  ///       but only the region M*(KL+KU+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert the original matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, m):
  ///              for j in range(max(0, i-kl), min(i+ku+1, n)):
  ///                  b[i, j-i+kl] = a[i, j]
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param KL The number of sub-diagonals of the matrix A.
  ///@param KU The number of super-diagonals of the matrix A.
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains the band matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void DGBMV(
          int TransA,
          int KL,
          int KU,
          double alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DGBMV, jni.JniType.voidType, [
        TransA,
        KL,
        KU,
        alpha,
        A.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_CGBMV = jniAccessors.getMethodIDOf(_classRef, "CGBMV",
      "(IIILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;I)V");

  /// from: public void CGBMV(int TransA, int KL, int KU, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, android.renderscript.Float2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// CGBMV performs one of the matrix-vector operations
  /// y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y   or   y := alpha*A**H*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d0/d75/cgbmv_8f.html
  ///
  /// Note: For a M*N matrix, the input Allocation should also be of size M*N (dimY = M, dimX = N),
  ///       but only the region M*(KL+KU+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert the original matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, m):
  ///              for j in range(max(0, i-kl), min(i+ku+1, n)):
  ///                  b[i, j-i+kl] = a[i, j]
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param KL The number of sub-diagonals of the matrix A.
  ///@param KU The number of super-diagonals of the matrix A.
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains the band matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void CGBMV(
          int TransA,
          int KL,
          int KU,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          float2_.Float2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CGBMV, jni.JniType.voidType, [
        TransA,
        KL,
        KU,
        alpha.reference,
        A.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_ZGBMV = jniAccessors.getMethodIDOf(_classRef, "ZGBMV",
      "(IIILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZGBMV(int TransA, int KL, int KU, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, android.renderscript.Double2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// ZGBMV performs one of the matrix-vector operations
  /// y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y   or   y := alpha*A**H*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d9/d46/zgbmv_8f.html
  ///
  /// Note: For a M*N matrix, the input Allocation should also be of size M*N (dimY = M, dimX = N),
  ///       but only the region M*(KL+KU+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert the original matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, m):
  ///              for j in range(max(0, i-kl), min(i+ku+1, n)):
  ///                  b[i, j-i+kl] = a[i, j]
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param KL The number of sub-diagonals of the matrix A.
  ///@param KU The number of super-diagonals of the matrix A.
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains the band matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void ZGBMV(
          int TransA,
          int KL,
          int KU,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double2_.Double2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZGBMV, jni.JniType.voidType, [
        TransA,
        KL,
        KU,
        alpha.reference,
        A.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_STRMV = jniAccessors.getMethodIDOf(_classRef, "STRMV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void STRMV(int Uplo, int TransA, int Diag, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// STRMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/de/d45/strmv_8f.html
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void STRMV(int Uplo, int TransA, int Diag, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_STRMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, A.reference, X.reference, incX]).check();

  static final _id_DTRMV = jniAccessors.getMethodIDOf(_classRef, "DTRMV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void DTRMV(int Uplo, int TransA, int Diag, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// DTRMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dc/d7e/dtrmv_8f.html
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void DTRMV(int Uplo, int TransA, int Diag, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DTRMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, A.reference, X.reference, incX]).check();

  static final _id_CTRMV = jniAccessors.getMethodIDOf(_classRef, "CTRMV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void CTRMV(int Uplo, int TransA, int Diag, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// CTRMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x   or   x := A**H*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/df/d78/ctrmv_8f.html
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void CTRMV(int Uplo, int TransA, int Diag, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_CTRMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, A.reference, X.reference, incX]).check();

  static final _id_ZTRMV = jniAccessors.getMethodIDOf(_classRef, "ZTRMV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZTRMV(int Uplo, int TransA, int Diag, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// ZTRMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x   or   x := A**H*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d0/dd1/ztrmv_8f.html
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void ZTRMV(int Uplo, int TransA, int Diag, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_ZTRMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, A.reference, X.reference, incX]).check();

  static final _id_STBMV = jniAccessors.getMethodIDOf(_classRef, "STBMV",
      "(IIIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void STBMV(int Uplo, int TransA, int Diag, int K, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// STBMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d6/d7d/stbmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param K The number of off-diagonals of the matrix A
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void STBMV(int Uplo, int TransA, int Diag, int K, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_STBMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, K, A.reference, X.reference, incX]).check();

  static final _id_DTBMV = jniAccessors.getMethodIDOf(_classRef, "DTBMV",
      "(IIIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void DTBMV(int Uplo, int TransA, int Diag, int K, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// DTBMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/df/d29/dtbmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param K The number of off-diagonals of the matrix A
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void DTBMV(int Uplo, int TransA, int Diag, int K, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DTBMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, K, A.reference, X.reference, incX]).check();

  static final _id_CTBMV = jniAccessors.getMethodIDOf(_classRef, "CTBMV",
      "(IIIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void CTBMV(int Uplo, int TransA, int Diag, int K, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// CTBMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x   or   x := A**H*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/dcd/ctbmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param K The number of off-diagonals of the matrix A
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void CTBMV(int Uplo, int TransA, int Diag, int K, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_CTBMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, K, A.reference, X.reference, incX]).check();

  static final _id_ZTBMV = jniAccessors.getMethodIDOf(_classRef, "ZTBMV",
      "(IIIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZTBMV(int Uplo, int TransA, int Diag, int K, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// ZTBMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x   or   x := A**H*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/d39/ztbmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param K The number of off-diagonals of the matrix A
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void ZTBMV(int Uplo, int TransA, int Diag, int K, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_ZTBMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, K, A.reference, X.reference, incX]).check();

  static final _id_STPMV = jniAccessors.getMethodIDOf(_classRef, "STPMV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void STPMV(int Uplo, int TransA, int Diag, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX)
  ///
  /// STPMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/db1/stpmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param Ap The input allocation contains packed matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void STPMV(int Uplo, int TransA, int Diag, allocation_.Allocation Ap,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_STPMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, Ap.reference, X.reference, incX]).check();

  static final _id_DTPMV = jniAccessors.getMethodIDOf(_classRef, "DTPMV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void DTPMV(int Uplo, int TransA, int Diag, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX)
  ///
  /// DTPMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dc/dcd/dtpmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param Ap The input allocation contains packed matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void DTPMV(int Uplo, int TransA, int Diag, allocation_.Allocation Ap,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DTPMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, Ap.reference, X.reference, incX]).check();

  static final _id_CTPMV = jniAccessors.getMethodIDOf(_classRef, "CTPMV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void CTPMV(int Uplo, int TransA, int Diag, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX)
  ///
  /// CTPMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x   or   x := A**H*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d4/dbb/ctpmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param Ap The input allocation contains packed matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void CTPMV(int Uplo, int TransA, int Diag, allocation_.Allocation Ap,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_CTPMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, Ap.reference, X.reference, incX]).check();

  static final _id_ZTPMV = jniAccessors.getMethodIDOf(_classRef, "ZTPMV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZTPMV(int Uplo, int TransA, int Diag, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX)
  ///
  /// ZTPMV performs one of the matrix-vector operations
  /// x := A*x   or   x := A**T*x   or   x := A**H*x
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d2/d9e/ztpmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param Ap The input allocation contains packed matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void ZTPMV(int Uplo, int TransA, int Diag, allocation_.Allocation Ap,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_ZTPMV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, Ap.reference, X.reference, incX]).check();

  static final _id_STRSV = jniAccessors.getMethodIDOf(_classRef, "STRSV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void STRSV(int Uplo, int TransA, int Diag, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// STRSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d0/d2a/strsv_8f.html
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void STRSV(int Uplo, int TransA, int Diag, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_STRSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, A.reference, X.reference, incX]).check();

  static final _id_DTRSV = jniAccessors.getMethodIDOf(_classRef, "DTRSV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void DTRSV(int Uplo, int TransA, int Diag, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// DTRSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d6/d96/dtrsv_8f.html
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void DTRSV(int Uplo, int TransA, int Diag, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DTRSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, A.reference, X.reference, incX]).check();

  static final _id_CTRSV = jniAccessors.getMethodIDOf(_classRef, "CTRSV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void CTRSV(int Uplo, int TransA, int Diag, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// CTRSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b   or   A**H*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d4/dc8/ctrsv_8f.html
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void CTRSV(int Uplo, int TransA, int Diag, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_CTRSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, A.reference, X.reference, incX]).check();

  static final _id_ZTRSV = jniAccessors.getMethodIDOf(_classRef, "ZTRSV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZTRSV(int Uplo, int TransA, int Diag, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// ZTRSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b   or   A**H*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d1/d2f/ztrsv_8f.html
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void ZTRSV(int Uplo, int TransA, int Diag, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_ZTRSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, A.reference, X.reference, incX]).check();

  static final _id_STBSV = jniAccessors.getMethodIDOf(_classRef, "STBSV",
      "(IIIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void STBSV(int Uplo, int TransA, int Diag, int K, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// STBSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d0/d1f/stbsv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param K The number of off-diagonals of the matrix A
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void STBSV(int Uplo, int TransA, int Diag, int K, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_STBSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, K, A.reference, X.reference, incX]).check();

  static final _id_DTBSV = jniAccessors.getMethodIDOf(_classRef, "DTBSV",
      "(IIIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void DTBSV(int Uplo, int TransA, int Diag, int K, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// DTBSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d4/dcf/dtbsv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param K The number of off-diagonals of the matrix A
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void DTBSV(int Uplo, int TransA, int Diag, int K, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DTBSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, K, A.reference, X.reference, incX]).check();

  static final _id_CTBSV = jniAccessors.getMethodIDOf(_classRef, "CTBSV",
      "(IIIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void CTBSV(int Uplo, int TransA, int Diag, int K, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// CTBSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b   or   A**H*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d9/d5f/ctbsv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param K The number of off-diagonals of the matrix A
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void CTBSV(int Uplo, int TransA, int Diag, int K, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_CTBSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, K, A.reference, X.reference, incX]).check();

  static final _id_ZTBSV = jniAccessors.getMethodIDOf(_classRef, "ZTBSV",
      "(IIIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZTBSV(int Uplo, int TransA, int Diag, int K, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX)
  ///
  /// ZTBSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b   or   A**H*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d4/d5a/ztbsv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param K The number of off-diagonals of the matrix A
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void ZTBSV(int Uplo, int TransA, int Diag, int K, allocation_.Allocation A,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_ZTBSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, K, A.reference, X.reference, incX]).check();

  static final _id_STPSV = jniAccessors.getMethodIDOf(_classRef, "STPSV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void STPSV(int Uplo, int TransA, int Diag, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX)
  ///
  /// STPSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d0/d7c/stpsv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param Ap The input allocation contains packed matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void STPSV(int Uplo, int TransA, int Diag, allocation_.Allocation Ap,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_STPSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, Ap.reference, X.reference, incX]).check();

  static final _id_DTPSV = jniAccessors.getMethodIDOf(_classRef, "DTPSV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void DTPSV(int Uplo, int TransA, int Diag, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX)
  ///
  /// DTPSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d9/d84/dtpsv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param Ap The input allocation contains packed matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void DTPSV(int Uplo, int TransA, int Diag, allocation_.Allocation Ap,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DTPSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, Ap.reference, X.reference, incX]).check();

  static final _id_CTPSV = jniAccessors.getMethodIDOf(_classRef, "CTPSV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void CTPSV(int Uplo, int TransA, int Diag, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX)
  ///
  /// CTPSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b   or   A**H*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d8/d56/ctpsv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param Ap The input allocation contains packed matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void CTPSV(int Uplo, int TransA, int Diag, allocation_.Allocation Ap,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_CTPSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, Ap.reference, X.reference, incX]).check();

  static final _id_ZTPSV = jniAccessors.getMethodIDOf(_classRef, "ZTPSV",
      "(IIILandroid/renderscript/Allocation;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZTPSV(int Uplo, int TransA, int Diag, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX)
  ///
  /// ZTPSV solves one of the systems of equations
  /// A*x = b   or   A**T*x = b   or   A**H*x = b
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/da/d57/ztpsv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the matrix is an upper or lower triangular matrix.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param Ap The input allocation contains packed matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  void ZTPSV(int Uplo, int TransA, int Diag, allocation_.Allocation Ap,
          allocation_.Allocation X, int incX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_ZTPSV,
          jni.JniType.voidType,
          [Uplo, TransA, Diag, Ap.reference, X.reference, incX]).check();

  static final _id_SSYMV = jniAccessors.getMethodIDOf(_classRef, "SSYMV",
      "(IFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IFLandroid/renderscript/Allocation;I)V");

  /// from: public void SSYMV(int Uplo, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, float beta, android.renderscript.Allocation Y, int incY)
  ///
  /// SSYMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d2/d94/ssymv_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void SSYMV(
          int Uplo,
          double alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SSYMV, jni.JniType.voidType, [
        Uplo,
        alpha,
        A.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_SSBMV = jniAccessors.getMethodIDOf(_classRef, "SSBMV",
      "(IIFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IFLandroid/renderscript/Allocation;I)V");

  /// from: public void SSBMV(int Uplo, int K, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, float beta, android.renderscript.Allocation Y, int incY)
  ///
  /// SSBMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/da1/ssbmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part of the band matrix A is being supplied.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param K The number of off-diagonals of the matrix A
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void SSBMV(
          int Uplo,
          int K,
          double alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SSBMV, jni.JniType.voidType, [
        Uplo,
        K,
        alpha,
        A.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_SSPMV = jniAccessors.getMethodIDOf(_classRef, "SSPMV",
      "(IFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IFLandroid/renderscript/Allocation;I)V");

  /// from: public void SSPMV(int Uplo, float alpha, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX, float beta, android.renderscript.Allocation Y, int incY)
  ///
  /// SSPMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d8/d68/sspmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part of the matrix A is supplied in packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void SSPMV(
          int Uplo,
          double alpha,
          allocation_.Allocation Ap,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SSPMV, jni.JniType.voidType, [
        Uplo,
        alpha,
        Ap.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_SGER = jniAccessors.getMethodIDOf(_classRef, "SGER",
      "(FLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void SGER(float alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// SGER performs the rank 1 operation
  /// A := alpha*x*y**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/d5c/sger_8f.html
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  void SGER(double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(reference, _id_SGER, jni.JniType.voidType,
          [alpha, X.reference, incX, Y.reference, incY, A.reference]).check();

  static final _id_SSYR = jniAccessors.getMethodIDOf(_classRef, "SSYR",
      "(IFLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void SSYR(int Uplo, float alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation A)
  ///
  /// SSYR performs the rank 1 operation
  /// A := alpha*x*x**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d6/dac/ssyr_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  void SSYR(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(reference, _id_SSYR, jni.JniType.voidType,
          [Uplo, alpha, X.reference, incX, A.reference]).check();

  static final _id_SSPR = jniAccessors.getMethodIDOf(_classRef, "SSPR",
      "(IFLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void SSPR(int Uplo, float alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Ap)
  ///
  /// SSPR performs the rank 1 operation
  /// A := alpha*x*x**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d2/d9b/sspr_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F32.
  void SSPR(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Ap) =>
      jniAccessors.callMethodWithArgs(reference, _id_SSPR, jni.JniType.voidType,
          [Uplo, alpha, X.reference, incX, Ap.reference]).check();

  static final _id_SSYR2 = jniAccessors.getMethodIDOf(_classRef, "SSYR2",
      "(IFLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void SSYR2(int Uplo, float alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// SSYR2 performs the symmetric rank 2 operation
  /// A := alpha*x*y**T + alpha*y*x**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/d99/ssyr2_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  void SSYR2(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SSYR2, jni.JniType.voidType, [
        Uplo,
        alpha,
        X.reference,
        incX,
        Y.reference,
        incY,
        A.reference
      ]).check();

  static final _id_SSPR2 = jniAccessors.getMethodIDOf(_classRef, "SSPR2",
      "(IFLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void SSPR2(int Uplo, float alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation Ap)
  ///
  /// SSPR2 performs the symmetric rank 2 operation
  /// A := alpha*x*y**T + alpha*y*x**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/d3e/sspr2_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F32.
  void SSPR2(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation Ap) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SSPR2, jni.JniType.voidType, [
        Uplo,
        alpha,
        X.reference,
        incX,
        Y.reference,
        incY,
        Ap.reference
      ]).check();

  static final _id_DSYMV = jniAccessors.getMethodIDOf(_classRef, "DSYMV",
      "(IDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IDLandroid/renderscript/Allocation;I)V");

  /// from: public void DSYMV(int Uplo, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, double beta, android.renderscript.Allocation Y, int incY)
  ///
  /// DSYMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d8/dbe/dsymv_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void DSYMV(
          int Uplo,
          double alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DSYMV, jni.JniType.voidType, [
        Uplo,
        alpha,
        A.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_DSBMV = jniAccessors.getMethodIDOf(_classRef, "DSBMV",
      "(IIDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IDLandroid/renderscript/Allocation;I)V");

  /// from: public void DSBMV(int Uplo, int K, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, double beta, android.renderscript.Allocation Y, int incY)
  ///
  /// DSBMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d8/d1e/dsbmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part of the band matrix A is being supplied.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param K The number of off-diagonals of the matrix A
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void DSBMV(
          int Uplo,
          int K,
          double alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DSBMV, jni.JniType.voidType, [
        Uplo,
        K,
        alpha,
        A.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_DSPMV = jniAccessors.getMethodIDOf(_classRef, "DSPMV",
      "(IDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;IDLandroid/renderscript/Allocation;I)V");

  /// from: public void DSPMV(int Uplo, double alpha, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX, double beta, android.renderscript.Allocation Y, int incY)
  ///
  /// DSPMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d4/d85/dspmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part of the matrix A is supplied in packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void DSPMV(
          int Uplo,
          double alpha,
          allocation_.Allocation Ap,
          allocation_.Allocation X,
          int incX,
          double beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DSPMV, jni.JniType.voidType, [
        Uplo,
        alpha,
        Ap.reference,
        X.reference,
        incX,
        beta,
        Y.reference,
        incY
      ]).check();

  static final _id_DGER = jniAccessors.getMethodIDOf(_classRef, "DGER",
      "(DLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void DGER(double alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// DGER performs the rank 1 operation
  /// A := alpha*x*y**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dc/da8/dger_8f.html
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  void DGER(double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(reference, _id_DGER, jni.JniType.voidType,
          [alpha, X.reference, incX, Y.reference, incY, A.reference]).check();

  static final _id_DSYR = jniAccessors.getMethodIDOf(_classRef, "DSYR",
      "(IDLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void DSYR(int Uplo, double alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation A)
  ///
  /// DSYR performs the rank 1 operation
  /// A := alpha*x*x**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/d60/dsyr_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  void DSYR(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(reference, _id_DSYR, jni.JniType.voidType,
          [Uplo, alpha, X.reference, incX, A.reference]).check();

  static final _id_DSPR = jniAccessors.getMethodIDOf(_classRef, "DSPR",
      "(IDLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void DSPR(int Uplo, double alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Ap)
  ///
  /// DSPR performs the rank 1 operation
  /// A := alpha*x*x**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dd/dba/dspr_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F64.
  void DSPR(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Ap) =>
      jniAccessors.callMethodWithArgs(reference, _id_DSPR, jni.JniType.voidType,
          [Uplo, alpha, X.reference, incX, Ap.reference]).check();

  static final _id_DSYR2 = jniAccessors.getMethodIDOf(_classRef, "DSYR2",
      "(IDLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void DSYR2(int Uplo, double alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// DSYR2 performs the symmetric rank 2 operation
  /// A := alpha*x*y**T + alpha*y*x**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/de/d41/dsyr2_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  void DSYR2(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DSYR2, jni.JniType.voidType, [
        Uplo,
        alpha,
        X.reference,
        incX,
        Y.reference,
        incY,
        A.reference
      ]).check();

  static final _id_DSPR2 = jniAccessors.getMethodIDOf(_classRef, "DSPR2",
      "(IDLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void DSPR2(int Uplo, double alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation Ap)
  ///
  /// DSPR2 performs the symmetric rank 2 operation
  /// A := alpha*x*y**T + alpha*y*x**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dd/d9e/dspr2_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F64.
  void DSPR2(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation Ap) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DSPR2, jni.JniType.voidType, [
        Uplo,
        alpha,
        X.reference,
        incX,
        Y.reference,
        incY,
        Ap.reference
      ]).check();

  static final _id_CHEMV = jniAccessors.getMethodIDOf(_classRef, "CHEMV",
      "(ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;I)V");

  /// from: public void CHEMV(int Uplo, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, android.renderscript.Float2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// CHEMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d7/d51/chemv_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void CHEMV(
          int Uplo,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          float2_.Float2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CHEMV, jni.JniType.voidType, [
        Uplo,
        alpha.reference,
        A.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_CHBMV = jniAccessors.getMethodIDOf(_classRef, "CHBMV",
      "(IILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;I)V");

  /// from: public void CHBMV(int Uplo, int K, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, android.renderscript.Float2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// CHBMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/dc2/chbmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part of the band matrix A is being supplied.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param K The number of off-diagonals of the matrix A
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void CHBMV(
          int Uplo,
          int K,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          float2_.Float2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CHBMV, jni.JniType.voidType, [
        Uplo,
        K,
        alpha.reference,
        A.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_CHPMV = jniAccessors.getMethodIDOf(_classRef, "CHPMV",
      "(ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;I)V");

  /// from: public void CHPMV(int Uplo, android.renderscript.Float2 alpha, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX, android.renderscript.Float2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// CHPMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d2/d06/chpmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part of the matrix A is supplied in packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void CHPMV(
          int Uplo,
          float2_.Float2 alpha,
          allocation_.Allocation Ap,
          allocation_.Allocation X,
          int incX,
          float2_.Float2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CHPMV, jni.JniType.voidType, [
        Uplo,
        alpha.reference,
        Ap.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_CGERU = jniAccessors.getMethodIDOf(_classRef, "CGERU",
      "(Landroid/renderscript/Float2;Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void CGERU(android.renderscript.Float2 alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// CGERU performs the rank 1 operation
  /// A := alpha*x*y**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/d5f/cgeru_8f.html
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  void CGERU(float2_.Float2 alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_CGERU, jni.JniType.voidType, [
        alpha.reference,
        X.reference,
        incX,
        Y.reference,
        incY,
        A.reference
      ]).check();

  static final _id_CGERC = jniAccessors.getMethodIDOf(_classRef, "CGERC",
      "(Landroid/renderscript/Float2;Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void CGERC(android.renderscript.Float2 alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// CGERC performs the rank 1 operation
  /// A := alpha*x*y**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dd/d84/cgerc_8f.html
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  void CGERC(float2_.Float2 alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_CGERC, jni.JniType.voidType, [
        alpha.reference,
        X.reference,
        incX,
        Y.reference,
        incY,
        A.reference
      ]).check();

  static final _id_CHER = jniAccessors.getMethodIDOf(_classRef, "CHER",
      "(IFLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void CHER(int Uplo, float alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation A)
  ///
  /// CHER performs the rank 1 operation
  /// A := alpha*x*x**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/d6d/cher_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  void CHER(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(reference, _id_CHER, jni.JniType.voidType,
          [Uplo, alpha, X.reference, incX, A.reference]).check();

  static final _id_CHPR = jniAccessors.getMethodIDOf(_classRef, "CHPR",
      "(IFLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void CHPR(int Uplo, float alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Ap)
  ///
  /// CHPR performs the rank 1 operation
  /// A := alpha*x*x**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/dcd/chpr_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F32_2.
  void CHPR(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Ap) =>
      jniAccessors.callMethodWithArgs(reference, _id_CHPR, jni.JniType.voidType,
          [Uplo, alpha, X.reference, incX, Ap.reference]).check();

  static final _id_CHER2 = jniAccessors.getMethodIDOf(_classRef, "CHER2",
      "(ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void CHER2(int Uplo, android.renderscript.Float2 alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// CHER2 performs the symmetric rank 2 operation
  /// A := alpha*x*y**H + alpha*y*x**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/d87/cher2_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  void CHER2(int Uplo, float2_.Float2 alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_CHER2, jni.JniType.voidType, [
        Uplo,
        alpha.reference,
        X.reference,
        incX,
        Y.reference,
        incY,
        A.reference
      ]).check();

  static final _id_CHPR2 = jniAccessors.getMethodIDOf(_classRef, "CHPR2",
      "(ILandroid/renderscript/Float2;Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void CHPR2(int Uplo, android.renderscript.Float2 alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation Ap)
  ///
  /// CHPR2 performs the symmetric rank 2 operation
  /// A := alpha*x*y**H + alpha*y*x**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d6/d44/chpr2_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F32_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F32_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F32_2.
  void CHPR2(int Uplo, float2_.Float2 alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation Ap) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_CHPR2, jni.JniType.voidType, [
        Uplo,
        alpha.reference,
        X.reference,
        incX,
        Y.reference,
        incY,
        Ap.reference
      ]).check();

  static final _id_ZHEMV = jniAccessors.getMethodIDOf(_classRef, "ZHEMV",
      "(ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZHEMV(int Uplo, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, android.renderscript.Double2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// ZHEMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d0/ddd/zhemv_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void ZHEMV(
          int Uplo,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double2_.Double2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZHEMV, jni.JniType.voidType, [
        Uplo,
        alpha.reference,
        A.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_ZHBMV = jniAccessors.getMethodIDOf(_classRef, "ZHBMV",
      "(IILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZHBMV(int Uplo, int K, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation X, int incX, android.renderscript.Double2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// ZHBMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/d1a/zhbmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),
  ///       but only the region N*(K+1) will be referenced. The following subroutine can is an
  ///       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.
  ///           for i in range(0, n):
  ///              for j in range(i, min(i+k+1, n)):
  ///                  b[i, j-i] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part of the band matrix A is being supplied.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param K The number of off-diagonals of the matrix A
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void ZHBMV(
          int Uplo,
          int K,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation X,
          int incX,
          double2_.Double2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZHBMV, jni.JniType.voidType, [
        Uplo,
        K,
        alpha.reference,
        A.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_ZHPMV = jniAccessors.getMethodIDOf(_classRef, "ZHPMV",
      "(ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;I)V");

  /// from: public void ZHPMV(int Uplo, android.renderscript.Double2 alpha, android.renderscript.Allocation Ap, android.renderscript.Allocation X, int incX, android.renderscript.Double2 beta, android.renderscript.Allocation Y, int incY)
  ///
  /// ZHPMV performs the matrix-vector operation
  /// y := alpha*A*x + beta*y
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d0/d60/zhpmv_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part of the matrix A is supplied in packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param beta The scalar beta.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  void ZHPMV(
          int Uplo,
          double2_.Double2 alpha,
          allocation_.Allocation Ap,
          allocation_.Allocation X,
          int incX,
          double2_.Double2 beta,
          allocation_.Allocation Y,
          int incY) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZHPMV, jni.JniType.voidType, [
        Uplo,
        alpha.reference,
        Ap.reference,
        X.reference,
        incX,
        beta.reference,
        Y.reference,
        incY
      ]).check();

  static final _id_ZGERU = jniAccessors.getMethodIDOf(_classRef, "ZGERU",
      "(Landroid/renderscript/Double2;Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void ZGERU(android.renderscript.Double2 alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// ZGERU performs the rank 1 operation
  /// A := alpha*x*y**T + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d7/d12/zgeru_8f.html
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  void ZGERU(double2_.Double2 alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ZGERU, jni.JniType.voidType, [
        alpha.reference,
        X.reference,
        incX,
        Y.reference,
        incY,
        A.reference
      ]).check();

  static final _id_ZGERC = jniAccessors.getMethodIDOf(_classRef, "ZGERC",
      "(Landroid/renderscript/Double2;Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void ZGERC(android.renderscript.Double2 alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// ZGERC performs the rank 1 operation
  /// A := alpha*x*y**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/dad/zgerc_8f.html
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  void ZGERC(double2_.Double2 alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Y, int incY, allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ZGERC, jni.JniType.voidType, [
        alpha.reference,
        X.reference,
        incX,
        Y.reference,
        incY,
        A.reference
      ]).check();

  static final _id_ZHER = jniAccessors.getMethodIDOf(_classRef, "ZHER",
      "(IDLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void ZHER(int Uplo, double alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation A)
  ///
  /// ZHER performs the rank 1 operation
  /// A := alpha*x*x**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/de/d0e/zher_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  void ZHER(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(reference, _id_ZHER, jni.JniType.voidType,
          [Uplo, alpha, X.reference, incX, A.reference]).check();

  static final _id_ZHPR = jniAccessors.getMethodIDOf(_classRef, "ZHPR",
      "(IDLandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void ZHPR(int Uplo, double alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Ap)
  ///
  /// ZHPR performs the rank 1 operation
  /// A := alpha*x*x**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/de/de1/zhpr_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F64_2.
  void ZHPR(int Uplo, double alpha, allocation_.Allocation X, int incX,
          allocation_.Allocation Ap) =>
      jniAccessors.callMethodWithArgs(reference, _id_ZHPR, jni.JniType.voidType,
          [Uplo, alpha, X.reference, incX, Ap.reference]).check();

  static final _id_ZHER2 = jniAccessors.getMethodIDOf(_classRef, "ZHER2",
      "(ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void ZHER2(int Uplo, android.renderscript.Double2 alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation A)
  ///
  /// ZHER2 performs the symmetric rank 2 operation
  /// A := alpha*x*y**H + alpha*y*x**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/da/d8a/zher2_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  void ZHER2(
          int Uplo,
          double2_.Double2 alpha,
          allocation_.Allocation X,
          int incX,
          allocation_.Allocation Y,
          int incY,
          allocation_.Allocation A) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ZHER2, jni.JniType.voidType, [
        Uplo,
        alpha.reference,
        X.reference,
        incX,
        Y.reference,
        incY,
        A.reference
      ]).check();

  static final _id_ZHPR2 = jniAccessors.getMethodIDOf(_classRef, "ZHPR2",
      "(ILandroid/renderscript/Double2;Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;)V");

  /// from: public void ZHPR2(int Uplo, android.renderscript.Double2 alpha, android.renderscript.Allocation X, int incX, android.renderscript.Allocation Y, int incY, android.renderscript.Allocation Ap)
  ///
  /// ZHPR2 performs the symmetric rank 2 operation
  /// A := alpha*x*y**H + alpha*y*x**H + A
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d5/d52/zhpr2_8f.html
  ///
  /// Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,
  ///       The following subroutine can is an example showing how to convert a UPPER trianglar matrix
  ///       'a' to packed matrix 'b'.
  ///           k = 0
  ///           for i in range(0, n):
  ///              for j in range(i, n):
  ///                  b[k++] = a[i, j]
  ///@param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param X The input allocation contains vector x, supported elements type Element\#F64_2.
  ///@param incX The increment for the elements of vector x, must be larger than zero.
  ///@param Y The input allocation contains vector y, supported elements type Element\#F64_2.
  ///@param incY The increment for the elements of vector y, must be larger than zero.
  ///@param Ap The input allocation contains matrix A, supported elements type Element\#F64_2.
  void ZHPR2(
          int Uplo,
          double2_.Double2 alpha,
          allocation_.Allocation X,
          int incX,
          allocation_.Allocation Y,
          int incY,
          allocation_.Allocation Ap) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ZHPR2, jni.JniType.voidType, [
        Uplo,
        alpha.reference,
        X.reference,
        incX,
        Y.reference,
        incY,
        Ap.reference
      ]).check();

  static final _id_SGEMM = jniAccessors.getMethodIDOf(_classRef, "SGEMM",
      "(IIFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;FLandroid/renderscript/Allocation;)V");

  /// from: public void SGEMM(int TransA, int TransB, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, float beta, android.renderscript.Allocation C)
  ///
  /// SGEMM performs one of the matrix-matrix operations
  /// C := alpha*op(A)*op(B) + beta*C   where op(X) is one of op(X) = X  or  op(X) = X**T
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d4/de2/sgemm_8f.html
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param TransB The type of transpose applied to matrix B.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32.
  void SGEMM(int TransA, int TransB, double alpha, allocation_.Allocation A,
          allocation_.Allocation B, double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SGEMM, jni.JniType.voidType, [
        TransA,
        TransB,
        alpha,
        A.reference,
        B.reference,
        beta,
        C.reference
      ]).check();

  static final _id_DGEMM = jniAccessors.getMethodIDOf(_classRef, "DGEMM",
      "(IIDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;DLandroid/renderscript/Allocation;)V");

  /// from: public void DGEMM(int TransA, int TransB, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, double beta, android.renderscript.Allocation C)
  ///
  /// DGEMM performs one of the matrix-matrix operations
  /// C := alpha*op(A)*op(B) + beta*C   where op(X) is one of op(X) = X  or  op(X) = X**T
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d7/d2b/dgemm_8f.html
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param TransB The type of transpose applied to matrix B.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64.
  void DGEMM(int TransA, int TransB, double alpha, allocation_.Allocation A,
          allocation_.Allocation B, double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DGEMM, jni.JniType.voidType, [
        TransA,
        TransB,
        alpha,
        A.reference,
        B.reference,
        beta,
        C.reference
      ]).check();

  static final _id_CGEMM = jniAccessors.getMethodIDOf(_classRef, "CGEMM",
      "(IILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Float2;Landroid/renderscript/Allocation;)V");

  /// from: public void CGEMM(int TransA, int TransB, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, android.renderscript.Float2 beta, android.renderscript.Allocation C)
  ///
  /// CGEMM performs one of the matrix-matrix operations
  /// C := alpha*op(A)*op(B) + beta*C   where op(X) is one of op(X) = X  or  op(X) = X**T  or  op(X) = X**H
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d6/d5b/cgemm_8f.html
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param TransB The type of transpose applied to matrix B.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32_2.
  void CGEMM(
          int TransA,
          int TransB,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          float2_.Float2 beta,
          allocation_.Allocation C) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CGEMM, jni.JniType.voidType, [
        TransA,
        TransB,
        alpha.reference,
        A.reference,
        B.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_ZGEMM = jniAccessors.getMethodIDOf(_classRef, "ZGEMM",
      "(IILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Double2;Landroid/renderscript/Allocation;)V");

  /// from: public void ZGEMM(int TransA, int TransB, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, android.renderscript.Double2 beta, android.renderscript.Allocation C)
  ///
  /// ZGEMM performs one of the matrix-matrix operations
  /// C := alpha*op(A)*op(B) + beta*C   where op(X) is one of op(X) = X  or  op(X) = X**T  or  op(X) = X**H
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d7/d76/zgemm_8f.html
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param TransB The type of transpose applied to matrix B.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64_2.
  void ZGEMM(
          int TransA,
          int TransB,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          double2_.Double2 beta,
          allocation_.Allocation C) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZGEMM, jni.JniType.voidType, [
        TransA,
        TransB,
        alpha.reference,
        A.reference,
        B.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_SSYMM = jniAccessors.getMethodIDOf(_classRef, "SSYMM",
      "(IIFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;FLandroid/renderscript/Allocation;)V");

  /// from: public void SSYMM(int Side, int Uplo, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, float beta, android.renderscript.Allocation C)
  ///
  /// SSYMM performs one of the matrix-matrix operations
  /// C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d7/d42/ssymm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32.
  void SSYMM(int Side, int Uplo, double alpha, allocation_.Allocation A,
          allocation_.Allocation B, double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SSYMM, jni.JniType.voidType, [
        Side,
        Uplo,
        alpha,
        A.reference,
        B.reference,
        beta,
        C.reference
      ]).check();

  static final _id_DSYMM = jniAccessors.getMethodIDOf(_classRef, "DSYMM",
      "(IIDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;DLandroid/renderscript/Allocation;)V");

  /// from: public void DSYMM(int Side, int Uplo, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, double beta, android.renderscript.Allocation C)
  ///
  /// DSYMM performs one of the matrix-matrix operations
  /// C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d8/db0/dsymm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64.
  void DSYMM(int Side, int Uplo, double alpha, allocation_.Allocation A,
          allocation_.Allocation B, double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DSYMM, jni.JniType.voidType, [
        Side,
        Uplo,
        alpha,
        A.reference,
        B.reference,
        beta,
        C.reference
      ]).check();

  static final _id_CSYMM = jniAccessors.getMethodIDOf(_classRef, "CSYMM",
      "(IILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Float2;Landroid/renderscript/Allocation;)V");

  /// from: public void CSYMM(int Side, int Uplo, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, android.renderscript.Float2 beta, android.renderscript.Allocation C)
  ///
  /// CSYMM performs one of the matrix-matrix operations
  /// C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/db/d59/csymm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32_2.
  void CSYMM(
          int Side,
          int Uplo,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          float2_.Float2 beta,
          allocation_.Allocation C) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CSYMM, jni.JniType.voidType, [
        Side,
        Uplo,
        alpha.reference,
        A.reference,
        B.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_ZSYMM = jniAccessors.getMethodIDOf(_classRef, "ZSYMM",
      "(IILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Double2;Landroid/renderscript/Allocation;)V");

  /// from: public void ZSYMM(int Side, int Uplo, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, android.renderscript.Double2 beta, android.renderscript.Allocation C)
  ///
  /// ZSYMM performs one of the matrix-matrix operations
  /// C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/df/d51/zsymm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64_2.
  void ZSYMM(
          int Side,
          int Uplo,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          double2_.Double2 beta,
          allocation_.Allocation C) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZSYMM, jni.JniType.voidType, [
        Side,
        Uplo,
        alpha.reference,
        A.reference,
        B.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_SSYRK = jniAccessors.getMethodIDOf(_classRef, "SSYRK",
      "(IIFLandroid/renderscript/Allocation;FLandroid/renderscript/Allocation;)V");

  /// from: public void SSYRK(int Uplo, int Trans, float alpha, android.renderscript.Allocation A, float beta, android.renderscript.Allocation C)
  ///
  /// SSYRK performs one of the symmetric rank k operations
  /// C := alpha*A*A**T + beta*C   or   C := alpha*A**T*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d0/d40/ssyrk_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32.
  void SSYRK(int Uplo, int Trans, double alpha, allocation_.Allocation A,
          double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_SSYRK,
          jni.JniType.voidType,
          [Uplo, Trans, alpha, A.reference, beta, C.reference]).check();

  static final _id_DSYRK = jniAccessors.getMethodIDOf(_classRef, "DSYRK",
      "(IIDLandroid/renderscript/Allocation;DLandroid/renderscript/Allocation;)V");

  /// from: public void DSYRK(int Uplo, int Trans, double alpha, android.renderscript.Allocation A, double beta, android.renderscript.Allocation C)
  ///
  /// DSYRK performs one of the symmetric rank k operations
  /// C := alpha*A*A**T + beta*C   or   C := alpha*A**T*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dc/d05/dsyrk_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64.
  void DSYRK(int Uplo, int Trans, double alpha, allocation_.Allocation A,
          double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DSYRK,
          jni.JniType.voidType,
          [Uplo, Trans, alpha, A.reference, beta, C.reference]).check();

  static final _id_CSYRK = jniAccessors.getMethodIDOf(_classRef, "CSYRK",
      "(IILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Float2;Landroid/renderscript/Allocation;)V");

  /// from: public void CSYRK(int Uplo, int Trans, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Float2 beta, android.renderscript.Allocation C)
  ///
  /// CSYRK performs one of the symmetric rank k operations
  /// C := alpha*A*A**T + beta*C   or   C := alpha*A**T*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/d6a/csyrk_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32_2.
  void CSYRK(
          int Uplo,
          int Trans,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          float2_.Float2 beta,
          allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_CSYRK, jni.JniType.voidType, [
        Uplo,
        Trans,
        alpha.reference,
        A.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_ZSYRK = jniAccessors.getMethodIDOf(_classRef, "ZSYRK",
      "(IILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Double2;Landroid/renderscript/Allocation;)V");

  /// from: public void ZSYRK(int Uplo, int Trans, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Double2 beta, android.renderscript.Allocation C)
  ///
  /// ZSYRK performs one of the symmetric rank k operations
  /// C := alpha*A*A**T + beta*C   or   C := alpha*A**T*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/de/d54/zsyrk_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64_2.
  void ZSYRK(
          int Uplo,
          int Trans,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          double2_.Double2 beta,
          allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ZSYRK, jni.JniType.voidType, [
        Uplo,
        Trans,
        alpha.reference,
        A.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_SSYR2K = jniAccessors.getMethodIDOf(_classRef, "SSYR2K",
      "(IIFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;FLandroid/renderscript/Allocation;)V");

  /// from: public void SSYR2K(int Uplo, int Trans, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, float beta, android.renderscript.Allocation C)
  ///
  /// SSYR2K performs one of the symmetric rank 2k operations
  /// C := alpha*A*B**T + alpha*B*A**T + beta*C   or   C := alpha*A**T*B + alpha*B**T*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/df/d3d/ssyr2k_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32.
  void SSYR2K(int Uplo, int Trans, double alpha, allocation_.Allocation A,
          allocation_.Allocation B, double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_SSYR2K, jni.JniType.voidType, [
        Uplo,
        Trans,
        alpha,
        A.reference,
        B.reference,
        beta,
        C.reference
      ]).check();

  static final _id_DSYR2K = jniAccessors.getMethodIDOf(_classRef, "DSYR2K",
      "(IIDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;DLandroid/renderscript/Allocation;)V");

  /// from: public void DSYR2K(int Uplo, int Trans, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, double beta, android.renderscript.Allocation C)
  ///
  /// DSYR2K performs one of the symmetric rank 2k operations
  /// C := alpha*A*B**T + alpha*B*A**T + beta*C   or   C := alpha*A**T*B + alpha*B**T*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d1/dec/dsyr2k_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64.
  void DSYR2K(int Uplo, int Trans, double alpha, allocation_.Allocation A,
          allocation_.Allocation B, double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_DSYR2K, jni.JniType.voidType, [
        Uplo,
        Trans,
        alpha,
        A.reference,
        B.reference,
        beta,
        C.reference
      ]).check();

  static final _id_CSYR2K = jniAccessors.getMethodIDOf(_classRef, "CSYR2K",
      "(IILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Float2;Landroid/renderscript/Allocation;)V");

  /// from: public void CSYR2K(int Uplo, int Trans, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, android.renderscript.Float2 beta, android.renderscript.Allocation C)
  ///
  /// CSYR2K performs one of the symmetric rank 2k operations
  /// C := alpha*A*B**T + alpha*B*A**T + beta*C   or   C := alpha*A**T*B + alpha*B**T*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/de/d7e/csyr2k_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32_2.
  void CSYR2K(
          int Uplo,
          int Trans,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          float2_.Float2 beta,
          allocation_.Allocation C) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CSYR2K, jni.JniType.voidType, [
        Uplo,
        Trans,
        alpha.reference,
        A.reference,
        B.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_ZSYR2K = jniAccessors.getMethodIDOf(_classRef, "ZSYR2K",
      "(IILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Double2;Landroid/renderscript/Allocation;)V");

  /// from: public void ZSYR2K(int Uplo, int Trans, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, android.renderscript.Double2 beta, android.renderscript.Allocation C)
  ///
  /// ZSYR2K performs one of the symmetric rank 2k operations
  /// C := alpha*A*B**T + alpha*B*A**T + beta*C   or   C := alpha*A**T*B + alpha*B**T*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/df/d20/zsyr2k_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64_2.
  void ZSYR2K(
          int Uplo,
          int Trans,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          double2_.Double2 beta,
          allocation_.Allocation C) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZSYR2K, jni.JniType.voidType, [
        Uplo,
        Trans,
        alpha.reference,
        A.reference,
        B.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_STRMM = jniAccessors.getMethodIDOf(_classRef, "STRMM",
      "(IIIIFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void STRMM(int Side, int Uplo, int TransA, int Diag, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation B)
  ///
  /// STRMM performs one of the matrix-matrix operations
  /// B := alpha*op(A)*B   or   B := alpha*B*op(A)
  /// op(A) is one of  op(A) = A  or  op(A) = A**T
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/df/d01/strmm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether matrix A is upper or lower triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32.
  void STRMM(int Side, int Uplo, int TransA, int Diag, double alpha,
          allocation_.Allocation A, allocation_.Allocation B) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_STRMM,
          jni.JniType.voidType,
          [Side, Uplo, TransA, Diag, alpha, A.reference, B.reference]).check();

  static final _id_DTRMM = jniAccessors.getMethodIDOf(_classRef, "DTRMM",
      "(IIIIDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void DTRMM(int Side, int Uplo, int TransA, int Diag, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation B)
  ///
  /// DTRMM performs one of the matrix-matrix operations
  /// B := alpha*op(A)*B   or   B := alpha*B*op(A)
  /// op(A) is one of  op(A) = A  or  op(A) = A**T
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/dd/d19/dtrmm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether matrix A is upper or lower triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64.
  void DTRMM(int Side, int Uplo, int TransA, int Diag, double alpha,
          allocation_.Allocation A, allocation_.Allocation B) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DTRMM,
          jni.JniType.voidType,
          [Side, Uplo, TransA, Diag, alpha, A.reference, B.reference]).check();

  static final _id_CTRMM = jniAccessors.getMethodIDOf(_classRef, "CTRMM",
      "(IIIILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void CTRMM(int Side, int Uplo, int TransA, int Diag, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B)
  ///
  /// CTRMM performs one of the matrix-matrix operations
  /// B := alpha*op(A)*B   or   B := alpha*B*op(A)
  /// op(A) is one of  op(A) = A  or  op(A) = A**T  or  op(A) = A**H
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d4/d9b/ctrmm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether matrix A is upper or lower triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32_2.
  void CTRMM(int Side, int Uplo, int TransA, int Diag, float2_.Float2 alpha,
          allocation_.Allocation A, allocation_.Allocation B) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_CTRMM, jni.JniType.voidType, [
        Side,
        Uplo,
        TransA,
        Diag,
        alpha.reference,
        A.reference,
        B.reference
      ]).check();

  static final _id_ZTRMM = jniAccessors.getMethodIDOf(_classRef, "ZTRMM",
      "(IIIILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void ZTRMM(int Side, int Uplo, int TransA, int Diag, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B)
  ///
  /// ZTRMM performs one of the matrix-matrix operations
  /// B := alpha*op(A)*B   or   B := alpha*B*op(A)
  /// op(A) is one of  op(A) = A  or  op(A) = A**T  or  op(A) = A**H
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d8/de1/ztrmm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether matrix A is upper or lower triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64_2.
  void ZTRMM(int Side, int Uplo, int TransA, int Diag, double2_.Double2 alpha,
          allocation_.Allocation A, allocation_.Allocation B) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ZTRMM, jni.JniType.voidType, [
        Side,
        Uplo,
        TransA,
        Diag,
        alpha.reference,
        A.reference,
        B.reference
      ]).check();

  static final _id_STRSM = jniAccessors.getMethodIDOf(_classRef, "STRSM",
      "(IIIIFLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void STRSM(int Side, int Uplo, int TransA, int Diag, float alpha, android.renderscript.Allocation A, android.renderscript.Allocation B)
  ///
  /// STRSM solves one of the matrix equations
  /// op(A)*X := alpha*B   or   X*op(A) := alpha*B
  /// op(A) is one of  op(A) = A  or  op(A) = A**T
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d2/d8b/strsm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether matrix A is upper or lower triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32.
  void STRSM(int Side, int Uplo, int TransA, int Diag, double alpha,
          allocation_.Allocation A, allocation_.Allocation B) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_STRSM,
          jni.JniType.voidType,
          [Side, Uplo, TransA, Diag, alpha, A.reference, B.reference]).check();

  static final _id_DTRSM = jniAccessors.getMethodIDOf(_classRef, "DTRSM",
      "(IIIIDLandroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void DTRSM(int Side, int Uplo, int TransA, int Diag, double alpha, android.renderscript.Allocation A, android.renderscript.Allocation B)
  ///
  /// DTRSM solves one of the matrix equations
  /// op(A)*X := alpha*B   or   X*op(A) := alpha*B
  /// op(A) is one of  op(A) = A  or  op(A) = A**T
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/de/da7/dtrsm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether matrix A is upper or lower triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64.
  void DTRSM(int Side, int Uplo, int TransA, int Diag, double alpha,
          allocation_.Allocation A, allocation_.Allocation B) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_DTRSM,
          jni.JniType.voidType,
          [Side, Uplo, TransA, Diag, alpha, A.reference, B.reference]).check();

  static final _id_CTRSM = jniAccessors.getMethodIDOf(_classRef, "CTRSM",
      "(IIIILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void CTRSM(int Side, int Uplo, int TransA, int Diag, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B)
  ///
  /// CTRSM solves one of the matrix equations
  /// op(A)*X := alpha*B   or   X*op(A) := alpha*B
  /// op(A) is one of  op(A) = A  or  op(A) = A**T  or  op(A) = A**H
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/de/d30/ctrsm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether matrix A is upper or lower triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32_2.
  void CTRSM(int Side, int Uplo, int TransA, int Diag, float2_.Float2 alpha,
          allocation_.Allocation A, allocation_.Allocation B) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_CTRSM, jni.JniType.voidType, [
        Side,
        Uplo,
        TransA,
        Diag,
        alpha.reference,
        A.reference,
        B.reference
      ]).check();

  static final _id_ZTRSM = jniAccessors.getMethodIDOf(_classRef, "ZTRSM",
      "(IIIILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void ZTRSM(int Side, int Uplo, int TransA, int Diag, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B)
  ///
  /// ZTRSM solves one of the matrix equations
  /// op(A)*X := alpha*B   or   X*op(A) := alpha*B
  /// op(A) is one of  op(A) = A  or  op(A) = A**T  or  op(A) = A**H
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d1/d39/ztrsm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether matrix A is upper or lower triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param TransA The type of transpose applied to matrix A.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param Diag Specifies whether or not A is unit triangular.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NON_UNIT, or android.renderscript.ScriptIntrinsicBLAS\#UNIT
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64_2.
  void ZTRSM(int Side, int Uplo, int TransA, int Diag, double2_.Double2 alpha,
          allocation_.Allocation A, allocation_.Allocation B) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ZTRSM, jni.JniType.voidType, [
        Side,
        Uplo,
        TransA,
        Diag,
        alpha.reference,
        A.reference,
        B.reference
      ]).check();

  static final _id_CHEMM = jniAccessors.getMethodIDOf(_classRef, "CHEMM",
      "(IILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Float2;Landroid/renderscript/Allocation;)V");

  /// from: public void CHEMM(int Side, int Uplo, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, android.renderscript.Float2 beta, android.renderscript.Allocation C)
  ///
  /// CHEMM performs one of the matrix-matrix operations
  /// C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d3/d66/chemm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32_2.
  void CHEMM(
          int Side,
          int Uplo,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          float2_.Float2 beta,
          allocation_.Allocation C) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_CHEMM, jni.JniType.voidType, [
        Side,
        Uplo,
        alpha.reference,
        A.reference,
        B.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_ZHEMM = jniAccessors.getMethodIDOf(_classRef, "ZHEMM",
      "(IILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Double2;Landroid/renderscript/Allocation;)V");

  /// from: public void ZHEMM(int Side, int Uplo, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, android.renderscript.Double2 beta, android.renderscript.Allocation C)
  ///
  /// ZHEMM performs one of the matrix-matrix operations
  /// C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d6/d3e/zhemm_8f.html
  ///@param Side Specifies whether the symmetric matrix A appears on the left or right.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#LEFT, or android.renderscript.ScriptIntrinsicBLAS\#RIGHT
  ///@param Uplo Specifies whether the upper or lower triangular part is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64_2.
  void ZHEMM(
          int Side,
          int Uplo,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          double2_.Double2 beta,
          allocation_.Allocation C) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_ZHEMM, jni.JniType.voidType, [
        Side,
        Uplo,
        alpha.reference,
        A.reference,
        B.reference,
        beta.reference,
        C.reference
      ]).check();

  static final _id_CHERK = jniAccessors.getMethodIDOf(_classRef, "CHERK",
      "(IIFLandroid/renderscript/Allocation;FLandroid/renderscript/Allocation;)V");

  /// from: public void CHERK(int Uplo, int Trans, float alpha, android.renderscript.Allocation A, float beta, android.renderscript.Allocation C)
  ///
  /// CHERK performs one of the hermitian rank k operations
  /// C := alpha*A*A**H + beta*C   or   C := alpha*A**H*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d8/d52/cherk_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32_2.
  void CHERK(int Uplo, int Trans, double alpha, allocation_.Allocation A,
          double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_CHERK,
          jni.JniType.voidType,
          [Uplo, Trans, alpha, A.reference, beta, C.reference]).check();

  static final _id_ZHERK = jniAccessors.getMethodIDOf(_classRef, "ZHERK",
      "(IIDLandroid/renderscript/Allocation;DLandroid/renderscript/Allocation;)V");

  /// from: public void ZHERK(int Uplo, int Trans, double alpha, android.renderscript.Allocation A, double beta, android.renderscript.Allocation C)
  ///
  /// ZHERK performs one of the hermitian rank k operations
  /// C := alpha*A*A**H + beta*C   or   C := alpha*A**H*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d1/db1/zherk_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64_2.
  void ZHERK(int Uplo, int Trans, double alpha, allocation_.Allocation A,
          double beta, allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_ZHERK,
          jni.JniType.voidType,
          [Uplo, Trans, alpha, A.reference, beta, C.reference]).check();

  static final _id_CHER2K = jniAccessors.getMethodIDOf(_classRef, "CHER2K",
      "(IILandroid/renderscript/Float2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;FLandroid/renderscript/Allocation;)V");

  /// from: public void CHER2K(int Uplo, int Trans, android.renderscript.Float2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, float beta, android.renderscript.Allocation C)
  ///
  /// CHER2K performs one of the hermitian rank 2k operations
  /// C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C   or   C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d1/d82/cher2k_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F32_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F32_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F32_2.
  void CHER2K(
          int Uplo,
          int Trans,
          float2_.Float2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          double beta,
          allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_CHER2K, jni.JniType.voidType, [
        Uplo,
        Trans,
        alpha.reference,
        A.reference,
        B.reference,
        beta,
        C.reference
      ]).check();

  static final _id_ZHER2K = jniAccessors.getMethodIDOf(_classRef, "ZHER2K",
      "(IILandroid/renderscript/Double2;Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;DLandroid/renderscript/Allocation;)V");

  /// from: public void ZHER2K(int Uplo, int Trans, android.renderscript.Double2 alpha, android.renderscript.Allocation A, android.renderscript.Allocation B, double beta, android.renderscript.Allocation C)
  ///
  /// ZHER2K performs one of the hermitian rank 2k operations
  /// C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C   or   C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C
  ///
  /// Details: http://www.netlib.org/lapack/explore-html/d7/dfa/zher2k_8f.html
  ///@param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#UPPER, or android.renderscript.ScriptIntrinsicBLAS\#LOWER
  ///@param Trans The type of transpose applied to the operation.
  /// Value is android.renderscript.ScriptIntrinsicBLAS\#NO_TRANSPOSE, android.renderscript.ScriptIntrinsicBLAS\#TRANSPOSE, or android.renderscript.ScriptIntrinsicBLAS\#CONJ_TRANSPOSE
  ///@param alpha The scalar alpha.
  ///@param A The input allocation contains matrix A, supported elements type Element\#F64_2.
  ///@param B The input allocation contains matrix B, supported elements type Element\#F64_2.
  ///@param beta The scalar beta.
  ///@param C The input allocation contains matrix C, supported elements type Element\#F64_2.
  void ZHER2K(
          int Uplo,
          int Trans,
          double2_.Double2 alpha,
          allocation_.Allocation A,
          allocation_.Allocation B,
          double beta,
          allocation_.Allocation C) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ZHER2K, jni.JniType.voidType, [
        Uplo,
        Trans,
        alpha.reference,
        A.reference,
        B.reference,
        beta,
        C.reference
      ]).check();

  static final _id_BNNM = jniAccessors.getMethodIDOf(_classRef, "BNNM",
      "(Landroid/renderscript/Allocation;ILandroid/renderscript/Allocation;ILandroid/renderscript/Allocation;II)V");

  /// from: public void BNNM(android.renderscript.Allocation A, int a_offset, android.renderscript.Allocation B, int b_offset, android.renderscript.Allocation C, int c_offset, int c_mult)
  ///
  /// 8-bit GEMM-like operation for neural networks: C = A * Transpose(B)
  /// Calculations are done in 1.10.21 fixed-point format for the final output,
  /// just before there's a shift down to drop the fractional parts. The output
  /// values are gated to 0 to 255 to fit in a byte, but the 10-bit format
  /// gives some headroom to avoid wrapping around on small overflows.
  ///@param A The input allocation contains matrix A, supported elements type Element\#U8.
  ///@param a_offset The offset for all values in matrix A, e.g A[i,j] = A[i,j] - a_offset. Value should be from 0 to 255.
  ///@param B The input allocation contains matrix B, supported elements type Element\#U8.
  ///@param b_offset The offset for all values in matrix B, e.g B[i,j] = B[i,j] - b_offset. Value should be from 0 to 255.
  ///@param C The input allocation contains matrix C, supported elements type Element\#U8.
  ///@param c_offset The offset for all values in matrix C.
  ///@param c_mult The multiplier for all values in matrix C, e.g C[i,j] = (C[i,j] + c_offset) * c_mult.
  void BNNM(allocation_.Allocation A, int a_offset, allocation_.Allocation B,
          int b_offset, allocation_.Allocation C, int c_offset, int c_mult) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_BNNM, jni.JniType.voidType, [
        A.reference,
        a_offset,
        B.reference,
        b_offset,
        C.reference,
        c_offset,
        c_mult
      ]).check();
}
