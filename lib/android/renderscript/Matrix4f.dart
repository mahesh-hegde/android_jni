// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.renderscript.Matrix4f
///
/// Class for exposing the native RenderScript rs_matrix4x4 type back to the Android system.
class Matrix4f extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/renderscript/Matrix4f");
  Matrix4f.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new identity 4x4 matrix
  Matrix4f()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([F)V");

  /// from: public void <init>(float[] dataArray)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new matrix and sets its values from the given
  /// parameter
  ///@param dataArray values to set the matrix to, must be 16
  ///                  floats long
  Matrix4f.ctor1(jni.JniObject dataArray)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [dataArray.reference]).object);

  static final _id_getArray =
      jniAccessors.getMethodIDOf(_classRef, "getArray", "()[F");

  /// from: public float[] getArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a reference to the internal array representing matrix
  /// values. Modifying this array will also change the matrix
  ///@return internal array representing the matrix
  jni.JniObject getArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getArray, jni.JniType.objectType, []).object);

  static final _id_get0 = jniAccessors.getMethodIDOf(_classRef, "get", "(II)F");

  /// from: public float get(int x, int y)
  ///
  /// Returns the value for a given row and column
  ///@param x column of the value to return
  ///@param y row of the value to return
  ///@return value in the yth row and xth column
  double get0(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_get0, jni.JniType.floatType, [x, y]).float;

  static final _id_set0 =
      jniAccessors.getMethodIDOf(_classRef, "set", "(IIF)V");

  /// from: public void set(int x, int y, float v)
  ///
  /// Sets the value for a given row and column
  ///@param x column of the value to set
  ///@param y row of the value to set
  void set0(int x, int y, double v) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.voidType, [x, y, v]).check();

  static final _id_loadIdentity =
      jniAccessors.getMethodIDOf(_classRef, "loadIdentity", "()V");

  /// from: public void loadIdentity()
  ///
  /// Sets the matrix values to identity
  void loadIdentity() => jniAccessors.callMethodWithArgs(
      reference, _id_loadIdentity, jni.JniType.voidType, []).check();

  static final _id_load = jniAccessors.getMethodIDOf(
      _classRef, "load", "(Landroid/renderscript/Matrix4f;)V");

  /// from: public void load(android.renderscript.Matrix4f src)
  ///
  /// Sets the values of the matrix to those of the parameter
  ///@param src matrix to load the values from
  void load(Matrix4f src) => jniAccessors.callMethodWithArgs(
      reference, _id_load, jni.JniType.voidType, [src.reference]).check();

  static final _id_loadRotate =
      jniAccessors.getMethodIDOf(_classRef, "loadRotate", "(FFFF)V");

  /// from: public void loadRotate(float rot, float x, float y, float z)
  ///
  /// Sets current values to be a rotation matrix of certain angle
  /// about a given axis
  ///@param rot angle of rotation
  ///@param x rotation axis x
  ///@param y rotation axis y
  ///@param z rotation axis z
  void loadRotate(double rot, double x, double y, double z) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadRotate,
          jni.JniType.voidType, [rot, x, y, z]).check();

  static final _id_loadScale =
      jniAccessors.getMethodIDOf(_classRef, "loadScale", "(FFF)V");

  /// from: public void loadScale(float x, float y, float z)
  ///
  /// Sets current values to be a scale matrix of given dimensions
  ///@param x scale component x
  ///@param y scale component y
  ///@param z scale component z
  void loadScale(double x, double y, double z) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_loadScale, jni.JniType.voidType, [x, y, z]).check();

  static final _id_loadTranslate =
      jniAccessors.getMethodIDOf(_classRef, "loadTranslate", "(FFF)V");

  /// from: public void loadTranslate(float x, float y, float z)
  ///
  /// Sets current values to be a translation matrix of given
  /// dimensions
  ///@param x translation component x
  ///@param y translation component y
  ///@param z translation component z
  void loadTranslate(double x, double y, double z) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadTranslate,
          jni.JniType.voidType, [x, y, z]).check();

  static final _id_loadMultiply = jniAccessors.getMethodIDOf(
      _classRef,
      "loadMultiply",
      "(Landroid/renderscript/Matrix4f;Landroid/renderscript/Matrix4f;)V");

  /// from: public void loadMultiply(android.renderscript.Matrix4f lhs, android.renderscript.Matrix4f rhs)
  ///
  /// Sets current values to be the result of multiplying two given
  /// matrices
  ///@param lhs left hand side matrix
  ///@param rhs right hand side matrix
  void loadMultiply(Matrix4f lhs, Matrix4f rhs) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadMultiply,
          jni.JniType.voidType, [lhs.reference, rhs.reference]).check();

  static final _id_loadOrtho =
      jniAccessors.getMethodIDOf(_classRef, "loadOrtho", "(FFFFFF)V");

  /// from: public void loadOrtho(float l, float r, float b, float t, float n, float f)
  ///
  /// Set current values to be an orthographic projection matrix
  ///@param l location of the left vertical clipping plane
  ///@param r location of the right vertical clipping plane
  ///@param b location of the bottom horizontal clipping plane
  ///@param t location of the top horizontal clipping plane
  ///@param n location of the near clipping plane
  ///@param f location of the far clipping plane
  void loadOrtho(double l, double r, double b, double t, double n, double f) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadOrtho,
          jni.JniType.voidType, [l, r, b, t, n, f]).check();

  static final _id_loadOrthoWindow =
      jniAccessors.getMethodIDOf(_classRef, "loadOrthoWindow", "(II)V");

  /// from: public void loadOrthoWindow(int w, int h)
  ///
  /// Set current values to be an orthographic projection matrix
  /// with the right and bottom clipping planes set to the given
  /// values. Left and top clipping planes are set to 0. Near and
  /// far are set to -1, 1 respectively
  ///@param w location of the right vertical clipping plane
  ///@param h location of the bottom horizontal clipping plane
  void loadOrthoWindow(int w, int h) => jniAccessors.callMethodWithArgs(
      reference, _id_loadOrthoWindow, jni.JniType.voidType, [w, h]).check();

  static final _id_loadFrustum =
      jniAccessors.getMethodIDOf(_classRef, "loadFrustum", "(FFFFFF)V");

  /// from: public void loadFrustum(float l, float r, float b, float t, float n, float f)
  ///
  /// Sets current values to be a perspective projection matrix
  ///@param l location of the left vertical clipping plane
  ///@param r location of the right vertical clipping plane
  ///@param b location of the bottom horizontal clipping plane
  ///@param t location of the top horizontal clipping plane
  ///@param n location of the near clipping plane, must be positive
  ///@param f location of the far clipping plane, must be positive
  void loadFrustum(
          double l, double r, double b, double t, double n, double f) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadFrustum,
          jni.JniType.voidType, [l, r, b, t, n, f]).check();

  static final _id_loadPerspective =
      jniAccessors.getMethodIDOf(_classRef, "loadPerspective", "(FFFF)V");

  /// from: public void loadPerspective(float fovy, float aspect, float near, float far)
  ///
  /// Sets current values to be a perspective projection matrix
  ///@param fovy vertical field of view angle in degrees
  ///@param aspect aspect ratio of the screen
  ///@param near near cliping plane, must be positive
  ///@param far far clipping plane, must be positive
  void loadPerspective(double fovy, double aspect, double near, double far) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadPerspective,
          jni.JniType.voidType, [fovy, aspect, near, far]).check();

  static final _id_loadProjectionNormalized = jniAccessors.getMethodIDOf(
      _classRef, "loadProjectionNormalized", "(II)V");

  /// from: public void loadProjectionNormalized(int w, int h)
  ///
  /// Helper function to set the current values to a perspective
  /// projection matrix with aspect ratio defined by the parameters
  /// and (near, far), (bottom, top) mapping to (-1, 1) at z = 0
  ///@param w screen width
  ///@param h screen height
  void loadProjectionNormalized(int w, int h) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadProjectionNormalized,
          jni.JniType.voidType, [w, h]).check();

  static final _id_multiply = jniAccessors.getMethodIDOf(
      _classRef, "multiply", "(Landroid/renderscript/Matrix4f;)V");

  /// from: public void multiply(android.renderscript.Matrix4f rhs)
  ///
  /// Post-multiplies the current matrix by a given parameter
  ///@param rhs right hand side to multiply by
  void multiply(Matrix4f rhs) => jniAccessors.callMethodWithArgs(
      reference, _id_multiply, jni.JniType.voidType, [rhs.reference]).check();

  static final _id_rotate =
      jniAccessors.getMethodIDOf(_classRef, "rotate", "(FFFF)V");

  /// from: public void rotate(float rot, float x, float y, float z)
  ///
  /// Modifies the current matrix by post-multiplying it with a
  /// rotation matrix of certain angle about a given axis
  ///@param rot angle of rotation
  ///@param x rotation axis x
  ///@param y rotation axis y
  ///@param z rotation axis z
  void rotate(double rot, double x, double y, double z) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_rotate, jni.JniType.voidType, [rot, x, y, z]).check();

  static final _id_scale =
      jniAccessors.getMethodIDOf(_classRef, "scale", "(FFF)V");

  /// from: public void scale(float x, float y, float z)
  ///
  /// Modifies the current matrix by post-multiplying it with a
  /// scale matrix of given dimensions
  ///@param x scale component x
  ///@param y scale component y
  ///@param z scale component z
  void scale(double x, double y, double z) => jniAccessors.callMethodWithArgs(
      reference, _id_scale, jni.JniType.voidType, [x, y, z]).check();

  static final _id_translate =
      jniAccessors.getMethodIDOf(_classRef, "translate", "(FFF)V");

  /// from: public void translate(float x, float y, float z)
  ///
  /// Modifies the current matrix by post-multiplying it with a
  /// translation matrix of given dimensions
  ///@param x translation component x
  ///@param y translation component y
  ///@param z translation component z
  void translate(double x, double y, double z) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_translate, jni.JniType.voidType, [x, y, z]).check();

  static final _id_inverse =
      jniAccessors.getMethodIDOf(_classRef, "inverse", "()Z");

  /// from: public boolean inverse()
  ///
  /// Sets the current matrix to its inverse
  bool inverse() => jniAccessors.callMethodWithArgs(
      reference, _id_inverse, jni.JniType.booleanType, []).boolean;

  static final _id_inverseTranspose =
      jniAccessors.getMethodIDOf(_classRef, "inverseTranspose", "()Z");

  /// from: public boolean inverseTranspose()
  ///
  /// Sets the current matrix to its inverse transpose
  bool inverseTranspose() => jniAccessors.callMethodWithArgs(
      reference, _id_inverseTranspose, jni.JniType.booleanType, []).boolean;

  static final _id_transpose =
      jniAccessors.getMethodIDOf(_classRef, "transpose", "()V");

  /// from: public void transpose()
  ///
  /// Sets the current matrix to its transpose
  void transpose() => jniAccessors.callMethodWithArgs(
      reference, _id_transpose, jni.JniType.voidType, []).check();
}
