// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "BaseObj.dart" as baseobj_;

import "RenderScript.dart" as renderscript_;

import "Type.dart" as type_;

import "Element.dart" as element_;

import "../graphics/Bitmap.dart" as bitmap_;

import "FieldPacker.dart" as fieldpacker_;

import "../view/Surface.dart" as surface_;

import "../content/res/Resources.dart" as resources_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.renderscript.Allocation
///
///  This class provides the primary method through which data is passed to
/// and from RenderScript kernels.  An Allocation provides the backing store for
/// a given android.renderscript.Type.
///
///
/// An Allocation also contains a set of usage flags that denote how the
/// Allocation could be used. For example, an Allocation may have usage flags
/// specifying that it can be used from a script as well as input to a android.renderscript.Sampler. A developer must synchronize across these
/// different usages using android.renderscript.Allocation\#syncAll in
/// order to ensure that different users of the Allocation have a consistent view
/// of memory. For example, in the case where an Allocation is used as the output
/// of one kernel and as Sampler input in a later kernel, a developer must call
/// \#syncAll syncAll(Allocation.USAGE_SCRIPT) prior to launching the
/// second kernel to ensure correctness.
///
/// An Allocation can be populated with the \#copyFrom routines. For
/// more complex Element types, the \#copyFromUnchecked methods can be
/// used to copy from byte arrays or similar constructs.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating an application that uses RenderScript, read the
/// <a href="{@docRoot}guide/topics/renderscript/index.html">RenderScript</a> developer guide.
///
/// </div>
class Allocation extends baseobj_.BaseObj {
  static final _classRef =
      jniAccessors.getClassOf("android/renderscript/Allocation");
  Allocation.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int USAGE_GRAPHICS_CONSTANTS
  ///
  /// The Allocation will be used as the source of shader constants by one or
  /// more programs.
  ///
  /// This was deprecated in API level 16.
  static const USAGE_GRAPHICS_CONSTANTS = 8;

  /// from: static public final int USAGE_GRAPHICS_RENDER_TARGET
  ///
  /// The Allocation will be used as a target for offscreen rendering
  ///
  /// This was deprecated in API level 16.
  static const USAGE_GRAPHICS_RENDER_TARGET = 16;

  /// from: static public final int USAGE_GRAPHICS_TEXTURE
  ///
  /// The Allocation will be used as a texture source by one or more graphics
  /// programs.
  static const USAGE_GRAPHICS_TEXTURE = 2;

  /// from: static public final int USAGE_GRAPHICS_VERTEX
  ///
  /// The Allocation will be used as a graphics mesh.
  ///
  /// This was deprecated in API level 16.
  static const USAGE_GRAPHICS_VERTEX = 4;

  /// from: static public final int USAGE_IO_INPUT
  ///
  /// The Allocation will be used as a android.view.Surface
  /// consumer.  This usage will cause the Allocation to be created
  /// as read-only.
  static const USAGE_IO_INPUT = 32;

  /// from: static public final int USAGE_IO_OUTPUT
  ///
  /// The Allocation will be used as a android.view.Surface
  /// producer.  The dimensions and format of the android.view.Surface will be forced to those of the
  /// Allocation.
  static const USAGE_IO_OUTPUT = 64;

  /// from: static public final int USAGE_SCRIPT
  ///
  /// The Allocation will be bound to and accessed by scripts.
  static const USAGE_SCRIPT = 1;

  /// from: static public final int USAGE_SHARED
  ///
  /// The Allocation's backing store will be inherited from another object
  /// (usually a android.graphics.Bitmap); copying to or from the
  /// original source Bitmap will cause a synchronization rather than a full
  /// copy.  \#syncAll may also be used to synchronize the Allocation
  /// and the source Bitmap.
  ///
  /// This is set by default for allocations created with \#createFromBitmap in API version 18 and higher.
  ///
  static const USAGE_SHARED = 128;

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(JLandroid/renderscript/RenderScript;Landroid/renderscript/Type;I)V");

  /// from: void <init>(long id, android.renderscript.RenderScript rs, android.renderscript.Type t, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Allocation.ctor1(
      int id, renderscript_.RenderScript rs, type_.Type t, int usage)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [id, rs.reference, t.reference, usage]).object);

  static final _id_getElement = jniAccessors.getMethodIDOf(
      _classRef, "getElement", "()Landroid/renderscript/Element;");

  /// from: public android.renderscript.Element getElement()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the android.renderscript.Element of the android.renderscript.Type of the Allocation.
  ///@return Element
  element_.Element getElement() =>
      element_.Element.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getElement, jni.JniType.objectType, []).object);

  static final _id_getUsage =
      jniAccessors.getMethodIDOf(_classRef, "getUsage", "()I");

  /// from: public int getUsage()
  ///
  /// Get the usage flags of the Allocation.
  ///@return usage this Allocation's set of the USAGE_* flags OR'd together
  int getUsage() => jniAccessors.callMethodWithArgs(
      reference, _id_getUsage, jni.JniType.intType, []).integer;

  static final _id_setAutoPadding =
      jniAccessors.getMethodIDOf(_classRef, "setAutoPadding", "(Z)V");

  /// from: public void setAutoPadding(boolean useAutoPadding)
  ///
  /// Specifies the mapping between the Allocation's cells and an array's elements
  /// when data is copied from the Allocation to the array, or vice-versa.
  ///
  /// Only applies to an Allocation whose Element is a vector of length 3 (such as
  /// Element\#U8_3 or Element\#RGB_888). Enabling this feature may make
  /// copying data from the Allocation to an array or vice-versa less efficient.
  ///
  ///  Vec3 Element cells are stored in an Allocation as Vec4 Element cells with
  /// the same android.renderscript.Element.DataType, with the fourth vector
  /// component treated as padding. When this feature is enabled, only the data components,
  /// i.e. the first 3 vector components of each cell, will be mapped between the array
  /// and the Allocation. When disabled, explicit mapping of the padding components
  /// is required, as described in the following example.
  ///
  ///  For example, when copying an integer array to an Allocation of two Element\#I32_3 cells using \#copyFrom(int[]):
  ///  When disabled:
  ///     The array must have at least 8 integers, with the first 4 integers copied
  ///     to the first cell of the Allocation, and the next 4 integers copied to
  ///     the second cell. The 4th and 8th integers are mapped as the padding components.
  ///
  ///  When enabled:
  ///     The array just needs to have at least 6 integers, with the first 3 integers
  ///     copied to the the first cell as data components, and the next 3 copied to
  ///     the second cell. There is no mapping for the padding components.
  ///
  ///  Similarly, when copying a byte array to an Allocation of two Element\#I32_3 cells, using \#copyFromUnchecked(int[]):
  ///  When disabled:
  ///     The array must have at least 32 bytes, with the first 16 bytes copied
  ///     to the first cell of the Allocation, and the next 16 bytes copied to
  ///     the second cell. The 13th-16th and 29th-32nd bytes are mapped as padding
  ///     components.
  ///
  ///  When enabled:
  ///     The array just needs to have at least 24 bytes, with the first 12 bytes copied
  ///     to the first cell of the Allocation, and the next 12 bytes copied to
  ///     the second cell. There is no mapping for the padding components.
  ///
  ///  Similar to copying data to an Allocation from an array, when copying data from an
  /// Allocation to an array, the padding components for Vec3 Element cells will not be
  /// copied/mapped to the array if AutoPadding is enabled.
  ///
  ///  Default: Disabled.
  ///@param useAutoPadding True: enable AutoPadding; False: disable AutoPadding
  void setAutoPadding(bool useAutoPadding) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAutoPadding,
      jni.JniType.voidType,
      [useAutoPadding]).check();

  static final _id_getBytesSize =
      jniAccessors.getMethodIDOf(_classRef, "getBytesSize", "()I");

  /// from: public int getBytesSize()
  ///
  /// Get the size of the Allocation in bytes.
  ///@return size of the Allocation in bytes.
  int getBytesSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getBytesSize, jni.JniType.intType, []).integer;

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getType = jniAccessors.getMethodIDOf(
      _classRef, "getType", "()Landroid/renderscript/Type;");

  /// from: public android.renderscript.Type getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the android.renderscript.Type of the Allocation.
  ///@return Type
  type_.Type getType() => type_.Type.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.objectType, []).object);

  static final _id_syncAll =
      jniAccessors.getMethodIDOf(_classRef, "syncAll", "(I)V");

  /// from: public void syncAll(int srcLocation)
  ///
  /// Propagate changes from one usage of the Allocation to the
  /// other usages of the Allocation.
  void syncAll(int srcLocation) => jniAccessors.callMethodWithArgs(
      reference, _id_syncAll, jni.JniType.voidType, [srcLocation]).check();

  static final _id_ioSend =
      jniAccessors.getMethodIDOf(_classRef, "ioSend", "()V");

  /// from: public void ioSend()
  ///
  /// Send a buffer to the output stream.  The contents of the Allocation will
  /// be undefined after this operation. This operation is only valid if \#USAGE_IO_OUTPUT is set on the Allocation.
  void ioSend() => jniAccessors.callMethodWithArgs(
      reference, _id_ioSend, jni.JniType.voidType, []).check();

  static final _id_ioReceive =
      jniAccessors.getMethodIDOf(_classRef, "ioReceive", "()V");

  /// from: public void ioReceive()
  ///
  /// Receive the latest input into the Allocation. This operation
  /// is only valid if \#USAGE_IO_INPUT is set on the Allocation.
  void ioReceive() => jniAccessors.callMethodWithArgs(
      reference, _id_ioReceive, jni.JniType.voidType, []).check();

  static final _id_copyFrom = jniAccessors.getMethodIDOf(
      _classRef, "copyFrom", "([Landroid/renderscript/BaseObj;)V");

  /// from: public void copyFrom(android.renderscript.BaseObj[] d)
  ///
  /// Copy an array of RS objects to the Allocation.
  ///@param d Source array.
  void copyFrom(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom, jni.JniType.voidType, [d.reference]).check();

  static final _id_copyFromUnchecked = jniAccessors.getMethodIDOf(
      _classRef, "copyFromUnchecked", "(Ljava/lang/Object;)V");

  /// from: public void copyFromUnchecked(java.lang.Object array)
  ///
  /// Copy into this Allocation from an array. This method does not guarantee
  /// that the Allocation is compatible with the input buffer; it copies memory
  /// without reinterpretation.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param array The source array
  void copyFromUnchecked(jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyFromUnchecked,
          jni.JniType.voidType, [array.reference]).check();

  static final _id_copyFromUnchecked1 =
      jniAccessors.getMethodIDOf(_classRef, "copyFromUnchecked", "([I)V");

  /// from: public void copyFromUnchecked(int[] d)
  ///
  /// Copy into this Allocation from an array. This method does not guarantee
  /// that the Allocation is compatible with the input buffer; it copies memory
  /// without reinterpretation.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d the source array
  void copyFromUnchecked1(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference,
      _id_copyFromUnchecked1,
      jni.JniType.voidType,
      [d.reference]).check();

  static final _id_copyFromUnchecked2 =
      jniAccessors.getMethodIDOf(_classRef, "copyFromUnchecked", "([S)V");

  /// from: public void copyFromUnchecked(short[] d)
  ///
  /// Copy into this Allocation from an array. This method does not guarantee
  /// that the Allocation is compatible with the input buffer; it copies memory
  /// without reinterpretation.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d the source array
  void copyFromUnchecked2(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference,
      _id_copyFromUnchecked2,
      jni.JniType.voidType,
      [d.reference]).check();

  static final _id_copyFromUnchecked3 =
      jniAccessors.getMethodIDOf(_classRef, "copyFromUnchecked", "([B)V");

  /// from: public void copyFromUnchecked(byte[] d)
  ///
  /// Copy into this Allocation from an array. This method does not guarantee
  /// that the Allocation is compatible with the input buffer; it copies memory
  /// without reinterpretation.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d the source array
  void copyFromUnchecked3(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference,
      _id_copyFromUnchecked3,
      jni.JniType.voidType,
      [d.reference]).check();

  static final _id_copyFromUnchecked4 =
      jniAccessors.getMethodIDOf(_classRef, "copyFromUnchecked", "([F)V");

  /// from: public void copyFromUnchecked(float[] d)
  ///
  /// Copy into this Allocation from an array. This method does not guarantee
  /// that the Allocation is compatible with the input buffer; it copies memory
  /// without reinterpretation.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d the source array
  void copyFromUnchecked4(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference,
      _id_copyFromUnchecked4,
      jni.JniType.voidType,
      [d.reference]).check();

  static final _id_copyFrom1 = jniAccessors.getMethodIDOf(
      _classRef, "copyFrom", "(Ljava/lang/Object;)V");

  /// from: public void copyFrom(java.lang.Object array)
  ///
  /// Copy into this Allocation from an array.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element does not match the array's
  /// primitive type.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param array The source array
  void copyFrom1(jni.JniObject array) => jniAccessors.callMethodWithArgs(
      reference,
      _id_copyFrom1,
      jni.JniType.voidType,
      [array.reference]).check();

  static final _id_copyFrom2 =
      jniAccessors.getMethodIDOf(_classRef, "copyFrom", "([I)V");

  /// from: public void copyFrom(int[] d)
  ///
  /// Copy into this Allocation from an array.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not a 32 bit integer nor a vector of 32 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d the source array
  void copyFrom2(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom2, jni.JniType.voidType, [d.reference]).check();

  static final _id_copyFrom3 =
      jniAccessors.getMethodIDOf(_classRef, "copyFrom", "([S)V");

  /// from: public void copyFrom(short[] d)
  ///
  /// Copy into this Allocation from an array.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not a 16 bit integer nor a vector of 16 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d the source array
  void copyFrom3(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom3, jni.JniType.voidType, [d.reference]).check();

  static final _id_copyFrom4 =
      jniAccessors.getMethodIDOf(_classRef, "copyFrom", "([B)V");

  /// from: public void copyFrom(byte[] d)
  ///
  /// Copy into this Allocation from an array.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not an 8 bit integer nor a vector of 8 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d the source array
  void copyFrom4(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom4, jni.JniType.voidType, [d.reference]).check();

  static final _id_copyFrom5 =
      jniAccessors.getMethodIDOf(_classRef, "copyFrom", "([F)V");

  /// from: public void copyFrom(float[] d)
  ///
  /// Copy into this Allocation from an array.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither a 32 bit float nor a vector of
  /// 32 bit floats android.renderscript.Element.DataType.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d the source array
  void copyFrom5(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom5, jni.JniType.voidType, [d.reference]).check();

  static final _id_copyFrom6 = jniAccessors.getMethodIDOf(
      _classRef, "copyFrom", "(Landroid/graphics/Bitmap;)V");

  /// from: public void copyFrom(android.graphics.Bitmap b)
  ///
  /// Copy into an Allocation from a android.graphics.Bitmap.  The
  /// height, width, and format of the bitmap must match the existing
  /// allocation.
  ///
  /// If the android.graphics.Bitmap is the same as the android.graphics.Bitmap used to create the Allocation with \#createFromBitmap and \#USAGE_SHARED is set on the Allocation,
  /// this will synchronize the Allocation with the latest data from the android.graphics.Bitmap, potentially avoiding the actual copy.
  ///
  ///@param b the source bitmap
  void copyFrom6(bitmap_.Bitmap b) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom6, jni.JniType.voidType, [b.reference]).check();

  static final _id_copyFrom7 = jniAccessors.getMethodIDOf(
      _classRef, "copyFrom", "(Landroid/renderscript/Allocation;)V");

  /// from: public void copyFrom(android.renderscript.Allocation a)
  ///
  /// Copy an Allocation from an Allocation.  The types of both allocations
  /// must be identical.
  ///@param a the source allocation
  void copyFrom7(Allocation a) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom7, jni.JniType.voidType, [a.reference]).check();

  static final _id_setFromFieldPacker = jniAccessors.getMethodIDOf(_classRef,
      "setFromFieldPacker", "(ILandroid/renderscript/FieldPacker;)V");

  /// from: public void setFromFieldPacker(int xoff, android.renderscript.FieldPacker fp)
  ///
  /// This is only intended to be used by auto-generated code reflected from
  /// the RenderScript script files and should not be used by developers.
  ///@param xoff
  ///@param fp
  void setFromFieldPacker(int xoff, fieldpacker_.FieldPacker fp) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFromFieldPacker,
          jni.JniType.voidType, [xoff, fp.reference]).check();

  static final _id_setFromFieldPacker1 = jniAccessors.getMethodIDOf(_classRef,
      "setFromFieldPacker", "(IILandroid/renderscript/FieldPacker;)V");

  /// from: public void setFromFieldPacker(int xoff, int component_number, android.renderscript.FieldPacker fp)
  ///
  /// This is only intended to be used by auto-generated code reflected from
  /// the RenderScript script files and should not be used by developers.
  ///@param xoff
  ///@param component_number
  ///@param fp
  void setFromFieldPacker1(
          int xoff, int component_number, fieldpacker_.FieldPacker fp) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFromFieldPacker1,
          jni.JniType.voidType, [xoff, component_number, fp.reference]).check();

  static final _id_setFromFieldPacker2 = jniAccessors.getMethodIDOf(_classRef,
      "setFromFieldPacker", "(IIIILandroid/renderscript/FieldPacker;)V");

  /// from: public void setFromFieldPacker(int xoff, int yoff, int zoff, int component_number, android.renderscript.FieldPacker fp)
  ///
  /// This is only intended to be used by auto-generated code reflected from
  /// the RenderScript script files and should not be used by developers.
  ///@param xoff
  ///@param yoff
  ///@param zoff
  ///@param component_number
  ///@param fp
  void setFromFieldPacker2(int xoff, int yoff, int zoff, int component_number,
          fieldpacker_.FieldPacker fp) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setFromFieldPacker2,
          jni.JniType.voidType,
          [xoff, yoff, zoff, component_number, fp.reference]).check();

  static final _id_generateMipmaps =
      jniAccessors.getMethodIDOf(_classRef, "generateMipmaps", "()V");

  /// from: public void generateMipmaps()
  ///
  /// Generate a mipmap chain. This is only valid if the Type of the Allocation
  /// includes mipmaps.
  ///
  /// This function will generate a complete set of mipmaps from the top
  /// level LOD and place them into the script memory space.
  ///
  ///
  /// If the Allocation is also using other memory spaces, a call to \#syncAll syncAll(Allocation.USAGE_SCRIPT) is required.
  ///
  void generateMipmaps() => jniAccessors.callMethodWithArgs(
      reference, _id_generateMipmaps, jni.JniType.voidType, []).check();

  static final _id_copy1DRangeFromUnchecked = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeFromUnchecked", "(IILjava/lang/Object;)V");

  /// from: public void copy1DRangeFromUnchecked(int off, int count, java.lang.Object array)
  ///
  /// Copy an array into a 1D region of this Allocation.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param array The source array
  void copy1DRangeFromUnchecked(int off, int count, jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFromUnchecked,
          jni.JniType.voidType, [off, count, array.reference]).check();

  static final _id_copy1DRangeFromUnchecked1 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeFromUnchecked", "(II[I)V");

  /// from: public void copy1DRangeFromUnchecked(int off, int count, int[] d)
  ///
  /// Copy an array into a 1D region of this Allocation.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeFromUnchecked1(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFromUnchecked1,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeFromUnchecked2 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeFromUnchecked", "(II[S)V");

  /// from: public void copy1DRangeFromUnchecked(int off, int count, short[] d)
  ///
  /// Copy an array into a 1D region of this Allocation.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeFromUnchecked2(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFromUnchecked2,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeFromUnchecked3 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeFromUnchecked", "(II[B)V");

  /// from: public void copy1DRangeFromUnchecked(int off, int count, byte[] d)
  ///
  /// Copy an array into a 1D region of this Allocation.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeFromUnchecked3(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFromUnchecked3,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeFromUnchecked4 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeFromUnchecked", "(II[F)V");

  /// from: public void copy1DRangeFromUnchecked(int off, int count, float[] d)
  ///
  /// Copy an array into a 1D region of this Allocation.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeFromUnchecked4(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFromUnchecked4,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeFrom = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeFrom", "(IILjava/lang/Object;)V");

  /// from: public void copy1DRangeFrom(int off, int count, java.lang.Object array)
  ///
  /// Copy an array into a 1D region of this Allocation.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element does not match the component type
  /// of the array passed in.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param array The source array.
  void copy1DRangeFrom(int off, int count, jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFrom,
          jni.JniType.voidType, [off, count, array.reference]).check();

  static final _id_copy1DRangeFrom1 =
      jniAccessors.getMethodIDOf(_classRef, "copy1DRangeFrom", "(II[I)V");

  /// from: public void copy1DRangeFrom(int off, int count, int[] d)
  ///
  /// Copy an array into a 1D region of this Allocation.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not an 32 bit integer nor a vector of 32 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeFrom1(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFrom1,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeFrom2 =
      jniAccessors.getMethodIDOf(_classRef, "copy1DRangeFrom", "(II[S)V");

  /// from: public void copy1DRangeFrom(int off, int count, short[] d)
  ///
  /// Copy an array into a 1D region of this Allocation.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not an 16 bit integer nor a vector of 16 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeFrom2(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFrom2,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeFrom3 =
      jniAccessors.getMethodIDOf(_classRef, "copy1DRangeFrom", "(II[B)V");

  /// from: public void copy1DRangeFrom(int off, int count, byte[] d)
  ///
  /// Copy an array into a 1D region of this Allocation.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not an 8 bit integer nor a vector of 8 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeFrom3(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFrom3,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeFrom4 =
      jniAccessors.getMethodIDOf(_classRef, "copy1DRangeFrom", "(II[F)V");

  /// from: public void copy1DRangeFrom(int off, int count, float[] d)
  ///
  /// Copy an array into a 1D region of this Allocation.  This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither a 32 bit float nor a vector of
  /// 32 bit floats android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array.
  void copy1DRangeFrom4(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFrom4,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeFrom5 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeFrom", "(IILandroid/renderscript/Allocation;I)V");

  /// from: public void copy1DRangeFrom(int off, int count, android.renderscript.Allocation data, int dataOff)
  ///
  /// Copy part of an Allocation into this Allocation.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param data the source data allocation.
  ///@param dataOff off The offset of the first element in data to
  ///          be copied.
  void copy1DRangeFrom5(int off, int count, Allocation data, int dataOff) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeFrom5,
          jni.JniType.voidType, [off, count, data.reference, dataOff]).check();

  static final _id_copy2DRangeFrom = jniAccessors.getMethodIDOf(
      _classRef, "copy2DRangeFrom", "(IIIILjava/lang/Object;)V");

  /// from: public void copy2DRangeFrom(int xoff, int yoff, int w, int h, java.lang.Object array)
  ///
  /// Copy from an array into a rectangular region in this Allocation.  The
  /// array is assumed to be tightly packed. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element does not match the input data type.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to update in this Allocation
  ///@param yoff Y offset of the region to update in this Allocation
  ///@param w Width of the region to update
  ///@param h Height of the region to update
  ///@param array Data to be placed into the Allocation
  void copy2DRangeFrom(int xoff, int yoff, int w, int h, jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeFrom,
          jni.JniType.voidType, [xoff, yoff, w, h, array.reference]).check();

  static final _id_copy2DRangeFrom1 =
      jniAccessors.getMethodIDOf(_classRef, "copy2DRangeFrom", "(IIII[B)V");

  /// from: public void copy2DRangeFrom(int xoff, int yoff, int w, int h, byte[] data)
  ///
  /// Copy from an array into a rectangular region in this Allocation.  The
  /// array is assumed to be tightly packed. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not an 8 bit integer nor a vector of 8 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to update in this Allocation
  ///@param yoff Y offset of the region to update in this Allocation
  ///@param w Width of the region to update
  ///@param h Height of the region to update
  ///@param data to be placed into the Allocation
  void copy2DRangeFrom1(int xoff, int yoff, int w, int h, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeFrom1,
          jni.JniType.voidType, [xoff, yoff, w, h, data.reference]).check();

  static final _id_copy2DRangeFrom2 =
      jniAccessors.getMethodIDOf(_classRef, "copy2DRangeFrom", "(IIII[S)V");

  /// from: public void copy2DRangeFrom(int xoff, int yoff, int w, int h, short[] data)
  ///
  /// Copy from an array into a rectangular region in this Allocation.  The
  /// array is assumed to be tightly packed. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not a 16 bit integer nor a vector of 16 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to update in this Allocation
  ///@param yoff Y offset of the region to update in this Allocation
  ///@param w Width of the region to update
  ///@param h Height of the region to update
  ///@param data to be placed into the Allocation
  void copy2DRangeFrom2(int xoff, int yoff, int w, int h, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeFrom2,
          jni.JniType.voidType, [xoff, yoff, w, h, data.reference]).check();

  static final _id_copy2DRangeFrom3 =
      jniAccessors.getMethodIDOf(_classRef, "copy2DRangeFrom", "(IIII[I)V");

  /// from: public void copy2DRangeFrom(int xoff, int yoff, int w, int h, int[] data)
  ///
  /// Copy from an array into a rectangular region in this Allocation.  The
  /// array is assumed to be tightly packed. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not a 32 bit integer nor a vector of 32 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to update in this Allocation
  ///@param yoff Y offset of the region to update in this Allocation
  ///@param w Width of the region to update
  ///@param h Height of the region to update
  ///@param data to be placed into the Allocation
  void copy2DRangeFrom3(int xoff, int yoff, int w, int h, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeFrom3,
          jni.JniType.voidType, [xoff, yoff, w, h, data.reference]).check();

  static final _id_copy2DRangeFrom4 =
      jniAccessors.getMethodIDOf(_classRef, "copy2DRangeFrom", "(IIII[F)V");

  /// from: public void copy2DRangeFrom(int xoff, int yoff, int w, int h, float[] data)
  ///
  /// Copy from an array into a rectangular region in this Allocation.  The
  /// array is assumed to be tightly packed. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither a 32 bit float nor a vector of
  /// 32 bit floats android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to update in this Allocation
  ///@param yoff Y offset of the region to update in this Allocation
  ///@param w Width of the region to update
  ///@param h Height of the region to update
  ///@param data to be placed into the Allocation
  void copy2DRangeFrom4(int xoff, int yoff, int w, int h, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeFrom4,
          jni.JniType.voidType, [xoff, yoff, w, h, data.reference]).check();

  static final _id_copy2DRangeFrom5 = jniAccessors.getMethodIDOf(_classRef,
      "copy2DRangeFrom", "(IIIILandroid/renderscript/Allocation;II)V");

  /// from: public void copy2DRangeFrom(int xoff, int yoff, int w, int h, android.renderscript.Allocation data, int dataXoff, int dataYoff)
  ///
  /// Copy a rectangular region from an Allocation into a rectangular region in
  /// this Allocation.
  ///@param xoff X offset of the region in this Allocation
  ///@param yoff Y offset of the region in this Allocation
  ///@param w Width of the region to update.
  ///@param h Height of the region to update.
  ///@param data source Allocation.
  ///@param dataXoff X offset in source Allocation
  ///@param dataYoff Y offset in source Allocation
  void copy2DRangeFrom5(int xoff, int yoff, int w, int h, Allocation data,
          int dataXoff, int dataYoff) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_copy2DRangeFrom5,
          jni.JniType.voidType,
          [xoff, yoff, w, h, data.reference, dataXoff, dataYoff]).check();

  static final _id_copy2DRangeFrom6 = jniAccessors.getMethodIDOf(
      _classRef, "copy2DRangeFrom", "(IILandroid/graphics/Bitmap;)V");

  /// from: public void copy2DRangeFrom(int xoff, int yoff, android.graphics.Bitmap data)
  ///
  /// Copy a android.graphics.Bitmap into an Allocation.  The height
  /// and width of the update will use the height and width of the android.graphics.Bitmap.
  ///@param xoff X offset of the region to update in this Allocation
  ///@param yoff Y offset of the region to update in this Allocation
  ///@param data the Bitmap to be copied
  void copy2DRangeFrom6(int xoff, int yoff, bitmap_.Bitmap data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeFrom6,
          jni.JniType.voidType, [xoff, yoff, data.reference]).check();

  static final _id_copy3DRangeFrom = jniAccessors.getMethodIDOf(
      _classRef, "copy3DRangeFrom", "(IIIIIILjava/lang/Object;)V");

  /// from: public void copy3DRangeFrom(int xoff, int yoff, int zoff, int w, int h, int d, java.lang.Object array)
  ///
  /// Copy from an array into a 3D region in this Allocation.  The
  /// array is assumed to be tightly packed. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element does not match the input data type.
  ///
  ///  The size of the region is: w * h * d * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to update in this Allocation
  ///@param yoff Y offset of the region to update in this Allocation
  ///@param zoff Z offset of the region to update in this Allocation
  ///@param w Width of the region to update
  ///@param h Height of the region to update
  ///@param d Depth of the region to update
  ///@param array to be placed into the allocation
  void copy3DRangeFrom(int xoff, int yoff, int zoff, int w, int h, int d,
          jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_copy3DRangeFrom,
          jni.JniType.voidType,
          [xoff, yoff, zoff, w, h, d, array.reference]).check();

  static final _id_copy3DRangeFrom1 = jniAccessors.getMethodIDOf(_classRef,
      "copy3DRangeFrom", "(IIIIIILandroid/renderscript/Allocation;III)V");

  /// from: public void copy3DRangeFrom(int xoff, int yoff, int zoff, int w, int h, int d, android.renderscript.Allocation data, int dataXoff, int dataYoff, int dataZoff)
  ///
  /// Copy a rectangular region into the allocation from another
  /// allocation.
  ///@param xoff X offset of the region to update in this Allocation
  ///@param yoff Y offset of the region to update in this Allocation
  ///@param zoff Z offset of the region to update in this Allocation
  ///@param w Width of the region to update.
  ///@param h Height of the region to update.
  ///@param d Depth of the region to update.
  ///@param data source allocation.
  ///@param dataXoff X offset of the region in the source Allocation
  ///@param dataYoff Y offset of the region in the source Allocation
  ///@param dataZoff Z offset of the region in the source Allocation
  void copy3DRangeFrom1(int xoff, int yoff, int zoff, int w, int h, int d,
          Allocation data, int dataXoff, int dataYoff, int dataZoff) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_copy3DRangeFrom1, jni.JniType.voidType, [
        xoff,
        yoff,
        zoff,
        w,
        h,
        d,
        data.reference,
        dataXoff,
        dataYoff,
        dataZoff
      ]).check();

  static final _id_copyTo = jniAccessors.getMethodIDOf(
      _classRef, "copyTo", "(Landroid/graphics/Bitmap;)V");

  /// from: public void copyTo(android.graphics.Bitmap b)
  ///
  /// Copy from the Allocation into a android.graphics.Bitmap.  The
  /// bitmap must match the dimensions of the Allocation.
  ///@param b The bitmap to be set from the Allocation.
  void copyTo(bitmap_.Bitmap b) => jniAccessors.callMethodWithArgs(
      reference, _id_copyTo, jni.JniType.voidType, [b.reference]).check();

  static final _id_copyTo1 =
      jniAccessors.getMethodIDOf(_classRef, "copyTo", "(Ljava/lang/Object;)V");

  /// from: public void copyTo(java.lang.Object array)
  ///
  /// Copy from the Allocation into an array. The method is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element does not match the input data type.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells will be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param array The array to be set from the Allocation.
  void copyTo1(jni.JniObject array) => jniAccessors.callMethodWithArgs(
      reference, _id_copyTo1, jni.JniType.voidType, [array.reference]).check();

  static final _id_copyTo2 =
      jniAccessors.getMethodIDOf(_classRef, "copyTo", "([B)V");

  /// from: public void copyTo(byte[] d)
  ///
  /// Copy from the Allocation into a byte array. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither an 8 bit integer nor a vector of 8 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells will be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d The array to be set from the Allocation.
  void copyTo2(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyTo2, jni.JniType.voidType, [d.reference]).check();

  static final _id_copyTo3 =
      jniAccessors.getMethodIDOf(_classRef, "copyTo", "([S)V");

  /// from: public void copyTo(short[] d)
  ///
  /// Copy from the Allocation into a short array. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not a 16 bit integer nor a vector of 16 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells will be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d The array to be set from the Allocation.
  void copyTo3(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyTo3, jni.JniType.voidType, [d.reference]).check();

  static final _id_copyTo4 =
      jniAccessors.getMethodIDOf(_classRef, "copyTo", "([I)V");

  /// from: public void copyTo(int[] d)
  ///
  /// Copy from the Allocation into a int array. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is not a 32 bit integer nor a vector of 32 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells will be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d The array to be set from the Allocation.
  void copyTo4(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyTo4, jni.JniType.voidType, [d.reference]).check();

  static final _id_copyTo5 =
      jniAccessors.getMethodIDOf(_classRef, "copyTo", "([F)V");

  /// from: public void copyTo(float[] d)
  ///
  /// Copy from the Allocation into a float array. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither a 32 bit float nor a vector of
  /// 32 bit floats android.renderscript.Element.DataType.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the Allocation \#getBytesSize getBytesSize().
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells will be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the Allocation \#getBytesSize getBytesSize(). The padding bytes for
  /// the cells must not be part of the array.
  ///@param d The array to be set from the Allocation.
  void copyTo5(jni.JniObject d) => jniAccessors.callMethodWithArgs(
      reference, _id_copyTo5, jni.JniType.voidType, [d.reference]).check();

  static final _id_resize =
      jniAccessors.getMethodIDOf(_classRef, "resize", "(I)V");

  /// from: synchronized public void resize(int dimX)
  ///
  /// Resize a 1D allocation.  The contents of the allocation are preserved.
  /// If new elements are allocated objects are created with null contents and
  /// the new region is otherwise undefined.
  ///
  /// If the new region is smaller the references of any objects outside the
  /// new region will be released.
  ///
  ///
  /// A new type will be created with the new dimension.
  ///
  ///@param dimX The new size of the allocation.
  ///@deprecated RenderScript objects should be immutable once created.  The
  /// replacement is to create a new allocation and copy the contents. This
  /// function will throw an exception if API 21 or higher is used.
  void resize(int dimX) => jniAccessors.callMethodWithArgs(
      reference, _id_resize, jni.JniType.voidType, [dimX]).check();

  static final _id_copy1DRangeToUnchecked = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeToUnchecked", "(IILjava/lang/Object;)V");

  /// from: public void copy1DRangeToUnchecked(int off, int count, java.lang.Object array)
  ///
  /// Copy a 1D region of this Allocation into an array.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param array The dest array
  void copy1DRangeToUnchecked(int off, int count, jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeToUnchecked,
          jni.JniType.voidType, [off, count, array.reference]).check();

  static final _id_copy1DRangeToUnchecked1 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeToUnchecked", "(II[I)V");

  /// from: public void copy1DRangeToUnchecked(int off, int count, int[] d)
  ///
  /// Copy a 1D region of this Allocation into an array.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeToUnchecked1(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeToUnchecked1,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeToUnchecked2 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeToUnchecked", "(II[S)V");

  /// from: public void copy1DRangeToUnchecked(int off, int count, short[] d)
  ///
  /// Copy a 1D region of this Allocation into an array.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeToUnchecked2(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeToUnchecked2,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeToUnchecked3 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeToUnchecked", "(II[B)V");

  /// from: public void copy1DRangeToUnchecked(int off, int count, byte[] d)
  ///
  /// Copy a 1D region of this Allocation into an array.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeToUnchecked3(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeToUnchecked3,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeToUnchecked4 = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeToUnchecked", "(II[F)V");

  /// from: public void copy1DRangeToUnchecked(int off, int count, float[] d)
  ///
  /// Copy a 1D region of this Allocation into an array.  This method does not
  /// guarantee that the Allocation is compatible with the input buffer.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeToUnchecked4(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeToUnchecked4,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeTo = jniAccessors.getMethodIDOf(
      _classRef, "copy1DRangeTo", "(IILjava/lang/Object;)V");

  /// from: public void copy1DRangeTo(int off, int count, java.lang.Object array)
  ///
  /// Copy a 1D region of this Allocation into an array.  This method is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element does not match the component type
  /// of the array passed in.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param array The source array.
  void copy1DRangeTo(int off, int count, jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeTo,
          jni.JniType.voidType, [off, count, array.reference]).check();

  static final _id_copy1DRangeTo1 =
      jniAccessors.getMethodIDOf(_classRef, "copy1DRangeTo", "(II[I)V");

  /// from: public void copy1DRangeTo(int off, int count, int[] d)
  ///
  /// Copy a 1D region of this Allocation into an array. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither a 32 bit integer nor a vector of 32 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeTo1(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeTo1,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeTo2 =
      jniAccessors.getMethodIDOf(_classRef, "copy1DRangeTo", "(II[S)V");

  /// from: public void copy1DRangeTo(int off, int count, short[] d)
  ///
  /// Copy a 1D region of this Allocation into an array. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither a 16 bit integer nor a vector of 16 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeTo2(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeTo2,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeTo3 =
      jniAccessors.getMethodIDOf(_classRef, "copy1DRangeTo", "(II[B)V");

  /// from: public void copy1DRangeTo(int off, int count, byte[] d)
  ///
  /// Copy a 1D region of this Allocation into an array. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither an 8 bit integer nor a vector of 8 bit
  /// integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array
  void copy1DRangeTo3(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeTo3,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy1DRangeTo4 =
      jniAccessors.getMethodIDOf(_classRef, "copy1DRangeTo", "(II[F)V");

  /// from: public void copy1DRangeTo(int off, int count, float[] d)
  ///
  /// Copy a 1D region of this Allocation into an array. This variant is type checked
  /// and will generate exceptions if the Allocation's android.renderscript.Element is neither a 32 bit float nor a vector of
  /// 32 bit floats android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: count * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param off The offset of the first element to be copied.
  ///@param count The number of elements to be copied.
  ///@param d the source array.
  void copy1DRangeTo4(int off, int count, jni.JniObject d) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy1DRangeTo4,
          jni.JniType.voidType, [off, count, d.reference]).check();

  static final _id_copy2DRangeTo = jniAccessors.getMethodIDOf(
      _classRef, "copy2DRangeTo", "(IIIILjava/lang/Object;)V");

  /// from: public void copy2DRangeTo(int xoff, int yoff, int w, int h, java.lang.Object array)
  ///
  /// Copy from a rectangular region in this Allocation into an array. This
  /// method is type checked and will generate exceptions if the Allocation's
  /// android.renderscript.Element does not match the component type
  /// of the array passed in.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to copy in this Allocation
  ///@param yoff Y offset of the region to copy in this Allocation
  ///@param w Width of the region to copy
  ///@param h Height of the region to copy
  ///@param array Dest Array to be copied into
  void copy2DRangeTo(int xoff, int yoff, int w, int h, jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeTo,
          jni.JniType.voidType, [xoff, yoff, w, h, array.reference]).check();

  static final _id_copy2DRangeTo1 =
      jniAccessors.getMethodIDOf(_classRef, "copy2DRangeTo", "(IIII[B)V");

  /// from: public void copy2DRangeTo(int xoff, int yoff, int w, int h, byte[] data)
  ///
  /// Copy from a rectangular region in this Allocation into an array. This
  /// variant is type checked and will generate exceptions if the Allocation's
  /// android.renderscript.Element is neither an 8 bit integer nor a vector
  /// of 8 bit integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to copy in this Allocation
  ///@param yoff Y offset of the region to copy in this Allocation
  ///@param w Width of the region to copy
  ///@param h Height of the region to copy
  ///@param data Dest Array to be copied into
  void copy2DRangeTo1(int xoff, int yoff, int w, int h, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeTo1,
          jni.JniType.voidType, [xoff, yoff, w, h, data.reference]).check();

  static final _id_copy2DRangeTo2 =
      jniAccessors.getMethodIDOf(_classRef, "copy2DRangeTo", "(IIII[S)V");

  /// from: public void copy2DRangeTo(int xoff, int yoff, int w, int h, short[] data)
  ///
  /// Copy from a rectangular region in this Allocation into an array. This
  /// variant is type checked and will generate exceptions if the Allocation's
  /// android.renderscript.Element is neither a 16 bit integer nor a vector
  /// of 16 bit integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to copy in this Allocation
  ///@param yoff Y offset of the region to copy in this Allocation
  ///@param w Width of the region to copy
  ///@param h Height of the region to copy
  ///@param data Dest Array to be copied into
  void copy2DRangeTo2(int xoff, int yoff, int w, int h, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeTo2,
          jni.JniType.voidType, [xoff, yoff, w, h, data.reference]).check();

  static final _id_copy2DRangeTo3 =
      jniAccessors.getMethodIDOf(_classRef, "copy2DRangeTo", "(IIII[I)V");

  /// from: public void copy2DRangeTo(int xoff, int yoff, int w, int h, int[] data)
  ///
  /// Copy from a rectangular region in this Allocation into an array. This
  /// variant is type checked and will generate exceptions if the Allocation's
  /// android.renderscript.Element is neither a 32 bit integer nor a vector
  /// of 32 bit integers android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to copy in this Allocation
  ///@param yoff Y offset of the region to copy in this Allocation
  ///@param w Width of the region to copy
  ///@param h Height of the region to copy
  ///@param data Dest Array to be copied into
  void copy2DRangeTo3(int xoff, int yoff, int w, int h, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeTo3,
          jni.JniType.voidType, [xoff, yoff, w, h, data.reference]).check();

  static final _id_copy2DRangeTo4 =
      jniAccessors.getMethodIDOf(_classRef, "copy2DRangeTo", "(IIII[F)V");

  /// from: public void copy2DRangeTo(int xoff, int yoff, int w, int h, float[] data)
  ///
  /// Copy from a rectangular region in this Allocation into an array. This
  /// variant is type checked and will generate exceptions if the Allocation's
  /// android.renderscript.Element is neither a 32 bit float nor a vector
  /// of 32 bit floats android.renderscript.Element.DataType.
  ///
  ///  The size of the region is: w * h * \#getElement.Element\#getBytesSize.
  ///
  ///  If the Allocation does not have Vec3 Elements, then the size of the
  /// array in bytes must be at least the size of the region.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is disabled, then the size of the array in bytes must be at least the size
  /// of the region. The padding bytes for the cells must be part of the array.
  ///
  ///  If the Allocation has Vec3 Elements and \#setAutoPadding AutoPadding
  /// is enabled, then the size of the array in bytes must be at least 3/4 the size
  /// of the region. The padding bytes for the cells must not be part of the array.
  ///@param xoff X offset of the region to copy in this Allocation
  ///@param yoff Y offset of the region to copy in this Allocation
  ///@param w Width of the region to copy
  ///@param h Height of the region to copy
  ///@param data Dest Array to be copied into
  void copy2DRangeTo4(int xoff, int yoff, int w, int h, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_copy2DRangeTo4,
          jni.JniType.voidType, [xoff, yoff, w, h, data.reference]).check();

  static final _id_copy3DRangeTo = jniAccessors.getMethodIDOf(
      _classRef, "copy3DRangeTo", "(IIIIIILjava/lang/Object;)V");

  /// from: public void copy3DRangeTo(int xoff, int yoff, int zoff, int w, int h, int d, java.lang.Object array)
  void copy3DRangeTo(int xoff, int yoff, int zoff, int w, int h, int d,
          jni.JniObject array) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_copy3DRangeTo,
          jni.JniType.voidType,
          [xoff, yoff, zoff, w, h, d, array.reference]).check();

  static final _id_createTyped = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createTyped",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Type;Landroid/renderscript/Allocation\$MipmapControl;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createTyped(android.renderscript.RenderScript rs, android.renderscript.Type type, android.renderscript.Allocation.MipmapControl mips, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new Allocation with the given android.renderscript.Type, mipmap flag, and usage flags.
  ///@param type RenderScript type describing data layout
  ///@param mips specifies desired mipmap behaviour for the
  ///             allocation
  ///@param usage bit field specifying how the Allocation is
  ///              utilized
  static Allocation createTyped(renderscript_.RenderScript rs, type_.Type type,
          Allocation_MipmapControl mips, int usage) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createTyped,
          jni.JniType.objectType,
          [rs.reference, type.reference, mips.reference, usage]).object);

  static final _id_createTyped1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createTyped",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Type;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createTyped(android.renderscript.RenderScript rs, android.renderscript.Type type, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an Allocation with the size specified by the type and no mipmaps
  /// generated by default
  ///@param rs Context to which the allocation will belong.
  ///@param type renderscript type describing data layout
  ///@param usage bit field specifying how the allocation is
  ///              utilized
  ///@return allocation
  static Allocation createTyped1(
          renderscript_.RenderScript rs, type_.Type type, int usage) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createTyped1,
          jni.JniType.objectType,
          [rs.reference, type.reference, usage]).object);

  static final _id_createTyped2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createTyped",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Type;)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createTyped(android.renderscript.RenderScript rs, android.renderscript.Type type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an Allocation for use by scripts with a given android.renderscript.Type and no mipmaps
  ///@param rs Context to which the Allocation will belong.
  ///@param type RenderScript Type describing data layout
  ///@return allocation
  static Allocation createTyped2(
          renderscript_.RenderScript rs, type_.Type type) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createTyped2,
          jni.JniType.objectType,
          [rs.reference, type.reference]).object);

  static final _id_createSized = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createSized",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Element;II)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createSized(android.renderscript.RenderScript rs, android.renderscript.Element e, int count, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an Allocation with a specified number of given elements
  ///@param rs Context to which the Allocation will belong.
  ///@param e Element to use in the Allocation
  ///@param count the number of Elements in the Allocation
  ///@param usage bit field specifying how the Allocation is
  ///              utilized
  ///@return allocation
  static Allocation createSized(renderscript_.RenderScript rs,
          element_.Element e, int count, int usage) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createSized,
          jni.JniType.objectType,
          [rs.reference, e.reference, count, usage]).object);

  static final _id_createSized1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createSized",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Element;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createSized(android.renderscript.RenderScript rs, android.renderscript.Element e, int count)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an Allocation with a specified number of given elements
  ///@param rs Context to which the Allocation will belong.
  ///@param e Element to use in the Allocation
  ///@param count the number of Elements in the Allocation
  ///@return allocation
  static Allocation createSized1(
          renderscript_.RenderScript rs, element_.Element e, int count) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createSized1,
          jni.JniType.objectType,
          [rs.reference, e.reference, count]).object);

  static final _id_createFromBitmap = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromBitmap",
      "(Landroid/renderscript/RenderScript;Landroid/graphics/Bitmap;Landroid/renderscript/Allocation\$MipmapControl;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createFromBitmap(android.renderscript.RenderScript rs, android.graphics.Bitmap b, android.renderscript.Allocation.MipmapControl mips, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an Allocation from a android.graphics.Bitmap.
  ///@param rs Context to which the allocation will belong.
  ///@param b Bitmap source for the allocation data
  ///@param mips specifies desired mipmap behaviour for the
  ///             allocation
  ///@param usage bit field specifying how the allocation is
  ///              utilized
  ///@return Allocation containing bitmap data
  static Allocation createFromBitmap(renderscript_.RenderScript rs,
          bitmap_.Bitmap b, Allocation_MipmapControl mips, int usage) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromBitmap,
          jni.JniType.objectType,
          [rs.reference, b.reference, mips.reference, usage]).object);

  static final _id_getByteBuffer = jniAccessors.getMethodIDOf(
      _classRef, "getByteBuffer", "()Ljava/nio/ByteBuffer;");

  /// from: public java.nio.ByteBuffer getByteBuffer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets or creates a ByteBuffer that contains the raw data of the current Allocation.
  ///  If the Allocation is created with USAGE_IO_INPUT, the returned ByteBuffer
  /// would contain the up-to-date data as READ ONLY.
  /// For a 2D or 3D Allocation, the raw data maybe padded so that each row of
  /// the Allocation has certain alignment. The size of each row including padding,
  /// called stride, can be queried using the \#getStride() method.
  ///
  /// Note: Operating on the ByteBuffer of a destroyed Allocation will triger errors.
  ///@return ByteBuffer The ByteBuffer associated with raw data pointer of the Allocation.
  jni.JniObject getByteBuffer() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getByteBuffer, jni.JniType.objectType, []).object);

  static final _id_createAllocations = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createAllocations",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Type;II)[Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation[] createAllocations(android.renderscript.RenderScript rs, android.renderscript.Type t, int usage, int numAlloc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new Allocation Array with the given android.renderscript.Type, and usage flags.
  /// Note: If the input allocation is of usage: USAGE_IO_INPUT,
  /// the created Allocation will be sharing the same BufferQueue.
  ///@param rs RenderScript context
  ///@param t RenderScript type describing data layout
  ///@param usage bit field specifying how the Allocation is
  ///              utilized
  ///@param numAlloc Number of Allocations in the array.
  ///@return Allocation[]
  static jni.JniObject createAllocations(renderscript_.RenderScript rs,
          type_.Type t, int usage, int numAlloc) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createAllocations,
          jni.JniType.objectType,
          [rs.reference, t.reference, usage, numAlloc]).object);

  static final _id_getStride =
      jniAccessors.getMethodIDOf(_classRef, "getStride", "()J");

  /// from: public long getStride()
  ///
  /// Gets the stride of the Allocation.
  /// For a 2D or 3D Allocation, the raw data maybe padded so that each row of
  /// the Allocation has certain alignment. The size of each row including such
  /// padding is called stride.
  ///@return the stride. For 1D Allocation, the stride will be the number of
  ///         bytes of this Allocation. For 2D and 3D Allocations, the stride
  ///         will be the stride in X dimension measuring in bytes.
  int getStride() => jniAccessors.callMethodWithArgs(
      reference, _id_getStride, jni.JniType.longType, []).long;

  static final _id_getTimeStamp =
      jniAccessors.getMethodIDOf(_classRef, "getTimeStamp", "()J");

  /// from: public long getTimeStamp()
  ///
  /// Get the timestamp for the most recent buffer held by this Allocation.
  /// The timestamp is guaranteed to be unique and monotonically increasing.
  /// Default value: -1. The timestamp will be updated after each \#ioReceive ioReceive() call.
  ///
  /// It can be used to identify the images by comparing the unique timestamps
  /// when used with android.hardware.camera2 APIs.
  /// Example steps:
  ///   1. Save android.hardware.camera2.TotalCaptureResult when the
  ///      capture is completed.
  ///   2. Get the timestamp after \#ioReceive ioReceive() call.
  ///   3. Comparing totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP) with
  ///      alloc.getTimeStamp().
  ///@return long Timestamp associated with the buffer held by the Allocation.
  int getTimeStamp() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimeStamp, jni.JniType.longType, []).long;

  static final _id_getSurface = jniAccessors.getMethodIDOf(
      _classRef, "getSurface", "()Landroid/view/Surface;");

  /// from: public android.view.Surface getSurface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the handle to a raw buffer that is being managed by the screen
  /// compositor. This operation is only valid for Allocations with \#USAGE_IO_INPUT.
  ///@return Surface object associated with allocation
  surface_.Surface getSurface() =>
      surface_.Surface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurface, jni.JniType.objectType, []).object);

  static final _id_setSurface = jniAccessors.getMethodIDOf(
      _classRef, "setSurface", "(Landroid/view/Surface;)V");

  /// from: public void setSurface(android.view.Surface sur)
  ///
  /// Associate a android.view.Surface with this Allocation. This
  /// operation is only valid for Allocations with \#USAGE_IO_OUTPUT.
  ///@param sur Surface to associate with allocation
  void setSurface(surface_.Surface sur) => jniAccessors.callMethodWithArgs(
      reference, _id_setSurface, jni.JniType.voidType, [sur.reference]).check();

  static final _id_createFromBitmap1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromBitmap",
      "(Landroid/renderscript/RenderScript;Landroid/graphics/Bitmap;)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createFromBitmap(android.renderscript.RenderScript rs, android.graphics.Bitmap b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an Allocation from a android.graphics.Bitmap.
  ///
  /// With target API version 18 or greater, this Allocation will be created
  /// with \#USAGE_SHARED, \#USAGE_SCRIPT, and \#USAGE_GRAPHICS_TEXTURE. With target API version 17 or lower, this
  /// Allocation will be created with \#USAGE_GRAPHICS_TEXTURE.
  ///
  ///@param rs Context to which the allocation will belong.
  ///@param b bitmap source for the allocation data
  ///@return Allocation containing bitmap data
  static Allocation createFromBitmap1(
          renderscript_.RenderScript rs, bitmap_.Bitmap b) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromBitmap1,
          jni.JniType.objectType,
          [rs.reference, b.reference]).object);

  static final _id_createCubemapFromBitmap = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createCubemapFromBitmap",
      "(Landroid/renderscript/RenderScript;Landroid/graphics/Bitmap;Landroid/renderscript/Allocation\$MipmapControl;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createCubemapFromBitmap(android.renderscript.RenderScript rs, android.graphics.Bitmap b, android.renderscript.Allocation.MipmapControl mips, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a cubemap Allocation from a android.graphics.Bitmap
  /// containing the horizontal list of cube faces. Each face must be a square,
  /// have the same size as all other faces, and have a width that is a power
  /// of 2.
  ///@param rs Context to which the allocation will belong.
  ///@param b Bitmap with cubemap faces layed out in the following
  ///          format: right, left, top, bottom, front, back
  ///@param mips specifies desired mipmap behaviour for the cubemap
  ///@param usage bit field specifying how the cubemap is utilized
  ///@return allocation containing cubemap data
  static Allocation createCubemapFromBitmap(renderscript_.RenderScript rs,
          bitmap_.Bitmap b, Allocation_MipmapControl mips, int usage) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createCubemapFromBitmap,
          jni.JniType.objectType,
          [rs.reference, b.reference, mips.reference, usage]).object);

  static final _id_createCubemapFromBitmap1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createCubemapFromBitmap",
      "(Landroid/renderscript/RenderScript;Landroid/graphics/Bitmap;)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createCubemapFromBitmap(android.renderscript.RenderScript rs, android.graphics.Bitmap b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a non-mipmapped cubemap Allocation for use as a graphics texture
  /// from a android.graphics.Bitmap containing the horizontal list of
  /// cube faces. Each face must be a square, have the same size as all other
  /// faces, and have a width that is a power of 2.
  ///@param rs Context to which the allocation will belong.
  ///@param b bitmap with cubemap faces layed out in the following
  ///          format: right, left, top, bottom, front, back
  ///@return allocation containing cubemap data
  static Allocation createCubemapFromBitmap1(
          renderscript_.RenderScript rs, bitmap_.Bitmap b) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createCubemapFromBitmap1,
          jni.JniType.objectType,
          [rs.reference, b.reference]).object);

  static final _id_createCubemapFromCubeFaces = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createCubemapFromCubeFaces",
      "(Landroid/renderscript/RenderScript;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/renderscript/Allocation\$MipmapControl;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createCubemapFromCubeFaces(android.renderscript.RenderScript rs, android.graphics.Bitmap xpos, android.graphics.Bitmap xneg, android.graphics.Bitmap ypos, android.graphics.Bitmap yneg, android.graphics.Bitmap zpos, android.graphics.Bitmap zneg, android.renderscript.Allocation.MipmapControl mips, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a cubemap Allocation from 6 android.graphics.Bitmap
  /// objects containing the cube faces. Each face must be a square, have the
  /// same size as all other faces, and have a width that is a power of 2.
  ///@param rs Context to which the allocation will belong.
  ///@param xpos cubemap face in the positive x direction
  ///@param xneg cubemap face in the negative x direction
  ///@param ypos cubemap face in the positive y direction
  ///@param yneg cubemap face in the negative y direction
  ///@param zpos cubemap face in the positive z direction
  ///@param zneg cubemap face in the negative z direction
  ///@param mips specifies desired mipmap behaviour for the cubemap
  ///@param usage bit field specifying how the cubemap is utilized
  ///@return allocation containing cubemap data
  static Allocation createCubemapFromCubeFaces(
          renderscript_.RenderScript rs,
          bitmap_.Bitmap xpos,
          bitmap_.Bitmap xneg,
          bitmap_.Bitmap ypos,
          bitmap_.Bitmap yneg,
          bitmap_.Bitmap zpos,
          bitmap_.Bitmap zneg,
          Allocation_MipmapControl mips,
          int usage) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createCubemapFromCubeFaces, jni.JniType.objectType, [
        rs.reference,
        xpos.reference,
        xneg.reference,
        ypos.reference,
        yneg.reference,
        zpos.reference,
        zneg.reference,
        mips.reference,
        usage
      ]).object);

  static final _id_createCubemapFromCubeFaces1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createCubemapFromCubeFaces",
      "(Landroid/renderscript/RenderScript;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;Landroid/graphics/Bitmap;)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createCubemapFromCubeFaces(android.renderscript.RenderScript rs, android.graphics.Bitmap xpos, android.graphics.Bitmap xneg, android.graphics.Bitmap ypos, android.graphics.Bitmap yneg, android.graphics.Bitmap zpos, android.graphics.Bitmap zneg)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a non-mipmapped cubemap Allocation for use as a sampler input
  /// from 6 android.graphics.Bitmap objects containing the cube
  /// faces. Each face must be a square, have the same size as all other faces,
  /// and have a width that is a power of 2.
  ///@param rs Context to which the allocation will belong.
  ///@param xpos cubemap face in the positive x direction
  ///@param xneg cubemap face in the negative x direction
  ///@param ypos cubemap face in the positive y direction
  ///@param yneg cubemap face in the negative y direction
  ///@param zpos cubemap face in the positive z direction
  ///@param zneg cubemap face in the negative z direction
  ///@return allocation containing cubemap data
  static Allocation createCubemapFromCubeFaces1(
          renderscript_.RenderScript rs,
          bitmap_.Bitmap xpos,
          bitmap_.Bitmap xneg,
          bitmap_.Bitmap ypos,
          bitmap_.Bitmap yneg,
          bitmap_.Bitmap zpos,
          bitmap_.Bitmap zneg) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createCubemapFromCubeFaces1, jni.JniType.objectType, [
        rs.reference,
        xpos.reference,
        xneg.reference,
        ypos.reference,
        yneg.reference,
        zpos.reference,
        zneg.reference
      ]).object);

  static final _id_createFromBitmapResource = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromBitmapResource",
      "(Landroid/renderscript/RenderScript;Landroid/content/res/Resources;ILandroid/renderscript/Allocation\$MipmapControl;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createFromBitmapResource(android.renderscript.RenderScript rs, android.content.res.Resources res, int id, android.renderscript.Allocation.MipmapControl mips, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an Allocation from the Bitmap referenced
  /// by resource ID.
  ///@param rs Context to which the allocation will belong.
  ///@param res application resources
  ///@param id resource id to load the data from
  ///@param mips specifies desired mipmap behaviour for the
  ///             allocation
  ///@param usage bit field specifying how the allocation is
  ///              utilized
  ///@return Allocation containing resource data
  static Allocation createFromBitmapResource(
          renderscript_.RenderScript rs,
          resources_.Resources res,
          int id,
          Allocation_MipmapControl mips,
          int usage) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromBitmapResource,
          jni.JniType.objectType,
          [rs.reference, res.reference, id, mips.reference, usage]).object);

  static final _id_createFromBitmapResource1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromBitmapResource",
      "(Landroid/renderscript/RenderScript;Landroid/content/res/Resources;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createFromBitmapResource(android.renderscript.RenderScript rs, android.content.res.Resources res, int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a non-mipmapped Allocation to use as a graphics texture from the
  /// android.graphics.Bitmap referenced by resource ID.
  ///
  /// With target API version 18 or greater, this allocation will be created
  /// with \#USAGE_SCRIPT and \#USAGE_GRAPHICS_TEXTURE. With
  /// target API version 17 or lower, this allocation will be created with
  /// \#USAGE_GRAPHICS_TEXTURE.
  ///
  ///@param rs Context to which the allocation will belong.
  ///@param res application resources
  ///@param id resource id to load the data from
  ///@return Allocation containing resource data
  static Allocation createFromBitmapResource1(
          renderscript_.RenderScript rs, resources_.Resources res, int id) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromBitmapResource1,
          jni.JniType.objectType,
          [rs.reference, res.reference, id]).object);

  static final _id_createFromString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromString",
      "(Landroid/renderscript/RenderScript;Ljava/lang/String;I)Landroid/renderscript/Allocation;");

  /// from: static public android.renderscript.Allocation createFromString(android.renderscript.RenderScript rs, java.lang.String str, int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an Allocation containing string data encoded in UTF-8 format.
  ///@param rs Context to which the allocation will belong.
  ///@param str string to create the allocation from
  ///@param usage bit field specifying how the allocaiton is
  ///              utilized
  static Allocation createFromString(
          renderscript_.RenderScript rs, jni.JniString str, int usage) =>
      Allocation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromString,
          jni.JniType.objectType,
          [rs.reference, str.reference, usage]).object);

  static final _id_setOnBufferAvailableListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnBufferAvailableListener",
      "(Landroid/renderscript/Allocation\$OnBufferAvailableListener;)V");

  /// from: public void setOnBufferAvailableListener(android.renderscript.Allocation.OnBufferAvailableListener callback)
  ///
  /// Set a notification handler for \#USAGE_IO_INPUT.
  ///@param callback instance of the OnBufferAvailableListener
  ///                 class to be called when buffer arrive.
  void setOnBufferAvailableListener(
          Allocation_OnBufferAvailableListener callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnBufferAvailableListener,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_destroy =
      jniAccessors.getMethodIDOf(_classRef, "destroy", "()V");

  /// from: public void destroy()
  ///
  /// For USAGE_IO_OUTPUT, destroy() implies setSurface(null).
  void destroy() => jniAccessors.callMethodWithArgs(
      reference, _id_destroy, jni.JniType.voidType, []).check();
}

/// from: android.renderscript.Allocation$OnBufferAvailableListener
///
/// Interface to handle notification when new buffers are available via
/// \#USAGE_IO_INPUT. An application will receive one notification
/// when a buffer is available. Additional buffers will not trigger new
/// notifications until a buffer is processed.
class Allocation_OnBufferAvailableListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/renderscript/Allocation\$OnBufferAvailableListener");
  Allocation_OnBufferAvailableListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onBufferAvailable = jniAccessors.getMethodIDOf(
      _classRef, "onBufferAvailable", "(Landroid/renderscript/Allocation;)V");

  /// from: public abstract void onBufferAvailable(android.renderscript.Allocation a)
  void onBufferAvailable(Allocation a) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBufferAvailable,
      jni.JniType.voidType,
      [a.reference]).check();
}

/// from: android.renderscript.Allocation$MipmapControl
///
/// Controls mipmap behavior when using the bitmap creation and update
/// functions.
class Allocation_MipmapControl extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/renderscript/Allocation\$MipmapControl");
  Allocation_MipmapControl.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(_classRef,
      "values", "()[Landroid/renderscript/Allocation\$MipmapControl;");

  /// from: static public android.renderscript.Allocation.MipmapControl[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/renderscript/Allocation\$MipmapControl;");

  /// from: static public android.renderscript.Allocation.MipmapControl valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Allocation_MipmapControl valueOf(jni.JniString name) =>
      Allocation_MipmapControl.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Allocation_MipmapControl()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
