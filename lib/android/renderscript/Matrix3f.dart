// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.renderscript.Matrix3f
///
/// Class for exposing the native RenderScript rs_matrix3x3 type back to the Android system.
class Matrix3f extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/renderscript/Matrix3f");
  Matrix3f.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new identity 3x3 matrix
  Matrix3f()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([F)V");

  /// from: public void <init>(float[] dataArray)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new matrix and sets its values from the given
  /// parameter
  ///@param dataArray values to set the matrix to, must be 9
  ///                  floats long
  Matrix3f.ctor1(jni.JniObject dataArray)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [dataArray.reference]).object);

  static final _id_getArray =
      jniAccessors.getMethodIDOf(_classRef, "getArray", "()[F");

  /// from: public float[] getArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a reference to the internal array representing matrix
  /// values. Modifying this array will also change the matrix
  ///@return internal array representing the matrix
  jni.JniObject getArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getArray, jni.JniType.objectType, []).object);

  static final _id_get0 = jniAccessors.getMethodIDOf(_classRef, "get", "(II)F");

  /// from: public float get(int x, int y)
  ///
  /// Returns the value for a given row and column
  ///@param x column of the value to return
  ///@param y row of the value to return
  ///@return value in the yth row and xth column
  double get0(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_get0, jni.JniType.floatType, [x, y]).float;

  static final _id_set0 =
      jniAccessors.getMethodIDOf(_classRef, "set", "(IIF)V");

  /// from: public void set(int x, int y, float v)
  ///
  /// Sets the value for a given row and column
  ///@param x column of the value to set
  ///@param y row of the value to set
  void set0(int x, int y, double v) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.voidType, [x, y, v]).check();

  static final _id_loadIdentity =
      jniAccessors.getMethodIDOf(_classRef, "loadIdentity", "()V");

  /// from: public void loadIdentity()
  ///
  /// Sets the matrix values to identity
  void loadIdentity() => jniAccessors.callMethodWithArgs(
      reference, _id_loadIdentity, jni.JniType.voidType, []).check();

  static final _id_load = jniAccessors.getMethodIDOf(
      _classRef, "load", "(Landroid/renderscript/Matrix3f;)V");

  /// from: public void load(android.renderscript.Matrix3f src)
  ///
  /// Sets the values of the matrix to those of the parameter
  ///@param src matrix to load the values from
  void load(Matrix3f src) => jniAccessors.callMethodWithArgs(
      reference, _id_load, jni.JniType.voidType, [src.reference]).check();

  static final _id_loadRotate =
      jniAccessors.getMethodIDOf(_classRef, "loadRotate", "(FFFF)V");

  /// from: public void loadRotate(float rot, float x, float y, float z)
  ///
  /// Sets current values to be a rotation matrix of certain angle
  /// about a given axis
  ///@param rot angle of rotation
  ///@param x rotation axis x
  ///@param y rotation axis y
  ///@param z rotation axis z
  void loadRotate(double rot, double x, double y, double z) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadRotate,
          jni.JniType.voidType, [rot, x, y, z]).check();

  static final _id_loadRotate1 =
      jniAccessors.getMethodIDOf(_classRef, "loadRotate", "(F)V");

  /// from: public void loadRotate(float rot)
  ///
  /// Makes the upper 2x2 a rotation matrix of the given angle
  ///@param rot rotation angle
  void loadRotate1(double rot) => jniAccessors.callMethodWithArgs(
      reference, _id_loadRotate1, jni.JniType.voidType, [rot]).check();

  static final _id_loadScale =
      jniAccessors.getMethodIDOf(_classRef, "loadScale", "(FF)V");

  /// from: public void loadScale(float x, float y)
  ///
  /// Makes the upper 2x2 a scale matrix of given dimensions
  ///@param x scale component x
  ///@param y scale component y
  void loadScale(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_loadScale, jni.JniType.voidType, [x, y]).check();

  static final _id_loadScale1 =
      jniAccessors.getMethodIDOf(_classRef, "loadScale", "(FFF)V");

  /// from: public void loadScale(float x, float y, float z)
  ///
  /// Sets current values to be a scale matrix of given dimensions
  ///@param x scale component x
  ///@param y scale component y
  ///@param z scale component z
  void loadScale1(double x, double y, double z) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_loadScale1, jni.JniType.voidType, [x, y, z]).check();

  static final _id_loadTranslate =
      jniAccessors.getMethodIDOf(_classRef, "loadTranslate", "(FF)V");

  /// from: public void loadTranslate(float x, float y)
  ///
  /// Sets current values to be a translation matrix of given
  /// dimensions
  ///@param x translation component x
  ///@param y translation component y
  void loadTranslate(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_loadTranslate, jni.JniType.voidType, [x, y]).check();

  static final _id_loadMultiply = jniAccessors.getMethodIDOf(
      _classRef,
      "loadMultiply",
      "(Landroid/renderscript/Matrix3f;Landroid/renderscript/Matrix3f;)V");

  /// from: public void loadMultiply(android.renderscript.Matrix3f lhs, android.renderscript.Matrix3f rhs)
  ///
  /// Sets current values to be the result of multiplying two given
  /// matrices
  ///@param lhs left hand side matrix
  ///@param rhs right hand side matrix
  void loadMultiply(Matrix3f lhs, Matrix3f rhs) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadMultiply,
          jni.JniType.voidType, [lhs.reference, rhs.reference]).check();

  static final _id_multiply = jniAccessors.getMethodIDOf(
      _classRef, "multiply", "(Landroid/renderscript/Matrix3f;)V");

  /// from: public void multiply(android.renderscript.Matrix3f rhs)
  ///
  /// Post-multiplies the current matrix by a given parameter
  ///@param rhs right hand side to multiply by
  void multiply(Matrix3f rhs) => jniAccessors.callMethodWithArgs(
      reference, _id_multiply, jni.JniType.voidType, [rhs.reference]).check();

  static final _id_rotate =
      jniAccessors.getMethodIDOf(_classRef, "rotate", "(FFFF)V");

  /// from: public void rotate(float rot, float x, float y, float z)
  ///
  /// Modifies the current matrix by post-multiplying it with a
  /// rotation matrix of certain angle about a given axis
  ///@param rot angle of rotation
  ///@param x rotation axis x
  ///@param y rotation axis y
  ///@param z rotation axis z
  void rotate(double rot, double x, double y, double z) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_rotate, jni.JniType.voidType, [rot, x, y, z]).check();

  static final _id_rotate1 =
      jniAccessors.getMethodIDOf(_classRef, "rotate", "(F)V");

  /// from: public void rotate(float rot)
  ///
  /// Modifies the upper 2x2 of the current matrix by
  /// post-multiplying it with a rotation matrix of given angle
  ///@param rot angle of rotation
  void rotate1(double rot) => jniAccessors.callMethodWithArgs(
      reference, _id_rotate1, jni.JniType.voidType, [rot]).check();

  static final _id_scale =
      jniAccessors.getMethodIDOf(_classRef, "scale", "(FF)V");

  /// from: public void scale(float x, float y)
  ///
  /// Modifies the upper 2x2 of the current matrix by
  /// post-multiplying it with a scale matrix of given dimensions
  ///@param x scale component x
  ///@param y scale component y
  void scale(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_scale, jni.JniType.voidType, [x, y]).check();

  static final _id_scale1 =
      jniAccessors.getMethodIDOf(_classRef, "scale", "(FFF)V");

  /// from: public void scale(float x, float y, float z)
  ///
  /// Modifies the current matrix by post-multiplying it with a
  /// scale matrix of given dimensions
  ///@param x scale component x
  ///@param y scale component y
  ///@param z scale component z
  void scale1(double x, double y, double z) => jniAccessors.callMethodWithArgs(
      reference, _id_scale1, jni.JniType.voidType, [x, y, z]).check();

  static final _id_translate =
      jniAccessors.getMethodIDOf(_classRef, "translate", "(FF)V");

  /// from: public void translate(float x, float y)
  ///
  /// Modifies the current matrix by post-multiplying it with a
  /// translation matrix of given dimensions
  ///@param x translation component x
  ///@param y translation component y
  void translate(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_translate, jni.JniType.voidType, [x, y]).check();

  static final _id_transpose =
      jniAccessors.getMethodIDOf(_classRef, "transpose", "()V");

  /// from: public void transpose()
  ///
  /// Sets the current matrix to its transpose
  void transpose() => jniAccessors.callMethodWithArgs(
      reference, _id_transpose, jni.JniType.voidType, []).check();
}
