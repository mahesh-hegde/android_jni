// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ScriptIntrinsic.dart" as scriptintrinsic_;

import "RenderScript.dart" as renderscript_;

import "Element.dart" as element_;

import "Matrix4f.dart" as matrix4f_;

import "Matrix3f.dart" as matrix3f_;

import "Float4.dart" as float4_;

import "Allocation.dart" as allocation_;

import "Script.dart" as script_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.renderscript.ScriptIntrinsicColorMatrix
///
/// Intrinsic for applying a color matrix to allocations.
///
/// If the element type is Element.DataType\#UNSIGNED_8,
/// it is converted to Element.DataType\#FLOAT_32 and
/// normalized from (0-255) to (0-1). If the incoming vector size
/// is less than four, a Element\#F32_4 is created by
/// filling the missing vector channels with zero. This value is
/// then multiplied by the 4x4 color matrix as performed by
/// rsMatrixMultiply(), adding a Element\#F32_4, and then
/// writing it to the output Allocation.
///
/// If the ouptut type is unsigned, the value is normalized from
/// (0-1) to (0-255) and converted. If the output vector size is
/// less than four, the unused channels are discarded.
///
/// Supported elements types are Element\#U8, Element\#U8_2, Element\#U8_3, Element\#U8_4,
/// Element\#F32, Element\#F32_2, Element\#F32_3, and Element\#F32_4.
class ScriptIntrinsicColorMatrix extends scriptintrinsic_.ScriptIntrinsic {
  static final _classRef = jniAccessors
      .getClassOf("android/renderscript/ScriptIntrinsicColorMatrix");
  ScriptIntrinsicColorMatrix.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Element;)Landroid/renderscript/ScriptIntrinsicColorMatrix;");

  /// from: static public android.renderscript.ScriptIntrinsicColorMatrix create(android.renderscript.RenderScript rs, android.renderscript.Element e)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intrinsic for applying a color matrix to an
  /// allocation.
  ///@param rs The RenderScript context
  ///@param e Element type for inputs and outputs, As of API 19,
  ///          this parameter is ignored. The Element type check is
  ///          performed in the kernel launch.
  ///@deprecated Use the single argument version as Element is now
  ///             ignored.
  ///@return ScriptIntrinsicColorMatrix
  static ScriptIntrinsicColorMatrix create(
          renderscript_.RenderScript rs, element_.Element e) =>
      ScriptIntrinsicColorMatrix.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create,
          jni.JniType.objectType,
          [rs.reference, e.reference]).object);

  static final _id_create1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/renderscript/RenderScript;)Landroid/renderscript/ScriptIntrinsicColorMatrix;");

  /// from: static public android.renderscript.ScriptIntrinsicColorMatrix create(android.renderscript.RenderScript rs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intrinsic for applying a color matrix to an
  /// allocation.
  ///@param rs The RenderScript context
  ///@return ScriptIntrinsicColorMatrix
  static ScriptIntrinsicColorMatrix create1(renderscript_.RenderScript rs) =>
      ScriptIntrinsicColorMatrix.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create1,
          jni.JniType.objectType,
          [rs.reference]).object);

  static final _id_setColorMatrix = jniAccessors.getMethodIDOf(
      _classRef, "setColorMatrix", "(Landroid/renderscript/Matrix4f;)V");

  /// from: public void setColorMatrix(android.renderscript.Matrix4f m)
  ///
  /// Set the color matrix which will be applied to each cell of
  /// the image.
  ///@param m The 4x4 matrix to set.
  void setColorMatrix(matrix4f_.Matrix4f m) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setColorMatrix,
      jni.JniType.voidType,
      [m.reference]).check();

  static final _id_setColorMatrix1 = jniAccessors.getMethodIDOf(
      _classRef, "setColorMatrix", "(Landroid/renderscript/Matrix3f;)V");

  /// from: public void setColorMatrix(android.renderscript.Matrix3f m)
  ///
  /// Set the color matrix which will be applied to each cell of the image.
  /// This will set the alpha channel to be a copy.
  ///@param m The 3x3 matrix to set.
  void setColorMatrix1(matrix3f_.Matrix3f m) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setColorMatrix1,
      jni.JniType.voidType,
      [m.reference]).check();

  static final _id_setAdd = jniAccessors.getMethodIDOf(
      _classRef, "setAdd", "(Landroid/renderscript/Float4;)V");

  /// from: public void setAdd(android.renderscript.Float4 f)
  ///
  /// Set the value to be added after the color matrix has been
  /// applied. The default value is {0, 0, 0, 0}
  ///@param f The float4 value to be added.
  void setAdd(float4_.Float4 f) => jniAccessors.callMethodWithArgs(
      reference, _id_setAdd, jni.JniType.voidType, [f.reference]).check();

  static final _id_setAdd1 =
      jniAccessors.getMethodIDOf(_classRef, "setAdd", "(FFFF)V");

  /// from: public void setAdd(float r, float g, float b, float a)
  ///
  /// Set the value to be added after the color matrix has been
  /// applied. The default value is {0, 0, 0, 0}
  ///@param r The red add value.
  ///@param g The green add value.
  ///@param b The blue add value.
  ///@param a The alpha add value.
  void setAdd1(double r, double g, double b, double a) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setAdd1, jni.JniType.voidType, [r, g, b, a]).check();

  static final _id_setGreyscale =
      jniAccessors.getMethodIDOf(_classRef, "setGreyscale", "()V");

  /// from: public void setGreyscale()
  ///
  /// Set a color matrix to convert from RGB to luminance. The alpha channel
  /// will be a copy.
  void setGreyscale() => jniAccessors.callMethodWithArgs(
      reference, _id_setGreyscale, jni.JniType.voidType, []).check();

  static final _id_setYUVtoRGB =
      jniAccessors.getMethodIDOf(_classRef, "setYUVtoRGB", "()V");

  /// from: public void setYUVtoRGB()
  ///
  /// Set the matrix to convert from YUV to RGB with a direct copy of the 4th
  /// channel.
  void setYUVtoRGB() => jniAccessors.callMethodWithArgs(
      reference, _id_setYUVtoRGB, jni.JniType.voidType, []).check();

  static final _id_setRGBtoYUV =
      jniAccessors.getMethodIDOf(_classRef, "setRGBtoYUV", "()V");

  /// from: public void setRGBtoYUV()
  ///
  /// Set the matrix to convert from RGB to YUV with a direct copy of the 4th
  /// channel.
  void setRGBtoYUV() => jniAccessors.callMethodWithArgs(
      reference, _id_setRGBtoYUV, jni.JniType.voidType, []).check();

  static final _id_forEach4 = jniAccessors.getMethodIDOf(_classRef, "forEach",
      "(Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;)V");

  /// from: public void forEach(android.renderscript.Allocation ain, android.renderscript.Allocation aout)
  ///
  /// Invoke the kernel and apply the matrix to each cell of input
  /// Allocation and copy to the output Allocation.
  ///
  /// If the vector size of the input is less than four, the
  /// remaining components are treated as zero for the matrix
  /// multiply.
  ///
  /// If the output vector size is less than four, the unused
  /// vector components are discarded.
  ///@param ain Input allocation
  ///@param aout Output allocation
  void forEach4(allocation_.Allocation ain, allocation_.Allocation aout) =>
      jniAccessors.callMethodWithArgs(reference, _id_forEach4,
          jni.JniType.voidType, [ain.reference, aout.reference]).check();

  static final _id_forEach5 = jniAccessors.getMethodIDOf(_classRef, "forEach",
      "(Landroid/renderscript/Allocation;Landroid/renderscript/Allocation;Landroid/renderscript/Script\$LaunchOptions;)V");

  /// from: public void forEach(android.renderscript.Allocation ain, android.renderscript.Allocation aout, android.renderscript.Script.LaunchOptions opt)
  ///
  /// Invoke the kernel and apply the matrix to each cell of input
  /// Allocation and copy to the output Allocation.
  ///
  /// If the vector size of the input is less than four, the
  /// remaining components are treated as zero for the matrix
  /// multiply.
  ///
  /// If the output vector size is less than four, the unused
  /// vector components are discarded.
  ///@param ain Input allocation
  ///@param aout Output allocation
  ///@param opt LaunchOptions for clipping
  void forEach5(allocation_.Allocation ain, allocation_.Allocation aout,
          script_.Script_LaunchOptions opt) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_forEach5,
          jni.JniType.voidType,
          [ain.reference, aout.reference, opt.reference]).check();

  static final _id_getKernelID = jniAccessors.getMethodIDOf(
      _classRef, "getKernelID", "()Landroid/renderscript/Script\$KernelID;");

  /// from: public android.renderscript.Script.KernelID getKernelID()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a KernelID for this intrinsic kernel.
  ///@return Script.KernelID The KernelID object.
  script_.Script_KernelID getKernelID() =>
      script_.Script_KernelID.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKernelID, jni.JniType.objectType, []).object);
}
