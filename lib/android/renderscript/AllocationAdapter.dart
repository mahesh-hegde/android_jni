// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Allocation.dart" as allocation_;

import "Type.dart" as type_;

import "RenderScript.dart" as renderscript_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.renderscript.AllocationAdapter
///
/// Only intended for use by generated reflected code.
class AllocationAdapter extends allocation_.Allocation {
  static final _classRef =
      jniAccessors.getClassOf("android/renderscript/AllocationAdapter");
  AllocationAdapter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_setLOD =
      jniAccessors.getMethodIDOf(_classRef, "setLOD", "(I)V");

  /// from: public void setLOD(int lod)
  ///
  /// Set the active LOD.  The LOD must be within the range for the
  /// type being adapted.  The base allocation must have mipmaps.
  ///
  /// Because this changes the dimensions of the adapter the
  /// current Y and Z will be reset.
  ///@param lod The LOD to make active.
  void setLOD(int lod) => jniAccessors.callMethodWithArgs(
      reference, _id_setLOD, jni.JniType.voidType, [lod]).check();

  static final _id_setFace = jniAccessors.getMethodIDOf(
      _classRef, "setFace", "(Landroid/renderscript/Type\$CubemapFace;)V");

  /// from: public void setFace(android.renderscript.Type.CubemapFace cf)
  ///
  /// Set the active Face.  The base allocation must be of a type
  /// that includes faces.
  ///@param cf The face to make active.
  void setFace(type_.Type_CubemapFace cf) => jniAccessors.callMethodWithArgs(
      reference, _id_setFace, jni.JniType.voidType, [cf.reference]).check();

  static final _id_setX = jniAccessors.getMethodIDOf(_classRef, "setX", "(I)V");

  /// from: public void setX(int x)
  ///
  /// Set the active X.  The x value must be within the range for
  /// the allocation being adapted.
  ///@param x The x to make active.
  void setX(int x) => jniAccessors.callMethodWithArgs(
      reference, _id_setX, jni.JniType.voidType, [x]).check();

  static final _id_setY = jniAccessors.getMethodIDOf(_classRef, "setY", "(I)V");

  /// from: public void setY(int y)
  ///
  /// Set the active Y.  The y value must be within the range for
  /// the allocation being adapted.  The base allocation must
  /// contain the Y dimension.
  ///@param y The y to make active.
  void setY(int y) => jniAccessors.callMethodWithArgs(
      reference, _id_setY, jni.JniType.voidType, [y]).check();

  static final _id_setZ = jniAccessors.getMethodIDOf(_classRef, "setZ", "(I)V");

  /// from: public void setZ(int z)
  ///
  /// Set the active Z.  The z value must be within the range for
  /// the allocation being adapted.  The base allocation must
  /// contain the Z dimension.
  ///@param z The z to make active.
  void setZ(int z) => jniAccessors.callMethodWithArgs(
      reference, _id_setZ, jni.JniType.voidType, [z]).check();

  static final _id_create1D = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create1D",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Allocation;)Landroid/renderscript/AllocationAdapter;");

  /// from: static public android.renderscript.AllocationAdapter create1D(android.renderscript.RenderScript rs, android.renderscript.Allocation a)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static AllocationAdapter create1D(
          renderscript_.RenderScript rs, allocation_.Allocation a) =>
      AllocationAdapter.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create1D,
          jni.JniType.objectType,
          [rs.reference, a.reference]).object);

  static final _id_create2D = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create2D",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Allocation;)Landroid/renderscript/AllocationAdapter;");

  /// from: static public android.renderscript.AllocationAdapter create2D(android.renderscript.RenderScript rs, android.renderscript.Allocation a)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static AllocationAdapter create2D(
          renderscript_.RenderScript rs, allocation_.Allocation a) =>
      AllocationAdapter.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create2D,
          jni.JniType.objectType,
          [rs.reference, a.reference]).object);

  static final _id_createTyped3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createTyped",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Allocation;Landroid/renderscript/Type;)Landroid/renderscript/AllocationAdapter;");

  /// from: static public android.renderscript.AllocationAdapter createTyped(android.renderscript.RenderScript rs, android.renderscript.Allocation a, android.renderscript.Type t)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an arbitrary window into the base allocation.
  /// The type describes the shape of the window.
  ///
  /// Any dimensions present in the type must be equal or smaller
  /// to the dimensions in the source allocation.  A dimension
  /// present in the allocation that is not present in the type
  /// will be constrained away with the selectors.
  ///
  /// If a dimension is present in both the type and allocation, one of
  /// two things will happen.
  ///
  /// If the type is smaller than the allocation, a window will be
  /// created, the selected value in the adapter for that dimension
  /// will act as the base address, and the type will describe the
  /// size of the view starting at that point.
  ///
  /// If the type and allocation dimension are of the same size,
  /// then setting the selector for the dimension will be an error.
  static AllocationAdapter createTyped3(renderscript_.RenderScript rs,
          allocation_.Allocation a, type_.Type t) =>
      AllocationAdapter.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createTyped3,
          jni.JniType.objectType,
          [rs.reference, a.reference, t.reference]).object);

  static final _id_resize =
      jniAccessors.getMethodIDOf(_classRef, "resize", "(I)V");

  /// from: synchronized public void resize(int dimX)
  ///
  /// Override the Allocation resize.  Resizing adapters is not
  /// allowed and will throw a RSInvalidStateException.
  ///@param dimX ignored.
  void resize(int dimX) => jniAccessors.callMethodWithArgs(
      reference, _id_resize, jni.JniType.voidType, [dimX]).check();
}
