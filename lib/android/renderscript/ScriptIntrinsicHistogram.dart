// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ScriptIntrinsic.dart" as scriptintrinsic_;

import "RenderScript.dart" as renderscript_;

import "Element.dart" as element_;

import "Allocation.dart" as allocation_;

import "Script.dart" as script_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.renderscript.ScriptIntrinsicHistogram
///
/// Intrinsic Histogram filter.
class ScriptIntrinsicHistogram extends scriptintrinsic_.ScriptIntrinsic {
  static final _classRef =
      jniAccessors.getClassOf("android/renderscript/ScriptIntrinsicHistogram");
  ScriptIntrinsicHistogram.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/renderscript/RenderScript;Landroid/renderscript/Element;)Landroid/renderscript/ScriptIntrinsicHistogram;");

  /// from: static public android.renderscript.ScriptIntrinsicHistogram create(android.renderscript.RenderScript rs, android.renderscript.Element e)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intrinsic for calculating the histogram of an uchar
  /// or uchar4 image.
  ///
  /// Supported elements types are
  /// Element\#U8_4, Element\#U8_3,
  /// Element\#U8_2, Element\#U8
  ///@param rs The RenderScript context
  ///@param e Element type for inputs
  ///@return ScriptIntrinsicHistogram
  static ScriptIntrinsicHistogram create(
          renderscript_.RenderScript rs, element_.Element e) =>
      ScriptIntrinsicHistogram.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create,
          jni.JniType.objectType,
          [rs.reference, e.reference]).object);

  static final _id_forEach4 = jniAccessors.getMethodIDOf(
      _classRef, "forEach", "(Landroid/renderscript/Allocation;)V");

  /// from: public void forEach(android.renderscript.Allocation ain)
  ///
  /// Process an input buffer and place the histogram into the
  /// output allocation. The output allocation may be a narrower
  /// vector size than the input. In this case the vector size of
  /// the output is used to determine how many of the input
  /// channels are used in the computation. This is useful if you
  /// have an RGBA input buffer but only want the histogram for
  /// RGB.
  ///
  /// 1D and 2D input allocations are supported.
  ///@param ain The input image
  void forEach4(allocation_.Allocation ain) => jniAccessors.callMethodWithArgs(
      reference, _id_forEach4, jni.JniType.voidType, [ain.reference]).check();

  static final _id_forEach5 = jniAccessors.getMethodIDOf(_classRef, "forEach",
      "(Landroid/renderscript/Allocation;Landroid/renderscript/Script\$LaunchOptions;)V");

  /// from: public void forEach(android.renderscript.Allocation ain, android.renderscript.Script.LaunchOptions opt)
  ///
  /// Process an input buffer and place the histogram into the
  /// output allocation. The output allocation may be a narrower
  /// vector size than the input. In this case the vector size of
  /// the output is used to determine how many of the input
  /// channels are used in the computation. This is useful if you
  /// have an RGBA input buffer but only want the histogram for
  /// RGB.
  ///
  /// 1D and 2D input allocations are supported.
  ///@param ain The input image
  ///@param opt LaunchOptions for clipping
  void forEach5(allocation_.Allocation ain, script_.Script_LaunchOptions opt) =>
      jniAccessors.callMethodWithArgs(reference, _id_forEach5,
          jni.JniType.voidType, [ain.reference, opt.reference]).check();

  static final _id_setDotCoefficients =
      jniAccessors.getMethodIDOf(_classRef, "setDotCoefficients", "(FFFF)V");

  /// from: public void setDotCoefficients(float r, float g, float b, float a)
  ///
  /// Set the coefficients used for the RGBA to Luminocity
  /// calculation. The default is {0.299f, 0.587f, 0.114f, 0.f}.
  ///
  /// Coefficients must be >= 0 and sum to 1.0 or less.
  ///@param r Red coefficient
  ///@param g Green coefficient
  ///@param b Blue coefficient
  ///@param a Alpha coefficient
  void setDotCoefficients(double r, double g, double b, double a) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDotCoefficients,
          jni.JniType.voidType, [r, g, b, a]).check();

  static final _id_setOutput = jniAccessors.getMethodIDOf(
      _classRef, "setOutput", "(Landroid/renderscript/Allocation;)V");

  /// from: public void setOutput(android.renderscript.Allocation aout)
  ///
  /// Set the output of the histogram.  32 bit integer types are
  /// supported.
  ///@param aout The output allocation
  void setOutput(allocation_.Allocation aout) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOutput,
          jni.JniType.voidType, [aout.reference]).check();

  static final _id_forEach_Dot = jniAccessors.getMethodIDOf(
      _classRef, "forEach_Dot", "(Landroid/renderscript/Allocation;)V");

  /// from: public void forEach_Dot(android.renderscript.Allocation ain)
  ///
  /// Process an input buffer and place the histogram into the
  /// output allocation. The dot product of the input channel and
  /// the coefficients from 'setDotCoefficients' are used to
  /// calculate the output values.
  ///
  /// 1D and 2D input allocations are supported.
  ///@param ain The input image
  void forEach_Dot(allocation_.Allocation ain) =>
      jniAccessors.callMethodWithArgs(reference, _id_forEach_Dot,
          jni.JniType.voidType, [ain.reference]).check();

  static final _id_forEach_Dot1 = jniAccessors.getMethodIDOf(
      _classRef,
      "forEach_Dot",
      "(Landroid/renderscript/Allocation;Landroid/renderscript/Script\$LaunchOptions;)V");

  /// from: public void forEach_Dot(android.renderscript.Allocation ain, android.renderscript.Script.LaunchOptions opt)
  ///
  /// Process an input buffer and place the histogram into the
  /// output allocation. The dot product of the input channel and
  /// the coefficients from 'setDotCoefficients' are used to
  /// calculate the output values.
  ///
  /// 1D and 2D input allocations are supported.
  ///@param ain The input image
  ///@param opt LaunchOptions for clipping
  void forEach_Dot1(
          allocation_.Allocation ain, script_.Script_LaunchOptions opt) =>
      jniAccessors.callMethodWithArgs(reference, _id_forEach_Dot1,
          jni.JniType.voidType, [ain.reference, opt.reference]).check();

  static final _id_getKernelID_Separate = jniAccessors.getMethodIDOf(_classRef,
      "getKernelID_Separate", "()Landroid/renderscript/Script\$KernelID;");

  /// from: public android.renderscript.Script.KernelID getKernelID_Separate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a KernelID for this intrinsic kernel.
  ///@return Script.KernelID The KernelID object.
  script_.Script_KernelID getKernelID_Separate() =>
      script_.Script_KernelID.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getKernelID_Separate, jni.JniType.objectType, []).object);

  static final _id_getFieldID_Input = jniAccessors.getMethodIDOf(_classRef,
      "getFieldID_Input", "()Landroid/renderscript/Script\$FieldID;");

  /// from: public android.renderscript.Script.FieldID getFieldID_Input()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a FieldID for the input field of this intrinsic.
  ///@return Script.FieldID The FieldID object.
  script_.Script_FieldID getFieldID_Input() =>
      script_.Script_FieldID.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFieldID_Input, jni.JniType.objectType, []).object);
}
