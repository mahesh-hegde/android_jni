// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../print/PrinterId.dart" as printerid_;

import "../os/CancellationSignal.dart" as cancellationsignal_;

import "CustomPrinterIconCallback.dart" as customprintericoncallback_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.printservice.PrinterDiscoverySession
///
/// This class encapsulates the interaction between a print service and the
/// system during printer discovery. During printer discovery you are responsible
/// for adding discovered printers, removing previously added printers that
/// disappeared, and updating already added printers.
///
/// During the lifetime of this session you may be asked to start and stop
/// performing printer discovery multiple times. You will receive a call to PrinterDiscoverySession\#onStartPrinterDiscovery(List) to start printer
/// discovery and a call to PrinterDiscoverySession\#onStopPrinterDiscovery()
/// to stop printer discovery. When the system is no longer interested in printers
/// discovered by this session you will receive a call to \#onDestroy() at
/// which point the system will no longer call into the session and all the session
/// methods will do nothing.
///
///
///
/// Discovered printers are added by invoking PrinterDiscoverySession\#addPrinters(List). Added printers that disappeared are
/// removed by invoking PrinterDiscoverySession\#removePrinters(List). Added
/// printers whose properties or capabilities changed are updated through a call to
/// PrinterDiscoverySession\#addPrinters(List). The printers added in this
/// session can be acquired via \#getPrinters() where the returned printers
/// will be an up-to-date snapshot of the printers that you reported during the
/// session. Printers are <strong>not</strong> persisted across sessions.
///
///
///
/// The system will make a call to \#onValidatePrinters(List) if you
/// need to update some printers. It is possible that you add a printer without
/// specifying its capabilities. This enables you to avoid querying all discovered
/// printers for their capabilities, rather querying the capabilities of a printer
/// only if necessary. For example, the system will request that you update a printer
/// if it gets selected by the user. When validating printers you do not need to
/// provide the printers' capabilities but may do so.
///
///
///
/// If the system is interested in being constantly updated for the state of a
/// printer you will receive a call to \#onStartPrinterStateTracking(PrinterId)
/// after which you will have to do a best effort to keep the system updated for
/// changes in the printer state and capabilities. You also <strong>must</strong>
/// update the printer capabilities if you did not provide them when adding it, or
/// the printer will be ignored. When the system is no longer interested in getting
/// updates for a printer you will receive a call to \#onStopPrinterStateTracking(
/// PrinterId).
///
///
///
/// <strong>Note: </strong> All callbacks in this class are executed on the main
/// application thread. You also have to invoke any method of this class on the main
/// application thread.
///
///
class PrinterDiscoverySession extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/printservice/PrinterDiscoverySession");
  PrinterDiscoverySession.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor.
  PrinterDiscoverySession()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getPrinters = jniAccessors.getMethodIDOf(
      _classRef, "getPrinters", "()Ljava/util/List;");

  /// from: public final java.util.List<android.print.PrinterInfo> getPrinters()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the printers reported in this session. For example, if you add two
  /// printers and remove one of them, the returned list will contain only
  /// the printer that was added but not removed.
  ///
  /// <strong>Note: </strong> Calls to this method after the session is
  /// destroyed, that is after the \#onDestroy() callback, will be ignored.
  ///
  ///
  ///@return The printers.
  ///
  /// This value will never be {@code null}.
  ///@see \#addPrinters(List)
  ///@see \#removePrinters(List)
  ///@see \#isDestroyed()
  jni.JniObject getPrinters() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPrinters, jni.JniType.objectType, []).object);

  static final _id_addPrinters = jniAccessors.getMethodIDOf(
      _classRef, "addPrinters", "(Ljava/util/List;)V");

  /// from: public final void addPrinters(java.util.List<android.print.PrinterInfo> printers)
  ///
  /// Adds discovered printers. Adding an already added printer updates it.
  /// Removed printers can be added again. You can call this method multiple
  /// times during the life of this session. Duplicates will be ignored.
  ///
  /// <strong>Note: </strong> Calls to this method after the session is
  /// destroyed, that is after the \#onDestroy() callback, will be ignored.
  ///
  ///
  ///@param printers The printers to add.
  ///
  /// This value must never be {@code null}.
  ///@see \#removePrinters(List)
  ///@see \#getPrinters()
  ///@see \#isDestroyed()
  void addPrinters(jni.JniObject printers) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addPrinters,
      jni.JniType.voidType,
      [printers.reference]).check();

  static final _id_removePrinters = jniAccessors.getMethodIDOf(
      _classRef, "removePrinters", "(Ljava/util/List;)V");

  /// from: public final void removePrinters(java.util.List<android.print.PrinterId> printerIds)
  ///
  /// Removes added printers. Removing an already removed or never added
  /// printer has no effect. Removed printers can be added again. You can
  /// call this method multiple times during the lifetime of this session.
  ///
  /// <strong>Note: </strong> Calls to this method after the session is
  /// destroyed, that is after the \#onDestroy() callback, will be ignored.
  ///
  ///
  ///@param printerIds The ids of the removed printers.
  ///
  /// This value must never be {@code null}.
  ///@see \#addPrinters(List)
  ///@see \#getPrinters()
  ///@see \#isDestroyed()
  void removePrinters(jni.JniObject printerIds) =>
      jniAccessors.callMethodWithArgs(reference, _id_removePrinters,
          jni.JniType.voidType, [printerIds.reference]).check();

  static final _id_onStartPrinterDiscovery = jniAccessors.getMethodIDOf(
      _classRef, "onStartPrinterDiscovery", "(Ljava/util/List;)V");

  /// from: public abstract void onStartPrinterDiscovery(java.util.List<android.print.PrinterId> priorityList)
  ///
  /// Callback asking you to start printer discovery. Discovered printers should be
  /// added via calling \#addPrinters(List). Added printers that disappeared
  /// should be removed via calling \#removePrinters(List). Added printers
  /// whose properties or capabilities changed should be updated via calling \#addPrinters(List). You will receive a call to \#onStopPrinterDiscovery()
  /// when you should stop printer discovery.
  ///
  /// During the lifetime of this session all printers that are known to your print
  /// service have to be added. The system does not retain any printers across sessions.
  /// However, if you were asked to start and then stop performing printer discovery
  /// in this session, then a subsequent discovering should not re-discover already
  /// discovered printers. You can get the printers reported during this session by
  /// calling \#getPrinters().
  ///
  ///
  ///
  /// <strong>Note: </strong>You are also given a list of printers whose availability
  /// has to be checked first. For example, these printers could be the user's favorite
  /// ones, therefore they have to be verified first. You do <strong>not need</strong>
  /// to provide the capabilities of the printers, rather verify whether they exist
  /// similarly to \#onValidatePrinters(List).
  ///
  ///
  ///@param priorityList The list of printers to validate first. Never null.
  ///
  /// This value must never be {@code null}.
  ///@see \#onStopPrinterDiscovery()
  ///@see \#addPrinters(List)
  ///@see \#removePrinters(List)
  ///@see \#isPrinterDiscoveryStarted()
  void onStartPrinterDiscovery(jni.JniObject priorityList) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartPrinterDiscovery,
          jni.JniType.voidType, [priorityList.reference]).check();

  static final _id_onStopPrinterDiscovery =
      jniAccessors.getMethodIDOf(_classRef, "onStopPrinterDiscovery", "()V");

  /// from: public abstract void onStopPrinterDiscovery()
  ///
  /// Callback notifying you that you should stop printer discovery.
  ///@see \#onStartPrinterDiscovery(List)
  ///@see \#isPrinterDiscoveryStarted()
  void onStopPrinterDiscovery() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopPrinterDiscovery, jni.JniType.voidType, []).check();

  static final _id_onValidatePrinters = jniAccessors.getMethodIDOf(
      _classRef, "onValidatePrinters", "(Ljava/util/List;)V");

  /// from: public abstract void onValidatePrinters(java.util.List<android.print.PrinterId> printerIds)
  ///
  /// Callback asking you to validate that the given printers are valid, that
  /// is they exist. You are responsible for checking whether these printers
  /// exist and for the ones that do exist notify the system via calling
  /// \#addPrinters(List).
  ///
  /// <strong>Note: </strong> You are <strong>not required</strong> to provide
  /// the printer capabilities when updating the printers that do exist.
  ///
  ///@param printerIds The printers to validate.
  ///
  /// This value must never be {@code null}.
  ///@see android.print.PrinterInfo.Builder\#setCapabilities(PrinterCapabilitiesInfo) PrinterInfo.Builder.setCapabilities(PrinterCapabilitiesInfo)
  void onValidatePrinters(jni.JniObject printerIds) =>
      jniAccessors.callMethodWithArgs(reference, _id_onValidatePrinters,
          jni.JniType.voidType, [printerIds.reference]).check();

  static final _id_onStartPrinterStateTracking = jniAccessors.getMethodIDOf(
      _classRef, "onStartPrinterStateTracking", "(Landroid/print/PrinterId;)V");

  /// from: public abstract void onStartPrinterStateTracking(android.print.PrinterId printerId)
  ///
  /// Callback asking you to start tracking the state of a printer. Tracking
  /// the state means that you should do a best effort to observe the state
  /// of this printer and notify the system if that state changes via calling
  /// \#addPrinters(List).
  ///
  /// <strong>Note: </strong> A printer can be initially added without its
  /// capabilities to avoid polling printers that the user will not select.
  /// However, after this method is called you are expected to update the
  /// printer <strong>including</strong> its capabilities. Otherwise, the
  /// printer will be ignored.
  ///
  ///
  /// A scenario when you may be requested to track a printer's state is if
  /// the user selects that printer and the system has to present print
  /// options UI based on the printer's capabilities. In this case the user
  /// should be promptly informed if, for example, the printer becomes
  /// unavailable.
  ///
  ///
  ///@param printerId The printer to start tracking.
  ///
  /// This value must never be {@code null}.
  ///@see \#onStopPrinterStateTracking(PrinterId)
  ///@see android.print.PrinterInfo.Builder\#setCapabilities(PrinterCapabilitiesInfo) PrinterInfo.Builder.setCapabilities(PrinterCapabilitiesInfo)
  void onStartPrinterStateTracking(printerid_.PrinterId printerId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onStartPrinterStateTracking,
          jni.JniType.voidType,
          [printerId.reference]).check();

  static final _id_onRequestCustomPrinterIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestCustomPrinterIcon",
      "(Landroid/print/PrinterId;Landroid/os/CancellationSignal;Landroid/printservice/CustomPrinterIconCallback;)V");

  /// from: public void onRequestCustomPrinterIcon(android.print.PrinterId printerId, android.os.CancellationSignal cancellationSignal, android.printservice.CustomPrinterIconCallback callback)
  ///
  /// Called by the system to request the custom icon for a printer. Once the icon is available the
  /// print services uses CustomPrinterIconCallback\#onCustomPrinterIconLoaded to send the
  /// icon to the system.
  ///@param printerId The printer to icon belongs to.
  /// This value must never be {@code null}.
  ///@param cancellationSignal Signal used to cancel the request.
  /// This value must never be {@code null}.
  ///@param callback Callback for returning the icon to the system.
  ///
  /// This value must never be {@code null}.
  ///@see android.print.PrinterInfo.Builder\#setHasCustomPrinterIcon(boolean)
  void onRequestCustomPrinterIcon(
          printerid_.PrinterId printerId,
          cancellationsignal_.CancellationSignal cancellationSignal,
          customprintericoncallback_.CustomPrinterIconCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onRequestCustomPrinterIcon, jni.JniType.voidType, [
        printerId.reference,
        cancellationSignal.reference,
        callback.reference
      ]).check();

  static final _id_onStopPrinterStateTracking = jniAccessors.getMethodIDOf(
      _classRef, "onStopPrinterStateTracking", "(Landroid/print/PrinterId;)V");

  /// from: public abstract void onStopPrinterStateTracking(android.print.PrinterId printerId)
  ///
  /// Callback asking you to stop tracking the state of a printer. The passed
  /// in printer id is the one for which you received a call to \#onStartPrinterStateTracking(PrinterId).
  ///@param printerId The printer to stop tracking.
  ///
  /// This value must never be {@code null}.
  ///@see \#onStartPrinterStateTracking(PrinterId)
  void onStopPrinterStateTracking(printerid_.PrinterId printerId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStopPrinterStateTracking,
          jni.JniType.voidType, [printerId.reference]).check();

  static final _id_getTrackedPrinters = jniAccessors.getMethodIDOf(
      _classRef, "getTrackedPrinters", "()Ljava/util/List;");

  /// from: public final java.util.List<android.print.PrinterId> getTrackedPrinters()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the printers that should be tracked. These are printers that are
  /// important to the user and for which you received a call to \#onStartPrinterStateTracking(PrinterId) asking you to observer their
  /// state and reporting it to the system via \#addPrinters(List).
  /// You will receive a call to \#onStopPrinterStateTracking(PrinterId)
  /// if you should stop tracking a printer.
  ///
  /// <strong>Note: </strong> Calls to this method after the session is
  /// destroyed, that is after the \#onDestroy() callback, will be ignored.
  ///
  ///
  ///@return The printers.
  ///
  /// This value will never be {@code null}.
  ///@see \#onStartPrinterStateTracking(PrinterId)
  ///@see \#onStopPrinterStateTracking(PrinterId)
  ///@see \#isDestroyed()
  jni.JniObject getTrackedPrinters() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTrackedPrinters, jni.JniType.objectType, []).object);

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public abstract void onDestroy()
  ///
  /// Notifies you that the session is destroyed. After this callback is invoked
  /// any calls to the methods of this class will be ignored, \#isDestroyed()
  /// will return true and you will also no longer receive callbacks.
  ///@see \#isDestroyed()
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_isDestroyed =
      jniAccessors.getMethodIDOf(_classRef, "isDestroyed", "()Z");

  /// from: public final boolean isDestroyed()
  ///
  /// Gets whether the session is destroyed.
  ///@return Whether the session is destroyed.
  ///@see \#onDestroy()
  bool isDestroyed() => jniAccessors.callMethodWithArgs(
      reference, _id_isDestroyed, jni.JniType.booleanType, []).boolean;

  static final _id_isPrinterDiscoveryStarted =
      jniAccessors.getMethodIDOf(_classRef, "isPrinterDiscoveryStarted", "()Z");

  /// from: public final boolean isPrinterDiscoveryStarted()
  ///
  /// Gets whether printer discovery is started.
  ///@return Whether printer discovery is destroyed.
  ///@see \#onStartPrinterDiscovery(List)
  ///@see \#onStopPrinterDiscovery()
  bool isPrinterDiscoveryStarted() => jniAccessors.callMethodWithArgs(reference,
      _id_isPrinterDiscoveryStarted, jni.JniType.booleanType, []).boolean;
}
