// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../app/Service.dart" as service_;

import "../content/Context.dart" as context_;

import "PrinterDiscoverySession.dart" as printerdiscoverysession_;

import "PrintJob.dart" as printjob_;

import "../print/PrinterId.dart" as printerid_;

import "../os/IBinder.dart" as ibinder_;

import "../content/Intent.dart" as intent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.printservice.PrintService
///
///
/// This is the base class for implementing print services. A print service knows
/// how to discover and interact one or more printers via one or more protocols.
///
///
/// <h3>Printer discovery</h3>
///
/// A print service is responsible for discovering printers, adding discovered printers,
/// removing added printers, and updating added printers. When the system is interested
/// in printers managed by your service it will call \#onCreatePrinterDiscoverySession() from which you must return a new PrinterDiscoverySession instance. The returned session encapsulates the interaction
/// between the system and your service during printer discovery. For description of this
/// interaction refer to the documentation for PrinterDiscoverySession.
///
///
///
/// For every printer discovery session all printers have to be added since system does
/// not retain printers across sessions. Hence, each printer known to this print service
/// should be added only once during a discovery session. Only an already added printer
/// can be removed or updated. Removed printers can be added again.
///
///
/// <h3>Print jobs</h3>
///
/// When a new print job targeted to a printer managed by this print service is is queued,
/// i.e. ready for processing by the print service, you will receive a call to \#onPrintJobQueued(PrintJob). The print service may handle the print job immediately
/// or schedule that for an appropriate time in the future. The list of all active print
/// jobs for this service is obtained by calling \#getActivePrintJobs(). Active
/// print jobs are ones that are queued or started.
///
///
///
/// A print service is responsible for setting a print job's state as appropriate
/// while processing it. Initially, a print job is queued, i.e. PrintJob\#isQueued() PrintJob.isQueued() returns true, which means that the document to be printed is
/// spooled by the system and the print service can begin processing it. You can obtain
/// the printed document by calling PrintJob\#getDocument() PrintJob.getDocument()
/// whose data is accessed via PrintDocument\#getData() PrintDocument.getData().
/// After the print service starts printing the data it should set the print job's
/// state to started by calling PrintJob\#start() after which
/// PrintJob\#isStarted() PrintJob.isStarted() would return true. Upon successful
/// completion, the print job should be marked as completed by calling PrintJob\#complete() PrintJob.complete() after which PrintJob\#isCompleted() PrintJob.isCompleted() would return true. In case of a failure, the print job should
/// be marked as failed by calling PrintJob\#fail(String) PrintJob.fail(
/// String) after which PrintJob\#isFailed() PrintJob.isFailed() would
/// return true.
///
///
///
/// If a print job is queued or started and the user requests to cancel it, the print
/// service will receive a call to \#onRequestCancelPrintJob(PrintJob) which
/// requests from the service to do best effort in canceling the job. In case the job
/// is successfully canceled, its state has to be marked as cancelled by calling PrintJob\#cancel() PrintJob.cancel() after which PrintJob\#isCancelled() PrintJob.isCacnelled() would return true.
///
///
/// <h3>Lifecycle</h3>
///
/// The lifecycle of a print service is managed exclusively by the system and follows
/// the established service lifecycle. Additionally, starting or stopping a print service
/// is triggered exclusively by an explicit user action through enabling or disabling it
/// in the device settings. After the system binds to a print service, it calls \#onConnected(). This method can be overriden by clients to perform post binding setup.
/// Also after the system unbinds from a print service, it calls \#onDisconnected().
/// This method can be overriden by clients to perform post unbinding cleanup. Your should
/// not do any work after the system disconnected from your print service since the
/// service can be killed at any time to reclaim memory. The system will not disconnect
/// from a print service if there are active print jobs for the printers managed by it.
///
///
/// <h3>Declaration</h3>
///
/// A print service is declared as any other service in an AndroidManifest.xml but it must
/// also specify that it handles the android.content.Intent with action \#SERVICE_INTERFACE android.printservice.PrintService. Failure to declare this intent
/// will cause the system to ignore the print service. Additionally, a print service must
/// request the android.Manifest.permission\#BIND_PRINT_SERVICE android.permission.BIND_PRINT_SERVICE permission to ensure that only the system can
/// bind to it. Failure to declare this intent will cause the system to ignore the print
/// service. Following is an example declaration:
///
///
/// <pre>
/// &lt;service android:name=".MyPrintService"
///         android:permission="android.permission.BIND_PRINT_SERVICE"&gt;
///     &lt;intent-filter&gt;
///         &lt;action android:name="android.printservice.PrintService" /&gt;
///     &lt;/intent-filter&gt;
///     . . .
/// &lt;/service&gt;
/// </pre>
/// <h3>Configuration</h3>
///
/// A print service can be configured by specifying an optional settings activity which
/// exposes service specific settings, an optional add printers activity which is used for
/// manual addition of printers, vendor name ,etc. It is a responsibility of the system
/// to launch the settings and add printers activities when appropriate.
///
///
///
/// A print service is configured by providing a \#SERVICE_META_DATA meta-data
/// entry in the manifest when declaring the service. A service declaration with a meta-data
/// tag is presented below:
/// <pre> &lt;service android:name=".MyPrintService"
///         android:permission="android.permission.BIND_PRINT_SERVICE"&gt;
///     &lt;intent-filter&gt;
///         &lt;action android:name="android.printservice.PrintService" /&gt;
///     &lt;/intent-filter&gt;
///     &lt;meta-data android:name="android.printservice" android:resource="@xml/printservice" /&gt;
/// &lt;/service&gt;</pre>
///
///
///
/// For more details for how to configure your print service via the meta-data refer to
/// \#SERVICE_META_DATA and <code>&lt;android.R.styleable\#PrintService print-service&gt;</code>.
///
///
///
/// <strong>Note: </strong> All callbacks in this class are executed on the main
/// application thread. You should also invoke any method of this class on the main
/// application thread.
///
///
class PrintService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/printservice/PrintService");
  PrintService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String EXTRA_CAN_SELECT_PRINTER
  ///
  /// When the PendingIntent declared via
  /// PrinterInfo.Builder\#setInfoIntent(PendingIntent) is called this boolean extra
  /// will be filled in if the activity can select the printer.
  ///@see \#EXTRA_SELECT_PRINTER
  static const EXTRA_CAN_SELECT_PRINTER =
      "android.printservice.extra.CAN_SELECT_PRINTER";

  /// from: static public final java.lang.String EXTRA_PRINTER_INFO
  ///
  /// If you declared an optional activity with advanced print options via the
  /// android.R.attr\#advancedPrintOptionsActivity advancedPrintOptionsActivity
  /// attribute, this extra is used to pass in the currently selected printer's
  /// android.print.PrinterInfo to your activity allowing you to inspect it.
  ///@see \#EXTRA_PRINT_JOB_INFO
  static const EXTRA_PRINTER_INFO =
      "android.intent.extra.print.EXTRA_PRINTER_INFO";

  /// from: static public final java.lang.String EXTRA_PRINT_DOCUMENT_INFO
  ///
  /// If you declared an optional activity with advanced print options via the
  /// android.R.attr\#advancedPrintOptionsActivity advancedPrintOptionsActivity
  /// attribute, this extra is used to pass in the meta-data for the currently printed
  /// document as a android.print.PrintDocumentInfo to your activity allowing
  /// you to inspect it.
  ///@see \#EXTRA_PRINT_JOB_INFO
  ///@see \#EXTRA_PRINTER_INFO
  static const EXTRA_PRINT_DOCUMENT_INFO =
      "android.printservice.extra.PRINT_DOCUMENT_INFO";

  /// from: static public final java.lang.String EXTRA_PRINT_JOB_INFO
  ///
  /// If you declared an optional activity with advanced print options via the
  /// android.R.attr\#advancedPrintOptionsActivity advancedPrintOptionsActivity attribute,
  /// this extra is used to pass in the currently constructed PrintJobInfo to your activity
  /// allowing you to modify it. After you are done, you must return the modified
  /// PrintJobInfo via the same extra.
  ///
  /// You cannot modify the passed in PrintJobInfo directly, rather you should build
  /// another one using the android.print.PrintJobInfo.Builder PrintJobInfo.Builder class.
  /// You can specify any standard properties and add advanced, printer specific, ones via
  /// android.print.PrintJobInfo.Builder\#putAdvancedOption(String, String) PrintJobInfo.Builder.putAdvancedOption(String, String) and
  /// android.print.PrintJobInfo.Builder\#putAdvancedOption(String, int) PrintJobInfo.Builder.putAdvancedOption(String, int). The advanced options are not
  /// interpreted by the system, they will not be visible to applications, and can only be accessed
  /// by your print service via PrintJob\#getAdvancedStringOption(String) PrintJob.getAdvancedStringOption(String) and PrintJob\#getAdvancedIntOption(String) PrintJob.getAdvancedIntOption(String).
  ///
  ///
  ///
  /// If the advanced print options activity offers changes to the standard print options, you can
  /// get the current android.print.PrinterInfo PrinterInfo using the
  /// \#EXTRA_PRINTER_INFO extra which will allow you to present the user with UI options
  /// supported by the current printer. For example, if the current printer does not support a
  /// given media size, you should not offer it in the advanced print options UI.
  ///
  ///
  ///@see \#EXTRA_PRINTER_INFO
  static const EXTRA_PRINT_JOB_INFO =
      "android.intent.extra.print.PRINT_JOB_INFO";

  /// from: static public final java.lang.String EXTRA_SELECT_PRINTER
  ///
  /// If this boolean extra is set to {@code true} in the Activity\#setResult(int, Intent) result data from the activity specified in
  /// PrinterInfo.Builder\#setInfoIntent(PendingIntent) the printer will be selected.
  ///@see \#EXTRA_CAN_SELECT_PRINTER
  static const EXTRA_SELECT_PRINTER =
      "android.printservice.extra.SELECT_PRINTER";

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent action that must be declared as handled by a service
  /// in its manifest for the system to recognize it as a print service.
  static const SERVICE_INTERFACE = "android.printservice.PrintService";

  /// from: static public final java.lang.String SERVICE_META_DATA
  ///
  /// Name under which a PrintService component publishes additional information
  /// about itself. This meta-data must reference a XML resource containing a <code>
  /// &lt;android.R.styleable\#PrintService print-service&gt;</code> tag. This is
  /// a sample XML file configuring a print service:
  /// <pre> &lt;print-service
  ///     android:vendor="SomeVendor"
  ///     android:settingsActivity="foo.bar.MySettingsActivity"
  ///     andorid:addPrintersActivity="foo.bar.MyAddPrintersActivity."
  ///     . . .
  /// /&gt;</pre>
  ///
  /// For detailed configuration options that can be specified via the meta-data
  /// refer to android.R.styleable\#PrintService android.R.styleable.PrintService.
  ///
  ///
  ///
  /// If you declare a settings or add a printers activity, they have to be exported,
  /// by setting the android.R.attr\#exported activity attribute to <code>true
  /// </code>. Also in case you want only the system to be able to start any of these
  /// activities you can specify that they request the android.permission
  /// .START_PRINT_SERVICE_CONFIG_ACTIVITY permission by setting the
  /// android.R.attr\#permission activity attribute.
  ///
  ///
  static const SERVICE_META_DATA = "android.printservice";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PrintService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_attachBaseContext1 = jniAccessors.getMethodIDOf(
      _classRef, "attachBaseContext", "(Landroid/content/Context;)V");

  /// from: protected final void attachBaseContext(android.content.Context base)
  void attachBaseContext1(context_.Context base) =>
      jniAccessors.callMethodWithArgs(reference, _id_attachBaseContext1,
          jni.JniType.voidType, [base.reference]).check();

  static final _id_onConnected =
      jniAccessors.getMethodIDOf(_classRef, "onConnected", "()V");

  /// from: protected void onConnected()
  ///
  /// The system has connected to this service.
  void onConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_onConnected, jni.JniType.voidType, []).check();

  static final _id_onDisconnected =
      jniAccessors.getMethodIDOf(_classRef, "onDisconnected", "()V");

  /// from: protected void onDisconnected()
  ///
  /// The system has disconnected from this service.
  void onDisconnected() => jniAccessors.callMethodWithArgs(
      reference, _id_onDisconnected, jni.JniType.voidType, []).check();

  static final _id_onCreatePrinterDiscoverySession = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreatePrinterDiscoverySession",
      "()Landroid/printservice/PrinterDiscoverySession;");

  /// from: protected abstract android.printservice.PrinterDiscoverySession onCreatePrinterDiscoverySession()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Callback asking you to create a new PrinterDiscoverySession.
  ///@return The created session.
  /// This value may be {@code null}.
  ///@see PrinterDiscoverySession
  printerdiscoverysession_.PrinterDiscoverySession
      onCreatePrinterDiscoverySession() =>
          printerdiscoverysession_.PrinterDiscoverySession.fromRef(jniAccessors
              .callMethodWithArgs(
                  reference,
                  _id_onCreatePrinterDiscoverySession,
                  jni.JniType.objectType, []).object);

  static final _id_onRequestCancelPrintJob = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestCancelPrintJob",
      "(Landroid/printservice/PrintJob;)V");

  /// from: protected abstract void onRequestCancelPrintJob(android.printservice.PrintJob printJob)
  ///
  /// Called when cancellation of a print job is requested. The service
  /// should do best effort to fulfill the request. After the cancellation
  /// is performed, the print job should be marked as cancelled state by
  /// calling PrintJob\#cancel().
  ///@param printJob The print job to cancel.
  ///@see PrintJob\#cancel() PrintJob.cancel()
  ///@see PrintJob\#isCancelled() PrintJob.isCancelled()
  void onRequestCancelPrintJob(printjob_.PrintJob printJob) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRequestCancelPrintJob,
          jni.JniType.voidType, [printJob.reference]).check();

  static final _id_onPrintJobQueued = jniAccessors.getMethodIDOf(
      _classRef, "onPrintJobQueued", "(Landroid/printservice/PrintJob;)V");

  /// from: protected abstract void onPrintJobQueued(android.printservice.PrintJob printJob)
  ///
  /// Called when there is a queued print job for one of the printers
  /// managed by this print service.
  ///@param printJob The new queued print job.
  ///@see PrintJob\#isQueued() PrintJob.isQueued()
  ///@see \#getActivePrintJobs()
  void onPrintJobQueued(printjob_.PrintJob printJob) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrintJobQueued,
          jni.JniType.voidType, [printJob.reference]).check();

  static final _id_getActivePrintJobs = jniAccessors.getMethodIDOf(
      _classRef, "getActivePrintJobs", "()Ljava/util/List;");

  /// from: public final java.util.List<android.printservice.PrintJob> getActivePrintJobs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the active print jobs for the printers managed by this service.
  /// Active print jobs are ones that are not in a final state, i.e. whose
  /// state is queued or started.
  ///@return The active print jobs.
  ///@see PrintJob\#isQueued() PrintJob.isQueued()
  ///@see PrintJob\#isStarted() PrintJob.isStarted()
  jni.JniObject getActivePrintJobs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getActivePrintJobs, jni.JniType.objectType, []).object);

  static final _id_generatePrinterId = jniAccessors.getMethodIDOf(_classRef,
      "generatePrinterId", "(Ljava/lang/String;)Landroid/print/PrinterId;");

  /// from: public final android.print.PrinterId generatePrinterId(java.lang.String localId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generates a global printer id given the printer's locally unique one.
  ///@param localId A locally unique id in the context of your print service.
  ///@return Global printer id.
  ///
  /// This value will never be {@code null}.
  printerid_.PrinterId generatePrinterId(jni.JniString localId) =>
      printerid_.PrinterId.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generatePrinterId,
          jni.JniType.objectType,
          [localId.reference]).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);
}
