// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.accounts.AccountManagerFuture
///
/// A <tt>AccountManagerFuture</tt> represents the result of an asynchronous
/// AccountManager call.  Methods are provided to check if the computation is
/// complete, to wait for its completion, and to retrieve the result of
/// the computation.  The result can only be retrieved using method
/// <tt>get</tt> when the computation has completed, blocking if
/// necessary until it is ready.  Cancellation is performed by the
/// <tt>cancel</tt> method.  Additional methods are provided to
/// determine if the task completed normally or was cancelled. Once a
/// computation has completed, the computation cannot be cancelled.
/// If you would like to use a <tt>Future</tt> for the sake
/// of cancellability but not provide a usable result, you can
/// declare types of the form <tt>Future&lt;?&gt;</tt> and
/// return <tt>null</tt> as a result of the underlying task.
class AccountManagerFuture extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/accounts/AccountManagerFuture");
  AccountManagerFuture.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "(Z)Z");

  /// from: public abstract boolean cancel(boolean mayInterruptIfRunning)
  ///
  /// Attempts to cancel execution of this task.  This attempt will
  /// fail if the task has already completed, has already been cancelled,
  /// or could not be cancelled for some other reason. If successful,
  /// and this task has not started when <tt>cancel</tt> is called,
  /// this task should never run.  If the task has already started,
  /// then the <tt>mayInterruptIfRunning</tt> parameter determines
  /// whether the thread executing this task should be interrupted in
  /// an attempt to stop the task.
  ///
  /// After this method returns, subsequent calls to \#isDone will
  /// always return <tt>true</tt>.  Subsequent calls to \#isCancelled
  /// will always return <tt>true</tt> if this method returned <tt>true</tt>.
  ///@param mayInterruptIfRunning <tt>true</tt> if the thread executing this
  /// task should be interrupted; otherwise, in-progress tasks are allowed
  /// to complete
  ///@return <tt>false</tt> if the task could not be cancelled,
  /// typically because it has already completed normally;
  /// <tt>true</tt> otherwise
  bool cancel(bool mayInterruptIfRunning) => jniAccessors.callMethodWithArgs(
      reference,
      _id_cancel,
      jni.JniType.booleanType,
      [mayInterruptIfRunning]).boolean;

  static final _id_isCancelled =
      jniAccessors.getMethodIDOf(_classRef, "isCancelled", "()Z");

  /// from: public abstract boolean isCancelled()
  ///
  /// Returns <tt>true</tt> if this task was cancelled before it completed
  /// normally.
  ///@return <tt>true</tt> if this task was cancelled before it completed
  bool isCancelled() => jniAccessors.callMethodWithArgs(
      reference, _id_isCancelled, jni.JniType.booleanType, []).boolean;

  static final _id_isDone =
      jniAccessors.getMethodIDOf(_classRef, "isDone", "()Z");

  /// from: public abstract boolean isDone()
  ///
  /// Returns <tt>true</tt> if this task completed.
  ///
  /// Completion may be due to normal termination, an exception, or
  /// cancellation -- in all of these cases, this method will return
  /// <tt>true</tt>.
  ///@return <tt>true</tt> if this task completed
  bool isDone() => jniAccessors.callMethodWithArgs(
      reference, _id_isDone, jni.JniType.booleanType, []).boolean;
}
