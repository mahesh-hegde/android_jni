// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.Range
///
/// Immutable class for describing the range of two numeric values.
///
/// A range (or "interval") defines the inclusive boundaries around a contiguous span of
/// values of some Comparable type; for example,
/// "integers from 1 to 100 inclusive."
///
///
///
/// All ranges are bounded, and the left side of the range is always {@code >=}
/// the right side of the range.
///
///
///
/// Although the implementation itself is immutable, there is no restriction that objects
/// stored must also be immutable. If mutable objects are stored here, then the range
/// effectively becomes mutable.
///
class Range extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/Range");
  Range.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_contains1 = jniAccessors.getMethodIDOf(
      _classRef, "contains", "(Landroid/util/Range;)Z");

  /// from: public boolean contains(android.util.Range<T> range)
  ///
  /// Checks if another {@code range} is within the bounds of this range.
  ///
  /// A range is considered to be within this range if both of its endpoints
  /// are within this range.
  ///
  ///@param range a non-{@code null} {@code T} reference
  ///@return {@code true} if the range is within this inclusive range, {@code false} otherwise
  ///@throws NullPointerException if {@code range} was {@code null}
  bool contains1(Range range) => jniAccessors.callMethodWithArgs(reference,
      _id_contains1, jni.JniType.booleanType, [range.reference]).boolean;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Compare two ranges for equality.
  ///
  /// A range is considered equal if and only if both the lower and upper endpoints
  /// are also equal.
  ///
  ///@return {@code true} if the ranges are equal, {@code false} otherwise
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_intersect = jniAccessors.getMethodIDOf(
      _classRef, "intersect", "(Landroid/util/Range;)Landroid/util/Range;");

  /// from: public android.util.Range<T> intersect(android.util.Range<T> range)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the intersection of this range and another {@code range}.
  ///
  /// E.g. if a {@code <} b {@code <} c {@code <} d, the
  /// intersection of [a, c] and [b, d] ranges is [b, c].
  /// As the endpoints are object references, there is no guarantee
  /// which specific endpoint reference is used from the input ranges:
  ///
  ///
  /// E.g. if a {@code ==} a' {@code <} b {@code <} c, the
  /// intersection of [a, b] and [a', c] ranges could be either
  /// [a, b] or ['a, b], where [a, b] could be either the exact
  /// input range, or a newly created range with the same endpoints.
  ///
  ///@param range a non-{@code null} {@code Range<T>} reference
  ///@return the intersection of this range and the other range.
  ///@throws NullPointerException if {@code range} was {@code null}
  ///@throws IllegalArgumentException if the ranges are disjoint.
  Range intersect(Range range) => Range.fromRef(jniAccessors.callMethodWithArgs(
      reference,
      _id_intersect,
      jni.JniType.objectType,
      [range.reference]).object);

  static final _id_extend = jniAccessors.getMethodIDOf(
      _classRef, "extend", "(Landroid/util/Range;)Landroid/util/Range;");

  /// from: public android.util.Range<T> extend(android.util.Range<T> range)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the smallest range that includes this range and
  /// another {@code range}.
  ///
  /// E.g. if a {@code <} b {@code <} c {@code <} d, the
  /// extension of [a, c] and [b, d] ranges is [a, d].
  /// As the endpoints are object references, there is no guarantee
  /// which specific endpoint reference is used from the input ranges:
  ///
  ///
  /// E.g. if a {@code ==} a' {@code <} b {@code <} c, the
  /// extension of [a, b] and [a', c] ranges could be either
  /// [a, c] or ['a, c], where ['a, c] could be either the exact
  /// input range, or a newly created range with the same endpoints.
  ///
  ///@param range a non-{@code null} {@code Range<T>} reference
  ///@return the extension of this range and the other range.
  ///@throws NullPointerException if {@code range} was {@code null}
  Range extend(Range range) => Range.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_extend, jni.JniType.objectType, [range.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the range as a string representation {@code "[lower, upper]"}.
  ///@return string representation of the range
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
