// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.Property
///
/// A property is an abstraction that can be used to represent a <emb>mutable_ value that is held
/// in a _host_ object. The Property's \#set(Object, Object) or \#get(Object)
/// methods can be implemented in terms of the private fields of the host object, or via "setter" and
/// "getter" methods or by some other mechanism, as appropriate.
///@param <T> The class on which the property is declared.
///@param <V> The type that this property represents.
class Property extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/Property");
  Property.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/Class;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.Class<V> type, java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A constructor that takes an identifying name and \#getType() type for the property.
  Property(jni.JniObject type, jni.JniString name)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [type.reference, name.reference]).object);

  static final _id_of = jniAccessors.getStaticMethodIDOf(_classRef, "of",
      "(Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;)Landroid/util/Property;");

  /// from: static public android.util.Property<T,V> of(java.lang.Class<T> hostType, java.lang.Class<V> valueType, java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This factory method creates and returns a Property given the <code>class</code> and
  /// <code>name</code> parameters, where the <code>"name"</code> parameter represents either:
  /// <ul>
  ///     <li>a public <code>getName()</code> method on the class which takes no arguments, plus an
  ///     optional public <code>setName()</code> method which takes a value of the same type
  ///     returned by <code>getName()</code>
  ///     <li>a public <code>isName()</code> method on the class which takes no arguments, plus an
  ///     optional public <code>setName()</code> method which takes a value of the same type
  ///     returned by <code>isName()</code>
  ///     <li>a public <code>name</code> field on the class
  /// </ul>
  ///
  /// If either of the get/is method alternatives is found on the class, but an appropriate
  /// <code>setName()</code> method is not found, the <code>Property</code> will be
  /// \#isReadOnly() readOnly. Calling the \#set(Object, Object) method on such
  /// a property is allowed, but will have no effect.
  ///
  ///
  /// If neither the methods nor the field are found on the class a
  /// NoSuchPropertyException exception will be thrown.
  ///
  static Property of(jni.JniObject hostType, jni.JniObject valueType,
          jni.JniString name) =>
      Property.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_of,
          jni.JniType.objectType,
          [hostType.reference, valueType.reference, name.reference]).object);

  static final _id_isReadOnly =
      jniAccessors.getMethodIDOf(_classRef, "isReadOnly", "()Z");

  /// from: public boolean isReadOnly()
  ///
  /// Returns true if the \#set(Object, Object) method does not set the value on the target
  /// object (in which case the \#set(Object, Object) set() method should throw a NoSuchPropertyException exception). This may happen if the Property wraps functionality that
  /// allows querying the underlying value but not setting it. For example, the \#of(Class,
  /// Class, String) factory method may return a Property with name "foo" for an object that has
  /// only a <code>getFoo()</code> or <code>isFoo()</code> method, but no matching
  /// <code>setFoo()</code> method.
  bool isReadOnly() => jniAccessors.callMethodWithArgs(
      reference, _id_isReadOnly, jni.JniType.booleanType, []).boolean;

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name for this property.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()Ljava/lang/Class;");

  /// from: public java.lang.Class<V> getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the type for this property.
  jni.JniObject getType() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getType, jni.JniType.objectType, []).object);
}
