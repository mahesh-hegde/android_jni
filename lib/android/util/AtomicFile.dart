// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.AtomicFile
///
/// Helper class for performing atomic operations on a file by creating a
/// backup file until a write has successfully completed.  If you need this
/// on older versions of the platform you can use
/// android.support.v4.util.AtomicFile in the v4 support library.
///
/// Atomic file guarantees file integrity by ensuring that a file has
/// been completely written and sync'd to disk before removing its backup.
/// As long as the backup file exists, the original file is considered
/// to be invalid (left over from a previous attempt to write the file).
///
///
/// Atomic file does not confer any file locking semantics.
/// Do not use this class when the file may be accessed or modified concurrently
/// by multiple threads or processes.  The caller is responsible for ensuring
/// appropriate mutual exclusion invariants whenever it accesses the file.
///
///
class AtomicFile extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/AtomicFile");
  AtomicFile.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/io/File;)V");

  /// from: public void <init>(java.io.File baseName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new AtomicFile for a file located at the given File path.
  /// The secondary backup file will be the same file path with ".bak" appended.
  AtomicFile(jni.JniObject baseName)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [baseName.reference]).object);

  static final _id_getBaseFile =
      jniAccessors.getMethodIDOf(_classRef, "getBaseFile", "()Ljava/io/File;");

  /// from: public java.io.File getBaseFile()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the path to the base file.  You should not generally use this,
  /// as the data at that path may not be valid.
  jni.JniObject getBaseFile() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBaseFile, jni.JniType.objectType, []).object);

  static final _id_delete1 =
      jniAccessors.getMethodIDOf(_classRef, "delete", "()V");

  /// from: public void delete()
  ///
  /// Delete the atomic file.  This deletes both the base and backup files.
  void delete1() => jniAccessors.callMethodWithArgs(
      reference, _id_delete1, jni.JniType.voidType, []).check();

  static final _id_startWrite = jniAccessors.getMethodIDOf(
      _classRef, "startWrite", "()Ljava/io/FileOutputStream;");

  /// from: public java.io.FileOutputStream startWrite()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a new write operation on the file.  This returns a FileOutputStream
  /// to which you can write the new file data.  The existing file is replaced
  /// with the new data.  You _must not_ directly close the given
  /// FileOutputStream; instead call either \#finishWrite(FileOutputStream)
  /// or \#failWrite(FileOutputStream).
  ///
  /// Note that if another thread is currently performing
  /// a write, this will simply replace whatever that thread is writing
  /// with the new file being written by this thread, and when the other
  /// thread finishes the write the new write operation will no longer be
  /// safe (or will be lost).  You must do your own threading protection for
  /// access to AtomicFile.
  jni.JniObject startWrite() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_startWrite, jni.JniType.objectType, []).object);

  static final _id_finishWrite = jniAccessors.getMethodIDOf(
      _classRef, "finishWrite", "(Ljava/io/FileOutputStream;)V");

  /// from: public void finishWrite(java.io.FileOutputStream str)
  ///
  /// Call when you have successfully finished writing to the stream
  /// returned by \#startWrite().  This will close, sync, and
  /// commit the new data.  The next attempt to read the atomic file
  /// will return the new file stream.
  void finishWrite(jni.JniObject str) => jniAccessors.callMethodWithArgs(
      reference,
      _id_finishWrite,
      jni.JniType.voidType,
      [str.reference]).check();

  static final _id_failWrite = jniAccessors.getMethodIDOf(
      _classRef, "failWrite", "(Ljava/io/FileOutputStream;)V");

  /// from: public void failWrite(java.io.FileOutputStream str)
  ///
  /// Call when you have failed for some reason at writing to the stream
  /// returned by \#startWrite().  This will close the current
  /// write stream, and roll back to the previous state of the file.
  void failWrite(jni.JniObject str) => jniAccessors.callMethodWithArgs(
      reference, _id_failWrite, jni.JniType.voidType, [str.reference]).check();

  static final _id_openRead = jniAccessors.getMethodIDOf(
      _classRef, "openRead", "()Ljava/io/FileInputStream;");

  /// from: public java.io.FileInputStream openRead()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open the atomic file for reading.  If there previously was an
  /// incomplete write, this will roll back to the last good data before
  /// opening for read.  You should call close() on the FileInputStream when
  /// you are done reading from it.
  ///
  /// Note that if another thread is currently performing
  /// a write, this will incorrectly consider it to be in the state of a bad
  /// write and roll back, causing the new data currently being written to
  /// be dropped.  You must do your own threading protection for access to
  /// AtomicFile.
  jni.JniObject openRead() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_openRead, jni.JniType.objectType, []).object);

  static final _id_readFully =
      jniAccessors.getMethodIDOf(_classRef, "readFully", "()[B");

  /// from: public byte[] readFully()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience for \#openRead() that also reads all of the
  /// file contents into a byte array which is returned.
  jni.JniObject readFully() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readFully, jni.JniType.objectType, []).object);
}
