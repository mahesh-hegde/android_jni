// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.DisplayMetrics
///
/// A structure describing general information about a display, such as its
/// size, density, and font scaling.
/// To access the DisplayMetrics members, initialize an object like this:
///
/// <pre> DisplayMetrics metrics = new DisplayMetrics();
/// getWindowManager().getDefaultDisplay().getMetrics(metrics);</pre>
class DisplayMetrics extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/util/DisplayMetrics");
  DisplayMetrics.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DENSITY_260
  ///
  /// Intermediate density for screens that sit between \#DENSITY_HIGH (240dpi) and
  /// \#DENSITY_XHIGH (320dpi). This is not a density that applications should target,
  /// instead relying on the system to scale their \#DENSITY_XHIGH assets for them.
  static const DENSITY_260 = 260;

  /// from: static public final int DENSITY_280
  ///
  /// Intermediate density for screens that sit between \#DENSITY_HIGH (240dpi) and
  /// \#DENSITY_XHIGH (320dpi). This is not a density that applications should target,
  /// instead relying on the system to scale their \#DENSITY_XHIGH assets for them.
  static const DENSITY_280 = 280;

  /// from: static public final int DENSITY_300
  ///
  /// Intermediate density for screens that sit between \#DENSITY_HIGH (240dpi) and
  /// \#DENSITY_XHIGH (320dpi). This is not a density that applications should target,
  /// instead relying on the system to scale their \#DENSITY_XHIGH assets for them.
  static const DENSITY_300 = 300;

  /// from: static public final int DENSITY_340
  ///
  /// Intermediate density for screens that sit somewhere between
  /// \#DENSITY_XHIGH (320 dpi) and \#DENSITY_XXHIGH (480 dpi).
  /// This is not a density that applications should target, instead relying
  /// on the system to scale their \#DENSITY_XXHIGH assets for them.
  static const DENSITY_340 = 340;

  /// from: static public final int DENSITY_360
  ///
  /// Intermediate density for screens that sit somewhere between
  /// \#DENSITY_XHIGH (320 dpi) and \#DENSITY_XXHIGH (480 dpi).
  /// This is not a density that applications should target, instead relying
  /// on the system to scale their \#DENSITY_XXHIGH assets for them.
  static const DENSITY_360 = 360;

  /// from: static public final int DENSITY_400
  ///
  /// Intermediate density for screens that sit somewhere between
  /// \#DENSITY_XHIGH (320 dpi) and \#DENSITY_XXHIGH (480 dpi).
  /// This is not a density that applications should target, instead relying
  /// on the system to scale their \#DENSITY_XXHIGH assets for them.
  static const DENSITY_400 = 400;

  /// from: static public final int DENSITY_420
  ///
  /// Intermediate density for screens that sit somewhere between
  /// \#DENSITY_XHIGH (320 dpi) and \#DENSITY_XXHIGH (480 dpi).
  /// This is not a density that applications should target, instead relying
  /// on the system to scale their \#DENSITY_XXHIGH assets for them.
  static const DENSITY_420 = 420;

  /// from: static public final int DENSITY_440
  ///
  /// Intermediate density for screens that sit somewhere between
  /// \#DENSITY_XHIGH (320 dpi) and \#DENSITY_XXHIGH (480 dpi).
  /// This is not a density that applications should target, instead relying
  /// on the system to scale their \#DENSITY_XXHIGH assets for them.
  static const DENSITY_440 = 440;

  /// from: static public final int DENSITY_560
  ///
  /// Intermediate density for screens that sit somewhere between
  /// \#DENSITY_XXHIGH (480 dpi) and \#DENSITY_XXXHIGH (640 dpi).
  /// This is not a density that applications should target, instead relying
  /// on the system to scale their \#DENSITY_XXXHIGH assets for them.
  static const DENSITY_560 = 560;

  /// from: static public final int DENSITY_DEFAULT
  ///
  /// The reference density used throughout the system.
  static const DENSITY_DEFAULT = 160;

  static final _id_DENSITY_DEVICE_STABLE =
      jniAccessors.getStaticFieldIDOf(_classRef, "DENSITY_DEVICE_STABLE", "I");

  /// from: static public final int DENSITY_DEVICE_STABLE
  ///
  /// The device's stable density.
  ///
  /// This value is constant at run time and may not reflect the current
  /// display density. To obtain the current density for a specific display,
  /// use \#densityDpi.
  static int get DENSITY_DEVICE_STABLE => jniAccessors
      .getStaticField(_classRef, _id_DENSITY_DEVICE_STABLE, jni.JniType.intType)
      .integer;

  /// from: static public final int DENSITY_HIGH
  ///
  /// Standard quantized DPI for high-density screens.
  static const DENSITY_HIGH = 240;

  /// from: static public final int DENSITY_LOW
  ///
  /// Standard quantized DPI for low-density screens.
  static const DENSITY_LOW = 120;

  /// from: static public final int DENSITY_MEDIUM
  ///
  /// Standard quantized DPI for medium-density screens.
  static const DENSITY_MEDIUM = 160;

  /// from: static public final int DENSITY_TV
  ///
  /// This is a secondary density, added for some common screen configurations.
  /// It is recommended that applications not generally target this as a first
  /// class density -- that is, don't supply specific graphics for this
  /// density, instead allow the platform to scale from other densities
  /// (typically \#DENSITY_HIGH) as
  /// appropriate.  In most cases (such as using bitmaps in
  /// android.graphics.drawable.Drawable) the platform
  /// can perform this scaling at load time, so the only cost is some slight
  /// startup runtime overhead.
  ///
  /// This density was original introduced to correspond with a
  /// 720p TV screen: the density for 1080p televisions is
  /// \#DENSITY_XHIGH, and the value here provides the same UI
  /// size for a TV running at 720p.  It has also found use in 7" tablets,
  /// when these devices have 1280x720 displays.
  static const DENSITY_TV = 213;

  /// from: static public final int DENSITY_XHIGH
  ///
  /// Standard quantized DPI for extra-high-density screens.
  static const DENSITY_XHIGH = 320;

  /// from: static public final int DENSITY_XXHIGH
  ///
  /// Standard quantized DPI for extra-extra-high-density screens.
  static const DENSITY_XXHIGH = 480;

  /// from: static public final int DENSITY_XXXHIGH
  ///
  /// Standard quantized DPI for extra-extra-extra-high-density screens.  Applications
  /// should not generally worry about this density; relying on XHIGH graphics
  /// being scaled up to it should be sufficient for almost all cases.  A typical
  /// use of this density would be 4K television screens -- 3840x2160, which
  /// is 2x a traditional HD 1920x1080 screen which runs at DENSITY_XHIGH.
  static const DENSITY_XXXHIGH = 640;

  static final _id_density =
      jniAccessors.getFieldIDOf(_classRef, "density", "F");

  /// from: public float density
  ///
  /// The logical density of the display.  This is a scaling factor for the
  /// Density Independent Pixel unit, where one DIP is one pixel on an
  /// approximately 160 dpi screen (for example a 240x320, 1.5"x2" screen),
  /// providing the baseline of the system's display. Thus on a 160dpi screen
  /// this density value will be 1; on a 120 dpi screen it would be .75; etc.
  ///
  /// This value does not exactly follow the real screen size (as given by
  /// \#xdpi and \#ydpi, but rather is used to scale the size of
  /// the overall UI in steps based on gross changes in the display dpi.  For
  /// example, a 240x320 screen will have a density of 1 even if its width is
  /// 1.8", 1.3", etc. However, if the screen resolution is increased to
  /// 320x480 but the screen size remained 1.5"x2" then the density would be
  /// increased (probably to 1.5).
  ///@see \#DENSITY_DEFAULT
  double get density => jniAccessors
      .getField(reference, _id_density, jni.JniType.floatType)
      .float;

  /// from: public float density
  ///
  /// The logical density of the display.  This is a scaling factor for the
  /// Density Independent Pixel unit, where one DIP is one pixel on an
  /// approximately 160 dpi screen (for example a 240x320, 1.5"x2" screen),
  /// providing the baseline of the system's display. Thus on a 160dpi screen
  /// this density value will be 1; on a 120 dpi screen it would be .75; etc.
  ///
  /// This value does not exactly follow the real screen size (as given by
  /// \#xdpi and \#ydpi, but rather is used to scale the size of
  /// the overall UI in steps based on gross changes in the display dpi.  For
  /// example, a 240x320 screen will have a density of 1 even if its width is
  /// 1.8", 1.3", etc. However, if the screen resolution is increased to
  /// 320x480 but the screen size remained 1.5"x2" then the density would be
  /// increased (probably to 1.5).
  ///@see \#DENSITY_DEFAULT
  set density(double value) =>
      jniEnv.SetFloatField(reference, _id_density, value);

  static final _id_densityDpi =
      jniAccessors.getFieldIDOf(_classRef, "densityDpi", "I");

  /// from: public int densityDpi
  ///
  /// The screen density expressed as dots-per-inch.  May be either
  /// \#DENSITY_LOW, \#DENSITY_MEDIUM, or \#DENSITY_HIGH.
  int get densityDpi => jniAccessors
      .getField(reference, _id_densityDpi, jni.JniType.intType)
      .integer;

  /// from: public int densityDpi
  ///
  /// The screen density expressed as dots-per-inch.  May be either
  /// \#DENSITY_LOW, \#DENSITY_MEDIUM, or \#DENSITY_HIGH.
  set densityDpi(int value) =>
      jniEnv.SetIntField(reference, _id_densityDpi, value);

  static final _id_heightPixels =
      jniAccessors.getFieldIDOf(_classRef, "heightPixels", "I");

  /// from: public int heightPixels
  ///
  /// The absolute height of the available display size in pixels.
  int get heightPixels => jniAccessors
      .getField(reference, _id_heightPixels, jni.JniType.intType)
      .integer;

  /// from: public int heightPixels
  ///
  /// The absolute height of the available display size in pixels.
  set heightPixels(int value) =>
      jniEnv.SetIntField(reference, _id_heightPixels, value);

  static final _id_scaledDensity =
      jniAccessors.getFieldIDOf(_classRef, "scaledDensity", "F");

  /// from: public float scaledDensity
  ///
  /// A scaling factor for fonts displayed on the display.  This is the same
  /// as \#density, except that it may be adjusted in smaller
  /// increments at runtime based on a user preference for the font size.
  double get scaledDensity => jniAccessors
      .getField(reference, _id_scaledDensity, jni.JniType.floatType)
      .float;

  /// from: public float scaledDensity
  ///
  /// A scaling factor for fonts displayed on the display.  This is the same
  /// as \#density, except that it may be adjusted in smaller
  /// increments at runtime based on a user preference for the font size.
  set scaledDensity(double value) =>
      jniEnv.SetFloatField(reference, _id_scaledDensity, value);

  static final _id_widthPixels =
      jniAccessors.getFieldIDOf(_classRef, "widthPixels", "I");

  /// from: public int widthPixels
  ///
  /// The absolute width of the available display size in pixels.
  int get widthPixels => jniAccessors
      .getField(reference, _id_widthPixels, jni.JniType.intType)
      .integer;

  /// from: public int widthPixels
  ///
  /// The absolute width of the available display size in pixels.
  set widthPixels(int value) =>
      jniEnv.SetIntField(reference, _id_widthPixels, value);

  static final _id_xdpi = jniAccessors.getFieldIDOf(_classRef, "xdpi", "F");

  /// from: public float xdpi
  ///
  /// The exact physical pixels per inch of the screen in the X dimension.
  double get xdpi =>
      jniAccessors.getField(reference, _id_xdpi, jni.JniType.floatType).float;

  /// from: public float xdpi
  ///
  /// The exact physical pixels per inch of the screen in the X dimension.
  set xdpi(double value) => jniEnv.SetFloatField(reference, _id_xdpi, value);

  static final _id_ydpi = jniAccessors.getFieldIDOf(_classRef, "ydpi", "F");

  /// from: public float ydpi
  ///
  /// The exact physical pixels per inch of the screen in the Y dimension.
  double get ydpi =>
      jniAccessors.getField(reference, _id_ydpi, jni.JniType.floatType).float;

  /// from: public float ydpi
  ///
  /// The exact physical pixels per inch of the screen in the Y dimension.
  set ydpi(double value) => jniEnv.SetFloatField(reference, _id_ydpi, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DisplayMetrics()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setTo = jniAccessors.getMethodIDOf(
      _classRef, "setTo", "(Landroid/util/DisplayMetrics;)V");

  /// from: public void setTo(android.util.DisplayMetrics o)
  void setTo(DisplayMetrics o) => jniAccessors.callMethodWithArgs(
      reference, _id_setTo, jni.JniType.voidType, [o.reference]).check();

  static final _id_setToDefaults =
      jniAccessors.getMethodIDOf(_classRef, "setToDefaults", "()V");

  /// from: public void setToDefaults()
  void setToDefaults() => jniAccessors.callMethodWithArgs(
      reference, _id_setToDefaults, jni.JniType.voidType, []).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_equals2 = jniAccessors.getMethodIDOf(
      _classRef, "equals", "(Landroid/util/DisplayMetrics;)Z");

  /// from: public boolean equals(android.util.DisplayMetrics other)
  ///
  /// Returns true if these display metrics equal the other display metrics.
  ///@param other The display metrics with which to compare.
  ///@return True if the display metrics are equal.
  bool equals2(DisplayMetrics other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals2,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
