// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "DisplayMetrics.dart" as displaymetrics_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.TypedValue
///
/// Container for a dynamically typed data value.  Primarily used with
/// android.content.res.Resources for holding resource values.
class TypedValue extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/TypedValue");
  TypedValue.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int COMPLEX_MANTISSA_MASK
  ///
  /// Complex data: mask to extract mantissa information (after shifting by
  ///  \#COMPLEX_MANTISSA_SHIFT). This gives us 23 bits of precision;
  ///  the top bit is the sign.
  static const COMPLEX_MANTISSA_MASK = 16777215;

  /// from: static public final int COMPLEX_MANTISSA_SHIFT
  ///
  /// Complex data: bit location of mantissa information.
  static const COMPLEX_MANTISSA_SHIFT = 8;

  /// from: static public final int COMPLEX_RADIX_0p23
  ///
  /// Complex data: the mantissa magnitude is 0 bits -- i.e, 0x0.nnnnnn
  static const COMPLEX_RADIX_0p23 = 3;

  /// from: static public final int COMPLEX_RADIX_16p7
  ///
  /// Complex data: the mantissa magnitude is 16 bits -- i.e, 0xnnnn.nn
  static const COMPLEX_RADIX_16p7 = 1;

  /// from: static public final int COMPLEX_RADIX_23p0
  ///
  /// Complex data: the mantissa is an integral number -- i.e., 0xnnnnnn.0
  static const COMPLEX_RADIX_23p0 = 0;

  /// from: static public final int COMPLEX_RADIX_8p15
  ///
  /// Complex data: the mantissa magnitude is 8 bits -- i.e, 0xnn.nnnn
  static const COMPLEX_RADIX_8p15 = 2;

  /// from: static public final int COMPLEX_RADIX_MASK
  ///
  /// Complex data: mask to extract radix information (after shifting by
  /// \#COMPLEX_RADIX_SHIFT). This give us 4 possible fixed point
  /// representations as defined below.
  static const COMPLEX_RADIX_MASK = 3;

  /// from: static public final int COMPLEX_RADIX_SHIFT
  ///
  /// Complex data: where the radix information is, telling where the decimal
  ///  place appears in the mantissa.
  static const COMPLEX_RADIX_SHIFT = 4;

  /// from: static public final int COMPLEX_UNIT_DIP
  ///
  /// \#TYPE_DIMENSION complex unit: Value is Device Independent
  ///  Pixels.
  static const COMPLEX_UNIT_DIP = 1;

  /// from: static public final int COMPLEX_UNIT_FRACTION
  ///
  /// \#TYPE_FRACTION complex unit: A basic fraction of the overall
  ///  size.
  static const COMPLEX_UNIT_FRACTION = 0;

  /// from: static public final int COMPLEX_UNIT_FRACTION_PARENT
  ///
  /// \#TYPE_FRACTION complex unit: A fraction of the parent size.
  static const COMPLEX_UNIT_FRACTION_PARENT = 1;

  /// from: static public final int COMPLEX_UNIT_IN
  ///
  /// \#TYPE_DIMENSION complex unit: Value is in inches.
  static const COMPLEX_UNIT_IN = 4;

  /// from: static public final int COMPLEX_UNIT_MASK
  ///
  /// Complex data: mask to extract unit information (after shifting by
  ///  \#COMPLEX_UNIT_SHIFT). This gives us 16 possible types, as
  ///  defined below.
  static const COMPLEX_UNIT_MASK = 15;

  /// from: static public final int COMPLEX_UNIT_MM
  ///
  /// \#TYPE_DIMENSION complex unit: Value is in millimeters.
  static const COMPLEX_UNIT_MM = 5;

  /// from: static public final int COMPLEX_UNIT_PT
  ///
  /// \#TYPE_DIMENSION complex unit: Value is in points.
  static const COMPLEX_UNIT_PT = 3;

  /// from: static public final int COMPLEX_UNIT_PX
  ///
  /// \#TYPE_DIMENSION complex unit: Value is raw pixels.
  static const COMPLEX_UNIT_PX = 0;

  /// from: static public final int COMPLEX_UNIT_SHIFT
  ///
  /// Complex data: bit location of unit information.
  static const COMPLEX_UNIT_SHIFT = 0;

  /// from: static public final int COMPLEX_UNIT_SP
  ///
  /// \#TYPE_DIMENSION complex unit: Value is a scaled pixel.
  static const COMPLEX_UNIT_SP = 2;

  /// from: static public final int DATA_NULL_EMPTY
  ///
  /// \#TYPE_NULL data indicating the value was explicitly set to null.
  static const DATA_NULL_EMPTY = 1;

  /// from: static public final int DATA_NULL_UNDEFINED
  ///
  /// \#TYPE_NULL data indicating the value was not specified.
  static const DATA_NULL_UNDEFINED = 0;

  /// from: static public final int DENSITY_DEFAULT
  ///
  /// If \#density is equal to this value, then the density should be
  /// treated as the system's default density value: DisplayMetrics\#DENSITY_DEFAULT.
  static const DENSITY_DEFAULT = 0;

  /// from: static public final int DENSITY_NONE
  ///
  /// If \#density is equal to this value, then there is no density
  /// associated with the resource and it should not be scaled.
  static const DENSITY_NONE = 65535;

  /// from: static public final int TYPE_ATTRIBUTE
  ///
  /// The <var>data</var> field holds an attribute resource
  ///  identifier (referencing an attribute in the current theme
  ///  style, not a resource entry).
  static const TYPE_ATTRIBUTE = 2;

  /// from: static public final int TYPE_DIMENSION
  ///
  /// The <var>data</var> field holds a complex number encoding a
  ///  dimension value.
  static const TYPE_DIMENSION = 5;

  /// from: static public final int TYPE_FIRST_COLOR_INT
  ///
  /// Identifies the start of integer values that were specified as
  ///  color constants (starting with '\#').
  static const TYPE_FIRST_COLOR_INT = 28;

  /// from: static public final int TYPE_FIRST_INT
  ///
  /// Identifies the start of plain integer values.  Any type value
  ///  from this to \#TYPE_LAST_INT means the
  ///  <var>data</var> field holds a generic integer value.
  static const TYPE_FIRST_INT = 16;

  /// from: static public final int TYPE_FLOAT
  ///
  /// The <var>data</var> field holds an IEEE 754 floating point number.
  static const TYPE_FLOAT = 4;

  /// from: static public final int TYPE_FRACTION
  ///
  /// The <var>data</var> field holds a complex number encoding a fraction
  ///  of a container.
  static const TYPE_FRACTION = 6;

  /// from: static public final int TYPE_INT_BOOLEAN
  ///
  /// The <var>data</var> field holds 0 or 1 that was originally
  ///  specified as "false" or "true".
  static const TYPE_INT_BOOLEAN = 18;

  /// from: static public final int TYPE_INT_COLOR_ARGB4
  ///
  /// The <var>data</var> field holds a color that was originally
  ///  specified as \#argb.
  static const TYPE_INT_COLOR_ARGB4 = 30;

  /// from: static public final int TYPE_INT_COLOR_ARGB8
  ///
  /// The <var>data</var> field holds a color that was originally
  ///  specified as \#aarrggbb.
  static const TYPE_INT_COLOR_ARGB8 = 28;

  /// from: static public final int TYPE_INT_COLOR_RGB4
  ///
  /// The <var>data</var> field holds a color that was originally
  ///  specified as \#rgb.
  static const TYPE_INT_COLOR_RGB4 = 31;

  /// from: static public final int TYPE_INT_COLOR_RGB8
  ///
  /// The <var>data</var> field holds a color that was originally
  ///  specified as \#rrggbb.
  static const TYPE_INT_COLOR_RGB8 = 29;

  /// from: static public final int TYPE_INT_DEC
  ///
  /// The <var>data</var> field holds a number that was
  ///  originally specified in decimal.
  static const TYPE_INT_DEC = 16;

  /// from: static public final int TYPE_INT_HEX
  ///
  /// The <var>data</var> field holds a number that was
  ///  originally specified in hexadecimal (0xn).
  static const TYPE_INT_HEX = 17;

  /// from: static public final int TYPE_LAST_COLOR_INT
  ///
  /// Identifies the end of integer values that were specified as color
  ///  constants.
  static const TYPE_LAST_COLOR_INT = 31;

  /// from: static public final int TYPE_LAST_INT
  ///
  /// Identifies the end of plain integer values.
  static const TYPE_LAST_INT = 31;

  /// from: static public final int TYPE_NULL
  ///
  /// The value contains no data.
  static const TYPE_NULL = 0;

  /// from: static public final int TYPE_REFERENCE
  ///
  /// The <var>data</var> field holds a resource identifier.
  static const TYPE_REFERENCE = 1;

  /// from: static public final int TYPE_STRING
  ///
  /// The <var>string</var> field holds string data.  In addition, if
  ///  <var>data</var> is non-zero then it is the string block
  ///  index of the string and <var>assetCookie</var> is the set of
  ///  assets the string came from.
  static const TYPE_STRING = 3;

  static final _id_assetCookie =
      jniAccessors.getFieldIDOf(_classRef, "assetCookie", "I");

  /// from: public int assetCookie
  ///
  /// Additional information about where the value came from; only
  ///  set for strings.
  int get assetCookie => jniAccessors
      .getField(reference, _id_assetCookie, jni.JniType.intType)
      .integer;

  /// from: public int assetCookie
  ///
  /// Additional information about where the value came from; only
  ///  set for strings.
  set assetCookie(int value) =>
      jniEnv.SetIntField(reference, _id_assetCookie, value);

  static final _id_changingConfigurations =
      jniAccessors.getFieldIDOf(_classRef, "changingConfigurations", "I");

  /// from: public int changingConfigurations
  ///
  /// If the value came from a resource, these are the configurations for
  /// which its contents can change.
  ///
  /// For example, if a resource has a value defined for the -land resource qualifier,
  /// this field will have the android.content.pm.ActivityInfo\#CONFIG_ORIENTATION bit set.
  ///
  ///
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see android.content.pm.ActivityInfo\#CONFIG_MCC
  ///@see android.content.pm.ActivityInfo\#CONFIG_MNC
  ///@see android.content.pm.ActivityInfo\#CONFIG_LOCALE
  ///@see android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN
  ///@see android.content.pm.ActivityInfo\#CONFIG_KEYBOARD
  ///@see android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN
  ///@see android.content.pm.ActivityInfo\#CONFIG_NAVIGATION
  ///@see android.content.pm.ActivityInfo\#CONFIG_ORIENTATION
  ///@see android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT
  ///@see android.content.pm.ActivityInfo\#CONFIG_UI_MODE
  ///@see android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE
  ///@see android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE
  ///@see android.content.pm.ActivityInfo\#CONFIG_DENSITY
  ///@see android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION
  ///@see android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE
  int get changingConfigurations => jniAccessors
      .getField(reference, _id_changingConfigurations, jni.JniType.intType)
      .integer;

  /// from: public int changingConfigurations
  ///
  /// If the value came from a resource, these are the configurations for
  /// which its contents can change.
  ///
  /// For example, if a resource has a value defined for the -land resource qualifier,
  /// this field will have the android.content.pm.ActivityInfo\#CONFIG_ORIENTATION bit set.
  ///
  ///
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see android.content.pm.ActivityInfo\#CONFIG_MCC
  ///@see android.content.pm.ActivityInfo\#CONFIG_MNC
  ///@see android.content.pm.ActivityInfo\#CONFIG_LOCALE
  ///@see android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN
  ///@see android.content.pm.ActivityInfo\#CONFIG_KEYBOARD
  ///@see android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN
  ///@see android.content.pm.ActivityInfo\#CONFIG_NAVIGATION
  ///@see android.content.pm.ActivityInfo\#CONFIG_ORIENTATION
  ///@see android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT
  ///@see android.content.pm.ActivityInfo\#CONFIG_UI_MODE
  ///@see android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE
  ///@see android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE
  ///@see android.content.pm.ActivityInfo\#CONFIG_DENSITY
  ///@see android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION
  ///@see android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE
  set changingConfigurations(int value) =>
      jniEnv.SetIntField(reference, _id_changingConfigurations, value);

  static final _id_data = jniAccessors.getFieldIDOf(_classRef, "data", "I");

  /// from: public int data
  ///
  /// Basic data in the value, interpreted according to \#type
  int get data =>
      jniAccessors.getField(reference, _id_data, jni.JniType.intType).integer;

  /// from: public int data
  ///
  /// Basic data in the value, interpreted according to \#type
  set data(int value) => jniEnv.SetIntField(reference, _id_data, value);

  static final _id_density =
      jniAccessors.getFieldIDOf(_classRef, "density", "I");

  /// from: public int density
  ///
  /// If the Value came from a resource, this holds the corresponding pixel density.
  int get density => jniAccessors
      .getField(reference, _id_density, jni.JniType.intType)
      .integer;

  /// from: public int density
  ///
  /// If the Value came from a resource, this holds the corresponding pixel density.
  set density(int value) => jniEnv.SetIntField(reference, _id_density, value);

  static final _id_resourceId =
      jniAccessors.getFieldIDOf(_classRef, "resourceId", "I");

  /// from: public int resourceId
  ///
  /// If Value came from a resource, this holds the corresponding resource id.
  int get resourceId => jniAccessors
      .getField(reference, _id_resourceId, jni.JniType.intType)
      .integer;

  /// from: public int resourceId
  ///
  /// If Value came from a resource, this holds the corresponding resource id.
  set resourceId(int value) =>
      jniEnv.SetIntField(reference, _id_resourceId, value);

  static final _id_string = jniAccessors.getFieldIDOf(
      _classRef, "string", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence string
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the value holds a string, this is it.
  jni.JniObject get string => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_string, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence string
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the value holds a string, this is it.
  set string(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_string, value.reference);

  static final _id_type = jniAccessors.getFieldIDOf(_classRef, "type", "I");

  /// from: public int type
  ///
  /// The type held by this value, as defined by the constants here.
  ///  This tells you how to interpret the other fields in the object.
  int get type =>
      jniAccessors.getField(reference, _id_type, jni.JniType.intType).integer;

  /// from: public int type
  ///
  /// The type held by this value, as defined by the constants here.
  ///  This tells you how to interpret the other fields in the object.
  set type(int value) => jniEnv.SetIntField(reference, _id_type, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TypedValue()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getFloat =
      jniAccessors.getMethodIDOf(_classRef, "getFloat", "()F");

  /// from: public final float getFloat()
  ///
  /// Return the data for this value as a float.  Only use for values
  ///  whose type is \#TYPE_FLOAT.
  double getFloat() => jniAccessors.callMethodWithArgs(
      reference, _id_getFloat, jni.JniType.floatType, []).float;

  static final _id_complexToFloat =
      jniAccessors.getStaticMethodIDOf(_classRef, "complexToFloat", "(I)F");

  /// from: static public float complexToFloat(int complex)
  ///
  /// Retrieve the base value from a complex data integer.  This uses the
  /// \#COMPLEX_MANTISSA_MASK and \#COMPLEX_RADIX_MASK fields of
  /// the data to compute a floating point representation of the number they
  /// describe.  The units are ignored.
  ///@param complex A complex data value.
  ///@return A floating point value corresponding to the complex data.
  static double complexToFloat(int complex) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_complexToFloat,
          jni.JniType.floatType, [complex]).float;

  static final _id_complexToDimension = jniAccessors.getStaticMethodIDOf(
      _classRef, "complexToDimension", "(ILandroid/util/DisplayMetrics;)F");

  /// from: static public float complexToDimension(int data, android.util.DisplayMetrics metrics)
  ///
  /// Converts a complex data value holding a dimension to its final floating
  /// point value. The given <var>data</var> must be structured as a
  /// \#TYPE_DIMENSION.
  ///@param data A complex data value holding a unit, magnitude, and
  ///             mantissa.
  ///@param metrics Current display metrics to use in the conversion --
  ///                supplies display density and scaling information.
  ///@return The complex floating point value multiplied by the appropriate
  /// metrics depending on its unit.
  static double complexToDimension(
          int data, displaymetrics_.DisplayMetrics metrics) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_complexToDimension,
          jni.JniType.floatType, [data, metrics.reference]).float;

  static final _id_complexToDimensionPixelOffset =
      jniAccessors.getStaticMethodIDOf(_classRef,
          "complexToDimensionPixelOffset", "(ILandroid/util/DisplayMetrics;)I");

  /// from: static public int complexToDimensionPixelOffset(int data, android.util.DisplayMetrics metrics)
  ///
  /// Converts a complex data value holding a dimension to its final value
  /// as an integer pixel offset.  This is the same as
  /// \#complexToDimension, except the raw floating point value is
  /// truncated to an integer (pixel) value.
  /// The given <var>data</var> must be structured as a
  /// \#TYPE_DIMENSION.
  ///@param data A complex data value holding a unit, magnitude, and
  ///             mantissa.
  ///@param metrics Current display metrics to use in the conversion --
  ///                supplies display density and scaling information.
  ///@return The number of pixels specified by the data and its desired
  /// multiplier and units.
  static int complexToDimensionPixelOffset(
          int data, displaymetrics_.DisplayMetrics metrics) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_complexToDimensionPixelOffset,
          jni.JniType.intType,
          [data, metrics.reference]).integer;

  static final _id_complexToDimensionPixelSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "complexToDimensionPixelSize",
          "(ILandroid/util/DisplayMetrics;)I");

  /// from: static public int complexToDimensionPixelSize(int data, android.util.DisplayMetrics metrics)
  ///
  /// Converts a complex data value holding a dimension to its final value
  /// as an integer pixel size.  This is the same as
  /// \#complexToDimension, except the raw floating point value is
  /// converted to an integer (pixel) value for use as a size.  A size
  /// conversion involves rounding the base value, and ensuring that a
  /// non-zero base value is at least one pixel in size.
  /// The given <var>data</var> must be structured as a
  /// \#TYPE_DIMENSION.
  ///@param data A complex data value holding a unit, magnitude, and
  ///             mantissa.
  ///@param metrics Current display metrics to use in the conversion --
  ///                supplies display density and scaling information.
  ///@return The number of pixels specified by the data and its desired
  /// multiplier and units.
  static int complexToDimensionPixelSize(
          int data, displaymetrics_.DisplayMetrics metrics) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_complexToDimensionPixelSize,
          jni.JniType.intType,
          [data, metrics.reference]).integer;

  static final _id_getComplexUnit =
      jniAccessors.getMethodIDOf(_classRef, "getComplexUnit", "()I");

  /// from: public int getComplexUnit()
  ///
  /// Return the complex unit type for this value. For example, a dimen type
  /// with value 12sp will return \#COMPLEX_UNIT_SP. Only use for values
  /// whose type is \#TYPE_DIMENSION.
  ///@return The complex unit type.
  int getComplexUnit() => jniAccessors.callMethodWithArgs(
      reference, _id_getComplexUnit, jni.JniType.intType, []).integer;

  static final _id_applyDimension = jniAccessors.getStaticMethodIDOf(
      _classRef, "applyDimension", "(IFLandroid/util/DisplayMetrics;)F");

  /// from: static public float applyDimension(int unit, float value, android.util.DisplayMetrics metrics)
  ///
  /// Converts an unpacked complex data value holding a dimension to its final floating
  /// point value. The two parameters <var>unit</var> and <var>value</var>
  /// are as in \#TYPE_DIMENSION.
  ///@param unit The unit to convert from.
  ///@param value The value to apply the unit to.
  ///@param metrics Current display metrics to use in the conversion --
  ///                supplies display density and scaling information.
  ///@return The complex floating point value multiplied by the appropriate
  /// metrics depending on its unit.
  static double applyDimension(
          int unit, double value, displaymetrics_.DisplayMetrics metrics) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_applyDimension,
          jni.JniType.floatType, [unit, value, metrics.reference]).float;

  static final _id_getDimension = jniAccessors.getMethodIDOf(
      _classRef, "getDimension", "(Landroid/util/DisplayMetrics;)F");

  /// from: public float getDimension(android.util.DisplayMetrics metrics)
  ///
  /// Return the data for this value as a dimension.  Only use for values
  /// whose type is \#TYPE_DIMENSION.
  ///@param metrics Current display metrics to use in the conversion --
  ///                supplies display density and scaling information.
  ///@return The complex floating point value multiplied by the appropriate
  /// metrics depending on its unit.
  double getDimension(displaymetrics_.DisplayMetrics metrics) =>
      jniAccessors.callMethodWithArgs(reference, _id_getDimension,
          jni.JniType.floatType, [metrics.reference]).float;

  static final _id_complexToFraction = jniAccessors.getStaticMethodIDOf(
      _classRef, "complexToFraction", "(IFF)F");

  /// from: static public float complexToFraction(int data, float base, float pbase)
  ///
  /// Converts a complex data value holding a fraction to its final floating
  /// point value. The given <var>data</var> must be structured as a
  /// \#TYPE_FRACTION.
  ///@param data A complex data value holding a unit, magnitude, and
  ///             mantissa.
  ///@param base The base value of this fraction.  In other words, a
  ///             standard fraction is multiplied by this value.
  ///@param pbase The parent base value of this fraction.  In other
  ///             words, a parent fraction (nn%p) is multiplied by this
  ///             value.
  ///@return The complex floating point value multiplied by the appropriate
  /// base value depending on its unit.
  static double complexToFraction(int data, double base, double pbase) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_complexToFraction,
          jni.JniType.floatType, [data, base, pbase]).float;

  static final _id_getFraction =
      jniAccessors.getMethodIDOf(_classRef, "getFraction", "(FF)F");

  /// from: public float getFraction(float base, float pbase)
  ///
  /// Return the data for this value as a fraction.  Only use for values whose
  /// type is \#TYPE_FRACTION.
  ///@param base The base value of this fraction.  In other words, a
  ///             standard fraction is multiplied by this value.
  ///@param pbase The parent base value of this fraction.  In other
  ///             words, a parent fraction (nn%p) is multiplied by this
  ///             value.
  ///@return The complex floating point value multiplied by the appropriate
  /// base value depending on its unit.
  double getFraction(double base, double pbase) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFraction,
          jni.JniType.floatType, [base, pbase]).float;

  static final _id_coerceToString = jniAccessors.getMethodIDOf(
      _classRef, "coerceToString", "()Ljava/lang/CharSequence;");

  /// from: public final java.lang.CharSequence coerceToString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Regardless of the actual type of the value, try to convert it to a
  /// string value.  For example, a color type will be converted to a
  /// string of the form \#aarrggbb.
  ///@return CharSequence The coerced string value.  If the value is
  ///         null or the type is not known, null is returned.
  jni.JniObject coerceToString() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_coerceToString, jni.JniType.objectType, []).object);

  static final _id_coerceToString1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "coerceToString", "(II)Ljava/lang/String;");

  /// from: static public final java.lang.String coerceToString(int type, int data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform type conversion as per \#coerceToString() on an
  /// explicitly supplied type and data.
  ///@param type The data type identifier.
  ///@param data The data value.
  ///@return String The coerced string value.  If the value is
  ///         null or the type is not known, null is returned.
  static jni.JniString coerceToString1(int type, int data) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_coerceToString1, jni.JniType.objectType, [type, data]).object);

  static final _id_setTo = jniAccessors.getMethodIDOf(
      _classRef, "setTo", "(Landroid/util/TypedValue;)V");

  /// from: public void setTo(android.util.TypedValue other)
  void setTo(TypedValue other) => jniAccessors.callMethodWithArgs(
      reference, _id_setTo, jni.JniType.voidType, [other.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
