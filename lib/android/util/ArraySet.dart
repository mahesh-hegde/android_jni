// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.ArraySet
///
/// ArraySet is a generic set data structure that is designed to be more memory efficient than a
/// traditional java.util.HashSet.  The design is very similar to
/// ArrayMap, with all of the caveats described there.  This implementation is
/// separate from ArrayMap, however, so the Object array contains only one item for each
/// entry in the set (instead of a pair for a mapping).
///
/// Note that this implementation is not intended to be appropriate for data structures
/// that may contain large numbers of items.  It is generally slower than a traditional
/// HashSet, since lookups require a binary search and adds and removes require inserting
/// and deleting entries in the array.  For containers holding up to hundreds of items,
/// the performance difference is not significant, less than 50%.
///
///
/// Because this container is intended to better balance memory use, unlike most other
/// standard Java containers it will shrink its array as items are removed from it.  Currently
/// you have no control over this shrinking -- if you set a capacity and then remove an
/// item, it may reduce the capacity to better match the current size.  In the future an
/// explicit call to set the capacity should turn off this aggressive shrinking behavior.
///
class ArraySet extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/ArraySet");
  ArraySet.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new empty ArraySet.  The default capacity of an array map is 0, and
  /// will grow once items are added to it.
  ArraySet()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int capacity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ArraySet with a given initial capacity.
  ArraySet.ctor1(int capacity)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [capacity]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/util/ArraySet;)V");

  /// from: public void <init>(android.util.ArraySet<E> set)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ArraySet with the mappings from the given ArraySet.
  ArraySet.ctor2(ArraySet set0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [set0.reference]).object);

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Make the array map empty.  All storage is released.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_ensureCapacity =
      jniAccessors.getMethodIDOf(_classRef, "ensureCapacity", "(I)V");

  /// from: public void ensureCapacity(int minimumCapacity)
  ///
  /// Ensure the array map can hold at least <var>minimumCapacity</var>
  /// items.
  void ensureCapacity(int minimumCapacity) => jniAccessors.callMethodWithArgs(
      reference,
      _id_ensureCapacity,
      jni.JniType.voidType,
      [minimumCapacity]).check();

  static final _id_contains = jniAccessors.getMethodIDOf(
      _classRef, "contains", "(Ljava/lang/Object;)Z");

  /// from: public boolean contains(java.lang.Object key)
  ///
  /// Check whether a value exists in the set.
  ///@param key The value to search for.
  ///@return Returns true if the value exists, else false.
  bool contains(jni.JniObject key) => jniAccessors.callMethodWithArgs(reference,
      _id_contains, jni.JniType.booleanType, [key.reference]).boolean;

  static final _id_indexOf =
      jniAccessors.getMethodIDOf(_classRef, "indexOf", "(Ljava/lang/Object;)I");

  /// from: public int indexOf(java.lang.Object key)
  ///
  /// Returns the index of a value in the set.
  ///@param key The value to search for.
  ///@return Returns the index of the value if it exists, else a negative integer.
  int indexOf(jni.JniObject key) => jniAccessors.callMethodWithArgs(
      reference, _id_indexOf, jni.JniType.intType, [key.reference]).integer;

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public boolean isEmpty()
  ///
  /// Return true if the array map contains no items.
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniType.booleanType, []).boolean;

  static final _id_addAll = jniAccessors.getMethodIDOf(
      _classRef, "addAll", "(Landroid/util/ArraySet;)V");

  /// from: public void addAll(android.util.ArraySet<? extends E> array)
  ///
  /// Perform a \#add(Object) of all values in <var>array</var>
  ///@param array The array whose contents are to be retrieved.
  void addAll(ArraySet array) => jniAccessors.callMethodWithArgs(
      reference, _id_addAll, jni.JniType.voidType, [array.reference]).check();

  static final _id_remove =
      jniAccessors.getMethodIDOf(_classRef, "remove", "(Ljava/lang/Object;)Z");

  /// from: public boolean remove(java.lang.Object object)
  ///
  /// Removes the specified object from this set.
  ///@param object the object to remove.
  ///@return {@code true} if this set was modified, {@code false} otherwise.
  bool remove(jni.JniObject object) => jniAccessors.callMethodWithArgs(
      reference,
      _id_remove,
      jni.JniType.booleanType,
      [object.reference]).boolean;

  static final _id_removeAll = jniAccessors.getMethodIDOf(
      _classRef, "removeAll", "(Landroid/util/ArraySet;)Z");

  /// from: public boolean removeAll(android.util.ArraySet<? extends E> array)
  ///
  /// Perform a \#remove(Object) of all values in <var>array</var>
  ///@param array The array whose contents are to be removed.
  bool removeAll(ArraySet array) => jniAccessors.callMethodWithArgs(reference,
      _id_removeAll, jni.JniType.booleanType, [array.reference]).boolean;

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: public int size()
  ///
  /// Return the number of items in this array map.
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.intType, []).integer;

  static final _id_toArray =
      jniAccessors.getMethodIDOf(_classRef, "toArray", "()[Ljava/lang/Object;");

  /// from: public java.lang.Object[] toArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject toArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toArray, jni.JniType.objectType, []).object);

  static final _id_toArray1 = jniAccessors.getMethodIDOf(
      _classRef, "toArray", "([Ljava/lang/Object;)[Ljava/lang/Object;");

  /// from: public T[] toArray(T[] array)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject toArray1(jni.JniObject array) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_toArray1, jni.JniType.objectType, [array.reference]).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  ///
  /// {@inheritDoc}
  ///
  /// This implementation returns false if the object is not a set, or
  /// if the sets have different sizes.  Otherwise, for each value in this
  /// set, it checks to make sure the value also exists in the other set.
  /// If any value doesn't exist, the method returns false; otherwise, it
  /// returns true.
  bool equals1(jni.JniObject object) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [object.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// This implementation composes a string by iterating over its values. If
  /// this set contains itself as a value, the string "(this Set)"
  /// will appear in its place.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_iterator = jniAccessors.getMethodIDOf(
      _classRef, "iterator", "()Ljava/util/Iterator;");

  /// from: public java.util.Iterator<E> iterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an java.util.Iterator over all values in the set.
  ///
  /// __Note:__ this is a fairly inefficient way to access the array contents, it
  /// requires generating a number of temporary objects and allocates additional state
  /// information associated with the container that will remain for the life of the container.
  ///
  jni.JniObject iterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_iterator, jni.JniType.objectType, []).object);

  static final _id_containsAll = jniAccessors.getMethodIDOf(
      _classRef, "containsAll", "(Ljava/util/Collection;)Z");

  /// from: public boolean containsAll(java.util.Collection<?> collection)
  ///
  /// Determine if the array set contains all of the values in the given collection.
  ///@param collection The collection whose contents are to be checked against.
  ///@return Returns true if this array set contains a value for every entry
  /// in <var>collection</var>, else returns false.
  bool containsAll(jni.JniObject collection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsAll,
      jni.JniType.booleanType,
      [collection.reference]).boolean;

  static final _id_addAll1 = jniAccessors.getMethodIDOf(
      _classRef, "addAll", "(Ljava/util/Collection;)Z");

  /// from: public boolean addAll(java.util.Collection<? extends E> collection)
  ///
  /// Perform an \#add(Object) of all values in <var>collection</var>
  ///@param collection The collection whose contents are to be retrieved.
  bool addAll1(jni.JniObject collection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addAll1,
      jni.JniType.booleanType,
      [collection.reference]).boolean;

  static final _id_removeAll1 = jniAccessors.getMethodIDOf(
      _classRef, "removeAll", "(Ljava/util/Collection;)Z");

  /// from: public boolean removeAll(java.util.Collection<?> collection)
  ///
  /// Remove all values in the array set that exist in the given collection.
  ///@param collection The collection whose contents are to be used to remove values.
  ///@return Returns true if any values were removed from the array set, else false.
  bool removeAll1(jni.JniObject collection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeAll1,
      jni.JniType.booleanType,
      [collection.reference]).boolean;

  static final _id_retainAll = jniAccessors.getMethodIDOf(
      _classRef, "retainAll", "(Ljava/util/Collection;)Z");

  /// from: public boolean retainAll(java.util.Collection<?> collection)
  ///
  /// Remove all values in the array set that do __not__ exist in the given collection.
  ///@param collection The collection whose contents are to be used to determine which
  /// values to keep.
  ///@return Returns true if any values were removed from the array set, else false.
  bool retainAll(jni.JniObject collection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_retainAll,
      jni.JniType.booleanType,
      [collection.reference]).boolean;
}
