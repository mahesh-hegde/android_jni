// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.JsonWriter
///
/// Writes a JSON (<a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>)
/// encoded value to a stream, one token at a time. The stream includes both
/// literal values (strings, numbers, booleans and nulls) as well as the begin
/// and end delimiters of objects and arrays.
///
/// <h3>Encoding JSON</h3>
/// To encode your data as JSON, create a new {@code JsonWriter}. Each JSON
/// document must contain one top-level array or object. Call methods on the
/// writer as you walk the structure's contents, nesting arrays and objects as
/// necessary:
/// <ul>
///   <li>To write <strong>arrays</strong>, first call \#beginArray().
///       Write each of the array's elements with the appropriate \#value
///       methods or by nesting other arrays and objects. Finally close the array
///       using \#endArray().
///   <li>To write <strong>objects</strong>, first call \#beginObject().
///       Write each of the object's properties by alternating calls to
///       \#name with the property's value. Write property values with the
///       appropriate \#value method or by nesting other objects or arrays.
///       Finally close the object using \#endObject().
/// </ul>
///
/// <h3>Example</h3>
/// Suppose we'd like to encode a stream of messages such as the following: <pre> {@code
/// [
///   {
///     "id": 912345678901,
///     "text": "How do I write JSON on Android?",
///     "geo": null,
///     "user": {
///       "name": "android_newb",
///       "followers_count": 41
///      }
///   },
///   {
///     "id": 912345678902,
///     "text": "@android_newb just use android.util.JsonWriter!",
///     "geo": [50.454722, -104.606667],
///     "user": {
///       "name": "jesse",
///       "followers_count": 2
///     }
///   }
/// ]}</pre>
/// This code encodes the above structure: <pre>   {@code
///   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {
///     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
///     writer.setIndent("  ");
///     writeMessagesArray(writer, messages);
///     writer.close();
///   }
///
///   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {
///     writer.beginArray();
///     for (Message message : messages) {
///       writeMessage(writer, message);
///     }
///     writer.endArray();
///   }
///
///   public void writeMessage(JsonWriter writer, Message message) throws IOException {
///     writer.beginObject();
///     writer.name("id").value(message.getId());
///     writer.name("text").value(message.getText());
///     if (message.getGeo() != null) {
///       writer.name("geo");
///       writeDoublesArray(writer, message.getGeo());
///     } else {
///       writer.name("geo").nullValue();
///     }
///     writer.name("user");
///     writeUser(writer, message.getUser());
///     writer.endObject();
///   }
///
///   public void writeUser(JsonWriter writer, User user) throws IOException {
///     writer.beginObject();
///     writer.name("name").value(user.getName());
///     writer.name("followers_count").value(user.getFollowersCount());
///     writer.endObject();
///   }
///
///   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {
///     writer.beginArray();
///     for (Double value : doubles) {
///       writer.value(value);
///     }
///     writer.endArray();
///   }}</pre>
///
/// Each {@code JsonWriter} may be used to write a single JSON stream.
/// Instances of this class are not thread safe. Calls that would result in a
/// malformed JSON string will fail with an IllegalStateException.
class JsonWriter extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/JsonWriter");
  JsonWriter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/io/Writer;)V");

  /// from: public void <init>(java.io.Writer out)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new instance that writes a JSON-encoded stream to {@code out}.
  /// For best performance, ensure Writer is buffered; wrapping in
  /// java.io.BufferedWriter BufferedWriter if necessary.
  JsonWriter(jni.JniObject out)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [out.reference]).object);

  static final _id_setIndent = jniAccessors.getMethodIDOf(
      _classRef, "setIndent", "(Ljava/lang/String;)V");

  /// from: public void setIndent(java.lang.String indent)
  ///
  /// Sets the indentation string to be repeated for each level of indentation
  /// in the encoded document. If {@code indent.isEmpty()} the encoded document
  /// will be compact. Otherwise the encoded document will be more
  /// human-readable.
  ///@param indent a string containing only whitespace.
  void setIndent(jni.JniString indent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIndent,
      jni.JniType.voidType,
      [indent.reference]).check();

  static final _id_setLenient =
      jniAccessors.getMethodIDOf(_classRef, "setLenient", "(Z)V");

  /// from: public void setLenient(boolean lenient)
  ///
  /// Configure this writer to relax its syntax rules. By default, this writer
  /// only emits well-formed JSON as specified by <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the writer
  /// to lenient permits the following:
  /// <ul>
  ///   <li>Top-level values of any type. With strict writing, the top-level
  ///       value must be an object or an array.
  ///   <li>Numbers may be Double\#isNaN() NaNs or Double\#isInfinite() infinities.
  /// </ul>
  void setLenient(bool lenient) => jniAccessors.callMethodWithArgs(
      reference, _id_setLenient, jni.JniType.voidType, [lenient]).check();

  static final _id_isLenient =
      jniAccessors.getMethodIDOf(_classRef, "isLenient", "()Z");

  /// from: public boolean isLenient()
  ///
  /// Returns true if this writer has relaxed syntax rules.
  bool isLenient() => jniAccessors.callMethodWithArgs(
      reference, _id_isLenient, jni.JniType.booleanType, []).boolean;

  static final _id_beginArray = jniAccessors.getMethodIDOf(
      _classRef, "beginArray", "()Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter beginArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Begins encoding a new array. Each call to this method must be paired with
  /// a call to \#endArray.
  ///@return this writer.
  JsonWriter beginArray() => JsonWriter.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_beginArray, jni.JniType.objectType, []).object);

  static final _id_endArray = jniAccessors.getMethodIDOf(
      _classRef, "endArray", "()Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter endArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Ends encoding the current array.
  ///@return this writer.
  JsonWriter endArray() => JsonWriter.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_endArray, jni.JniType.objectType, []).object);

  static final _id_beginObject = jniAccessors.getMethodIDOf(
      _classRef, "beginObject", "()Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter beginObject()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Begins encoding a new object. Each call to this method must be paired
  /// with a call to \#endObject.
  ///@return this writer.
  JsonWriter beginObject() =>
      JsonWriter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_beginObject, jni.JniType.objectType, []).object);

  static final _id_endObject = jniAccessors.getMethodIDOf(
      _classRef, "endObject", "()Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter endObject()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Ends encoding the current object.
  ///@return this writer.
  JsonWriter endObject() => JsonWriter.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_endObject, jni.JniType.objectType, []).object);

  static final _id_name = jniAccessors.getMethodIDOf(
      _classRef, "name", "(Ljava/lang/String;)Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter name(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes the property name.
  ///@param name the name of the forthcoming value. May not be null.
  ///@return this writer.
  JsonWriter name(jni.JniString name) =>
      JsonWriter.fromRef(jniAccessors.callMethodWithArgs(reference, _id_name,
          jni.JniType.objectType, [name.reference]).object);

  static final _id_value = jniAccessors.getMethodIDOf(
      _classRef, "value", "(Ljava/lang/String;)Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter value(java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes {@code value}.
  ///@param value the literal string value, or null to encode a null literal.
  ///@return this writer.
  JsonWriter value(jni.JniString value) =>
      JsonWriter.fromRef(jniAccessors.callMethodWithArgs(reference, _id_value,
          jni.JniType.objectType, [value.reference]).object);

  static final _id_nullValue = jniAccessors.getMethodIDOf(
      _classRef, "nullValue", "()Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter nullValue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes {@code null}.
  ///@return this writer.
  JsonWriter nullValue() => JsonWriter.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_nullValue, jni.JniType.objectType, []).object);

  static final _id_value1 = jniAccessors.getMethodIDOf(
      _classRef, "value", "(Z)Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter value(boolean value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes {@code value}.
  ///@return this writer.
  JsonWriter value1(bool value) =>
      JsonWriter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_value1, jni.JniType.objectType, [value]).object);

  static final _id_value2 = jniAccessors.getMethodIDOf(
      _classRef, "value", "(D)Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter value(double value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes {@code value}.
  ///@param value a finite value. May not be Double\#isNaN() NaNs or
  ///     Double\#isInfinite() infinities unless this writer is lenient.
  ///@return this writer.
  JsonWriter value2(double value) =>
      JsonWriter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_value2, jni.JniType.objectType, [value]).object);

  static final _id_value3 = jniAccessors.getMethodIDOf(
      _classRef, "value", "(J)Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter value(long value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes {@code value}.
  ///@return this writer.
  JsonWriter value3(int value) =>
      JsonWriter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_value3, jni.JniType.objectType, [value]).object);

  static final _id_value4 = jniAccessors.getMethodIDOf(
      _classRef, "value", "(Ljava/lang/Number;)Landroid/util/JsonWriter;");

  /// from: public android.util.JsonWriter value(java.lang.Number value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes {@code value}.
  ///@param value a finite value. May not be Double\#isNaN() NaNs or
  ///     Double\#isInfinite() infinities unless this writer is lenient.
  ///@return this writer.
  JsonWriter value4(jni.JniObject value) =>
      JsonWriter.fromRef(jniAccessors.callMethodWithArgs(reference, _id_value4,
          jni.JniType.objectType, [value.reference]).object);

  static final _id_flush =
      jniAccessors.getMethodIDOf(_classRef, "flush", "()V");

  /// from: public void flush()
  ///
  /// Ensures all buffered data is written to the underlying Writer
  /// and flushes that writer.
  void flush() => jniAccessors.callMethodWithArgs(
      reference, _id_flush, jni.JniType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Flushes and closes this writer and the underlying Writer.
  ///@throws IOException if the JSON document is incomplete.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();
}
