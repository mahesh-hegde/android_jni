// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.LongSparseArray
///
/// SparseArray mapping longs to Objects.  Unlike a normal array of Objects,
/// there can be gaps in the indices.  It is intended to be more memory efficient
/// than using a HashMap to map Longs to Objects, both because it avoids
/// auto-boxing keys and its data structure doesn't rely on an extra entry object
/// for each mapping.
///
/// Note that this container keeps its mappings in an array data structure,
/// using a binary search to find keys.  The implementation is not intended to be appropriate for
/// data structures
/// that may contain large numbers of items.  It is generally slower than a traditional
/// HashMap, since lookups require a binary search and adds and removes require inserting
/// and deleting entries in the array.  For containers holding up to hundreds of items,
/// the performance difference is not significant, less than 50%.
///
///
/// To help with performance, the container includes an optimization when removing
/// keys: instead of compacting its array immediately, it leaves the removed entry marked
/// as deleted.  The entry can then be re-used for the same key, or compacted later in
/// a single garbage collection step of all removed entries.  This garbage collection will
/// need to be performed at any time the array needs to be grown or the the map size or
/// entry values are retrieved.
///
///
/// It is possible to iterate over the items in this container using
/// \#keyAt(int) and \#valueAt(int). Iterating over the keys using
/// <code>keyAt(int)</code> with ascending values of the index will return the
/// keys in ascending order, or the values corresponding to the keys in ascending
/// order in the case of <code>valueAt(int)</code>.
///
class LongSparseArray extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/util/LongSparseArray");
  LongSparseArray.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new LongSparseArray containing no mappings.
  LongSparseArray()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int initialCapacity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new LongSparseArray containing no mappings that will not
  /// require any additional memory allocation to store the specified
  /// number of mappings.  If you supply an initial capacity of 0, the
  /// sparse array will be initialized with a light-weight representation
  /// not requiring any additional array allocations.
  LongSparseArray.ctor1(int initialCapacity)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [initialCapacity]).object);

  static final _id_clone = jniAccessors.getMethodIDOf(
      _classRef, "clone", "()Landroid/util/LongSparseArray;");

  /// from: public android.util.LongSparseArray<E> clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LongSparseArray clone() =>
      LongSparseArray.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_delete1 =
      jniAccessors.getMethodIDOf(_classRef, "delete", "(J)V");

  /// from: public void delete(long key)
  ///
  /// Removes the mapping from the specified key, if there was any.
  void delete1(int key) => jniAccessors.callMethodWithArgs(
      reference, _id_delete1, jni.JniType.voidType, [key]).check();

  static final _id_remove =
      jniAccessors.getMethodIDOf(_classRef, "remove", "(J)V");

  /// from: public void remove(long key)
  ///
  /// Alias for \#delete(long).
  void remove(int key) => jniAccessors.callMethodWithArgs(
      reference, _id_remove, jni.JniType.voidType, [key]).check();

  static final _id_removeAt =
      jniAccessors.getMethodIDOf(_classRef, "removeAt", "(I)V");

  /// from: public void removeAt(int index)
  ///
  /// Removes the mapping at the specified index.
  void removeAt(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_removeAt, jni.JniType.voidType, [index]).check();

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: public int size()
  ///
  /// Returns the number of key-value mappings that this LongSparseArray
  /// currently stores.
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.intType, []).integer;

  static final _id_keyAt =
      jniAccessors.getMethodIDOf(_classRef, "keyAt", "(I)J");

  /// from: public long keyAt(int index)
  ///
  /// Given an index in the range <code>0...size()-1</code>, returns
  /// the key from the <code>index</code>th key-value mapping that this
  /// LongSparseArray stores.
  ///
  /// The keys corresponding to indices in ascending order are guaranteed to
  /// be in ascending order, e.g., <code>keyAt(0)</code> will return the
  /// smallest key and <code>keyAt(size()-1)</code> will return the largest
  /// key.
  ///
  int keyAt(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_keyAt, jni.JniType.longType, [index]).long;

  static final _id_indexOfKey =
      jniAccessors.getMethodIDOf(_classRef, "indexOfKey", "(J)I");

  /// from: public int indexOfKey(long key)
  ///
  /// Returns the index for which \#keyAt would return the
  /// specified key, or a negative number if the specified
  /// key is not mapped.
  int indexOfKey(int key) => jniAccessors.callMethodWithArgs(
      reference, _id_indexOfKey, jni.JniType.intType, [key]).integer;

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Removes all key-value mappings from this LongSparseArray.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// This implementation composes a string by iterating over its mappings. If
  /// this map contains itself as a value, the string "(this Map)"
  /// will appear in its place.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
