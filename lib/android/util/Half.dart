// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.Half
///
/// The {@code Half} class is a wrapper and a utility class to manipulate half-precision 16-bit
/// <a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">IEEE 754</a>
/// floating point data types (also called fp16 or binary16). A half-precision float can be
/// created from or converted to single-precision floats, and is stored in a short data type.
/// To distinguish short values holding half-precision floats from regular short values,
/// it is recommended to use the <code>@HalfFloat</code> annotation.
///
///
/// The IEEE 754 standard specifies an fp16 as having the following format:
///
/// <ul>
/// <li>Sign bit: 1 bit</li>
/// <li>Exponent width: 5 bits</li>
/// <li>Significand: 10 bits</li>
/// </ul>
///
/// The format is laid out as follows:
///
/// <pre>
/// 1   11111   1111111111
/// ^   --^--   -----^----
/// sign  |          |_______ significand
///       |
///       -- exponent
/// </pre>
///
/// Half-precision floating points can be useful to save memory and/or
/// bandwidth at the expense of range and precision when compared to single-precision
/// floating points (fp32).
///
/// To help you decide whether fp16 is the right storage type for you need, please
/// refer to the table below that shows the available precision throughout the range of
/// possible values. The _precision_ column indicates the step size between two
/// consecutive numbers in a specific part of the range.
///
///
/// <table summary="Precision of fp16 across the range">
///     <tr><th>Range start</th><th>Precision</th></tr>
///     <tr><td>0</td><td>1 &frasl; 16,777,216</td></tr>
///     <tr><td>1 &frasl; 16,384</td><td>1 &frasl; 16,777,216</td></tr>
///     <tr><td>1 &frasl; 8,192</td><td>1 &frasl; 8,388,608</td></tr>
///     <tr><td>1 &frasl; 4,096</td><td>1 &frasl; 4,194,304</td></tr>
///     <tr><td>1 &frasl; 2,048</td><td>1 &frasl; 2,097,152</td></tr>
///     <tr><td>1 &frasl; 1,024</td><td>1 &frasl; 1,048,576</td></tr>
///     <tr><td>1 &frasl; 512</td><td>1 &frasl; 524,288</td></tr>
///     <tr><td>1 &frasl; 256</td><td>1 &frasl; 262,144</td></tr>
///     <tr><td>1 &frasl; 128</td><td>1 &frasl; 131,072</td></tr>
///     <tr><td>1 &frasl; 64</td><td>1 &frasl; 65,536</td></tr>
///     <tr><td>1 &frasl; 32</td><td>1 &frasl; 32,768</td></tr>
///     <tr><td>1 &frasl; 16</td><td>1 &frasl; 16,384</td></tr>
///     <tr><td>1 &frasl; 8</td><td>1 &frasl; 8,192</td></tr>
///     <tr><td>1 &frasl; 4</td><td>1 &frasl; 4,096</td></tr>
///     <tr><td>1 &frasl; 2</td><td>1 &frasl; 2,048</td></tr>
///     <tr><td>1</td><td>1 &frasl; 1,024</td></tr>
///     <tr><td>2</td><td>1 &frasl; 512</td></tr>
///     <tr><td>4</td><td>1 &frasl; 256</td></tr>
///     <tr><td>8</td><td>1 &frasl; 128</td></tr>
///     <tr><td>16</td><td>1 &frasl; 64</td></tr>
///     <tr><td>32</td><td>1 &frasl; 32</td></tr>
///     <tr><td>64</td><td>1 &frasl; 16</td></tr>
///     <tr><td>128</td><td>1 &frasl; 8</td></tr>
///     <tr><td>256</td><td>1 &frasl; 4</td></tr>
///     <tr><td>512</td><td>1 &frasl; 2</td></tr>
///     <tr><td>1,024</td><td>1</td></tr>
///     <tr><td>2,048</td><td>2</td></tr>
///     <tr><td>4,096</td><td>4</td></tr>
///     <tr><td>8,192</td><td>8</td></tr>
///     <tr><td>16,384</td><td>16</td></tr>
///     <tr><td>32,768</td><td>32</td></tr>
/// </table>
///
/// This table shows that numbers higher than 1024 lose all fractional precision.
///
class Half extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/Half");
  Half.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final short EPSILON
  ///
  /// Epsilon is the difference between 1.0 and the next value representable
  /// by a half-precision floating-point.
  static const EPSILON = 5120;

  /// from: static public final short LOWEST_VALUE
  ///
  /// Smallest negative value a half-precision float may have.
  static const LOWEST_VALUE = -1025;

  /// from: static public final int MAX_EXPONENT
  ///
  /// Maximum exponent a finite half-precision float may have.
  static const MAX_EXPONENT = 15;

  /// from: static public final short MAX_VALUE
  ///
  /// Maximum positive finite value a half-precision float may have.
  static const MAX_VALUE = 31743;

  /// from: static public final int MIN_EXPONENT
  ///
  /// Minimum exponent a normalized half-precision float may have.
  static const MIN_EXPONENT = -14;

  /// from: static public final short MIN_NORMAL
  ///
  /// Smallest positive normal value a half-precision float may have.
  static const MIN_NORMAL = 1024;

  /// from: static public final short MIN_VALUE
  ///
  /// Smallest positive non-zero value a half-precision float may have.
  static const MIN_VALUE = 1;

  /// from: static public final short NEGATIVE_INFINITY
  ///
  /// Negative infinity of type half-precision float.
  static const NEGATIVE_INFINITY = -1024;

  /// from: static public final short NEGATIVE_ZERO
  ///
  /// Negative 0 of type half-precision float.
  static const NEGATIVE_ZERO = -32768;

  /// from: static public final short NaN
  ///
  /// A Not-a-Number representation of a half-precision float.
  static const NaN = 32256;

  /// from: static public final short POSITIVE_INFINITY
  ///
  /// Positive infinity of type half-precision float.
  static const POSITIVE_INFINITY = 31744;

  /// from: static public final short POSITIVE_ZERO
  ///
  /// Positive 0 of type half-precision float.
  static const POSITIVE_ZERO = 0;

  /// from: static public final int SIZE
  ///
  /// The number of bits used to represent a half-precision float value.
  static const SIZE = 16;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(S)V");

  /// from: public void <init>(short value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a newly allocated {@code Half} object that represents the
  /// half-precision float type argument.
  ///@param value The value to be represented by the {@code Half}
  Half(int value)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [value]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(F)V");

  /// from: public void <init>(float value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a newly allocated {@code Half} object that represents the
  /// argument converted to a half-precision float.
  ///@param value The value to be represented by the {@code Half}
  ///@see \#toHalf(float)
  Half.ctor1(double value)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [value]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(D)V");

  /// from: public void <init>(double value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a newly allocated {@code Half} object that
  /// represents the argument converted to a half-precision float.
  ///@param value The value to be represented by the {@code Half}
  ///@see \#toHalf(float)
  Half.ctor2(double value)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [value]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a newly allocated {@code Half} object that represents the
  /// half-precision float value represented by the string.
  /// The string is converted to a half-precision float value as if by the
  /// \#valueOf(String) method.
  ///
  ///
  /// Calling this constructor is equivalent to calling:
  ///
  /// <pre>
  ///     new Half(Float.parseFloat(value))
  /// </pre>
  ///@param value A string to be converted to a {@code Half}
  /// This value must never be {@code null}.
  ///@throws NumberFormatException if the string does not contain a parsable number
  ///@see Float\#valueOf(java.lang.String)
  ///@see \#toHalf(float)
  Half.ctor3(jni.JniString value)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [value.reference]).object);

  static final _id_halfValue =
      jniAccessors.getMethodIDOf(_classRef, "halfValue", "()S");

  /// from: public short halfValue()
  ///
  /// Returns the half-precision value of this {@code Half} as a {@code short}
  /// containing the bit representation described in Half.
  ///@return The half-precision float value represented by this object
  int halfValue() => jniAccessors.callMethodWithArgs(
      reference, _id_halfValue, jni.JniType.shortType, []).short;

  static final _id_byteValue =
      jniAccessors.getMethodIDOf(_classRef, "byteValue", "()B");

  /// from: public byte byteValue()
  ///
  /// Returns the value of this {@code Half} as a {@code byte} after
  /// a narrowing primitive conversion.
  ///@return The half-precision float value represented by this object
  ///         converted to type {@code byte}
  int byteValue() => jniAccessors.callMethodWithArgs(
      reference, _id_byteValue, jni.JniType.byteType, []).byte;

  static final _id_shortValue =
      jniAccessors.getMethodIDOf(_classRef, "shortValue", "()S");

  /// from: public short shortValue()
  ///
  /// Returns the value of this {@code Half} as a {@code short} after
  /// a narrowing primitive conversion.
  ///@return The half-precision float value represented by this object
  ///         converted to type {@code short}
  int shortValue() => jniAccessors.callMethodWithArgs(
      reference, _id_shortValue, jni.JniType.shortType, []).short;

  static final _id_intValue =
      jniAccessors.getMethodIDOf(_classRef, "intValue", "()I");

  /// from: public int intValue()
  ///
  /// Returns the value of this {@code Half} as a {@code int} after
  /// a narrowing primitive conversion.
  ///@return The half-precision float value represented by this object
  ///         converted to type {@code int}
  int intValue() => jniAccessors.callMethodWithArgs(
      reference, _id_intValue, jni.JniType.intType, []).integer;

  static final _id_longValue =
      jniAccessors.getMethodIDOf(_classRef, "longValue", "()J");

  /// from: public long longValue()
  ///
  /// Returns the value of this {@code Half} as a {@code long} after
  /// a narrowing primitive conversion.
  ///@return The half-precision float value represented by this object
  ///         converted to type {@code long}
  int longValue() => jniAccessors.callMethodWithArgs(
      reference, _id_longValue, jni.JniType.longType, []).long;

  static final _id_floatValue =
      jniAccessors.getMethodIDOf(_classRef, "floatValue", "()F");

  /// from: public float floatValue()
  ///
  /// Returns the value of this {@code Half} as a {@code float} after
  /// a widening primitive conversion.
  ///@return The half-precision float value represented by this object
  ///         converted to type {@code float}
  double floatValue() => jniAccessors.callMethodWithArgs(
      reference, _id_floatValue, jni.JniType.floatType, []).float;

  static final _id_doubleValue =
      jniAccessors.getMethodIDOf(_classRef, "doubleValue", "()D");

  /// from: public double doubleValue()
  ///
  /// Returns the value of this {@code Half} as a {@code double} after
  /// a widening primitive conversion.
  ///@return The half-precision float value represented by this object
  ///         converted to type {@code double}
  double doubleValue() => jniAccessors.callMethodWithArgs(
      reference, _id_doubleValue, jni.JniType.doubleType, []).doubleFloat;

  static final _id_isNaN =
      jniAccessors.getMethodIDOf(_classRef, "isNaN", "()Z");

  /// from: public boolean isNaN()
  ///
  /// Returns true if this {@code Half} value represents a Not-a-Number,
  /// false otherwise.
  ///@return True if the value is a NaN, false otherwise
  bool isNaN() => jniAccessors.callMethodWithArgs(
      reference, _id_isNaN, jni.JniType.booleanType, []).boolean;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  ///
  /// Compares this object against the specified object. The result is {@code true}
  /// if and only if the argument is not {@code null} and is a {@code Half} object
  /// that represents the same half-precision value as the this object. Two
  /// half-precision values are considered to be the same if and only if the method
  /// \#halfToIntBits(short) returns an identical {@code int} value for both.
  ///@param o The object to compare
  /// This value may be {@code null}.
  ///@return True if the objects are the same, false otherwise
  ///@see \#halfToIntBits(short)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// Returns a hash code for this {@code Half} object. The result is the
  /// integer bit representation, exactly as produced by the method
  /// \#halfToIntBits(short), of the primitive half-precision float
  /// value represented by this {@code Half} object.
  ///@return A hash code value for this object
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string representation of the specified half-precision
  /// float value. See \#toString(short) for more information.
  ///@return A string representation of this {@code Half} object
  ///
  /// This value will never be {@code null}.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_compareTo = jniAccessors.getMethodIDOf(
      _classRef, "compareTo", "(Landroid/util/Half;)I");

  /// from: public int compareTo(android.util.Half h)
  ///
  /// Compares the two specified half-precision float values. The following
  /// conditions apply during the comparison:
  ///
  ///
  /// <ul>
  /// <li>\#NaN is considered by this method to be equal to itself and greater
  /// than all other half-precision float values (including {@code \#POSITIVE_INFINITY})</li>
  /// <li>\#POSITIVE_ZERO is considered by this method to be greater than
  /// \#NEGATIVE_ZERO.</li>
  /// </ul>
  ///@param h The half-precision float value to compare to the half-precision value
  ///          represented by this {@code Half} object
  ///
  /// This value must never be {@code null}.
  ///@return The value {@code 0} if {@code x} is numerically equal to {@code y}; a
  ///          value less than {@code 0} if {@code x} is numerically less than {@code y};
  ///          and a value greater than {@code 0} if {@code x} is numerically greater
  ///          than {@code y}
  int compareTo(Half h) => jniAccessors.callMethodWithArgs(
      reference, _id_compareTo, jni.JniType.intType, [h.reference]).integer;

  static final _id_hashCode2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "hashCode", "(S)I");

  /// from: static public int hashCode(short h)
  ///
  /// Returns a hash code for a half-precision float value.
  ///@param h The value to hash
  ///@return A hash code value for a half-precision float value
  static int hashCode2(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_hashCode2, jni.JniType.intType, [h]).integer;

  static final _id_compare =
      jniAccessors.getStaticMethodIDOf(_classRef, "compare", "(SS)I");

  /// from: static public int compare(short x, short y)
  ///
  /// Compares the two specified half-precision float values. The following
  /// conditions apply during the comparison:
  ///
  ///
  /// <ul>
  /// <li>\#NaN is considered by this method to be equal to itself and greater
  /// than all other half-precision float values (including {@code \#POSITIVE_INFINITY})</li>
  /// <li>\#POSITIVE_ZERO is considered by this method to be greater than
  /// \#NEGATIVE_ZERO.</li>
  /// </ul>
  ///@param x The first half-precision float value to compare.
  ///@param y The second half-precision float value to compare
  ///@return The value {@code 0} if {@code x} is numerically equal to {@code y}, a
  ///          value less than {@code 0} if {@code x} is numerically less than {@code y},
  ///          and a value greater than {@code 0} if {@code x} is numerically greater
  ///          than {@code y}
  static int compare(int x, int y) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_compare, jni.JniType.intType, [x, y]).integer;

  static final _id_halfToShortBits =
      jniAccessors.getStaticMethodIDOf(_classRef, "halfToShortBits", "(S)S");

  /// from: static public short halfToShortBits(short h)
  ///
  /// Returns a representation of the specified half-precision float value
  /// according to the bit layout described in Half.
  ///
  ///
  /// Similar to \#halfToIntBits(short), this method collapses all
  /// possible Not-a-Number values to a single canonical Not-a-Number value
  /// defined by \#NaN.
  ///
  ///@param h A half-precision float value
  ///@return The bits that represent the half-precision float value
  ///@see \#halfToIntBits(short)
  static int halfToShortBits(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_halfToShortBits, jni.JniType.shortType, [h]).short;

  static final _id_halfToIntBits =
      jniAccessors.getStaticMethodIDOf(_classRef, "halfToIntBits", "(S)I");

  /// from: static public int halfToIntBits(short h)
  ///
  /// Returns a representation of the specified half-precision float value
  /// according to the bit layout described in Half.
  ///
  ///
  /// Unlike \#halfToRawIntBits(short), this method collapses all
  /// possible Not-a-Number values to a single canonical Not-a-Number value
  /// defined by \#NaN.
  ///
  ///@param h A half-precision float value
  ///@return The bits that represent the half-precision float value
  ///@see \#halfToRawIntBits(short)
  ///@see \#halfToShortBits(short)
  ///@see \#intBitsToHalf(int)
  static int halfToIntBits(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_halfToIntBits, jni.JniType.intType, [h]).integer;

  static final _id_halfToRawIntBits =
      jniAccessors.getStaticMethodIDOf(_classRef, "halfToRawIntBits", "(S)I");

  /// from: static public int halfToRawIntBits(short h)
  ///
  /// Returns a representation of the specified half-precision float value
  /// according to the bit layout described in Half.
  ///
  ///
  /// The argument is considered to be a representation of a half-precision
  /// float value according to the bit layout described in Half. The 16
  /// most significant bits of the returned value are set to 0.
  ///
  ///@param h A half-precision float value
  ///@return The bits that represent the half-precision float value
  ///@see \#halfToIntBits(short)
  ///@see \#intBitsToHalf(int)
  static int halfToRawIntBits(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_halfToRawIntBits, jni.JniType.intType, [h]).integer;

  static final _id_intBitsToHalf =
      jniAccessors.getStaticMethodIDOf(_classRef, "intBitsToHalf", "(I)S");

  /// from: static public short intBitsToHalf(int bits)
  ///
  /// Returns the half-precision float value corresponding to a given
  /// bit representation.
  ///
  ///
  /// The argument is considered to be a representation of a half-precision
  /// float value according to the bit layout described in Half. The 16
  /// most significant bits of the argument are ignored.
  ///
  ///@param bits An integer
  ///@return The half-precision float value with the same bit pattern
  static int intBitsToHalf(int bits) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_intBitsToHalf, jni.JniType.shortType, [bits]).short;

  static final _id_copySign =
      jniAccessors.getStaticMethodIDOf(_classRef, "copySign", "(SS)S");

  /// from: static public short copySign(short magnitude, short sign)
  ///
  /// Returns the first parameter with the sign of the second parameter.
  /// This method treats NaNs as having a sign.
  ///@param magnitude A half-precision float value providing the magnitude of the result
  ///@param sign A half-precision float value providing the sign of the result
  ///@return A value with the magnitude of the first parameter and the sign
  ///         of the second parameter
  static int copySign(int magnitude, int sign) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_copySign,
          jni.JniType.shortType, [magnitude, sign]).short;

  static final _id_abs =
      jniAccessors.getStaticMethodIDOf(_classRef, "abs", "(S)S");

  /// from: static public short abs(short h)
  ///
  /// Returns the absolute value of the specified half-precision float.
  /// Special values are handled in the following ways:
  /// <ul>
  /// <li>If the specified half-precision float is NaN, the result is NaN</li>
  /// <li>If the specified half-precision float is zero (negative or positive),
  /// the result is positive zero (see \#POSITIVE_ZERO)</li>
  /// <li>If the specified half-precision float is infinity (negative or positive),
  /// the result is positive infinity (see \#POSITIVE_INFINITY)</li>
  /// </ul>
  ///@param h A half-precision float value
  ///@return The absolute value of the specified half-precision float
  static int abs(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_abs, jni.JniType.shortType, [h]).short;

  static final _id_round =
      jniAccessors.getStaticMethodIDOf(_classRef, "round", "(S)S");

  /// from: static public short round(short h)
  ///
  /// Returns the closest integral half-precision float value to the specified
  /// half-precision float value. Special values are handled in the
  /// following ways:
  /// <ul>
  /// <li>If the specified half-precision float is NaN, the result is NaN</li>
  /// <li>If the specified half-precision float is infinity (negative or positive),
  /// the result is infinity (with the same sign)</li>
  /// <li>If the specified half-precision float is zero (negative or positive),
  /// the result is zero (with the same sign)</li>
  /// </ul>
  ///@param h A half-precision float value
  ///@return The value of the specified half-precision float rounded to the nearest
  ///         half-precision float value
  static int round(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_round, jni.JniType.shortType, [h]).short;

  static final _id_ceil =
      jniAccessors.getStaticMethodIDOf(_classRef, "ceil", "(S)S");

  /// from: static public short ceil(short h)
  ///
  /// Returns the smallest half-precision float value toward negative infinity
  /// greater than or equal to the specified half-precision float value.
  /// Special values are handled in the following ways:
  /// <ul>
  /// <li>If the specified half-precision float is NaN, the result is NaN</li>
  /// <li>If the specified half-precision float is infinity (negative or positive),
  /// the result is infinity (with the same sign)</li>
  /// <li>If the specified half-precision float is zero (negative or positive),
  /// the result is zero (with the same sign)</li>
  /// </ul>
  ///@param h A half-precision float value
  ///@return The smallest half-precision float value toward negative infinity
  ///         greater than or equal to the specified half-precision float value
  static int ceil(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_ceil, jni.JniType.shortType, [h]).short;

  static final _id_floor =
      jniAccessors.getStaticMethodIDOf(_classRef, "floor", "(S)S");

  /// from: static public short floor(short h)
  ///
  /// Returns the largest half-precision float value toward positive infinity
  /// less than or equal to the specified half-precision float value.
  /// Special values are handled in the following ways:
  /// <ul>
  /// <li>If the specified half-precision float is NaN, the result is NaN</li>
  /// <li>If the specified half-precision float is infinity (negative or positive),
  /// the result is infinity (with the same sign)</li>
  /// <li>If the specified half-precision float is zero (negative or positive),
  /// the result is zero (with the same sign)</li>
  /// </ul>
  ///@param h A half-precision float value
  ///@return The largest half-precision float value toward positive infinity
  ///         less than or equal to the specified half-precision float value
  static int floor(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_floor, jni.JniType.shortType, [h]).short;

  static final _id_trunc =
      jniAccessors.getStaticMethodIDOf(_classRef, "trunc", "(S)S");

  /// from: static public short trunc(short h)
  ///
  /// Returns the truncated half-precision float value of the specified
  /// half-precision float value. Special values are handled in the following ways:
  /// <ul>
  /// <li>If the specified half-precision float is NaN, the result is NaN</li>
  /// <li>If the specified half-precision float is infinity (negative or positive),
  /// the result is infinity (with the same sign)</li>
  /// <li>If the specified half-precision float is zero (negative or positive),
  /// the result is zero (with the same sign)</li>
  /// </ul>
  ///@param h A half-precision float value
  ///@return The truncated half-precision float value of the specified
  ///         half-precision float value
  static int trunc(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_trunc, jni.JniType.shortType, [h]).short;

  static final _id_min =
      jniAccessors.getStaticMethodIDOf(_classRef, "min", "(SS)S");

  /// from: static public short min(short x, short y)
  ///
  /// Returns the smaller of two half-precision float values (the value closest
  /// to negative infinity). Special values are handled in the following ways:
  /// <ul>
  /// <li>If either value is NaN, the result is NaN</li>
  /// <li>\#NEGATIVE_ZERO is smaller than \#POSITIVE_ZERO</li>
  /// </ul>
  ///@param x The first half-precision value
  ///@param y The second half-precision value
  ///@return The smaller of the two specified half-precision values
  static int min(int x, int y) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_min, jni.JniType.shortType, [x, y]).short;

  static final _id_max =
      jniAccessors.getStaticMethodIDOf(_classRef, "max", "(SS)S");

  /// from: static public short max(short x, short y)
  ///
  /// Returns the larger of two half-precision float values (the value closest
  /// to positive infinity). Special values are handled in the following ways:
  /// <ul>
  /// <li>If either value is NaN, the result is NaN</li>
  /// <li>\#POSITIVE_ZERO is greater than \#NEGATIVE_ZERO</li>
  /// </ul>
  ///@param x The first half-precision value
  ///@param y The second half-precision value
  ///@return The larger of the two specified half-precision values
  static int max(int x, int y) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_max, jni.JniType.shortType, [x, y]).short;

  static final _id_less =
      jniAccessors.getStaticMethodIDOf(_classRef, "less", "(SS)Z");

  /// from: static public boolean less(short x, short y)
  ///
  /// Returns true if the first half-precision float value is less (smaller
  /// toward negative infinity) than the second half-precision float value.
  /// If either of the values is NaN, the result is false.
  ///@param x The first half-precision value
  ///@param y The second half-precision value
  ///@return True if x is less than y, false otherwise
  static bool less(int x, int y) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_less, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_lessEquals =
      jniAccessors.getStaticMethodIDOf(_classRef, "lessEquals", "(SS)Z");

  /// from: static public boolean lessEquals(short x, short y)
  ///
  /// Returns true if the first half-precision float value is less (smaller
  /// toward negative infinity) than or equal to the second half-precision
  /// float value. If either of the values is NaN, the result is false.
  ///@param x The first half-precision value
  ///@param y The second half-precision value
  ///@return True if x is less than or equal to y, false otherwise
  static bool lessEquals(int x, int y) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_lessEquals, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_greater =
      jniAccessors.getStaticMethodIDOf(_classRef, "greater", "(SS)Z");

  /// from: static public boolean greater(short x, short y)
  ///
  /// Returns true if the first half-precision float value is greater (larger
  /// toward positive infinity) than the second half-precision float value.
  /// If either of the values is NaN, the result is false.
  ///@param x The first half-precision value
  ///@param y The second half-precision value
  ///@return True if x is greater than y, false otherwise
  static bool greater(int x, int y) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_greater, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_greaterEquals =
      jniAccessors.getStaticMethodIDOf(_classRef, "greaterEquals", "(SS)Z");

  /// from: static public boolean greaterEquals(short x, short y)
  ///
  /// Returns true if the first half-precision float value is greater (larger
  /// toward positive infinity) than or equal to the second half-precision float
  /// value. If either of the values is NaN, the result is false.
  ///@param x The first half-precision value
  ///@param y The second half-precision value
  ///@return True if x is greater than y, false otherwise
  static bool greaterEquals(int x, int y) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_greaterEquals,
          jni.JniType.booleanType, [x, y]).boolean;

  static final _id_equals2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "equals", "(SS)Z");

  /// from: static public boolean equals(short x, short y)
  ///
  /// Returns true if the two half-precision float values are equal.
  /// If either of the values is NaN, the result is false. \#POSITIVE_ZERO
  /// and \#NEGATIVE_ZERO are considered equal.
  ///@param x The first half-precision value
  ///@param y The second half-precision value
  ///@return True if x is equal to y, false otherwise
  static bool equals2(int x, int y) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_equals2, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_getSign =
      jniAccessors.getStaticMethodIDOf(_classRef, "getSign", "(S)I");

  /// from: static public int getSign(short h)
  ///
  /// Returns the sign of the specified half-precision float.
  ///@param h A half-precision float value
  ///@return 1 if the value is positive, -1 if the value is negative
  static int getSign(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getSign, jni.JniType.intType, [h]).integer;

  static final _id_getExponent =
      jniAccessors.getStaticMethodIDOf(_classRef, "getExponent", "(S)I");

  /// from: static public int getExponent(short h)
  ///
  /// Returns the unbiased exponent used in the representation of
  /// the specified  half-precision float value. if the value is NaN
  /// or infinite, this* method returns \#MAX_EXPONENT + 1.
  /// If the argument is 0 or a subnormal representation, this method
  /// returns \#MIN_EXPONENT - 1.
  ///@param h A half-precision float value
  ///@return The unbiased exponent of the specified value
  static int getExponent(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getExponent, jni.JniType.intType, [h]).integer;

  static final _id_getSignificand =
      jniAccessors.getStaticMethodIDOf(_classRef, "getSignificand", "(S)I");

  /// from: static public int getSignificand(short h)
  ///
  /// Returns the significand, or mantissa, used in the representation
  /// of the specified half-precision float value.
  ///@param h A half-precision float value
  ///@return The significand, or significand, of the specified vlaue
  static int getSignificand(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getSignificand, jni.JniType.intType, [h]).integer;

  static final _id_isInfinite =
      jniAccessors.getStaticMethodIDOf(_classRef, "isInfinite", "(S)Z");

  /// from: static public boolean isInfinite(short h)
  ///
  /// Returns true if the specified half-precision float value represents
  /// infinity, false otherwise.
  ///@param h A half-precision float value
  ///@return True if the value is positive infinity or negative infinity,
  ///         false otherwise
  static bool isInfinite(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isInfinite, jni.JniType.booleanType, [h]).boolean;

  static final _id_isNaN1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "isNaN", "(S)Z");

  /// from: static public boolean isNaN(short h)
  ///
  /// Returns true if the specified half-precision float value represents
  /// a Not-a-Number, false otherwise.
  ///@param h A half-precision float value
  ///@return True if the value is a NaN, false otherwise
  static bool isNaN1(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isNaN1, jni.JniType.booleanType, [h]).boolean;

  static final _id_isNormalized =
      jniAccessors.getStaticMethodIDOf(_classRef, "isNormalized", "(S)Z");

  /// from: static public boolean isNormalized(short h)
  ///
  /// Returns true if the specified half-precision float value is normalized
  /// (does not have a subnormal representation). If the specified value is
  /// \#POSITIVE_INFINITY, \#NEGATIVE_INFINITY,
  /// \#POSITIVE_ZERO, \#NEGATIVE_ZERO, NaN or any subnormal
  /// number, this method returns false.
  ///@param h A half-precision float value
  ///@return True if the value is normalized, false otherwise
  static bool isNormalized(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isNormalized, jni.JniType.booleanType, [h]).boolean;

  static final _id_toFloat =
      jniAccessors.getStaticMethodIDOf(_classRef, "toFloat", "(S)F");

  /// from: static public float toFloat(short h)
  ///
  /// Converts the specified half-precision float value into a
  /// single-precision float value. The following special cases are handled:
  ///
  /// <ul>
  /// <li>If the input is \#NaN, the returned value is Float\#NaN</li>
  /// <li>If the input is \#POSITIVE_INFINITY or
  /// \#NEGATIVE_INFINITY, the returned value is respectively
  /// Float\#POSITIVE_INFINITY or Float\#NEGATIVE_INFINITY</li>
  /// <li>If the input is 0 (positive or negative), the returned value is +/-0.0f</li>
  /// <li>Otherwise, the returned value is a normalized single-precision float value</li>
  /// </ul>
  ///@param h The half-precision float value to convert to single-precision
  ///@return A normalized single-precision float value
  static double toFloat(int h) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_toFloat, jni.JniType.floatType, [h]).float;

  static final _id_toHalf =
      jniAccessors.getStaticMethodIDOf(_classRef, "toHalf", "(F)S");

  /// from: static public short toHalf(float f)
  ///
  /// Converts the specified single-precision float value into a
  /// half-precision float value. The following special cases are handled:
  ///
  /// <ul>
  /// <li>If the input is NaN (see Float\#isNaN(float)), the returned
  /// value is \#NaN</li>
  /// <li>If the input is Float\#POSITIVE_INFINITY or
  /// Float\#NEGATIVE_INFINITY, the returned value is respectively
  /// \#POSITIVE_INFINITY or \#NEGATIVE_INFINITY</li>
  /// <li>If the input is 0 (positive or negative), the returned value is
  /// \#POSITIVE_ZERO or \#NEGATIVE_ZERO</li>
  /// <li>If the input is a less than \#MIN_VALUE, the returned value
  /// is flushed to \#POSITIVE_ZERO or \#NEGATIVE_ZERO</li>
  /// <li>If the input is a less than \#MIN_NORMAL, the returned value
  /// is a denorm half-precision float</li>
  /// <li>Otherwise, the returned value is rounded to the nearest
  /// representable half-precision float value</li>
  /// </ul>
  ///@param f The single-precision float value to convert to half-precision
  ///@return A half-precision float value
  static int toHalf(double f) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_toHalf, jni.JniType.shortType, [f]).short;

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(S)Landroid/util/Half;");

  /// from: static public android.util.Half valueOf(short h)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a {@code Half} instance representing the specified
  /// half-precision float value.
  ///@param h A half-precision float value
  ///@return a {@code Half} instance representing {@code h}
  ///
  /// This value will never be {@code null}.
  static Half valueOf(int h) =>
      Half.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_valueOf, jni.JniType.objectType, [h]).object);

  static final _id_valueOf1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(F)Landroid/util/Half;");

  /// from: static public android.util.Half valueOf(float f)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a {@code Half} instance representing the specified float value.
  ///@param f A float value
  ///@return a {@code Half} instance representing {@code f}
  ///
  /// This value will never be {@code null}.
  static Half valueOf1(double f) =>
      Half.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_valueOf1, jni.JniType.objectType, [f]).object);

  static final _id_valueOf2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(Ljava/lang/String;)Landroid/util/Half;");

  /// from: static public android.util.Half valueOf(java.lang.String s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a {@code Half} instance representing the specified string value.
  /// Calling this method is equivalent to calling
  /// <code>toHalf(Float.parseString(h))</code>. See Float\#valueOf(String)
  /// for more information on the format of the string representation.
  ///@param s The string to be parsed
  /// This value must never be {@code null}.
  ///@return a {@code Half} instance representing {@code h}
  /// This value will never be {@code null}.
  ///@throws NumberFormatException if the string does not contain a parsable
  ///         half-precision float value
  static Half valueOf2(jni.JniString s) =>
      Half.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf2, jni.JniType.objectType, [s.reference]).object);

  static final _id_parseHalf = jniAccessors.getStaticMethodIDOf(
      _classRef, "parseHalf", "(Ljava/lang/String;)S");

  /// from: static public short parseHalf(java.lang.String s)
  ///
  /// Returns the half-precision float value represented by the specified string.
  /// Calling this method is equivalent to calling
  /// <code>toHalf(Float.parseString(h))</code>. See Float\#valueOf(String)
  /// for more information on the format of the string representation.
  ///@param s The string to be parsed
  /// This value must never be {@code null}.
  ///@return A half-precision float value represented by the string
  ///@throws NumberFormatException if the string does not contain a parsable
  ///         half-precision float value
  static int parseHalf(jni.JniString s) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_parseHalf, jni.JniType.shortType, [s.reference]).short;

  static final _id_toString2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "toString", "(S)Ljava/lang/String;");

  /// from: static public java.lang.String toString(short h)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string representation of the specified half-precision
  /// float value. Calling this method is equivalent to calling
  /// <code>Float.toString(toFloat(h))</code>. See Float\#toString(float)
  /// for more information on the format of the string representation.
  ///@param h A half-precision float value
  ///@return A string representation of the specified value
  ///
  /// This value will never be {@code null}.
  static jni.JniString toString2(int h) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_toString2, jni.JniType.objectType, [h]).object);

  static final _id_toHexString = jniAccessors.getStaticMethodIDOf(
      _classRef, "toHexString", "(S)Ljava/lang/String;");

  /// from: static public java.lang.String toHexString(short h)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a hexadecimal string representation of the specified half-precision
  /// float value. If the value is a NaN, the result is <code>"NaN"</code>,
  /// otherwise the result follows this format:
  ///
  /// <ul>
  /// <li>If the sign is positive, no sign character appears in the result</li>
  /// <li>If the sign is negative, the first character is <code>'-'</code></li>
  /// <li>If the value is inifinity, the string is <code>"Infinity"</code></li>
  /// <li>If the value is 0, the string is <code>"0x0.0p0"</code></li>
  /// <li>If the value has a normalized representation, the exponent and
  /// significand are represented in the string in two fields. The significand
  /// starts with <code>"0x1."</code> followed by its lowercase hexadecimal
  /// representation. Trailing zeroes are removed unless all digits are 0, then
  /// a single zero is used. The significand representation is followed by the
  /// exponent, represented by <code>"p"</code>, itself followed by a decimal
  /// string of the unbiased exponent</li>
  /// <li>If the value has a subnormal representation, the significand starts
  /// with <code>"0x0."</code> followed by its lowercase hexadecimal
  /// representation. Trailing zeroes are removed unless all digits are 0, then
  /// a single zero is used. The significand representation is followed by the
  /// exponent, represented by <code>"p-14"</code></li>
  /// </ul>
  ///@param h A half-precision float value
  ///@return A hexadecimal string representation of the specified value
  ///
  /// This value will never be {@code null}.
  static jni.JniString toHexString(int h) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_toHexString, jni.JniType.objectType, [h]).object);
}
