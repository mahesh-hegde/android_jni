// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.ArrayMap
///
/// ArrayMap is a generic key->value mapping data structure that is
/// designed to be more memory efficient than a traditional java.util.HashMap.
/// It keeps its mappings in an array data structure -- an integer array of hash
/// codes for each item, and an Object array of the key/value pairs.  This allows it to
/// avoid having to create an extra object for every entry put in to the map, and it
/// also tries to control the growth of the size of these arrays more aggressively
/// (since growing them only requires copying the entries in the array, not rebuilding
/// a hash map).
///
/// Note that this implementation is not intended to be appropriate for data structures
/// that may contain large numbers of items.  It is generally slower than a traditional
/// HashMap, since lookups require a binary search and adds and removes require inserting
/// and deleting entries in the array.  For containers holding up to hundreds of items,
/// the performance difference is not significant, less than 50%.
///
///
/// Because this container is intended to better balance memory use, unlike most other
/// standard Java containers it will shrink its array as items are removed from it.  Currently
/// you have no control over this shrinking -- if you set a capacity and then remove an
/// item, it may reduce the capacity to better match the current size.  In the future an
/// explicit call to set the capacity should turn off this aggressive shrinking behavior.
///
class ArrayMap extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/ArrayMap");
  ArrayMap.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new empty ArrayMap.  The default capacity of an array map is 0, and
  /// will grow once items are added to it.
  ArrayMap()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int capacity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ArrayMap with a given initial capacity.
  ArrayMap.ctor1(int capacity)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [capacity]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/util/ArrayMap;)V");

  /// from: public void <init>(android.util.ArrayMap<K,V> map)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ArrayMap with the mappings from the given ArrayMap.
  ArrayMap.ctor2(ArrayMap map)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [map.reference]).object);

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Make the array map empty.  All storage is released.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_ensureCapacity =
      jniAccessors.getMethodIDOf(_classRef, "ensureCapacity", "(I)V");

  /// from: public void ensureCapacity(int minimumCapacity)
  ///
  /// Ensure the array map can hold at least <var>minimumCapacity</var>
  /// items.
  void ensureCapacity(int minimumCapacity) => jniAccessors.callMethodWithArgs(
      reference,
      _id_ensureCapacity,
      jni.JniType.voidType,
      [minimumCapacity]).check();

  static final _id_containsKey = jniAccessors.getMethodIDOf(
      _classRef, "containsKey", "(Ljava/lang/Object;)Z");

  /// from: public boolean containsKey(java.lang.Object key)
  ///
  /// Check whether a key exists in the array.
  ///@param key The key to search for.
  ///@return Returns true if the key exists, else false.
  bool containsKey(jni.JniObject key) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsKey,
      jni.JniType.booleanType,
      [key.reference]).boolean;

  static final _id_indexOfKey = jniAccessors.getMethodIDOf(
      _classRef, "indexOfKey", "(Ljava/lang/Object;)I");

  /// from: public int indexOfKey(java.lang.Object key)
  ///
  /// Returns the index of a key in the set.
  ///@param key The key to search for.
  ///@return Returns the index of the key if it exists, else a negative integer.
  int indexOfKey(jni.JniObject key) => jniAccessors.callMethodWithArgs(
      reference, _id_indexOfKey, jni.JniType.intType, [key.reference]).integer;

  static final _id_containsValue = jniAccessors.getMethodIDOf(
      _classRef, "containsValue", "(Ljava/lang/Object;)Z");

  /// from: public boolean containsValue(java.lang.Object value)
  ///
  /// Check whether a value exists in the array.  This requires a linear search
  /// through the entire array.
  ///@param value The value to search for.
  ///@return Returns true if the value exists, else false.
  bool containsValue(jni.JniObject value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsValue,
      jni.JniType.booleanType,
      [value.reference]).boolean;

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public boolean isEmpty()
  ///
  /// Return true if the array map contains no items.
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniType.booleanType, []).boolean;

  static final _id_putAll = jniAccessors.getMethodIDOf(
      _classRef, "putAll", "(Landroid/util/ArrayMap;)V");

  /// from: public void putAll(android.util.ArrayMap<? extends K,? extends V> array)
  ///
  /// Perform a \#put(Object, Object) of all key/value pairs in <var>array</var>
  ///@param array The array whose contents are to be retrieved.
  void putAll(ArrayMap array) => jniAccessors.callMethodWithArgs(
      reference, _id_putAll, jni.JniType.voidType, [array.reference]).check();

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: public int size()
  ///
  /// Return the number of items in this array map.
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  ///
  /// {@inheritDoc}
  ///
  /// This implementation returns false if the object is not a map, or
  /// if the maps have different sizes. Otherwise, for each key in this map,
  /// values of both maps are compared. If the values for any key are not
  /// equal, the method returns false, otherwise it returns true.
  bool equals1(jni.JniObject object) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [object.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// This implementation composes a string by iterating over its mappings. If
  /// this map contains itself as a key or a value, the string "(this Map)"
  /// will appear in its place.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_containsAll = jniAccessors.getMethodIDOf(
      _classRef, "containsAll", "(Ljava/util/Collection;)Z");

  /// from: public boolean containsAll(java.util.Collection<?> collection)
  ///
  /// Determine if the array map contains all of the keys in the given collection.
  ///@param collection The collection whose contents are to be checked against.
  ///@return Returns true if this array map contains a key for every entry
  /// in <var>collection</var>, else returns false.
  bool containsAll(jni.JniObject collection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsAll,
      jni.JniType.booleanType,
      [collection.reference]).boolean;

  static final _id_putAll1 =
      jniAccessors.getMethodIDOf(_classRef, "putAll", "(Ljava/util/Map;)V");

  /// from: public void putAll(java.util.Map<? extends K,? extends V> map)
  ///
  /// Perform a \#put(Object, Object) of all key/value pairs in <var>map</var>
  ///@param map The map whose contents are to be retrieved.
  void putAll1(jni.JniObject map) => jniAccessors.callMethodWithArgs(
      reference, _id_putAll1, jni.JniType.voidType, [map.reference]).check();

  static final _id_removeAll = jniAccessors.getMethodIDOf(
      _classRef, "removeAll", "(Ljava/util/Collection;)Z");

  /// from: public boolean removeAll(java.util.Collection<?> collection)
  ///
  /// Remove all keys in the array map that exist in the given collection.
  ///@param collection The collection whose contents are to be used to remove keys.
  ///@return Returns true if any keys were removed from the array map, else false.
  bool removeAll(jni.JniObject collection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeAll,
      jni.JniType.booleanType,
      [collection.reference]).boolean;

  static final _id_retainAll = jniAccessors.getMethodIDOf(
      _classRef, "retainAll", "(Ljava/util/Collection;)Z");

  /// from: public boolean retainAll(java.util.Collection<?> collection)
  ///
  /// Remove all keys in the array map that do __not__ exist in the given collection.
  ///@param collection The collection whose contents are to be used to determine which
  /// keys to keep.
  ///@return Returns true if any keys were removed from the array map, else false.
  bool retainAll(jni.JniObject collection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_retainAll,
      jni.JniType.booleanType,
      [collection.reference]).boolean;

  static final _id_entrySet =
      jniAccessors.getMethodIDOf(_classRef, "entrySet", "()Ljava/util/Set;");

  /// from: public java.util.Set<java.util.Map.Entry<K,V>> entrySet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a java.util.Set for iterating over and interacting with all mappings
  /// in the array map.
  ///
  /// __Note:__ this is a very inefficient way to access the array contents, it
  /// requires generating a number of temporary objects and allocates additional state
  /// information associated with the container that will remain for the life of the container.
  ///
  ///
  /// __Note:__
  /// the semantics of this
  /// Set are subtly different than that of a java.util.HashMap: most important,
  /// the java.util.Map.Entry Map.Entry object returned by its iterator is a single
  /// object that exists for the entire iterator, so you can __not__ hold on to it
  /// after calling java.util.Iterator\#next() Iterator.next.
  ///
  jni.JniObject entrySet() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_entrySet, jni.JniType.objectType, []).object);

  static final _id_keySet =
      jniAccessors.getMethodIDOf(_classRef, "keySet", "()Ljava/util/Set;");

  /// from: public java.util.Set<K> keySet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a java.util.Set for iterating over and interacting with all keys
  /// in the array map.
  ///
  /// __Note:__ this is a fairly inefficient way to access the array contents, it
  /// requires generating a number of temporary objects and allocates additional state
  /// information associated with the container that will remain for the life of the container.
  ///
  jni.JniObject keySet() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_keySet, jni.JniType.objectType, []).object);

  static final _id_values = jniAccessors.getMethodIDOf(
      _classRef, "values", "()Ljava/util/Collection;");

  /// from: public java.util.Collection<V> values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a java.util.Collection for iterating over and interacting with all values
  /// in the array map.
  ///
  /// __Note:__ this is a fairly inefficient way to access the array contents, it
  /// requires generating a number of temporary objects and allocates additional state
  /// information associated with the container that will remain for the life of the container.
  ///
  jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_values, jni.JniType.objectType, []).object);
}
