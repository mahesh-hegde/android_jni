// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.util.LruCache
///
/// A cache that holds strong references to a limited number of values. Each time
/// a value is accessed, it is moved to the head of a queue. When a value is
/// added to a full cache, the value at the end of that queue is evicted and may
/// become eligible for garbage collection.
///
/// If your cached values hold resources that need to be explicitly released,
/// override \#entryRemoved.
///
/// If a cache miss should be computed on demand for the corresponding keys,
/// override \#create. This simplifies the calling code, allowing it to
/// assume a value will always be returned, even when there's a cache miss.
///
/// By default, the cache size is measured in the number of entries. Override
/// \#sizeOf to size the cache in different units. For example, this cache
/// is limited to 4MiB of bitmaps:
/// <pre>   {@code
///   int cacheSize = 4 * 1024 * 1024; // 4MiB
///   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {
///       protected int sizeOf(String key, Bitmap value) {
///           return value.getByteCount();
///       }
///   }}</pre>
///
/// This class is thread-safe. Perform multiple cache operations atomically by
/// synchronizing on the cache: <pre>   {@code
///   synchronized (cache) {
///     if (cache.get(key) == null) {
///         cache.put(key, value);
///     }
///   }}</pre>
///
/// This class does not allow null to be used as a key or value. A return
/// value of null from \#get, \#put or \#remove is
/// unambiguous: the key was not in the cache.
///
/// This class appeared in Android 3.1 (Honeycomb MR1); it's available as part
/// of <a href="http://developer.android.com/sdk/compatibility-library.html">Android's
/// Support Package</a> for earlier releases.
class LruCache extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/util/LruCache");
  LruCache.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int maxSize)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param maxSize for caches that do not override \#sizeOf, this is
  ///     the maximum number of entries in the cache. For all other caches,
  ///     this is the maximum sum of the sizes of the entries in this cache.
  LruCache(int maxSize)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [maxSize]).object);

  static final _id_resize =
      jniAccessors.getMethodIDOf(_classRef, "resize", "(I)V");

  /// from: public void resize(int maxSize)
  ///
  /// Sets the size of the cache.
  ///@param maxSize The new maximum size.
  void resize(int maxSize) => jniAccessors.callMethodWithArgs(
      reference, _id_resize, jni.JniType.voidType, [maxSize]).check();

  static final _id_trimToSize =
      jniAccessors.getMethodIDOf(_classRef, "trimToSize", "(I)V");

  /// from: public void trimToSize(int maxSize)
  ///
  /// Remove the eldest entries until the total of remaining entries is at or
  /// below the requested size.
  ///@param maxSize the maximum size of the cache before returning. May be -1
  ///            to evict even 0-sized elements.
  void trimToSize(int maxSize) => jniAccessors.callMethodWithArgs(
      reference, _id_trimToSize, jni.JniType.voidType, [maxSize]).check();

  static final _id_evictAll =
      jniAccessors.getMethodIDOf(_classRef, "evictAll", "()V");

  /// from: public final void evictAll()
  ///
  /// Clear the cache, calling \#entryRemoved on each removed entry.
  void evictAll() => jniAccessors.callMethodWithArgs(
      reference, _id_evictAll, jni.JniType.voidType, []).check();

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: synchronized public final int size()
  ///
  /// For caches that do not override \#sizeOf, this returns the number
  /// of entries in the cache. For all other caches, this returns the sum of
  /// the sizes of the entries in this cache.
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.intType, []).integer;

  static final _id_maxSize =
      jniAccessors.getMethodIDOf(_classRef, "maxSize", "()I");

  /// from: synchronized public final int maxSize()
  ///
  /// For caches that do not override \#sizeOf, this returns the maximum
  /// number of entries in the cache. For all other caches, this returns the
  /// maximum sum of the sizes of the entries in this cache.
  int maxSize() => jniAccessors.callMethodWithArgs(
      reference, _id_maxSize, jni.JniType.intType, []).integer;

  static final _id_hitCount =
      jniAccessors.getMethodIDOf(_classRef, "hitCount", "()I");

  /// from: synchronized public final int hitCount()
  ///
  /// Returns the number of times \#get returned a value that was
  /// already present in the cache.
  int hitCount() => jniAccessors.callMethodWithArgs(
      reference, _id_hitCount, jni.JniType.intType, []).integer;

  static final _id_missCount =
      jniAccessors.getMethodIDOf(_classRef, "missCount", "()I");

  /// from: synchronized public final int missCount()
  ///
  /// Returns the number of times \#get returned null or required a new
  /// value to be created.
  int missCount() => jniAccessors.callMethodWithArgs(
      reference, _id_missCount, jni.JniType.intType, []).integer;

  static final _id_createCount =
      jniAccessors.getMethodIDOf(_classRef, "createCount", "()I");

  /// from: synchronized public final int createCount()
  ///
  /// Returns the number of times \#create(Object) returned a value.
  int createCount() => jniAccessors.callMethodWithArgs(
      reference, _id_createCount, jni.JniType.intType, []).integer;

  static final _id_putCount =
      jniAccessors.getMethodIDOf(_classRef, "putCount", "()I");

  /// from: synchronized public final int putCount()
  ///
  /// Returns the number of times \#put was called.
  int putCount() => jniAccessors.callMethodWithArgs(
      reference, _id_putCount, jni.JniType.intType, []).integer;

  static final _id_evictionCount =
      jniAccessors.getMethodIDOf(_classRef, "evictionCount", "()I");

  /// from: synchronized public final int evictionCount()
  ///
  /// Returns the number of values that have been evicted.
  int evictionCount() => jniAccessors.callMethodWithArgs(
      reference, _id_evictionCount, jni.JniType.intType, []).integer;

  static final _id_snapshot =
      jniAccessors.getMethodIDOf(_classRef, "snapshot", "()Ljava/util/Map;");

  /// from: synchronized public final java.util.Map<K,V> snapshot()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of the current contents of the cache, ordered from least
  /// recently accessed to most recently accessed.
  jni.JniObject snapshot() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_snapshot, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: synchronized public final java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
