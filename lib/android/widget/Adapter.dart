// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../database/DataSetObserver.dart" as datasetobserver_;

import "../view/View.dart" as view_;

import "../view/ViewGroup.dart" as viewgroup_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.Adapter
///
/// An Adapter object acts as a bridge between an AdapterView and the
/// underlying data for that view. The Adapter provides access to the data items.
/// The Adapter is also responsible for making a android.view.View for
/// each item in the data set.
///@see android.widget.ArrayAdapter
///@see android.widget.CursorAdapter
///@see android.widget.SimpleCursorAdapter
class Adapter extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/widget/Adapter");
  Adapter.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int IGNORE_ITEM_VIEW_TYPE
  ///
  /// An item view type that causes the AdapterView to ignore the item
  /// view. For example, this can be used if the client does not want a
  /// particular view to be given for conversion in
  /// \#getView(int, View, ViewGroup).
  ///@see \#getItemViewType(int)
  ///@see \#getViewTypeCount()
  static const IGNORE_ITEM_VIEW_TYPE = -1;

  /// from: static public final int NO_SELECTION
  static const NO_SELECTION = -2147483648;

  static final _id_registerDataSetObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDataSetObserver",
      "(Landroid/database/DataSetObserver;)V");

  /// from: public abstract void registerDataSetObserver(android.database.DataSetObserver observer)
  ///
  /// Register an observer that is called when changes happen to the data used by this adapter.
  ///@param observer the object that gets notified when the data set changes.
  void registerDataSetObserver(datasetobserver_.DataSetObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerDataSetObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_unregisterDataSetObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterDataSetObserver",
      "(Landroid/database/DataSetObserver;)V");

  /// from: public abstract void unregisterDataSetObserver(android.database.DataSetObserver observer)
  ///
  /// Unregister an observer that has previously been registered with this
  /// adapter via \#registerDataSetObserver.
  ///@param observer the object to unregister.
  void unregisterDataSetObserver(datasetobserver_.DataSetObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterDataSetObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_getCount =
      jniAccessors.getMethodIDOf(_classRef, "getCount", "()I");

  /// from: public abstract int getCount()
  ///
  /// How many items are in the data set represented by this Adapter.
  ///@return Count of items.
  int getCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getCount, jni.JniType.intType, []).integer;

  static final _id_getItem =
      jniAccessors.getMethodIDOf(_classRef, "getItem", "(I)Ljava/lang/Object;");

  /// from: public abstract java.lang.Object getItem(int position)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the data item associated with the specified position in the data set.
  ///@param position Position of the item whose data we want within the adapter's
  /// data set.
  ///@return The data at the specified position.
  jni.JniObject getItem(int position) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getItem, jni.JniType.objectType, [position]).object);

  static final _id_getItemId =
      jniAccessors.getMethodIDOf(_classRef, "getItemId", "(I)J");

  /// from: public abstract long getItemId(int position)
  ///
  /// Get the row id associated with the specified position in the list.
  ///@param position The position of the item within the adapter's data set whose row id we want.
  ///@return The id of the item at the specified position.
  int getItemId(int position) => jniAccessors.callMethodWithArgs(
      reference, _id_getItemId, jni.JniType.longType, [position]).long;

  static final _id_hasStableIds =
      jniAccessors.getMethodIDOf(_classRef, "hasStableIds", "()Z");

  /// from: public abstract boolean hasStableIds()
  ///
  /// Indicates whether the item ids are stable across changes to the
  /// underlying data.
  ///@return True if the same id always refers to the same object.
  bool hasStableIds() => jniAccessors.callMethodWithArgs(
      reference, _id_hasStableIds, jni.JniType.booleanType, []).boolean;

  static final _id_getView = jniAccessors.getMethodIDOf(_classRef, "getView",
      "(ILandroid/view/View;Landroid/view/ViewGroup;)Landroid/view/View;");

  /// from: public abstract android.view.View getView(int position, android.view.View convertView, android.view.ViewGroup parent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a View that displays the data at the specified position in the data set. You can either
  /// create a View manually or inflate it from an XML layout file. When the View is inflated, the
  /// parent View (GridView, ListView...) will apply default layout parameters unless you use
  /// android.view.LayoutInflater\#inflate(int, android.view.ViewGroup, boolean)
  /// to specify a root view and to prevent attachment to the root.
  ///@param position The position of the item within the adapter's data set of the item whose view
  ///        we want.
  ///@param convertView The old view to reuse, if possible. Note: You should check that this view
  ///        is non-null and of an appropriate type before using. If it is not possible to convert
  ///        this view to display the correct data, this method can create a new view.
  ///        Heterogeneous lists can specify their number of view types, so that this View is
  ///        always of the right type (see \#getViewTypeCount() and
  ///        \#getItemViewType(int)).
  ///@param parent The parent that this view will eventually be attached to
  ///@return A View corresponding to the data at the specified position.
  view_.View getView(
          int position, view_.View convertView, viewgroup_.ViewGroup parent) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getView,
          jni.JniType.objectType,
          [position, convertView.reference, parent.reference]).object);

  static final _id_getItemViewType =
      jniAccessors.getMethodIDOf(_classRef, "getItemViewType", "(I)I");

  /// from: public abstract int getItemViewType(int position)
  ///
  /// Get the type of View that will be created by \#getView for the specified item.
  ///@param position The position of the item within the adapter's data set whose view type we
  ///        want.
  ///@return An integer representing the type of View. Two views should share the same type if one
  ///         can be converted to the other in \#getView. Note: Integers must be in the
  ///         range 0 to \#getViewTypeCount - 1. \#IGNORE_ITEM_VIEW_TYPE can
  ///         also be returned.
  ///@see \#IGNORE_ITEM_VIEW_TYPE
  int getItemViewType(int position) => jniAccessors.callMethodWithArgs(
      reference, _id_getItemViewType, jni.JniType.intType, [position]).integer;

  static final _id_getViewTypeCount =
      jniAccessors.getMethodIDOf(_classRef, "getViewTypeCount", "()I");

  /// from: public abstract int getViewTypeCount()
  ///
  ///
  /// Returns the number of types of Views that will be created by
  /// \#getView. Each type represents a set of views that can be
  /// converted in \#getView. If the adapter always returns the same
  /// type of View for all items, this method should return 1.
  ///
  ///
  ///
  /// This method will only be called when the adapter is set on the AdapterView.
  ///
  ///
  ///@return The number of types of Views that will be created by this adapter
  int getViewTypeCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getViewTypeCount, jni.JniType.intType, []).integer;

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public abstract boolean isEmpty()
  ///
  /// @return true if this adapter doesn't contain any data.  This is used to determine
  /// whether the empty view should be displayed.  A typical implementation will return
  /// getCount() == 0 but since getCount() includes the headers and footers, specialized
  /// adapters might want a different behavior.
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniType.booleanType, []).boolean;

  static final _id_getAutofillOptions = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillOptions", "()[Ljava/lang/CharSequence;");

  /// from: default public java.lang.CharSequence[] getAutofillOptions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a string representation of the adapter data that can help
  /// android.service.autofill.AutofillService autofill the view backed by the adapter.
  ///
  ///
  /// It should only be set (i.e., non-{@code null} if the values do not represent PII
  /// (Personally Identifiable Information - sensitive data such as email addresses,
  /// credit card numbers, passwords, etc...). For
  /// example, it's ok to return a list of month names, but not a list of usernames. A good rule of
  /// thumb is that if the adapter data comes from static resources, such data is not PII - see
  /// android.view.ViewStructure\#setDataIsSensitive(boolean) for more info.
  ///@return {@code null} by default, unless implementations override it.
  jni.JniObject getAutofillOptions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAutofillOptions, jni.JniType.objectType, []).object);
}
