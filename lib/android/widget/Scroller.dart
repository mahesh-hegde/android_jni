// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../view/animation/Interpolator.dart" as interpolator_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.Scroller
///
/// This class encapsulates scrolling. You can use scrollers (Scroller
/// or OverScroller) to collect the data you need to produce a scrolling
/// animation&mdash;for example, in response to a fling gesture. Scrollers track
/// scroll offsets for you over time, but they don't automatically apply those
/// positions to your view. It's your responsibility to get and apply new
/// coordinates at a rate that will make the scrolling animation look smooth.
///
///
/// Here is a simple example:
///
///
/// <pre> private Scroller mScroller = new Scroller(context);
/// ...
/// public void zoomIn() {
///     // Revert any animation currently in progress
///     mScroller.forceFinished(true);
///     // Start scrolling by providing a starting point and
///     // the distance to travel
///     mScroller.startScroll(0, 0, 100, 0);
///     // Invalidate to request a redraw
///     invalidate();
/// }</pre>
///
/// To track the changing positions of the x/y coordinates, use
/// \#computeScrollOffset. The method returns a boolean to indicate
/// whether the scroller is finished. If it isn't, it means that a fling or
/// programmatic pan operation is still in progress. You can use this method to
/// find the current offsets of the x and y coordinates, for example:
///
///
/// <pre>if (mScroller.computeScrollOffset()) {
///     // Get current x and y positions
///     int currX = mScroller.getCurrX();
///     int currY = mScroller.getCurrY();
///    ...
/// }</pre>
class Scroller extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/widget/Scroller");
  Scroller.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Scroller with the default duration and interpolator.
  Scroller(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/animation/Interpolator;)V");

  /// from: public void <init>(android.content.Context context, android.view.animation.Interpolator interpolator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Scroller with the specified interpolator. If the interpolator is
  /// null, the default (viscous) interpolator will be used. "Flywheel" behavior will
  /// be in effect for apps targeting Honeycomb or newer.
  Scroller.ctor1(
      context_.Context context, interpolator_.Interpolator interpolator)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [context.reference, interpolator.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/animation/Interpolator;Z)V");

  /// from: public void <init>(android.content.Context context, android.view.animation.Interpolator interpolator, boolean flywheel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Scroller with the specified interpolator. If the interpolator is
  /// null, the default (viscous) interpolator will be used. Specify whether or
  /// not to support progressive "flywheel" behavior in flinging.
  Scroller.ctor2(context_.Context context,
      interpolator_.Interpolator interpolator, bool flywheel)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, interpolator.reference, flywheel]).object);

  static final _id_setFriction =
      jniAccessors.getMethodIDOf(_classRef, "setFriction", "(F)V");

  /// from: public final void setFriction(float friction)
  ///
  /// The amount of friction applied to flings. The default value
  /// is ViewConfiguration\#getScrollFriction.
  ///@param friction A scalar dimension-less value representing the coefficient of
  ///         friction.
  void setFriction(double friction) => jniAccessors.callMethodWithArgs(
      reference, _id_setFriction, jni.JniType.voidType, [friction]).check();

  static final _id_isFinished =
      jniAccessors.getMethodIDOf(_classRef, "isFinished", "()Z");

  /// from: public final boolean isFinished()
  ///
  /// Returns whether the scroller has finished scrolling.
  ///@return True if the scroller has finished scrolling, false otherwise.
  bool isFinished() => jniAccessors.callMethodWithArgs(
      reference, _id_isFinished, jni.JniType.booleanType, []).boolean;

  static final _id_forceFinished =
      jniAccessors.getMethodIDOf(_classRef, "forceFinished", "(Z)V");

  /// from: public final void forceFinished(boolean finished)
  ///
  /// Force the finished field to a particular value.
  ///@param finished The new finished value.
  void forceFinished(bool finished) => jniAccessors.callMethodWithArgs(
      reference, _id_forceFinished, jni.JniType.voidType, [finished]).check();

  static final _id_getDuration =
      jniAccessors.getMethodIDOf(_classRef, "getDuration", "()I");

  /// from: public final int getDuration()
  ///
  /// Returns how long the scroll event will take, in milliseconds.
  ///@return The duration of the scroll in milliseconds.
  int getDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getDuration, jni.JniType.intType, []).integer;

  static final _id_getCurrX =
      jniAccessors.getMethodIDOf(_classRef, "getCurrX", "()I");

  /// from: public final int getCurrX()
  ///
  /// Returns the current X offset in the scroll.
  ///@return The new X offset as an absolute distance from the origin.
  int getCurrX() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrX, jni.JniType.intType, []).integer;

  static final _id_getCurrY =
      jniAccessors.getMethodIDOf(_classRef, "getCurrY", "()I");

  /// from: public final int getCurrY()
  ///
  /// Returns the current Y offset in the scroll.
  ///@return The new Y offset as an absolute distance from the origin.
  int getCurrY() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrY, jni.JniType.intType, []).integer;

  static final _id_getCurrVelocity =
      jniAccessors.getMethodIDOf(_classRef, "getCurrVelocity", "()F");

  /// from: public float getCurrVelocity()
  ///
  /// Returns the current velocity.
  ///@return The original velocity less the deceleration. Result may be
  /// negative.
  double getCurrVelocity() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrVelocity, jni.JniType.floatType, []).float;

  static final _id_getStartX =
      jniAccessors.getMethodIDOf(_classRef, "getStartX", "()I");

  /// from: public final int getStartX()
  ///
  /// Returns the start X offset in the scroll.
  ///@return The start X offset as an absolute distance from the origin.
  int getStartX() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartX, jni.JniType.intType, []).integer;

  static final _id_getStartY =
      jniAccessors.getMethodIDOf(_classRef, "getStartY", "()I");

  /// from: public final int getStartY()
  ///
  /// Returns the start Y offset in the scroll.
  ///@return The start Y offset as an absolute distance from the origin.
  int getStartY() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartY, jni.JniType.intType, []).integer;

  static final _id_getFinalX =
      jniAccessors.getMethodIDOf(_classRef, "getFinalX", "()I");

  /// from: public final int getFinalX()
  ///
  /// Returns where the scroll will end. Valid only for "fling" scrolls.
  ///@return The final X offset as an absolute distance from the origin.
  int getFinalX() => jniAccessors.callMethodWithArgs(
      reference, _id_getFinalX, jni.JniType.intType, []).integer;

  static final _id_getFinalY =
      jniAccessors.getMethodIDOf(_classRef, "getFinalY", "()I");

  /// from: public final int getFinalY()
  ///
  /// Returns where the scroll will end. Valid only for "fling" scrolls.
  ///@return The final Y offset as an absolute distance from the origin.
  int getFinalY() => jniAccessors.callMethodWithArgs(
      reference, _id_getFinalY, jni.JniType.intType, []).integer;

  static final _id_computeScrollOffset =
      jniAccessors.getMethodIDOf(_classRef, "computeScrollOffset", "()Z");

  /// from: public boolean computeScrollOffset()
  ///
  /// Call this when you want to know the new location.  If it returns true,
  /// the animation is not yet finished.
  bool computeScrollOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_computeScrollOffset, jni.JniType.booleanType, []).boolean;

  static final _id_startScroll =
      jniAccessors.getMethodIDOf(_classRef, "startScroll", "(IIII)V");

  /// from: public void startScroll(int startX, int startY, int dx, int dy)
  ///
  /// Start scrolling by providing a starting point and the distance to travel.
  /// The scroll will use the default value of 250 milliseconds for the
  /// duration.
  ///@param startX Starting horizontal scroll offset in pixels. Positive
  ///        numbers will scroll the content to the left.
  ///@param startY Starting vertical scroll offset in pixels. Positive numbers
  ///        will scroll the content up.
  ///@param dx Horizontal distance to travel. Positive numbers will scroll the
  ///        content to the left.
  ///@param dy Vertical distance to travel. Positive numbers will scroll the
  ///        content up.
  void startScroll(int startX, int startY, int dx, int dy) =>
      jniAccessors.callMethodWithArgs(reference, _id_startScroll,
          jni.JniType.voidType, [startX, startY, dx, dy]).check();

  static final _id_startScroll1 =
      jniAccessors.getMethodIDOf(_classRef, "startScroll", "(IIIII)V");

  /// from: public void startScroll(int startX, int startY, int dx, int dy, int duration)
  ///
  /// Start scrolling by providing a starting point, the distance to travel,
  /// and the duration of the scroll.
  ///@param startX Starting horizontal scroll offset in pixels. Positive
  ///        numbers will scroll the content to the left.
  ///@param startY Starting vertical scroll offset in pixels. Positive numbers
  ///        will scroll the content up.
  ///@param dx Horizontal distance to travel. Positive numbers will scroll the
  ///        content to the left.
  ///@param dy Vertical distance to travel. Positive numbers will scroll the
  ///        content up.
  ///@param duration Duration of the scroll in milliseconds.
  void startScroll1(int startX, int startY, int dx, int dy, int duration) =>
      jniAccessors.callMethodWithArgs(reference, _id_startScroll1,
          jni.JniType.voidType, [startX, startY, dx, dy, duration]).check();

  static final _id_fling =
      jniAccessors.getMethodIDOf(_classRef, "fling", "(IIIIIIII)V");

  /// from: public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY)
  ///
  /// Start scrolling based on a fling gesture. The distance travelled will
  /// depend on the initial velocity of the fling.
  ///@param startX Starting point of the scroll (X)
  ///@param startY Starting point of the scroll (Y)
  ///@param velocityX Initial velocity of the fling (X) measured in pixels per
  ///        second.
  ///@param velocityY Initial velocity of the fling (Y) measured in pixels per
  ///        second
  ///@param minX Minimum X value. The scroller will not scroll past this
  ///        point.
  ///@param maxX Maximum X value. The scroller will not scroll past this
  ///        point.
  ///@param minY Minimum Y value. The scroller will not scroll past this
  ///        point.
  ///@param maxY Maximum Y value. The scroller will not scroll past this
  ///        point.
  void fling(int startX, int startY, int velocityX, int velocityY, int minX,
          int maxX, int minY, int maxY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_fling, jni.JniType.voidType, [
        startX,
        startY,
        velocityX,
        velocityY,
        minX,
        maxX,
        minY,
        maxY
      ]).check();

  static final _id_abortAnimation =
      jniAccessors.getMethodIDOf(_classRef, "abortAnimation", "()V");

  /// from: public void abortAnimation()
  ///
  /// Stops the animation. Contrary to \#forceFinished(boolean),
  /// aborting the animating cause the scroller to move to the final x and y
  /// position
  ///@see \#forceFinished(boolean)
  void abortAnimation() => jniAccessors.callMethodWithArgs(
      reference, _id_abortAnimation, jni.JniType.voidType, []).check();

  static final _id_extendDuration =
      jniAccessors.getMethodIDOf(_classRef, "extendDuration", "(I)V");

  /// from: public void extendDuration(int extend)
  ///
  /// Extend the scroll animation. This allows a running animation to scroll
  /// further and longer, when used with \#setFinalX(int) or \#setFinalY(int).
  ///@param extend Additional time to scroll in milliseconds.
  ///@see \#setFinalX(int)
  ///@see \#setFinalY(int)
  void extendDuration(int extend) => jniAccessors.callMethodWithArgs(
      reference, _id_extendDuration, jni.JniType.voidType, [extend]).check();

  static final _id_timePassed =
      jniAccessors.getMethodIDOf(_classRef, "timePassed", "()I");

  /// from: public int timePassed()
  ///
  /// Returns the time elapsed since the beginning of the scrolling.
  ///@return The elapsed time in milliseconds.
  int timePassed() => jniAccessors.callMethodWithArgs(
      reference, _id_timePassed, jni.JniType.intType, []).integer;

  static final _id_setFinalX =
      jniAccessors.getMethodIDOf(_classRef, "setFinalX", "(I)V");

  /// from: public void setFinalX(int newX)
  ///
  /// Sets the final position (X) for this scroller.
  ///@param newX The new X offset as an absolute distance from the origin.
  ///@see \#extendDuration(int)
  ///@see \#setFinalY(int)
  void setFinalX(int newX) => jniAccessors.callMethodWithArgs(
      reference, _id_setFinalX, jni.JniType.voidType, [newX]).check();

  static final _id_setFinalY =
      jniAccessors.getMethodIDOf(_classRef, "setFinalY", "(I)V");

  /// from: public void setFinalY(int newY)
  ///
  /// Sets the final position (Y) for this scroller.
  ///@param newY The new Y offset as an absolute distance from the origin.
  ///@see \#extendDuration(int)
  ///@see \#setFinalX(int)
  void setFinalY(int newY) => jniAccessors.callMethodWithArgs(
      reference, _id_setFinalY, jni.JniType.voidType, [newY]).check();
}
