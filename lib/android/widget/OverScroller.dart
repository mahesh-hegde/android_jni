// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../view/animation/Interpolator.dart" as interpolator_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.OverScroller
///
/// This class encapsulates scrolling with the ability to overshoot the bounds
/// of a scrolling operation. This class is a drop-in replacement for
/// android.widget.Scroller in most cases.
class OverScroller extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/OverScroller");
  OverScroller.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an OverScroller with a viscous fluid scroll interpolator and flywheel.
  ///@param context
  OverScroller(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/animation/Interpolator;)V");

  /// from: public void <init>(android.content.Context context, android.view.animation.Interpolator interpolator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an OverScroller with flywheel enabled.
  ///@param context The context of this application.
  ///@param interpolator The scroll interpolator. If null, a default (viscous) interpolator will
  /// be used.
  OverScroller.ctor1(
      context_.Context context, interpolator_.Interpolator interpolator)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [context.reference, interpolator.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/animation/Interpolator;FF)V");

  /// from: public void <init>(android.content.Context context, android.view.animation.Interpolator interpolator, float bounceCoefficientX, float bounceCoefficientY)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an OverScroller with flywheel enabled.
  ///@param context The context of this application.
  ///@param interpolator The scroll interpolator. If null, a default (viscous) interpolator will
  /// be used.
  ///@param bounceCoefficientX A value between 0 and 1 that will determine the proportion of the
  /// velocity which is preserved in the bounce when the horizontal edge is reached. A null value
  /// means no bounce. This behavior is no longer supported and this coefficient has no effect.
  ///@param bounceCoefficientY Same as bounceCoefficientX but for the vertical direction. This
  /// behavior is no longer supported and this coefficient has no effect.
  ///@deprecated Use \#OverScroller(Context, Interpolator) instead.
  OverScroller.ctor2(
      context_.Context context,
      interpolator_.Interpolator interpolator,
      double bounceCoefficientX,
      double bounceCoefficientY)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, [
          context.reference,
          interpolator.reference,
          bounceCoefficientX,
          bounceCoefficientY
        ]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/animation/Interpolator;FFZ)V");

  /// from: public void <init>(android.content.Context context, android.view.animation.Interpolator interpolator, float bounceCoefficientX, float bounceCoefficientY, boolean flywheel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an OverScroller.
  ///@param context The context of this application.
  ///@param interpolator The scroll interpolator. If null, a default (viscous) interpolator will
  /// be used.
  ///@param bounceCoefficientX A value between 0 and 1 that will determine the proportion of the
  /// velocity which is preserved in the bounce when the horizontal edge is reached. A null value
  /// means no bounce. This behavior is no longer supported and this coefficient has no effect.
  ///@param bounceCoefficientY Same as bounceCoefficientX but for the vertical direction. This
  /// behavior is no longer supported and this coefficient has no effect.
  ///@param flywheel If true, successive fling motions will keep on increasing scroll speed.
  ///@deprecated Use \#OverScroller(Context, Interpolator) instead.
  OverScroller.ctor3(
      context_.Context context,
      interpolator_.Interpolator interpolator,
      double bounceCoefficientX,
      double bounceCoefficientY,
      bool flywheel)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          interpolator.reference,
          bounceCoefficientX,
          bounceCoefficientY,
          flywheel
        ]).object);

  static final _id_setFriction =
      jniAccessors.getMethodIDOf(_classRef, "setFriction", "(F)V");

  /// from: public final void setFriction(float friction)
  ///
  /// The amount of friction applied to flings. The default value
  /// is ViewConfiguration\#getScrollFriction.
  ///@param friction A scalar dimension-less value representing the coefficient of
  ///         friction.
  void setFriction(double friction) => jniAccessors.callMethodWithArgs(
      reference, _id_setFriction, jni.JniType.voidType, [friction]).check();

  static final _id_isFinished =
      jniAccessors.getMethodIDOf(_classRef, "isFinished", "()Z");

  /// from: public final boolean isFinished()
  ///
  /// Returns whether the scroller has finished scrolling.
  ///@return True if the scroller has finished scrolling, false otherwise.
  bool isFinished() => jniAccessors.callMethodWithArgs(
      reference, _id_isFinished, jni.JniType.booleanType, []).boolean;

  static final _id_forceFinished =
      jniAccessors.getMethodIDOf(_classRef, "forceFinished", "(Z)V");

  /// from: public final void forceFinished(boolean finished)
  ///
  /// Force the finished field to a particular value. Contrary to
  /// \#abortAnimation(), forcing the animation to finished
  /// does NOT cause the scroller to move to the final x and y
  /// position.
  ///@param finished The new finished value.
  void forceFinished(bool finished) => jniAccessors.callMethodWithArgs(
      reference, _id_forceFinished, jni.JniType.voidType, [finished]).check();

  static final _id_getCurrX =
      jniAccessors.getMethodIDOf(_classRef, "getCurrX", "()I");

  /// from: public final int getCurrX()
  ///
  /// Returns the current X offset in the scroll.
  ///@return The new X offset as an absolute distance from the origin.
  int getCurrX() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrX, jni.JniType.intType, []).integer;

  static final _id_getCurrY =
      jniAccessors.getMethodIDOf(_classRef, "getCurrY", "()I");

  /// from: public final int getCurrY()
  ///
  /// Returns the current Y offset in the scroll.
  ///@return The new Y offset as an absolute distance from the origin.
  int getCurrY() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrY, jni.JniType.intType, []).integer;

  static final _id_getCurrVelocity =
      jniAccessors.getMethodIDOf(_classRef, "getCurrVelocity", "()F");

  /// from: public float getCurrVelocity()
  ///
  /// Returns the absolute value of the current velocity.
  ///@return The original velocity less the deceleration, norm of the X and Y velocity vector.
  double getCurrVelocity() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrVelocity, jni.JniType.floatType, []).float;

  static final _id_getStartX =
      jniAccessors.getMethodIDOf(_classRef, "getStartX", "()I");

  /// from: public final int getStartX()
  ///
  /// Returns the start X offset in the scroll.
  ///@return The start X offset as an absolute distance from the origin.
  int getStartX() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartX, jni.JniType.intType, []).integer;

  static final _id_getStartY =
      jniAccessors.getMethodIDOf(_classRef, "getStartY", "()I");

  /// from: public final int getStartY()
  ///
  /// Returns the start Y offset in the scroll.
  ///@return The start Y offset as an absolute distance from the origin.
  int getStartY() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartY, jni.JniType.intType, []).integer;

  static final _id_getFinalX =
      jniAccessors.getMethodIDOf(_classRef, "getFinalX", "()I");

  /// from: public final int getFinalX()
  ///
  /// Returns where the scroll will end. Valid only for "fling" scrolls.
  ///@return The final X offset as an absolute distance from the origin.
  int getFinalX() => jniAccessors.callMethodWithArgs(
      reference, _id_getFinalX, jni.JniType.intType, []).integer;

  static final _id_getFinalY =
      jniAccessors.getMethodIDOf(_classRef, "getFinalY", "()I");

  /// from: public final int getFinalY()
  ///
  /// Returns where the scroll will end. Valid only for "fling" scrolls.
  ///@return The final Y offset as an absolute distance from the origin.
  int getFinalY() => jniAccessors.callMethodWithArgs(
      reference, _id_getFinalY, jni.JniType.intType, []).integer;

  static final _id_computeScrollOffset =
      jniAccessors.getMethodIDOf(_classRef, "computeScrollOffset", "()Z");

  /// from: public boolean computeScrollOffset()
  ///
  /// Call this when you want to know the new location. If it returns true, the
  /// animation is not yet finished.
  bool computeScrollOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_computeScrollOffset, jni.JniType.booleanType, []).boolean;

  static final _id_startScroll =
      jniAccessors.getMethodIDOf(_classRef, "startScroll", "(IIII)V");

  /// from: public void startScroll(int startX, int startY, int dx, int dy)
  ///
  /// Start scrolling by providing a starting point and the distance to travel.
  /// The scroll will use the default value of 250 milliseconds for the
  /// duration.
  ///@param startX Starting horizontal scroll offset in pixels. Positive
  ///        numbers will scroll the content to the left.
  ///@param startY Starting vertical scroll offset in pixels. Positive numbers
  ///        will scroll the content up.
  ///@param dx Horizontal distance to travel. Positive numbers will scroll the
  ///        content to the left.
  ///@param dy Vertical distance to travel. Positive numbers will scroll the
  ///        content up.
  void startScroll(int startX, int startY, int dx, int dy) =>
      jniAccessors.callMethodWithArgs(reference, _id_startScroll,
          jni.JniType.voidType, [startX, startY, dx, dy]).check();

  static final _id_startScroll1 =
      jniAccessors.getMethodIDOf(_classRef, "startScroll", "(IIIII)V");

  /// from: public void startScroll(int startX, int startY, int dx, int dy, int duration)
  ///
  /// Start scrolling by providing a starting point and the distance to travel.
  ///@param startX Starting horizontal scroll offset in pixels. Positive
  ///        numbers will scroll the content to the left.
  ///@param startY Starting vertical scroll offset in pixels. Positive numbers
  ///        will scroll the content up.
  ///@param dx Horizontal distance to travel. Positive numbers will scroll the
  ///        content to the left.
  ///@param dy Vertical distance to travel. Positive numbers will scroll the
  ///        content up.
  ///@param duration Duration of the scroll in milliseconds.
  void startScroll1(int startX, int startY, int dx, int dy, int duration) =>
      jniAccessors.callMethodWithArgs(reference, _id_startScroll1,
          jni.JniType.voidType, [startX, startY, dx, dy, duration]).check();

  static final _id_springBack =
      jniAccessors.getMethodIDOf(_classRef, "springBack", "(IIIIII)Z");

  /// from: public boolean springBack(int startX, int startY, int minX, int maxX, int minY, int maxY)
  ///
  /// Call this when you want to 'spring back' into a valid coordinate range.
  ///@param startX Starting X coordinate
  ///@param startY Starting Y coordinate
  ///@param minX Minimum valid X value
  ///@param maxX Maximum valid X value
  ///@param minY Minimum valid Y value
  ///@param maxY Minimum valid Y value
  ///@return true if a springback was initiated, false if startX and startY were
  ///          already within the valid range.
  bool springBack(
          int startX, int startY, int minX, int maxX, int minY, int maxY) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_springBack,
          jni.JniType.booleanType,
          [startX, startY, minX, maxX, minY, maxY]).boolean;

  static final _id_fling =
      jniAccessors.getMethodIDOf(_classRef, "fling", "(IIIIIIII)V");

  /// from: public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY)
  void fling(int startX, int startY, int velocityX, int velocityY, int minX,
          int maxX, int minY, int maxY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_fling, jni.JniType.voidType, [
        startX,
        startY,
        velocityX,
        velocityY,
        minX,
        maxX,
        minY,
        maxY
      ]).check();

  static final _id_fling1 =
      jniAccessors.getMethodIDOf(_classRef, "fling", "(IIIIIIIIII)V");

  /// from: public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY, int overX, int overY)
  ///
  /// Start scrolling based on a fling gesture. The distance traveled will
  /// depend on the initial velocity of the fling.
  ///@param startX Starting point of the scroll (X)
  ///@param startY Starting point of the scroll (Y)
  ///@param velocityX Initial velocity of the fling (X) measured in pixels per
  ///            second.
  ///@param velocityY Initial velocity of the fling (Y) measured in pixels per
  ///            second
  ///@param minX Minimum X value. The scroller will not scroll past this point
  ///            unless overX > 0. If overfling is allowed, it will use minX as
  ///            a springback boundary.
  ///@param maxX Maximum X value. The scroller will not scroll past this point
  ///            unless overX > 0. If overfling is allowed, it will use maxX as
  ///            a springback boundary.
  ///@param minY Minimum Y value. The scroller will not scroll past this point
  ///            unless overY > 0. If overfling is allowed, it will use minY as
  ///            a springback boundary.
  ///@param maxY Maximum Y value. The scroller will not scroll past this point
  ///            unless overY > 0. If overfling is allowed, it will use maxY as
  ///            a springback boundary.
  ///@param overX Overfling range. If > 0, horizontal overfling in either
  ///            direction will be possible.
  ///@param overY Overfling range. If > 0, vertical overfling in either
  ///            direction will be possible.
  void fling1(int startX, int startY, int velocityX, int velocityY, int minX,
          int maxX, int minY, int maxY, int overX, int overY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_fling1, jni.JniType.voidType, [
        startX,
        startY,
        velocityX,
        velocityY,
        minX,
        maxX,
        minY,
        maxY,
        overX,
        overY
      ]).check();

  static final _id_notifyHorizontalEdgeReached = jniAccessors.getMethodIDOf(
      _classRef, "notifyHorizontalEdgeReached", "(III)V");

  /// from: public void notifyHorizontalEdgeReached(int startX, int finalX, int overX)
  ///
  /// Notify the scroller that we've reached a horizontal boundary.
  /// Normally the information to handle this will already be known
  /// when the animation is started, such as in a call to one of the
  /// fling functions. However there are cases where this cannot be known
  /// in advance. This function will transition the current motion and
  /// animate from startX to finalX as appropriate.
  ///@param startX Starting/current X position
  ///@param finalX Desired final X position
  ///@param overX Magnitude of overscroll allowed. This should be the maximum
  ///              desired distance from finalX. Absolute value - must be positive.
  void notifyHorizontalEdgeReached(int startX, int finalX, int overX) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyHorizontalEdgeReached,
          jni.JniType.voidType,
          [startX, finalX, overX]).check();

  static final _id_notifyVerticalEdgeReached = jniAccessors.getMethodIDOf(
      _classRef, "notifyVerticalEdgeReached", "(III)V");

  /// from: public void notifyVerticalEdgeReached(int startY, int finalY, int overY)
  ///
  /// Notify the scroller that we've reached a vertical boundary.
  /// Normally the information to handle this will already be known
  /// when the animation is started, such as in a call to one of the
  /// fling functions. However there are cases where this cannot be known
  /// in advance. This function will animate a parabolic motion from
  /// startY to finalY.
  ///@param startY Starting/current Y position
  ///@param finalY Desired final Y position
  ///@param overY Magnitude of overscroll allowed. This should be the maximum
  ///              desired distance from finalY. Absolute value - must be positive.
  void notifyVerticalEdgeReached(int startY, int finalY, int overY) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyVerticalEdgeReached,
          jni.JniType.voidType, [startY, finalY, overY]).check();

  static final _id_isOverScrolled =
      jniAccessors.getMethodIDOf(_classRef, "isOverScrolled", "()Z");

  /// from: public boolean isOverScrolled()
  ///
  /// Returns whether the current Scroller is currently returning to a valid position.
  /// Valid bounds were provided by the
  /// \#fling(int, int, int, int, int, int, int, int, int, int) method.
  ///
  /// One should check this value before calling
  /// \#startScroll(int, int, int, int) as the interpolation currently in progress
  /// to restore a valid position will then be stopped. The caller has to take into account
  /// the fact that the started scroll will start from an overscrolled position.
  ///@return true when the current position is overscrolled and in the process of
  ///         interpolating back to a valid value.
  bool isOverScrolled() => jniAccessors.callMethodWithArgs(
      reference, _id_isOverScrolled, jni.JniType.booleanType, []).boolean;

  static final _id_abortAnimation =
      jniAccessors.getMethodIDOf(_classRef, "abortAnimation", "()V");

  /// from: public void abortAnimation()
  ///
  /// Stops the animation. Contrary to \#forceFinished(boolean),
  /// aborting the animating causes the scroller to move to the final x and y
  /// positions.
  ///@see \#forceFinished(boolean)
  void abortAnimation() => jniAccessors.callMethodWithArgs(
      reference, _id_abortAnimation, jni.JniType.voidType, []).check();
}
