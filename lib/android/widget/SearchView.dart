// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "LinearLayout.dart" as linearlayout_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../app/SearchableInfo.dart" as searchableinfo_;

import "../graphics/Rect.dart" as rect_;

import "../view/View.dart" as view_;

import "CursorAdapter.dart" as cursoradapter_;

import "../view/KeyEvent.dart" as keyevent_;

import "../os/Parcelable.dart" as parcelable_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.SearchView
///
/// A widget that provides a user interface for the user to enter a search query and submit a request
/// to a search provider. Shows a list of query suggestions or results, if available, and allows the
/// user to pick a suggestion or result to launch into.
///
///
/// When the SearchView is used in an ActionBar as an action view for a collapsible menu item, it
/// needs to be set to iconified by default using \#setIconifiedByDefault(boolean) setIconifiedByDefault(true). This is the default, so nothing needs to be done.
///
///
///
/// If you want the search field to always be visible, then call setIconifiedByDefault(false).
///
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about using {@code SearchView}, read the
/// <a href="{@docRoot}guide/topics/search/index.html">Search</a> developer guide.
///
/// </div>
///@see android.view.MenuItem\#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW
///@attr ref android.R.styleable\#SearchView_iconifiedByDefault
///@attr ref android.R.styleable\#SearchView_imeOptions
///@attr ref android.R.styleable\#SearchView_inputType
///@attr ref android.R.styleable\#SearchView_maxWidth
///@attr ref android.R.styleable\#SearchView_queryHint
class SearchView extends linearlayout_.LinearLayout {
  static final _classRef = jniAccessors.getClassOf("android/widget/SearchView");
  SearchView.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SearchView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SearchView.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SearchView.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SearchView.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_setSearchableInfo = jniAccessors.getMethodIDOf(
      _classRef, "setSearchableInfo", "(Landroid/app/SearchableInfo;)V");

  /// from: public void setSearchableInfo(android.app.SearchableInfo searchable)
  ///
  /// Sets the SearchableInfo for this SearchView. Properties in the SearchableInfo are used
  /// to display labels, hints, suggestions, create intents for launching search results screens
  /// and controlling other affordances such as a voice button.
  ///@param searchable a SearchableInfo can be retrieved from the SearchManager, for a specific
  /// activity or a global search provider.
  void setSearchableInfo(searchableinfo_.SearchableInfo searchable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSearchableInfo,
          jni.JniType.voidType, [searchable.reference]).check();

  static final _id_setImeOptions =
      jniAccessors.getMethodIDOf(_classRef, "setImeOptions", "(I)V");

  /// from: public void setImeOptions(int imeOptions)
  ///
  /// Sets the IME options on the query text field.
  ///@see TextView\#setImeOptions(int)
  ///@param imeOptions the options to set on the query text field
  ///@attr ref android.R.styleable\#SearchView_imeOptions
  void setImeOptions(int imeOptions) => jniAccessors.callMethodWithArgs(
      reference, _id_setImeOptions, jni.JniType.voidType, [imeOptions]).check();

  static final _id_getImeOptions =
      jniAccessors.getMethodIDOf(_classRef, "getImeOptions", "()I");

  /// from: public int getImeOptions()
  ///
  /// Returns the IME options set on the query text field.
  ///@return the ime options
  ///@see TextView\#setImeOptions(int)
  ///@attr ref android.R.styleable\#SearchView_imeOptions
  int getImeOptions() => jniAccessors.callMethodWithArgs(
      reference, _id_getImeOptions, jni.JniType.intType, []).integer;

  static final _id_setInputType =
      jniAccessors.getMethodIDOf(_classRef, "setInputType", "(I)V");

  /// from: public void setInputType(int inputType)
  ///
  /// Sets the input type on the query text field.
  ///@see TextView\#setInputType(int)
  ///@param inputType the input type to set on the query text field
  ///@attr ref android.R.styleable\#SearchView_inputType
  void setInputType(int inputType) => jniAccessors.callMethodWithArgs(
      reference, _id_setInputType, jni.JniType.voidType, [inputType]).check();

  static final _id_getInputType =
      jniAccessors.getMethodIDOf(_classRef, "getInputType", "()I");

  /// from: public int getInputType()
  ///
  /// Returns the input type set on the query text field.
  ///@return the input type
  ///@attr ref android.R.styleable\#SearchView_inputType
  int getInputType() => jniAccessors.callMethodWithArgs(
      reference, _id_getInputType, jni.JniType.intType, []).integer;

  static final _id_requestFocus3 = jniAccessors.getMethodIDOf(
      _classRef, "requestFocus", "(ILandroid/graphics/Rect;)Z");

  /// from: public boolean requestFocus(int direction, android.graphics.Rect previouslyFocusedRect)
  ///
  /// @hide
  bool requestFocus3(int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestFocus3,
          jni.JniType.booleanType,
          [direction, previouslyFocusedRect.reference]).boolean;

  static final _id_clearFocus1 =
      jniAccessors.getMethodIDOf(_classRef, "clearFocus", "()V");

  /// from: public void clearFocus()
  ///
  /// @hide
  void clearFocus1() => jniAccessors.callMethodWithArgs(
      reference, _id_clearFocus1, jni.JniType.voidType, []).check();

  static final _id_setOnQueryTextListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnQueryTextListener",
      "(Landroid/widget/SearchView\$OnQueryTextListener;)V");

  /// from: public void setOnQueryTextListener(android.widget.SearchView.OnQueryTextListener listener)
  ///
  /// Sets a listener for user actions within the SearchView.
  ///@param listener the listener object that receives callbacks when the user performs
  /// actions in the SearchView such as clicking on buttons or typing a query.
  void setOnQueryTextListener(SearchView_OnQueryTextListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnQueryTextListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnCloseListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnCloseListener", "(Landroid/widget/SearchView\$OnCloseListener;)V");

  /// from: public void setOnCloseListener(android.widget.SearchView.OnCloseListener listener)
  ///
  /// Sets a listener to inform when the user closes the SearchView.
  ///@param listener the listener to call when the user closes the SearchView.
  void setOnCloseListener(SearchView_OnCloseListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnCloseListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnQueryTextFocusChangeListener =
      jniAccessors.getMethodIDOf(_classRef, "setOnQueryTextFocusChangeListener",
          "(Landroid/view/View\$OnFocusChangeListener;)V");

  /// from: public void setOnQueryTextFocusChangeListener(android.view.View.OnFocusChangeListener listener)
  ///
  /// Sets a listener to inform when the focus of the query text field changes.
  ///@param listener the listener to inform of focus changes.
  void setOnQueryTextFocusChangeListener(
          view_.View_OnFocusChangeListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnQueryTextFocusChangeListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setOnSuggestionListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnSuggestionListener",
      "(Landroid/widget/SearchView\$OnSuggestionListener;)V");

  /// from: public void setOnSuggestionListener(android.widget.SearchView.OnSuggestionListener listener)
  ///
  /// Sets a listener to inform when a suggestion is focused or clicked.
  ///@param listener the listener to inform of suggestion selection events.
  void setOnSuggestionListener(SearchView_OnSuggestionListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnSuggestionListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnSearchClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnSearchClickListener",
      "(Landroid/view/View\$OnClickListener;)V");

  /// from: public void setOnSearchClickListener(android.view.View.OnClickListener listener)
  ///
  /// Sets a listener to inform when the search button is pressed. This is only
  /// relevant when the text field is not visible by default. Calling \#setIconified setIconified(false) can also cause this listener to be informed.
  ///@param listener the listener to inform when the search button is clicked or
  /// the text field is programmatically de-iconified.
  void setOnSearchClickListener(view_.View_OnClickListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnSearchClickListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_getQuery = jniAccessors.getMethodIDOf(
      _classRef, "getQuery", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getQuery()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the query string currently in the text field.
  ///@return the query string
  jni.JniObject getQuery() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getQuery, jni.JniType.objectType, []).object);

  static final _id_setQuery = jniAccessors.getMethodIDOf(
      _classRef, "setQuery", "(Ljava/lang/CharSequence;Z)V");

  /// from: public void setQuery(java.lang.CharSequence query, boolean submit)
  ///
  /// Sets a query string in the text field and optionally submits the query as well.
  ///@param query the query string. This replaces any query text already present in the
  /// text field.
  ///@param submit whether to submit the query right now or only update the contents of
  /// text field.
  void setQuery(jni.JniObject query, bool submit) =>
      jniAccessors.callMethodWithArgs(reference, _id_setQuery,
          jni.JniType.voidType, [query.reference, submit]).check();

  static final _id_setQueryHint = jniAccessors.getMethodIDOf(
      _classRef, "setQueryHint", "(Ljava/lang/CharSequence;)V");

  /// from: public void setQueryHint(java.lang.CharSequence hint)
  ///
  /// Sets the hint text to display in the query text field. This overrides
  /// any hint specified in the SearchableInfo.
  ///
  /// This value may be specified as an empty string to prevent any query hint
  /// from being displayed.
  ///@param hint the hint text to display or {@code null} to clear
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#SearchView_queryHint
  void setQueryHint(jni.JniObject hint) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setQueryHint,
      jni.JniType.voidType,
      [hint.reference]).check();

  static final _id_getQueryHint = jniAccessors.getMethodIDOf(
      _classRef, "getQueryHint", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getQueryHint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the hint text that will be displayed in the query text field.
  ///
  /// The displayed query hint is chosen in the following order:
  /// <ol>
  /// <li>Non-null value set with \#setQueryHint(CharSequence)
  /// <li>Value specified in XML using
  ///     android.R.styleable\#SearchView_queryHint android:queryHint
  /// <li>Valid string resource ID exposed by the SearchableInfo via
  ///     SearchableInfo\#getHintId()
  /// <li>Default hint provided by the theme against which the view was
  ///     inflated
  /// </ol>
  ///@return the displayed query hint text, or {@code null} if none set
  ///@attr ref android.R.styleable\#SearchView_queryHint
  jni.JniObject getQueryHint() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getQueryHint, jni.JniType.objectType, []).object);

  static final _id_setIconifiedByDefault =
      jniAccessors.getMethodIDOf(_classRef, "setIconifiedByDefault", "(Z)V");

  /// from: public void setIconifiedByDefault(boolean iconified)
  ///
  /// Sets the default or resting state of the search field. If true, a single search icon is
  /// shown by default and expands to show the text field and other buttons when pressed. Also,
  /// if the default state is iconified, then it collapses to that state when the close button
  /// is pressed. Changes to this property will take effect immediately.
  ///
  /// The default value is true.
  ///
  ///@param iconified whether the search field should be iconified by default
  ///@attr ref android.R.styleable\#SearchView_iconifiedByDefault
  void setIconifiedByDefault(bool iconified) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIconifiedByDefault,
      jni.JniType.voidType,
      [iconified]).check();

  static final _id_isIconfiedByDefault =
      jniAccessors.getMethodIDOf(_classRef, "isIconfiedByDefault", "()Z");

  /// from: public boolean isIconfiedByDefault()
  ///
  /// Returns the default iconified state of the search field.
  ///@return
  ///@attr ref android.R.styleable\#SearchView_iconifiedByDefault
  bool isIconfiedByDefault() => jniAccessors.callMethodWithArgs(
      reference, _id_isIconfiedByDefault, jni.JniType.booleanType, []).boolean;

  static final _id_setIconified =
      jniAccessors.getMethodIDOf(_classRef, "setIconified", "(Z)V");

  /// from: public void setIconified(boolean iconify)
  ///
  /// Iconifies or expands the SearchView. Any query text is cleared when iconified. This is
  /// a temporary state and does not override the default iconified state set by
  /// \#setIconifiedByDefault(boolean). If the default state is iconified, then
  /// a false here will only be valid until the user closes the field. And if the default
  /// state is expanded, then a true here will only clear the text field and not close it.
  ///@param iconify a true value will collapse the SearchView to an icon, while a false will
  /// expand it.
  void setIconified(bool iconify) => jniAccessors.callMethodWithArgs(
      reference, _id_setIconified, jni.JniType.voidType, [iconify]).check();

  static final _id_isIconified =
      jniAccessors.getMethodIDOf(_classRef, "isIconified", "()Z");

  /// from: public boolean isIconified()
  ///
  /// Returns the current iconified state of the SearchView.
  ///@return true if the SearchView is currently iconified, false if the search field is
  /// fully visible.
  bool isIconified() => jniAccessors.callMethodWithArgs(
      reference, _id_isIconified, jni.JniType.booleanType, []).boolean;

  static final _id_setSubmitButtonEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setSubmitButtonEnabled", "(Z)V");

  /// from: public void setSubmitButtonEnabled(boolean enabled)
  ///
  /// Enables showing a submit button when the query is non-empty. In cases where the SearchView
  /// is being used to filter the contents of the current activity and doesn't launch a separate
  /// results activity, then the submit button should be disabled.
  ///@param enabled true to show a submit button for submitting queries, false if a submit
  /// button is not required.
  void setSubmitButtonEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSubmitButtonEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_isSubmitButtonEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isSubmitButtonEnabled", "()Z");

  /// from: public boolean isSubmitButtonEnabled()
  ///
  /// Returns whether the submit button is enabled when necessary or never displayed.
  ///@return whether the submit button is enabled automatically when necessary
  bool isSubmitButtonEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isSubmitButtonEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setQueryRefinementEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setQueryRefinementEnabled", "(Z)V");

  /// from: public void setQueryRefinementEnabled(boolean enable)
  ///
  /// Specifies if a query refinement button should be displayed alongside each suggestion
  /// or if it should depend on the flags set in the individual items retrieved from the
  /// suggestions provider. Clicking on the query refinement button will replace the text
  /// in the query text field with the text from the suggestion. This flag only takes effect
  /// if a SearchableInfo has been specified with \#setSearchableInfo(SearchableInfo)
  /// and not when using a custom adapter.
  ///@param enable true if all items should have a query refinement button, false if only
  /// those items that have a query refinement flag set should have the button.
  ///@see SearchManager\#SUGGEST_COLUMN_FLAGS
  ///@see SearchManager\#FLAG_QUERY_REFINEMENT
  void setQueryRefinementEnabled(bool enable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setQueryRefinementEnabled,
          jni.JniType.voidType, [enable]).check();

  static final _id_isQueryRefinementEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isQueryRefinementEnabled", "()Z");

  /// from: public boolean isQueryRefinementEnabled()
  ///
  /// Returns whether query refinement is enabled for all items or only specific ones.
  ///@return true if enabled for all items, false otherwise.
  bool isQueryRefinementEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isQueryRefinementEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setSuggestionsAdapter = jniAccessors.getMethodIDOf(
      _classRef, "setSuggestionsAdapter", "(Landroid/widget/CursorAdapter;)V");

  /// from: public void setSuggestionsAdapter(android.widget.CursorAdapter adapter)
  ///
  /// You can set a custom adapter if you wish. Otherwise the default adapter is used to
  /// display the suggestions from the suggestions provider associated with the SearchableInfo.
  ///@see \#setSearchableInfo(SearchableInfo)
  void setSuggestionsAdapter(cursoradapter_.CursorAdapter adapter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSuggestionsAdapter,
          jni.JniType.voidType, [adapter.reference]).check();

  static final _id_getSuggestionsAdapter = jniAccessors.getMethodIDOf(
      _classRef, "getSuggestionsAdapter", "()Landroid/widget/CursorAdapter;");

  /// from: public android.widget.CursorAdapter getSuggestionsAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the adapter used for suggestions, if any.
  ///@return the suggestions adapter
  cursoradapter_.CursorAdapter getSuggestionsAdapter() =>
      cursoradapter_.CursorAdapter.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSuggestionsAdapter,
          jni.JniType.objectType, []).object);

  static final _id_setMaxWidth =
      jniAccessors.getMethodIDOf(_classRef, "setMaxWidth", "(I)V");

  /// from: public void setMaxWidth(int maxpixels)
  ///
  /// Makes the view at most this many pixels wide
  ///@attr ref android.R.styleable\#SearchView_maxWidth
  void setMaxWidth(int maxpixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxWidth, jni.JniType.voidType, [maxpixels]).check();

  static final _id_getMaxWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMaxWidth", "()I");

  /// from: public int getMaxWidth()
  ///
  /// Gets the specified maximum width in pixels, if set. Returns zero if
  /// no maximum width was specified.
  ///@return the maximum width of the view
  ///@attr ref android.R.styleable\#SearchView_maxWidth
  int getMaxWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxWidth, jni.JniType.intType, []).integer;

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int left, int top, int right, int bottom)
  void onLayout(bool changed, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, left, top, right, bottom]).check();

  static final _id_onDetachedFromWindow1 =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow1() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow1, jni.JniType.voidType, []).check();

  static final _id_onKeyDown1 = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  ///
  /// Handles the key down event for dealing with action keys.
  ///@param keyCode This is the keycode of the typed key, and is the same value as
  ///        found in the KeyEvent parameter.
  ///@param event The complete event record for the typed key
  ///@return true if the event was handled here, or false if not.
  bool onKeyDown1(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown1,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onWindowFocusChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasWindowFocus)
  void onWindowFocusChanged1(bool hasWindowFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowFocusChanged1,
          jni.JniType.voidType, [hasWindowFocus]).check();

  static final _id_onActionViewCollapsed =
      jniAccessors.getMethodIDOf(_classRef, "onActionViewCollapsed", "()V");

  /// from: public void onActionViewCollapsed()
  ///
  /// {@inheritDoc}
  void onActionViewCollapsed() => jniAccessors.callMethodWithArgs(
      reference, _id_onActionViewCollapsed, jni.JniType.voidType, []).check();

  static final _id_onActionViewExpanded =
      jniAccessors.getMethodIDOf(_classRef, "onActionViewExpanded", "()V");

  /// from: public void onActionViewExpanded()
  ///
  /// {@inheritDoc}
  void onActionViewExpanded() => jniAccessors.callMethodWithArgs(
      reference, _id_onActionViewExpanded, jni.JniType.voidType, []).check();

  static final _id_onSaveInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: protected android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  parcelable_.Parcelable onSaveInstanceState1() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState1, jni.JniType.objectType, []).object);

  static final _id_onRestoreInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: protected void onRestoreInstanceState(android.os.Parcelable state)
  void onRestoreInstanceState1(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState1,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);
}

/// from: android.widget.SearchView$OnSuggestionListener
///
/// Callback interface for selection events on suggestions. These callbacks
/// are only relevant when a SearchableInfo has been specified by \#setSearchableInfo.
class SearchView_OnSuggestionListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/SearchView\$OnSuggestionListener");
  SearchView_OnSuggestionListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onSuggestionSelect =
      jniAccessors.getMethodIDOf(_classRef, "onSuggestionSelect", "(I)Z");

  /// from: public abstract boolean onSuggestionSelect(int position)
  ///
  /// Called when a suggestion was selected by navigating to it.
  ///@param position the absolute position in the list of suggestions.
  ///@return true if the listener handles the event and wants to override the default
  /// behavior of possibly rewriting the query based on the selected item, false otherwise.
  bool onSuggestionSelect(int position) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSuggestionSelect,
      jni.JniType.booleanType,
      [position]).boolean;

  static final _id_onSuggestionClick =
      jniAccessors.getMethodIDOf(_classRef, "onSuggestionClick", "(I)Z");

  /// from: public abstract boolean onSuggestionClick(int position)
  ///
  /// Called when a suggestion was clicked.
  ///@param position the absolute position of the clicked item in the list of suggestions.
  ///@return true if the listener handles the event and wants to override the default
  /// behavior of launching any intent or submitting a search query specified on that item.
  /// Return false otherwise.
  bool onSuggestionClick(int position) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSuggestionClick,
      jni.JniType.booleanType,
      [position]).boolean;
}

/// from: android.widget.SearchView$OnQueryTextListener
///
/// Callbacks for changes to the query text.
class SearchView_OnQueryTextListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/SearchView\$OnQueryTextListener");
  SearchView_OnQueryTextListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onQueryTextSubmit = jniAccessors.getMethodIDOf(
      _classRef, "onQueryTextSubmit", "(Ljava/lang/String;)Z");

  /// from: public abstract boolean onQueryTextSubmit(java.lang.String query)
  ///
  /// Called when the user submits the query. This could be due to a key press on the
  /// keyboard or due to pressing a submit button.
  /// The listener can override the standard behavior by returning true
  /// to indicate that it has handled the submit request. Otherwise return false to
  /// let the SearchView handle the submission by launching any associated intent.
  ///@param query the query text that is to be submitted
  ///@return true if the query has been handled by the listener, false to let the
  /// SearchView perform the default action.
  bool onQueryTextSubmit(jni.JniString query) =>
      jniAccessors.callMethodWithArgs(reference, _id_onQueryTextSubmit,
          jni.JniType.booleanType, [query.reference]).boolean;

  static final _id_onQueryTextChange = jniAccessors.getMethodIDOf(
      _classRef, "onQueryTextChange", "(Ljava/lang/String;)Z");

  /// from: public abstract boolean onQueryTextChange(java.lang.String newText)
  ///
  /// Called when the query text is changed by the user.
  ///@param newText the new content of the query text field.
  ///@return false if the SearchView should perform the default action of showing any
  /// suggestions if available, true if the action was handled by the listener.
  bool onQueryTextChange(jni.JniString newText) =>
      jniAccessors.callMethodWithArgs(reference, _id_onQueryTextChange,
          jni.JniType.booleanType, [newText.reference]).boolean;
}

/// from: android.widget.SearchView$OnCloseListener
class SearchView_OnCloseListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/SearchView\$OnCloseListener");
  SearchView_OnCloseListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onClose =
      jniAccessors.getMethodIDOf(_classRef, "onClose", "()Z");

  /// from: public abstract boolean onClose()
  ///
  /// The user is attempting to close the SearchView.
  ///@return true if the listener wants to override the default behavior of clearing the
  /// text field and dismissing it, false otherwise.
  bool onClose() => jniAccessors.callMethodWithArgs(
      reference, _id_onClose, jni.JniType.booleanType, []).boolean;
}
