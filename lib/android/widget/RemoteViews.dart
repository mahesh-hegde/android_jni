// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;

import "../net/Uri.dart" as uri_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../graphics/drawable/Icon.dart" as icon_;

import "../app/PendingIntent.dart" as pendingintent_;

import "../content/Intent.dart" as intent_;

import "../os/Bundle.dart" as bundle_;

import "../view/View.dart" as view_;

import "../content/Context.dart" as context_;

import "../view/ViewGroup.dart" as viewgroup_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.RemoteViews
///
/// A class that describes a view hierarchy that can be displayed in
/// another process. The hierarchy is inflated from a layout resource
/// file, and this class provides some basic operations for modifying
/// the content of the inflated hierarchy.
///
/// {@code RemoteViews} is limited to support for the following layouts:
///
/// <ul>
///   <li>android.widget.AdapterViewFlipper</li>
///   <li>android.widget.FrameLayout</li>
///   <li>android.widget.GridLayout</li>
///   <li>android.widget.GridView</li>
///   <li>android.widget.LinearLayout</li>
///   <li>android.widget.ListView</li>
///   <li>android.widget.RelativeLayout</li>
///   <li>android.widget.StackView</li>
///   <li>android.widget.ViewFlipper</li>
/// </ul>
/// And the following widgets:
///
/// <ul>
///   <li>android.widget.AnalogClock</li>
///   <li>android.widget.Button</li>
///   <li>android.widget.Chronometer</li>
///   <li>android.widget.ImageButton</li>
///   <li>android.widget.ImageView</li>
///   <li>android.widget.ProgressBar</li>
///   <li>android.widget.TextClock</li>
///   <li>android.widget.TextView</li>
/// </ul>
/// Descendants of these classes are not supported.
///
class RemoteViews extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/RemoteViews");
  RemoteViews.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.widget.RemoteViews> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parcelable.Creator that instantiates RemoteViews objects
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;I)V");

  /// from: public void <init>(java.lang.String packageName, int layoutId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new RemoteViews object that will display the views contained
  /// in the specified layout file.
  ///@param packageName Name of the package that contains the layout resource
  ///@param layoutId The id of the layout resource
  RemoteViews(jni.JniString packageName, int layoutId)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [packageName.reference, layoutId]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/widget/RemoteViews;Landroid/widget/RemoteViews;)V");

  /// from: public void <init>(android.widget.RemoteViews landscape, android.widget.RemoteViews portrait)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new RemoteViews object that will inflate as the specified
  /// landspace or portrait RemoteViews, depending on the current configuration.
  ///@param landscape The RemoteViews to inflate in landscape configuration
  ///@param portrait The RemoteViews to inflate in portrait configuration
  RemoteViews.ctor1(RemoteViews landscape, RemoteViews portrait)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [landscape.reference, portrait.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/widget/RemoteViews;)V");

  /// from: public void <init>(android.widget.RemoteViews src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a copy of another RemoteViews.
  RemoteViews.ctor2(RemoteViews src)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [src.reference]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel parcel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reads a RemoteViews object from a parcel.
  ///@param parcel
  RemoteViews.ctor3(parcel_.Parcel parcel)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [parcel.reference]).object);

  static final _id_clone = jniAccessors.getMethodIDOf(
      _classRef, "clone", "()Landroid/widget/RemoteViews;");

  /// from: public android.widget.RemoteViews clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a deep copy of the RemoteViews object. The RemoteView may not be
  /// attached to another RemoteView -- it must be the root of a hierarchy.
  ///@deprecated use \#RemoteViews(RemoteViews) instead.
  ///@throws IllegalStateException if this is not the root of a RemoteView
  ///         hierarchy
  RemoteViews clone() => RemoteViews.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_getPackage = jniAccessors.getMethodIDOf(
      _classRef, "getPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPackage, jni.JniType.objectType, []).object);

  static final _id_getLayoutId =
      jniAccessors.getMethodIDOf(_classRef, "getLayoutId", "()I");

  /// from: public int getLayoutId()
  ///
  /// Returns the layout id of the root layout associated with this RemoteViews. In the case
  /// that the RemoteViews has both a landscape and portrait root, this will return the layout
  /// id associated with the portrait layout.
  ///@return the layout id.
  int getLayoutId() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayoutId, jni.JniType.intType, []).integer;

  static final _id_addView = jniAccessors.getMethodIDOf(
      _classRef, "addView", "(ILandroid/widget/RemoteViews;)V");

  /// from: public void addView(int viewId, android.widget.RemoteViews nestedView)
  ///
  /// Equivalent to calling ViewGroup\#addView(View) after inflating the
  /// given RemoteViews. This allows users to build "nested"
  /// RemoteViews. In cases where consumers of RemoteViews may
  /// recycle layouts, use \#removeAllViews(int) to clear any existing
  /// children.
  ///@param viewId The id of the parent ViewGroup to add child into.
  ///@param nestedView RemoteViews that describes the child.
  void addView(int viewId, RemoteViews nestedView) =>
      jniAccessors.callMethodWithArgs(reference, _id_addView,
          jni.JniType.voidType, [viewId, nestedView.reference]).check();

  static final _id_removeAllViews =
      jniAccessors.getMethodIDOf(_classRef, "removeAllViews", "(I)V");

  /// from: public void removeAllViews(int viewId)
  ///
  /// Equivalent to calling ViewGroup\#removeAllViews().
  ///@param viewId The id of the parent ViewGroup to remove all
  ///            children from.
  void removeAllViews(int viewId) => jniAccessors.callMethodWithArgs(
      reference, _id_removeAllViews, jni.JniType.voidType, [viewId]).check();

  static final _id_showNext =
      jniAccessors.getMethodIDOf(_classRef, "showNext", "(I)V");

  /// from: public void showNext(int viewId)
  ///
  /// Equivalent to calling AdapterViewAnimator\#showNext()
  ///@param viewId The id of the view on which to call AdapterViewAnimator\#showNext()
  void showNext(int viewId) => jniAccessors.callMethodWithArgs(
      reference, _id_showNext, jni.JniType.voidType, [viewId]).check();

  static final _id_showPrevious =
      jniAccessors.getMethodIDOf(_classRef, "showPrevious", "(I)V");

  /// from: public void showPrevious(int viewId)
  ///
  /// Equivalent to calling AdapterViewAnimator\#showPrevious()
  ///@param viewId The id of the view on which to call AdapterViewAnimator\#showPrevious()
  void showPrevious(int viewId) => jniAccessors.callMethodWithArgs(
      reference, _id_showPrevious, jni.JniType.voidType, [viewId]).check();

  static final _id_setDisplayedChild =
      jniAccessors.getMethodIDOf(_classRef, "setDisplayedChild", "(II)V");

  /// from: public void setDisplayedChild(int viewId, int childIndex)
  ///
  /// Equivalent to calling AdapterViewAnimator\#setDisplayedChild(int)
  ///@param viewId The id of the view on which to call
  ///               AdapterViewAnimator\#setDisplayedChild(int)
  void setDisplayedChild(int viewId, int childIndex) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisplayedChild,
          jni.JniType.voidType, [viewId, childIndex]).check();

  static final _id_setViewVisibility =
      jniAccessors.getMethodIDOf(_classRef, "setViewVisibility", "(II)V");

  /// from: public void setViewVisibility(int viewId, int visibility)
  ///
  /// Equivalent to calling View\#setVisibility(int)
  ///@param viewId The id of the view whose visibility should change
  ///@param visibility The new visibility for the view
  void setViewVisibility(int viewId, int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_setViewVisibility,
          jni.JniType.voidType, [viewId, visibility]).check();

  static final _id_setTextViewText = jniAccessors.getMethodIDOf(
      _classRef, "setTextViewText", "(ILjava/lang/CharSequence;)V");

  /// from: public void setTextViewText(int viewId, java.lang.CharSequence text)
  ///
  /// Equivalent to calling TextView\#setText(CharSequence)
  ///@param viewId The id of the view whose text should change
  ///@param text The new text for the view
  void setTextViewText(int viewId, jni.JniObject text) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextViewText,
          jni.JniType.voidType, [viewId, text.reference]).check();

  static final _id_setTextViewTextSize =
      jniAccessors.getMethodIDOf(_classRef, "setTextViewTextSize", "(IIF)V");

  /// from: public void setTextViewTextSize(int viewId, int units, float size)
  ///
  /// Equivalent to calling TextView\#setTextSize(int, float)
  ///@param viewId The id of the view whose text size should change
  ///@param units The units of size (e.g.&nbsp;COMPLEX_UNIT_SP)
  ///@param size The size of the text
  void setTextViewTextSize(int viewId, int units, double size) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextViewTextSize,
          jni.JniType.voidType, [viewId, units, size]).check();

  static final _id_setTextViewCompoundDrawables = jniAccessors.getMethodIDOf(
      _classRef, "setTextViewCompoundDrawables", "(IIIII)V");

  /// from: public void setTextViewCompoundDrawables(int viewId, int left, int top, int right, int bottom)
  ///
  /// Equivalent to calling
  /// TextView\#setCompoundDrawablesWithIntrinsicBounds(int, int, int, int).
  ///@param viewId The id of the view whose text should change
  ///@param left The id of a drawable to place to the left of the text, or 0
  ///@param top The id of a drawable to place above the text, or 0
  ///@param right The id of a drawable to place to the right of the text, or 0
  ///@param bottom The id of a drawable to place below the text, or 0
  void setTextViewCompoundDrawables(
          int viewId, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTextViewCompoundDrawables,
          jni.JniType.voidType,
          [viewId, left, top, right, bottom]).check();

  static final _id_setTextViewCompoundDrawablesRelative =
      jniAccessors.getMethodIDOf(
          _classRef, "setTextViewCompoundDrawablesRelative", "(IIIII)V");

  /// from: public void setTextViewCompoundDrawablesRelative(int viewId, int start, int top, int end, int bottom)
  ///
  /// Equivalent to calling TextView\#setCompoundDrawablesRelativeWithIntrinsicBounds(int, int, int, int).
  ///@param viewId The id of the view whose text should change
  ///@param start The id of a drawable to place before the text (relative to the
  /// layout direction), or 0
  ///@param top The id of a drawable to place above the text, or 0
  ///@param end The id of a drawable to place after the text, or 0
  ///@param bottom The id of a drawable to place below the text, or 0
  void setTextViewCompoundDrawablesRelative(
          int viewId, int start, int top, int end, int bottom) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTextViewCompoundDrawablesRelative,
          jni.JniType.voidType,
          [viewId, start, top, end, bottom]).check();

  static final _id_setImageViewResource =
      jniAccessors.getMethodIDOf(_classRef, "setImageViewResource", "(II)V");

  /// from: public void setImageViewResource(int viewId, int srcId)
  ///
  /// Equivalent to calling ImageView\#setImageResource(int)
  ///@param viewId The id of the view whose drawable should change
  ///@param srcId The new resource id for the drawable
  void setImageViewResource(int viewId, int srcId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImageViewResource,
          jni.JniType.voidType, [viewId, srcId]).check();

  static final _id_setImageViewUri = jniAccessors.getMethodIDOf(
      _classRef, "setImageViewUri", "(ILandroid/net/Uri;)V");

  /// from: public void setImageViewUri(int viewId, android.net.Uri uri)
  ///
  /// Equivalent to calling ImageView\#setImageURI(Uri)
  ///@param viewId The id of the view whose drawable should change
  ///@param uri The Uri for the image
  void setImageViewUri(int viewId, uri_.Uri uri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImageViewUri,
          jni.JniType.voidType, [viewId, uri.reference]).check();

  static final _id_setImageViewBitmap = jniAccessors.getMethodIDOf(
      _classRef, "setImageViewBitmap", "(ILandroid/graphics/Bitmap;)V");

  /// from: public void setImageViewBitmap(int viewId, android.graphics.Bitmap bitmap)
  ///
  /// Equivalent to calling ImageView\#setImageBitmap(Bitmap)
  ///@param viewId The id of the view whose bitmap should change
  ///@param bitmap The new Bitmap for the drawable
  void setImageViewBitmap(int viewId, bitmap_.Bitmap bitmap) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImageViewBitmap,
          jni.JniType.voidType, [viewId, bitmap.reference]).check();

  static final _id_setImageViewIcon = jniAccessors.getMethodIDOf(
      _classRef, "setImageViewIcon", "(ILandroid/graphics/drawable/Icon;)V");

  /// from: public void setImageViewIcon(int viewId, android.graphics.drawable.Icon icon)
  ///
  /// Equivalent to calling ImageView\#setImageIcon(Icon)
  ///@param viewId The id of the view whose bitmap should change
  ///@param icon The new Icon for the ImageView
  void setImageViewIcon(int viewId, icon_.Icon icon) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImageViewIcon,
          jni.JniType.voidType, [viewId, icon.reference]).check();

  static final _id_setEmptyView =
      jniAccessors.getMethodIDOf(_classRef, "setEmptyView", "(II)V");

  /// from: public void setEmptyView(int viewId, int emptyViewId)
  ///
  /// Equivalent to calling AdapterView\#setEmptyView(View)
  ///@param viewId The id of the view on which to set the empty view
  ///@param emptyViewId The view id of the empty view
  void setEmptyView(int viewId, int emptyViewId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEmptyView,
          jni.JniType.voidType, [viewId, emptyViewId]).check();

  static final _id_setChronometer = jniAccessors.getMethodIDOf(
      _classRef, "setChronometer", "(IJLjava/lang/String;Z)V");

  /// from: public void setChronometer(int viewId, long base, java.lang.String format, boolean started)
  ///
  /// Equivalent to calling Chronometer\#setBase Chronometer.setBase,
  /// Chronometer\#setFormat Chronometer.setFormat,
  /// and Chronometer\#start Chronometer.start() or
  /// Chronometer\#stop Chronometer.stop().
  ///@param viewId The id of the Chronometer to change
  ///@param base The time at which the timer would have read 0:00.  This
  ///             time should be based off of
  ///             android.os.SystemClock\#elapsedRealtime SystemClock.elapsedRealtime().
  ///@param format The Chronometer format string, or null to
  ///               simply display the timer value.
  ///@param started True if you want the clock to be started, false if not.
  ///@see \#setChronometerCountDown(int, boolean)
  void setChronometer(
          int viewId, int base, jni.JniString format, bool started) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setChronometer,
          jni.JniType.voidType,
          [viewId, base, format.reference, started]).check();

  static final _id_setChronometerCountDown =
      jniAccessors.getMethodIDOf(_classRef, "setChronometerCountDown", "(IZ)V");

  /// from: public void setChronometerCountDown(int viewId, boolean isCountDown)
  ///
  /// Equivalent to calling Chronometer\#setCountDown(boolean) Chronometer.setCountDown on
  /// the chronometer with the given viewId.
  ///@param viewId The id of the Chronometer to change
  ///@param isCountDown True if you want the chronometer to count down to base instead of
  ///                    counting up.
  void setChronometerCountDown(int viewId, bool isCountDown) =>
      jniAccessors.callMethodWithArgs(reference, _id_setChronometerCountDown,
          jni.JniType.voidType, [viewId, isCountDown]).check();

  static final _id_setProgressBar =
      jniAccessors.getMethodIDOf(_classRef, "setProgressBar", "(IIIZ)V");

  /// from: public void setProgressBar(int viewId, int max, int progress, boolean indeterminate)
  ///
  /// Equivalent to calling ProgressBar\#setMax ProgressBar.setMax,
  /// ProgressBar\#setProgress ProgressBar.setProgress, and
  /// ProgressBar\#setIndeterminate ProgressBar.setIndeterminate
  ///
  /// If indeterminate is true, then the values for max and progress are ignored.
  ///@param viewId The id of the ProgressBar to change
  ///@param max The 100% value for the progress bar
  ///@param progress The current value of the progress bar.
  ///@param indeterminate True if the progress bar is indeterminate,
  ///                false if not.
  void setProgressBar(int viewId, int max, int progress, bool indeterminate) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProgressBar,
          jni.JniType.voidType, [viewId, max, progress, indeterminate]).check();

  static final _id_setOnClickPendingIntent = jniAccessors.getMethodIDOf(
      _classRef, "setOnClickPendingIntent", "(ILandroid/app/PendingIntent;)V");

  /// from: public void setOnClickPendingIntent(int viewId, android.app.PendingIntent pendingIntent)
  ///
  /// Equivalent to calling
  /// android.view.View\#setOnClickListener(android.view.View.OnClickListener)
  /// to launch the provided PendingIntent. The source bounds
  /// (Intent\#getSourceBounds()) of the intent will be set to the bounds of the clicked
  /// view in screen space.
  /// Note that any activity options associated with the pendingIntent may get overridden
  /// before starting the intent.
  ///
  /// When setting the on-click action of items within collections (eg. ListView,
  /// StackView etc.), this method will not work. Instead, use RemoteViews\#setPendingIntentTemplate(int, PendingIntent) in conjunction with
  /// RemoteViews\#setOnClickFillInIntent(int, Intent).
  ///@param viewId The id of the view that will trigger the PendingIntent when clicked
  ///@param pendingIntent The PendingIntent to send when user clicks
  void setOnClickPendingIntent(
          int viewId, pendingintent_.PendingIntent pendingIntent) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnClickPendingIntent,
          jni.JniType.voidType, [viewId, pendingIntent.reference]).check();

  static final _id_setPendingIntentTemplate = jniAccessors.getMethodIDOf(
      _classRef, "setPendingIntentTemplate", "(ILandroid/app/PendingIntent;)V");

  /// from: public void setPendingIntentTemplate(int viewId, android.app.PendingIntent pendingIntentTemplate)
  ///
  /// When using collections (eg. ListView, StackView etc.) in widgets, it is very
  /// costly to set PendingIntents on the individual items, and is hence not permitted. Instead
  /// this method should be used to set a single PendingIntent template on the collection, and
  /// individual items can differentiate their on-click behavior using
  /// RemoteViews\#setOnClickFillInIntent(int, Intent).
  ///@param viewId The id of the collection who's children will use this PendingIntent template
  ///          when clicked
  ///@param pendingIntentTemplate The PendingIntent to be combined with extras specified
  ///          by a child of viewId and executed when that child is clicked
  void setPendingIntentTemplate(
          int viewId, pendingintent_.PendingIntent pendingIntentTemplate) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPendingIntentTemplate,
          jni.JniType.voidType,
          [viewId, pendingIntentTemplate.reference]).check();

  static final _id_setOnClickFillInIntent = jniAccessors.getMethodIDOf(
      _classRef, "setOnClickFillInIntent", "(ILandroid/content/Intent;)V");

  /// from: public void setOnClickFillInIntent(int viewId, android.content.Intent fillInIntent)
  ///
  /// When using collections (eg. ListView, StackView etc.) in widgets, it is very
  /// costly to set PendingIntents on the individual items, and is hence not permitted. Instead
  /// a single PendingIntent template can be set on the collection, see RemoteViews\#setPendingIntentTemplate(int, PendingIntent), and the individual on-click
  /// action of a given item can be distinguished by setting a fillInIntent on that item. The
  /// fillInIntent is then combined with the PendingIntent template in order to determine the final
  /// intent which will be executed when the item is clicked. This works as follows: any fields
  /// which are left blank in the PendingIntent template, but are provided by the fillInIntent
  /// will be overwritten, and the resulting PendingIntent will be used. The rest
  /// of the PendingIntent template will then be filled in with the associated fields that are
  /// set in fillInIntent. See Intent\#fillIn(Intent, int) for more details.
  ///@param viewId The id of the view on which to set the fillInIntent
  ///@param fillInIntent The intent which will be combined with the parent's PendingIntent
  ///        in order to determine the on-click behavior of the view specified by viewId
  void setOnClickFillInIntent(int viewId, intent_.Intent fillInIntent) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnClickFillInIntent,
          jni.JniType.voidType, [viewId, fillInIntent.reference]).check();

  static final _id_setTextColor =
      jniAccessors.getMethodIDOf(_classRef, "setTextColor", "(II)V");

  /// from: public void setTextColor(int viewId, int color)
  ///
  /// Equivalent to calling android.widget.TextView\#setTextColor(int).
  ///@param viewId The id of the view whose text color should change
  ///@param color Sets the text color for all the states (normal, selected,
  ///            focused) to be this color.
  void setTextColor(int viewId, int color) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextColor,
      jni.JniType.voidType,
      [viewId, color]).check();

  static final _id_setRemoteAdapter = jniAccessors.getMethodIDOf(
      _classRef, "setRemoteAdapter", "(IILandroid/content/Intent;)V");

  /// from: public void setRemoteAdapter(int appWidgetId, int viewId, android.content.Intent intent)
  ///
  /// Equivalent to calling android.widget.AbsListView\#setRemoteViewsAdapter(Intent).
  ///@param appWidgetId The id of the app widget which contains the specified view. (This
  ///      parameter is ignored in this deprecated method)
  ///@param viewId The id of the AdapterView
  ///@param intent The intent of the service which will be
  ///            providing data to the RemoteViewsAdapter
  ///@deprecated This method has been deprecated. See
  ///      android.widget.RemoteViews\#setRemoteAdapter(int, Intent)
  void setRemoteAdapter(int appWidgetId, int viewId, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRemoteAdapter,
          jni.JniType.voidType,
          [appWidgetId, viewId, intent.reference]).check();

  static final _id_setRemoteAdapter1 = jniAccessors.getMethodIDOf(
      _classRef, "setRemoteAdapter", "(ILandroid/content/Intent;)V");

  /// from: public void setRemoteAdapter(int viewId, android.content.Intent intent)
  ///
  /// Equivalent to calling android.widget.AbsListView\#setRemoteViewsAdapter(Intent).
  /// Can only be used for App Widgets.
  ///@param viewId The id of the AdapterView
  ///@param intent The intent of the service which will be
  ///            providing data to the RemoteViewsAdapter
  void setRemoteAdapter1(int viewId, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRemoteAdapter1,
          jni.JniType.voidType, [viewId, intent.reference]).check();

  static final _id_setScrollPosition =
      jniAccessors.getMethodIDOf(_classRef, "setScrollPosition", "(II)V");

  /// from: public void setScrollPosition(int viewId, int position)
  ///
  /// Equivalent to calling ListView\#smoothScrollToPosition(int).
  ///@param viewId The id of the view to change
  ///@param position Scroll to this adapter position
  void setScrollPosition(int viewId, int position) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScrollPosition,
          jni.JniType.voidType, [viewId, position]).check();

  static final _id_setRelativeScrollPosition = jniAccessors.getMethodIDOf(
      _classRef, "setRelativeScrollPosition", "(II)V");

  /// from: public void setRelativeScrollPosition(int viewId, int offset)
  ///
  /// Equivalent to calling ListView\#smoothScrollByOffset(int).
  ///@param viewId The id of the view to change
  ///@param offset Scroll by this adapter position offset
  void setRelativeScrollPosition(int viewId, int offset) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRelativeScrollPosition,
          jni.JniType.voidType, [viewId, offset]).check();

  static final _id_setViewPadding =
      jniAccessors.getMethodIDOf(_classRef, "setViewPadding", "(IIIII)V");

  /// from: public void setViewPadding(int viewId, int left, int top, int right, int bottom)
  ///
  /// Equivalent to calling android.view.View\#setPadding(int, int, int, int).
  ///@param viewId The id of the view to change
  ///@param left the left padding in pixels
  ///@param top the top padding in pixels
  ///@param right the right padding in pixels
  ///@param bottom the bottom padding in pixels
  void setViewPadding(int viewId, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setViewPadding,
          jni.JniType.voidType, [viewId, left, top, right, bottom]).check();

  static final _id_setBoolean = jniAccessors.getMethodIDOf(
      _classRef, "setBoolean", "(ILjava/lang/String;Z)V");

  /// from: public void setBoolean(int viewId, java.lang.String methodName, boolean value)
  ///
  /// Call a method taking one boolean on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setBoolean(int viewId, jni.JniString methodName, bool value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBoolean,
          jni.JniType.voidType, [viewId, methodName.reference, value]).check();

  static final _id_setByte = jniAccessors.getMethodIDOf(
      _classRef, "setByte", "(ILjava/lang/String;B)V");

  /// from: public void setByte(int viewId, java.lang.String methodName, byte value)
  ///
  /// Call a method taking one byte on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setByte(int viewId, jni.JniString methodName, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setByte,
          jni.JniType.voidType, [viewId, methodName.reference, value]).check();

  static final _id_setShort = jniAccessors.getMethodIDOf(
      _classRef, "setShort", "(ILjava/lang/String;S)V");

  /// from: public void setShort(int viewId, java.lang.String methodName, short value)
  ///
  /// Call a method taking one short on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setShort(int viewId, jni.JniString methodName, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setShort,
          jni.JniType.voidType, [viewId, methodName.reference, value]).check();

  static final _id_setInt = jniAccessors.getMethodIDOf(
      _classRef, "setInt", "(ILjava/lang/String;I)V");

  /// from: public void setInt(int viewId, java.lang.String methodName, int value)
  ///
  /// Call a method taking one int on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setInt(int viewId, jni.JniString methodName, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInt,
          jni.JniType.voidType, [viewId, methodName.reference, value]).check();

  static final _id_setLong = jniAccessors.getMethodIDOf(
      _classRef, "setLong", "(ILjava/lang/String;J)V");

  /// from: public void setLong(int viewId, java.lang.String methodName, long value)
  ///
  /// Call a method taking one long on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setLong(int viewId, jni.JniString methodName, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLong,
          jni.JniType.voidType, [viewId, methodName.reference, value]).check();

  static final _id_setFloat = jniAccessors.getMethodIDOf(
      _classRef, "setFloat", "(ILjava/lang/String;F)V");

  /// from: public void setFloat(int viewId, java.lang.String methodName, float value)
  ///
  /// Call a method taking one float on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setFloat(int viewId, jni.JniString methodName, double value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFloat,
          jni.JniType.voidType, [viewId, methodName.reference, value]).check();

  static final _id_setDouble = jniAccessors.getMethodIDOf(
      _classRef, "setDouble", "(ILjava/lang/String;D)V");

  /// from: public void setDouble(int viewId, java.lang.String methodName, double value)
  ///
  /// Call a method taking one double on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setDouble(int viewId, jni.JniString methodName, double value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDouble,
          jni.JniType.voidType, [viewId, methodName.reference, value]).check();

  static final _id_setChar = jniAccessors.getMethodIDOf(
      _classRef, "setChar", "(ILjava/lang/String;C)V");

  /// from: public void setChar(int viewId, java.lang.String methodName, char value)
  ///
  /// Call a method taking one char on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setChar(int viewId, jni.JniString methodName, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setChar,
          jni.JniType.voidType, [viewId, methodName.reference, value]).check();

  static final _id_setString = jniAccessors.getMethodIDOf(
      _classRef, "setString", "(ILjava/lang/String;Ljava/lang/String;)V");

  /// from: public void setString(int viewId, java.lang.String methodName, java.lang.String value)
  ///
  /// Call a method taking one String on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setString(int viewId, jni.JniString methodName, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setString,
          jni.JniType.voidType,
          [viewId, methodName.reference, value.reference]).check();

  static final _id_setCharSequence = jniAccessors.getMethodIDOf(_classRef,
      "setCharSequence", "(ILjava/lang/String;Ljava/lang/CharSequence;)V");

  /// from: public void setCharSequence(int viewId, java.lang.String methodName, java.lang.CharSequence value)
  ///
  /// Call a method taking one CharSequence on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setCharSequence(
          int viewId, jni.JniString methodName, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCharSequence,
          jni.JniType.voidType,
          [viewId, methodName.reference, value.reference]).check();

  static final _id_setUri = jniAccessors.getMethodIDOf(
      _classRef, "setUri", "(ILjava/lang/String;Landroid/net/Uri;)V");

  /// from: public void setUri(int viewId, java.lang.String methodName, android.net.Uri value)
  ///
  /// Call a method taking one Uri on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setUri(int viewId, jni.JniString methodName, uri_.Uri value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setUri,
          jni.JniType.voidType,
          [viewId, methodName.reference, value.reference]).check();

  static final _id_setBitmap = jniAccessors.getMethodIDOf(_classRef,
      "setBitmap", "(ILjava/lang/String;Landroid/graphics/Bitmap;)V");

  /// from: public void setBitmap(int viewId, java.lang.String methodName, android.graphics.Bitmap value)
  ///
  /// Call a method taking one Bitmap on a view in the layout for this RemoteViews.
  ///@more <p class="note">The bitmap will be flattened into the parcel if this object is
  /// sent across processes, so it may end up using a lot of memory, and may be fairly slow.
  ///
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setBitmap(int viewId, jni.JniString methodName, bitmap_.Bitmap value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setBitmap,
          jni.JniType.voidType,
          [viewId, methodName.reference, value.reference]).check();

  static final _id_setBundle = jniAccessors.getMethodIDOf(
      _classRef, "setBundle", "(ILjava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void setBundle(int viewId, java.lang.String methodName, android.os.Bundle value)
  ///
  /// Call a method taking one Bundle on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The value to pass to the method.
  void setBundle(int viewId, jni.JniString methodName, bundle_.Bundle value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setBundle,
          jni.JniType.voidType,
          [viewId, methodName.reference, value.reference]).check();

  static final _id_setIntent = jniAccessors.getMethodIDOf(
      _classRef, "setIntent", "(ILjava/lang/String;Landroid/content/Intent;)V");

  /// from: public void setIntent(int viewId, java.lang.String methodName, android.content.Intent value)
  ///
  /// Call a method taking one Intent on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The android.content.Intent to pass the method.
  void setIntent(int viewId, jni.JniString methodName, intent_.Intent value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setIntent,
          jni.JniType.voidType,
          [viewId, methodName.reference, value.reference]).check();

  static final _id_setIcon = jniAccessors.getMethodIDOf(_classRef, "setIcon",
      "(ILjava/lang/String;Landroid/graphics/drawable/Icon;)V");

  /// from: public void setIcon(int viewId, java.lang.String methodName, android.graphics.drawable.Icon value)
  ///
  /// Call a method taking one Icon on a view in the layout for this RemoteViews.
  ///@param viewId The id of the view on which to call the method.
  ///@param methodName The name of the method to call.
  ///@param value The android.graphics.drawable.Icon to pass the method.
  void setIcon(int viewId, jni.JniString methodName, icon_.Icon value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setIcon,
          jni.JniType.voidType,
          [viewId, methodName.reference, value.reference]).check();

  static final _id_setContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "setContentDescription", "(ILjava/lang/CharSequence;)V");

  /// from: public void setContentDescription(int viewId, java.lang.CharSequence contentDescription)
  ///
  /// Equivalent to calling View.setContentDescription(CharSequence).
  ///@param viewId The id of the view whose content description should change.
  ///@param contentDescription The new content description for the view.
  void setContentDescription(int viewId, jni.JniObject contentDescription) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentDescription,
          jni.JniType.voidType, [viewId, contentDescription.reference]).check();

  static final _id_setAccessibilityTraversalBefore = jniAccessors.getMethodIDOf(
      _classRef, "setAccessibilityTraversalBefore", "(II)V");

  /// from: public void setAccessibilityTraversalBefore(int viewId, int nextId)
  ///
  /// Equivalent to calling android.view.View\#setAccessibilityTraversalBefore(int).
  ///@param viewId The id of the view whose before view in accessibility traversal to set.
  ///@param nextId The id of the next in the accessibility traversal.
  void setAccessibilityTraversalBefore(int viewId, int nextId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAccessibilityTraversalBefore,
          jni.JniType.voidType,
          [viewId, nextId]).check();

  static final _id_setAccessibilityTraversalAfter = jniAccessors.getMethodIDOf(
      _classRef, "setAccessibilityTraversalAfter", "(II)V");

  /// from: public void setAccessibilityTraversalAfter(int viewId, int nextId)
  ///
  /// Equivalent to calling android.view.View\#setAccessibilityTraversalAfter(int).
  ///@param viewId The id of the view whose after view in accessibility traversal to set.
  ///@param nextId The id of the next in the accessibility traversal.
  void setAccessibilityTraversalAfter(int viewId, int nextId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAccessibilityTraversalAfter,
          jni.JniType.voidType,
          [viewId, nextId]).check();

  static final _id_setLabelFor =
      jniAccessors.getMethodIDOf(_classRef, "setLabelFor", "(II)V");

  /// from: public void setLabelFor(int viewId, int labeledId)
  ///
  /// Equivalent to calling View\#setLabelFor(int).
  ///@param viewId The id of the view whose property to set.
  ///@param labeledId The id of a view for which this view serves as a label.
  void setLabelFor(int viewId, int labeledId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLabelFor,
          jni.JniType.voidType, [viewId, labeledId]).check();

  static final _id_apply = jniAccessors.getMethodIDOf(_classRef, "apply",
      "(Landroid/content/Context;Landroid/view/ViewGroup;)Landroid/view/View;");

  /// from: public android.view.View apply(android.content.Context context, android.view.ViewGroup parent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inflates the view hierarchy represented by this object and applies
  /// all of the actions.
  ///
  /// <strong>Caller beware: this may throw</strong>
  ///@param context Default context to use
  ///@param parent Parent that the resulting view hierarchy will be attached to. This method
  /// does <strong>not</strong> attach the hierarchy. The caller should do so when appropriate.
  ///@return The inflated view hierarchy
  view_.View apply(context_.Context context, viewgroup_.ViewGroup parent) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_apply,
          jni.JniType.objectType,
          [context.reference, parent.reference]).object);

  static final _id_reapply = jniAccessors.getMethodIDOf(
      _classRef, "reapply", "(Landroid/content/Context;Landroid/view/View;)V");

  /// from: public void reapply(android.content.Context context, android.view.View v)
  ///
  /// Applies all of the actions to the provided view.
  ///
  /// <strong>Caller beware: this may throw</strong>
  ///@param v The view to apply the actions to.  This should be the result of
  /// the \#apply(Context,ViewGroup) call.
  void reapply(context_.Context context, view_.View v) =>
      jniAccessors.callMethodWithArgs(reference, _id_reapply,
          jni.JniType.voidType, [context.reference, v.reference]).check();

  static final _id_onLoadClass = jniAccessors.getMethodIDOf(
      _classRef, "onLoadClass", "(Ljava/lang/Class;)Z");

  /// from: public boolean onLoadClass(java.lang.Class clazz)
  bool onLoadClass(jni.JniObject clazz) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onLoadClass,
      jni.JniType.booleanType,
      [clazz.reference]).boolean;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.widget.RemoteViews$ActionException
///
/// Exception to send when something goes wrong executing an action
class RemoteViews_ActionException extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/RemoteViews\$ActionException");
  RemoteViews_ActionException.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/Exception;)V");

  /// from: public void <init>(java.lang.Exception ex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RemoteViews_ActionException(jni.JniObject ex)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [ex.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RemoteViews_ActionException.ctor1(jni.JniString message)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [message.reference]).object);
}
