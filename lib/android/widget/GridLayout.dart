// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/ViewGroup.dart" as viewgroup_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../view/View.dart" as view_;

import "../content/res/TypedArray.dart" as typedarray_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.GridLayout
///
/// A layout that places its children in a rectangular _grid_.
///
/// The grid is composed of a set of infinitely thin lines that separate the
/// viewing area into _cells_. Throughout the API, grid lines are referenced
/// by grid _indices_. A grid with {@code N} columns
/// has {@code N + 1} grid indices that run from {@code 0}
/// through {@code N} inclusive. Regardless of how GridLayout is
/// configured, grid index {@code 0} is fixed to the leading edge of the
/// container and grid index {@code N} is fixed to its trailing edge
/// (after padding is taken into account).
///
/// <h4>Row and Column Specs</h4>
///
/// Children occupy one or more contiguous cells, as defined
/// by their GridLayout.LayoutParams\#rowSpec rowSpec and
/// GridLayout.LayoutParams\#columnSpec columnSpec layout parameters.
/// Each spec defines the set of rows or columns that are to be
/// occupied; and how children should be aligned within the resulting group of cells.
/// Although cells do not normally overlap in a GridLayout, GridLayout does
/// not prevent children being defined to occupy the same cell or group of cells.
/// In this case however, there is no guarantee that children will not themselves
/// overlap after the layout operation completes.
///
/// <h4>Default Cell Assignment</h4>
///
/// If a child does not specify the row and column indices of the cell it
/// wishes to occupy, GridLayout assigns cell locations automatically using its:
/// GridLayout\#setOrientation(int) orientation,
/// GridLayout\#setRowCount(int) rowCount and
/// GridLayout\#setColumnCount(int) columnCount properties.
///
/// <h4>Space</h4>
///
/// Space between children may be specified either by using instances of the
/// dedicated Space view or by setting the
///
/// ViewGroup.MarginLayoutParams\#leftMargin leftMargin,
/// ViewGroup.MarginLayoutParams\#topMargin topMargin,
/// ViewGroup.MarginLayoutParams\#rightMargin rightMargin and
/// ViewGroup.MarginLayoutParams\#bottomMargin bottomMargin
///
/// layout parameters. When the
/// GridLayout\#setUseDefaultMargins(boolean) useDefaultMargins
/// property is set, default margins around children are automatically
/// allocated based on the prevailing UI style guide for the platform.
/// Each of the margins so defined may be independently overridden by an assignment
/// to the appropriate layout parameter.
/// Default values will generally produce a reasonable spacing between components
/// but values may change between different releases of the platform.
///
/// <h4>Excess Space Distribution</h4>
///
/// As of API 21, GridLayout's distribution of excess space accomodates the principle of weight.
/// In the event that no weights are specified, the previous conventions are respected and
/// columns and rows are taken as flexible if their views specify some form of alignment
/// within their groups.
///
/// The flexibility of a view is therefore influenced by its alignment which is,
/// in turn, typically defined by setting the
/// LayoutParams\#setGravity(int) gravity property of the child's layout parameters.
/// If either a weight or alignment were defined along a given axis then the component
/// is taken as _flexible_ in that direction. If no weight or alignment was set,
/// the component is instead assumed to be _inflexible_.
///
/// Multiple components in the same row or column group are
/// considered to act in _parallel_. Such a
/// group is flexible only if _all_ of the components
/// within it are flexible. Row and column groups that sit either side of a common boundary
/// are instead considered to act in _series_. The composite group made of these two
/// elements is flexible if _one_ of its elements is flexible.
///
/// To make a column stretch, make sure all of the components inside it define a
/// weight or a gravity. To prevent a column from stretching, ensure that one of the components
/// in the column does not define a weight or a gravity.
///
/// When the principle of flexibility does not provide complete disambiguation,
/// GridLayout's algorithms favour rows and columns that are closer to its _right_
/// and _bottom_ edges. To be more precise, GridLayout treats each of its layout
/// parameters as a constraint in the a set of variables that define the grid-lines along a
/// given axis. During layout, GridLayout solves the constraints so as to return the unique
/// solution to those constraints for which all variables are less-than-or-equal-to
/// the corresponding value in any other valid solution.
///
/// <h4>Interpretation of GONE</h4>
///
/// For layout purposes, GridLayout treats views whose visibility status is
/// View\#GONE GONE, as having zero width and height. This is subtly different from
/// the policy of ignoring views that are marked as GONE outright. If, for example, a gone-marked
/// view was alone in a column, that column would itself collapse to zero width if and only if
/// no gravity was defined on the view. If gravity was defined, then the gone-marked
/// view has no effect on the layout and the container should be laid out as if the view
/// had never been added to it. GONE views are taken to have zero weight during excess space
/// distribution.
///
/// These statements apply equally to rows as well as columns, and to groups of rows or columns.
///
///
/// See GridLayout.LayoutParams for a full description of the
/// layout parameters used by GridLayout.
///@attr ref android.R.styleable\#GridLayout_orientation
///@attr ref android.R.styleable\#GridLayout_rowCount
///@attr ref android.R.styleable\#GridLayout_columnCount
///@attr ref android.R.styleable\#GridLayout_useDefaultMargins
///@attr ref android.R.styleable\#GridLayout_rowOrderPreserved
///@attr ref android.R.styleable\#GridLayout_columnOrderPreserved
class GridLayout extends viewgroup_.ViewGroup {
  static final _classRef = jniAccessors.getClassOf("android/widget/GridLayout");
  GridLayout.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ALIGN_BOUNDS
  ///
  /// This constant is an \#setAlignmentMode(int) alignmentMode.
  /// When the {@code alignmentMode} is set to \#ALIGN_BOUNDS, alignment
  /// is made between the edges of each component's raw
  /// view boundary: i.e. the area delimited by the component's:
  /// android.view.View\#getTop() top,
  /// android.view.View\#getLeft() left,
  /// android.view.View\#getBottom() bottom and
  /// android.view.View\#getRight() right properties.
  ///
  /// For example, when {@code GridLayout} is in \#ALIGN_BOUNDS mode,
  /// children that belong to a row group that uses \#TOP alignment will
  /// all return the same value when their android.view.View\#getTop()
  /// method is called.
  ///@see \#setAlignmentMode(int)
  static const ALIGN_BOUNDS = 0;

  /// from: static public final int ALIGN_MARGINS
  ///
  /// This constant is an \#setAlignmentMode(int) alignmentMode.
  /// When the {@code alignmentMode} is set to \#ALIGN_MARGINS,
  /// the bounds of each view are extended outwards, according
  /// to their margins, before the edges of the resulting rectangle are aligned.
  ///
  /// For example, when {@code GridLayout} is in \#ALIGN_MARGINS mode,
  /// the quantity {@code top - layoutParams.topMargin} is the same for all children that
  /// belong to a row group that uses \#TOP alignment.
  ///@see \#setAlignmentMode(int)
  static const ALIGN_MARGINS = 1;

  static final _id_BASELINE = jniAccessors.getStaticFieldIDOf(
      _classRef, "BASELINE", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment BASELINE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should be aligned with the _baselines_
  /// of the other views in its cell group.
  /// This constant may only be used as an alignment in LayoutParams\#rowSpec rowSpecs.
  ///@see View\#getBaseline()
  static GridLayout_Alignment get BASELINE =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_BASELINE, jni.JniType.objectType)
          .object);

  static final _id_BOTTOM = jniAccessors.getStaticFieldIDOf(
      _classRef, "BOTTOM", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment BOTTOM
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should be aligned with the _bottom_
  /// edges of the other views in its cell group.
  static GridLayout_Alignment get BOTTOM =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_BOTTOM, jni.JniType.objectType)
          .object);

  static final _id_CENTER = jniAccessors.getStaticFieldIDOf(
      _classRef, "CENTER", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment CENTER
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should be _centered_ with the other views in its cell group.
  /// This constant may be used in both LayoutParams\#rowSpec rowSpecs and LayoutParams\#columnSpec columnSpecs.
  static GridLayout_Alignment get CENTER =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CENTER, jni.JniType.objectType)
          .object);

  static final _id_END = jniAccessors.getStaticFieldIDOf(
      _classRef, "END", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment END
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should be aligned with the _end_
  /// edges of the other views in its cell group.
  static GridLayout_Alignment get END =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_END, jni.JniType.objectType)
          .object);

  static final _id_FILL = jniAccessors.getStaticFieldIDOf(
      _classRef, "FILL", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment FILL
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should expanded to fit the boundaries of its cell group.
  /// This constant may be used in both LayoutParams\#rowSpec rowSpecs and
  /// LayoutParams\#columnSpec columnSpecs.
  static GridLayout_Alignment get FILL =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_FILL, jni.JniType.objectType)
          .object);

  /// from: static public final int HORIZONTAL
  ///
  /// The horizontal orientation.
  static const HORIZONTAL = 0;

  static final _id_LEFT = jniAccessors.getStaticFieldIDOf(
      _classRef, "LEFT", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment LEFT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should be aligned with the _left_
  /// edges of the other views in its cell group.
  static GridLayout_Alignment get LEFT =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LEFT, jni.JniType.objectType)
          .object);

  static final _id_RIGHT = jniAccessors.getStaticFieldIDOf(
      _classRef, "RIGHT", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment RIGHT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should be aligned with the _right_
  /// edges of the other views in its cell group.
  static GridLayout_Alignment get RIGHT =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_RIGHT, jni.JniType.objectType)
          .object);

  static final _id_START = jniAccessors.getStaticFieldIDOf(
      _classRef, "START", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment START
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should be aligned with the _start_
  /// edges of the other views in its cell group.
  static GridLayout_Alignment get START =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_START, jni.JniType.objectType)
          .object);

  static final _id_TOP = jniAccessors.getStaticFieldIDOf(
      _classRef, "TOP", "Landroid/widget/GridLayout\$Alignment;");

  /// from: static public final android.widget.GridLayout.Alignment TOP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates that a view should be aligned with the _top_
  /// edges of the other views in its cell group.
  static GridLayout_Alignment get TOP =>
      GridLayout_Alignment.fromRef(jniAccessors
          .getStaticField(_classRef, _id_TOP, jni.JniType.objectType)
          .object);

  /// from: static public final int UNDEFINED
  ///
  /// The constant used to indicate that a value is undefined.
  /// Fields can use this value to indicate that their values
  /// have not yet been set. Similarly, methods can return this value
  /// to indicate that there is no suitable value that the implementation
  /// can return.
  /// The value used for the constant (currently Integer\#MIN_VALUE) is
  /// intended to avoid confusion between valid values whose sign may not be known.
  static const UNDEFINED = -2147483648;

  /// from: static public final int VERTICAL
  ///
  /// The vertical orientation.
  static const VERTICAL = 1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GridLayout(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GridLayout.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GridLayout.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GridLayout.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_getOrientation =
      jniAccessors.getMethodIDOf(_classRef, "getOrientation", "()I");

  /// from: public int getOrientation()
  ///
  /// Returns the current orientation.
  ///@return either \#HORIZONTAL or \#VERTICAL
  ///
  /// Value is android.widget.GridLayout\#HORIZONTAL, or android.widget.GridLayout\#VERTICAL
  ///@see \#setOrientation(int)
  ///@attr ref android.R.styleable\#GridLayout_orientation
  int getOrientation() => jniAccessors.callMethodWithArgs(
      reference, _id_getOrientation, jni.JniType.intType, []).integer;

  static final _id_setOrientation =
      jniAccessors.getMethodIDOf(_classRef, "setOrientation", "(I)V");

  /// from: public void setOrientation(int orientation)
  ///
  /// GridLayout uses the orientation property for two purposes:
  /// <ul>
  ///  <li>
  ///      To control the 'direction' in which default row/column indices are generated
  ///      when they are not specified in a component's layout parameters.
  ///  </li>
  ///  <li>
  ///      To control which axis should be processed first during the layout operation:
  ///      when orientation is \#HORIZONTAL the horizontal axis is laid out first.
  ///  </li>
  /// </ul>
  ///
  /// The order in which axes are laid out is important if, for example, the height of
  /// one of GridLayout's children is dependent on its width - and its width is, in turn,
  /// dependent on the widths of other components.
  ///
  /// If your layout contains a TextView (or derivative:
  /// {@code Button}, {@code EditText}, {@code CheckBox}, etc.) which is
  /// in multi-line mode (the default) it is normally best to leave GridLayout's
  /// orientation as {@code HORIZONTAL} - because {@code TextView} is capable of
  /// deriving its height for a given width, but not the other way around.
  ///
  /// Other than the effects above, orientation does not affect the actual layout operation of
  /// GridLayout, so it's fine to leave GridLayout in {@code HORIZONTAL} mode even if
  /// the height of the intended layout greatly exceeds its width.
  ///
  /// The default value of this property is \#HORIZONTAL.
  ///@param orientation either \#HORIZONTAL or \#VERTICAL
  ///
  /// Value is android.widget.GridLayout\#HORIZONTAL, or android.widget.GridLayout\#VERTICAL
  ///@see \#getOrientation()
  ///@attr ref android.R.styleable\#GridLayout_orientation
  void setOrientation(int orientation) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOrientation,
      jni.JniType.voidType,
      [orientation]).check();

  static final _id_getRowCount =
      jniAccessors.getMethodIDOf(_classRef, "getRowCount", "()I");

  /// from: public int getRowCount()
  ///
  /// Returns the current number of rows. This is either the last value that was set
  /// with \#setRowCount(int) or, if no such value was set, the maximum
  /// value of each the upper bounds defined in LayoutParams\#rowSpec.
  ///@return the current number of rows
  ///@see \#setRowCount(int)
  ///@see LayoutParams\#rowSpec
  ///@attr ref android.R.styleable\#GridLayout_rowCount
  int getRowCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRowCount, jni.JniType.intType, []).integer;

  static final _id_setRowCount =
      jniAccessors.getMethodIDOf(_classRef, "setRowCount", "(I)V");

  /// from: public void setRowCount(int rowCount)
  ///
  /// RowCount is used only to generate default row/column indices when
  /// they are not specified by a component's layout parameters.
  ///@param rowCount the number of rows
  ///@see \#getRowCount()
  ///@see LayoutParams\#rowSpec
  ///@attr ref android.R.styleable\#GridLayout_rowCount
  void setRowCount(int rowCount) => jniAccessors.callMethodWithArgs(
      reference, _id_setRowCount, jni.JniType.voidType, [rowCount]).check();

  static final _id_getColumnCount =
      jniAccessors.getMethodIDOf(_classRef, "getColumnCount", "()I");

  /// from: public int getColumnCount()
  ///
  /// Returns the current number of columns. This is either the last value that was set
  /// with \#setColumnCount(int) or, if no such value was set, the maximum
  /// value of each the upper bounds defined in LayoutParams\#columnSpec.
  ///@return the current number of columns
  ///@see \#setColumnCount(int)
  ///@see LayoutParams\#columnSpec
  ///@attr ref android.R.styleable\#GridLayout_columnCount
  int getColumnCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getColumnCount, jni.JniType.intType, []).integer;

  static final _id_setColumnCount =
      jniAccessors.getMethodIDOf(_classRef, "setColumnCount", "(I)V");

  /// from: public void setColumnCount(int columnCount)
  ///
  /// ColumnCount is used only to generate default column/column indices when
  /// they are not specified by a component's layout parameters.
  ///@param columnCount the number of columns.
  ///@see \#getColumnCount()
  ///@see LayoutParams\#columnSpec
  ///@attr ref android.R.styleable\#GridLayout_columnCount
  void setColumnCount(int columnCount) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setColumnCount,
      jni.JniType.voidType,
      [columnCount]).check();

  static final _id_getUseDefaultMargins =
      jniAccessors.getMethodIDOf(_classRef, "getUseDefaultMargins", "()Z");

  /// from: public boolean getUseDefaultMargins()
  ///
  /// Returns whether or not this GridLayout will allocate default margins when no
  /// corresponding layout parameters are defined.
  ///@return {@code true} if default margins should be allocated
  ///@see \#setUseDefaultMargins(boolean)
  ///@attr ref android.R.styleable\#GridLayout_useDefaultMargins
  bool getUseDefaultMargins() => jniAccessors.callMethodWithArgs(
      reference, _id_getUseDefaultMargins, jni.JniType.booleanType, []).boolean;

  static final _id_setUseDefaultMargins =
      jniAccessors.getMethodIDOf(_classRef, "setUseDefaultMargins", "(Z)V");

  /// from: public void setUseDefaultMargins(boolean useDefaultMargins)
  ///
  /// When {@code true}, GridLayout allocates default margins around children
  /// based on the child's visual characteristics. Each of the
  /// margins so defined may be independently overridden by an assignment
  /// to the appropriate layout parameter.
  ///
  /// When {@code false}, the default value of all margins is zero.
  ///
  /// When setting to {@code true}, consider setting the value of the
  /// \#setAlignmentMode(int) alignmentMode
  /// property to \#ALIGN_BOUNDS.
  ///
  /// The default value of this property is {@code false}.
  ///@param useDefaultMargins use {@code true} to make GridLayout allocate default margins
  ///@see \#getUseDefaultMargins()
  ///@see \#setAlignmentMode(int)
  ///@see MarginLayoutParams\#leftMargin
  ///@see MarginLayoutParams\#topMargin
  ///@see MarginLayoutParams\#rightMargin
  ///@see MarginLayoutParams\#bottomMargin
  ///@attr ref android.R.styleable\#GridLayout_useDefaultMargins
  void setUseDefaultMargins(bool useDefaultMargins) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUseDefaultMargins,
          jni.JniType.voidType, [useDefaultMargins]).check();

  static final _id_getAlignmentMode =
      jniAccessors.getMethodIDOf(_classRef, "getAlignmentMode", "()I");

  /// from: public int getAlignmentMode()
  ///
  /// Returns the alignment mode.
  ///@return the alignment mode; either \#ALIGN_BOUNDS or \#ALIGN_MARGINS
  ///
  /// Value is android.widget.GridLayout\#ALIGN_BOUNDS, or android.widget.GridLayout\#ALIGN_MARGINS
  ///@see \#ALIGN_BOUNDS
  ///@see \#ALIGN_MARGINS
  ///@see \#setAlignmentMode(int)
  ///@attr ref android.R.styleable\#GridLayout_alignmentMode
  int getAlignmentMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlignmentMode, jni.JniType.intType, []).integer;

  static final _id_setAlignmentMode =
      jniAccessors.getMethodIDOf(_classRef, "setAlignmentMode", "(I)V");

  /// from: public void setAlignmentMode(int alignmentMode)
  ///
  /// Sets the alignment mode to be used for all of the alignments between the
  /// children of this container.
  ///
  /// The default value of this property is \#ALIGN_MARGINS.
  ///@param alignmentMode either \#ALIGN_BOUNDS or \#ALIGN_MARGINS
  ///
  /// Value is android.widget.GridLayout\#ALIGN_BOUNDS, or android.widget.GridLayout\#ALIGN_MARGINS
  ///@see \#ALIGN_BOUNDS
  ///@see \#ALIGN_MARGINS
  ///@see \#getAlignmentMode()
  ///@attr ref android.R.styleable\#GridLayout_alignmentMode
  void setAlignmentMode(int alignmentMode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAlignmentMode,
      jni.JniType.voidType,
      [alignmentMode]).check();

  static final _id_isRowOrderPreserved =
      jniAccessors.getMethodIDOf(_classRef, "isRowOrderPreserved", "()Z");

  /// from: public boolean isRowOrderPreserved()
  ///
  /// Returns whether or not row boundaries are ordered by their grid indices.
  ///@return {@code true} if row boundaries must appear in the order of their indices,
  ///         {@code false} otherwise
  ///@see \#setRowOrderPreserved(boolean)
  ///@attr ref android.R.styleable\#GridLayout_rowOrderPreserved
  bool isRowOrderPreserved() => jniAccessors.callMethodWithArgs(
      reference, _id_isRowOrderPreserved, jni.JniType.booleanType, []).boolean;

  static final _id_setRowOrderPreserved =
      jniAccessors.getMethodIDOf(_classRef, "setRowOrderPreserved", "(Z)V");

  /// from: public void setRowOrderPreserved(boolean rowOrderPreserved)
  ///
  /// When this property is {@code true}, GridLayout is forced to place the row boundaries
  /// so that their associated grid indices are in ascending order in the view.
  ///
  /// When this property is {@code false} GridLayout is at liberty to place the vertical row
  /// boundaries in whatever order best fits the given constraints.
  ///
  /// The default value of this property is {@code true}.
  ///@param rowOrderPreserved {@code true} to force GridLayout to respect the order
  ///        of row boundaries
  ///@see \#isRowOrderPreserved()
  ///@attr ref android.R.styleable\#GridLayout_rowOrderPreserved
  void setRowOrderPreserved(bool rowOrderPreserved) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRowOrderPreserved,
          jni.JniType.voidType, [rowOrderPreserved]).check();

  static final _id_isColumnOrderPreserved =
      jniAccessors.getMethodIDOf(_classRef, "isColumnOrderPreserved", "()Z");

  /// from: public boolean isColumnOrderPreserved()
  ///
  /// Returns whether or not column boundaries are ordered by their grid indices.
  ///@return {@code true} if column boundaries must appear in the order of their indices,
  ///         {@code false} otherwise
  ///@see \#setColumnOrderPreserved(boolean)
  ///@attr ref android.R.styleable\#GridLayout_columnOrderPreserved
  bool isColumnOrderPreserved() => jniAccessors.callMethodWithArgs(reference,
      _id_isColumnOrderPreserved, jni.JniType.booleanType, []).boolean;

  static final _id_setColumnOrderPreserved =
      jniAccessors.getMethodIDOf(_classRef, "setColumnOrderPreserved", "(Z)V");

  /// from: public void setColumnOrderPreserved(boolean columnOrderPreserved)
  ///
  /// When this property is {@code true}, GridLayout is forced to place the column boundaries
  /// so that their associated grid indices are in ascending order in the view.
  ///
  /// When this property is {@code false} GridLayout is at liberty to place the horizontal column
  /// boundaries in whatever order best fits the given constraints.
  ///
  /// The default value of this property is {@code true}.
  ///@param columnOrderPreserved use {@code true} to force GridLayout to respect the order
  ///        of column boundaries.
  ///@see \#isColumnOrderPreserved()
  ///@attr ref android.R.styleable\#GridLayout_columnOrderPreserved
  void setColumnOrderPreserved(bool columnOrderPreserved) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColumnOrderPreserved,
          jni.JniType.voidType, [columnOrderPreserved]).check();

  static final _id_checkLayoutParams = jniAccessors.getMethodIDOf(_classRef,
      "checkLayoutParams", "(Landroid/view/ViewGroup\$LayoutParams;)Z");

  /// from: protected boolean checkLayoutParams(android.view.ViewGroup.LayoutParams p)
  bool checkLayoutParams(viewgroup_.ViewGroup_LayoutParams p) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkLayoutParams,
          jni.JniType.booleanType, [p.reference]).boolean;

  static final _id_generateDefaultLayoutParams1 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateDefaultLayoutParams",
      "()Landroid/widget/GridLayout\$LayoutParams;");

  /// from: protected android.widget.GridLayout.LayoutParams generateDefaultLayoutParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GridLayout_LayoutParams generateDefaultLayoutParams1() =>
      GridLayout_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_generateDefaultLayoutParams1, jni.JniType.objectType, []).object);

  static final _id_generateLayoutParams2 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/util/AttributeSet;)Landroid/widget/GridLayout\$LayoutParams;");

  /// from: public android.widget.GridLayout.LayoutParams generateLayoutParams(android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GridLayout_LayoutParams generateLayoutParams2(
          attributeset_.AttributeSet attrs) =>
      GridLayout_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams2,
          jni.JniType.objectType,
          [attrs.reference]).object);

  static final _id_generateLayoutParams3 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/view/ViewGroup\$LayoutParams;)Landroid/widget/GridLayout\$LayoutParams;");

  /// from: protected android.widget.GridLayout.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams lp)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GridLayout_LayoutParams generateLayoutParams3(
          viewgroup_.ViewGroup_LayoutParams lp) =>
      GridLayout_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams3,
          jni.JniType.objectType,
          [lp.reference]).object);

  static final _id_onViewAdded = jniAccessors.getMethodIDOf(
      _classRef, "onViewAdded", "(Landroid/view/View;)V");

  /// from: public void onViewAdded(android.view.View child)
  void onViewAdded(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onViewAdded,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_onViewRemoved = jniAccessors.getMethodIDOf(
      _classRef, "onViewRemoved", "(Landroid/view/View;)V");

  /// from: public void onViewRemoved(android.view.View child)
  void onViewRemoved(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onViewRemoved,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthSpec, int heightSpec)
  void onMeasure1(int widthSpec, int heightSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthSpec, heightSpec]).check();

  static final _id_requestLayout1 =
      jniAccessors.getMethodIDOf(_classRef, "requestLayout", "()V");

  /// from: public void requestLayout()
  void requestLayout1() => jniAccessors.callMethodWithArgs(
      reference, _id_requestLayout1, jni.JniType.voidType, []).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int left, int top, int right, int bottom)
  ///
  /// {@inheritDoc}
  void onLayout(bool changed, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, left, top, right, bottom]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_spec = jniAccessors.getStaticMethodIDOf(_classRef, "spec",
      "(IILandroid/widget/GridLayout\$Alignment;F)Landroid/widget/GridLayout\$Spec;");

  /// from: static public android.widget.GridLayout.Spec spec(int start, int size, android.widget.GridLayout.Alignment alignment, float weight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a Spec, {@code spec}, where:
  /// <ul>
  ///     <li> {@code spec.span = [start, start + size]} </li>
  ///     <li> {@code spec.alignment = alignment} </li>
  ///     <li> {@code spec.weight = weight} </li>
  /// </ul>
  ///
  /// To leave the start index undefined, use the value \#UNDEFINED.
  ///@param start the start
  ///@param size the size
  ///@param alignment the alignment
  ///@param weight the weight
  static GridLayout_Spec spec(
          int start, int size, GridLayout_Alignment alignment, double weight) =>
      GridLayout_Spec.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_spec,
          jni.JniType.objectType,
          [start, size, alignment.reference, weight]).object);

  static final _id_spec1 = jniAccessors.getStaticMethodIDOf(_classRef, "spec",
      "(ILandroid/widget/GridLayout\$Alignment;F)Landroid/widget/GridLayout\$Spec;");

  /// from: static public android.widget.GridLayout.Spec spec(int start, android.widget.GridLayout.Alignment alignment, float weight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Equivalent to: {@code spec(start, 1, alignment, weight)}.
  ///@param start the start
  ///@param alignment the alignment
  ///@param weight the weight
  static GridLayout_Spec spec1(
          int start, GridLayout_Alignment alignment, double weight) =>
      GridLayout_Spec.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_spec1,
          jni.JniType.objectType,
          [start, alignment.reference, weight]).object);

  static final _id_spec2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "spec", "(IIF)Landroid/widget/GridLayout\$Spec;");

  /// from: static public android.widget.GridLayout.Spec spec(int start, int size, float weight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Equivalent to: {@code spec(start, 1, default_alignment, weight)} -
  /// where {@code default_alignment} is specified in
  /// android.widget.GridLayout.LayoutParams.
  ///@param start the start
  ///@param size the size
  ///@param weight the weight
  static GridLayout_Spec spec2(int start, int size, double weight) =>
      GridLayout_Spec.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_spec2, jni.JniType.objectType, [start, size, weight]).object);

  static final _id_spec3 = jniAccessors.getStaticMethodIDOf(
      _classRef, "spec", "(IF)Landroid/widget/GridLayout\$Spec;");

  /// from: static public android.widget.GridLayout.Spec spec(int start, float weight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Equivalent to: {@code spec(start, 1, weight)}.
  ///@param start the start
  ///@param weight the weight
  static GridLayout_Spec spec3(int start, double weight) =>
      GridLayout_Spec.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_spec3, jni.JniType.objectType, [start, weight]).object);

  static final _id_spec4 = jniAccessors.getStaticMethodIDOf(_classRef, "spec",
      "(IILandroid/widget/GridLayout\$Alignment;)Landroid/widget/GridLayout\$Spec;");

  /// from: static public android.widget.GridLayout.Spec spec(int start, int size, android.widget.GridLayout.Alignment alignment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Equivalent to: {@code spec(start, size, alignment, 0f)}.
  ///@param start the start
  ///@param size the size
  ///@param alignment the alignment
  static GridLayout_Spec spec4(
          int start, int size, GridLayout_Alignment alignment) =>
      GridLayout_Spec.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_spec4,
          jni.JniType.objectType,
          [start, size, alignment.reference]).object);

  static final _id_spec5 = jniAccessors.getStaticMethodIDOf(_classRef, "spec",
      "(ILandroid/widget/GridLayout\$Alignment;)Landroid/widget/GridLayout\$Spec;");

  /// from: static public android.widget.GridLayout.Spec spec(int start, android.widget.GridLayout.Alignment alignment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a Spec, {@code spec}, where:
  /// <ul>
  ///     <li> {@code spec.span = [start, start + 1]} </li>
  ///     <li> {@code spec.alignment = alignment} </li>
  /// </ul>
  ///
  /// To leave the start index undefined, use the value \#UNDEFINED.
  ///@param start the start index
  ///@param alignment the alignment
  ///@see \#spec(int, int, Alignment)
  static GridLayout_Spec spec5(int start, GridLayout_Alignment alignment) =>
      GridLayout_Spec.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_spec5,
          jni.JniType.objectType,
          [start, alignment.reference]).object);

  static final _id_spec6 = jniAccessors.getStaticMethodIDOf(
      _classRef, "spec", "(II)Landroid/widget/GridLayout\$Spec;");

  /// from: static public android.widget.GridLayout.Spec spec(int start, int size)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a Spec, {@code spec}, where:
  /// <ul>
  ///     <li> {@code spec.span = [start, start + size]} </li>
  /// </ul>
  ///
  /// To leave the start index undefined, use the value \#UNDEFINED.
  ///@param start the start
  ///@param size the size
  ///@see \#spec(int, Alignment)
  static GridLayout_Spec spec6(int start, int size) =>
      GridLayout_Spec.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_spec6, jni.JniType.objectType, [start, size]).object);

  static final _id_spec7 = jniAccessors.getStaticMethodIDOf(
      _classRef, "spec", "(I)Landroid/widget/GridLayout\$Spec;");

  /// from: static public android.widget.GridLayout.Spec spec(int start)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a Spec, {@code spec}, where:
  /// <ul>
  ///     <li> {@code spec.span = [start, start + 1]} </li>
  /// </ul>
  ///
  /// To leave the start index undefined, use the value \#UNDEFINED.
  ///@param start the start index
  ///@see \#spec(int, int)
  static GridLayout_Spec spec7(int start) =>
      GridLayout_Spec.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_spec7, jni.JniType.objectType, [start]).object);
}

/// from: android.widget.GridLayout$Spec
///
/// A Spec defines the horizontal or vertical characteristics of a group of
/// cells. Each spec. defines the _grid indices_ and _alignment_
/// along the appropriate axis.
///
/// The _grid indices_ are the leading and trailing edges of this cell group.
/// See GridLayout for a description of the conventions used by GridLayout
/// for grid indices.
///
/// The _alignment_ property specifies how cells should be aligned in this group.
/// For row groups, this specifies the vertical alignment.
/// For column groups, this specifies the horizontal alignment.
///
/// Use the following static methods to create specs:
/// <ul>
///   <li>\#spec(int)</li>
///   <li>\#spec(int, int)</li>
///   <li>\#spec(int, Alignment)</li>
///   <li>\#spec(int, int, Alignment)</li>
///   <li>\#spec(int, float)</li>
///   <li>\#spec(int, int, float)</li>
///   <li>\#spec(int, Alignment, float)</li>
///   <li>\#spec(int, int, Alignment, float)</li>
/// </ul>
class GridLayout_Spec extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/GridLayout\$Spec");
  GridLayout_Spec.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object that)
  ///
  /// Returns {@code true} if the {@code class}, {@code alignment} and {@code span}
  /// properties of this Spec and the supplied parameter are pairwise equal,
  /// {@code false} otherwise.
  ///@param that the object to compare this spec with
  ///@return {@code true} if the specified object is equal to this
  ///         {@code Spec}; {@code false} otherwise
  bool equals1(jni.JniObject that) => jniAccessors.callMethodWithArgs(reference,
      _id_equals1, jni.JniType.booleanType, [that.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}

/// from: android.widget.GridLayout$LayoutParams
///
/// Layout information associated with each of the children of a GridLayout.
///
/// GridLayout supports both row and column spanning and arbitrary forms of alignment within
/// each cell group. The fundamental parameters associated with each cell group are
/// gathered into their vertical and horizontal components and stored
/// in the \#rowSpec and \#columnSpec layout parameters.
/// GridLayout.Spec Specs are immutable structures
/// and may be shared between the layout parameters of different children.
///
/// The row and column specs contain the leading and trailing indices along each axis
/// and together specify the four grid indices that delimit the cells of this cell group.
///
/// The  alignment properties of the row and column specs together specify
/// both aspects of alignment within the cell group. It is also possible to specify a child's
/// alignment within its cell group by using the GridLayout.LayoutParams\#setGravity(int)
/// method.
///
/// The weight property is also included in Spec and specifies the proportion of any
/// excess space that is due to the associated view.
///
/// <h4>WRAP_CONTENT and MATCH_PARENT</h4>
///
/// Because the default values of the \#width and \#height
/// properties are both \#WRAP_CONTENT, this value never needs to be explicitly
/// declared in the layout parameters of GridLayout's children. In addition,
/// GridLayout does not distinguish the special size value \#MATCH_PARENT from
/// \#WRAP_CONTENT. A component's ability to expand to the size of the parent is
/// instead controlled by the principle of _flexibility_,
/// as discussed in GridLayout.
///
/// <h4>Summary</h4>
///
/// You should not need to use either of the special size values:
/// {@code WRAP_CONTENT} or {@code MATCH_PARENT} when configuring the children of
/// a GridLayout.
///
/// <h4>Default values</h4>
///
/// <ul>
///     <li>\#width = \#WRAP_CONTENT</li>
///     <li>\#height = \#WRAP_CONTENT</li>
///     <li>\#topMargin = 0 when
///          GridLayout\#setUseDefaultMargins(boolean) useDefaultMargins is
///          {@code false}; otherwise \#UNDEFINED, to
///          indicate that a default value should be computed on demand. </li>
///     <li>\#leftMargin = 0 when
///          GridLayout\#setUseDefaultMargins(boolean) useDefaultMargins is
///          {@code false}; otherwise \#UNDEFINED, to
///          indicate that a default value should be computed on demand. </li>
///     <li>\#bottomMargin = 0 when
///          GridLayout\#setUseDefaultMargins(boolean) useDefaultMargins is
///          {@code false}; otherwise \#UNDEFINED, to
///          indicate that a default value should be computed on demand. </li>
///     <li>\#rightMargin = 0 when
///          GridLayout\#setUseDefaultMargins(boolean) useDefaultMargins is
///          {@code false}; otherwise \#UNDEFINED, to
///          indicate that a default value should be computed on demand. </li>
///     <li>\#rowSpec<code>.row</code> = \#UNDEFINED </li>
///     <li>\#rowSpec<code>.rowSpan</code> = 1 </li>
///     <li>\#rowSpec<code>.alignment</code> = \#BASELINE </li>
///     <li>\#rowSpec<code>.weight</code> = 0 </li>
///     <li>\#columnSpec<code>.column</code> = \#UNDEFINED </li>
///     <li>\#columnSpec<code>.columnSpan</code> = 1 </li>
///     <li>\#columnSpec<code>.alignment</code> = \#START </li>
///     <li>\#columnSpec<code>.weight</code> = 0 </li>
/// </ul>
///
/// See GridLayout for a more complete description of the conventions
/// used by GridLayout in the interpretation of the properties of this class.
///@attr ref android.R.styleable\#GridLayout_Layout_layout_row
///@attr ref android.R.styleable\#GridLayout_Layout_layout_rowSpan
///@attr ref android.R.styleable\#GridLayout_Layout_layout_rowWeight
///@attr ref android.R.styleable\#GridLayout_Layout_layout_column
///@attr ref android.R.styleable\#GridLayout_Layout_layout_columnSpan
///@attr ref android.R.styleable\#GridLayout_Layout_layout_columnWeight
///@attr ref android.R.styleable\#GridLayout_Layout_layout_gravity
class GridLayout_LayoutParams extends viewgroup_.ViewGroup_MarginLayoutParams {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/GridLayout\$LayoutParams");
  GridLayout_LayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_columnSpec = jniAccessors.getFieldIDOf(
      _classRef, "columnSpec", "Landroid/widget/GridLayout\$Spec;");

  /// from: public android.widget.GridLayout.Spec columnSpec
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The spec that defines the horizontal characteristics of the cell group
  /// described by these layout parameters.
  /// If an assignment is made to this field after a measurement or layout operation
  /// has already taken place, a call to
  /// ViewGroup\#setLayoutParams(ViewGroup.LayoutParams)
  /// must be made to notify GridLayout of the change. GridLayout is normally able
  /// to detect when code fails to observe this rule, issue a warning and take steps to
  /// compensate for the omission. This facility is implemented on a best effort basis
  /// and should not be relied upon in production code - so it is best to include the above
  /// calls to remove the warnings as soon as it is practical.
  GridLayout_Spec get columnSpec => GridLayout_Spec.fromRef(jniAccessors
      .getField(reference, _id_columnSpec, jni.JniType.objectType)
      .object);

  /// from: public android.widget.GridLayout.Spec columnSpec
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The spec that defines the horizontal characteristics of the cell group
  /// described by these layout parameters.
  /// If an assignment is made to this field after a measurement or layout operation
  /// has already taken place, a call to
  /// ViewGroup\#setLayoutParams(ViewGroup.LayoutParams)
  /// must be made to notify GridLayout of the change. GridLayout is normally able
  /// to detect when code fails to observe this rule, issue a warning and take steps to
  /// compensate for the omission. This facility is implemented on a best effort basis
  /// and should not be relied upon in production code - so it is best to include the above
  /// calls to remove the warnings as soon as it is practical.
  set columnSpec(GridLayout_Spec value) =>
      jniEnv.SetObjectField(reference, _id_columnSpec, value.reference);

  static final _id_rowSpec = jniAccessors.getFieldIDOf(
      _classRef, "rowSpec", "Landroid/widget/GridLayout\$Spec;");

  /// from: public android.widget.GridLayout.Spec rowSpec
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The spec that defines the vertical characteristics of the cell group
  /// described by these layout parameters.
  /// If an assignment is made to this field after a measurement or layout operation
  /// has already taken place, a call to
  /// ViewGroup\#setLayoutParams(ViewGroup.LayoutParams)
  /// must be made to notify GridLayout of the change. GridLayout is normally able
  /// to detect when code fails to observe this rule, issue a warning and take steps to
  /// compensate for the omission. This facility is implemented on a best effort basis
  /// and should not be relied upon in production code - so it is best to include the above
  /// calls to remove the warnings as soon as it is practical.
  GridLayout_Spec get rowSpec => GridLayout_Spec.fromRef(jniAccessors
      .getField(reference, _id_rowSpec, jni.JniType.objectType)
      .object);

  /// from: public android.widget.GridLayout.Spec rowSpec
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The spec that defines the vertical characteristics of the cell group
  /// described by these layout parameters.
  /// If an assignment is made to this field after a measurement or layout operation
  /// has already taken place, a call to
  /// ViewGroup\#setLayoutParams(ViewGroup.LayoutParams)
  /// must be made to notify GridLayout of the change. GridLayout is normally able
  /// to detect when code fails to observe this rule, issue a warning and take steps to
  /// compensate for the omission. This facility is implemented on a best effort basis
  /// and should not be relied upon in production code - so it is best to include the above
  /// calls to remove the warnings as soon as it is practical.
  set rowSpec(GridLayout_Spec value) =>
      jniEnv.SetObjectField(reference, _id_rowSpec, value.reference);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/widget/GridLayout\$Spec;Landroid/widget/GridLayout\$Spec;)V");

  /// from: public void <init>(android.widget.GridLayout.Spec rowSpec, android.widget.GridLayout.Spec columnSpec)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new LayoutParams instance for this <code>rowSpec</code>
  /// and <code>columnSpec</code>. All other fields are initialized with
  /// default values as defined in LayoutParams.
  ///@param rowSpec the rowSpec
  ///@param columnSpec the columnSpec
  GridLayout_LayoutParams.ctor4(
      GridLayout_Spec rowSpec, GridLayout_Spec columnSpec)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor4,
            [rowSpec.reference, columnSpec.reference]).object);

  static final _id_ctor5 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new LayoutParams with default values as defined in LayoutParams.
  GridLayout_LayoutParams.ctor5()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor5, []).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.LayoutParams params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  GridLayout_LayoutParams.ctor2(viewgroup_.ViewGroup_LayoutParams params)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [params.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$MarginLayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.MarginLayoutParams params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  GridLayout_LayoutParams.ctor3(viewgroup_.ViewGroup_MarginLayoutParams params)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [params.reference]).object);

  static final _id_ctor6 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/widget/GridLayout\$LayoutParams;)V");

  /// from: public void <init>(android.widget.GridLayout.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy constructor. Clones the width, height, margin values, row spec,
  /// and column spec of the source.
  ///@param source The layout params to copy from.
  GridLayout_LayoutParams.ctor6(GridLayout_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor6, [source.reference]).object);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// Values not defined in the attribute set take the default values
  /// defined in LayoutParams.
  GridLayout_LayoutParams(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference, attrs.reference]).object);

  static final _id_setGravity =
      jniAccessors.getMethodIDOf(_classRef, "setGravity", "(I)V");

  /// from: public void setGravity(int gravity)
  ///
  /// Describes how the child views are positioned. Default is {@code LEFT | BASELINE}.
  /// See Gravity.
  ///@param gravity the new gravity value
  ///@attr ref android.R.styleable\#GridLayout_Layout_layout_gravity
  void setGravity(int gravity) => jniAccessors.callMethodWithArgs(
      reference, _id_setGravity, jni.JniType.voidType, [gravity]).check();

  static final _id_setBaseAttributes1 = jniAccessors.getMethodIDOf(
      _classRef, "setBaseAttributes", "(Landroid/content/res/TypedArray;II)V");

  /// from: protected void setBaseAttributes(android.content.res.TypedArray attributes, int widthAttr, int heightAttr)
  void setBaseAttributes1(
          typedarray_.TypedArray attributes, int widthAttr, int heightAttr) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setBaseAttributes1,
          jni.JniType.voidType,
          [attributes.reference, widthAttr, heightAttr]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}

/// from: android.widget.GridLayout$Alignment
///
/// Alignments specify where a view should be placed within a cell group and
/// what size it should be.
///
/// The LayoutParams class contains a LayoutParams\#rowSpec rowSpec
/// and a LayoutParams\#columnSpec columnSpec each of which contains an
/// {@code alignment}. Overall placement of the view in the cell
/// group is specified by the two alignments which act along each axis independently.
///
///  The GridLayout class defines the most common alignments used in general layout:
/// \#TOP, \#LEFT, \#BOTTOM, \#RIGHT, \#START,
/// \#END, \#CENTER, \#BASELINE and \#FILL.
class GridLayout_Alignment extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/GridLayout\$Alignment");
  GridLayout_Alignment.fromRef(jni.JObject ref) : super.fromRef(ref);
}
