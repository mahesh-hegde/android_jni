// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/View.dart" as view_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../content/res/ColorStateList.dart" as colorstatelist_;

import "../graphics/PorterDuff.dart" as porterduff_;

import "../view/animation/Interpolator.dart" as interpolator_;

import "../graphics/Canvas.dart" as canvas_;

import "../os/Parcelable.dart" as parcelable_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.ProgressBar
///
///
/// A user interface element that indicates the progress of an operation.
/// Progress bar supports two modes to represent progress: determinate, and indeterminate. For
/// a visual overview of the difference between determinate and indeterminate progress modes, see
/// <a href="https://material.io/guidelines/components/progress-activity.html\#progress-activity-types-of-indicators">
/// Progress & activity</a>.
/// Display progress bars to a user in a non-interruptive way.
/// Show the progress bar in your app's user interface or in a notification
/// instead of within a dialog.
///
///
/// <h3>Indeterminate Progress</h3>
///
/// Use indeterminate mode for the progress bar when you do not know how long an
/// operation will take.
/// Indeterminate mode is the default for progress bar and shows a cyclic animation without a
/// specific amount of progress indicated.
/// The following example shows an indeterminate progress bar:
/// <pre>
/// &lt;ProgressBar
///      android:id="@+id/indeterminateBar"
///      android:layout_width="wrap_content"
///      android:layout_height="wrap_content"
///      /&gt;
/// </pre>
///
///
/// <h3>Determinate Progress</h3>
///
/// Use determinate mode for the progress bar when you want to show that a specific quantity of
/// progress has occurred.
/// For example, the percent remaining of a file being retrieved, the amount records in
/// a batch written to database, or the percent remaining of an audio file that is playing.
///
///
/// To indicate determinate progress, you set the style of the progress bar to
/// android.R.style\#Widget_ProgressBar_Horizontal and set the amount of progress.
/// The following example shows a determinate progress bar that is 25% complete:
/// <pre>
/// &lt;ProgressBar
///      android:id="@+id/determinateBar"
///      style="@android:style/Widget.ProgressBar.Horizontal"
///      android:layout_width="wrap_content"
///      android:layout_height="wrap_content"
///      android:progress="25"/&gt;
/// </pre>
/// You can update the percentage of progress displayed by using the
/// \#setProgress(int) method, or by calling
/// \#incrementProgressBy(int) to increase the current progress completed
/// by a specified amount.
/// By default, the progress bar is full when the progress value reaches 100.
/// You can adjust this default by setting the
/// android.R.styleable\#ProgressBar_max android:max attribute.
///
///
/// Other progress bar styles provided by the system include:
///
/// <ul>
/// <li>android.R.style\#Widget_ProgressBar_Horizontal Widget.ProgressBar.Horizontal</li>
/// <li>android.R.style\#Widget_ProgressBar_Small Widget.ProgressBar.Small</li>
/// <li>android.R.style\#Widget_ProgressBar_Large Widget.ProgressBar.Large</li>
/// <li>android.R.style\#Widget_ProgressBar_Inverse Widget.ProgressBar.Inverse</li>
/// <li>android.R.style\#Widget_ProgressBar_Small_Inverse Widget.ProgressBar.Small.Inverse</li>
/// <li>android.R.style\#Widget_ProgressBar_Large_Inverse Widget.ProgressBar.Large.Inverse</li>
/// </ul>
/// The "inverse" styles provide an inverse color scheme for the spinner, which may be necessary
/// if your application uses a light colored theme (a white background).
///
///
/// <strong>XML attributes__</strong>
///
/// See android.R.styleable\#ProgressBar ProgressBar Attributes,
/// android.R.styleable\#View View Attributes
///
///
///@attr ref android.R.styleable\#ProgressBar_animationResolution
///@attr ref android.R.styleable\#ProgressBar_indeterminate
///@attr ref android.R.styleable\#ProgressBar_indeterminateBehavior
///@attr ref android.R.styleable\#ProgressBar_indeterminateDrawable
///@attr ref android.R.styleable\#ProgressBar_indeterminateDuration
///@attr ref android.R.styleable\#ProgressBar_indeterminateOnly
///@attr ref android.R.styleable\#ProgressBar_interpolator
///@attr ref android.R.styleable\#ProgressBar_min
///@attr ref android.R.styleable\#ProgressBar_max
///@attr ref android.R.styleable\#ProgressBar_maxHeight
///@attr ref android.R.styleable\#ProgressBar_maxWidth
///@attr ref android.R.styleable\#ProgressBar_minHeight
///@attr ref android.R.styleable\#ProgressBar_minWidth
///@attr ref android.R.styleable\#ProgressBar_mirrorForRtl
///@attr ref android.R.styleable\#ProgressBar_progress
///@attr ref android.R.styleable\#ProgressBar_progressDrawable
///@attr ref android.R.styleable\#ProgressBar_secondaryProgress
class ProgressBar extends view_.View {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/ProgressBar");
  ProgressBar.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new progress bar with range 0...100 and initial progress of 0.
  ///@param context the application environment
  ProgressBar(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ProgressBar.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ProgressBar.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ProgressBar.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_isIndeterminate =
      jniAccessors.getMethodIDOf(_classRef, "isIndeterminate", "()Z");

  /// from: synchronized public boolean isIndeterminate()
  ///
  /// Indicate whether this progress bar is in indeterminate mode.
  ///
  ///@return true if the progress bar is in indeterminate mode
  bool isIndeterminate() => jniAccessors.callMethodWithArgs(
      reference, _id_isIndeterminate, jni.JniType.booleanType, []).boolean;

  static final _id_setIndeterminate =
      jniAccessors.getMethodIDOf(_classRef, "setIndeterminate", "(Z)V");

  /// from: synchronized public void setIndeterminate(boolean indeterminate)
  ///
  /// Change the indeterminate mode for this progress bar. In indeterminate
  /// mode, the progress is ignored and the progress bar shows an infinite
  /// animation instead.
  ///
  ///
  /// If this progress bar's style only supports indeterminate mode (such as the circular
  /// progress bars), then this will be ignored.
  ///@param indeterminate true to enable the indeterminate mode
  void setIndeterminate(bool indeterminate) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIndeterminate,
      jni.JniType.voidType,
      [indeterminate]).check();

  static final _id_getIndeterminateDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "getIndeterminateDrawable",
      "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getIndeterminateDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the drawable used to draw the progress bar in
  /// indeterminate mode.
  ///
  ///@return a android.graphics.drawable.Drawable instance
  ///@see \#setIndeterminateDrawable(android.graphics.drawable.Drawable)
  ///@see \#setIndeterminate(boolean)
  drawable_.Drawable getIndeterminateDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getIndeterminateDrawable, jni.JniType.objectType, []).object);

  static final _id_setIndeterminateDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "setIndeterminateDrawable",
      "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setIndeterminateDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Define the drawable used to draw the progress bar in indeterminate mode.
  ///@param d the new drawable
  ///@see \#getIndeterminateDrawable()
  ///@see \#setIndeterminate(boolean)
  void setIndeterminateDrawable(drawable_.Drawable d) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIndeterminateDrawable,
          jni.JniType.voidType, [d.reference]).check();

  static final _id_setIndeterminateTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "setIndeterminateTintList",
      "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setIndeterminateTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the indeterminate drawable. Does not modify the
  /// current tint mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// Subsequent calls to \#setIndeterminateDrawable(Drawable) will
  /// automatically mutate the drawable and apply the specified tint and
  /// tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_indeterminateTint
  ///@see \#getIndeterminateTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setIndeterminateTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIndeterminateTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_getIndeterminateTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "getIndeterminateTintList",
      "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getIndeterminateTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the tint applied to the indeterminate drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_indeterminateTint
  ///@see \#setIndeterminateTintList(ColorStateList)
  colorstatelist_.ColorStateList getIndeterminateTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getIndeterminateTintList,
          jni.JniType.objectType, []).object);

  static final _id_setIndeterminateTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "setIndeterminateTintMode",
      "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setIndeterminateTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setIndeterminateTintList(ColorStateList) to the indeterminate
  /// drawable. The default mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_indeterminateTintMode
  ///@see \#setIndeterminateTintList(ColorStateList)
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setIndeterminateTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIndeterminateTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_getIndeterminateTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "getIndeterminateTintMode",
      "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getIndeterminateTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the blending mode used to apply the tint to the indeterminate
  /// drawable, if specified.
  ///@return the blending mode used to apply the tint to the indeterminate
  ///         drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_indeterminateTintMode
  ///@see \#setIndeterminateTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getIndeterminateTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getIndeterminateTintMode,
          jni.JniType.objectType, []).object);

  static final _id_setIndeterminateDrawableTiled = jniAccessors.getMethodIDOf(
      _classRef,
      "setIndeterminateDrawableTiled",
      "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setIndeterminateDrawableTiled(android.graphics.drawable.Drawable d)
  ///
  /// Define the tileable drawable used to draw the progress bar in
  /// indeterminate mode.
  ///
  /// If the drawable is a BitmapDrawable or contains BitmapDrawables, a
  /// tiled copy will be generated for display as a progress bar.
  ///@param d the new drawable
  ///@see \#getIndeterminateDrawable()
  ///@see \#setIndeterminate(boolean)
  void setIndeterminateDrawableTiled(drawable_.Drawable d) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setIndeterminateDrawableTiled,
          jni.JniType.voidType,
          [d.reference]).check();

  static final _id_getProgressDrawable = jniAccessors.getMethodIDOf(_classRef,
      "getProgressDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getProgressDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the drawable used to draw the progress bar in
  /// progress mode.
  ///
  ///@return a android.graphics.drawable.Drawable instance
  ///@see \#setProgressDrawable(android.graphics.drawable.Drawable)
  ///@see \#setIndeterminate(boolean)
  drawable_.Drawable getProgressDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getProgressDrawable, jni.JniType.objectType, []).object);

  static final _id_setProgressDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setProgressDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setProgressDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Define the drawable used to draw the progress bar in progress mode.
  ///@param d the new drawable
  ///@see \#getProgressDrawable()
  ///@see \#setIndeterminate(boolean)
  void setProgressDrawable(drawable_.Drawable d) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProgressDrawable,
          jni.JniType.voidType, [d.reference]).check();

  static final _id_setProgressTintList = jniAccessors.getMethodIDOf(_classRef,
      "setProgressTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setProgressTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the progress indicator, if one exists, or to the
  /// entire progress drawable otherwise. Does not modify the current tint
  /// mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// The progress indicator should be specified as a layer with
  /// id android.R.id\#progress in a LayerDrawable
  /// used as the progress drawable.
  ///
  /// Subsequent calls to \#setProgressDrawable(Drawable) will
  /// automatically mutate the drawable and apply the specified tint and
  /// tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_progressTint
  ///@see \#getProgressTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setProgressTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProgressTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_getProgressTintList = jniAccessors.getMethodIDOf(_classRef,
      "getProgressTintList", "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getProgressTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the tint applied to the progress drawable, if specified.
  ///@return the tint applied to the progress drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_progressTint
  ///@see \#setProgressTintList(ColorStateList)
  colorstatelist_.ColorStateList getProgressTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getProgressTintList,
          jni.JniType.objectType, []).object);

  static final _id_setProgressTintMode = jniAccessors.getMethodIDOf(_classRef,
      "setProgressTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setProgressTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setProgressTintList(ColorStateList)} to the progress
  /// indicator. The default mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_progressTintMode
  ///@see \#getProgressTintMode()
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setProgressTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProgressTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_getProgressTintMode = jniAccessors.getMethodIDOf(_classRef,
      "getProgressTintMode", "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getProgressTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the blending mode used to apply the tint to the progress
  /// drawable, if specified.
  ///@return the blending mode used to apply the tint to the progress
  ///         drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_progressTintMode
  ///@see \#setProgressTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getProgressTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getProgressTintMode,
          jni.JniType.objectType, []).object);

  static final _id_setProgressBackgroundTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "setProgressBackgroundTintList",
      "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setProgressBackgroundTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the progress background, if one exists. Does not
  /// modify the current tint mode, which is
  /// PorterDuff.Mode\#SRC_ATOP by default.
  ///
  /// The progress background must be specified as a layer with
  /// id android.R.id\#background in a LayerDrawable
  /// used as the progress drawable.
  ///
  /// Subsequent calls to \#setProgressDrawable(Drawable) where the
  /// drawable contains a progress background will automatically mutate the
  /// drawable and apply the specified tint and tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_progressBackgroundTint
  ///@see \#getProgressBackgroundTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setProgressBackgroundTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setProgressBackgroundTintList,
          jni.JniType.voidType,
          [tint.reference]).check();

  static final _id_getProgressBackgroundTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "getProgressBackgroundTintList",
      "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getProgressBackgroundTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the tint applied to the progress background, if specified.
  ///@return the tint applied to the progress background
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_progressBackgroundTint
  ///@see \#setProgressBackgroundTintList(ColorStateList)
  colorstatelist_.ColorStateList getProgressBackgroundTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getProgressBackgroundTintList,
          jni.JniType.objectType, []).object);

  static final _id_setProgressBackgroundTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "setProgressBackgroundTintMode",
      "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setProgressBackgroundTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setProgressBackgroundTintList(ColorStateList)} to the progress
  /// background. The default mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_progressBackgroundTintMode
  ///@see \#setProgressBackgroundTintList(ColorStateList)
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setProgressBackgroundTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setProgressBackgroundTintMode,
          jni.JniType.voidType,
          [tintMode.reference]).check();

  static final _id_getProgressBackgroundTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "getProgressBackgroundTintMode",
      "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getProgressBackgroundTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the blending mode used to apply the tint to the progress
  ///         background
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_progressBackgroundTintMode
  ///@see \#setProgressBackgroundTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getProgressBackgroundTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getProgressBackgroundTintMode,
          jni.JniType.objectType, []).object);

  static final _id_setSecondaryProgressTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "setSecondaryProgressTintList",
      "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setSecondaryProgressTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the secondary progress indicator, if one exists.
  /// Does not modify the current tint mode, which is
  /// PorterDuff.Mode\#SRC_ATOP by default.
  ///
  /// The secondary progress indicator must be specified as a layer with
  /// id android.R.id\#secondaryProgress in a LayerDrawable
  /// used as the progress drawable.
  ///
  /// Subsequent calls to \#setProgressDrawable(Drawable) where the
  /// drawable contains a secondary progress indicator will automatically
  /// mutate the drawable and apply the specified tint and tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_secondaryProgressTint
  ///@see \#getSecondaryProgressTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setSecondaryProgressTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSecondaryProgressTintList,
          jni.JniType.voidType,
          [tint.reference]).check();

  static final _id_getSecondaryProgressTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "getSecondaryProgressTintList",
      "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getSecondaryProgressTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the tint applied to the secondary progress drawable, if
  /// specified.
  ///@return the tint applied to the secondary progress drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_secondaryProgressTint
  ///@see \#setSecondaryProgressTintList(ColorStateList)
  colorstatelist_.ColorStateList getSecondaryProgressTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSecondaryProgressTintList,
          jni.JniType.objectType, []).object);

  static final _id_setSecondaryProgressTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "setSecondaryProgressTintMode",
      "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setSecondaryProgressTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setSecondaryProgressTintList(ColorStateList)} to the secondary
  /// progress indicator. The default mode is
  /// PorterDuff.Mode\#SRC_ATOP.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_secondaryProgressTintMode
  ///@see \#setSecondaryProgressTintList(ColorStateList)
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setSecondaryProgressTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSecondaryProgressTintMode,
          jni.JniType.voidType,
          [tintMode.reference]).check();

  static final _id_getSecondaryProgressTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "getSecondaryProgressTintMode",
      "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getSecondaryProgressTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the blending mode used to apply the tint to the secondary
  /// progress drawable, if specified.
  ///@return the blending mode used to apply the tint to the secondary
  ///         progress drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ProgressBar_secondaryProgressTintMode
  ///@see \#setSecondaryProgressTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getSecondaryProgressTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSecondaryProgressTintMode,
          jni.JniType.objectType, []).object);

  static final _id_setProgressDrawableTiled = jniAccessors.getMethodIDOf(
      _classRef,
      "setProgressDrawableTiled",
      "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setProgressDrawableTiled(android.graphics.drawable.Drawable d)
  ///
  /// Define the tileable drawable used to draw the progress bar in
  /// progress mode.
  ///
  /// If the drawable is a BitmapDrawable or contains BitmapDrawables, a
  /// tiled copy will be generated for display as a progress bar.
  ///@param d the new drawable
  ///@see \#getProgressDrawable()
  ///@see \#setIndeterminate(boolean)
  void setProgressDrawableTiled(drawable_.Drawable d) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProgressDrawableTiled,
          jni.JniType.voidType, [d.reference]).check();

  static final _id_verifyDrawable = jniAccessors.getMethodIDOf(
      _classRef, "verifyDrawable", "(Landroid/graphics/drawable/Drawable;)Z");

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable who)
  ///
  /// @param who This value must never be {@code null}.
  bool verifyDrawable(drawable_.Drawable who) =>
      jniAccessors.callMethodWithArgs(reference, _id_verifyDrawable,
          jni.JniType.booleanType, [who.reference]).boolean;

  static final _id_jumpDrawablesToCurrentState = jniAccessors.getMethodIDOf(
      _classRef, "jumpDrawablesToCurrentState", "()V");

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_jumpDrawablesToCurrentState,
      jni.JniType.voidType, []).check();

  static final _id_postInvalidate =
      jniAccessors.getMethodIDOf(_classRef, "postInvalidate", "()V");

  /// from: public void postInvalidate()
  void postInvalidate() => jniAccessors.callMethodWithArgs(
      reference, _id_postInvalidate, jni.JniType.voidType, []).check();

  static final _id_setProgress =
      jniAccessors.getMethodIDOf(_classRef, "setProgress", "(I)V");

  /// from: synchronized public void setProgress(int progress)
  ///
  /// Sets the current progress to the specified value. Does not do anything
  /// if the progress bar is in indeterminate mode.
  ///
  /// This method will immediately update the visual position of the progress
  /// indicator. To animate the visual position to the target value, use
  /// \#setProgress(int, boolean)}.
  ///@param progress the new progress, between \#getMin() and \#getMax()
  ///@see \#setIndeterminate(boolean)
  ///@see \#isIndeterminate()
  ///@see \#getProgress()
  ///@see \#incrementProgressBy(int)
  void setProgress(int progress) => jniAccessors.callMethodWithArgs(
      reference, _id_setProgress, jni.JniType.voidType, [progress]).check();

  static final _id_setProgress1 =
      jniAccessors.getMethodIDOf(_classRef, "setProgress", "(IZ)V");

  /// from: public void setProgress(int progress, boolean animate)
  ///
  /// Sets the current progress to the specified value, optionally animating
  /// the visual position between the current and target values.
  ///
  /// Animation does not affect the result of \#getProgress(), which
  /// will return the target value immediately after this method is called.
  ///@param progress the new progress value, between \#getMin() and \#getMax()
  ///@param animate {@code true} to animate between the current and target
  ///                values or {@code false} to not animate
  void setProgress1(int progress, bool animate) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProgress1,
          jni.JniType.voidType, [progress, animate]).check();

  static final _id_setSecondaryProgress =
      jniAccessors.getMethodIDOf(_classRef, "setSecondaryProgress", "(I)V");

  /// from: synchronized public void setSecondaryProgress(int secondaryProgress)
  ///
  ///
  /// Set the current secondary progress to the specified value. Does not do
  /// anything if the progress bar is in indeterminate mode.
  ///
  ///
  ///@param secondaryProgress the new secondary progress, between \#getMin() and
  /// \#getMax()
  ///@see \#setIndeterminate(boolean)
  ///@see \#isIndeterminate()
  ///@see \#getSecondaryProgress()
  ///@see \#incrementSecondaryProgressBy(int)
  void setSecondaryProgress(int secondaryProgress) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSecondaryProgress,
          jni.JniType.voidType, [secondaryProgress]).check();

  static final _id_getProgress =
      jniAccessors.getMethodIDOf(_classRef, "getProgress", "()I");

  /// from: synchronized public int getProgress()
  ///
  /// Get the progress bar's current level of progress. Return 0 when the
  /// progress bar is in indeterminate mode.
  ///
  ///@return the current progress, between \#getMin() and \#getMax()
  ///@see \#setIndeterminate(boolean)
  ///@see \#isIndeterminate()
  ///@see \#setProgress(int)
  ///@see \#setMax(int)
  ///@see \#getMax()
  int getProgress() => jniAccessors.callMethodWithArgs(
      reference, _id_getProgress, jni.JniType.intType, []).integer;

  static final _id_getSecondaryProgress =
      jniAccessors.getMethodIDOf(_classRef, "getSecondaryProgress", "()I");

  /// from: synchronized public int getSecondaryProgress()
  ///
  /// Get the progress bar's current level of secondary progress. Return 0 when the
  /// progress bar is in indeterminate mode.
  ///
  ///@return the current secondary progress, between \#getMin() and \#getMax()
  ///@see \#setIndeterminate(boolean)
  ///@see \#isIndeterminate()
  ///@see \#setSecondaryProgress(int)
  ///@see \#setMax(int)
  ///@see \#getMax()
  int getSecondaryProgress() => jniAccessors.callMethodWithArgs(
      reference, _id_getSecondaryProgress, jni.JniType.intType, []).integer;

  static final _id_getMin =
      jniAccessors.getMethodIDOf(_classRef, "getMin", "()I");

  /// from: synchronized public int getMin()
  ///
  /// Return the lower limit of this progress bar's range.
  ///
  ///@return a positive integer
  ///@see \#setMin(int)
  ///@see \#getProgress()
  ///@see \#getSecondaryProgress()
  int getMin() => jniAccessors.callMethodWithArgs(
      reference, _id_getMin, jni.JniType.intType, []).integer;

  static final _id_getMax =
      jniAccessors.getMethodIDOf(_classRef, "getMax", "()I");

  /// from: synchronized public int getMax()
  ///
  /// Return the upper limit of this progress bar's range.
  ///
  ///@return a positive integer
  ///@see \#setMax(int)
  ///@see \#getProgress()
  ///@see \#getSecondaryProgress()
  int getMax() => jniAccessors.callMethodWithArgs(
      reference, _id_getMax, jni.JniType.intType, []).integer;

  static final _id_setMin =
      jniAccessors.getMethodIDOf(_classRef, "setMin", "(I)V");

  /// from: synchronized public void setMin(int min)
  ///
  /// Set the lower range of the progress bar to <tt>min</tt>.
  ///
  ///@param min the lower range of this progress bar
  ///@see \#getMin()
  ///@see \#setProgress(int)
  ///@see \#setSecondaryProgress(int)
  void setMin(int min) => jniAccessors.callMethodWithArgs(
      reference, _id_setMin, jni.JniType.voidType, [min]).check();

  static final _id_setMax =
      jniAccessors.getMethodIDOf(_classRef, "setMax", "(I)V");

  /// from: synchronized public void setMax(int max)
  ///
  /// Set the upper range of the progress bar <tt>max</tt>.
  ///
  ///@param max the upper range of this progress bar
  ///@see \#getMax()
  ///@see \#setProgress(int)
  ///@see \#setSecondaryProgress(int)
  void setMax(int max) => jniAccessors.callMethodWithArgs(
      reference, _id_setMax, jni.JniType.voidType, [max]).check();

  static final _id_incrementProgressBy =
      jniAccessors.getMethodIDOf(_classRef, "incrementProgressBy", "(I)V");

  /// from: synchronized public final void incrementProgressBy(int diff)
  ///
  /// Increase the progress bar's progress by the specified amount.
  ///
  ///@param diff the amount by which the progress must be increased
  ///@see \#setProgress(int)
  void incrementProgressBy(int diff) => jniAccessors.callMethodWithArgs(
      reference, _id_incrementProgressBy, jni.JniType.voidType, [diff]).check();

  static final _id_incrementSecondaryProgressBy = jniAccessors.getMethodIDOf(
      _classRef, "incrementSecondaryProgressBy", "(I)V");

  /// from: synchronized public final void incrementSecondaryProgressBy(int diff)
  ///
  /// Increase the progress bar's secondary progress by the specified amount.
  ///
  ///@param diff the amount by which the secondary progress must be increased
  ///@see \#setSecondaryProgress(int)
  void incrementSecondaryProgressBy(int diff) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_incrementSecondaryProgressBy,
          jni.JniType.voidType,
          [diff]).check();

  static final _id_setInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "setInterpolator", "(Landroid/content/Context;I)V");

  /// from: public void setInterpolator(android.content.Context context, int resID)
  ///
  /// Sets the acceleration curve for the indeterminate animation.
  /// The interpolator is loaded as a resource from the specified context.
  ///@param context The application environment
  ///@param resID The resource identifier of the interpolator to load
  void setInterpolator(context_.Context context, int resID) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInterpolator,
          jni.JniType.voidType, [context.reference, resID]).check();

  static final _id_setInterpolator1 = jniAccessors.getMethodIDOf(
      _classRef, "setInterpolator", "(Landroid/view/animation/Interpolator;)V");

  /// from: public void setInterpolator(android.view.animation.Interpolator interpolator)
  ///
  /// Sets the acceleration curve for the indeterminate animation.
  /// Defaults to a linear interpolation.
  ///@param interpolator The interpolator which defines the acceleration curve
  void setInterpolator1(interpolator_.Interpolator interpolator) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInterpolator1,
          jni.JniType.voidType, [interpolator.reference]).check();

  static final _id_getInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "getInterpolator", "()Landroid/view/animation/Interpolator;");

  /// from: public android.view.animation.Interpolator getInterpolator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the acceleration curve type for the indeterminate animation.
  ///@return the Interpolator associated to this animation
  interpolator_.Interpolator getInterpolator() =>
      interpolator_.Interpolator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getInterpolator, jni.JniType.objectType, []).object);

  static final _id_onVisibilityAggregated =
      jniAccessors.getMethodIDOf(_classRef, "onVisibilityAggregated", "(Z)V");

  /// from: public void onVisibilityAggregated(boolean isVisible)
  void onVisibilityAggregated(bool isVisible) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVisibilityAggregated,
          jni.JniType.voidType, [isVisible]).check();

  static final _id_invalidateDrawable = jniAccessors.getMethodIDOf(_classRef,
      "invalidateDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable dr)
  ///
  /// @param dr This value must never be {@code null}.
  void invalidateDrawable(drawable_.Drawable dr) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateDrawable,
          jni.JniType.voidType, [dr.reference]).check();

  static final _id_onSizeChanged =
      jniAccessors.getMethodIDOf(_classRef, "onSizeChanged", "(IIII)V");

  /// from: protected void onSizeChanged(int w, int h, int oldw, int oldh)
  void onSizeChanged(int w, int h, int oldw, int oldh) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSizeChanged,
          jni.JniType.voidType, [w, h, oldw, oldh]).check();

  static final _id_onDraw = jniAccessors.getMethodIDOf(
      _classRef, "onDraw", "(Landroid/graphics/Canvas;)V");

  /// from: synchronized protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_onDraw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_onMeasure =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: synchronized protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_drawableStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableStateChanged", "()V");

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_drawableStateChanged, jni.JniType.voidType, []).check();

  static final _id_drawableHotspotChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableHotspotChanged", "(FF)V");

  /// from: public void drawableHotspotChanged(float x, float y)
  void drawableHotspotChanged(double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawableHotspotChanged,
          jni.JniType.voidType, [x, y]).check();

  static final _id_onSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  parcelable_.Parcelable onSaveInstanceState() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState, jni.JniType.objectType, []).object);

  static final _id_onRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: public void onRestoreInstanceState(android.os.Parcelable state)
  void onRestoreInstanceState(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_isAnimating =
      jniAccessors.getMethodIDOf(_classRef, "isAnimating", "()Z");

  /// from: public boolean isAnimating()
  ///
  /// Returns whether the ProgressBar is animating or not. This is essentially the same
  /// as whether the ProgressBar is \#isIndeterminate() indeterminate and visible,
  /// as indeterminate ProgressBars are always animating, and non-indeterminate
  /// ProgressBars are not animating.
  ///@return true if the ProgressBar is animating, false otherwise.
  bool isAnimating() => jniAccessors.callMethodWithArgs(
      reference, _id_isAnimating, jni.JniType.booleanType, []).boolean;
}
