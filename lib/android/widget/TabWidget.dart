// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "LinearLayout.dart" as linearlayout_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../view/View.dart" as view_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../graphics/Canvas.dart" as canvas_;

import "../view/PointerIcon.dart" as pointericon_;

import "../view/MotionEvent.dart" as motionevent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.TabWidget
///
/// Displays a list of tab labels representing each page in the parent's tab
/// collection.
///
/// The container object for this widget is android.widget.TabHost TabHost.
/// When the user selects a tab, this object sends a message to the parent
/// container, TabHost, to tell it to switch the displayed page. You typically
/// won't use many methods directly on this object. The container TabHost is
/// used to add labels, add the callback handler, and manage callbacks. You
/// might call this object to iterate the list of tabs, or to tweak the layout
/// of the tab list, but most methods should be called on the containing TabHost
/// object.
///@attr ref android.R.styleable\#TabWidget_divider
///@attr ref android.R.styleable\#TabWidget_tabStripEnabled
///@attr ref android.R.styleable\#TabWidget_tabStripLeft
///@attr ref android.R.styleable\#TabWidget_tabStripRight
class TabWidget extends linearlayout_.LinearLayout {
  static final _classRef = jniAccessors.getClassOf("android/widget/TabWidget");
  TabWidget.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TabWidget(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TabWidget.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TabWidget.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TabWidget.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_onSizeChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onSizeChanged", "(IIII)V");

  /// from: protected void onSizeChanged(int w, int h, int oldw, int oldh)
  void onSizeChanged1(int w, int h, int oldw, int oldh) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSizeChanged1,
          jni.JniType.voidType, [w, h, oldw, oldh]).check();

  static final _id_getChildDrawingOrder1 =
      jniAccessors.getMethodIDOf(_classRef, "getChildDrawingOrder", "(II)I");

  /// from: protected int getChildDrawingOrder(int childCount, int i)
  int getChildDrawingOrder1(int childCount, int i) =>
      jniAccessors.callMethodWithArgs(reference, _id_getChildDrawingOrder1,
          jni.JniType.intType, [childCount, i]).integer;

  static final _id_getChildTabViewAt = jniAccessors.getMethodIDOf(
      _classRef, "getChildTabViewAt", "(I)Landroid/view/View;");

  /// from: public android.view.View getChildTabViewAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the tab indicator view at the given index.
  ///@param index the zero-based index of the tab indicator view to return
  ///@return the tab indicator view at the given index
  view_.View getChildTabViewAt(int index) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getChildTabViewAt, jni.JniType.objectType, [index]).object);

  static final _id_getTabCount =
      jniAccessors.getMethodIDOf(_classRef, "getTabCount", "()I");

  /// from: public int getTabCount()
  ///
  /// Returns the number of tab indicator views.
  ///@return the number of tab indicator views
  int getTabCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getTabCount, jni.JniType.intType, []).integer;

  static final _id_setDividerDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setDividerDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setDividerDrawable(android.graphics.drawable.Drawable drawable)
  ///
  /// Sets the drawable to use as a divider between the tab indicators.
  ///@param drawable the divider drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#TabWidget_divider
  void setDividerDrawable(drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDividerDrawable,
          jni.JniType.voidType, [drawable.reference]).check();

  static final _id_setDividerDrawable1 =
      jniAccessors.getMethodIDOf(_classRef, "setDividerDrawable", "(I)V");

  /// from: public void setDividerDrawable(int resId)
  ///
  /// Sets the drawable to use as a divider between the tab indicators.
  ///@param resId the resource identifier of the drawable to use as a divider
  ///@attr ref android.R.styleable\#TabWidget_divider
  void setDividerDrawable1(int resId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDividerDrawable1,
      jni.JniType.voidType,
      [resId]).check();

  static final _id_setLeftStripDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setLeftStripDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setLeftStripDrawable(android.graphics.drawable.Drawable drawable)
  ///
  /// Sets the drawable to use as the left part of the strip below the tab
  /// indicators.
  ///@param drawable the left strip drawable
  /// This value may be {@code null}.
  ///@see \#getLeftStripDrawable()
  ///@attr ref android.R.styleable\#TabWidget_tabStripLeft
  void setLeftStripDrawable(drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLeftStripDrawable,
          jni.JniType.voidType, [drawable.reference]).check();

  static final _id_setLeftStripDrawable1 =
      jniAccessors.getMethodIDOf(_classRef, "setLeftStripDrawable", "(I)V");

  /// from: public void setLeftStripDrawable(int resId)
  ///
  /// Sets the drawable to use as the left part of the strip below the tab
  /// indicators.
  ///@param resId the resource identifier of the drawable to use as the left
  ///              strip drawable
  ///@see \#getLeftStripDrawable()
  ///@attr ref android.R.styleable\#TabWidget_tabStripLeft
  void setLeftStripDrawable1(int resId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLeftStripDrawable1,
      jni.JniType.voidType,
      [resId]).check();

  static final _id_getLeftStripDrawable = jniAccessors.getMethodIDOf(_classRef,
      "getLeftStripDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getLeftStripDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the drawable used as the left part of the strip below the tab
  ///         indicators, may be {@code null}
  ///@see \#setLeftStripDrawable(int)
  ///@see \#setLeftStripDrawable(Drawable)
  ///@attr ref android.R.styleable\#TabWidget_tabStripLeft
  drawable_.Drawable getLeftStripDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getLeftStripDrawable, jni.JniType.objectType, []).object);

  static final _id_setRightStripDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setRightStripDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setRightStripDrawable(android.graphics.drawable.Drawable drawable)
  ///
  /// Sets the drawable to use as the right part of the strip below the tab
  /// indicators.
  ///@param drawable the right strip drawable
  /// This value may be {@code null}.
  ///@see \#getRightStripDrawable()
  ///@attr ref android.R.styleable\#TabWidget_tabStripRight
  void setRightStripDrawable(drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRightStripDrawable,
          jni.JniType.voidType, [drawable.reference]).check();

  static final _id_setRightStripDrawable1 =
      jniAccessors.getMethodIDOf(_classRef, "setRightStripDrawable", "(I)V");

  /// from: public void setRightStripDrawable(int resId)
  ///
  /// Sets the drawable to use as the right part of the strip below the tab
  /// indicators.
  ///@param resId the resource identifier of the drawable to use as the right
  ///              strip drawable
  ///@see \#getRightStripDrawable()
  ///@attr ref android.R.styleable\#TabWidget_tabStripRight
  void setRightStripDrawable1(int resId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRightStripDrawable1,
      jni.JniType.voidType,
      [resId]).check();

  static final _id_getRightStripDrawable = jniAccessors.getMethodIDOf(_classRef,
      "getRightStripDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getRightStripDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the drawable used as the right part of the strip below the tab
  ///         indicators, may be {@code null}
  ///@see \#setRightStripDrawable(int)
  ///@see \#setRightStripDrawable(Drawable)
  ///@attr ref android.R.styleable\#TabWidget_tabStripRight
  drawable_.Drawable getRightStripDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRightStripDrawable, jni.JniType.objectType, []).object);

  static final _id_setStripEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setStripEnabled", "(Z)V");

  /// from: public void setStripEnabled(boolean stripEnabled)
  ///
  /// Controls whether the bottom strips on the tab indicators are drawn or
  /// not.  The default is to draw them.  If the user specifies a custom
  /// view for the tab indicators, then the TabHost class calls this method
  /// to disable drawing of the bottom strips.
  ///@param stripEnabled true if the bottom strips should be drawn.
  void setStripEnabled(bool stripEnabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setStripEnabled,
      jni.JniType.voidType,
      [stripEnabled]).check();

  static final _id_isStripEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isStripEnabled", "()Z");

  /// from: public boolean isStripEnabled()
  ///
  /// Indicates whether the bottom strips on the tab indicators are drawn
  /// or not.
  bool isStripEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isStripEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_childDrawableStateChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "childDrawableStateChanged", "(Landroid/view/View;)V");

  /// from: public void childDrawableStateChanged(android.view.View child)
  void childDrawableStateChanged1(view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_childDrawableStateChanged1,
          jni.JniType.voidType, [child.reference]).check();

  static final _id_dispatchDraw1 = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: public void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw1(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw1,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_setCurrentTab =
      jniAccessors.getMethodIDOf(_classRef, "setCurrentTab", "(I)V");

  /// from: public void setCurrentTab(int index)
  ///
  /// Sets the current tab.
  ///
  /// This method is used to bring a tab to the front of the Widget,
  /// and is used to post to the rest of the UI that a different tab
  /// has been brought to the foreground.
  ///
  /// Note, this is separate from the traditional "focus" that is
  /// employed from the view logic.
  ///
  /// For instance, if we have a list in a tabbed view, a user may be
  /// navigating up and down the list, moving the UI focus (orange
  /// highlighting) through the list items.  The cursor movement does
  /// not effect the "selected" tab though, because what is being
  /// scrolled through is all on the same tab.  The selected tab only
  /// changes when we navigate between tabs (moving from the list view
  /// to the next tabbed view, in this example).
  ///
  /// To move both the focus AND the selected tab at once, please use
  /// \#setCurrentTab. Normally, the view logic takes care of
  /// adjusting the focus, so unless you're circumventing the UI,
  /// you'll probably just focus your interest here.
  ///@param index the index of the tab that you want to indicate as the
  ///              selected tab (tab brought to the front of the widget)
  ///@see \#focusCurrentTab
  void setCurrentTab(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_setCurrentTab, jni.JniType.voidType, [index]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_focusCurrentTab =
      jniAccessors.getMethodIDOf(_classRef, "focusCurrentTab", "(I)V");

  /// from: public void focusCurrentTab(int index)
  ///
  /// Sets the current tab and focuses the UI on it.
  /// This method makes sure that the focused tab matches the selected
  /// tab, normally at \#setCurrentTab.  Normally this would not
  /// be an issue if we go through the UI, since the UI is responsible
  /// for calling TabWidget.onFocusChanged(), but in the case where we
  /// are selecting the tab programmatically, we'll need to make sure
  /// focus keeps up.
  ///@param index The tab that you want focused (highlighted in orange)
  ///  and selected (tab brought to the front of the widget)
  ///@see \#setCurrentTab
  void focusCurrentTab(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_focusCurrentTab, jni.JniType.voidType, [index]).check();

  static final _id_setEnabled1 =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)V");

  /// from: public void setEnabled(boolean enabled)
  void setEnabled1(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled1, jni.JniType.voidType, [enabled]).check();

  static final _id_addView5 = jniAccessors.getMethodIDOf(
      _classRef, "addView", "(Landroid/view/View;)V");

  /// from: public void addView(android.view.View child)
  void addView5(view_.View child) => jniAccessors.callMethodWithArgs(
      reference, _id_addView5, jni.JniType.voidType, [child.reference]).check();

  static final _id_removeAllViews1 =
      jniAccessors.getMethodIDOf(_classRef, "removeAllViews", "()V");

  /// from: public void removeAllViews()
  void removeAllViews1() => jniAccessors.callMethodWithArgs(
      reference, _id_removeAllViews1, jni.JniType.voidType, []).check();

  static final _id_onResolvePointerIcon1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onResolvePointerIcon",
      "(Landroid/view/MotionEvent;I)Landroid/view/PointerIcon;");

  /// from: public android.view.PointerIcon onResolvePointerIcon(android.view.MotionEvent event, int pointerIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  pointericon_.PointerIcon onResolvePointerIcon1(
          motionevent_.MotionEvent event, int pointerIndex) =>
      pointericon_.PointerIcon.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onResolvePointerIcon1,
          jni.JniType.objectType,
          [event.reference, pointerIndex]).object);

  static final _id_onFocusChange = jniAccessors.getMethodIDOf(
      _classRef, "onFocusChange", "(Landroid/view/View;Z)V");

  /// from: public void onFocusChange(android.view.View v, boolean hasFocus)
  void onFocusChange(view_.View v, bool hasFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFocusChange,
          jni.JniType.voidType, [v.reference, hasFocus]).check();
}
