// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ListView.dart" as listview_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "ListAdapter.dart" as listadapter_;

import "AdapterView.dart" as adapterview_;

import "ExpandableListAdapter.dart" as expandablelistadapter_;

import "../view/View.dart" as view_;

import "../os/Parcelable.dart" as parcelable_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.ExpandableListView
///
/// A view that shows items in a vertically scrolling two-level list. This
/// differs from the ListView by allowing two levels: groups which can
/// individually be expanded to show its children. The items come from the
/// ExpandableListAdapter associated with this view.
///
/// Expandable lists are able to show an indicator beside each item to display
/// the item's current state (the states are usually one of expanded group,
/// collapsed group, child, or last child). Use
/// \#setChildIndicator(Drawable) or \#setGroupIndicator(Drawable)
/// (or the corresponding XML attributes) to set these indicators (see the docs
/// for each method to see additional state that each Drawable can have). The
/// default style for an ExpandableListView provides indicators which
/// will be shown next to Views given to the ExpandableListView. The
/// layouts android.R.layout.simple_expandable_list_item_1 and
/// android.R.layout.simple_expandable_list_item_2 (which should be used with
/// SimpleCursorTreeAdapter) contain the preferred position information
/// for indicators.
///
/// The context menu information set by an ExpandableListView will be a
/// ExpandableListContextMenuInfo object with
/// ExpandableListContextMenuInfo\#packedPosition being a packed position
/// that can be used with \#getPackedPositionType(long) and the other
/// similar methods.
///
/// ___Note:___ You cannot use the value <code>wrap_content</code>
/// for the <code>android:layout_height</code> attribute of a
/// ExpandableListView in XML if the parent's size is also not strictly specified
/// (for example, if the parent were ScrollView you could not specify
/// wrap_content since it also can be any length. However, you can use
/// wrap_content if the ExpandableListView parent has a specific size, such as
/// 100 pixels.
///@attr ref android.R.styleable\#ExpandableListView_groupIndicator
///@attr ref android.R.styleable\#ExpandableListView_indicatorLeft
///@attr ref android.R.styleable\#ExpandableListView_indicatorRight
///@attr ref android.R.styleable\#ExpandableListView_childIndicator
///@attr ref android.R.styleable\#ExpandableListView_childIndicatorLeft
///@attr ref android.R.styleable\#ExpandableListView_childIndicatorRight
///@attr ref android.R.styleable\#ExpandableListView_childDivider
///@attr ref android.R.styleable\#ExpandableListView_indicatorStart
///@attr ref android.R.styleable\#ExpandableListView_indicatorEnd
///@attr ref android.R.styleable\#ExpandableListView_childIndicatorStart
///@attr ref android.R.styleable\#ExpandableListView_childIndicatorEnd
class ExpandableListView extends listview_.ListView {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/ExpandableListView");
  ExpandableListView.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CHILD_INDICATOR_INHERIT
  ///
  /// Denotes when a child indicator should inherit this bound from the generic
  /// indicator bounds
  static const CHILD_INDICATOR_INHERIT = -1;

  /// from: static public final int PACKED_POSITION_TYPE_CHILD
  ///
  /// The packed position represents a child.
  static const PACKED_POSITION_TYPE_CHILD = 1;

  /// from: static public final int PACKED_POSITION_TYPE_GROUP
  ///
  /// The packed position represents a group.
  static const PACKED_POSITION_TYPE_GROUP = 0;

  /// from: static public final int PACKED_POSITION_TYPE_NULL
  ///
  /// The packed position represents a neither/null/no preference.
  static const PACKED_POSITION_TYPE_NULL = 2;

  /// from: static public final long PACKED_POSITION_VALUE_NULL
  ///
  /// The value for a packed position that represents neither/null/no
  /// preference. This value is not otherwise possible since a group type
  /// (first bit 0) should not have a child position filled.
  static const PACKED_POSITION_VALUE_NULL = 4294967295;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExpandableListView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExpandableListView.ctor1(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExpandableListView.ctor2(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExpandableListView.ctor3(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_onRtlPropertiesChanged2 =
      jniAccessors.getMethodIDOf(_classRef, "onRtlPropertiesChanged", "(I)V");

  /// from: public void onRtlPropertiesChanged(int layoutDirection)
  void onRtlPropertiesChanged2(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRtlPropertiesChanged2,
          jni.JniType.voidType, [layoutDirection]).check();

  static final _id_dispatchDraw1 = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw1(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw1,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_setChildDivider = jniAccessors.getMethodIDOf(
      _classRef, "setChildDivider", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setChildDivider(android.graphics.drawable.Drawable childDivider)
  ///
  /// Sets the drawable that will be drawn adjacent to every child in the list. This will
  /// be drawn using the same height as the normal divider (\#setDivider(Drawable)) or
  /// if it does not have an intrinsic height, the height set by \#setDividerHeight(int).
  ///@param childDivider The drawable to use.
  void setChildDivider(drawable_.Drawable childDivider) =>
      jniAccessors.callMethodWithArgs(reference, _id_setChildDivider,
          jni.JniType.voidType, [childDivider.reference]).check();

  static final _id_setAdapter1 = jniAccessors.getMethodIDOf(
      _classRef, "setAdapter", "(Landroid/widget/ListAdapter;)V");

  /// from: public void setAdapter(android.widget.ListAdapter adapter)
  ///
  /// This overloaded method should not be used, instead use
  /// \#setAdapter(ExpandableListAdapter).
  ///
  /// {@inheritDoc}
  void setAdapter1(listadapter_.ListAdapter adapter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAdapter1,
          jni.JniType.voidType, [adapter.reference]).check();

  static final _id_getAdapter1 = jniAccessors.getMethodIDOf(
      _classRef, "getAdapter", "()Landroid/widget/ListAdapter;");

  /// from: public android.widget.ListAdapter getAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method should not be used, use \#getExpandableListAdapter().
  listadapter_.ListAdapter getAdapter1() =>
      listadapter_.ListAdapter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAdapter1, jni.JniType.objectType, []).object);

  static final _id_setOnItemClickListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnItemClickListener",
      "(Landroid/widget/AdapterView\$OnItemClickListener;)V");

  /// from: public void setOnItemClickListener(android.widget.AdapterView.OnItemClickListener l)
  ///
  /// Register a callback to be invoked when an item has been clicked and the
  /// caller prefers to receive a ListView-style position instead of a group
  /// and/or child position. In most cases, the caller should use
  /// \#setOnGroupClickListener and/or \#setOnChildClickListener.
  /// <p/>
  /// {@inheritDoc}
  void setOnItemClickListener1(
          adapterview_.AdapterView_OnItemClickListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnItemClickListener1,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setAdapter2 = jniAccessors.getMethodIDOf(
      _classRef, "setAdapter", "(Landroid/widget/ExpandableListAdapter;)V");

  /// from: public void setAdapter(android.widget.ExpandableListAdapter adapter)
  ///
  /// Sets the adapter that provides data to this view.
  ///@param adapter The adapter that provides data to this view.
  void setAdapter2(expandablelistadapter_.ExpandableListAdapter adapter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAdapter2,
          jni.JniType.voidType, [adapter.reference]).check();

  static final _id_getExpandableListAdapter = jniAccessors.getMethodIDOf(
      _classRef,
      "getExpandableListAdapter",
      "()Landroid/widget/ExpandableListAdapter;");

  /// from: public android.widget.ExpandableListAdapter getExpandableListAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the adapter that provides data to this view.
  ///@return The adapter that provides data to this view.
  expandablelistadapter_.ExpandableListAdapter getExpandableListAdapter() =>
      expandablelistadapter_.ExpandableListAdapter.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getExpandableListAdapter,
              jni.JniType.objectType, []).object);

  static final _id_performItemClick1 = jniAccessors.getMethodIDOf(
      _classRef, "performItemClick", "(Landroid/view/View;IJ)Z");

  /// from: public boolean performItemClick(android.view.View v, int position, long id)
  bool performItemClick1(view_.View v, int position, int id) =>
      jniAccessors.callMethodWithArgs(reference, _id_performItemClick1,
          jni.JniType.booleanType, [v.reference, position, id]).boolean;

  static final _id_expandGroup =
      jniAccessors.getMethodIDOf(_classRef, "expandGroup", "(I)Z");

  /// from: public boolean expandGroup(int groupPos)
  ///
  /// Expand a group in the grouped list view
  ///@param groupPos the group to be expanded
  ///@return True if the group was expanded, false otherwise (if the group
  ///         was already expanded, this will return false)
  bool expandGroup(int groupPos) => jniAccessors.callMethodWithArgs(
      reference, _id_expandGroup, jni.JniType.booleanType, [groupPos]).boolean;

  static final _id_expandGroup1 =
      jniAccessors.getMethodIDOf(_classRef, "expandGroup", "(IZ)Z");

  /// from: public boolean expandGroup(int groupPos, boolean animate)
  ///
  /// Expand a group in the grouped list view
  ///@param groupPos the group to be expanded
  ///@param animate true if the expanding group should be animated in
  ///@return True if the group was expanded, false otherwise (if the group
  ///         was already expanded, this will return false)
  bool expandGroup1(int groupPos, bool animate) =>
      jniAccessors.callMethodWithArgs(reference, _id_expandGroup1,
          jni.JniType.booleanType, [groupPos, animate]).boolean;

  static final _id_collapseGroup =
      jniAccessors.getMethodIDOf(_classRef, "collapseGroup", "(I)Z");

  /// from: public boolean collapseGroup(int groupPos)
  ///
  /// Collapse a group in the grouped list view
  ///@param groupPos position of the group to collapse
  ///@return True if the group was collapsed, false otherwise (if the group
  ///         was already collapsed, this will return false)
  bool collapseGroup(int groupPos) => jniAccessors.callMethodWithArgs(reference,
      _id_collapseGroup, jni.JniType.booleanType, [groupPos]).boolean;

  static final _id_setOnGroupCollapseListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnGroupCollapseListener",
      "(Landroid/widget/ExpandableListView\$OnGroupCollapseListener;)V");

  /// from: public void setOnGroupCollapseListener(android.widget.ExpandableListView.OnGroupCollapseListener onGroupCollapseListener)
  void setOnGroupCollapseListener(
          ExpandableListView_OnGroupCollapseListener onGroupCollapseListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnGroupCollapseListener,
          jni.JniType.voidType, [onGroupCollapseListener.reference]).check();

  static final _id_setOnGroupExpandListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnGroupExpandListener",
      "(Landroid/widget/ExpandableListView\$OnGroupExpandListener;)V");

  /// from: public void setOnGroupExpandListener(android.widget.ExpandableListView.OnGroupExpandListener onGroupExpandListener)
  void setOnGroupExpandListener(
          ExpandableListView_OnGroupExpandListener onGroupExpandListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnGroupExpandListener,
          jni.JniType.voidType, [onGroupExpandListener.reference]).check();

  static final _id_setOnGroupClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnGroupClickListener",
      "(Landroid/widget/ExpandableListView\$OnGroupClickListener;)V");

  /// from: public void setOnGroupClickListener(android.widget.ExpandableListView.OnGroupClickListener onGroupClickListener)
  void setOnGroupClickListener(
          ExpandableListView_OnGroupClickListener onGroupClickListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnGroupClickListener,
          jni.JniType.voidType, [onGroupClickListener.reference]).check();

  static final _id_setOnChildClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnChildClickListener",
      "(Landroid/widget/ExpandableListView\$OnChildClickListener;)V");

  /// from: public void setOnChildClickListener(android.widget.ExpandableListView.OnChildClickListener onChildClickListener)
  void setOnChildClickListener(
          ExpandableListView_OnChildClickListener onChildClickListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnChildClickListener,
          jni.JniType.voidType, [onChildClickListener.reference]).check();

  static final _id_getExpandableListPosition = jniAccessors.getMethodIDOf(
      _classRef, "getExpandableListPosition", "(I)J");

  /// from: public long getExpandableListPosition(int flatListPosition)
  ///
  /// Converts a flat list position (the raw position of an item (child or group)
  /// in the list) to a group and/or child position (represented in a
  /// packed position). This is useful in situations where the caller needs to
  /// use the underlying ListView's methods. Use
  /// ExpandableListView\#getPackedPositionType ,
  /// ExpandableListView\#getPackedPositionChild,
  /// ExpandableListView\#getPackedPositionGroup to unpack.
  ///@param flatListPosition The flat list position to be converted.
  ///@return The group and/or child position for the given flat list position
  ///         in packed position representation. \#PACKED_POSITION_VALUE_NULL if
  ///         the position corresponds to a header or a footer item.
  int getExpandableListPosition(int flatListPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_getExpandableListPosition,
          jni.JniType.longType, [flatListPosition]).long;

  static final _id_getFlatListPosition =
      jniAccessors.getMethodIDOf(_classRef, "getFlatListPosition", "(J)I");

  /// from: public int getFlatListPosition(long packedPosition)
  ///
  /// Converts a group and/or child position to a flat list position. This is
  /// useful in situations where the caller needs to use the underlying
  /// ListView's methods.
  ///@param packedPosition The group and/or child positions to be converted in
  ///            packed position representation. Use
  ///            \#getPackedPositionForChild(int, int) or
  ///            \#getPackedPositionForGroup(int).
  ///@return The flat list position for the given child or group.
  int getFlatListPosition(int packedPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFlatListPosition,
          jni.JniType.intType, [packedPosition]).integer;

  static final _id_getSelectedPosition =
      jniAccessors.getMethodIDOf(_classRef, "getSelectedPosition", "()J");

  /// from: public long getSelectedPosition()
  ///
  /// Gets the position of the currently selected group or child (along with
  /// its type). Can return \#PACKED_POSITION_VALUE_NULL if no selection.
  ///@return A packed position containing the currently selected group or
  ///         child's position and type. \#PACKED_POSITION_VALUE_NULL if no selection
  ///         or if selection is on a header or a footer item.
  int getSelectedPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectedPosition, jni.JniType.longType, []).long;

  static final _id_getSelectedId =
      jniAccessors.getMethodIDOf(_classRef, "getSelectedId", "()J");

  /// from: public long getSelectedId()
  ///
  /// Gets the ID of the currently selected group or child. Can return -1 if no
  /// selection.
  ///@return The ID of the currently selected group or child. -1 if no
  ///         selection.
  int getSelectedId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectedId, jni.JniType.longType, []).long;

  static final _id_setSelectedGroup =
      jniAccessors.getMethodIDOf(_classRef, "setSelectedGroup", "(I)V");

  /// from: public void setSelectedGroup(int groupPosition)
  ///
  /// Sets the selection to the specified group.
  ///@param groupPosition The position of the group that should be selected.
  void setSelectedGroup(int groupPosition) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSelectedGroup,
      jni.JniType.voidType,
      [groupPosition]).check();

  static final _id_setSelectedChild =
      jniAccessors.getMethodIDOf(_classRef, "setSelectedChild", "(IIZ)Z");

  /// from: public boolean setSelectedChild(int groupPosition, int childPosition, boolean shouldExpandGroup)
  ///
  /// Sets the selection to the specified child. If the child is in a collapsed
  /// group, the group will only be expanded and child subsequently selected if
  /// shouldExpandGroup is set to true, otherwise the method will return false.
  ///@param groupPosition The position of the group that contains the child.
  ///@param childPosition The position of the child within the group.
  ///@param shouldExpandGroup Whether the child's group should be expanded if
  ///            it is collapsed.
  ///@return Whether the selection was successfully set on the child.
  bool setSelectedChild(
          int groupPosition, int childPosition, bool shouldExpandGroup) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSelectedChild,
          jni.JniType.booleanType,
          [groupPosition, childPosition, shouldExpandGroup]).boolean;

  static final _id_isGroupExpanded =
      jniAccessors.getMethodIDOf(_classRef, "isGroupExpanded", "(I)Z");

  /// from: public boolean isGroupExpanded(int groupPosition)
  ///
  /// Whether the given group is currently expanded.
  ///@param groupPosition The group to check.
  ///@return Whether the group is currently expanded.
  bool isGroupExpanded(int groupPosition) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isGroupExpanded,
      jni.JniType.booleanType,
      [groupPosition]).boolean;

  static final _id_getPackedPositionType = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPackedPositionType", "(J)I");

  /// from: static public int getPackedPositionType(long packedPosition)
  ///
  /// Gets the type of a packed position. See
  /// \#getPackedPositionForChild(int, int).
  ///@param packedPosition The packed position for which to return the type.
  ///@return The type of the position contained within the packed position,
  ///         either \#PACKED_POSITION_TYPE_CHILD, \#PACKED_POSITION_TYPE_GROUP, or
  ///         \#PACKED_POSITION_TYPE_NULL.
  static int getPackedPositionType(int packedPosition) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPackedPositionType,
          jni.JniType.intType,
          [packedPosition]).integer;

  static final _id_getPackedPositionGroup = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPackedPositionGroup", "(J)I");

  /// from: static public int getPackedPositionGroup(long packedPosition)
  ///
  /// Gets the group position from a packed position. See
  /// \#getPackedPositionForChild(int, int).
  ///@param packedPosition The packed position from which the group position
  ///            will be returned.
  ///@return The group position portion of the packed position. If this does
  ///         not contain a group, returns -1.
  static int getPackedPositionGroup(int packedPosition) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPackedPositionGroup,
          jni.JniType.intType,
          [packedPosition]).integer;

  static final _id_getPackedPositionChild = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPackedPositionChild", "(J)I");

  /// from: static public int getPackedPositionChild(long packedPosition)
  ///
  /// Gets the child position from a packed position that is of
  /// \#PACKED_POSITION_TYPE_CHILD type (use \#getPackedPositionType(long)).
  /// To get the group that this child belongs to, use
  /// \#getPackedPositionGroup(long). See
  /// \#getPackedPositionForChild(int, int).
  ///@param packedPosition The packed position from which the child position
  ///            will be returned.
  ///@return The child position portion of the packed position. If this does
  ///         not contain a child, returns -1.
  static int getPackedPositionChild(int packedPosition) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPackedPositionChild,
          jni.JniType.intType,
          [packedPosition]).integer;

  static final _id_getPackedPositionForChild = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPackedPositionForChild", "(II)J");

  /// from: static public long getPackedPositionForChild(int groupPosition, int childPosition)
  ///
  /// Returns the packed position representation of a child's position.
  ///
  /// In general, a packed position should be used in
  /// situations where the position given to/returned from an
  /// ExpandableListAdapter or ExpandableListView method can
  /// either be a child or group. The two positions are packed into a single
  /// long which can be unpacked using
  /// \#getPackedPositionChild(long),
  /// \#getPackedPositionGroup(long), and
  /// \#getPackedPositionType(long).
  ///@param groupPosition The child's parent group's position.
  ///@param childPosition The child position within the group.
  ///@return The packed position representation of the child (and parent group).
  static int getPackedPositionForChild(int groupPosition, int childPosition) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPackedPositionForChild,
          jni.JniType.longType,
          [groupPosition, childPosition]).long;

  static final _id_getPackedPositionForGroup = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPackedPositionForGroup", "(I)J");

  /// from: static public long getPackedPositionForGroup(int groupPosition)
  ///
  /// Returns the packed position representation of a group's position. See
  /// \#getPackedPositionForChild(int, int).
  ///@param groupPosition The child's parent group's position.
  ///@return The packed position representation of the group.
  static int getPackedPositionForGroup(int groupPosition) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPackedPositionForGroup,
          jni.JniType.longType,
          [groupPosition]).long;

  static final _id_setChildIndicator = jniAccessors.getMethodIDOf(_classRef,
      "setChildIndicator", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setChildIndicator(android.graphics.drawable.Drawable childIndicator)
  ///
  /// Sets the indicator to be drawn next to a child.
  ///@param childIndicator The drawable to be used as an indicator. If the
  ///            child is the last child for a group, the state
  ///            android.R.attr\#state_last will be set.
  void setChildIndicator(drawable_.Drawable childIndicator) =>
      jniAccessors.callMethodWithArgs(reference, _id_setChildIndicator,
          jni.JniType.voidType, [childIndicator.reference]).check();

  static final _id_setChildIndicatorBounds =
      jniAccessors.getMethodIDOf(_classRef, "setChildIndicatorBounds", "(II)V");

  /// from: public void setChildIndicatorBounds(int left, int right)
  ///
  /// Sets the drawing bounds for the child indicator. For either, you can
  /// specify \#CHILD_INDICATOR_INHERIT to use inherit from the general
  /// indicator's bounds.
  ///@see \#setIndicatorBounds(int, int)
  ///@param left The left position (relative to the left bounds of this View)
  ///            to start drawing the indicator.
  ///@param right The right position (relative to the left bounds of this
  ///            View) to end the drawing of the indicator.
  void setChildIndicatorBounds(int left, int right) =>
      jniAccessors.callMethodWithArgs(reference, _id_setChildIndicatorBounds,
          jni.JniType.voidType, [left, right]).check();

  static final _id_setChildIndicatorBoundsRelative = jniAccessors.getMethodIDOf(
      _classRef, "setChildIndicatorBoundsRelative", "(II)V");

  /// from: public void setChildIndicatorBoundsRelative(int start, int end)
  ///
  /// Sets the relative drawing bounds for the child indicator. For either, you can
  /// specify \#CHILD_INDICATOR_INHERIT to use inherit from the general
  /// indicator's bounds.
  ///@see \#setIndicatorBounds(int, int)
  ///@param start The start position (relative to the start bounds of this View)
  ///            to start drawing the indicator.
  ///@param end The end position (relative to the end bounds of this
  ///            View) to end the drawing of the indicator.
  void setChildIndicatorBoundsRelative(int start, int end) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setChildIndicatorBoundsRelative,
          jni.JniType.voidType,
          [start, end]).check();

  static final _id_setGroupIndicator = jniAccessors.getMethodIDOf(_classRef,
      "setGroupIndicator", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setGroupIndicator(android.graphics.drawable.Drawable groupIndicator)
  ///
  /// Sets the indicator to be drawn next to a group.
  ///@param groupIndicator The drawable to be used as an indicator. If the
  ///            group is empty, the state android.R.attr\#state_empty will be
  ///            set. If the group is expanded, the state
  ///            android.R.attr\#state_expanded will be set.
  void setGroupIndicator(drawable_.Drawable groupIndicator) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGroupIndicator,
          jni.JniType.voidType, [groupIndicator.reference]).check();

  static final _id_setIndicatorBounds =
      jniAccessors.getMethodIDOf(_classRef, "setIndicatorBounds", "(II)V");

  /// from: public void setIndicatorBounds(int left, int right)
  ///
  /// Sets the drawing bounds for the indicators (at minimum, the group indicator
  /// is affected by this; the child indicator is affected by this if the
  /// child indicator bounds are set to inherit).
  ///@see \#setChildIndicatorBounds(int, int)
  ///@param left The left position (relative to the left bounds of this View)
  ///            to start drawing the indicator.
  ///@param right The right position (relative to the left bounds of this
  ///            View) to end the drawing of the indicator.
  void setIndicatorBounds(int left, int right) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIndicatorBounds,
          jni.JniType.voidType, [left, right]).check();

  static final _id_setIndicatorBoundsRelative = jniAccessors.getMethodIDOf(
      _classRef, "setIndicatorBoundsRelative", "(II)V");

  /// from: public void setIndicatorBoundsRelative(int start, int end)
  ///
  /// Sets the relative drawing bounds for the indicators (at minimum, the group indicator
  /// is affected by this; the child indicator is affected by this if the
  /// child indicator bounds are set to inherit).
  ///@see \#setChildIndicatorBounds(int, int)
  ///@param start The start position (relative to the start bounds of this View)
  ///            to start drawing the indicator.
  ///@param end The end position (relative to the end bounds of this
  ///            View) to end the drawing of the indicator.
  void setIndicatorBoundsRelative(int start, int end) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIndicatorBoundsRelative,
          jni.JniType.voidType, [start, end]).check();

  static final _id_onSaveInstanceState2 = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  parcelable_.Parcelable onSaveInstanceState2() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState2, jni.JniType.objectType, []).object);

  static final _id_onRestoreInstanceState2 = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: public void onRestoreInstanceState(android.os.Parcelable state)
  void onRestoreInstanceState2(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState2,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);
}

/// from: android.widget.ExpandableListView$OnGroupExpandListener
///
/// Used for being notified when a group is expanded
class ExpandableListView_OnGroupExpandListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/ExpandableListView\$OnGroupExpandListener");
  ExpandableListView_OnGroupExpandListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onGroupExpand =
      jniAccessors.getMethodIDOf(_classRef, "onGroupExpand", "(I)V");

  /// from: public abstract void onGroupExpand(int groupPosition)
  ///
  /// Callback method to be invoked when a group in this expandable list has
  /// been expanded.
  ///@param groupPosition The group position that was expanded
  void onGroupExpand(int groupPosition) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onGroupExpand,
      jni.JniType.voidType,
      [groupPosition]).check();
}

/// from: android.widget.ExpandableListView$OnGroupCollapseListener
///
/// Used for being notified when a group is collapsed
class ExpandableListView_OnGroupCollapseListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/ExpandableListView\$OnGroupCollapseListener");
  ExpandableListView_OnGroupCollapseListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onGroupCollapse =
      jniAccessors.getMethodIDOf(_classRef, "onGroupCollapse", "(I)V");

  /// from: public abstract void onGroupCollapse(int groupPosition)
  ///
  /// Callback method to be invoked when a group in this expandable list has
  /// been collapsed.
  ///@param groupPosition The group position that was collapsed
  void onGroupCollapse(int groupPosition) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onGroupCollapse,
      jni.JniType.voidType,
      [groupPosition]).check();
}

/// from: android.widget.ExpandableListView$OnGroupClickListener
///
/// Interface definition for a callback to be invoked when a group in this
/// expandable list has been clicked.
class ExpandableListView_OnGroupClickListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/ExpandableListView\$OnGroupClickListener");
  ExpandableListView_OnGroupClickListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onGroupClick = jniAccessors.getMethodIDOf(
      _classRef,
      "onGroupClick",
      "(Landroid/widget/ExpandableListView;Landroid/view/View;IJ)Z");

  /// from: public abstract boolean onGroupClick(android.widget.ExpandableListView parent, android.view.View v, int groupPosition, long id)
  ///
  /// Callback method to be invoked when a group in this expandable list has
  /// been clicked.
  ///@param parent The ExpandableListConnector where the click happened
  ///@param v The view within the expandable list/ListView that was clicked
  ///@param groupPosition The group position that was clicked
  ///@param id The row id of the group that was clicked
  ///@return True if the click was handled
  bool onGroupClick(
          ExpandableListView parent, view_.View v, int groupPosition, int id) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onGroupClick,
          jni.JniType.booleanType,
          [parent.reference, v.reference, groupPosition, id]).boolean;
}

/// from: android.widget.ExpandableListView$OnChildClickListener
///
/// Interface definition for a callback to be invoked when a child in this
/// expandable list has been clicked.
class ExpandableListView_OnChildClickListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/ExpandableListView\$OnChildClickListener");
  ExpandableListView_OnChildClickListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onChildClick = jniAccessors.getMethodIDOf(
      _classRef,
      "onChildClick",
      "(Landroid/widget/ExpandableListView;Landroid/view/View;IIJ)Z");

  /// from: public abstract boolean onChildClick(android.widget.ExpandableListView parent, android.view.View v, int groupPosition, int childPosition, long id)
  ///
  /// Callback method to be invoked when a child in this expandable list has
  /// been clicked.
  ///@param parent The ExpandableListView where the click happened
  ///@param v The view within the expandable list/ListView that was clicked
  ///@param groupPosition The group position that contains the child that
  ///        was clicked
  ///@param childPosition The child position within the group
  ///@param id The row id of the child that was clicked
  ///@return True if the click was handled
  bool onChildClick(ExpandableListView parent, view_.View v, int groupPosition,
          int childPosition, int id) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onChildClick, jni.JniType.booleanType, [
        parent.reference,
        v.reference,
        groupPosition,
        childPosition,
        id
      ]).boolean;
}

/// from: android.widget.ExpandableListView$ExpandableListContextMenuInfo
///
/// Extra menu information specific to an ExpandableListView provided
/// to the
/// android.view.View.OnCreateContextMenuListener\#onCreateContextMenu(ContextMenu, View, ContextMenuInfo)
/// callback when a context menu is brought up for this AdapterView.
class ExpandableListView_ExpandableListContextMenuInfo extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/widget/ExpandableListView\$ExpandableListContextMenuInfo");
  ExpandableListView_ExpandableListContextMenuInfo.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_id = jniAccessors.getFieldIDOf(_classRef, "id", "J");

  /// from: public long id
  ///
  /// The ID of the item (group or child) for which the context menu is
  /// being displayed.
  int get id =>
      jniAccessors.getField(reference, _id_id, jni.JniType.longType).long;

  /// from: public long id
  ///
  /// The ID of the item (group or child) for which the context menu is
  /// being displayed.
  set id(int value) => jniEnv.SetLongField(reference, _id_id, value);

  static final _id_packedPosition =
      jniAccessors.getFieldIDOf(_classRef, "packedPosition", "J");

  /// from: public long packedPosition
  ///
  /// The packed position in the list represented by the adapter for which
  /// the context menu is being displayed. Use the methods
  /// ExpandableListView\#getPackedPositionType,
  /// ExpandableListView\#getPackedPositionChild, and
  /// ExpandableListView\#getPackedPositionGroup to unpack this.
  int get packedPosition => jniAccessors
      .getField(reference, _id_packedPosition, jni.JniType.longType)
      .long;

  /// from: public long packedPosition
  ///
  /// The packed position in the list represented by the adapter for which
  /// the context menu is being displayed. Use the methods
  /// ExpandableListView\#getPackedPositionType,
  /// ExpandableListView\#getPackedPositionChild, and
  /// ExpandableListView\#getPackedPositionGroup to unpack this.
  set packedPosition(int value) =>
      jniEnv.SetLongField(reference, _id_packedPosition, value);

  static final _id_targetView =
      jniAccessors.getFieldIDOf(_classRef, "targetView", "Landroid/view/View;");

  /// from: public android.view.View targetView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The view for which the context menu is being displayed. This
  /// will be one of the children Views of this ExpandableListView.
  view_.View get targetView => view_.View.fromRef(jniAccessors
      .getField(reference, _id_targetView, jni.JniType.objectType)
      .object);

  /// from: public android.view.View targetView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The view for which the context menu is being displayed. This
  /// will be one of the children Views of this ExpandableListView.
  set targetView(view_.View value) =>
      jniEnv.SetObjectField(reference, _id_targetView, value.reference);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/View;JJ)V");

  /// from: public void <init>(android.view.View targetView, long packedPosition, long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExpandableListView_ExpandableListContextMenuInfo(
      view_.View targetView, int packedPosition, int id)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [targetView.reference, packedPosition, id]).object);
}
