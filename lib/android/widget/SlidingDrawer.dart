// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/ViewGroup.dart" as viewgroup_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../graphics/Canvas.dart" as canvas_;

import "../view/MotionEvent.dart" as motionevent_;

import "../view/View.dart" as view_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.SlidingDrawer
///
/// SlidingDrawer hides content out of the screen and allows the user to drag a handle
/// to bring the content on screen. SlidingDrawer can be used vertically or horizontally.
///
/// A special widget composed of two children views: the handle, that the users drags,
/// and the content, attached to the handle and dragged with it.
///
/// SlidingDrawer should be used as an overlay inside layouts. This means SlidingDrawer
/// should only be used inside of a FrameLayout or a RelativeLayout for instance. The
/// size of the SlidingDrawer defines how much space the content will occupy once slid
/// out so SlidingDrawer should usually use match_parent for both its dimensions.
///
/// Inside an XML layout, SlidingDrawer must define the id of the handle and of the
/// content:
///
/// <pre class="prettyprint">
/// &lt;SlidingDrawer
///     android:id="@+id/drawer"
///     android:layout_width="match_parent"
///     android:layout_height="match_parent"
///
///     android:handle="@+id/handle"
///     android:content="@+id/content"&gt;
///
///     &lt;ImageView
///         android:id="@id/handle"
///         android:layout_width="88dip"
///         android:layout_height="44dip" /&gt;
///
///     &lt;GridView
///         android:id="@id/content"
///         android:layout_width="match_parent"
///         android:layout_height="match_parent" /&gt;
///
/// &lt;/SlidingDrawer&gt;
/// </pre>
///@attr ref android.R.styleable\#SlidingDrawer_content
///@attr ref android.R.styleable\#SlidingDrawer_handle
///@attr ref android.R.styleable\#SlidingDrawer_topOffset
///@attr ref android.R.styleable\#SlidingDrawer_bottomOffset
///@attr ref android.R.styleable\#SlidingDrawer_orientation
///@attr ref android.R.styleable\#SlidingDrawer_allowSingleTap
///@attr ref android.R.styleable\#SlidingDrawer_animateOnClick
///@deprecated This class is not supported anymore. It is recommended you
/// base your own implementation on the source code for the Android Open
/// Source Project if you must use it in your application.
class SlidingDrawer extends viewgroup_.ViewGroup {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/SlidingDrawer");
  SlidingDrawer.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ORIENTATION_HORIZONTAL
  static const ORIENTATION_HORIZONTAL = 0;

  /// from: static public final int ORIENTATION_VERTICAL
  static const ORIENTATION_VERTICAL = 1;

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new SlidingDrawer from a specified set of attributes defined in XML.
  ///@param context The application's environment.
  ///@param attrs The attributes defined in XML.
  SlidingDrawer.ctor1(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new SlidingDrawer from a specified set of attributes defined in XML.
  ///@param context The application's environment.
  ///@param attrs The attributes defined in XML.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  SlidingDrawer.ctor2(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new SlidingDrawer from a specified set of attributes defined in XML.
  ///@param context The application's environment.
  ///@param attrs The attributes defined in XML.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  ///@param defStyleRes A resource identifier of a style resource that
  ///        supplies default values for the view, used only if
  ///        defStyleAttr is 0 or can not be found in the theme. Can be 0
  ///        to not look for defaults.
  SlidingDrawer.ctor3(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_onFinishInflate1 =
      jniAccessors.getMethodIDOf(_classRef, "onFinishInflate", "()V");

  /// from: protected void onFinishInflate()
  void onFinishInflate1() => jniAccessors.callMethodWithArgs(
      reference, _id_onFinishInflate1, jni.JniType.voidType, []).check();

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_dispatchDraw = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int l, int t, int r, int b)
  void onLayout(bool changed, int l, int t, int r, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, l, t, r, b]).check();

  static final _id_onInterceptTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onInterceptTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onInterceptTouchEvent(android.view.MotionEvent event)
  bool onInterceptTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onInterceptTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onTouchEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  bool onTouchEvent1(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_toggle =
      jniAccessors.getMethodIDOf(_classRef, "toggle", "()V");

  /// from: public void toggle()
  ///
  /// Toggles the drawer open and close. Takes effect immediately.
  ///@see \#open()
  ///@see \#close()
  ///@see \#animateClose()
  ///@see \#animateOpen()
  ///@see \#animateToggle()
  void toggle() => jniAccessors.callMethodWithArgs(
      reference, _id_toggle, jni.JniType.voidType, []).check();

  static final _id_animateToggle =
      jniAccessors.getMethodIDOf(_classRef, "animateToggle", "()V");

  /// from: public void animateToggle()
  ///
  /// Toggles the drawer open and close with an animation.
  ///@see \#open()
  ///@see \#close()
  ///@see \#animateClose()
  ///@see \#animateOpen()
  ///@see \#toggle()
  void animateToggle() => jniAccessors.callMethodWithArgs(
      reference, _id_animateToggle, jni.JniType.voidType, []).check();

  static final _id_open = jniAccessors.getMethodIDOf(_classRef, "open", "()V");

  /// from: public void open()
  ///
  /// Opens the drawer immediately.
  ///@see \#toggle()
  ///@see \#close()
  ///@see \#animateOpen()
  void open() => jniAccessors.callMethodWithArgs(
      reference, _id_open, jni.JniType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Closes the drawer immediately.
  ///@see \#toggle()
  ///@see \#open()
  ///@see \#animateClose()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_animateClose =
      jniAccessors.getMethodIDOf(_classRef, "animateClose", "()V");

  /// from: public void animateClose()
  ///
  /// Closes the drawer with an animation.
  ///@see \#close()
  ///@see \#open()
  ///@see \#animateOpen()
  ///@see \#animateToggle()
  ///@see \#toggle()
  void animateClose() => jniAccessors.callMethodWithArgs(
      reference, _id_animateClose, jni.JniType.voidType, []).check();

  static final _id_animateOpen =
      jniAccessors.getMethodIDOf(_classRef, "animateOpen", "()V");

  /// from: public void animateOpen()
  ///
  /// Opens the drawer with an animation.
  ///@see \#close()
  ///@see \#open()
  ///@see \#animateClose()
  ///@see \#animateToggle()
  ///@see \#toggle()
  void animateOpen() => jniAccessors.callMethodWithArgs(
      reference, _id_animateOpen, jni.JniType.voidType, []).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_setOnDrawerOpenListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDrawerOpenListener",
      "(Landroid/widget/SlidingDrawer\$OnDrawerOpenListener;)V");

  /// from: public void setOnDrawerOpenListener(android.widget.SlidingDrawer.OnDrawerOpenListener onDrawerOpenListener)
  ///
  /// Sets the listener that receives a notification when the drawer becomes open.
  ///@param onDrawerOpenListener The listener to be notified when the drawer is opened.
  void setOnDrawerOpenListener(
          SlidingDrawer_OnDrawerOpenListener onDrawerOpenListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDrawerOpenListener,
          jni.JniType.voidType, [onDrawerOpenListener.reference]).check();

  static final _id_setOnDrawerCloseListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDrawerCloseListener",
      "(Landroid/widget/SlidingDrawer\$OnDrawerCloseListener;)V");

  /// from: public void setOnDrawerCloseListener(android.widget.SlidingDrawer.OnDrawerCloseListener onDrawerCloseListener)
  ///
  /// Sets the listener that receives a notification when the drawer becomes close.
  ///@param onDrawerCloseListener The listener to be notified when the drawer is closed.
  void setOnDrawerCloseListener(
          SlidingDrawer_OnDrawerCloseListener onDrawerCloseListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDrawerCloseListener,
          jni.JniType.voidType, [onDrawerCloseListener.reference]).check();

  static final _id_setOnDrawerScrollListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDrawerScrollListener",
      "(Landroid/widget/SlidingDrawer\$OnDrawerScrollListener;)V");

  /// from: public void setOnDrawerScrollListener(android.widget.SlidingDrawer.OnDrawerScrollListener onDrawerScrollListener)
  ///
  /// Sets the listener that receives a notification when the drawer starts or ends
  /// a scroll. A fling is considered as a scroll. A fling will also trigger a
  /// drawer opened or drawer closed event.
  ///@param onDrawerScrollListener The listener to be notified when scrolling
  ///        starts or stops.
  void setOnDrawerScrollListener(
          SlidingDrawer_OnDrawerScrollListener onDrawerScrollListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDrawerScrollListener,
          jni.JniType.voidType, [onDrawerScrollListener.reference]).check();

  static final _id_getHandle = jniAccessors.getMethodIDOf(
      _classRef, "getHandle", "()Landroid/view/View;");

  /// from: public android.view.View getHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the handle of the drawer.
  ///@return The View reprenseting the handle of the drawer, identified by
  ///         the "handle" id in XML.
  view_.View getHandle() => view_.View.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getHandle, jni.JniType.objectType, []).object);

  static final _id_getContent = jniAccessors.getMethodIDOf(
      _classRef, "getContent", "()Landroid/view/View;");

  /// from: public android.view.View getContent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the content of the drawer.
  ///@return The View reprenseting the content of the drawer, identified by
  ///         the "content" id in XML.
  view_.View getContent() => view_.View.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getContent, jni.JniType.objectType, []).object);

  static final _id_unlock =
      jniAccessors.getMethodIDOf(_classRef, "unlock", "()V");

  /// from: public void unlock()
  ///
  /// Unlocks the SlidingDrawer so that touch events are processed.
  ///@see \#lock()
  void unlock() => jniAccessors.callMethodWithArgs(
      reference, _id_unlock, jni.JniType.voidType, []).check();

  static final _id_lock = jniAccessors.getMethodIDOf(_classRef, "lock", "()V");

  /// from: public void lock()
  ///
  /// Locks the SlidingDrawer so that touch events are ignores.
  ///@see \#unlock()
  void lock() => jniAccessors.callMethodWithArgs(
      reference, _id_lock, jni.JniType.voidType, []).check();

  static final _id_isOpened =
      jniAccessors.getMethodIDOf(_classRef, "isOpened", "()Z");

  /// from: public boolean isOpened()
  ///
  /// Indicates whether the drawer is currently fully opened.
  ///@return True if the drawer is opened, false otherwise.
  bool isOpened() => jniAccessors.callMethodWithArgs(
      reference, _id_isOpened, jni.JniType.booleanType, []).boolean;

  static final _id_isMoving =
      jniAccessors.getMethodIDOf(_classRef, "isMoving", "()Z");

  /// from: public boolean isMoving()
  ///
  /// Indicates whether the drawer is scrolling or flinging.
  ///@return True if the drawer is scroller or flinging, false otherwise.
  bool isMoving() => jniAccessors.callMethodWithArgs(
      reference, _id_isMoving, jni.JniType.booleanType, []).boolean;
}

/// from: android.widget.SlidingDrawer$OnDrawerScrollListener
///
/// Callback invoked when the drawer is scrolled.
class SlidingDrawer_OnDrawerScrollListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/SlidingDrawer\$OnDrawerScrollListener");
  SlidingDrawer_OnDrawerScrollListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onScrollStarted =
      jniAccessors.getMethodIDOf(_classRef, "onScrollStarted", "()V");

  /// from: public abstract void onScrollStarted()
  ///
  /// Invoked when the user starts dragging/flinging the drawer's handle.
  void onScrollStarted() => jniAccessors.callMethodWithArgs(
      reference, _id_onScrollStarted, jni.JniType.voidType, []).check();

  static final _id_onScrollEnded =
      jniAccessors.getMethodIDOf(_classRef, "onScrollEnded", "()V");

  /// from: public abstract void onScrollEnded()
  ///
  /// Invoked when the user stops dragging/flinging the drawer's handle.
  void onScrollEnded() => jniAccessors.callMethodWithArgs(
      reference, _id_onScrollEnded, jni.JniType.voidType, []).check();
}

/// from: android.widget.SlidingDrawer$OnDrawerOpenListener
///
/// Callback invoked when the drawer is opened.
class SlidingDrawer_OnDrawerOpenListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/SlidingDrawer\$OnDrawerOpenListener");
  SlidingDrawer_OnDrawerOpenListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onDrawerOpened =
      jniAccessors.getMethodIDOf(_classRef, "onDrawerOpened", "()V");

  /// from: public abstract void onDrawerOpened()
  ///
  /// Invoked when the drawer becomes fully open.
  void onDrawerOpened() => jniAccessors.callMethodWithArgs(
      reference, _id_onDrawerOpened, jni.JniType.voidType, []).check();
}

/// from: android.widget.SlidingDrawer$OnDrawerCloseListener
///
/// Callback invoked when the drawer is closed.
class SlidingDrawer_OnDrawerCloseListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/SlidingDrawer\$OnDrawerCloseListener");
  SlidingDrawer_OnDrawerCloseListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onDrawerClosed =
      jniAccessors.getMethodIDOf(_classRef, "onDrawerClosed", "()V");

  /// from: public abstract void onDrawerClosed()
  ///
  /// Invoked when the drawer becomes fully closed.
  void onDrawerClosed() => jniAccessors.callMethodWithArgs(
      reference, _id_onDrawerClosed, jni.JniType.voidType, []).check();
}
