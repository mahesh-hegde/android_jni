// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../view/View.dart" as view_;

import "../transition/Transition.dart" as transition_;

import "../graphics/drawable/Drawable.dart" as drawable_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.PopupWindow
///
///
/// This class represents a popup window that can be used to display an
/// arbitrary view. The popup window is a floating container that appears on top
/// of the current activity.
///
///
/// <a name="Animation"></a>
/// <h3>Animation</h3>
///
/// On all versions of Android, popup window enter and exit animations may be
/// specified by calling \#setAnimationStyle(int) and passing the
/// resource ID for an animation style that defines {@code windowEnterAnimation}
/// and {@code windowExitAnimation}. For example, passing
/// android.R.style\#Animation_Dialog will give a scale and alpha
/// animation.
/// </br>
/// A window animation style may also be specified in the popup window's style
/// XML via the android.R.styleable\#PopupWindow_popupAnimationStyle popupAnimationStyle
/// attribute.
///
///
///
/// Starting with API 23, more complex popup window enter and exit transitions
/// may be specified by calling either \#setEnterTransition(Transition)
/// or \#setExitTransition(Transition) and passing a  Transition.
/// </br>
/// Popup enter and exit transitions may also be specified in the popup window's
/// style XML via the android.R.styleable\#PopupWindow_popupEnterTransition popupEnterTransition
/// and android.R.styleable\#PopupWindow_popupExitTransition popupExitTransition
/// attributes, respectively.
///
///
///@attr ref android.R.styleable\#PopupWindow_overlapAnchor
///@attr ref android.R.styleable\#PopupWindow_popupAnimationStyle
///@attr ref android.R.styleable\#PopupWindow_popupBackground
///@attr ref android.R.styleable\#PopupWindow_popupElevation
///@attr ref android.R.styleable\#PopupWindow_popupEnterTransition
///@attr ref android.R.styleable\#PopupWindow_popupExitTransition
///@see android.widget.AutoCompleteTextView
///@see android.widget.Spinner
class PopupWindow extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/PopupWindow");
  PopupWindow.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int INPUT_METHOD_FROM_FOCUSABLE
  ///
  /// Mode for \#setInputMethodMode(int): the requirements for the
  /// input method should be based on the focusability of the popup.  That is
  /// if it is focusable than it needs to work with the input method, else
  /// it doesn't.
  static const INPUT_METHOD_FROM_FOCUSABLE = 0;

  /// from: static public final int INPUT_METHOD_NEEDED
  ///
  /// Mode for \#setInputMethodMode(int): this popup always needs to
  /// work with an input method, regardless of whether it is focusable.  This
  /// means that it will always be displayed so that the user can also operate
  /// the input method while it is shown.
  static const INPUT_METHOD_NEEDED = 1;

  /// from: static public final int INPUT_METHOD_NOT_NEEDED
  ///
  /// Mode for \#setInputMethodMode(int): this popup never needs to
  /// work with an input method, regardless of whether it is focusable.  This
  /// means that it will always be displayed to use as much space on the
  /// screen as needed, regardless of whether this covers the input method.
  static const INPUT_METHOD_NOT_NEEDED = 2;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new empty, non focusable popup window of dimension (0,0).
  ///
  ///
  /// The popup does provide a background.
  ///
  PopupWindow(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new empty, non focusable popup window of dimension (0,0).
  ///
  ///
  /// The popup does provide a background.
  ///
  PopupWindow.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new empty, non focusable popup window of dimension (0,0).
  ///
  ///
  /// The popup does provide a background.
  ///
  PopupWindow.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new, empty, non focusable popup window of dimension (0,0).
  ///
  ///
  /// The popup does not provide a background.
  ///
  PopupWindow.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new empty, non focusable popup window of dimension (0,0).
  ///
  ///
  /// The popup does not provide any background. This should be handled
  /// by the content view.
  ///
  PopupWindow.ctor4()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor4, []).object);

  static final _id_ctor5 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/view/View;)V");

  /// from: public void <init>(android.view.View contentView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new non focusable popup window which can display the
  /// <tt>contentView</tt>. The dimension of the window are (0,0).
  ///
  ///
  /// The popup does not provide any background. This should be handled
  /// by the content view.
  ///
  ///@param contentView the popup's content
  PopupWindow.ctor5(view_.View contentView)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor5, [contentView.reference]).object);

  static final _id_ctor6 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new empty, non focusable popup window. The dimension of the
  /// window must be passed to this constructor.
  ///
  ///
  /// The popup does not provide any background. This should be handled
  /// by the content view.
  ///
  ///@param width the popup's width
  ///@param height the popup's height
  PopupWindow.ctor6(int width, int height)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor6, [width, height]).object);

  static final _id_ctor7 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/View;II)V");

  /// from: public void <init>(android.view.View contentView, int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new non focusable popup window which can display the
  /// <tt>contentView</tt>. The dimension of the window must be passed to
  /// this constructor.
  ///
  ///
  /// The popup does not provide any background. This should be handled
  /// by the content view.
  ///
  ///@param contentView the popup's content
  ///@param width the popup's width
  ///@param height the popup's height
  PopupWindow.ctor7(view_.View contentView, int width, int height)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor7,
            [contentView.reference, width, height]).object);

  static final _id_ctor8 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/View;IIZ)V");

  /// from: public void <init>(android.view.View contentView, int width, int height, boolean focusable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new popup window which can display the <tt>contentView</tt>.
  /// The dimension of the window must be passed to this constructor.
  ///
  ///
  /// The popup does not provide any background. This should be handled
  /// by the content view.
  ///
  ///@param contentView the popup's content
  ///@param width the popup's width
  ///@param height the popup's height
  ///@param focusable true if the popup can be focused, false otherwise
  PopupWindow.ctor8(
      view_.View contentView, int width, int height, bool focusable)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor8,
            [contentView.reference, width, height, focusable]).object);

  static final _id_setEnterTransition = jniAccessors.getMethodIDOf(
      _classRef, "setEnterTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setEnterTransition(android.transition.Transition enterTransition)
  ///
  /// Sets the enter transition to be used when the popup window is shown.
  ///@param enterTransition the enter transition, or {@code null} to clear
  /// This value may be {@code null}.
  ///@see \#getEnterTransition()
  ///@attr ref android.R.styleable\#PopupWindow_popupEnterTransition
  void setEnterTransition(transition_.Transition enterTransition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEnterTransition,
          jni.JniType.voidType, [enterTransition.reference]).check();

  static final _id_getEnterTransition = jniAccessors.getMethodIDOf(
      _classRef, "getEnterTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getEnterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the enter transition to be used when the popup window is shown.
  ///@return the enter transition, or {@code null} if not set
  ///@see \#setEnterTransition(Transition)
  ///@attr ref android.R.styleable\#PopupWindow_popupEnterTransition
  transition_.Transition getEnterTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getEnterTransition, jni.JniType.objectType, []).object);

  static final _id_setExitTransition = jniAccessors.getMethodIDOf(
      _classRef, "setExitTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setExitTransition(android.transition.Transition exitTransition)
  ///
  /// Sets the exit transition to be used when the popup window is dismissed.
  ///@param exitTransition the exit transition, or {@code null} to clear
  /// This value may be {@code null}.
  ///@see \#getExitTransition()
  ///@attr ref android.R.styleable\#PopupWindow_popupExitTransition
  void setExitTransition(transition_.Transition exitTransition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setExitTransition,
          jni.JniType.voidType, [exitTransition.reference]).check();

  static final _id_getExitTransition = jniAccessors.getMethodIDOf(
      _classRef, "getExitTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getExitTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the exit transition to be used when the popup window is
  /// dismissed.
  ///@return the exit transition, or {@code null} if not set
  ///@see \#setExitTransition(Transition)
  ///@attr ref android.R.styleable\#PopupWindow_popupExitTransition
  transition_.Transition getExitTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExitTransition, jni.JniType.objectType, []).object);

  static final _id_getBackground = jniAccessors.getMethodIDOf(
      _classRef, "getBackground", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getBackground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the drawable used as the popup window's background.
  ///@return the background drawable or {@code null} if not set
  ///@see \#setBackgroundDrawable(Drawable)
  ///@attr ref android.R.styleable\#PopupWindow_popupBackground
  drawable_.Drawable getBackground() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBackground, jni.JniType.objectType, []).object);

  static final _id_setBackgroundDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setBackgroundDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setBackgroundDrawable(android.graphics.drawable.Drawable background)
  ///
  /// Specifies the background drawable for this popup window. The background
  /// can be set to {@code null}.
  ///@param background the popup's background
  ///@see \#getBackground()
  ///@attr ref android.R.styleable\#PopupWindow_popupBackground
  void setBackgroundDrawable(drawable_.Drawable background) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBackgroundDrawable,
          jni.JniType.voidType, [background.reference]).check();

  static final _id_getElevation =
      jniAccessors.getMethodIDOf(_classRef, "getElevation", "()F");

  /// from: public float getElevation()
  ///
  /// @return the elevation for this popup window in pixels
  ///@see \#setElevation(float)
  ///@attr ref android.R.styleable\#PopupWindow_popupElevation
  double getElevation() => jniAccessors.callMethodWithArgs(
      reference, _id_getElevation, jni.JniType.floatType, []).float;

  static final _id_setElevation =
      jniAccessors.getMethodIDOf(_classRef, "setElevation", "(F)V");

  /// from: public void setElevation(float elevation)
  ///
  /// Specifies the elevation for this popup window.
  ///@param elevation the popup's elevation in pixels
  ///@see \#getElevation()
  ///@attr ref android.R.styleable\#PopupWindow_popupElevation
  void setElevation(double elevation) => jniAccessors.callMethodWithArgs(
      reference, _id_setElevation, jni.JniType.voidType, [elevation]).check();

  static final _id_getAnimationStyle =
      jniAccessors.getMethodIDOf(_classRef, "getAnimationStyle", "()I");

  /// from: public int getAnimationStyle()
  ///
  /// Return the animation style to use the popup appears and disappears
  ///
  ///@return the animation style to use the popup appears and disappears
  int getAnimationStyle() => jniAccessors.callMethodWithArgs(
      reference, _id_getAnimationStyle, jni.JniType.intType, []).integer;

  static final _id_setIgnoreCheekPress =
      jniAccessors.getMethodIDOf(_classRef, "setIgnoreCheekPress", "()V");

  /// from: public void setIgnoreCheekPress()
  ///
  /// Set the flag on popup to ignore cheek press events; by default this flag
  /// is set to false
  /// which means the popup will not ignore cheek press dispatch events.
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown or through a manual call to one of
  /// the \#update() methods.
  ///
  ///@see \#update()
  void setIgnoreCheekPress() => jniAccessors.callMethodWithArgs(
      reference, _id_setIgnoreCheekPress, jni.JniType.voidType, []).check();

  static final _id_setAnimationStyle =
      jniAccessors.getMethodIDOf(_classRef, "setAnimationStyle", "(I)V");

  /// from: public void setAnimationStyle(int animationStyle)
  ///
  /// Change the animation style resource for this popup.
  ///
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown or through a manual call to one of
  /// the \#update() methods.
  ///
  ///@param animationStyle animation style to use when the popup appears
  ///      and disappears.  Set to -1 for the default animation, 0 for no
  ///      animation, or a resource identifier for an explicit animation.
  ///@see \#update()
  void setAnimationStyle(int animationStyle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAnimationStyle,
      jni.JniType.voidType,
      [animationStyle]).check();

  static final _id_getContentView = jniAccessors.getMethodIDOf(
      _classRef, "getContentView", "()Landroid/view/View;");

  /// from: public android.view.View getContentView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the view used as the content of the popup window.
  ///
  ///@return a android.view.View representing the popup's content
  ///@see \#setContentView(android.view.View)
  view_.View getContentView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContentView, jni.JniType.objectType, []).object);

  static final _id_setContentView = jniAccessors.getMethodIDOf(
      _classRef, "setContentView", "(Landroid/view/View;)V");

  /// from: public void setContentView(android.view.View contentView)
  ///
  /// Change the popup's content. The content is represented by an instance
  /// of android.view.View.
  ///
  ///
  /// This method has no effect if called when the popup is showing.
  ///
  ///@param contentView the new content for the popup
  ///@see \#getContentView()
  ///@see \#isShowing()
  void setContentView(view_.View contentView) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentView,
          jni.JniType.voidType, [contentView.reference]).check();

  static final _id_setTouchInterceptor = jniAccessors.getMethodIDOf(_classRef,
      "setTouchInterceptor", "(Landroid/view/View\$OnTouchListener;)V");

  /// from: public void setTouchInterceptor(android.view.View.OnTouchListener l)
  ///
  /// Set a callback for all touch events being dispatched to the popup
  /// window.
  void setTouchInterceptor(view_.View_OnTouchListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTouchInterceptor,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_isFocusable =
      jniAccessors.getMethodIDOf(_classRef, "isFocusable", "()Z");

  /// from: public boolean isFocusable()
  ///
  /// Indicate whether the popup window can grab the focus.
  ///
  ///@return true if the popup is focusable, false otherwise
  ///@see \#setFocusable(boolean)
  bool isFocusable() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocusable, jni.JniType.booleanType, []).boolean;

  static final _id_setFocusable =
      jniAccessors.getMethodIDOf(_classRef, "setFocusable", "(Z)V");

  /// from: public void setFocusable(boolean focusable)
  ///
  /// Changes the focusability of the popup window. When focusable, the
  /// window will grab the focus from the current focused widget if the popup
  /// contains a focusable android.view.View.  By default a popup
  /// window is not focusable.
  ///
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown or through a manual call to one of
  /// the \#update() methods.
  ///
  ///@param focusable true if the popup should grab focus, false otherwise.
  ///@see \#isFocusable()
  ///@see \#isShowing()
  ///@see \#update()
  void setFocusable(bool focusable) => jniAccessors.callMethodWithArgs(
      reference, _id_setFocusable, jni.JniType.voidType, [focusable]).check();

  static final _id_getInputMethodMode =
      jniAccessors.getMethodIDOf(_classRef, "getInputMethodMode", "()I");

  /// from: public int getInputMethodMode()
  ///
  /// Return the current value in \#setInputMethodMode(int).
  ///@see \#setInputMethodMode(int)
  int getInputMethodMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getInputMethodMode, jni.JniType.intType, []).integer;

  static final _id_setInputMethodMode =
      jniAccessors.getMethodIDOf(_classRef, "setInputMethodMode", "(I)V");

  /// from: public void setInputMethodMode(int mode)
  ///
  /// Control how the popup operates with an input method: one of
  /// \#INPUT_METHOD_FROM_FOCUSABLE, \#INPUT_METHOD_NEEDED,
  /// or \#INPUT_METHOD_NOT_NEEDED.
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown or through a manual call to one of
  /// the \#update() methods.
  ///
  ///@see \#getInputMethodMode()
  ///@see \#update()
  void setInputMethodMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setInputMethodMode, jni.JniType.voidType, [mode]).check();

  static final _id_setSoftInputMode =
      jniAccessors.getMethodIDOf(_classRef, "setSoftInputMode", "(I)V");

  /// from: public void setSoftInputMode(int mode)
  ///
  /// Sets the operating mode for the soft input area.
  ///@param mode The desired mode, see
  ///        android.view.WindowManager.LayoutParams\#softInputMode
  ///        for the full list
  ///
  /// Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNCHANGED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_RESIZE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_PAN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_NOTHING, and android.view.WindowManager.LayoutParams\#SOFT_INPUT_IS_FORWARD_NAVIGATION
  ///@see android.view.WindowManager.LayoutParams\#softInputMode
  ///@see \#getSoftInputMode()
  void setSoftInputMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setSoftInputMode, jni.JniType.voidType, [mode]).check();

  static final _id_getSoftInputMode =
      jniAccessors.getMethodIDOf(_classRef, "getSoftInputMode", "()I");

  /// from: public int getSoftInputMode()
  ///
  /// Returns the current value in \#setSoftInputMode(int).
  ///@see \#setSoftInputMode(int)
  ///@see android.view.WindowManager.LayoutParams\#softInputMode
  ///@return Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNCHANGED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_RESIZE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_PAN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_NOTHING, and android.view.WindowManager.LayoutParams\#SOFT_INPUT_IS_FORWARD_NAVIGATION
  int getSoftInputMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getSoftInputMode, jni.JniType.intType, []).integer;

  static final _id_isTouchable =
      jniAccessors.getMethodIDOf(_classRef, "isTouchable", "()Z");

  /// from: public boolean isTouchable()
  ///
  /// Indicates whether the popup window receives touch events.
  ///
  ///@return true if the popup is touchable, false otherwise
  ///@see \#setTouchable(boolean)
  bool isTouchable() => jniAccessors.callMethodWithArgs(
      reference, _id_isTouchable, jni.JniType.booleanType, []).boolean;

  static final _id_setTouchable =
      jniAccessors.getMethodIDOf(_classRef, "setTouchable", "(Z)V");

  /// from: public void setTouchable(boolean touchable)
  ///
  /// Changes the touchability of the popup window. When touchable, the
  /// window will receive touch events, otherwise touch events will go to the
  /// window below it. By default the window is touchable.
  ///
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown or through a manual call to one of
  /// the \#update() methods.
  ///
  ///@param touchable true if the popup should receive touch events, false otherwise
  ///@see \#isTouchable()
  ///@see \#isShowing()
  ///@see \#update()
  void setTouchable(bool touchable) => jniAccessors.callMethodWithArgs(
      reference, _id_setTouchable, jni.JniType.voidType, [touchable]).check();

  static final _id_isOutsideTouchable =
      jniAccessors.getMethodIDOf(_classRef, "isOutsideTouchable", "()Z");

  /// from: public boolean isOutsideTouchable()
  ///
  /// Indicates whether the popup window will be informed of touch events
  /// outside of its window.
  ///
  ///@return true if the popup is outside touchable, false otherwise
  ///@see \#setOutsideTouchable(boolean)
  bool isOutsideTouchable() => jniAccessors.callMethodWithArgs(
      reference, _id_isOutsideTouchable, jni.JniType.booleanType, []).boolean;

  static final _id_setOutsideTouchable =
      jniAccessors.getMethodIDOf(_classRef, "setOutsideTouchable", "(Z)V");

  /// from: public void setOutsideTouchable(boolean touchable)
  ///
  /// Controls whether the pop-up will be informed of touch events outside
  /// of its window.  This only makes sense for pop-ups that are touchable
  /// but not focusable, which means touches outside of the window will
  /// be delivered to the window behind.  The default is false.
  ///
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown or through a manual call to one of
  /// the \#update() methods.
  ///
  ///@param touchable true if the popup should receive outside
  /// touch events, false otherwise
  ///@see \#isOutsideTouchable()
  ///@see \#isShowing()
  ///@see \#update()
  void setOutsideTouchable(bool touchable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOutsideTouchable,
      jni.JniType.voidType,
      [touchable]).check();

  static final _id_isClippingEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isClippingEnabled", "()Z");

  /// from: public boolean isClippingEnabled()
  ///
  /// Indicates whether clipping of the popup window is enabled.
  ///
  ///@return true if the clipping is enabled, false otherwise
  ///@see \#setClippingEnabled(boolean)
  bool isClippingEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isClippingEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setClippingEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setClippingEnabled", "(Z)V");

  /// from: public void setClippingEnabled(boolean enabled)
  ///
  /// Allows the popup window to extend beyond the bounds of the screen. By default the
  /// window is clipped to the screen boundaries. Setting this to false will allow windows to be
  /// accurately positioned.
  ///
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown or through a manual call to one of
  /// the \#update() methods.
  ///
  ///@param enabled false if the window should be allowed to extend outside of the screen
  ///@see \#isShowing()
  ///@see \#isClippingEnabled()
  ///@see \#update()
  void setClippingEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClippingEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_isSplitTouchEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isSplitTouchEnabled", "()Z");

  /// from: public boolean isSplitTouchEnabled()
  ///
  /// Indicates whether the popup window supports splitting touches.
  ///
  ///@return true if the touch splitting is enabled, false otherwise
  ///@see \#setSplitTouchEnabled(boolean)
  bool isSplitTouchEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isSplitTouchEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setSplitTouchEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setSplitTouchEnabled", "(Z)V");

  /// from: public void setSplitTouchEnabled(boolean enabled)
  ///
  /// Allows the popup window to split touches across other windows that also
  /// support split touch.  When this flag is false, the first pointer
  /// that goes down determines the window to which all subsequent touches
  /// go until all pointers go up.  When this flag is true, each pointer
  /// (not necessarily the first) that goes down determines the window
  /// to which all subsequent touches of that pointer will go until that
  /// pointer goes up thereby enabling touches with multiple pointers
  /// to be split across multiple windows.
  ///
  ///@param enabled true if the split touches should be enabled, false otherwise
  ///@see \#isSplitTouchEnabled()
  void setSplitTouchEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSplitTouchEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_isAttachedInDecor =
      jniAccessors.getMethodIDOf(_classRef, "isAttachedInDecor", "()Z");

  /// from: public boolean isAttachedInDecor()
  ///
  /// Indicates whether the popup window will be attached in the decor frame of its parent
  /// window.
  ///@return true if the window will be attached to the decor frame of its parent window.
  ///@see \#setAttachedInDecor(boolean)
  ///@see WindowManager.LayoutParams\#FLAG_LAYOUT_ATTACHED_IN_DECOR
  bool isAttachedInDecor() => jniAccessors.callMethodWithArgs(
      reference, _id_isAttachedInDecor, jni.JniType.booleanType, []).boolean;

  static final _id_setAttachedInDecor =
      jniAccessors.getMethodIDOf(_classRef, "setAttachedInDecor", "(Z)V");

  /// from: public void setAttachedInDecor(boolean enabled)
  ///
  /// This will attach the popup window to the decor frame of the parent window to avoid
  /// overlaping with screen decorations like the navigation bar. Overrides the default behavior of
  /// the flag WindowManager.LayoutParams\#FLAG_LAYOUT_ATTACHED_IN_DECOR.
  ///
  /// By default the flag is set on SDK version Build.VERSION_CODES\#LOLLIPOP_MR1 or
  /// greater and cleared on lesser SDK versions.
  ///@param enabled true if the popup should be attached to the decor frame of its parent window.
  ///@see WindowManager.LayoutParams\#FLAG_LAYOUT_ATTACHED_IN_DECOR
  void setAttachedInDecor(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAttachedInDecor,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_setWindowLayoutType =
      jniAccessors.getMethodIDOf(_classRef, "setWindowLayoutType", "(I)V");

  /// from: public void setWindowLayoutType(int layoutType)
  ///
  /// Set the layout type for this window.
  ///
  /// See WindowManager.LayoutParams\#type for possible values.
  ///@param layoutType Layout type for this window.
  ///@see WindowManager.LayoutParams\#type
  void setWindowLayoutType(int layoutType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWindowLayoutType,
      jni.JniType.voidType,
      [layoutType]).check();

  static final _id_getWindowLayoutType =
      jniAccessors.getMethodIDOf(_classRef, "getWindowLayoutType", "()I");

  /// from: public int getWindowLayoutType()
  ///
  /// Returns the layout type for this window.
  ///@see \#setWindowLayoutType(int)
  int getWindowLayoutType() => jniAccessors.callMethodWithArgs(
      reference, _id_getWindowLayoutType, jni.JniType.intType, []).integer;

  static final _id_setWindowLayoutMode =
      jniAccessors.getMethodIDOf(_classRef, "setWindowLayoutMode", "(II)V");

  /// from: public void setWindowLayoutMode(int widthSpec, int heightSpec)
  ///
  /// Change the width and height measure specs that are given to the
  /// window manager by the popup.  By default these are 0, meaning that
  /// the current width or height is requested as an explicit size from
  /// the window manager.  You can supply
  /// ViewGroup.LayoutParams\#WRAP_CONTENT or
  /// ViewGroup.LayoutParams\#MATCH_PARENT to have that measure
  /// spec supplied instead, replacing the absolute width and height that
  /// has been set in the popup.
  ///
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown.
  ///
  ///@param widthSpec an explicit width measure spec mode, either
  /// ViewGroup.LayoutParams\#WRAP_CONTENT,
  /// ViewGroup.LayoutParams\#MATCH_PARENT, or 0 to use the absolute
  /// width.
  ///@param heightSpec an explicit height measure spec mode, either
  /// ViewGroup.LayoutParams\#WRAP_CONTENT,
  /// ViewGroup.LayoutParams\#MATCH_PARENT, or 0 to use the absolute
  /// height.
  ///@deprecated Use \#setWidth(int) and \#setHeight(int).
  void setWindowLayoutMode(int widthSpec, int heightSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWindowLayoutMode,
          jni.JniType.voidType, [widthSpec, heightSpec]).check();

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Returns the popup's requested height. May be a layout constant such as
  /// LayoutParams\#WRAP_CONTENT or LayoutParams\#MATCH_PARENT.
  ///
  /// The actual size of the popup may depend on other factors such as
  /// clipping and window layout.
  ///@return the popup height in pixels or a layout constant
  ///@see \#setHeight(int)
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_setHeight =
      jniAccessors.getMethodIDOf(_classRef, "setHeight", "(I)V");

  /// from: public void setHeight(int height)
  ///
  /// Sets the popup's requested height. May be a layout constant such as
  /// LayoutParams\#WRAP_CONTENT or LayoutParams\#MATCH_PARENT.
  ///
  /// The actual size of the popup may depend on other factors such as
  /// clipping and window layout.
  ///
  /// If the popup is showing, calling this method will take effect the next
  /// time the popup is shown.
  ///@param height the popup height in pixels or a layout constant
  ///@see \#getHeight()
  ///@see \#isShowing()
  void setHeight(int height) => jniAccessors.callMethodWithArgs(
      reference, _id_setHeight, jni.JniType.voidType, [height]).check();

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Returns the popup's requested width. May be a layout constant such as
  /// LayoutParams\#WRAP_CONTENT or LayoutParams\#MATCH_PARENT.
  ///
  /// The actual size of the popup may depend on other factors such as
  /// clipping and window layout.
  ///@return the popup width in pixels or a layout constant
  ///@see \#setWidth(int)
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_setWidth =
      jniAccessors.getMethodIDOf(_classRef, "setWidth", "(I)V");

  /// from: public void setWidth(int width)
  ///
  /// Sets the popup's requested width. May be a layout constant such as
  /// LayoutParams\#WRAP_CONTENT or LayoutParams\#MATCH_PARENT.
  ///
  /// The actual size of the popup may depend on other factors such as
  /// clipping and window layout.
  ///
  /// If the popup is showing, calling this method will take effect the next
  /// time the popup is shown.
  ///@param width the popup width in pixels or a layout constant
  ///@see \#getWidth()
  ///@see \#isShowing()
  void setWidth(int width) => jniAccessors.callMethodWithArgs(
      reference, _id_setWidth, jni.JniType.voidType, [width]).check();

  static final _id_setOverlapAnchor =
      jniAccessors.getMethodIDOf(_classRef, "setOverlapAnchor", "(Z)V");

  /// from: public void setOverlapAnchor(boolean overlapAnchor)
  ///
  /// Sets whether the popup window should overlap its anchor view when
  /// displayed as a drop-down.
  ///
  /// If the popup is showing, calling this method will take effect only
  /// the next time the popup is shown.
  ///@param overlapAnchor Whether the popup should overlap its anchor.
  ///@see \#getOverlapAnchor()
  ///@see \#isShowing()
  void setOverlapAnchor(bool overlapAnchor) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOverlapAnchor,
      jni.JniType.voidType,
      [overlapAnchor]).check();

  static final _id_getOverlapAnchor =
      jniAccessors.getMethodIDOf(_classRef, "getOverlapAnchor", "()Z");

  /// from: public boolean getOverlapAnchor()
  ///
  /// Returns whether the popup window should overlap its anchor view when
  /// displayed as a drop-down.
  ///@return Whether the popup should overlap its anchor.
  ///@see \#setOverlapAnchor(boolean)
  bool getOverlapAnchor() => jniAccessors.callMethodWithArgs(
      reference, _id_getOverlapAnchor, jni.JniType.booleanType, []).boolean;

  static final _id_isShowing =
      jniAccessors.getMethodIDOf(_classRef, "isShowing", "()Z");

  /// from: public boolean isShowing()
  ///
  /// Indicate whether this popup window is showing on screen.
  ///
  ///@return true if the popup is showing, false otherwise
  bool isShowing() => jniAccessors.callMethodWithArgs(
      reference, _id_isShowing, jni.JniType.booleanType, []).boolean;

  static final _id_showAtLocation = jniAccessors.getMethodIDOf(
      _classRef, "showAtLocation", "(Landroid/view/View;III)V");

  /// from: public void showAtLocation(android.view.View parent, int gravity, int x, int y)
  ///
  ///
  /// Display the content view in a popup window at the specified location. If the popup window
  /// cannot fit on screen, it will be clipped. See android.view.WindowManager.LayoutParams
  /// for more information on how gravity and the x and y parameters are related. Specifying
  /// a gravity of android.view.Gravity\#NO_GRAVITY is similar to specifying
  /// <code>Gravity.LEFT | Gravity.TOP</code>.
  ///
  ///
  ///@param parent a parent view to get the android.view.View\#getWindowToken() token from
  ///@param gravity the gravity which controls the placement of the popup window
  ///@param x the popup's x location offset
  ///@param y the popup's y location offset
  void showAtLocation(view_.View parent, int gravity, int x, int y) =>
      jniAccessors.callMethodWithArgs(reference, _id_showAtLocation,
          jni.JniType.voidType, [parent.reference, gravity, x, y]).check();

  static final _id_showAsDropDown = jniAccessors.getMethodIDOf(
      _classRef, "showAsDropDown", "(Landroid/view/View;)V");

  /// from: public void showAsDropDown(android.view.View anchor)
  ///
  /// Display the content view in a popup window anchored to the bottom-left
  /// corner of the anchor view. If there is not enough room on screen to show
  /// the popup in its entirety, this method tries to find a parent scroll
  /// view to scroll. If no parent scroll view can be scrolled, the
  /// bottom-left corner of the popup is pinned at the top left corner of the
  /// anchor view.
  ///@param anchor the view on which to pin the popup window
  ///@see \#dismiss()
  void showAsDropDown(view_.View anchor) => jniAccessors.callMethodWithArgs(
      reference,
      _id_showAsDropDown,
      jni.JniType.voidType,
      [anchor.reference]).check();

  static final _id_showAsDropDown1 = jniAccessors.getMethodIDOf(
      _classRef, "showAsDropDown", "(Landroid/view/View;II)V");

  /// from: public void showAsDropDown(android.view.View anchor, int xoff, int yoff)
  ///
  /// Display the content view in a popup window anchored to the bottom-left
  /// corner of the anchor view offset by the specified x and y coordinates.
  /// If there is not enough room on screen to show the popup in its entirety,
  /// this method tries to find a parent scroll view to scroll. If no parent
  /// scroll view can be scrolled, the bottom-left corner of the popup is
  /// pinned at the top left corner of the anchor view.
  ///
  /// If the view later scrolls to move <code>anchor</code> to a different
  /// location, the popup will be moved correspondingly.
  ///@param anchor the view on which to pin the popup window
  ///@param xoff A horizontal offset from the anchor in pixels
  ///@param yoff A vertical offset from the anchor in pixels
  ///@see \#dismiss()
  void showAsDropDown1(view_.View anchor, int xoff, int yoff) =>
      jniAccessors.callMethodWithArgs(reference, _id_showAsDropDown1,
          jni.JniType.voidType, [anchor.reference, xoff, yoff]).check();

  static final _id_showAsDropDown2 = jniAccessors.getMethodIDOf(
      _classRef, "showAsDropDown", "(Landroid/view/View;III)V");

  /// from: public void showAsDropDown(android.view.View anchor, int xoff, int yoff, int gravity)
  ///
  /// Displays the content view in a popup window anchored to the corner of
  /// another view. The window is positioned according to the specified
  /// gravity and offset by the specified x and y coordinates.
  ///
  /// If there is not enough room on screen to show the popup in its entirety,
  /// this method tries to find a parent scroll view to scroll. If no parent
  /// view can be scrolled, the specified vertical gravity will be ignored and
  /// the popup will anchor itself such that it is visible.
  ///
  /// If the view later scrolls to move <code>anchor</code> to a different
  /// location, the popup will be moved correspondingly.
  ///@param anchor the view on which to pin the popup window
  ///@param xoff A horizontal offset from the anchor in pixels
  ///@param yoff A vertical offset from the anchor in pixels
  ///@param gravity Alignment of the popup relative to the anchor
  ///@see \#dismiss()
  void showAsDropDown2(view_.View anchor, int xoff, int yoff, int gravity) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_showAsDropDown2,
          jni.JniType.voidType,
          [anchor.reference, xoff, yoff, gravity]).check();

  static final _id_isAboveAnchor =
      jniAccessors.getMethodIDOf(_classRef, "isAboveAnchor", "()Z");

  /// from: public boolean isAboveAnchor()
  ///
  /// Indicates whether the popup is showing above (the y coordinate of the popup's bottom
  /// is less than the y coordinate of the anchor) or below the anchor view (the y coordinate
  /// of the popup is greater than y coordinate of the anchor's bottom).
  ///
  /// The value returned
  /// by this method is meaningful only after \#showAsDropDown(android.view.View)
  /// or \#showAsDropDown(android.view.View, int, int) was invoked.
  ///@return True if this popup is showing above the anchor view, false otherwise.
  bool isAboveAnchor() => jniAccessors.callMethodWithArgs(
      reference, _id_isAboveAnchor, jni.JniType.booleanType, []).boolean;

  static final _id_getMaxAvailableHeight = jniAccessors.getMethodIDOf(
      _classRef, "getMaxAvailableHeight", "(Landroid/view/View;)I");

  /// from: public int getMaxAvailableHeight(android.view.View anchor)
  ///
  /// Returns the maximum height that is available for the popup to be
  /// completely shown. It is recommended that this height be the maximum for
  /// the popup's height, otherwise it is possible that the popup will be
  /// clipped.
  ///@param anchor The view on which the popup window must be anchored.
  /// This value must never be {@code null}.
  ///@return The maximum available height for the popup to be completely
  ///         shown.
  int getMaxAvailableHeight(view_.View anchor) =>
      jniAccessors.callMethodWithArgs(reference, _id_getMaxAvailableHeight,
          jni.JniType.intType, [anchor.reference]).integer;

  static final _id_getMaxAvailableHeight1 = jniAccessors.getMethodIDOf(
      _classRef, "getMaxAvailableHeight", "(Landroid/view/View;I)I");

  /// from: public int getMaxAvailableHeight(android.view.View anchor, int yOffset)
  ///
  /// Returns the maximum height that is available for the popup to be
  /// completely shown. It is recommended that this height be the maximum for
  /// the popup's height, otherwise it is possible that the popup will be
  /// clipped.
  ///@param anchor The view on which the popup window must be anchored.
  /// This value must never be {@code null}.
  ///@param yOffset y offset from the view's bottom edge
  ///@return The maximum available height for the popup to be completely
  ///         shown.
  int getMaxAvailableHeight1(view_.View anchor, int yOffset) =>
      jniAccessors.callMethodWithArgs(reference, _id_getMaxAvailableHeight1,
          jni.JniType.intType, [anchor.reference, yOffset]).integer;

  static final _id_getMaxAvailableHeight2 = jniAccessors.getMethodIDOf(
      _classRef, "getMaxAvailableHeight", "(Landroid/view/View;IZ)I");

  /// from: public int getMaxAvailableHeight(android.view.View anchor, int yOffset, boolean ignoreBottomDecorations)
  ///
  /// Returns the maximum height that is available for the popup to be
  /// completely shown, optionally ignoring any bottom decorations such as
  /// the input method. It is recommended that this height be the maximum for
  /// the popup's height, otherwise it is possible that the popup will be
  /// clipped.
  ///@param anchor The view on which the popup window must be anchored.
  /// This value must never be {@code null}.
  ///@param yOffset y offset from the view's bottom edge
  ///@param ignoreBottomDecorations if true, the height returned will be
  ///        all the way to the bottom of the display, ignoring any
  ///        bottom decorations
  ///@return The maximum available height for the popup to be completely
  ///         shown.
  int getMaxAvailableHeight2(
          view_.View anchor, int yOffset, bool ignoreBottomDecorations) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getMaxAvailableHeight2,
          jni.JniType.intType,
          [anchor.reference, yOffset, ignoreBottomDecorations]).integer;

  static final _id_dismiss =
      jniAccessors.getMethodIDOf(_classRef, "dismiss", "()V");

  /// from: public void dismiss()
  ///
  /// Disposes of the popup window. This method can be invoked only after
  /// \#showAsDropDown(android.view.View) has been executed. Failing
  /// that, calling this method will have no effect.
  ///@see \#showAsDropDown(android.view.View)
  void dismiss() => jniAccessors.callMethodWithArgs(
      reference, _id_dismiss, jni.JniType.voidType, []).check();

  static final _id_setOnDismissListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDismissListener",
      "(Landroid/widget/PopupWindow\$OnDismissListener;)V");

  /// from: public void setOnDismissListener(android.widget.PopupWindow.OnDismissListener onDismissListener)
  ///
  /// Sets the listener to be called when the window is dismissed.
  ///@param onDismissListener The listener.
  void setOnDismissListener(PopupWindow_OnDismissListener onDismissListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDismissListener,
          jni.JniType.voidType, [onDismissListener.reference]).check();

  static final _id_update =
      jniAccessors.getMethodIDOf(_classRef, "update", "()V");

  /// from: public void update()
  ///
  /// Updates the state of the popup window, if it is currently being displayed,
  /// from the currently set state.
  ///
  /// This includes:
  /// <ul>
  ///     <li>\#setClippingEnabled(boolean)</li>
  ///     <li>\#setFocusable(boolean)</li>
  ///     <li>\#setIgnoreCheekPress()</li>
  ///     <li>\#setInputMethodMode(int)</li>
  ///     <li>\#setTouchable(boolean)</li>
  ///     <li>\#setAnimationStyle(int)</li>
  /// </ul>
  void update() => jniAccessors.callMethodWithArgs(
      reference, _id_update, jni.JniType.voidType, []).check();

  static final _id_update1 =
      jniAccessors.getMethodIDOf(_classRef, "update", "(II)V");

  /// from: public void update(int width, int height)
  ///
  /// Updates the dimension of the popup window.
  ///
  /// Calling this function also updates the window with the current popup
  /// state as described for \#update().
  ///@param width the new width in pixels, must be >= 0 or -1 to ignore
  ///@param height the new height in pixels, must be >= 0 or -1 to ignore
  void update1(int width, int height) => jniAccessors.callMethodWithArgs(
      reference, _id_update1, jni.JniType.voidType, [width, height]).check();

  static final _id_update2 =
      jniAccessors.getMethodIDOf(_classRef, "update", "(IIII)V");

  /// from: public void update(int x, int y, int width, int height)
  ///
  /// Updates the position and the dimension of the popup window.
  ///
  /// Width and height can be set to -1 to update location only. Calling this
  /// function also updates the window with the current popup state as
  /// described for \#update().
  ///@param x the new x location
  ///@param y the new y location
  ///@param width the new width in pixels, must be >= 0 or -1 to ignore
  ///@param height the new height in pixels, must be >= 0 or -1 to ignore
  void update2(int x, int y, int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_update2,
          jni.JniType.voidType, [x, y, width, height]).check();

  static final _id_update3 =
      jniAccessors.getMethodIDOf(_classRef, "update", "(IIIIZ)V");

  /// from: public void update(int x, int y, int width, int height, boolean force)
  ///
  /// Updates the position and the dimension of the popup window.
  ///
  /// Width and height can be set to -1 to update location only. Calling this
  /// function also updates the window with the current popup state as
  /// described for \#update().
  ///@param x the new x location
  ///@param y the new y location
  ///@param width the new width in pixels, must be >= 0 or -1 to ignore
  ///@param height the new height in pixels, must be >= 0 or -1 to ignore
  ///@param force {@code true} to reposition the window even if the specified
  ///              position already seems to correspond to the LayoutParams,
  ///              {@code false} to only reposition if needed
  void update3(int x, int y, int width, int height, bool force) =>
      jniAccessors.callMethodWithArgs(reference, _id_update3,
          jni.JniType.voidType, [x, y, width, height, force]).check();

  static final _id_update4 = jniAccessors.getMethodIDOf(
      _classRef, "update", "(Landroid/view/View;II)V");

  /// from: public void update(android.view.View anchor, int width, int height)
  ///
  /// Updates the position and the dimension of the popup window.
  ///
  /// Calling this function also updates the window with the current popup
  /// state as described for \#update().
  ///@param anchor the popup's anchor view
  ///@param width the new width in pixels, must be >= 0 or -1 to ignore
  ///@param height the new height in pixels, must be >= 0 or -1 to ignore
  void update4(view_.View anchor, int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_update4,
          jni.JniType.voidType, [anchor.reference, width, height]).check();

  static final _id_update5 = jniAccessors.getMethodIDOf(
      _classRef, "update", "(Landroid/view/View;IIII)V");

  /// from: public void update(android.view.View anchor, int xoff, int yoff, int width, int height)
  ///
  /// Updates the position and the dimension of the popup window.
  ///
  /// Width and height can be set to -1 to update location only. Calling this
  /// function also updates the window with the current popup state as
  /// described for \#update().
  ///
  /// If the view later scrolls to move {@code anchor} to a different
  /// location, the popup will be moved correspondingly.
  ///@param anchor the popup's anchor view
  ///@param xoff x offset from the view's left edge
  ///@param yoff y offset from the view's bottom edge
  ///@param width the new width in pixels, must be >= 0 or -1 to ignore
  ///@param height the new height in pixels, must be >= 0 or -1 to ignore
  void update5(view_.View anchor, int xoff, int yoff, int width, int height) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_update5,
          jni.JniType.voidType,
          [anchor.reference, xoff, yoff, width, height]).check();
}

/// from: android.widget.PopupWindow$OnDismissListener
///
/// Listener that is called when this popup window is dismissed.
class PopupWindow_OnDismissListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/PopupWindow\$OnDismissListener");
  PopupWindow_OnDismissListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onDismiss =
      jniAccessors.getMethodIDOf(_classRef, "onDismiss", "()V");

  /// from: public abstract void onDismiss()
  ///
  /// Called when this popup window is dismissed.
  void onDismiss() => jniAccessors.callMethodWithArgs(
      reference, _id_onDismiss, jni.JniType.voidType, []).check();
}
