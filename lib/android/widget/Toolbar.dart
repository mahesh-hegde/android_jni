// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/ViewGroup.dart" as viewgroup_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../view/View.dart" as view_;

import "../view/Menu.dart" as menu_;

import "../os/Parcelable.dart" as parcelable_;

import "../view/MotionEvent.dart" as motionevent_;

import "../view/MenuItem.dart" as menuitem_;

import "../app/ActionBar.dart" as actionbar_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.Toolbar
///
/// A standard toolbar for use within application content.
///
/// A Toolbar is a generalization of android.app.ActionBar action bars for use
/// within application layouts. While an action bar is traditionally part of an
/// android.app.Activity Activity's opaque window decor controlled by the framework,
/// a Toolbar may be placed at any arbitrary level of nesting within a view hierarchy.
/// An application may choose to designate a Toolbar as the action bar for an Activity
/// using the android.app.Activity\#setActionBar(Toolbar) setActionBar() method.
///
///
/// Toolbar supports a more focused feature set than ActionBar. From start to end, a toolbar
/// may contain a combination of the following optional elements:
///
/// <ul>
///     <li>_A navigation button._ This may be an Up arrow, navigation menu toggle, close,
///     collapse, done or another glyph of the app's choosing. This button should always be used
///     to access other navigational destinations within the container of the Toolbar and
///     its signified content or otherwise leave the current context signified by the Toolbar.
///     The navigation button is vertically aligned within the Toolbar's
///     android.R.styleable\#View_minHeight minimum height, if set.</li>
///     <li>_A branded logo image._ This may extend to the height of the bar and can be
///     arbitrarily wide.</li>
///     <li>_A title and subtitle._ The title should be a signpost for the Toolbar's current
///     position in the navigation hierarchy and the content contained there. The subtitle,
///     if present should indicate any extended information about the current content.
///     If an app uses a logo image it should strongly consider omitting a title and subtitle.</li>
///     <li>_One or more custom views._ The application may add arbitrary child views
///     to the Toolbar. They will appear at this position within the layout. If a child view's
///     LayoutParams indicates a Gravity value of
///     Gravity\#CENTER_HORIZONTAL CENTER_HORIZONTAL the view will attempt to center
///     within the available space remaining in the Toolbar after all other elements have been
///     measured.</li>
///     <li>_An ActionMenuView action menu._ The menu of actions will pin to the
///     end of the Toolbar offering a few
///     <a href="http://developer.android.com/design/patterns/actionbar.html\#ActionButtons">
///     frequent, important or typical</a> actions along with an optional overflow menu for
///     additional actions. Action buttons are vertically aligned within the Toolbar's
///     android.R.styleable\#View_minHeight minimum height, if set.</li>
/// </ul>
///
///
///
/// In modern Android UIs developers should lean more on a visually distinct color scheme for
/// toolbars than on their application icon. The use of application icon plus title as a standard
/// layout is discouraged on API 21 devices and newer.
///
///@attr ref android.R.styleable\#Toolbar_buttonGravity
///@attr ref android.R.styleable\#Toolbar_collapseContentDescription
///@attr ref android.R.styleable\#Toolbar_collapseIcon
///@attr ref android.R.styleable\#Toolbar_contentInsetEnd
///@attr ref android.R.styleable\#Toolbar_contentInsetLeft
///@attr ref android.R.styleable\#Toolbar_contentInsetRight
///@attr ref android.R.styleable\#Toolbar_contentInsetStart
///@attr ref android.R.styleable\#Toolbar_contentInsetStartWithNavigation
///@attr ref android.R.styleable\#Toolbar_contentInsetEndWithActions
///@attr ref android.R.styleable\#Toolbar_gravity
///@attr ref android.R.styleable\#Toolbar_logo
///@attr ref android.R.styleable\#Toolbar_logoDescription
///@attr ref android.R.styleable\#Toolbar_maxButtonHeight
///@attr ref android.R.styleable\#Toolbar_navigationContentDescription
///@attr ref android.R.styleable\#Toolbar_navigationIcon
///@attr ref android.R.styleable\#Toolbar_popupTheme
///@attr ref android.R.styleable\#Toolbar_subtitle
///@attr ref android.R.styleable\#Toolbar_subtitleTextAppearance
///@attr ref android.R.styleable\#Toolbar_subtitleTextColor
///@attr ref android.R.styleable\#Toolbar_title
///@attr ref android.R.styleable\#Toolbar_titleMargin
///@attr ref android.R.styleable\#Toolbar_titleMarginBottom
///@attr ref android.R.styleable\#Toolbar_titleMarginEnd
///@attr ref android.R.styleable\#Toolbar_titleMarginStart
///@attr ref android.R.styleable\#Toolbar_titleMarginTop
///@attr ref android.R.styleable\#Toolbar_titleTextAppearance
///@attr ref android.R.styleable\#Toolbar_titleTextColor
class Toolbar extends viewgroup_.ViewGroup {
  static final _classRef = jniAccessors.getClassOf("android/widget/Toolbar");
  Toolbar.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_setPopupTheme =
      jniAccessors.getMethodIDOf(_classRef, "setPopupTheme", "(I)V");

  /// from: public void setPopupTheme(int resId)
  ///
  /// Specifies the theme to use when inflating popup menus. By default, uses
  /// the same theme as the toolbar itself.
  ///@param resId theme used to inflate popup menus
  ///@see \#getPopupTheme()
  void setPopupTheme(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setPopupTheme, jni.JniType.voidType, [resId]).check();

  static final _id_getPopupTheme =
      jniAccessors.getMethodIDOf(_classRef, "getPopupTheme", "()I");

  /// from: public int getPopupTheme()
  ///
  /// @return resource identifier of the theme used to inflate popup menus, or
  ///         0 if menus are inflated against the toolbar theme
  ///@see \#setPopupTheme(int)
  int getPopupTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_getPopupTheme, jni.JniType.intType, []).integer;

  static final _id_setTitleMargin =
      jniAccessors.getMethodIDOf(_classRef, "setTitleMargin", "(IIII)V");

  /// from: public void setTitleMargin(int start, int top, int end, int bottom)
  ///
  /// Sets the title margin.
  ///@param start the starting title margin in pixels
  ///@param top the top title margin in pixels
  ///@param end the ending title margin in pixels
  ///@param bottom the bottom title margin in pixels
  ///@see \#getTitleMarginStart()
  ///@see \#getTitleMarginTop()
  ///@see \#getTitleMarginEnd()
  ///@see \#getTitleMarginBottom()
  ///@attr ref android.R.styleable\#Toolbar_titleMargin
  void setTitleMargin(int start, int top, int end, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTitleMargin,
          jni.JniType.voidType, [start, top, end, bottom]).check();

  static final _id_getTitleMarginStart =
      jniAccessors.getMethodIDOf(_classRef, "getTitleMarginStart", "()I");

  /// from: public int getTitleMarginStart()
  ///
  /// @return the starting title margin in pixels
  ///@see \#setTitleMarginStart(int)
  ///@attr ref android.R.styleable\#Toolbar_titleMarginStart
  int getTitleMarginStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getTitleMarginStart, jni.JniType.intType, []).integer;

  static final _id_setTitleMarginStart =
      jniAccessors.getMethodIDOf(_classRef, "setTitleMarginStart", "(I)V");

  /// from: public void setTitleMarginStart(int margin)
  ///
  /// Sets the starting title margin in pixels.
  ///@param margin the starting title margin in pixels
  ///@see \#getTitleMarginStart()
  ///@attr ref android.R.styleable\#Toolbar_titleMarginStart
  void setTitleMarginStart(int margin) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTitleMarginStart,
      jni.JniType.voidType,
      [margin]).check();

  static final _id_getTitleMarginTop =
      jniAccessors.getMethodIDOf(_classRef, "getTitleMarginTop", "()I");

  /// from: public int getTitleMarginTop()
  ///
  /// @return the top title margin in pixels
  ///@see \#setTitleMarginTop(int)
  ///@attr ref android.R.styleable\#Toolbar_titleMarginTop
  int getTitleMarginTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getTitleMarginTop, jni.JniType.intType, []).integer;

  static final _id_setTitleMarginTop =
      jniAccessors.getMethodIDOf(_classRef, "setTitleMarginTop", "(I)V");

  /// from: public void setTitleMarginTop(int margin)
  ///
  /// Sets the top title margin in pixels.
  ///@param margin the top title margin in pixels
  ///@see \#getTitleMarginTop()
  ///@attr ref android.R.styleable\#Toolbar_titleMarginTop
  void setTitleMarginTop(int margin) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitleMarginTop, jni.JniType.voidType, [margin]).check();

  static final _id_getTitleMarginEnd =
      jniAccessors.getMethodIDOf(_classRef, "getTitleMarginEnd", "()I");

  /// from: public int getTitleMarginEnd()
  ///
  /// @return the ending title margin in pixels
  ///@see \#setTitleMarginEnd(int)
  ///@attr ref android.R.styleable\#Toolbar_titleMarginEnd
  int getTitleMarginEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getTitleMarginEnd, jni.JniType.intType, []).integer;

  static final _id_setTitleMarginEnd =
      jniAccessors.getMethodIDOf(_classRef, "setTitleMarginEnd", "(I)V");

  /// from: public void setTitleMarginEnd(int margin)
  ///
  /// Sets the ending title margin in pixels.
  ///@param margin the ending title margin in pixels
  ///@see \#getTitleMarginEnd()
  ///@attr ref android.R.styleable\#Toolbar_titleMarginEnd
  void setTitleMarginEnd(int margin) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitleMarginEnd, jni.JniType.voidType, [margin]).check();

  static final _id_getTitleMarginBottom =
      jniAccessors.getMethodIDOf(_classRef, "getTitleMarginBottom", "()I");

  /// from: public int getTitleMarginBottom()
  ///
  /// @return the bottom title margin in pixels
  ///@see \#setTitleMarginBottom(int)
  ///@attr ref android.R.styleable\#Toolbar_titleMarginBottom
  int getTitleMarginBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getTitleMarginBottom, jni.JniType.intType, []).integer;

  static final _id_setTitleMarginBottom =
      jniAccessors.getMethodIDOf(_classRef, "setTitleMarginBottom", "(I)V");

  /// from: public void setTitleMarginBottom(int margin)
  ///
  /// Sets the bottom title margin in pixels.
  ///@param margin the bottom title margin in pixels
  ///@see \#getTitleMarginBottom()
  ///@attr ref android.R.styleable\#Toolbar_titleMarginBottom
  void setTitleMarginBottom(int margin) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTitleMarginBottom,
      jni.JniType.voidType,
      [margin]).check();

  static final _id_onRtlPropertiesChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onRtlPropertiesChanged", "(I)V");

  /// from: public void onRtlPropertiesChanged(int layoutDirection)
  ///
  /// @param layoutDirection Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  void onRtlPropertiesChanged1(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRtlPropertiesChanged1,
          jni.JniType.voidType, [layoutDirection]).check();

  static final _id_setLogo =
      jniAccessors.getMethodIDOf(_classRef, "setLogo", "(I)V");

  /// from: public void setLogo(int resId)
  ///
  /// Set a logo drawable from a resource id.
  ///
  /// This drawable should generally take the place of title text. The logo cannot be
  /// clicked. Apps using a logo should also supply a description using
  /// \#setLogoDescription(int).
  ///
  ///@param resId ID of a drawable resource
  void setLogo(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setLogo, jni.JniType.voidType, [resId]).check();

  static final _id_isOverflowMenuShowing =
      jniAccessors.getMethodIDOf(_classRef, "isOverflowMenuShowing", "()Z");

  /// from: public boolean isOverflowMenuShowing()
  ///
  /// Check whether the overflow menu is currently showing. This may not reflect
  /// a pending show operation in progress.
  ///@return true if the overflow menu is currently showing
  bool isOverflowMenuShowing() => jniAccessors.callMethodWithArgs(reference,
      _id_isOverflowMenuShowing, jni.JniType.booleanType, []).boolean;

  static final _id_showOverflowMenu =
      jniAccessors.getMethodIDOf(_classRef, "showOverflowMenu", "()Z");

  /// from: public boolean showOverflowMenu()
  ///
  /// Show the overflow items from the associated menu.
  ///@return true if the menu was able to be shown, false otherwise
  bool showOverflowMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_showOverflowMenu, jni.JniType.booleanType, []).boolean;

  static final _id_hideOverflowMenu =
      jniAccessors.getMethodIDOf(_classRef, "hideOverflowMenu", "()Z");

  /// from: public boolean hideOverflowMenu()
  ///
  /// Hide the overflow items from the associated menu.
  ///@return true if the menu was able to be hidden, false otherwise
  bool hideOverflowMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_hideOverflowMenu, jni.JniType.booleanType, []).boolean;

  static final _id_dismissPopupMenus =
      jniAccessors.getMethodIDOf(_classRef, "dismissPopupMenus", "()V");

  /// from: public void dismissPopupMenus()
  ///
  /// Dismiss all currently showing popup menus, including overflow or submenus.
  void dismissPopupMenus() => jniAccessors.callMethodWithArgs(
      reference, _id_dismissPopupMenus, jni.JniType.voidType, []).check();

  static final _id_setLogo1 = jniAccessors.getMethodIDOf(
      _classRef, "setLogo", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setLogo(android.graphics.drawable.Drawable drawable)
  ///
  /// Set a logo drawable.
  ///
  /// This drawable should generally take the place of title text. The logo cannot be
  /// clicked. Apps using a logo should also supply a description using
  /// \#setLogoDescription(int).
  ///
  ///@param drawable Drawable to use as a logo
  void setLogo1(drawable_.Drawable drawable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLogo1,
      jni.JniType.voidType,
      [drawable.reference]).check();

  static final _id_getLogo = jniAccessors.getMethodIDOf(
      _classRef, "getLogo", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getLogo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current logo drawable.
  ///@return The current logo drawable
  ///@see \#setLogo(int)
  ///@see \#setLogo(android.graphics.drawable.Drawable)
  drawable_.Drawable getLogo() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLogo, jni.JniType.objectType, []).object);

  static final _id_setLogoDescription =
      jniAccessors.getMethodIDOf(_classRef, "setLogoDescription", "(I)V");

  /// from: public void setLogoDescription(int resId)
  ///
  /// Set a description of the toolbar's logo.
  ///
  /// This description will be used for accessibility or other similar descriptions
  /// of the UI.
  ///
  ///@param resId String resource id
  void setLogoDescription(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setLogoDescription, jni.JniType.voidType, [resId]).check();

  static final _id_setLogoDescription1 = jniAccessors.getMethodIDOf(
      _classRef, "setLogoDescription", "(Ljava/lang/CharSequence;)V");

  /// from: public void setLogoDescription(java.lang.CharSequence description)
  ///
  /// Set a description of the toolbar's logo.
  ///
  /// This description will be used for accessibility or other similar descriptions
  /// of the UI.
  ///
  ///@param description Description to set
  void setLogoDescription1(jni.JniObject description) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLogoDescription1,
          jni.JniType.voidType, [description.reference]).check();

  static final _id_getLogoDescription = jniAccessors.getMethodIDOf(
      _classRef, "getLogoDescription", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getLogoDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the description of the toolbar's logo.
  ///@return A description of the logo
  jni.JniObject getLogoDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getLogoDescription, jni.JniType.objectType, []).object);

  static final _id_hasExpandedActionView =
      jniAccessors.getMethodIDOf(_classRef, "hasExpandedActionView", "()Z");

  /// from: public boolean hasExpandedActionView()
  ///
  /// Check whether this Toolbar is currently hosting an expanded action view.
  ///
  /// An action view may be expanded either directly from the
  /// android.view.MenuItem MenuItem it belongs to or by user action. If the Toolbar
  /// has an expanded action view it can be collapsed using the \#collapseActionView()
  /// method.
  ///
  ///@return true if the Toolbar has an expanded action view
  bool hasExpandedActionView() => jniAccessors.callMethodWithArgs(reference,
      _id_hasExpandedActionView, jni.JniType.booleanType, []).boolean;

  static final _id_collapseActionView =
      jniAccessors.getMethodIDOf(_classRef, "collapseActionView", "()V");

  /// from: public void collapseActionView()
  ///
  /// Collapse a currently expanded action view. If this Toolbar does not have an
  /// expanded action view this method has no effect.
  ///
  /// An action view may be expanded either directly from the
  /// android.view.MenuItem MenuItem it belongs to or by user action.
  ///
  ///@see \#hasExpandedActionView()
  void collapseActionView() => jniAccessors.callMethodWithArgs(
      reference, _id_collapseActionView, jni.JniType.voidType, []).check();

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the title of this toolbar.
  ///@return The current title.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_setTitle =
      jniAccessors.getMethodIDOf(_classRef, "setTitle", "(I)V");

  /// from: public void setTitle(int resId)
  ///
  /// Set the title of this toolbar.
  ///
  /// A title should be used as the anchor for a section of content. It should
  /// describe or name the content being viewed.
  ///
  ///@param resId Resource ID of a string to set as the title
  void setTitle(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle, jni.JniType.voidType, [resId]).check();

  static final _id_setTitle1 = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public void setTitle(java.lang.CharSequence title)
  ///
  /// Set the title of this toolbar.
  ///
  /// A title should be used as the anchor for a section of content. It should
  /// describe or name the content being viewed.
  ///
  ///@param title Title to set
  void setTitle1(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTitle1,
      jni.JniType.voidType,
      [title.reference]).check();

  static final _id_getSubtitle = jniAccessors.getMethodIDOf(
      _classRef, "getSubtitle", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getSubtitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the subtitle of this toolbar.
  ///@return The current subtitle
  jni.JniObject getSubtitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSubtitle, jni.JniType.objectType, []).object);

  static final _id_setSubtitle =
      jniAccessors.getMethodIDOf(_classRef, "setSubtitle", "(I)V");

  /// from: public void setSubtitle(int resId)
  ///
  /// Set the subtitle of this toolbar.
  ///
  /// Subtitles should express extended information about the current content.
  ///
  ///@param resId String resource ID
  void setSubtitle(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setSubtitle, jni.JniType.voidType, [resId]).check();

  static final _id_setSubtitle1 = jniAccessors.getMethodIDOf(
      _classRef, "setSubtitle", "(Ljava/lang/CharSequence;)V");

  /// from: public void setSubtitle(java.lang.CharSequence subtitle)
  ///
  /// Set the subtitle of this toolbar.
  ///
  /// Subtitles should express extended information about the current content.
  ///
  ///@param subtitle Subtitle to set
  void setSubtitle1(jni.JniObject subtitle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSubtitle1,
      jni.JniType.voidType,
      [subtitle.reference]).check();

  static final _id_setTitleTextAppearance = jniAccessors.getMethodIDOf(
      _classRef, "setTitleTextAppearance", "(Landroid/content/Context;I)V");

  /// from: public void setTitleTextAppearance(android.content.Context context, int resId)
  ///
  /// Sets the text color, size, style, hint color, and highlight color
  /// from the specified TextAppearance resource.
  void setTitleTextAppearance(context_.Context context, int resId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTitleTextAppearance,
          jni.JniType.voidType, [context.reference, resId]).check();

  static final _id_setSubtitleTextAppearance = jniAccessors.getMethodIDOf(
      _classRef, "setSubtitleTextAppearance", "(Landroid/content/Context;I)V");

  /// from: public void setSubtitleTextAppearance(android.content.Context context, int resId)
  ///
  /// Sets the text color, size, style, hint color, and highlight color
  /// from the specified TextAppearance resource.
  void setSubtitleTextAppearance(context_.Context context, int resId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSubtitleTextAppearance,
          jni.JniType.voidType, [context.reference, resId]).check();

  static final _id_setTitleTextColor =
      jniAccessors.getMethodIDOf(_classRef, "setTitleTextColor", "(I)V");

  /// from: public void setTitleTextColor(int color)
  ///
  /// Sets the text color of the title, if present.
  ///@param color The new text color in 0xAARRGGBB format
  void setTitleTextColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitleTextColor, jni.JniType.voidType, [color]).check();

  static final _id_setSubtitleTextColor =
      jniAccessors.getMethodIDOf(_classRef, "setSubtitleTextColor", "(I)V");

  /// from: public void setSubtitleTextColor(int color)
  ///
  /// Sets the text color of the subtitle, if present.
  ///@param color The new text color in 0xAARRGGBB format
  void setSubtitleTextColor(int color) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSubtitleTextColor,
      jni.JniType.voidType,
      [color]).check();

  static final _id_getNavigationContentDescription = jniAccessors.getMethodIDOf(
      _classRef,
      "getNavigationContentDescription",
      "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getNavigationContentDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the currently configured content description for the navigation button view.
  /// This will be used to describe the navigation action to users through mechanisms such
  /// as screen readers or tooltips.
  ///@return The navigation button's content description
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Toolbar_navigationContentDescription
  jni.JniObject getNavigationContentDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNavigationContentDescription,
          jni.JniType.objectType, []).object);

  static final _id_setNavigationContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "setNavigationContentDescription", "(I)V");

  /// from: public void setNavigationContentDescription(int resId)
  ///
  /// Set a content description for the navigation button if one is present. The content
  /// description will be read via screen readers or other accessibility systems to explain
  /// the action of the navigation button.
  ///@param resId Resource ID of a content description string to set, or 0 to
  ///              clear the description
  ///@attr ref android.R.styleable\#Toolbar_navigationContentDescription
  void setNavigationContentDescription(int resId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setNavigationContentDescription,
          jni.JniType.voidType,
          [resId]).check();

  static final _id_setNavigationContentDescription1 =
      jniAccessors.getMethodIDOf(_classRef, "setNavigationContentDescription",
          "(Ljava/lang/CharSequence;)V");

  /// from: public void setNavigationContentDescription(java.lang.CharSequence description)
  ///
  /// Set a content description for the navigation button if one is present. The content
  /// description will be read via screen readers or other accessibility systems to explain
  /// the action of the navigation button.
  ///@param description Content description to set, or <code>null</code> to
  ///                    clear the content description
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Toolbar_navigationContentDescription
  void setNavigationContentDescription1(jni.JniObject description) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setNavigationContentDescription1,
          jni.JniType.voidType,
          [description.reference]).check();

  static final _id_setNavigationIcon =
      jniAccessors.getMethodIDOf(_classRef, "setNavigationIcon", "(I)V");

  /// from: public void setNavigationIcon(int resId)
  ///
  /// Set the icon to use for the toolbar's navigation button.
  ///
  /// The navigation button appears at the start of the toolbar if present. Setting an icon
  /// will make the navigation button visible.
  ///
  ///
  /// If you use a navigation icon you should also set a description for its action using
  /// \#setNavigationContentDescription(int). This is used for accessibility and
  /// tooltips.
  ///
  ///@param resId Resource ID of a drawable to set
  ///@attr ref android.R.styleable\#Toolbar_navigationIcon
  void setNavigationIcon(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setNavigationIcon, jni.JniType.voidType, [resId]).check();

  static final _id_setNavigationIcon1 = jniAccessors.getMethodIDOf(_classRef,
      "setNavigationIcon", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setNavigationIcon(android.graphics.drawable.Drawable icon)
  ///
  /// Set the icon to use for the toolbar's navigation button.
  ///
  /// The navigation button appears at the start of the toolbar if present. Setting an icon
  /// will make the navigation button visible.
  ///
  ///
  /// If you use a navigation icon you should also set a description for its action using
  /// \#setNavigationContentDescription(int). This is used for accessibility and
  /// tooltips.
  ///
  ///@param icon Drawable to set, may be null to clear the icon
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Toolbar_navigationIcon
  void setNavigationIcon1(drawable_.Drawable icon) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNavigationIcon1,
          jni.JniType.voidType, [icon.reference]).check();

  static final _id_getNavigationIcon = jniAccessors.getMethodIDOf(
      _classRef, "getNavigationIcon", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getNavigationIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current drawable used as the navigation icon.
  ///@return The navigation icon drawable
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Toolbar_navigationIcon
  drawable_.Drawable getNavigationIcon() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNavigationIcon, jni.JniType.objectType, []).object);

  static final _id_setNavigationOnClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setNavigationOnClickListener",
      "(Landroid/view/View\$OnClickListener;)V");

  /// from: public void setNavigationOnClickListener(android.view.View.OnClickListener listener)
  ///
  /// Set a listener to respond to navigation events.
  ///
  /// This listener will be called whenever the user clicks the navigation button
  /// at the start of the toolbar. An icon must be set for the navigation button to appear.
  ///
  ///@param listener Listener to set
  ///@see \#setNavigationIcon(android.graphics.drawable.Drawable)
  void setNavigationOnClickListener(view_.View_OnClickListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setNavigationOnClickListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_getMenu =
      jniAccessors.getMethodIDOf(_classRef, "getMenu", "()Landroid/view/Menu;");

  /// from: public android.view.Menu getMenu()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Menu shown in the toolbar.
  ///
  /// Applications that wish to populate the toolbar's menu can do so from here. To use
  /// an XML menu resource, use \#inflateMenu(int).
  ///
  ///@return The toolbar's Menu
  menu_.Menu getMenu() => menu_.Menu.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getMenu, jni.JniType.objectType, []).object);

  static final _id_setOverflowIcon = jniAccessors.getMethodIDOf(
      _classRef, "setOverflowIcon", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setOverflowIcon(android.graphics.drawable.Drawable icon)
  ///
  /// Set the icon to use for the overflow button.
  ///@param icon Drawable to set, may be null to clear the icon
  ///
  /// This value may be {@code null}.
  void setOverflowIcon(drawable_.Drawable icon) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOverflowIcon,
          jni.JniType.voidType, [icon.reference]).check();

  static final _id_getOverflowIcon = jniAccessors.getMethodIDOf(
      _classRef, "getOverflowIcon", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getOverflowIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current drawable used as the overflow icon.
  ///@return The overflow icon drawable
  ///
  /// This value may be {@code null}.
  drawable_.Drawable getOverflowIcon() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOverflowIcon, jni.JniType.objectType, []).object);

  static final _id_inflateMenu =
      jniAccessors.getMethodIDOf(_classRef, "inflateMenu", "(I)V");

  /// from: public void inflateMenu(int resId)
  ///
  /// Inflate a menu resource into this toolbar.
  ///
  /// Inflate an XML menu resource into this toolbar. Existing items in the menu will not
  /// be modified or removed.
  ///
  ///@param resId ID of a menu resource to inflate
  void inflateMenu(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_inflateMenu, jni.JniType.voidType, [resId]).check();

  static final _id_setOnMenuItemClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnMenuItemClickListener",
      "(Landroid/widget/Toolbar\$OnMenuItemClickListener;)V");

  /// from: public void setOnMenuItemClickListener(android.widget.Toolbar.OnMenuItemClickListener listener)
  ///
  /// Set a listener to respond to menu item click events.
  ///
  /// This listener will be invoked whenever a user selects a menu item from
  /// the action buttons presented at the end of the toolbar or the associated overflow.
  ///
  ///@param listener Listener to set
  void setOnMenuItemClickListener(Toolbar_OnMenuItemClickListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnMenuItemClickListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setContentInsetsRelative = jniAccessors.getMethodIDOf(
      _classRef, "setContentInsetsRelative", "(II)V");

  /// from: public void setContentInsetsRelative(int contentInsetStart, int contentInsetEnd)
  ///
  /// Sets the content insets for this toolbar relative to layout direction.
  ///
  /// The content inset affects the valid area for Toolbar content other than
  /// the navigation button and menu. Insets define the minimum margin for these components
  /// and can be used to effectively align Toolbar content along well-known gridlines.
  ///
  ///@param contentInsetStart Content inset for the toolbar starting edge
  ///@param contentInsetEnd Content inset for the toolbar ending edge
  ///@see \#setContentInsetsAbsolute(int, int)
  ///@see \#getContentInsetStart()
  ///@see \#getContentInsetEnd()
  ///@see \#getContentInsetLeft()
  ///@see \#getContentInsetRight()
  ///@attr ref android.R.styleable\#Toolbar_contentInsetEnd
  ///@attr ref android.R.styleable\#Toolbar_contentInsetStart
  void setContentInsetsRelative(int contentInsetStart, int contentInsetEnd) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentInsetsRelative,
          jni.JniType.voidType, [contentInsetStart, contentInsetEnd]).check();

  static final _id_getContentInsetStart =
      jniAccessors.getMethodIDOf(_classRef, "getContentInsetStart", "()I");

  /// from: public int getContentInsetStart()
  ///
  /// Gets the starting content inset for this toolbar.
  ///
  /// The content inset affects the valid area for Toolbar content other than
  /// the navigation button and menu. Insets define the minimum margin for these components
  /// and can be used to effectively align Toolbar content along well-known gridlines.
  ///
  ///@return The starting content inset for this toolbar
  ///@see \#setContentInsetsRelative(int, int)
  ///@see \#setContentInsetsAbsolute(int, int)
  ///@see \#getContentInsetEnd()
  ///@see \#getContentInsetLeft()
  ///@see \#getContentInsetRight()
  ///@attr ref android.R.styleable\#Toolbar_contentInsetStart
  int getContentInsetStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentInsetStart, jni.JniType.intType, []).integer;

  static final _id_getContentInsetEnd =
      jniAccessors.getMethodIDOf(_classRef, "getContentInsetEnd", "()I");

  /// from: public int getContentInsetEnd()
  ///
  /// Gets the ending content inset for this toolbar.
  ///
  /// The content inset affects the valid area for Toolbar content other than
  /// the navigation button and menu. Insets define the minimum margin for these components
  /// and can be used to effectively align Toolbar content along well-known gridlines.
  ///
  ///@return The ending content inset for this toolbar
  ///@see \#setContentInsetsRelative(int, int)
  ///@see \#setContentInsetsAbsolute(int, int)
  ///@see \#getContentInsetStart()
  ///@see \#getContentInsetLeft()
  ///@see \#getContentInsetRight()
  ///@attr ref android.R.styleable\#Toolbar_contentInsetEnd
  int getContentInsetEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentInsetEnd, jni.JniType.intType, []).integer;

  static final _id_setContentInsetsAbsolute = jniAccessors.getMethodIDOf(
      _classRef, "setContentInsetsAbsolute", "(II)V");

  /// from: public void setContentInsetsAbsolute(int contentInsetLeft, int contentInsetRight)
  ///
  /// Sets the content insets for this toolbar.
  ///
  /// The content inset affects the valid area for Toolbar content other than
  /// the navigation button and menu. Insets define the minimum margin for these components
  /// and can be used to effectively align Toolbar content along well-known gridlines.
  ///
  ///@param contentInsetLeft Content inset for the toolbar's left edge
  ///@param contentInsetRight Content inset for the toolbar's right edge
  ///@see \#setContentInsetsAbsolute(int, int)
  ///@see \#getContentInsetStart()
  ///@see \#getContentInsetEnd()
  ///@see \#getContentInsetLeft()
  ///@see \#getContentInsetRight()
  ///@attr ref android.R.styleable\#Toolbar_contentInsetLeft
  ///@attr ref android.R.styleable\#Toolbar_contentInsetRight
  void setContentInsetsAbsolute(int contentInsetLeft, int contentInsetRight) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentInsetsAbsolute,
          jni.JniType.voidType, [contentInsetLeft, contentInsetRight]).check();

  static final _id_getContentInsetLeft =
      jniAccessors.getMethodIDOf(_classRef, "getContentInsetLeft", "()I");

  /// from: public int getContentInsetLeft()
  ///
  /// Gets the left content inset for this toolbar.
  ///
  /// The content inset affects the valid area for Toolbar content other than
  /// the navigation button and menu. Insets define the minimum margin for these components
  /// and can be used to effectively align Toolbar content along well-known gridlines.
  ///
  ///@return The left content inset for this toolbar
  ///@see \#setContentInsetsRelative(int, int)
  ///@see \#setContentInsetsAbsolute(int, int)
  ///@see \#getContentInsetStart()
  ///@see \#getContentInsetEnd()
  ///@see \#getContentInsetRight()
  ///@attr ref android.R.styleable\#Toolbar_contentInsetLeft
  int getContentInsetLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentInsetLeft, jni.JniType.intType, []).integer;

  static final _id_getContentInsetRight =
      jniAccessors.getMethodIDOf(_classRef, "getContentInsetRight", "()I");

  /// from: public int getContentInsetRight()
  ///
  /// Gets the right content inset for this toolbar.
  ///
  /// The content inset affects the valid area for Toolbar content other than
  /// the navigation button and menu. Insets define the minimum margin for these components
  /// and can be used to effectively align Toolbar content along well-known gridlines.
  ///
  ///@return The right content inset for this toolbar
  ///@see \#setContentInsetsRelative(int, int)
  ///@see \#setContentInsetsAbsolute(int, int)
  ///@see \#getContentInsetStart()
  ///@see \#getContentInsetEnd()
  ///@see \#getContentInsetLeft()
  ///@attr ref android.R.styleable\#Toolbar_contentInsetRight
  int getContentInsetRight() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentInsetRight, jni.JniType.intType, []).integer;

  static final _id_getContentInsetStartWithNavigation = jniAccessors
      .getMethodIDOf(_classRef, "getContentInsetStartWithNavigation", "()I");

  /// from: public int getContentInsetStartWithNavigation()
  ///
  /// Gets the start content inset to use when a navigation button is present.
  ///
  /// Different content insets are often called for when additional buttons are present
  /// in the toolbar, as well as at different toolbar sizes. The larger value of
  /// \#getContentInsetStart() and this value will be used during layout.
  ///
  ///@return the start content inset used when a navigation icon has been set in pixels
  ///@see \#setContentInsetStartWithNavigation(int)
  ///@attr ref android.R.styleable\#Toolbar_contentInsetStartWithNavigation
  int getContentInsetStartWithNavigation() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getContentInsetStartWithNavigation,
      jni.JniType.intType, []).integer;

  static final _id_setContentInsetStartWithNavigation = jniAccessors
      .getMethodIDOf(_classRef, "setContentInsetStartWithNavigation", "(I)V");

  /// from: public void setContentInsetStartWithNavigation(int insetStartWithNavigation)
  ///
  /// Sets the start content inset to use when a navigation button is present.
  ///
  /// Different content insets are often called for when additional buttons are present
  /// in the toolbar, as well as at different toolbar sizes. The larger value of
  /// \#getContentInsetStart() and this value will be used during layout.
  ///
  ///@param insetStartWithNavigation the inset to use when a navigation icon has been set
  ///                                 in pixels
  ///@see \#getContentInsetStartWithNavigation()
  ///@attr ref android.R.styleable\#Toolbar_contentInsetStartWithNavigation
  void setContentInsetStartWithNavigation(int insetStartWithNavigation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentInsetStartWithNavigation,
          jni.JniType.voidType,
          [insetStartWithNavigation]).check();

  static final _id_getContentInsetEndWithActions = jniAccessors.getMethodIDOf(
      _classRef, "getContentInsetEndWithActions", "()I");

  /// from: public int getContentInsetEndWithActions()
  ///
  /// Gets the end content inset to use when action buttons are present.
  ///
  /// Different content insets are often called for when additional buttons are present
  /// in the toolbar, as well as at different toolbar sizes. The larger value of
  /// \#getContentInsetEnd() and this value will be used during layout.
  ///
  ///@return the end content inset used when a menu has been set in pixels
  ///@see \#setContentInsetEndWithActions(int)
  ///@attr ref android.R.styleable\#Toolbar_contentInsetEndWithActions
  int getContentInsetEndWithActions() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getContentInsetEndWithActions,
      jni.JniType.intType, []).integer;

  static final _id_setContentInsetEndWithActions = jniAccessors.getMethodIDOf(
      _classRef, "setContentInsetEndWithActions", "(I)V");

  /// from: public void setContentInsetEndWithActions(int insetEndWithActions)
  ///
  /// Sets the start content inset to use when action buttons are present.
  ///
  /// Different content insets are often called for when additional buttons are present
  /// in the toolbar, as well as at different toolbar sizes. The larger value of
  /// \#getContentInsetEnd() and this value will be used during layout.
  ///
  ///@param insetEndWithActions the inset to use when a menu has been set in pixels
  ///@see \#setContentInsetEndWithActions(int)
  ///@attr ref android.R.styleable\#Toolbar_contentInsetEndWithActions
  void setContentInsetEndWithActions(int insetEndWithActions) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentInsetEndWithActions,
          jni.JniType.voidType,
          [insetEndWithActions]).check();

  static final _id_getCurrentContentInsetStart = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentContentInsetStart", "()I");

  /// from: public int getCurrentContentInsetStart()
  ///
  /// Gets the content inset that will be used on the starting side of the bar in the current
  /// toolbar configuration.
  ///@return the current content inset start in pixels
  ///@see \#getContentInsetStartWithNavigation()
  int getCurrentContentInsetStart() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCurrentContentInsetStart,
      jni.JniType.intType, []).integer;

  static final _id_getCurrentContentInsetEnd =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentContentInsetEnd", "()I");

  /// from: public int getCurrentContentInsetEnd()
  ///
  /// Gets the content inset that will be used on the ending side of the bar in the current
  /// toolbar configuration.
  ///@return the current content inset end in pixels
  ///@see \#getContentInsetEndWithActions()
  int getCurrentContentInsetEnd() => jniAccessors.callMethodWithArgs(reference,
      _id_getCurrentContentInsetEnd, jni.JniType.intType, []).integer;

  static final _id_getCurrentContentInsetLeft = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentContentInsetLeft", "()I");

  /// from: public int getCurrentContentInsetLeft()
  ///
  /// Gets the content inset that will be used on the left side of the bar in the current
  /// toolbar configuration.
  ///@return the current content inset left in pixels
  ///@see \#getContentInsetStartWithNavigation()
  ///@see \#getContentInsetEndWithActions()
  int getCurrentContentInsetLeft() => jniAccessors.callMethodWithArgs(reference,
      _id_getCurrentContentInsetLeft, jni.JniType.intType, []).integer;

  static final _id_getCurrentContentInsetRight = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentContentInsetRight", "()I");

  /// from: public int getCurrentContentInsetRight()
  ///
  /// Gets the content inset that will be used on the right side of the bar in the current
  /// toolbar configuration.
  ///@return the current content inset right in pixels
  ///@see \#getContentInsetStartWithNavigation()
  ///@see \#getContentInsetEndWithActions()
  int getCurrentContentInsetRight() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCurrentContentInsetRight,
      jni.JniType.intType, []).integer;

  static final _id_onSaveInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: protected android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  parcelable_.Parcelable onSaveInstanceState1() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState1, jni.JniType.objectType, []).object);

  static final _id_onRestoreInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: protected void onRestoreInstanceState(android.os.Parcelable state)
  void onRestoreInstanceState1(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState1,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_onTouchEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent ev)
  bool onTouchEvent1(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent1,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int l, int t, int r, int b)
  void onLayout(bool changed, int l, int t, int r, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, l, t, r, b]).check();

  static final _id_generateLayoutParams2 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/util/AttributeSet;)Landroid/widget/Toolbar\$LayoutParams;");

  /// from: public android.widget.Toolbar.LayoutParams generateLayoutParams(android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams generateLayoutParams2(
          attributeset_.AttributeSet attrs) =>
      Toolbar_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams2,
          jni.JniType.objectType,
          [attrs.reference]).object);

  static final _id_generateLayoutParams3 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/view/ViewGroup\$LayoutParams;)Landroid/widget/Toolbar\$LayoutParams;");

  /// from: protected android.widget.Toolbar.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams p)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams generateLayoutParams3(
          viewgroup_.ViewGroup_LayoutParams p) =>
      Toolbar_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams3,
          jni.JniType.objectType,
          [p.reference]).object);

  static final _id_generateDefaultLayoutParams1 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateDefaultLayoutParams",
      "()Landroid/widget/Toolbar\$LayoutParams;");

  /// from: protected android.widget.Toolbar.LayoutParams generateDefaultLayoutParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams generateDefaultLayoutParams1() =>
      Toolbar_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_generateDefaultLayoutParams1, jni.JniType.objectType, []).object);

  static final _id_checkLayoutParams = jniAccessors.getMethodIDOf(_classRef,
      "checkLayoutParams", "(Landroid/view/ViewGroup\$LayoutParams;)Z");

  /// from: protected boolean checkLayoutParams(android.view.ViewGroup.LayoutParams p)
  bool checkLayoutParams(viewgroup_.ViewGroup_LayoutParams p) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkLayoutParams,
          jni.JniType.booleanType, [p.reference]).boolean;
}

/// from: android.widget.Toolbar$OnMenuItemClickListener
///
/// Interface responsible for receiving menu item click events if the items themselves
/// do not have individual item click listeners.
class Toolbar_OnMenuItemClickListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/Toolbar\$OnMenuItemClickListener");
  Toolbar_OnMenuItemClickListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onMenuItemClick = jniAccessors.getMethodIDOf(
      _classRef, "onMenuItemClick", "(Landroid/view/MenuItem;)Z");

  /// from: public abstract boolean onMenuItemClick(android.view.MenuItem item)
  ///
  /// This method will be invoked when a menu item is clicked if the item itself did
  /// not already handle the event.
  ///@param item MenuItem that was clicked
  ///@return <code>true</code> if the event was handled, <code>false</code> otherwise.
  bool onMenuItemClick(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuItemClick,
          jni.JniType.booleanType, [item.reference]).boolean;
}

/// from: android.widget.Toolbar$LayoutParams
///
/// Layout information for child views of Toolbars.
///
/// Toolbar.LayoutParams extends ActionBar.LayoutParams for compatibility with existing
/// ActionBar API. See android.app.Activity\#setActionBar(Toolbar) Activity.setActionBar
/// for more info on how to use a Toolbar as your Activity's ActionBar.
///
///@attr ref android.R.styleable\#Toolbar_LayoutParams_layout_gravity
class Toolbar_LayoutParams extends actionbar_.ActionBar_LayoutParams {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/Toolbar\$LayoutParams");
  Toolbar_LayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param c This value must never be {@code null}.
  Toolbar_LayoutParams(context_.Context c, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [c.reference, attrs.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams.ctor1(int width, int height)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [width, height]).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(III)V");

  /// from: public void <init>(int width, int height, int gravity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams.ctor4(int width, int height, int gravity)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [width, height, gravity]).object);

  static final _id_ctor5 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int gravity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams.ctor5(int gravity)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor5, [gravity]).object);

  static final _id_ctor7 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/widget/Toolbar\$LayoutParams;)V");

  /// from: public void <init>(android.widget.Toolbar.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams.ctor7(Toolbar_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor7, [source.reference]).object);

  static final _id_ctor6 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/ActionBar\$LayoutParams;)V");

  /// from: public void <init>(android.app.ActionBar.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams.ctor6(actionbar_.ActionBar_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor6, [source.reference]).object);

  static final _id_ctor8 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$MarginLayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.MarginLayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams.ctor8(viewgroup_.ViewGroup_MarginLayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor8, [source.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Toolbar_LayoutParams.ctor2(viewgroup_.ViewGroup_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [source.reference]).object);
}
