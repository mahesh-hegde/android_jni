// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/ViewGroup.dart" as viewgroup_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.RelativeLayout
///
/// A Layout where the positions of the children can be described in relation to each other or to the
/// parent.
///
///
/// Note that you cannot have a circular dependency between the size of the RelativeLayout and the
/// position of its children. For example, you cannot have a RelativeLayout whose height is set to
/// android.view.ViewGroup.LayoutParams\#WRAP_CONTENT WRAP_CONTENT and a child set to
/// \#ALIGN_PARENT_BOTTOM.
///
///
///
/// <strong>Note:</strong> In platform version 17 and lower, RelativeLayout was affected by
/// a measurement bug that could cause child views to be measured with incorrect
/// android.view.View.MeasureSpec MeasureSpec values. (See
/// android.view.View.MeasureSpec\#makeMeasureSpec(int, int) MeasureSpec.makeMeasureSpec
/// for more details.) This was triggered when a RelativeLayout container was placed in
/// a scrolling container, such as a ScrollView or HorizontalScrollView. If a custom view
/// not equipped to properly measure with the MeasureSpec mode
/// android.view.View.MeasureSpec\#UNSPECIFIED UNSPECIFIED was placed in a RelativeLayout,
/// this would silently work anyway as RelativeLayout would pass a very large
/// android.view.View.MeasureSpec\#AT_MOST AT_MOST MeasureSpec instead.
///
///
/// This behavior has been preserved for apps that set <code>android:targetSdkVersion="17"</code>
/// or older in their manifest's <code>uses-sdk</code> tag for compatibility. Apps targeting SDK
/// version 18 or newer will receive the correct behavior
///
///
/// See the <a href="{@docRoot}guide/topics/ui/layout/relative.html">Relative
/// Layout</a> guide.
///
///
///
/// Also see android.widget.RelativeLayout.LayoutParams RelativeLayout.LayoutParams for
/// layout attributes
///
///
///@attr ref android.R.styleable\#RelativeLayout_gravity
///@attr ref android.R.styleable\#RelativeLayout_ignoreGravity
class RelativeLayout extends viewgroup_.ViewGroup {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/RelativeLayout");
  RelativeLayout.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ABOVE
  ///
  /// Rule that aligns a child's bottom edge with another child's top edge.
  static const ABOVE = 2;

  /// from: static public final int ALIGN_BASELINE
  ///
  /// Rule that aligns a child's baseline with another child's baseline.
  static const ALIGN_BASELINE = 4;

  /// from: static public final int ALIGN_BOTTOM
  ///
  /// Rule that aligns a child's bottom edge with another child's bottom edge.
  static const ALIGN_BOTTOM = 8;

  /// from: static public final int ALIGN_END
  ///
  /// Rule that aligns a child's end edge with another child's end edge.
  static const ALIGN_END = 19;

  /// from: static public final int ALIGN_LEFT
  ///
  /// Rule that aligns a child's left edge with another child's left edge.
  static const ALIGN_LEFT = 5;

  /// from: static public final int ALIGN_PARENT_BOTTOM
  ///
  /// Rule that aligns the child's bottom edge with its RelativeLayout
  /// parent's bottom edge.
  static const ALIGN_PARENT_BOTTOM = 12;

  /// from: static public final int ALIGN_PARENT_END
  ///
  /// Rule that aligns the child's end edge with its RelativeLayout
  /// parent's end edge.
  static const ALIGN_PARENT_END = 21;

  /// from: static public final int ALIGN_PARENT_LEFT
  ///
  /// Rule that aligns the child's left edge with its RelativeLayout
  /// parent's left edge.
  static const ALIGN_PARENT_LEFT = 9;

  /// from: static public final int ALIGN_PARENT_RIGHT
  ///
  /// Rule that aligns the child's right edge with its RelativeLayout
  /// parent's right edge.
  static const ALIGN_PARENT_RIGHT = 11;

  /// from: static public final int ALIGN_PARENT_START
  ///
  /// Rule that aligns the child's start edge with its RelativeLayout
  /// parent's start edge.
  static const ALIGN_PARENT_START = 20;

  /// from: static public final int ALIGN_PARENT_TOP
  ///
  /// Rule that aligns the child's top edge with its RelativeLayout
  /// parent's top edge.
  static const ALIGN_PARENT_TOP = 10;

  /// from: static public final int ALIGN_RIGHT
  ///
  /// Rule that aligns a child's right edge with another child's right edge.
  static const ALIGN_RIGHT = 7;

  /// from: static public final int ALIGN_START
  ///
  /// Rule that aligns a child's start edge with another child's start edge.
  static const ALIGN_START = 18;

  /// from: static public final int ALIGN_TOP
  ///
  /// Rule that aligns a child's top edge with another child's top edge.
  static const ALIGN_TOP = 6;

  /// from: static public final int BELOW
  ///
  /// Rule that aligns a child's top edge with another child's bottom edge.
  static const BELOW = 3;

  /// from: static public final int CENTER_HORIZONTAL
  ///
  /// Rule that centers the child horizontally with respect to the
  /// bounds of its RelativeLayout parent.
  static const CENTER_HORIZONTAL = 14;

  /// from: static public final int CENTER_IN_PARENT
  ///
  /// Rule that centers the child with respect to the bounds of its
  /// RelativeLayout parent.
  static const CENTER_IN_PARENT = 13;

  /// from: static public final int CENTER_VERTICAL
  ///
  /// Rule that centers the child vertically with respect to the
  /// bounds of its RelativeLayout parent.
  static const CENTER_VERTICAL = 15;

  /// from: static public final int END_OF
  ///
  /// Rule that aligns a child's start edge with another child's end edge.
  static const END_OF = 17;

  /// from: static public final int LEFT_OF
  ///
  /// Rule that aligns a child's right edge with another child's left edge.
  static const LEFT_OF = 0;

  /// from: static public final int RIGHT_OF
  ///
  /// Rule that aligns a child's left edge with another child's right edge.
  static const RIGHT_OF = 1;

  /// from: static public final int START_OF
  ///
  /// Rule that aligns a child's end edge with another child's start edge.
  static const START_OF = 16;

  /// from: static public final int TRUE
  static const TRUE = -1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RelativeLayout(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RelativeLayout.ctor1(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RelativeLayout.ctor2(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RelativeLayout.ctor3(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_shouldDelayChildPressedState = jniAccessors.getMethodIDOf(
      _classRef, "shouldDelayChildPressedState", "()Z");

  /// from: public boolean shouldDelayChildPressedState()
  bool shouldDelayChildPressedState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_shouldDelayChildPressedState,
      jni.JniType.booleanType, []).boolean;

  static final _id_setIgnoreGravity =
      jniAccessors.getMethodIDOf(_classRef, "setIgnoreGravity", "(I)V");

  /// from: public void setIgnoreGravity(int viewId)
  ///
  /// Defines which View is ignored when the gravity is applied. This setting has no
  /// effect if the gravity is <code>Gravity.START | Gravity.TOP</code>.
  ///@param viewId The id of the View to be ignored by gravity, or 0 if no View
  ///        should be ignored.
  ///@see \#setGravity(int)
  ///@attr ref android.R.styleable\#RelativeLayout_ignoreGravity
  void setIgnoreGravity(int viewId) => jniAccessors.callMethodWithArgs(
      reference, _id_setIgnoreGravity, jni.JniType.voidType, [viewId]).check();

  static final _id_getGravity =
      jniAccessors.getMethodIDOf(_classRef, "getGravity", "()I");

  /// from: public int getGravity()
  ///
  /// Describes how the child views are positioned.
  ///@return the gravity.
  ///@see \#setGravity(int)
  ///@see android.view.Gravity
  ///@attr ref android.R.styleable\#RelativeLayout_gravity
  int getGravity() => jniAccessors.callMethodWithArgs(
      reference, _id_getGravity, jni.JniType.intType, []).integer;

  static final _id_setGravity =
      jniAccessors.getMethodIDOf(_classRef, "setGravity", "(I)V");

  /// from: public void setGravity(int gravity)
  ///
  /// Describes how the child views are positioned. Defaults to
  /// <code>Gravity.START | Gravity.TOP</code>.
  ///
  /// Note that since RelativeLayout considers the positioning of each child
  /// relative to one another to be significant, setting gravity will affect
  /// the positioning of all children as a single unit within the parent.
  /// This happens after children have been relatively positioned.
  ///
  ///@param gravity See android.view.Gravity
  ///@see \#setHorizontalGravity(int)
  ///@see \#setVerticalGravity(int)
  ///@attr ref android.R.styleable\#RelativeLayout_gravity
  void setGravity(int gravity) => jniAccessors.callMethodWithArgs(
      reference, _id_setGravity, jni.JniType.voidType, [gravity]).check();

  static final _id_setHorizontalGravity =
      jniAccessors.getMethodIDOf(_classRef, "setHorizontalGravity", "(I)V");

  /// from: public void setHorizontalGravity(int horizontalGravity)
  void setHorizontalGravity(int horizontalGravity) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHorizontalGravity,
          jni.JniType.voidType, [horizontalGravity]).check();

  static final _id_setVerticalGravity =
      jniAccessors.getMethodIDOf(_classRef, "setVerticalGravity", "(I)V");

  /// from: public void setVerticalGravity(int verticalGravity)
  void setVerticalGravity(int verticalGravity) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVerticalGravity,
          jni.JniType.voidType, [verticalGravity]).check();

  static final _id_getBaseline1 =
      jniAccessors.getMethodIDOf(_classRef, "getBaseline", "()I");

  /// from: public int getBaseline()
  int getBaseline1() => jniAccessors.callMethodWithArgs(
      reference, _id_getBaseline1, jni.JniType.intType, []).integer;

  static final _id_requestLayout1 =
      jniAccessors.getMethodIDOf(_classRef, "requestLayout", "()V");

  /// from: public void requestLayout()
  void requestLayout1() => jniAccessors.callMethodWithArgs(
      reference, _id_requestLayout1, jni.JniType.voidType, []).check();

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int l, int t, int r, int b)
  void onLayout(bool changed, int l, int t, int r, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, l, t, r, b]).check();

  static final _id_generateLayoutParams2 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/util/AttributeSet;)Landroid/widget/RelativeLayout\$LayoutParams;");

  /// from: public android.widget.RelativeLayout.LayoutParams generateLayoutParams(android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RelativeLayout_LayoutParams generateLayoutParams2(
          attributeset_.AttributeSet attrs) =>
      RelativeLayout_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams2,
          jni.JniType.objectType,
          [attrs.reference]).object);

  static final _id_generateDefaultLayoutParams = jniAccessors.getMethodIDOf(
      _classRef,
      "generateDefaultLayoutParams",
      "()Landroid/view/ViewGroup\$LayoutParams;");

  /// from: protected android.view.ViewGroup.LayoutParams generateDefaultLayoutParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a set of layout parameters with a width of
  /// android.view.ViewGroup.LayoutParams\#WRAP_CONTENT,
  /// a height of android.view.ViewGroup.LayoutParams\#WRAP_CONTENT and no spanning.
  viewgroup_.ViewGroup_LayoutParams generateDefaultLayoutParams() =>
      viewgroup_.ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateDefaultLayoutParams,
          jni.JniType.objectType, []).object);

  static final _id_checkLayoutParams = jniAccessors.getMethodIDOf(_classRef,
      "checkLayoutParams", "(Landroid/view/ViewGroup\$LayoutParams;)Z");

  /// from: protected boolean checkLayoutParams(android.view.ViewGroup.LayoutParams p)
  bool checkLayoutParams(viewgroup_.ViewGroup_LayoutParams p) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkLayoutParams,
          jni.JniType.booleanType, [p.reference]).boolean;

  static final _id_generateLayoutParams1 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/view/ViewGroup\$LayoutParams;)Landroid/view/ViewGroup\$LayoutParams;");

  /// from: protected android.view.ViewGroup.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams lp)
  /// The returned object must be deleted after use, by calling the `delete` method.
  viewgroup_.ViewGroup_LayoutParams generateLayoutParams1(
          viewgroup_.ViewGroup_LayoutParams lp) =>
      viewgroup_.ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams1,
          jni.JniType.objectType,
          [lp.reference]).object);

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);
}

/// from: android.widget.RelativeLayout$LayoutParams
///
/// Specifies how a view is positioned within a RelativeLayout.
/// The relative layout containing the view uses the value of these layout parameters to
/// determine where to position the view on the screen.  If the view is not contained
/// within a relative layout, these attributes are ignored.
///
/// See the <a href="/guide/topics/ui/layout/relative.html">
/// Relative Layout</a> guide for example code demonstrating how to use relative layout\u2019s
/// layout parameters in a layout XML.
///
/// To learn more about layout parameters and how they differ from typical view attributes,
/// see the <a href="/guide/topics/ui/declaring-layout.html\#attributes">
///     Layouts guide</a>.
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignWithParentIfMissing
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_toLeftOf
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_toRightOf
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_above
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_below
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignBaseline
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignLeft
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignTop
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignRight
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignBottom
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignParentLeft
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignParentTop
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignParentRight
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignParentBottom
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_centerInParent
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_centerHorizontal
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_centerVertical
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_toStartOf
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_toEndOf
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignStart
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignEnd
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignParentStart
///@attr ref android.R.styleable\#RelativeLayout_Layout_layout_alignParentEnd
class RelativeLayout_LayoutParams
    extends viewgroup_.ViewGroup_MarginLayoutParams {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/RelativeLayout\$LayoutParams");
  RelativeLayout_LayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_alignWithParent =
      jniAccessors.getFieldIDOf(_classRef, "alignWithParent", "Z");

  /// from: public boolean alignWithParent
  ///
  /// When true, uses the parent as the anchor if the anchor doesn't exist or if
  /// the anchor's visibility is GONE.
  bool get alignWithParent => jniAccessors
      .getField(reference, _id_alignWithParent, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean alignWithParent
  ///
  /// When true, uses the parent as the anchor if the anchor doesn't exist or if
  /// the anchor's visibility is GONE.
  set alignWithParent(bool value) =>
      jniEnv.SetBooleanField(reference, _id_alignWithParent, value ? 1 : 0);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RelativeLayout_LayoutParams(
      context_.Context c, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [c.reference, attrs.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int w, int h)
  /// The returned object must be deleted after use, by calling the `delete` method.
  RelativeLayout_LayoutParams.ctor1(int w, int h)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [w, h]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  RelativeLayout_LayoutParams.ctor2(viewgroup_.ViewGroup_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [source.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$MarginLayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.MarginLayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  RelativeLayout_LayoutParams.ctor3(
      viewgroup_.ViewGroup_MarginLayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [source.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/widget/RelativeLayout\$LayoutParams;)V");

  /// from: public void <init>(android.widget.RelativeLayout.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy constructor. Clones the width, height, margin values, and rules
  /// of the source.
  ///@param source The layout params to copy from.
  RelativeLayout_LayoutParams.ctor4(RelativeLayout_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [source.reference]).object);

  static final _id_debug = jniAccessors.getMethodIDOf(
      _classRef, "debug", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String debug(java.lang.String output)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString debug(jni.JniString output) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_debug, jni.JniType.objectType, [output.reference]).object);

  static final _id_addRule =
      jniAccessors.getMethodIDOf(_classRef, "addRule", "(I)V");

  /// from: public void addRule(int verb)
  ///
  /// Adds a layout rule to be interpreted by the RelativeLayout.
  ///
  /// This method should only be used for verbs that don't refer to a
  /// sibling (ex. \#ALIGN_RIGHT) or take a boolean
  /// value (\#TRUE for true or 0 for false). To
  /// specify a verb that takes a subject, use \#addRule(int, int).
  ///
  /// If the rule is relative to the layout direction (ex.
  /// \#ALIGN_PARENT_START), then the layout direction must be
  /// resolved using \#resolveLayoutDirection(int) before calling
  /// \#getRule(int) an absolute rule (ex.
  /// \#ALIGN_PARENT_LEFT.
  ///@param verb a layout verb, such as \#ALIGN_PARENT_LEFT
  ///@see \#addRule(int, int)
  ///@see \#removeRule(int)
  ///@see \#getRule(int)
  void addRule(int verb) => jniAccessors.callMethodWithArgs(
      reference, _id_addRule, jni.JniType.voidType, [verb]).check();

  static final _id_addRule1 =
      jniAccessors.getMethodIDOf(_classRef, "addRule", "(II)V");

  /// from: public void addRule(int verb, int subject)
  ///
  /// Adds a layout rule to be interpreted by the RelativeLayout.
  ///
  /// Use this for verbs that refer to a sibling (ex.
  /// \#ALIGN_RIGHT) or take a boolean value (ex.
  /// \#CENTER_IN_PARENT).
  ///
  /// If the rule is relative to the layout direction (ex.
  /// \#START_OF), then the layout direction must be resolved using
  /// \#resolveLayoutDirection(int) before calling
  /// \#getRule(int) with an absolute rule (ex. \#LEFT_OF.
  ///@param verb a layout verb, such as \#ALIGN_RIGHT
  ///@param subject the ID of another view to use as an anchor, or a
  ///                boolean value (represented as \#TRUE for true
  ///                or 0 for false)
  ///@see \#addRule(int)
  ///@see \#removeRule(int)
  ///@see \#getRule(int)
  void addRule1(int verb, int subject) => jniAccessors.callMethodWithArgs(
      reference, _id_addRule1, jni.JniType.voidType, [verb, subject]).check();

  static final _id_removeRule =
      jniAccessors.getMethodIDOf(_classRef, "removeRule", "(I)V");

  /// from: public void removeRule(int verb)
  ///
  /// Removes a layout rule to be interpreted by the RelativeLayout.
  ///
  /// If the rule is relative to the layout direction (ex.
  /// \#START_OF, \#ALIGN_PARENT_START, etc.) then the
  /// layout direction must be resolved using
  /// \#resolveLayoutDirection(int) before before calling
  /// \#getRule(int) with an absolute rule (ex. \#LEFT_OF.
  ///@param verb One of the verbs defined by
  ///        android.widget.RelativeLayout RelativeLayout, such as
  ///         ALIGN_WITH_PARENT_LEFT.
  ///@see \#addRule(int)
  ///@see \#addRule(int, int)
  ///@see \#getRule(int)
  void removeRule(int verb) => jniAccessors.callMethodWithArgs(
      reference, _id_removeRule, jni.JniType.voidType, [verb]).check();

  static final _id_getRule =
      jniAccessors.getMethodIDOf(_classRef, "getRule", "(I)I");

  /// from: public int getRule(int verb)
  ///
  /// Returns the layout rule associated with a specific verb.
  ///@param verb one of the verbs defined by RelativeLayout, such
  ///             as ALIGN_WITH_PARENT_LEFT
  ///@return the id of another view to use as an anchor, a boolean value
  ///         (represented as RelativeLayout\#TRUE for true
  ///         or 0 for false), or -1 for verbs that don't refer to another
  ///         sibling (for example, ALIGN_WITH_PARENT_BOTTOM)
  ///@see \#addRule(int)
  ///@see \#addRule(int, int)
  int getRule(int verb) => jniAccessors.callMethodWithArgs(
      reference, _id_getRule, jni.JniType.intType, [verb]).integer;

  static final _id_getRules =
      jniAccessors.getMethodIDOf(_classRef, "getRules", "()[I");

  /// from: public int[] getRules()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves a complete list of all supported rules, where the index is the rule
  /// verb, and the element value is the value specified, or "false" if it was never
  /// set. There will be no resolution of relative rules done.
  ///@return the supported rules
  ///@see \#addRule(int, int)
  jni.JniObject getRules() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRules, jni.JniType.objectType, []).object);

  static final _id_resolveLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "resolveLayoutDirection", "(I)V");

  /// from: public void resolveLayoutDirection(int layoutDirection)
  ///
  /// This will be called by android.view.View\#requestLayout() to
  /// resolve layout parameters that are relative to the layout direction.
  ///
  /// After this method is called, any rules using layout-relative verbs
  /// (ex. \#START_OF) previously added via \#addRule(int)
  /// may only be accessed via their resolved absolute verbs (ex.
  /// \#LEFT_OF).
  void resolveLayoutDirection(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_resolveLayoutDirection,
          jni.JniType.voidType, [layoutDirection]).check();
}
