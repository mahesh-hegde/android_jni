// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "TextView.dart" as textview_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.TextClock
///
/// <code>TextClock</code> can display the current date and/or time as
/// a formatted string.
///
///
/// This view honors the 24-hour format system setting. As such, it is
/// possible and recommended to provide two different formatting patterns:
/// one to display the date/time in 24-hour mode and one to display the
/// date/time in 12-hour mode. Most callers will want to use the defaults,
/// though, which will be appropriate for the user's locale.
///
///
/// It is possible to determine whether the system is currently in
/// 24-hour mode by calling \#is24HourModeEnabled().
///
///
/// The rules used by this widget to decide how to format the date and
/// time are the following:
///
/// <ul>
///     <li>In 24-hour mode:
///         <ul>
///             <li>Use the value returned by \#getFormat24Hour() when non-null</li>
///             <li>Otherwise, use the value returned by \#getFormat12Hour() when non-null</li>
///             <li>Otherwise, use a default value appropriate for the user's locale, such as {@code h:mm a}</li>
///         </ul>
///     </li>
///     <li>In 12-hour mode:
///         <ul>
///             <li>Use the value returned by \#getFormat12Hour() when non-null</li>
///             <li>Otherwise, use the value returned by \#getFormat24Hour() when non-null</li>
///             <li>Otherwise, use a default value appropriate for the user's locale, such as {@code HH:mm}</li>
///         </ul>
///     </li>
/// </ul>
///
/// The CharSequence instances used as formatting patterns when calling either
/// \#setFormat24Hour(CharSequence) or \#setFormat12Hour(CharSequence) can
/// contain styling information. To do so, use a android.text.Spanned object.
/// Note that if you customize these strings, it is your responsibility to supply strings
/// appropriate for formatting dates and/or times in the user's locale.
///
///@attr ref android.R.styleable\#TextClock_format12Hour
///@attr ref android.R.styleable\#TextClock_format24Hour
///@attr ref android.R.styleable\#TextClock_timeZone
class TextClock extends textview_.TextView {
  static final _classRef = jniAccessors.getClassOf("android/widget/TextClock");
  TextClock.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_DEFAULT_FORMAT_12_HOUR = jniAccessors.getStaticFieldIDOf(
      _classRef, "DEFAULT_FORMAT_12_HOUR", "Ljava/lang/CharSequence;");

  /// from: static public final java.lang.CharSequence DEFAULT_FORMAT_12_HOUR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default formatting pattern in 12-hour mode. This pattern is used
  /// if \#setFormat12Hour(CharSequence) is called with a null pattern
  /// or if no pattern was specified when creating an instance of this class.
  ///
  /// This default pattern shows only the time, hours and minutes, and an am/pm
  /// indicator.
  ///@see \#setFormat12Hour(CharSequence)
  ///@see \#getFormat12Hour()
  ///@deprecated Let the system use locale-appropriate defaults instead.
  static jni.JniObject get DEFAULT_FORMAT_12_HOUR =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_DEFAULT_FORMAT_12_HOUR, jni.JniType.objectType)
          .object);

  static final _id_DEFAULT_FORMAT_24_HOUR = jniAccessors.getStaticFieldIDOf(
      _classRef, "DEFAULT_FORMAT_24_HOUR", "Ljava/lang/CharSequence;");

  /// from: static public final java.lang.CharSequence DEFAULT_FORMAT_24_HOUR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default formatting pattern in 24-hour mode. This pattern is used
  /// if \#setFormat24Hour(CharSequence) is called with a null pattern
  /// or if no pattern was specified when creating an instance of this class.
  ///
  /// This default pattern shows only the time, hours and minutes.
  ///@see \#setFormat24Hour(CharSequence)
  ///@see \#getFormat24Hour()
  ///@deprecated Let the system use locale-appropriate defaults instead.
  static jni.JniObject get DEFAULT_FORMAT_24_HOUR =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_DEFAULT_FORMAT_24_HOUR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new clock using the default patterns for the current locale.
  ///@param context The Context the view is running in, through which it can
  ///        access the current theme, resources, etc.
  TextClock(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new clock inflated from XML. This object's properties are
  /// intialized from the attributes specified in XML.
  ///
  /// This constructor uses a default style of 0, so the only attribute values
  /// applied are those in the Context's Theme and the given AttributeSet.
  ///@param context The Context the view is running in, through which it can
  ///        access the current theme, resources, etc.
  ///@param attrs The attributes of the XML tag that is inflating the view
  TextClock.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new clock inflated from XML. This object's properties are
  /// intialized from the attributes specified in XML.
  ///@param context The Context the view is running in, through which it can
  ///        access the current theme, resources, etc.
  ///@param attrs The attributes of the XML tag that is inflating the view
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  TextClock.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TextClock.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_getFormat12Hour = jniAccessors.getMethodIDOf(
      _classRef, "getFormat12Hour", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getFormat12Hour()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the formatting pattern used to display the date and/or time
  /// in 12-hour mode. The formatting pattern syntax is described in
  /// DateFormat.
  ///@return A CharSequence or null.
  ///@see \#setFormat12Hour(CharSequence)
  ///@see \#is24HourModeEnabled()
  jni.JniObject getFormat12Hour() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFormat12Hour, jni.JniType.objectType, []).object);

  static final _id_setFormat12Hour = jniAccessors.getMethodIDOf(
      _classRef, "setFormat12Hour", "(Ljava/lang/CharSequence;)V");

  /// from: public void setFormat12Hour(java.lang.CharSequence format)
  ///
  /// Specifies the formatting pattern used to display the date and/or time
  /// in 12-hour mode. The formatting pattern syntax is described in
  /// DateFormat.
  ///
  ///
  /// If this pattern is set to null, \#getFormat24Hour() will be used
  /// even in 12-hour mode. If both 24-hour and 12-hour formatting patterns
  /// are set to null, the default pattern for the current locale will be used
  /// instead.
  ///
  ///
  /// <strong>Note:</strong> if styling is not needed, it is highly recommended
  /// you supply a format string generated by
  /// DateFormat\#getBestDateTimePattern(java.util.Locale, String). This method
  /// takes care of generating a format string adapted to the desired locale.
  ///
  ///@param format A date/time formatting pattern as described in DateFormat
  ///@see \#getFormat12Hour()
  ///@see \#is24HourModeEnabled()
  ///@see DateFormat\#getBestDateTimePattern(java.util.Locale, String)
  ///@see DateFormat
  ///@attr ref android.R.styleable\#TextClock_format12Hour
  void setFormat12Hour(jni.JniObject format) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFormat12Hour,
      jni.JniType.voidType,
      [format.reference]).check();

  static final _id_getFormat24Hour = jniAccessors.getMethodIDOf(
      _classRef, "getFormat24Hour", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getFormat24Hour()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the formatting pattern used to display the date and/or time
  /// in 24-hour mode. The formatting pattern syntax is described in
  /// DateFormat.
  ///@return A CharSequence or null.
  ///@see \#setFormat24Hour(CharSequence)
  ///@see \#is24HourModeEnabled()
  jni.JniObject getFormat24Hour() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFormat24Hour, jni.JniType.objectType, []).object);

  static final _id_setFormat24Hour = jniAccessors.getMethodIDOf(
      _classRef, "setFormat24Hour", "(Ljava/lang/CharSequence;)V");

  /// from: public void setFormat24Hour(java.lang.CharSequence format)
  ///
  /// Specifies the formatting pattern used to display the date and/or time
  /// in 24-hour mode. The formatting pattern syntax is described in
  /// DateFormat.
  ///
  ///
  /// If this pattern is set to null, \#getFormat24Hour() will be used
  /// even in 12-hour mode. If both 24-hour and 12-hour formatting patterns
  /// are set to null, the default pattern for the current locale will be used
  /// instead.
  ///
  ///
  /// <strong>Note:</strong> if styling is not needed, it is highly recommended
  /// you supply a format string generated by
  /// DateFormat\#getBestDateTimePattern(java.util.Locale, String). This method
  /// takes care of generating a format string adapted to the desired locale.
  ///
  ///@param format A date/time formatting pattern as described in DateFormat
  ///@see \#getFormat24Hour()
  ///@see \#is24HourModeEnabled()
  ///@see DateFormat\#getBestDateTimePattern(java.util.Locale, String)
  ///@see DateFormat
  ///@attr ref android.R.styleable\#TextClock_format24Hour
  void setFormat24Hour(jni.JniObject format) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFormat24Hour,
      jni.JniType.voidType,
      [format.reference]).check();

  static final _id_is24HourModeEnabled =
      jniAccessors.getMethodIDOf(_classRef, "is24HourModeEnabled", "()Z");

  /// from: public boolean is24HourModeEnabled()
  ///
  /// Indicates whether the system is currently using the 24-hour mode.
  ///
  /// When the system is in 24-hour mode, this view will use the pattern
  /// returned by \#getFormat24Hour(). In 12-hour mode, the pattern
  /// returned by \#getFormat12Hour() is used instead.
  ///
  /// If either one of the formats is null, the other format is used. If
  /// both formats are null, the default formats for the current locale are used.
  ///@return true if time should be displayed in 24-hour format, false if it
  ///         should be displayed in 12-hour format.
  ///@see \#setFormat12Hour(CharSequence)
  ///@see \#getFormat12Hour()
  ///@see \#setFormat24Hour(CharSequence)
  ///@see \#getFormat24Hour()
  bool is24HourModeEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_is24HourModeEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getTimeZone = jniAccessors.getMethodIDOf(
      _classRef, "getTimeZone", "()Ljava/lang/String;");

  /// from: public java.lang.String getTimeZone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates which time zone is currently used by this view.
  ///@return The ID of the current time zone or null if the default time zone,
  ///         as set by the user, must be used
  ///@see TimeZone
  ///@see java.util.TimeZone\#getAvailableIDs()
  ///@see \#setTimeZone(String)
  jni.JniString getTimeZone() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTimeZone, jni.JniType.objectType, []).object);

  static final _id_setTimeZone = jniAccessors.getMethodIDOf(
      _classRef, "setTimeZone", "(Ljava/lang/String;)V");

  /// from: public void setTimeZone(java.lang.String timeZone)
  ///
  /// Sets the specified time zone to use in this clock. When the time zone
  /// is set through this method, system time zone changes (when the user
  /// sets the time zone in settings for instance) will be ignored.
  ///@param timeZone The desired time zone's ID as specified in TimeZone
  ///                 or null to user the time zone specified by the user
  ///                 (system time zone)
  ///@see \#getTimeZone()
  ///@see java.util.TimeZone\#getAvailableIDs()
  ///@see TimeZone\#getTimeZone(String)
  ///@attr ref android.R.styleable\#TextClock_timeZone
  void setTimeZone(jni.JniString timeZone) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTimeZone,
      jni.JniType.voidType,
      [timeZone.reference]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onVisibilityAggregated1 =
      jniAccessors.getMethodIDOf(_classRef, "onVisibilityAggregated", "(Z)V");

  /// from: public void onVisibilityAggregated(boolean isVisible)
  void onVisibilityAggregated1(bool isVisible) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVisibilityAggregated1,
          jni.JniType.voidType, [isVisible]).check();

  static final _id_onDetachedFromWindow1 =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow1() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow1, jni.JniType.voidType, []).check();
}
