// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "LinearLayout.dart" as linearlayout_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../view/View.dart" as view_;

import "../content/res/TypedArray.dart" as typedarray_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.TableLayout
///
/// A layout that arranges its children into rows and columns.
/// A TableLayout consists of a number of android.widget.TableRow objects,
/// each defining a row (actually, you can have other children, which will be
/// explained below). TableLayout containers do not display border lines for
/// their rows, columns, or cells. Each row has zero or more cells; each cell can
/// hold one android.view.View View object. The table has as many columns
/// as the row with the most cells. A table can leave cells empty. Cells can span
/// columns, as they can in HTML.
///
///
/// The width of a column is defined by the row with the widest cell in that
/// column. However, a TableLayout can specify certain columns as shrinkable or
/// stretchable by calling
/// \#setColumnShrinkable(int, boolean) setColumnShrinkable()
/// or \#setColumnStretchable(int, boolean) setColumnStretchable(). If
/// marked as shrinkable, the column width can be shrunk to fit the table into
/// its parent object. If marked as stretchable, it can expand in width to fit
/// any extra space. The total width of the table is defined by its parent
/// container. It is important to remember that a column can be both shrinkable
/// and stretchable. In such a situation, the column will change its size to
/// always use up the available space, but never more. Finally, you can hide a
/// column by calling
/// \#setColumnCollapsed(int,boolean) setColumnCollapsed().
///
///
/// The children of a TableLayout cannot specify the <code>layout_width</code>
/// attribute. Width is always <code>MATCH_PARENT</code>. However, the
/// <code>layout_height</code> attribute can be defined by a child; default value
/// is android.widget.TableLayout.LayoutParams\#WRAP_CONTENT. If the child
/// is a android.widget.TableRow, then the height is always
/// android.widget.TableLayout.LayoutParams\#WRAP_CONTENT.
///
///
///  Cells must be added to a row in increasing column order, both in code and
/// XML. Column numbers are zero-based. If you don't specify a column number for
/// a child cell, it will autoincrement to the next available column. If you skip
/// a column number, it will be considered an empty cell in that row. See the
/// TableLayout examples in ApiDemos for examples of creating tables in XML.
///
///
/// Although the typical child of a TableLayout is a TableRow, you can
/// actually use any View subclass as a direct child of TableLayout. The View
/// will be displayed as a single row that spans all the table columns.
///
class TableLayout extends linearlayout_.LinearLayout {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/TableLayout");
  TableLayout.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new TableLayout for the given context.
  ///
  ///@param context the application environment
  TableLayout(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new TableLayout for the given context and with the
  /// specified set attributes.
  ///
  ///@param context the application environment
  ///@param attrs a collection of attributes
  TableLayout.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_setOnHierarchyChangeListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnHierarchyChangeListener",
      "(Landroid/view/ViewGroup\$OnHierarchyChangeListener;)V");

  /// from: public void setOnHierarchyChangeListener(android.view.ViewGroup.OnHierarchyChangeListener listener)
  ///
  /// {@inheritDoc}
  void setOnHierarchyChangeListener1(
          viewgroup_.ViewGroup_OnHierarchyChangeListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnHierarchyChangeListener1,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_requestLayout1 =
      jniAccessors.getMethodIDOf(_classRef, "requestLayout", "()V");

  /// from: public void requestLayout()
  ///
  /// {@inheritDoc}
  void requestLayout1() => jniAccessors.callMethodWithArgs(
      reference, _id_requestLayout1, jni.JniType.voidType, []).check();

  static final _id_isShrinkAllColumns =
      jniAccessors.getMethodIDOf(_classRef, "isShrinkAllColumns", "()Z");

  /// from: public boolean isShrinkAllColumns()
  ///
  /// Indicates whether all columns are shrinkable or not.
  ///
  ///@return true if all columns are shrinkable, false otherwise
  ///@attr ref android.R.styleable\#TableLayout_shrinkColumns
  bool isShrinkAllColumns() => jniAccessors.callMethodWithArgs(
      reference, _id_isShrinkAllColumns, jni.JniType.booleanType, []).boolean;

  static final _id_setShrinkAllColumns =
      jniAccessors.getMethodIDOf(_classRef, "setShrinkAllColumns", "(Z)V");

  /// from: public void setShrinkAllColumns(boolean shrinkAllColumns)
  ///
  /// Convenience method to mark all columns as shrinkable.
  ///
  ///@param shrinkAllColumns true to mark all columns shrinkable
  ///@attr ref android.R.styleable\#TableLayout_shrinkColumns
  void setShrinkAllColumns(bool shrinkAllColumns) =>
      jniAccessors.callMethodWithArgs(reference, _id_setShrinkAllColumns,
          jni.JniType.voidType, [shrinkAllColumns]).check();

  static final _id_isStretchAllColumns =
      jniAccessors.getMethodIDOf(_classRef, "isStretchAllColumns", "()Z");

  /// from: public boolean isStretchAllColumns()
  ///
  /// Indicates whether all columns are stretchable or not.
  ///
  ///@return true if all columns are stretchable, false otherwise
  ///@attr ref android.R.styleable\#TableLayout_stretchColumns
  bool isStretchAllColumns() => jniAccessors.callMethodWithArgs(
      reference, _id_isStretchAllColumns, jni.JniType.booleanType, []).boolean;

  static final _id_setStretchAllColumns =
      jniAccessors.getMethodIDOf(_classRef, "setStretchAllColumns", "(Z)V");

  /// from: public void setStretchAllColumns(boolean stretchAllColumns)
  ///
  /// Convenience method to mark all columns as stretchable.
  ///
  ///@param stretchAllColumns true to mark all columns stretchable
  ///@attr ref android.R.styleable\#TableLayout_stretchColumns
  void setStretchAllColumns(bool stretchAllColumns) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStretchAllColumns,
          jni.JniType.voidType, [stretchAllColumns]).check();

  static final _id_setColumnCollapsed =
      jniAccessors.getMethodIDOf(_classRef, "setColumnCollapsed", "(IZ)V");

  /// from: public void setColumnCollapsed(int columnIndex, boolean isCollapsed)
  ///
  /// Collapses or restores a given column. When collapsed, a column
  /// does not appear on screen and the extra space is reclaimed by the
  /// other columns. A column is collapsed/restored only when it belongs to
  /// a android.widget.TableRow.
  ///
  ///
  /// Calling this method requests a layout operation.
  ///
  ///@param columnIndex the index of the column
  ///@param isCollapsed true if the column must be collapsed, false otherwise
  ///@attr ref android.R.styleable\#TableLayout_collapseColumns
  void setColumnCollapsed(int columnIndex, bool isCollapsed) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColumnCollapsed,
          jni.JniType.voidType, [columnIndex, isCollapsed]).check();

  static final _id_isColumnCollapsed =
      jniAccessors.getMethodIDOf(_classRef, "isColumnCollapsed", "(I)Z");

  /// from: public boolean isColumnCollapsed(int columnIndex)
  ///
  /// Returns the collapsed state of the specified column.
  ///
  ///@param columnIndex the index of the column
  ///@return true if the column is collapsed, false otherwise
  bool isColumnCollapsed(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isColumnCollapsed,
      jni.JniType.booleanType,
      [columnIndex]).boolean;

  static final _id_setColumnStretchable =
      jniAccessors.getMethodIDOf(_classRef, "setColumnStretchable", "(IZ)V");

  /// from: public void setColumnStretchable(int columnIndex, boolean isStretchable)
  ///
  /// Makes the given column stretchable or not. When stretchable, a column
  /// takes up as much as available space as possible in its row.
  ///
  ///
  /// Calling this method requests a layout operation.
  ///
  ///@param columnIndex the index of the column
  ///@param isStretchable true if the column must be stretchable,
  ///                      false otherwise. Default is false.
  ///@attr ref android.R.styleable\#TableLayout_stretchColumns
  void setColumnStretchable(int columnIndex, bool isStretchable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColumnStretchable,
          jni.JniType.voidType, [columnIndex, isStretchable]).check();

  static final _id_isColumnStretchable =
      jniAccessors.getMethodIDOf(_classRef, "isColumnStretchable", "(I)Z");

  /// from: public boolean isColumnStretchable(int columnIndex)
  ///
  /// Returns whether the specified column is stretchable or not.
  ///
  ///@param columnIndex the index of the column
  ///@return true if the column is stretchable, false otherwise
  bool isColumnStretchable(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isColumnStretchable,
      jni.JniType.booleanType,
      [columnIndex]).boolean;

  static final _id_setColumnShrinkable =
      jniAccessors.getMethodIDOf(_classRef, "setColumnShrinkable", "(IZ)V");

  /// from: public void setColumnShrinkable(int columnIndex, boolean isShrinkable)
  ///
  /// Makes the given column shrinkable or not. When a row is too wide, the
  /// table can reclaim extra space from shrinkable columns.
  ///
  ///
  /// Calling this method requests a layout operation.
  ///
  ///@param columnIndex the index of the column
  ///@param isShrinkable true if the column must be shrinkable,
  ///                     false otherwise. Default is false.
  ///@attr ref android.R.styleable\#TableLayout_shrinkColumns
  void setColumnShrinkable(int columnIndex, bool isShrinkable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColumnShrinkable,
          jni.JniType.voidType, [columnIndex, isShrinkable]).check();

  static final _id_isColumnShrinkable =
      jniAccessors.getMethodIDOf(_classRef, "isColumnShrinkable", "(I)Z");

  /// from: public boolean isColumnShrinkable(int columnIndex)
  ///
  /// Returns whether the specified column is shrinkable or not.
  ///
  ///@param columnIndex the index of the column
  ///@return true if the column is shrinkable, false otherwise. Default is false.
  bool isColumnShrinkable(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isColumnShrinkable,
      jni.JniType.booleanType,
      [columnIndex]).boolean;

  static final _id_addView5 = jniAccessors.getMethodIDOf(
      _classRef, "addView", "(Landroid/view/View;)V");

  /// from: public void addView(android.view.View child)
  ///
  /// {@inheritDoc}
  void addView5(view_.View child) => jniAccessors.callMethodWithArgs(
      reference, _id_addView5, jni.JniType.voidType, [child.reference]).check();

  static final _id_addView6 = jniAccessors.getMethodIDOf(
      _classRef, "addView", "(Landroid/view/View;I)V");

  /// from: public void addView(android.view.View child, int index)
  ///
  /// {@inheritDoc}
  void addView6(view_.View child, int index) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addView6,
      jni.JniType.voidType,
      [child.reference, index]).check();

  static final _id_addView7 = jniAccessors.getMethodIDOf(_classRef, "addView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void addView(android.view.View child, android.view.ViewGroup.LayoutParams params)
  ///
  /// {@inheritDoc}
  void addView7(view_.View child, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_addView7,
          jni.JniType.voidType, [child.reference, params.reference]).check();

  static final _id_addView8 = jniAccessors.getMethodIDOf(_classRef, "addView",
      "(Landroid/view/View;ILandroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void addView(android.view.View child, int index, android.view.ViewGroup.LayoutParams params)
  ///
  /// {@inheritDoc}
  void addView8(view_.View child, int index,
          viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addView8,
          jni.JniType.voidType,
          [child.reference, index, params.reference]).check();

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  ///
  /// {@inheritDoc}
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int l, int t, int r, int b)
  ///
  /// {@inheritDoc}
  void onLayout(bool changed, int l, int t, int r, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, l, t, r, b]).check();

  static final _id_generateLayoutParams4 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/util/AttributeSet;)Landroid/widget/TableLayout\$LayoutParams;");

  /// from: public android.widget.TableLayout.LayoutParams generateLayoutParams(android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  TableLayout_LayoutParams generateLayoutParams4(
          attributeset_.AttributeSet attrs) =>
      TableLayout_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams4,
          jni.JniType.objectType,
          [attrs.reference]).object);

  static final _id_generateDefaultLayoutParams1 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateDefaultLayoutParams",
      "()Landroid/widget/LinearLayout\$LayoutParams;");

  /// from: protected android.widget.LinearLayout.LayoutParams generateDefaultLayoutParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a set of layout parameters with a width of
  /// android.view.ViewGroup.LayoutParams\#MATCH_PARENT,
  /// and a height of android.view.ViewGroup.LayoutParams\#WRAP_CONTENT.
  linearlayout_.LinearLayout_LayoutParams generateDefaultLayoutParams1() =>
      linearlayout_.LinearLayout_LayoutParams.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_generateDefaultLayoutParams1,
              jni.JniType.objectType, []).object);

  static final _id_checkLayoutParams = jniAccessors.getMethodIDOf(_classRef,
      "checkLayoutParams", "(Landroid/view/ViewGroup\$LayoutParams;)Z");

  /// from: protected boolean checkLayoutParams(android.view.ViewGroup.LayoutParams p)
  ///
  /// {@inheritDoc}
  bool checkLayoutParams(viewgroup_.ViewGroup_LayoutParams p) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkLayoutParams,
          jni.JniType.booleanType, [p.reference]).boolean;

  static final _id_generateLayoutParams3 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/view/ViewGroup\$LayoutParams;)Landroid/widget/LinearLayout\$LayoutParams;");

  /// from: protected android.widget.LinearLayout.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams p)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  linearlayout_.LinearLayout_LayoutParams generateLayoutParams3(
          viewgroup_.ViewGroup_LayoutParams p) =>
      linearlayout_.LinearLayout_LayoutParams.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_generateLayoutParams3,
              jni.JniType.objectType, [p.reference]).object);

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);
}

/// from: android.widget.TableLayout$LayoutParams
///
/// This set of layout parameters enforces the width of each child to be
/// \#MATCH_PARENT and the height of each child to be
/// \#WRAP_CONTENT, but only if the height is not specified.
///
class TableLayout_LayoutParams extends linearlayout_.LinearLayout_LayoutParams {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/TableLayout\$LayoutParams");
  TableLayout_LayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  TableLayout_LayoutParams(context_.Context c, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [c.reference, attrs.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int w, int h)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  TableLayout_LayoutParams.ctor1(int w, int h)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [w, h]).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIF)V");

  /// from: public void <init>(int w, int h, float initWeight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  TableLayout_LayoutParams.ctor4(int w, int h, double initWeight)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [w, h, initWeight]).object);

  static final _id_ctor6 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the child width to
  /// android.view.ViewGroup.LayoutParams and the child height to
  /// android.view.ViewGroup.LayoutParams\#WRAP_CONTENT.
  ///
  TableLayout_LayoutParams.ctor6()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor6, []).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.LayoutParams p)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  TableLayout_LayoutParams.ctor2(viewgroup_.ViewGroup_LayoutParams p)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [p.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$MarginLayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.MarginLayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  TableLayout_LayoutParams.ctor3(viewgroup_.ViewGroup_MarginLayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [source.reference]).object);

  static final _id_setBaseAttributes1 = jniAccessors.getMethodIDOf(
      _classRef, "setBaseAttributes", "(Landroid/content/res/TypedArray;II)V");

  /// from: protected void setBaseAttributes(android.content.res.TypedArray a, int widthAttr, int heightAttr)
  ///
  /// Fixes the row's width to
  /// android.view.ViewGroup.LayoutParams\#MATCH_PARENT; the row's
  /// height is fixed to
  /// android.view.ViewGroup.LayoutParams\#WRAP_CONTENT if no layout
  /// height is specified.
  ///
  ///@param a the styled attributes set
  ///@param widthAttr the width attribute to fetch
  ///@param heightAttr the height attribute to fetch
  void setBaseAttributes1(
          typedarray_.TypedArray a, int widthAttr, int heightAttr) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBaseAttributes1,
          jni.JniType.voidType, [a.reference, widthAttr, heightAttr]).check();
}
