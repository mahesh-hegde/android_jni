// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "CompoundButton.dart" as compoundbutton_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../graphics/Typeface.dart" as typeface_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../content/res/ColorStateList.dart" as colorstatelist_;

import "../graphics/PorterDuff.dart" as porterduff_;

import "../view/MotionEvent.dart" as motionevent_;

import "../graphics/Canvas.dart" as canvas_;

import "../view/ViewStructure.dart" as viewstructure_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.Switch
///
/// A Switch is a two-state toggle switch widget that can select between two
/// options. The user may drag the "thumb" back and forth to choose the selected option,
/// or simply tap to toggle as if it were a checkbox. The \#setText(CharSequence) text
/// property controls the text displayed in the label for the switch, whereas the
/// \#setTextOff(CharSequence) off and \#setTextOn(CharSequence) on text
/// controls the text on the thumb. Similarly, the
/// \#setTextAppearance(android.content.Context, int) textAppearance and the related
/// setTypeface() methods control the typeface and style of label text, whereas the
/// \#setSwitchTextAppearance(android.content.Context, int) switchTextAppearance and
/// the related setSwitchTypeface() methods control that of the thumb.
///
/// android.support.v7.widget.SwitchCompat is a version of
/// the Switch widget which runs on devices back to API 7.
///
///
/// See the <a href="{@docRoot}guide/topics/ui/controls/togglebutton.html">Toggle Buttons</a>
/// guide.
///
///@attr ref android.R.styleable\#Switch_textOn
///@attr ref android.R.styleable\#Switch_textOff
///@attr ref android.R.styleable\#Switch_switchMinWidth
///@attr ref android.R.styleable\#Switch_switchPadding
///@attr ref android.R.styleable\#Switch_switchTextAppearance
///@attr ref android.R.styleable\#Switch_thumb
///@attr ref android.R.styleable\#Switch_thumbTextPadding
///@attr ref android.R.styleable\#Switch_track
class Switch extends compoundbutton_.CompoundButton {
  static final _classRef = jniAccessors.getClassOf("android/widget/Switch");
  Switch.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new Switch with default styling.
  ///@param context The Context that will determine this widget's theming.
  Switch(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new Switch with default styling, overriding specific style
  /// attributes as requested.
  ///@param context The Context that will determine this widget's theming.
  ///@param attrs Specification of attributes that should deviate from default styling.
  Switch.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new Switch with a default style determined by the given theme attribute,
  /// overriding specific style attributes as requested.
  ///@param context The Context that will determine this widget's theming.
  ///@param attrs Specification of attributes that should deviate from the default styling.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  Switch.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new Switch with a default style determined by the given theme
  /// attribute or style resource, overriding specific style attributes as
  /// requested.
  ///@param context The Context that will determine this widget's theming.
  ///@param attrs Specification of attributes that should deviate from the
  ///        default styling.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  ///@param defStyleRes A resource identifier of a style resource that
  ///        supplies default values for the view, used only if
  ///        defStyleAttr is 0 or can not be found in the theme. Can be 0
  ///        to not look for defaults.
  Switch.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_setSwitchTextAppearance = jniAccessors.getMethodIDOf(
      _classRef, "setSwitchTextAppearance", "(Landroid/content/Context;I)V");

  /// from: public void setSwitchTextAppearance(android.content.Context context, int resid)
  ///
  /// Sets the switch text color, size, style, hint color, and highlight color
  /// from the specified TextAppearance resource.
  ///@attr ref android.R.styleable\#Switch_switchTextAppearance
  void setSwitchTextAppearance(context_.Context context, int resid) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSwitchTextAppearance,
          jni.JniType.voidType, [context.reference, resid]).check();

  static final _id_setSwitchTypeface = jniAccessors.getMethodIDOf(
      _classRef, "setSwitchTypeface", "(Landroid/graphics/Typeface;I)V");

  /// from: public void setSwitchTypeface(android.graphics.Typeface tf, int style)
  ///
  /// Sets the typeface and style in which the text should be displayed on the
  /// switch, and turns on the fake bold and italic bits in the Paint if the
  /// Typeface that you provided does not have all the bits in the
  /// style that you specified.
  void setSwitchTypeface(typeface_.Typeface tf, int style) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSwitchTypeface,
          jni.JniType.voidType, [tf.reference, style]).check();

  static final _id_setSwitchTypeface1 = jniAccessors.getMethodIDOf(
      _classRef, "setSwitchTypeface", "(Landroid/graphics/Typeface;)V");

  /// from: public void setSwitchTypeface(android.graphics.Typeface tf)
  ///
  /// Sets the typeface in which the text should be displayed on the switch.
  /// Note that not all Typeface families actually have bold and italic
  /// variants, so you may need to use
  /// \#setSwitchTypeface(Typeface, int) to get the appearance
  /// that you actually want.
  ///@attr ref android.R.styleable\#TextView_typeface
  ///@attr ref android.R.styleable\#TextView_textStyle
  void setSwitchTypeface1(typeface_.Typeface tf) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSwitchTypeface1,
          jni.JniType.voidType, [tf.reference]).check();

  static final _id_setSwitchPadding =
      jniAccessors.getMethodIDOf(_classRef, "setSwitchPadding", "(I)V");

  /// from: public void setSwitchPadding(int pixels)
  ///
  /// Set the amount of horizontal padding between the switch and the associated text.
  ///@param pixels Amount of padding in pixels
  ///@attr ref android.R.styleable\#Switch_switchPadding
  void setSwitchPadding(int pixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setSwitchPadding, jni.JniType.voidType, [pixels]).check();

  static final _id_getSwitchPadding =
      jniAccessors.getMethodIDOf(_classRef, "getSwitchPadding", "()I");

  /// from: public int getSwitchPadding()
  ///
  /// Get the amount of horizontal padding between the switch and the associated text.
  ///@return Amount of padding in pixels
  ///@attr ref android.R.styleable\#Switch_switchPadding
  int getSwitchPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getSwitchPadding, jni.JniType.intType, []).integer;

  static final _id_setSwitchMinWidth =
      jniAccessors.getMethodIDOf(_classRef, "setSwitchMinWidth", "(I)V");

  /// from: public void setSwitchMinWidth(int pixels)
  ///
  /// Set the minimum width of the switch in pixels. The switch's width will be the maximum
  /// of this value and its measured width as determined by the switch drawables and text used.
  ///@param pixels Minimum width of the switch in pixels
  ///@attr ref android.R.styleable\#Switch_switchMinWidth
  void setSwitchMinWidth(int pixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setSwitchMinWidth, jni.JniType.voidType, [pixels]).check();

  static final _id_getSwitchMinWidth =
      jniAccessors.getMethodIDOf(_classRef, "getSwitchMinWidth", "()I");

  /// from: public int getSwitchMinWidth()
  ///
  /// Get the minimum width of the switch in pixels. The switch's width will be the maximum
  /// of this value and its measured width as determined by the switch drawables and text used.
  ///@return Minimum width of the switch in pixels
  ///@attr ref android.R.styleable\#Switch_switchMinWidth
  int getSwitchMinWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getSwitchMinWidth, jni.JniType.intType, []).integer;

  static final _id_setThumbTextPadding =
      jniAccessors.getMethodIDOf(_classRef, "setThumbTextPadding", "(I)V");

  /// from: public void setThumbTextPadding(int pixels)
  ///
  /// Set the horizontal padding around the text drawn on the switch itself.
  ///@param pixels Horizontal padding for switch thumb text in pixels
  ///@attr ref android.R.styleable\#Switch_thumbTextPadding
  void setThumbTextPadding(int pixels) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setThumbTextPadding,
      jni.JniType.voidType,
      [pixels]).check();

  static final _id_getThumbTextPadding =
      jniAccessors.getMethodIDOf(_classRef, "getThumbTextPadding", "()I");

  /// from: public int getThumbTextPadding()
  ///
  /// Get the horizontal padding around the text drawn on the switch itself.
  ///@return Horizontal padding for switch thumb text in pixels
  ///@attr ref android.R.styleable\#Switch_thumbTextPadding
  int getThumbTextPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getThumbTextPadding, jni.JniType.intType, []).integer;

  static final _id_setTrackDrawable = jniAccessors.getMethodIDOf(
      _classRef, "setTrackDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setTrackDrawable(android.graphics.drawable.Drawable track)
  ///
  /// Set the drawable used for the track that the switch slides within.
  ///@param track Track drawable
  ///@attr ref android.R.styleable\#Switch_track
  void setTrackDrawable(drawable_.Drawable track) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTrackDrawable,
          jni.JniType.voidType, [track.reference]).check();

  static final _id_setTrackResource =
      jniAccessors.getMethodIDOf(_classRef, "setTrackResource", "(I)V");

  /// from: public void setTrackResource(int resId)
  ///
  /// Set the drawable used for the track that the switch slides within.
  ///@param resId Resource ID of a track drawable
  ///@attr ref android.R.styleable\#Switch_track
  void setTrackResource(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setTrackResource, jni.JniType.voidType, [resId]).check();

  static final _id_getTrackDrawable = jniAccessors.getMethodIDOf(
      _classRef, "getTrackDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getTrackDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the drawable used for the track that the switch slides within.
  ///@return Track drawable
  ///@attr ref android.R.styleable\#Switch_track
  drawable_.Drawable getTrackDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTrackDrawable, jni.JniType.objectType, []).object);

  static final _id_setTrackTintList = jniAccessors.getMethodIDOf(
      _classRef, "setTrackTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTrackTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the track drawable. Does not modify the current
  /// tint mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// Subsequent calls to \#setTrackDrawable(Drawable) will
  /// automatically mutate the drawable and apply the specified tint and tint
  /// mode using Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Switch_trackTint
  ///@see \#getTrackTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setTrackTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTrackTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_getTrackTintList = jniAccessors.getMethodIDOf(
      _classRef, "getTrackTintList", "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getTrackTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the tint applied to the track drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Switch_trackTint
  ///@see \#setTrackTintList(ColorStateList)
  colorstatelist_.ColorStateList getTrackTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTrackTintList, jni.JniType.objectType, []).object);

  static final _id_setTrackTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setTrackTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setTrackTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setTrackTintList(ColorStateList)} to the track drawable.
  /// The default mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Switch_trackTintMode
  ///@see \#getTrackTintMode()
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setTrackTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTrackTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_getTrackTintMode = jniAccessors.getMethodIDOf(
      _classRef, "getTrackTintMode", "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getTrackTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the blending mode used to apply the tint to the track
  ///         drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Switch_trackTintMode
  ///@see \#setTrackTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getTrackTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTrackTintMode, jni.JniType.objectType, []).object);

  static final _id_setThumbDrawable = jniAccessors.getMethodIDOf(
      _classRef, "setThumbDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setThumbDrawable(android.graphics.drawable.Drawable thumb)
  ///
  /// Set the drawable used for the switch "thumb" - the piece that the user
  /// can physically touch and drag along the track.
  ///@param thumb Thumb drawable
  ///@attr ref android.R.styleable\#Switch_thumb
  void setThumbDrawable(drawable_.Drawable thumb) =>
      jniAccessors.callMethodWithArgs(reference, _id_setThumbDrawable,
          jni.JniType.voidType, [thumb.reference]).check();

  static final _id_setThumbResource =
      jniAccessors.getMethodIDOf(_classRef, "setThumbResource", "(I)V");

  /// from: public void setThumbResource(int resId)
  ///
  /// Set the drawable used for the switch "thumb" - the piece that the user
  /// can physically touch and drag along the track.
  ///@param resId Resource ID of a thumb drawable
  ///@attr ref android.R.styleable\#Switch_thumb
  void setThumbResource(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setThumbResource, jni.JniType.voidType, [resId]).check();

  static final _id_getThumbDrawable = jniAccessors.getMethodIDOf(
      _classRef, "getThumbDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getThumbDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the drawable used for the switch "thumb" - the piece that the user
  /// can physically touch and drag along the track.
  ///@return Thumb drawable
  ///@attr ref android.R.styleable\#Switch_thumb
  drawable_.Drawable getThumbDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getThumbDrawable, jni.JniType.objectType, []).object);

  static final _id_setThumbTintList = jniAccessors.getMethodIDOf(
      _classRef, "setThumbTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setThumbTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the thumb drawable. Does not modify the current
  /// tint mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// Subsequent calls to \#setThumbDrawable(Drawable) will
  /// automatically mutate the drawable and apply the specified tint and tint
  /// mode using Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Switch_thumbTint
  ///@see \#getThumbTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setThumbTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setThumbTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_getThumbTintList = jniAccessors.getMethodIDOf(
      _classRef, "getThumbTintList", "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getThumbTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the tint applied to the thumb drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Switch_thumbTint
  ///@see \#setThumbTintList(ColorStateList)
  colorstatelist_.ColorStateList getThumbTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getThumbTintList, jni.JniType.objectType, []).object);

  static final _id_setThumbTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setThumbTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setThumbTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setThumbTintList(ColorStateList)} to the thumb drawable.
  /// The default mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Switch_thumbTintMode
  ///@see \#getThumbTintMode()
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setThumbTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setThumbTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_getThumbTintMode = jniAccessors.getMethodIDOf(
      _classRef, "getThumbTintMode", "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getThumbTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the blending mode used to apply the tint to the thumb
  ///         drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#Switch_thumbTintMode
  ///@see \#setThumbTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getThumbTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getThumbTintMode, jni.JniType.objectType, []).object);

  static final _id_setSplitTrack =
      jniAccessors.getMethodIDOf(_classRef, "setSplitTrack", "(Z)V");

  /// from: public void setSplitTrack(boolean splitTrack)
  ///
  /// Specifies whether the track should be split by the thumb. When true,
  /// the thumb's optical bounds will be clipped out of the track drawable,
  /// then the thumb will be drawn into the resulting gap.
  ///@param splitTrack Whether the track should be split by the thumb
  ///@attr ref android.R.styleable\#Switch_splitTrack
  void setSplitTrack(bool splitTrack) => jniAccessors.callMethodWithArgs(
      reference, _id_setSplitTrack, jni.JniType.voidType, [splitTrack]).check();

  static final _id_getSplitTrack =
      jniAccessors.getMethodIDOf(_classRef, "getSplitTrack", "()Z");

  /// from: public boolean getSplitTrack()
  ///
  /// Returns whether the track should be split by the thumb.
  ///@attr ref android.R.styleable\#Switch_splitTrack
  bool getSplitTrack() => jniAccessors.callMethodWithArgs(
      reference, _id_getSplitTrack, jni.JniType.booleanType, []).boolean;

  static final _id_getTextOn = jniAccessors.getMethodIDOf(
      _classRef, "getTextOn", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTextOn()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the text displayed when the button is in the checked state.
  ///@attr ref android.R.styleable\#Switch_textOn
  jni.JniObject getTextOn() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextOn, jni.JniType.objectType, []).object);

  static final _id_setTextOn = jniAccessors.getMethodIDOf(
      _classRef, "setTextOn", "(Ljava/lang/CharSequence;)V");

  /// from: public void setTextOn(java.lang.CharSequence textOn)
  ///
  /// Sets the text displayed when the button is in the checked state.
  ///@attr ref android.R.styleable\#Switch_textOn
  void setTextOn(jni.JniObject textOn) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextOn,
      jni.JniType.voidType,
      [textOn.reference]).check();

  static final _id_getTextOff = jniAccessors.getMethodIDOf(
      _classRef, "getTextOff", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTextOff()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the text displayed when the button is not in the checked state.
  ///@attr ref android.R.styleable\#Switch_textOff
  jni.JniObject getTextOff() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextOff, jni.JniType.objectType, []).object);

  static final _id_setTextOff = jniAccessors.getMethodIDOf(
      _classRef, "setTextOff", "(Ljava/lang/CharSequence;)V");

  /// from: public void setTextOff(java.lang.CharSequence textOff)
  ///
  /// Sets the text displayed when the button is not in the checked state.
  ///@attr ref android.R.styleable\#Switch_textOff
  void setTextOff(jni.JniObject textOff) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextOff,
      jni.JniType.voidType,
      [textOff.reference]).check();

  static final _id_setShowText =
      jniAccessors.getMethodIDOf(_classRef, "setShowText", "(Z)V");

  /// from: public void setShowText(boolean showText)
  ///
  /// Sets whether the on/off text should be displayed.
  ///@param showText {@code true} to display on/off text
  ///@attr ref android.R.styleable\#Switch_showText
  void setShowText(bool showText) => jniAccessors.callMethodWithArgs(
      reference, _id_setShowText, jni.JniType.voidType, [showText]).check();

  static final _id_getShowText =
      jniAccessors.getMethodIDOf(_classRef, "getShowText", "()Z");

  /// from: public boolean getShowText()
  ///
  /// @return whether the on/off text should be displayed
  ///@attr ref android.R.styleable\#Switch_showText
  bool getShowText() => jniAccessors.callMethodWithArgs(
      reference, _id_getShowText, jni.JniType.booleanType, []).boolean;

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: public void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_onTouchEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent ev)
  bool onTouchEvent1(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent1,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_toggle =
      jniAccessors.getMethodIDOf(_classRef, "toggle", "()V");

  /// from: public void toggle()
  void toggle() => jniAccessors.callMethodWithArgs(
      reference, _id_toggle, jni.JniType.voidType, []).check();

  static final _id_setChecked =
      jniAccessors.getMethodIDOf(_classRef, "setChecked", "(Z)V");

  /// from: public void setChecked(boolean checked)
  void setChecked(bool checked) => jniAccessors.callMethodWithArgs(
      reference, _id_setChecked, jni.JniType.voidType, [checked]).check();

  static final _id_onLayout1 =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int left, int top, int right, int bottom)
  void onLayout1(bool changed, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout1,
          jni.JniType.voidType, [changed, left, top, right, bottom]).check();

  static final _id_draw1 = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas c)
  void draw1(canvas_.Canvas c) => jniAccessors.callMethodWithArgs(
      reference, _id_draw1, jni.JniType.voidType, [c.reference]).check();

  static final _id_onDraw1 = jniAccessors.getMethodIDOf(
      _classRef, "onDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw1(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_onDraw1, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getCompoundPaddingLeft1 =
      jniAccessors.getMethodIDOf(_classRef, "getCompoundPaddingLeft", "()I");

  /// from: public int getCompoundPaddingLeft()
  int getCompoundPaddingLeft1() => jniAccessors.callMethodWithArgs(
      reference, _id_getCompoundPaddingLeft1, jni.JniType.intType, []).integer;

  static final _id_getCompoundPaddingRight1 =
      jniAccessors.getMethodIDOf(_classRef, "getCompoundPaddingRight", "()I");

  /// from: public int getCompoundPaddingRight()
  int getCompoundPaddingRight1() => jniAccessors.callMethodWithArgs(
      reference, _id_getCompoundPaddingRight1, jni.JniType.intType, []).integer;

  static final _id_onCreateDrawableState1 =
      jniAccessors.getMethodIDOf(_classRef, "onCreateDrawableState", "(I)[I");

  /// from: protected int[] onCreateDrawableState(int extraSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onCreateDrawableState1(int extraSpace) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateDrawableState1,
          jni.JniType.objectType,
          [extraSpace]).object);

  static final _id_drawableStateChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "drawableStateChanged", "()V");

  /// from: protected void drawableStateChanged()
  void drawableStateChanged1() => jniAccessors.callMethodWithArgs(
      reference, _id_drawableStateChanged1, jni.JniType.voidType, []).check();

  static final _id_drawableHotspotChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "drawableHotspotChanged", "(FF)V");

  /// from: public void drawableHotspotChanged(float x, float y)
  void drawableHotspotChanged1(double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawableHotspotChanged1,
          jni.JniType.voidType, [x, y]).check();

  static final _id_verifyDrawable1 = jniAccessors.getMethodIDOf(
      _classRef, "verifyDrawable", "(Landroid/graphics/drawable/Drawable;)Z");

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable who)
  ///
  /// @param who This value must never be {@code null}.
  bool verifyDrawable1(drawable_.Drawable who) =>
      jniAccessors.callMethodWithArgs(reference, _id_verifyDrawable1,
          jni.JniType.booleanType, [who.reference]).boolean;

  static final _id_jumpDrawablesToCurrentState1 = jniAccessors.getMethodIDOf(
      _classRef, "jumpDrawablesToCurrentState", "()V");

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_jumpDrawablesToCurrentState1,
      jni.JniType.voidType, []).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_onProvideStructure1 = jniAccessors.getMethodIDOf(
      _classRef, "onProvideStructure", "(Landroid/view/ViewStructure;)V");

  /// from: public void onProvideStructure(android.view.ViewStructure structure)
  void onProvideStructure1(viewstructure_.ViewStructure structure) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideStructure1,
          jni.JniType.voidType, [structure.reference]).check();

  static final _id_onProvideAutofillStructure1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideAutofillStructure",
      "(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideAutofillStructure(android.view.ViewStructure structure, int flags)
  void onProvideAutofillStructure1(
          viewstructure_.ViewStructure structure, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onProvideAutofillStructure1,
          jni.JniType.voidType,
          [structure.reference, flags]).check();
}
