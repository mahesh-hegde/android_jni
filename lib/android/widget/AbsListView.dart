// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AdapterView.dart" as adapterview_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "ListAdapter.dart" as listadapter_;

import "../util/SparseBooleanArray.dart" as sparsebooleanarray_;

import "../view/View.dart" as view_;

import "../view/accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "../graphics/Rect.dart" as rect_;

import "../os/Parcelable.dart" as parcelable_;

import "../view/accessibility/AccessibilityNodeInfo.dart"
    as accessibilitynodeinfo_;

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../view/ContextMenu.dart" as contextmenu_;

import "../view/KeyEvent.dart" as keyevent_;

import "../view/MotionEvent.dart" as motionevent_;

import "../view/PointerIcon.dart" as pointericon_;

import "../view/inputmethod/InputConnection.dart" as inputconnection_;

import "../view/inputmethod/EditorInfo.dart" as editorinfo_;

import "../text/Editable.dart" as editable_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../content/Intent.dart" as intent_;

import "../view/ActionMode.dart" as actionmode_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.AbsListView
///
/// Base class that can be used to implement virtualized lists of items. A list does
/// not have a spatial definition here. For instance, subclasses of this class can
/// display the content of the list in a grid, in a carousel, as stack, etc.
///@attr ref android.R.styleable\#AbsListView_listSelector
///@attr ref android.R.styleable\#AbsListView_drawSelectorOnTop
///@attr ref android.R.styleable\#AbsListView_stackFromBottom
///@attr ref android.R.styleable\#AbsListView_scrollingCache
///@attr ref android.R.styleable\#AbsListView_textFilterEnabled
///@attr ref android.R.styleable\#AbsListView_transcriptMode
///@attr ref android.R.styleable\#AbsListView_cacheColorHint
///@attr ref android.R.styleable\#AbsListView_fastScrollEnabled
///@attr ref android.R.styleable\#AbsListView_smoothScrollbar
///@attr ref android.R.styleable\#AbsListView_choiceMode
class AbsListView extends adapterview_.AdapterView {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/AbsListView");
  AbsListView.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CHOICE_MODE_MULTIPLE
  ///
  /// The list allows multiple choices
  static const CHOICE_MODE_MULTIPLE = 2;

  /// from: static public final int CHOICE_MODE_MULTIPLE_MODAL
  ///
  /// The list allows multiple choices in a modal selection mode
  static const CHOICE_MODE_MULTIPLE_MODAL = 3;

  /// from: static public final int CHOICE_MODE_NONE
  ///
  /// Normal list that does not indicate choices
  static const CHOICE_MODE_NONE = 0;

  /// from: static public final int CHOICE_MODE_SINGLE
  ///
  /// The list allows up to one choice
  static const CHOICE_MODE_SINGLE = 1;

  /// from: static public final int TRANSCRIPT_MODE_ALWAYS_SCROLL
  ///
  /// The list will automatically scroll to the bottom, no matter what items
  /// are currently visible.
  ///@see \#setTranscriptMode(int)
  static const TRANSCRIPT_MODE_ALWAYS_SCROLL = 2;

  /// from: static public final int TRANSCRIPT_MODE_DISABLED
  ///
  /// Disables the transcript mode.
  ///@see \#setTranscriptMode(int)
  static const TRANSCRIPT_MODE_DISABLED = 0;

  /// from: static public final int TRANSCRIPT_MODE_NORMAL
  ///
  /// The list will automatically scroll to the bottom when a data set change
  /// notification is received and only if the last item is already visible
  /// on screen.
  ///@see \#setTranscriptMode(int)
  static const TRANSCRIPT_MODE_NORMAL = 1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_setOverScrollMode1 =
      jniAccessors.getMethodIDOf(_classRef, "setOverScrollMode", "(I)V");

  /// from: public void setOverScrollMode(int mode)
  void setOverScrollMode1(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setOverScrollMode1, jni.JniType.voidType, [mode]).check();

  static final _id_setAdapter1 = jniAccessors.getMethodIDOf(
      _classRef, "setAdapter", "(Landroid/widget/ListAdapter;)V");

  /// from: public void setAdapter(android.widget.ListAdapter adapter)
  ///
  /// {@inheritDoc}
  void setAdapter1(listadapter_.ListAdapter adapter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAdapter1,
          jni.JniType.voidType, [adapter.reference]).check();

  static final _id_getCheckedItemCount =
      jniAccessors.getMethodIDOf(_classRef, "getCheckedItemCount", "()I");

  /// from: public int getCheckedItemCount()
  ///
  /// Returns the number of items currently selected. This will only be valid
  /// if the choice mode is not \#CHOICE_MODE_NONE (default).
  ///
  /// To determine the specific items that are currently selected, use one of
  /// the <code>getChecked*</code> methods.
  ///@return The number of items currently selected
  ///@see \#getCheckedItemPosition()
  ///@see \#getCheckedItemPositions()
  ///@see \#getCheckedItemIds()
  int getCheckedItemCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getCheckedItemCount, jni.JniType.intType, []).integer;

  static final _id_isItemChecked =
      jniAccessors.getMethodIDOf(_classRef, "isItemChecked", "(I)Z");

  /// from: public boolean isItemChecked(int position)
  ///
  /// Returns the checked state of the specified position. The result is only
  /// valid if the choice mode has been set to \#CHOICE_MODE_SINGLE
  /// or \#CHOICE_MODE_MULTIPLE.
  ///@param position The item whose checked state to return
  ///@return The item's checked state or <code>false</code> if choice mode
  ///         is invalid
  ///@see \#setChoiceMode(int)
  bool isItemChecked(int position) => jniAccessors.callMethodWithArgs(reference,
      _id_isItemChecked, jni.JniType.booleanType, [position]).boolean;

  static final _id_getCheckedItemPosition =
      jniAccessors.getMethodIDOf(_classRef, "getCheckedItemPosition", "()I");

  /// from: public int getCheckedItemPosition()
  ///
  /// Returns the currently checked item. The result is only valid if the choice
  /// mode has been set to \#CHOICE_MODE_SINGLE.
  ///@return The position of the currently checked item or
  ///         \#INVALID_POSITION if nothing is selected
  ///@see \#setChoiceMode(int)
  int getCheckedItemPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getCheckedItemPosition, jni.JniType.intType, []).integer;

  static final _id_getCheckedItemPositions = jniAccessors.getMethodIDOf(
      _classRef,
      "getCheckedItemPositions",
      "()Landroid/util/SparseBooleanArray;");

  /// from: public android.util.SparseBooleanArray getCheckedItemPositions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of checked items in the list. The result is only valid if
  /// the choice mode has not been set to \#CHOICE_MODE_NONE.
  ///@return A SparseBooleanArray which will return true for each call to
  ///          get(int position) where position is a checked position in the
  ///          list and false otherwise, or <code>null</code> if the choice
  ///          mode is set to \#CHOICE_MODE_NONE.
  sparsebooleanarray_.SparseBooleanArray getCheckedItemPositions() =>
      sparsebooleanarray_.SparseBooleanArray.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getCheckedItemPositions,
              jni.JniType.objectType, []).object);

  static final _id_getCheckedItemIds =
      jniAccessors.getMethodIDOf(_classRef, "getCheckedItemIds", "()[J");

  /// from: public long[] getCheckedItemIds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of checked items ids. The result is only valid if the
  /// choice mode has not been set to \#CHOICE_MODE_NONE and the adapter
  /// has stable IDs. (ListAdapter\#hasStableIds() == {@code true})
  ///@return A new array which contains the id of each checked item in the
  ///         list.
  jni.JniObject getCheckedItemIds() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCheckedItemIds, jni.JniType.objectType, []).object);

  static final _id_clearChoices =
      jniAccessors.getMethodIDOf(_classRef, "clearChoices", "()V");

  /// from: public void clearChoices()
  ///
  /// Clear any choices previously set
  void clearChoices() => jniAccessors.callMethodWithArgs(
      reference, _id_clearChoices, jni.JniType.voidType, []).check();

  static final _id_setItemChecked =
      jniAccessors.getMethodIDOf(_classRef, "setItemChecked", "(IZ)V");

  /// from: public void setItemChecked(int position, boolean value)
  ///
  /// Sets the checked state of the specified position. The is only valid if
  /// the choice mode has been set to \#CHOICE_MODE_SINGLE or
  /// \#CHOICE_MODE_MULTIPLE.
  ///@param position The item whose checked state is to be checked
  ///@param value The new checked state for the item
  void setItemChecked(int position, bool value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setItemChecked,
          jni.JniType.voidType, [position, value]).check();

  static final _id_performItemClick = jniAccessors.getMethodIDOf(
      _classRef, "performItemClick", "(Landroid/view/View;IJ)Z");

  /// from: public boolean performItemClick(android.view.View view, int position, long id)
  bool performItemClick(view_.View view, int position, int id) =>
      jniAccessors.callMethodWithArgs(reference, _id_performItemClick,
          jni.JniType.booleanType, [view.reference, position, id]).boolean;

  static final _id_getChoiceMode =
      jniAccessors.getMethodIDOf(_classRef, "getChoiceMode", "()I");

  /// from: public int getChoiceMode()
  ///
  /// @see \#setChoiceMode(int)
  ///@return The current choice mode
  int getChoiceMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getChoiceMode, jni.JniType.intType, []).integer;

  static final _id_setChoiceMode =
      jniAccessors.getMethodIDOf(_classRef, "setChoiceMode", "(I)V");

  /// from: public void setChoiceMode(int choiceMode)
  ///
  /// Defines the choice behavior for the List. By default, Lists do not have any choice behavior
  /// (\#CHOICE_MODE_NONE). By setting the choiceMode to \#CHOICE_MODE_SINGLE, the
  /// List allows up to one item to  be in a chosen state. By setting the choiceMode to
  /// \#CHOICE_MODE_MULTIPLE, the list allows any number of items to be chosen.
  ///@param choiceMode One of \#CHOICE_MODE_NONE, \#CHOICE_MODE_SINGLE, or
  /// \#CHOICE_MODE_MULTIPLE
  void setChoiceMode(int choiceMode) => jniAccessors.callMethodWithArgs(
      reference, _id_setChoiceMode, jni.JniType.voidType, [choiceMode]).check();

  static final _id_setMultiChoiceModeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setMultiChoiceModeListener",
      "(Landroid/widget/AbsListView\$MultiChoiceModeListener;)V");

  /// from: public void setMultiChoiceModeListener(android.widget.AbsListView.MultiChoiceModeListener listener)
  ///
  /// Set a MultiChoiceModeListener that will manage the lifecycle of the
  /// selection ActionMode. Only used when the choice mode is set to
  /// \#CHOICE_MODE_MULTIPLE_MODAL.
  ///@param listener Listener that will manage the selection mode
  ///@see \#setChoiceMode(int)
  void setMultiChoiceModeListener(
          AbsListView_MultiChoiceModeListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMultiChoiceModeListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setFastScrollEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setFastScrollEnabled", "(Z)V");

  /// from: public void setFastScrollEnabled(boolean enabled)
  ///
  /// Specifies whether fast scrolling is enabled or disabled.
  ///
  /// When fast scrolling is enabled, the user can quickly scroll through lists
  /// by dragging the fast scroll thumb.
  ///
  /// If the adapter backing this list implements SectionIndexer, the
  /// fast scroller will display section header previews as the user scrolls.
  /// Additionally, the user will be able to quickly jump between sections by
  /// tapping along the length of the scroll bar.
  ///@see SectionIndexer
  ///@see \#isFastScrollEnabled()
  ///@param enabled true to enable fast scrolling, false otherwise
  void setFastScrollEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFastScrollEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_setFastScrollStyle =
      jniAccessors.getMethodIDOf(_classRef, "setFastScrollStyle", "(I)V");

  /// from: public void setFastScrollStyle(int styleResId)
  ///
  /// Specifies the style of the fast scroller decorations.
  ///@param styleResId style resource containing fast scroller properties
  ///@see android.R.styleable\#FastScroll
  void setFastScrollStyle(int styleResId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFastScrollStyle,
      jni.JniType.voidType,
      [styleResId]).check();

  static final _id_setFastScrollAlwaysVisible = jniAccessors.getMethodIDOf(
      _classRef, "setFastScrollAlwaysVisible", "(Z)V");

  /// from: public void setFastScrollAlwaysVisible(boolean alwaysShow)
  ///
  /// Set whether or not the fast scroller should always be shown in place of
  /// the standard scroll bars. This will enable fast scrolling if it is not
  /// already enabled.
  ///
  /// Fast scrollers shown in this way will not fade out and will be a
  /// permanent fixture within the list. This is best combined with an inset
  /// scroll bar style to ensure the scroll bar does not overlap content.
  ///@param alwaysShow true if the fast scroller should always be displayed,
  ///            false otherwise
  ///@see \#setScrollBarStyle(int)
  ///@see \#setFastScrollEnabled(boolean)
  void setFastScrollAlwaysVisible(bool alwaysShow) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFastScrollAlwaysVisible,
          jni.JniType.voidType, [alwaysShow]).check();

  static final _id_isFastScrollAlwaysVisible =
      jniAccessors.getMethodIDOf(_classRef, "isFastScrollAlwaysVisible", "()Z");

  /// from: public boolean isFastScrollAlwaysVisible()
  ///
  /// Returns true if the fast scroller is set to always show on this view.
  ///@return true if the fast scroller will always show
  ///@see \#setFastScrollAlwaysVisible(boolean)
  bool isFastScrollAlwaysVisible() => jniAccessors.callMethodWithArgs(reference,
      _id_isFastScrollAlwaysVisible, jni.JniType.booleanType, []).boolean;

  static final _id_getVerticalScrollbarWidth1 =
      jniAccessors.getMethodIDOf(_classRef, "getVerticalScrollbarWidth", "()I");

  /// from: public int getVerticalScrollbarWidth()
  int getVerticalScrollbarWidth1() => jniAccessors.callMethodWithArgs(reference,
      _id_getVerticalScrollbarWidth1, jni.JniType.intType, []).integer;

  static final _id_isFastScrollEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isFastScrollEnabled", "()Z");

  /// from: public boolean isFastScrollEnabled()
  ///
  /// Returns true if the fast scroller is enabled.
  ///@see \#setFastScrollEnabled(boolean)
  ///@return true if fast scroll is enabled, false otherwise
  bool isFastScrollEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isFastScrollEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setVerticalScrollbarPosition1 = jniAccessors.getMethodIDOf(
      _classRef, "setVerticalScrollbarPosition", "(I)V");

  /// from: public void setVerticalScrollbarPosition(int position)
  void setVerticalScrollbarPosition1(int position) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVerticalScrollbarPosition1,
          jni.JniType.voidType,
          [position]).check();

  static final _id_setScrollBarStyle1 =
      jniAccessors.getMethodIDOf(_classRef, "setScrollBarStyle", "(I)V");

  /// from: public void setScrollBarStyle(int style)
  void setScrollBarStyle1(int style) => jniAccessors.callMethodWithArgs(
      reference, _id_setScrollBarStyle1, jni.JniType.voidType, [style]).check();

  static final _id_setSmoothScrollbarEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setSmoothScrollbarEnabled", "(Z)V");

  /// from: public void setSmoothScrollbarEnabled(boolean enabled)
  ///
  /// When smooth scrollbar is enabled, the position and size of the scrollbar thumb
  /// is computed based on the number of visible pixels in the visible items. This
  /// however assumes that all list items have the same height. If you use a list in
  /// which items have different heights, the scrollbar will change appearance as the
  /// user scrolls through the list. To avoid this issue, you need to disable this
  /// property.
  ///
  /// When smooth scrollbar is disabled, the position and size of the scrollbar thumb
  /// is based solely on the number of items in the adapter and the position of the
  /// visible items inside the adapter. This provides a stable scrollbar as the user
  /// navigates through a list of items with varying heights.
  ///@param enabled Whether or not to enable smooth scrollbar.
  ///@see \#setSmoothScrollbarEnabled(boolean)
  ///@attr ref android.R.styleable\#AbsListView_smoothScrollbar
  void setSmoothScrollbarEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSmoothScrollbarEnabled,
          jni.JniType.voidType, [enabled]).check();

  static final _id_isSmoothScrollbarEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isSmoothScrollbarEnabled", "()Z");

  /// from: public boolean isSmoothScrollbarEnabled()
  ///
  /// Returns the current state of the fast scroll feature.
  ///@return True if smooth scrollbar is enabled is enabled, false otherwise.
  ///@see \#setSmoothScrollbarEnabled(boolean)
  bool isSmoothScrollbarEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isSmoothScrollbarEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setOnScrollListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnScrollListener",
      "(Landroid/widget/AbsListView\$OnScrollListener;)V");

  /// from: public void setOnScrollListener(android.widget.AbsListView.OnScrollListener l)
  ///
  /// Set the listener that will receive notifications every time the list scrolls.
  ///@param l the scroll listener
  void setOnScrollListener(AbsListView_OnScrollListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnScrollListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_sendAccessibilityEventUnchecked1 =
      jniAccessors.getMethodIDOf(_classRef, "sendAccessibilityEventUnchecked",
          "(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent event)
  ///
  /// @hide
  void sendAccessibilityEventUnchecked1(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendAccessibilityEventUnchecked1,
          jni.JniType.voidType,
          [event.reference]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_isScrollingCacheEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isScrollingCacheEnabled", "()Z");

  /// from: public boolean isScrollingCacheEnabled()
  ///
  /// Indicates whether the children's drawing cache is used during a scroll.
  /// By default, the drawing cache is enabled but this will consume more memory.
  ///@return true if the scrolling cache is enabled, false otherwise
  ///@see \#setScrollingCacheEnabled(boolean)
  ///@see View\#setDrawingCacheEnabled(boolean)
  bool isScrollingCacheEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isScrollingCacheEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setScrollingCacheEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setScrollingCacheEnabled", "(Z)V");

  /// from: public void setScrollingCacheEnabled(boolean enabled)
  ///
  /// Enables or disables the children's drawing cache during a scroll.
  /// By default, the drawing cache is enabled but this will use more memory.
  ///
  /// When the scrolling cache is enabled, the caches are kept after the
  /// first scrolling. You can manually clear the cache by calling
  /// android.view.ViewGroup\#setChildrenDrawingCacheEnabled(boolean).
  ///@param enabled true to enable the scroll cache, false otherwise
  ///@see \#isScrollingCacheEnabled()
  ///@see View\#setDrawingCacheEnabled(boolean)
  void setScrollingCacheEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScrollingCacheEnabled,
          jni.JniType.voidType, [enabled]).check();

  static final _id_setTextFilterEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setTextFilterEnabled", "(Z)V");

  /// from: public void setTextFilterEnabled(boolean textFilterEnabled)
  ///
  /// Enables or disables the type filter window. If enabled, typing when
  /// this view has focus will filter the children to match the users input.
  /// Note that the Adapter used by this view must implement the
  /// Filterable interface.
  ///@param textFilterEnabled true to enable type filtering, false otherwise
  ///@see Filterable
  void setTextFilterEnabled(bool textFilterEnabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextFilterEnabled,
          jni.JniType.voidType, [textFilterEnabled]).check();

  static final _id_isTextFilterEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isTextFilterEnabled", "()Z");

  /// from: public boolean isTextFilterEnabled()
  ///
  /// Indicates whether type filtering is enabled for this view
  ///@return true if type filtering is enabled, false otherwise
  ///@see \#setTextFilterEnabled(boolean)
  ///@see Filterable
  bool isTextFilterEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isTextFilterEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getFocusedRect1 = jniAccessors.getMethodIDOf(
      _classRef, "getFocusedRect", "(Landroid/graphics/Rect;)V");

  /// from: public void getFocusedRect(android.graphics.Rect r)
  void getFocusedRect1(rect_.Rect r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getFocusedRect1,
      jni.JniType.voidType,
      [r.reference]).check();

  static final _id_isStackFromBottom =
      jniAccessors.getMethodIDOf(_classRef, "isStackFromBottom", "()Z");

  /// from: public boolean isStackFromBottom()
  ///
  /// Indicates whether the content of this view is pinned to, or stacked from,
  /// the bottom edge.
  ///@return true if the content is stacked from the bottom edge, false otherwise
  bool isStackFromBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_isStackFromBottom, jni.JniType.booleanType, []).boolean;

  static final _id_setStackFromBottom =
      jniAccessors.getMethodIDOf(_classRef, "setStackFromBottom", "(Z)V");

  /// from: public void setStackFromBottom(boolean stackFromBottom)
  ///
  /// When stack from bottom is set to true, the list fills its content starting from
  /// the bottom of the view.
  ///@param stackFromBottom true to pin the view's content to the bottom edge,
  ///        false to pin the view's content to the top edge
  void setStackFromBottom(bool stackFromBottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStackFromBottom,
          jni.JniType.voidType, [stackFromBottom]).check();

  static final _id_onSaveInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  parcelable_.Parcelable onSaveInstanceState1() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState1, jni.JniType.objectType, []).object);

  static final _id_onRestoreInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: public void onRestoreInstanceState(android.os.Parcelable state)
  void onRestoreInstanceState1(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState1,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_setFilterText = jniAccessors.getMethodIDOf(
      _classRef, "setFilterText", "(Ljava/lang/String;)V");

  /// from: public void setFilterText(java.lang.String filterText)
  ///
  /// Sets the initial value for the text filter.
  ///@param filterText The text to use for the filter.
  ///@see \#setTextFilterEnabled
  void setFilterText(jni.JniString filterText) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFilterText,
          jni.JniType.voidType, [filterText.reference]).check();

  static final _id_getTextFilter = jniAccessors.getMethodIDOf(
      _classRef, "getTextFilter", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTextFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list's text filter, if available.
  ///@return the list's text filter or null if filtering isn't enabled
  jni.JniObject getTextFilter() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextFilter, jni.JniType.objectType, []).object);

  static final _id_onFocusChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "onFocusChanged", "(ZILandroid/graphics/Rect;)V");

  /// from: protected void onFocusChanged(boolean gainFocus, int direction, android.graphics.Rect previouslyFocusedRect)
  void onFocusChanged1(
          bool gainFocus, int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFocusChanged1,
          jni.JniType.voidType,
          [gainFocus, direction, previouslyFocusedRect.reference]).check();

  static final _id_requestLayout1 =
      jniAccessors.getMethodIDOf(_classRef, "requestLayout", "()V");

  /// from: public void requestLayout()
  void requestLayout1() => jniAccessors.callMethodWithArgs(
      reference, _id_requestLayout1, jni.JniType.voidType, []).check();

  static final _id_computeVerticalScrollExtent1 = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollExtent", "()I");

  /// from: protected int computeVerticalScrollExtent()
  int computeVerticalScrollExtent1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollExtent1,
      jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollOffset1 = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollOffset", "()I");

  /// from: protected int computeVerticalScrollOffset()
  int computeVerticalScrollOffset1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollOffset1,
      jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollRange1 = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollRange", "()I");

  /// from: protected int computeVerticalScrollRange()
  int computeVerticalScrollRange1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollRange1,
      jni.JniType.intType, []).integer;

  static final _id_getTopFadingEdgeStrength1 =
      jniAccessors.getMethodIDOf(_classRef, "getTopFadingEdgeStrength", "()F");

  /// from: protected float getTopFadingEdgeStrength()
  double getTopFadingEdgeStrength1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getTopFadingEdgeStrength1,
      jni.JniType.floatType, []).float;

  static final _id_getBottomFadingEdgeStrength1 = jniAccessors.getMethodIDOf(
      _classRef, "getBottomFadingEdgeStrength", "()F");

  /// from: protected float getBottomFadingEdgeStrength()
  double getBottomFadingEdgeStrength1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getBottomFadingEdgeStrength1,
      jni.JniType.floatType, []).float;

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int l, int t, int r, int b)
  ///
  /// Subclasses should NOT override this method but
  ///  \#layoutChildren() instead.
  void onLayout(bool changed, int l, int t, int r, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, l, t, r, b]).check();

  static final _id_layoutChildren =
      jniAccessors.getMethodIDOf(_classRef, "layoutChildren", "()V");

  /// from: protected void layoutChildren()
  ///
  /// Subclasses must override this method to layout their children.
  void layoutChildren() => jniAccessors.callMethodWithArgs(
      reference, _id_layoutChildren, jni.JniType.voidType, []).check();

  static final _id_getSelectedView = jniAccessors.getMethodIDOf(
      _classRef, "getSelectedView", "()Landroid/view/View;");

  /// from: public android.view.View getSelectedView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  view_.View getSelectedView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSelectedView, jni.JniType.objectType, []).object);

  static final _id_getListPaddingTop =
      jniAccessors.getMethodIDOf(_classRef, "getListPaddingTop", "()I");

  /// from: public int getListPaddingTop()
  ///
  /// List padding is the maximum of the normal view's padding and the padding of the selector.
  ///@see android.view.View\#getPaddingTop()
  ///@see \#getSelector()
  ///@return The top list padding.
  int getListPaddingTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getListPaddingTop, jni.JniType.intType, []).integer;

  static final _id_getListPaddingBottom =
      jniAccessors.getMethodIDOf(_classRef, "getListPaddingBottom", "()I");

  /// from: public int getListPaddingBottom()
  ///
  /// List padding is the maximum of the normal view's padding and the padding of the selector.
  ///@see android.view.View\#getPaddingBottom()
  ///@see \#getSelector()
  ///@return The bottom list padding.
  int getListPaddingBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getListPaddingBottom, jni.JniType.intType, []).integer;

  static final _id_getListPaddingLeft =
      jniAccessors.getMethodIDOf(_classRef, "getListPaddingLeft", "()I");

  /// from: public int getListPaddingLeft()
  ///
  /// List padding is the maximum of the normal view's padding and the padding of the selector.
  ///@see android.view.View\#getPaddingLeft()
  ///@see \#getSelector()
  ///@return The left list padding.
  int getListPaddingLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getListPaddingLeft, jni.JniType.intType, []).integer;

  static final _id_getListPaddingRight =
      jniAccessors.getMethodIDOf(_classRef, "getListPaddingRight", "()I");

  /// from: public int getListPaddingRight()
  ///
  /// List padding is the maximum of the normal view's padding and the padding of the selector.
  ///@see android.view.View\#getPaddingRight()
  ///@see \#getSelector()
  ///@return The right list padding.
  int getListPaddingRight() => jniAccessors.callMethodWithArgs(
      reference, _id_getListPaddingRight, jni.JniType.intType, []).integer;

  static final _id_onInitializeAccessibilityNodeInfoForItem =
      jniAccessors.getMethodIDOf(
          _classRef,
          "onInitializeAccessibilityNodeInfoForItem",
          "(Landroid/view/View;ILandroid/view/accessibility/AccessibilityNodeInfo;)V");

  /// from: public void onInitializeAccessibilityNodeInfoForItem(android.view.View view, int position, android.view.accessibility.AccessibilityNodeInfo info)
  ///
  /// Initializes an AccessibilityNodeInfo with information about a
  /// particular item in the list.
  ///@param view View representing the list item.
  ///@param position Position of the list item within the adapter.
  ///@param info Node info to populate.
  void onInitializeAccessibilityNodeInfoForItem(view_.View view, int position,
          accessibilitynodeinfo_.AccessibilityNodeInfo info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onInitializeAccessibilityNodeInfoForItem,
          jni.JniType.voidType,
          [view.reference, position, info.reference]).check();

  static final _id_dispatchDraw1 = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw1(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw1,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_isPaddingOffsetRequired1 =
      jniAccessors.getMethodIDOf(_classRef, "isPaddingOffsetRequired", "()Z");

  /// from: protected boolean isPaddingOffsetRequired()
  bool isPaddingOffsetRequired1() => jniAccessors.callMethodWithArgs(reference,
      _id_isPaddingOffsetRequired1, jni.JniType.booleanType, []).boolean;

  static final _id_getLeftPaddingOffset1 =
      jniAccessors.getMethodIDOf(_classRef, "getLeftPaddingOffset", "()I");

  /// from: protected int getLeftPaddingOffset()
  int getLeftPaddingOffset1() => jniAccessors.callMethodWithArgs(
      reference, _id_getLeftPaddingOffset1, jni.JniType.intType, []).integer;

  static final _id_getTopPaddingOffset1 =
      jniAccessors.getMethodIDOf(_classRef, "getTopPaddingOffset", "()I");

  /// from: protected int getTopPaddingOffset()
  int getTopPaddingOffset1() => jniAccessors.callMethodWithArgs(
      reference, _id_getTopPaddingOffset1, jni.JniType.intType, []).integer;

  static final _id_getRightPaddingOffset1 =
      jniAccessors.getMethodIDOf(_classRef, "getRightPaddingOffset", "()I");

  /// from: protected int getRightPaddingOffset()
  int getRightPaddingOffset1() => jniAccessors.callMethodWithArgs(
      reference, _id_getRightPaddingOffset1, jni.JniType.intType, []).integer;

  static final _id_getBottomPaddingOffset1 =
      jniAccessors.getMethodIDOf(_classRef, "getBottomPaddingOffset", "()I");

  /// from: protected int getBottomPaddingOffset()
  int getBottomPaddingOffset1() => jniAccessors.callMethodWithArgs(
      reference, _id_getBottomPaddingOffset1, jni.JniType.intType, []).integer;

  static final _id_onSizeChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onSizeChanged", "(IIII)V");

  /// from: protected void onSizeChanged(int w, int h, int oldw, int oldh)
  void onSizeChanged1(int w, int h, int oldw, int oldh) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSizeChanged1,
          jni.JniType.voidType, [w, h, oldw, oldh]).check();

  static final _id_setDrawSelectorOnTop =
      jniAccessors.getMethodIDOf(_classRef, "setDrawSelectorOnTop", "(Z)V");

  /// from: public void setDrawSelectorOnTop(boolean onTop)
  ///
  /// Controls whether the selection highlight drawable should be drawn on top of the item or
  /// behind it.
  ///@param onTop If true, the selector will be drawn on the item it is highlighting. The default
  ///        is false.
  ///@attr ref android.R.styleable\#AbsListView_drawSelectorOnTop
  void setDrawSelectorOnTop(bool onTop) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDrawSelectorOnTop,
      jni.JniType.voidType,
      [onTop]).check();

  static final _id_setSelector =
      jniAccessors.getMethodIDOf(_classRef, "setSelector", "(I)V");

  /// from: public void setSelector(int resID)
  ///
  /// Set a Drawable that should be used to highlight the currently selected item.
  ///@param resID A Drawable resource to use as the selection highlight.
  ///@attr ref android.R.styleable\#AbsListView_listSelector
  void setSelector(int resID) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelector, jni.JniType.voidType, [resID]).check();

  static final _id_setSelector1 = jniAccessors.getMethodIDOf(
      _classRef, "setSelector", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setSelector(android.graphics.drawable.Drawable sel)
  void setSelector1(drawable_.Drawable sel) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSelector1,
      jni.JniType.voidType,
      [sel.reference]).check();

  static final _id_getSelector = jniAccessors.getMethodIDOf(
      _classRef, "getSelector", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getSelector()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the selector android.graphics.drawable.Drawable that is used to draw the
  /// selection in the list.
  ///@return the drawable used to display the selector
  drawable_.Drawable getSelector() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSelector, jni.JniType.objectType, []).object);

  static final _id_setScrollIndicators2 = jniAccessors.getMethodIDOf(_classRef,
      "setScrollIndicators", "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void setScrollIndicators(android.view.View up, android.view.View down)
  void setScrollIndicators2(view_.View up, view_.View down) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScrollIndicators2,
          jni.JniType.voidType, [up.reference, down.reference]).check();

  static final _id_drawableStateChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "drawableStateChanged", "()V");

  /// from: protected void drawableStateChanged()
  void drawableStateChanged1() => jniAccessors.callMethodWithArgs(
      reference, _id_drawableStateChanged1, jni.JniType.voidType, []).check();

  static final _id_verifyDrawable1 = jniAccessors.getMethodIDOf(
      _classRef, "verifyDrawable", "(Landroid/graphics/drawable/Drawable;)Z");

  /// from: public boolean verifyDrawable(android.graphics.drawable.Drawable dr)
  ///
  /// @param dr This value must never be {@code null}.
  bool verifyDrawable1(drawable_.Drawable dr) =>
      jniAccessors.callMethodWithArgs(reference, _id_verifyDrawable1,
          jni.JniType.booleanType, [dr.reference]).boolean;

  static final _id_jumpDrawablesToCurrentState1 = jniAccessors.getMethodIDOf(
      _classRef, "jumpDrawablesToCurrentState", "()V");

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_jumpDrawablesToCurrentState1,
      jni.JniType.voidType, []).check();

  static final _id_onAttachedToWindow1 =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow1() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow1, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_onWindowFocusChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasWindowFocus)
  void onWindowFocusChanged1(bool hasWindowFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowFocusChanged1,
          jni.JniType.voidType, [hasWindowFocus]).check();

  static final _id_onRtlPropertiesChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onRtlPropertiesChanged", "(I)V");

  /// from: public void onRtlPropertiesChanged(int layoutDirection)
  void onRtlPropertiesChanged1(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRtlPropertiesChanged1,
          jni.JniType.voidType, [layoutDirection]).check();

  static final _id_onCancelPendingInputEvents1 = jniAccessors.getMethodIDOf(
      _classRef, "onCancelPendingInputEvents", "()V");

  /// from: public void onCancelPendingInputEvents()
  void onCancelPendingInputEvents1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCancelPendingInputEvents1,
      jni.JniType.voidType, []).check();

  static final _id_getContextMenuInfo1 = jniAccessors.getMethodIDOf(_classRef,
      "getContextMenuInfo", "()Landroid/view/ContextMenu\$ContextMenuInfo;");

  /// from: protected android.view.ContextMenu.ContextMenuInfo getContextMenuInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  contextmenu_.ContextMenu_ContextMenuInfo getContextMenuInfo1() =>
      contextmenu_.ContextMenu_ContextMenuInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getContextMenuInfo1,
              jni.JniType.objectType, []).object);

  static final _id_showContextMenu2 =
      jniAccessors.getMethodIDOf(_classRef, "showContextMenu", "()Z");

  /// from: public boolean showContextMenu()
  bool showContextMenu2() => jniAccessors.callMethodWithArgs(
      reference, _id_showContextMenu2, jni.JniType.booleanType, []).boolean;

  static final _id_showContextMenu3 =
      jniAccessors.getMethodIDOf(_classRef, "showContextMenu", "(FF)Z");

  /// from: public boolean showContextMenu(float x, float y)
  bool showContextMenu3(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_showContextMenu3, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_showContextMenuForChild2 = jniAccessors.getMethodIDOf(
      _classRef, "showContextMenuForChild", "(Landroid/view/View;)Z");

  /// from: public boolean showContextMenuForChild(android.view.View originalView)
  bool showContextMenuForChild2(view_.View originalView) =>
      jniAccessors.callMethodWithArgs(reference, _id_showContextMenuForChild2,
          jni.JniType.booleanType, [originalView.reference]).boolean;

  static final _id_showContextMenuForChild3 = jniAccessors.getMethodIDOf(
      _classRef, "showContextMenuForChild", "(Landroid/view/View;FF)Z");

  /// from: public boolean showContextMenuForChild(android.view.View originalView, float x, float y)
  bool showContextMenuForChild3(view_.View originalView, double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_showContextMenuForChild3,
          jni.JniType.booleanType, [originalView.reference, x, y]).boolean;

  static final _id_onKeyDown1 = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  bool onKeyDown1(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown1,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyUp1 = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  bool onKeyUp1(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp1,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_dispatchSetPressed1 =
      jniAccessors.getMethodIDOf(_classRef, "dispatchSetPressed", "(Z)V");

  /// from: protected void dispatchSetPressed(boolean pressed)
  void dispatchSetPressed1(bool pressed) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchSetPressed1,
      jni.JniType.voidType,
      [pressed]).check();

  static final _id_dispatchDrawableHotspotChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDrawableHotspotChanged", "(FF)V");

  /// from: public void dispatchDrawableHotspotChanged(float x, float y)
  void dispatchDrawableHotspotChanged1(double x, double y) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchDrawableHotspotChanged1,
          jni.JniType.voidType,
          [x, y]).check();

  static final _id_pointToPosition =
      jniAccessors.getMethodIDOf(_classRef, "pointToPosition", "(II)I");

  /// from: public int pointToPosition(int x, int y)
  ///
  /// Maps a point to a position in the list.
  ///@param x X in local coordinate
  ///@param y Y in local coordinate
  ///@return The position of the item which contains the specified point, or
  ///         \#INVALID_POSITION if the point does not intersect an item.
  int pointToPosition(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_pointToPosition, jni.JniType.intType, [x, y]).integer;

  static final _id_pointToRowId =
      jniAccessors.getMethodIDOf(_classRef, "pointToRowId", "(II)J");

  /// from: public long pointToRowId(int x, int y)
  ///
  /// Maps a point to a the rowId of the item which intersects that point.
  ///@param x X in local coordinate
  ///@param y Y in local coordinate
  ///@return The rowId of the item which contains the specified point, or \#INVALID_ROW_ID
  ///         if the point does not intersect an item.
  int pointToRowId(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_pointToRowId, jni.JniType.longType, [x, y]).long;

  static final _id_onTouchModeChanged =
      jniAccessors.getMethodIDOf(_classRef, "onTouchModeChanged", "(Z)V");

  /// from: public void onTouchModeChanged(boolean isInTouchMode)
  void onTouchModeChanged(bool isInTouchMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchModeChanged,
          jni.JniType.voidType, [isInTouchMode]).check();

  static final _id_onTouchEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent ev)
  bool onTouchEvent1(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent1,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_onOverScrolled1 =
      jniAccessors.getMethodIDOf(_classRef, "onOverScrolled", "(IIZZ)V");

  /// from: protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)
  void onOverScrolled1(
          int scrollX, int scrollY, bool clampedX, bool clampedY) =>
      jniAccessors.callMethodWithArgs(reference, _id_onOverScrolled1,
          jni.JniType.voidType, [scrollX, scrollY, clampedX, clampedY]).check();

  static final _id_onGenericMotionEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  bool onGenericMotionEvent1(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_fling =
      jniAccessors.getMethodIDOf(_classRef, "fling", "(I)V");

  /// from: public void fling(int velocityY)
  ///
  /// Initiate a fling with the given velocity.
  ///
  /// Applications can use this method to manually initiate a fling as if the user
  /// initiated it via touch interaction.
  ///
  ///@param velocityY Vertical velocity in pixels per second. Note that this is velocity of
  ///                  content, not velocity of a touch that initiated the fling.
  void fling(int velocityY) => jniAccessors.callMethodWithArgs(
      reference, _id_fling, jni.JniType.voidType, [velocityY]).check();

  static final _id_onStartNestedScroll1 = jniAccessors.getMethodIDOf(_classRef,
      "onStartNestedScroll", "(Landroid/view/View;Landroid/view/View;I)Z");

  /// from: public boolean onStartNestedScroll(android.view.View child, android.view.View target, int nestedScrollAxes)
  bool onStartNestedScroll1(
          view_.View child, view_.View target, int nestedScrollAxes) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onStartNestedScroll1,
          jni.JniType.booleanType,
          [child.reference, target.reference, nestedScrollAxes]).boolean;

  static final _id_onNestedScrollAccepted1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onNestedScrollAccepted",
      "(Landroid/view/View;Landroid/view/View;I)V");

  /// from: public void onNestedScrollAccepted(android.view.View child, android.view.View target, int axes)
  void onNestedScrollAccepted1(view_.View child, view_.View target, int axes) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedScrollAccepted1,
          jni.JniType.voidType,
          [child.reference, target.reference, axes]).check();

  static final _id_onNestedScroll1 = jniAccessors.getMethodIDOf(
      _classRef, "onNestedScroll", "(Landroid/view/View;IIII)V");

  /// from: public void onNestedScroll(android.view.View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)
  void onNestedScroll1(view_.View target, int dxConsumed, int dyConsumed,
          int dxUnconsumed, int dyUnconsumed) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onNestedScroll1, jni.JniType.voidType, [
        target.reference,
        dxConsumed,
        dyConsumed,
        dxUnconsumed,
        dyUnconsumed
      ]).check();

  static final _id_onNestedFling1 = jniAccessors.getMethodIDOf(
      _classRef, "onNestedFling", "(Landroid/view/View;FFZ)Z");

  /// from: public boolean onNestedFling(android.view.View target, float velocityX, float velocityY, boolean consumed)
  bool onNestedFling1(view_.View target, double velocityX, double velocityY,
          bool consumed) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedFling1,
          jni.JniType.booleanType,
          [target.reference, velocityX, velocityY, consumed]).boolean;

  static final _id_draw1 = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw1(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw1, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_requestDisallowInterceptTouchEvent1 = jniAccessors
      .getMethodIDOf(_classRef, "requestDisallowInterceptTouchEvent", "(Z)V");

  /// from: public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)
  void requestDisallowInterceptTouchEvent1(bool disallowIntercept) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestDisallowInterceptTouchEvent1,
          jni.JniType.voidType,
          [disallowIntercept]).check();

  static final _id_onInterceptHoverEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onInterceptHoverEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onInterceptHoverEvent(android.view.MotionEvent event)
  bool onInterceptHoverEvent1(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onInterceptHoverEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onResolvePointerIcon1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onResolvePointerIcon",
      "(Landroid/view/MotionEvent;I)Landroid/view/PointerIcon;");

  /// from: public android.view.PointerIcon onResolvePointerIcon(android.view.MotionEvent event, int pointerIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  pointericon_.PointerIcon onResolvePointerIcon1(
          motionevent_.MotionEvent event, int pointerIndex) =>
      pointericon_.PointerIcon.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onResolvePointerIcon1,
          jni.JniType.objectType,
          [event.reference, pointerIndex]).object);

  static final _id_onInterceptTouchEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onInterceptTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onInterceptTouchEvent(android.view.MotionEvent ev)
  bool onInterceptTouchEvent1(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onInterceptTouchEvent1,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_addTouchables1 = jniAccessors.getMethodIDOf(
      _classRef, "addTouchables", "(Ljava/util/ArrayList;)V");

  /// from: public void addTouchables(java.util.ArrayList<android.view.View> views)
  ///
  /// {@inheritDoc}
  void addTouchables1(jni.JniObject views) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addTouchables1,
      jni.JniType.voidType,
      [views.reference]).check();

  static final _id_setFriction =
      jniAccessors.getMethodIDOf(_classRef, "setFriction", "(F)V");

  /// from: public void setFriction(float friction)
  ///
  /// The amount of friction applied to flings. The default value
  /// is ViewConfiguration\#getScrollFriction.
  void setFriction(double friction) => jniAccessors.callMethodWithArgs(
      reference, _id_setFriction, jni.JniType.voidType, [friction]).check();

  static final _id_setVelocityScale =
      jniAccessors.getMethodIDOf(_classRef, "setVelocityScale", "(F)V");

  /// from: public void setVelocityScale(float scale)
  ///
  /// Sets a scale factor for the fling velocity. The initial scale
  /// factor is 1.0.
  ///@param scale The scale factor to multiply the velocity by.
  void setVelocityScale(double scale) => jniAccessors.callMethodWithArgs(
      reference, _id_setVelocityScale, jni.JniType.voidType, [scale]).check();

  static final _id_smoothScrollToPosition =
      jniAccessors.getMethodIDOf(_classRef, "smoothScrollToPosition", "(I)V");

  /// from: public void smoothScrollToPosition(int position)
  ///
  /// Smoothly scroll to the specified adapter position. The view will
  /// scroll such that the indicated position is displayed.
  ///@param position Scroll to this adapter position.
  void smoothScrollToPosition(int position) => jniAccessors.callMethodWithArgs(
      reference,
      _id_smoothScrollToPosition,
      jni.JniType.voidType,
      [position]).check();

  static final _id_smoothScrollToPositionFromTop = jniAccessors.getMethodIDOf(
      _classRef, "smoothScrollToPositionFromTop", "(III)V");

  /// from: public void smoothScrollToPositionFromTop(int position, int offset, int duration)
  ///
  /// Smoothly scroll to the specified adapter position. The view will scroll
  /// such that the indicated position is displayed <code>offset</code> pixels below
  /// the top edge of the view. If this is impossible, (e.g. the offset would scroll
  /// the first or last item beyond the boundaries of the list) it will get as close
  /// as possible. The scroll will take <code>duration</code> milliseconds to complete.
  ///@param position Position to scroll to
  ///@param offset Desired distance in pixels of <code>position</code> from the top
  ///               of the view when scrolling is finished
  ///@param duration Number of milliseconds to use for the scroll
  void smoothScrollToPositionFromTop(int position, int offset, int duration) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_smoothScrollToPositionFromTop,
          jni.JniType.voidType,
          [position, offset, duration]).check();

  static final _id_smoothScrollToPositionFromTop1 = jniAccessors.getMethodIDOf(
      _classRef, "smoothScrollToPositionFromTop", "(II)V");

  /// from: public void smoothScrollToPositionFromTop(int position, int offset)
  ///
  /// Smoothly scroll to the specified adapter position. The view will scroll
  /// such that the indicated position is displayed <code>offset</code> pixels below
  /// the top edge of the view. If this is impossible, (e.g. the offset would scroll
  /// the first or last item beyond the boundaries of the list) it will get as close
  /// as possible.
  ///@param position Position to scroll to
  ///@param offset Desired distance in pixels of <code>position</code> from the top
  ///               of the view when scrolling is finished
  void smoothScrollToPositionFromTop1(int position, int offset) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_smoothScrollToPositionFromTop1,
          jni.JniType.voidType,
          [position, offset]).check();

  static final _id_smoothScrollToPosition1 =
      jniAccessors.getMethodIDOf(_classRef, "smoothScrollToPosition", "(II)V");

  /// from: public void smoothScrollToPosition(int position, int boundPosition)
  ///
  /// Smoothly scroll to the specified adapter position. The view will
  /// scroll such that the indicated position is displayed, but it will
  /// stop early if scrolling further would scroll boundPosition out of
  /// view.
  ///@param position Scroll to this adapter position.
  ///@param boundPosition Do not scroll if it would move this adapter
  ///          position out of view.
  void smoothScrollToPosition1(int position, int boundPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_smoothScrollToPosition1,
          jni.JniType.voidType, [position, boundPosition]).check();

  static final _id_smoothScrollBy =
      jniAccessors.getMethodIDOf(_classRef, "smoothScrollBy", "(II)V");

  /// from: public void smoothScrollBy(int distance, int duration)
  ///
  /// Smoothly scroll by distance pixels over duration milliseconds.
  ///@param distance Distance to scroll in pixels.
  ///@param duration Duration of the scroll animation in milliseconds.
  void smoothScrollBy(int distance, int duration) =>
      jniAccessors.callMethodWithArgs(reference, _id_smoothScrollBy,
          jni.JniType.voidType, [distance, duration]).check();

  static final _id_scrollListBy =
      jniAccessors.getMethodIDOf(_classRef, "scrollListBy", "(I)V");

  /// from: public void scrollListBy(int y)
  ///
  /// Scrolls the list items within the view by a specified number of pixels.
  ///
  /// The actual amount of scroll is capped by the list content viewport height
  /// which is the list height minus top and bottom paddings minus one pixel.
  ///
  ///@param y the amount of pixels to scroll by vertically
  ///@see \#canScrollList(int)
  void scrollListBy(int y) => jniAccessors.callMethodWithArgs(
      reference, _id_scrollListBy, jni.JniType.voidType, [y]).check();

  static final _id_canScrollList =
      jniAccessors.getMethodIDOf(_classRef, "canScrollList", "(I)Z");

  /// from: public boolean canScrollList(int direction)
  ///
  /// Check if the items in the list can be scrolled in a certain direction.
  ///@param direction Negative to check scrolling up, positive to check
  ///            scrolling down.
  ///@return true if the list can be scrolled in the specified direction,
  ///         false otherwise.
  ///@see \#scrollListBy(int)
  bool canScrollList(int direction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_canScrollList,
      jni.JniType.booleanType,
      [direction]).boolean;

  static final _id_invalidateViews =
      jniAccessors.getMethodIDOf(_classRef, "invalidateViews", "()V");

  /// from: public void invalidateViews()
  ///
  /// Causes all the views to be rebuilt and redrawn.
  void invalidateViews() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidateViews, jni.JniType.voidType, []).check();

  static final _id_handleDataChanged =
      jniAccessors.getMethodIDOf(_classRef, "handleDataChanged", "()V");

  /// from: protected void handleDataChanged()
  void handleDataChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_handleDataChanged, jni.JniType.voidType, []).check();

  static final _id_onDisplayHint1 =
      jniAccessors.getMethodIDOf(_classRef, "onDisplayHint", "(I)V");

  /// from: protected void onDisplayHint(int hint)
  void onDisplayHint1(int hint) => jniAccessors.callMethodWithArgs(
      reference, _id_onDisplayHint1, jni.JniType.voidType, [hint]).check();

  static final _id_isInFilterMode =
      jniAccessors.getMethodIDOf(_classRef, "isInFilterMode", "()Z");

  /// from: protected boolean isInFilterMode()
  bool isInFilterMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isInFilterMode, jni.JniType.booleanType, []).boolean;

  static final _id_onCreateInputConnection1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateInputConnection",
      "(Landroid/view/inputmethod/EditorInfo;)Landroid/view/inputmethod/InputConnection;");

  /// from: public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo outAttrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an InputConnection for editing of the filter text.
  inputconnection_.InputConnection onCreateInputConnection1(
          editorinfo_.EditorInfo outAttrs) =>
      inputconnection_.InputConnection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateInputConnection1,
          jni.JniType.objectType,
          [outAttrs.reference]).object);

  static final _id_checkInputConnectionProxy1 = jniAccessors.getMethodIDOf(
      _classRef, "checkInputConnectionProxy", "(Landroid/view/View;)Z");

  /// from: public boolean checkInputConnectionProxy(android.view.View view)
  ///
  /// For filtering we proxy an input connection to an internal text editor,
  /// and this allows the proxying to happen.
  bool checkInputConnectionProxy1(view_.View view) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkInputConnectionProxy1,
          jni.JniType.booleanType, [view.reference]).boolean;

  static final _id_clearTextFilter =
      jniAccessors.getMethodIDOf(_classRef, "clearTextFilter", "()V");

  /// from: public void clearTextFilter()
  ///
  /// Clear the text filter.
  void clearTextFilter() => jniAccessors.callMethodWithArgs(
      reference, _id_clearTextFilter, jni.JniType.voidType, []).check();

  static final _id_hasTextFilter =
      jniAccessors.getMethodIDOf(_classRef, "hasTextFilter", "()Z");

  /// from: public boolean hasTextFilter()
  ///
  /// Returns if the ListView currently has a text filter.
  bool hasTextFilter() => jniAccessors.callMethodWithArgs(
      reference, _id_hasTextFilter, jni.JniType.booleanType, []).boolean;

  static final _id_onGlobalLayout =
      jniAccessors.getMethodIDOf(_classRef, "onGlobalLayout", "()V");

  /// from: public void onGlobalLayout()
  void onGlobalLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_onGlobalLayout, jni.JniType.voidType, []).check();

  static final _id_beforeTextChanged = jniAccessors.getMethodIDOf(
      _classRef, "beforeTextChanged", "(Ljava/lang/CharSequence;III)V");

  /// from: public void beforeTextChanged(java.lang.CharSequence s, int start, int count, int after)
  ///
  /// For our text watcher that is associated with the text filter.  Does
  /// nothing.
  void beforeTextChanged(jni.JniObject s, int start, int count, int after) =>
      jniAccessors.callMethodWithArgs(reference, _id_beforeTextChanged,
          jni.JniType.voidType, [s.reference, start, count, after]).check();

  static final _id_onTextChanged = jniAccessors.getMethodIDOf(
      _classRef, "onTextChanged", "(Ljava/lang/CharSequence;III)V");

  /// from: public void onTextChanged(java.lang.CharSequence s, int start, int before, int count)
  ///
  /// For our text watcher that is associated with the text filter. Performs
  /// the actual filtering as the text changes, and takes care of hiding and
  /// showing the popup displaying the currently entered filter text.
  void onTextChanged(jni.JniObject s, int start, int before, int count) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTextChanged,
          jni.JniType.voidType, [s.reference, start, before, count]).check();

  static final _id_afterTextChanged = jniAccessors.getMethodIDOf(
      _classRef, "afterTextChanged", "(Landroid/text/Editable;)V");

  /// from: public void afterTextChanged(android.text.Editable s)
  ///
  /// For our text watcher that is associated with the text filter.  Does
  /// nothing.
  void afterTextChanged(editable_.Editable s) =>
      jniAccessors.callMethodWithArgs(reference, _id_afterTextChanged,
          jni.JniType.voidType, [s.reference]).check();

  static final _id_onFilterComplete =
      jniAccessors.getMethodIDOf(_classRef, "onFilterComplete", "(I)V");

  /// from: public void onFilterComplete(int count)
  void onFilterComplete(int count) => jniAccessors.callMethodWithArgs(
      reference, _id_onFilterComplete, jni.JniType.voidType, [count]).check();

  static final _id_generateDefaultLayoutParams1 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateDefaultLayoutParams",
      "()Landroid/view/ViewGroup\$LayoutParams;");

  /// from: protected android.view.ViewGroup.LayoutParams generateDefaultLayoutParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  viewgroup_.ViewGroup_LayoutParams generateDefaultLayoutParams1() =>
      viewgroup_.ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateDefaultLayoutParams1,
          jni.JniType.objectType, []).object);

  static final _id_generateLayoutParams2 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/view/ViewGroup\$LayoutParams;)Landroid/view/ViewGroup\$LayoutParams;");

  /// from: protected android.view.ViewGroup.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams p)
  /// The returned object must be deleted after use, by calling the `delete` method.
  viewgroup_.ViewGroup_LayoutParams generateLayoutParams2(
          viewgroup_.ViewGroup_LayoutParams p) =>
      viewgroup_.ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams2,
          jni.JniType.objectType,
          [p.reference]).object);

  static final _id_generateLayoutParams3 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/util/AttributeSet;)Landroid/widget/AbsListView\$LayoutParams;");

  /// from: public android.widget.AbsListView.LayoutParams generateLayoutParams(android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView_LayoutParams generateLayoutParams3(
          attributeset_.AttributeSet attrs) =>
      AbsListView_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams3,
          jni.JniType.objectType,
          [attrs.reference]).object);

  static final _id_checkLayoutParams1 = jniAccessors.getMethodIDOf(_classRef,
      "checkLayoutParams", "(Landroid/view/ViewGroup\$LayoutParams;)Z");

  /// from: protected boolean checkLayoutParams(android.view.ViewGroup.LayoutParams p)
  bool checkLayoutParams1(viewgroup_.ViewGroup_LayoutParams p) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkLayoutParams1,
          jni.JniType.booleanType, [p.reference]).boolean;

  static final _id_setTranscriptMode =
      jniAccessors.getMethodIDOf(_classRef, "setTranscriptMode", "(I)V");

  /// from: public void setTranscriptMode(int mode)
  ///
  /// Puts the list or grid into transcript mode. In this mode the list or grid will always scroll
  /// to the bottom to show new items.
  ///@param mode the transcript mode to set
  ///@see \#TRANSCRIPT_MODE_DISABLED
  ///@see \#TRANSCRIPT_MODE_NORMAL
  ///@see \#TRANSCRIPT_MODE_ALWAYS_SCROLL
  void setTranscriptMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setTranscriptMode, jni.JniType.voidType, [mode]).check();

  static final _id_getTranscriptMode =
      jniAccessors.getMethodIDOf(_classRef, "getTranscriptMode", "()I");

  /// from: public int getTranscriptMode()
  ///
  /// Returns the current transcript mode.
  ///@return \#TRANSCRIPT_MODE_DISABLED, \#TRANSCRIPT_MODE_NORMAL or
  ///         \#TRANSCRIPT_MODE_ALWAYS_SCROLL
  int getTranscriptMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getTranscriptMode, jni.JniType.intType, []).integer;

  static final _id_getSolidColor1 =
      jniAccessors.getMethodIDOf(_classRef, "getSolidColor", "()I");

  /// from: public int getSolidColor()
  int getSolidColor1() => jniAccessors.callMethodWithArgs(
      reference, _id_getSolidColor1, jni.JniType.intType, []).integer;

  static final _id_setCacheColorHint =
      jniAccessors.getMethodIDOf(_classRef, "setCacheColorHint", "(I)V");

  /// from: public void setCacheColorHint(int color)
  ///
  /// When set to a non-zero value, the cache color hint indicates that this list is always drawn
  /// on top of a solid, single-color, opaque background.
  ///
  /// Zero means that what's behind this object is translucent (non solid) or is not made of a
  /// single color. This hint will not affect any existing background drawable set on this view (
  /// typically set via \#setBackgroundDrawable(Drawable)).
  ///@param color The background color
  void setCacheColorHint(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setCacheColorHint, jni.JniType.voidType, [color]).check();

  static final _id_getCacheColorHint =
      jniAccessors.getMethodIDOf(_classRef, "getCacheColorHint", "()I");

  /// from: public int getCacheColorHint()
  ///
  /// When set to a non-zero value, the cache color hint indicates that this list is always drawn
  /// on top of a solid, single-color, opaque background
  ///@return The cache color hint
  int getCacheColorHint() => jniAccessors.callMethodWithArgs(
      reference, _id_getCacheColorHint, jni.JniType.intType, []).integer;

  static final _id_reclaimViews = jniAccessors.getMethodIDOf(
      _classRef, "reclaimViews", "(Ljava/util/List;)V");

  /// from: public void reclaimViews(java.util.List<android.view.View> views)
  ///
  /// Move all views (excluding headers and footers) held by this AbsListView into the supplied
  /// List. This includes views displayed on the screen as well as views stored in AbsListView's
  /// internal view recycler.
  ///@param views A list into which to put the reclaimed views
  void reclaimViews(jni.JniObject views) => jniAccessors.callMethodWithArgs(
      reference,
      _id_reclaimViews,
      jni.JniType.voidType,
      [views.reference]).check();

  static final _id_setRemoteViewsAdapter = jniAccessors.getMethodIDOf(
      _classRef, "setRemoteViewsAdapter", "(Landroid/content/Intent;)V");

  /// from: public void setRemoteViewsAdapter(android.content.Intent intent)
  ///
  /// Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
  /// through the specified intent.
  ///@param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
  void setRemoteViewsAdapter(intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRemoteViewsAdapter,
          jni.JniType.voidType, [intent.reference]).check();

  static final _id_deferNotifyDataSetChanged =
      jniAccessors.getMethodIDOf(_classRef, "deferNotifyDataSetChanged", "()V");

  /// from: public void deferNotifyDataSetChanged()
  ///
  /// This defers a notifyDataSetChanged on the pending RemoteViewsAdapter if it has not
  /// connected yet.
  void deferNotifyDataSetChanged() => jniAccessors.callMethodWithArgs(reference,
      _id_deferNotifyDataSetChanged, jni.JniType.voidType, []).check();

  static final _id_onRemoteAdapterConnected =
      jniAccessors.getMethodIDOf(_classRef, "onRemoteAdapterConnected", "()Z");

  /// from: public boolean onRemoteAdapterConnected()
  ///
  /// Called back when the adapter connects to the RemoteViewsService.
  bool onRemoteAdapterConnected() => jniAccessors.callMethodWithArgs(reference,
      _id_onRemoteAdapterConnected, jni.JniType.booleanType, []).boolean;

  static final _id_onRemoteAdapterDisconnected = jniAccessors.getMethodIDOf(
      _classRef, "onRemoteAdapterDisconnected", "()V");

  /// from: public void onRemoteAdapterDisconnected()
  ///
  /// Called back when the adapter disconnects from the RemoteViewsService.
  void onRemoteAdapterDisconnected() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRemoteAdapterDisconnected,
      jni.JniType.voidType, []).check();

  static final _id_setRecyclerListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setRecyclerListener",
      "(Landroid/widget/AbsListView\$RecyclerListener;)V");

  /// from: public void setRecyclerListener(android.widget.AbsListView.RecyclerListener listener)
  ///
  /// Sets the recycler listener to be notified whenever a View is set aside in
  /// the recycler for later reuse. This listener can be used to free resources
  /// associated to the View.
  ///@param listener The recycler listener to be notified of views set aside
  ///        in the recycler.
  ///@see android.widget.AbsListView.RecycleBin
  ///@see android.widget.AbsListView.RecyclerListener
  void setRecyclerListener(AbsListView_RecyclerListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRecyclerListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setSelectionFromTop =
      jniAccessors.getMethodIDOf(_classRef, "setSelectionFromTop", "(II)V");

  /// from: public void setSelectionFromTop(int position, int y)
  ///
  /// Sets the selected item and positions the selection y pixels from the top edge
  /// of the ListView. (If in touch mode, the item will not be selected but it will
  /// still be positioned appropriately.)
  ///@param position Index (starting at 0) of the data item to be selected.
  ///@param y The distance from the top edge of the ListView (plus padding) that the
  ///        item will be positioned.
  void setSelectionFromTop(int position, int y) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSelectionFromTop,
          jni.JniType.voidType, [position, y]).check();
}

/// from: android.widget.AbsListView$SelectionBoundsAdjuster
///
/// The top-level view of a list item can implement this interface to allow
/// itself to modify the bounds of the selection shown for that item.
class AbsListView_SelectionBoundsAdjuster extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/AbsListView\$SelectionBoundsAdjuster");
  AbsListView_SelectionBoundsAdjuster.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_adjustListItemSelectionBounds = jniAccessors.getMethodIDOf(
      _classRef, "adjustListItemSelectionBounds", "(Landroid/graphics/Rect;)V");

  /// from: public abstract void adjustListItemSelectionBounds(android.graphics.Rect bounds)
  ///
  /// Called to allow the list item to adjust the bounds shown for
  /// its selection.
  ///@param bounds On call, this contains the bounds the list has
  /// selected for the item (that is the bounds of the entire view).  The
  /// values can be modified as desired.
  void adjustListItemSelectionBounds(rect_.Rect bounds) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_adjustListItemSelectionBounds,
          jni.JniType.voidType,
          [bounds.reference]).check();
}

/// from: android.widget.AbsListView$RecyclerListener
///
/// A RecyclerListener is used to receive a notification whenever a View is placed
/// inside the RecycleBin's scrap heap. This listener is used to free resources
/// associated to Views placed in the RecycleBin.
///@see android.widget.AbsListView.RecycleBin
///@see android.widget.AbsListView\#setRecyclerListener(android.widget.AbsListView.RecyclerListener)
class AbsListView_RecyclerListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/AbsListView\$RecyclerListener");
  AbsListView_RecyclerListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onMovedToScrapHeap = jniAccessors.getMethodIDOf(
      _classRef, "onMovedToScrapHeap", "(Landroid/view/View;)V");

  /// from: public abstract void onMovedToScrapHeap(android.view.View view)
  ///
  /// Indicates that the specified View was moved into the recycler's scrap heap.
  /// The view is not displayed on screen any more and any expensive resource
  /// associated with the view should be discarded.
  ///@param view
  void onMovedToScrapHeap(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onMovedToScrapHeap,
      jni.JniType.voidType,
      [view.reference]).check();
}

/// from: android.widget.AbsListView$OnScrollListener
///
/// Interface definition for a callback to be invoked when the list or grid
/// has been scrolled.
class AbsListView_OnScrollListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/AbsListView\$OnScrollListener");
  AbsListView_OnScrollListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SCROLL_STATE_FLING
  ///
  /// The user had previously been scrolling using touch and had performed a fling. The
  /// animation is now coasting to a stop
  static const SCROLL_STATE_FLING = 2;

  /// from: static public final int SCROLL_STATE_IDLE
  ///
  /// The view is not scrolling. Note navigating the list using the trackball counts as
  /// being in the idle state since these transitions are not animated.
  static const SCROLL_STATE_IDLE = 0;

  /// from: static public final int SCROLL_STATE_TOUCH_SCROLL
  ///
  /// The user is scrolling using touch, and their finger is still on the screen
  static const SCROLL_STATE_TOUCH_SCROLL = 1;

  static final _id_onScrollStateChanged = jniAccessors.getMethodIDOf(
      _classRef, "onScrollStateChanged", "(Landroid/widget/AbsListView;I)V");

  /// from: public abstract void onScrollStateChanged(android.widget.AbsListView view, int scrollState)
  ///
  /// Callback method to be invoked while the list view or grid view is being scrolled. If the
  /// view is being scrolled, this method will be called before the next frame of the scroll is
  /// rendered. In particular, it will be called before any calls to
  /// Adapter\#getView(int, View, ViewGroup).
  ///@param view The view whose scroll state is being reported
  ///@param scrollState The current scroll state. One of
  /// \#SCROLL_STATE_TOUCH_SCROLL or \#SCROLL_STATE_IDLE.
  void onScrollStateChanged(AbsListView view, int scrollState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScrollStateChanged,
          jni.JniType.voidType, [view.reference, scrollState]).check();

  static final _id_onScroll = jniAccessors.getMethodIDOf(
      _classRef, "onScroll", "(Landroid/widget/AbsListView;III)V");

  /// from: public abstract void onScroll(android.widget.AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount)
  ///
  /// Callback method to be invoked when the list or grid has been scrolled. This will be
  /// called after the scroll has completed
  ///@param view The view whose scroll state is being reported
  ///@param firstVisibleItem the index of the first visible cell (ignore if
  ///        visibleItemCount == 0)
  ///@param visibleItemCount the number of visible cells
  ///@param totalItemCount the number of items in the list adaptor
  void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
          int totalItemCount) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onScroll, jni.JniType.voidType, [
        view.reference,
        firstVisibleItem,
        visibleItemCount,
        totalItemCount
      ]).check();
}

/// from: android.widget.AbsListView$MultiChoiceModeListener
///
/// A MultiChoiceModeListener receives events for AbsListView\#CHOICE_MODE_MULTIPLE_MODAL.
/// It acts as the ActionMode.Callback for the selection mode and also receives
/// \#onItemCheckedStateChanged(ActionMode, int, long, boolean) events when the user
/// selects and deselects list items.
class AbsListView_MultiChoiceModeListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/AbsListView\$MultiChoiceModeListener");
  AbsListView_MultiChoiceModeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onItemCheckedStateChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onItemCheckedStateChanged",
      "(Landroid/view/ActionMode;IJZ)V");

  /// from: public abstract void onItemCheckedStateChanged(android.view.ActionMode mode, int position, long id, boolean checked)
  ///
  /// Called when an item is checked or unchecked during selection mode.
  ///@param mode The ActionMode providing the selection mode
  ///@param position Adapter position of the item that was checked or unchecked
  ///@param id Adapter ID of the item that was checked or unchecked
  ///@param checked <code>true</code> if the item is now checked, <code>false</code>
  ///                if the item is now unchecked.
  void onItemCheckedStateChanged(
          actionmode_.ActionMode mode, int position, int id, bool checked) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onItemCheckedStateChanged,
          jni.JniType.voidType,
          [mode.reference, position, id, checked]).check();
}

/// from: android.widget.AbsListView$LayoutParams
///
/// AbsListView extends LayoutParams to provide a place to hold the view type.
class AbsListView_LayoutParams extends viewgroup_.ViewGroup_LayoutParams {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/AbsListView\$LayoutParams");
  AbsListView_LayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView_LayoutParams(context_.Context c, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [c.reference, attrs.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int w, int h)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView_LayoutParams.ctor1(int w, int h)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [w, h]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(III)V");

  /// from: public void <init>(int w, int h, int viewType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView_LayoutParams.ctor3(int w, int h, int viewType)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [w, h, viewType]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsListView_LayoutParams.ctor2(viewgroup_.ViewGroup_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [source.reference]).object);
}
