// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/View.dart" as view_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../net/Uri.dart" as uri_;

import "../graphics/drawable/Icon.dart" as icon_;

import "../content/res/ColorStateList.dart" as colorstatelist_;

import "../graphics/PorterDuff.dart" as porterduff_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../graphics/Matrix.dart" as matrix_;

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/ColorFilter.dart" as colorfilter_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.ImageView
///
/// Displays image resources, for example android.graphics.Bitmap
/// or android.graphics.drawable.Drawable resources.
/// ImageView is also commonly used to \#setImageTintMode(PorterDuff.Mode) apply tints to an image and handle \#setScaleType(ScaleType) image scaling.
///
///
/// The following XML snippet is a common example of using an ImageView to display an image resource:
///
///
/// <pre>
/// &lt;LinearLayout
///     xmlns:android="http://schemas.android.com/apk/res/android"
///     android:layout_width="match_parent"
///     android:layout_height="match_parent"&gt;
///     &lt;ImageView
///         android:layout_width="wrap_content"
///         android:layout_height="wrap_content"
///         android:src="@mipmap/ic_launcher"
///         /&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// To learn more about Drawables, see: <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>.
/// To learn more about working with Bitmaps, see: <a href="{@docRoot}topic/performance/graphics/index.html">Handling Bitmaps</a>.
///
///
///@attr ref android.R.styleable\#ImageView_adjustViewBounds
///@attr ref android.R.styleable\#ImageView_src
///@attr ref android.R.styleable\#ImageView_maxWidth
///@attr ref android.R.styleable\#ImageView_maxHeight
///@attr ref android.R.styleable\#ImageView_tint
///@attr ref android.R.styleable\#ImageView_scaleType
///@attr ref android.R.styleable\#ImageView_cropToPadding
class ImageView extends view_.View {
  static final _classRef = jniAccessors.getClassOf("android/widget/ImageView");
  ImageView.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ImageView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param attrs This value may be {@code null}.
  ImageView.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param attrs This value may be {@code null}.
  ImageView.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param attrs This value may be {@code null}.
  ImageView.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_verifyDrawable = jniAccessors.getMethodIDOf(
      _classRef, "verifyDrawable", "(Landroid/graphics/drawable/Drawable;)Z");

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable dr)
  ///
  /// @param dr This value must never be {@code null}.
  bool verifyDrawable(drawable_.Drawable dr) => jniAccessors.callMethodWithArgs(
      reference,
      _id_verifyDrawable,
      jni.JniType.booleanType,
      [dr.reference]).boolean;

  static final _id_jumpDrawablesToCurrentState = jniAccessors.getMethodIDOf(
      _classRef, "jumpDrawablesToCurrentState", "()V");

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_jumpDrawablesToCurrentState,
      jni.JniType.voidType, []).check();

  static final _id_invalidateDrawable = jniAccessors.getMethodIDOf(_classRef,
      "invalidateDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable dr)
  ///
  /// @param dr This value must never be {@code null}.
  void invalidateDrawable(drawable_.Drawable dr) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateDrawable,
          jni.JniType.voidType, [dr.reference]).check();

  static final _id_hasOverlappingRendering =
      jniAccessors.getMethodIDOf(_classRef, "hasOverlappingRendering", "()Z");

  /// from: public boolean hasOverlappingRendering()
  bool hasOverlappingRendering() => jniAccessors.callMethodWithArgs(reference,
      _id_hasOverlappingRendering, jni.JniType.booleanType, []).boolean;

  static final _id_getAdjustViewBounds =
      jniAccessors.getMethodIDOf(_classRef, "getAdjustViewBounds", "()Z");

  /// from: public boolean getAdjustViewBounds()
  ///
  /// True when ImageView is adjusting its bounds
  /// to preserve the aspect ratio of its drawable
  ///@return whether to adjust the bounds of this view
  /// to preserve the original aspect ratio of the drawable
  ///@see \#setAdjustViewBounds(boolean)
  ///@attr ref android.R.styleable\#ImageView_adjustViewBounds
  bool getAdjustViewBounds() => jniAccessors.callMethodWithArgs(
      reference, _id_getAdjustViewBounds, jni.JniType.booleanType, []).boolean;

  static final _id_setAdjustViewBounds =
      jniAccessors.getMethodIDOf(_classRef, "setAdjustViewBounds", "(Z)V");

  /// from: public void setAdjustViewBounds(boolean adjustViewBounds)
  ///
  /// Set this to true if you want the ImageView to adjust its bounds
  /// to preserve the aspect ratio of its drawable.
  ///
  /// <strong>Note:</strong> If the application targets API level 17 or lower,
  /// adjustViewBounds will allow the drawable to shrink the view bounds, but not grow
  /// to fill available measured space in all cases. This is for compatibility with
  /// legacy android.view.View.MeasureSpec MeasureSpec and
  /// android.widget.RelativeLayout RelativeLayout behavior.
  ///
  ///@param adjustViewBounds Whether to adjust the bounds of this view
  /// to preserve the original aspect ratio of the drawable.
  ///@see \#getAdjustViewBounds()
  ///@attr ref android.R.styleable\#ImageView_adjustViewBounds
  void setAdjustViewBounds(bool adjustViewBounds) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAdjustViewBounds,
          jni.JniType.voidType, [adjustViewBounds]).check();

  static final _id_getMaxWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMaxWidth", "()I");

  /// from: public int getMaxWidth()
  ///
  /// The maximum width of this view.
  ///@return The maximum width of this view
  ///@see \#setMaxWidth(int)
  ///@attr ref android.R.styleable\#ImageView_maxWidth
  int getMaxWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxWidth, jni.JniType.intType, []).integer;

  static final _id_setMaxWidth =
      jniAccessors.getMethodIDOf(_classRef, "setMaxWidth", "(I)V");

  /// from: public void setMaxWidth(int maxWidth)
  ///
  /// An optional argument to supply a maximum width for this view. Only valid if
  /// \#setAdjustViewBounds(boolean) has been set to true. To set an image to be a maximum
  /// of 100 x 100 while preserving the original aspect ratio, do the following: 1) set
  /// adjustViewBounds to true 2) set maxWidth and maxHeight to 100 3) set the height and width
  /// layout params to WRAP_CONTENT.
  ///
  ///
  /// Note that this view could be still smaller than 100 x 100 using this approach if the original
  /// image is small. To set an image to a fixed size, specify that size in the layout params and
  /// then use \#setScaleType(android.widget.ImageView.ScaleType) to determine how to fit
  /// the image within the bounds.
  ///
  ///
  ///@param maxWidth maximum width for this view
  ///@see \#getMaxWidth()
  ///@attr ref android.R.styleable\#ImageView_maxWidth
  void setMaxWidth(int maxWidth) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxWidth, jni.JniType.voidType, [maxWidth]).check();

  static final _id_getMaxHeight =
      jniAccessors.getMethodIDOf(_classRef, "getMaxHeight", "()I");

  /// from: public int getMaxHeight()
  ///
  /// The maximum height of this view.
  ///@return The maximum height of this view
  ///@see \#setMaxHeight(int)
  ///@attr ref android.R.styleable\#ImageView_maxHeight
  int getMaxHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxHeight, jni.JniType.intType, []).integer;

  static final _id_setMaxHeight =
      jniAccessors.getMethodIDOf(_classRef, "setMaxHeight", "(I)V");

  /// from: public void setMaxHeight(int maxHeight)
  ///
  /// An optional argument to supply a maximum height for this view. Only valid if
  /// \#setAdjustViewBounds(boolean) has been set to true. To set an image to be a
  /// maximum of 100 x 100 while preserving the original aspect ratio, do the following: 1) set
  /// adjustViewBounds to true 2) set maxWidth and maxHeight to 100 3) set the height and width
  /// layout params to WRAP_CONTENT.
  ///
  ///
  /// Note that this view could be still smaller than 100 x 100 using this approach if the original
  /// image is small. To set an image to a fixed size, specify that size in the layout params and
  /// then use \#setScaleType(android.widget.ImageView.ScaleType) to determine how to fit
  /// the image within the bounds.
  ///
  ///
  ///@param maxHeight maximum height for this view
  ///@see \#getMaxHeight()
  ///@attr ref android.R.styleable\#ImageView_maxHeight
  void setMaxHeight(int maxHeight) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxHeight, jni.JniType.voidType, [maxHeight]).check();

  static final _id_getDrawable = jniAccessors.getMethodIDOf(
      _classRef, "getDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current Drawable, or null if no Drawable has been
  /// assigned.
  ///@return the view's drawable, or null if no drawable has been
  /// assigned.
  drawable_.Drawable getDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrawable, jni.JniType.objectType, []).object);

  static final _id_setImageResource =
      jniAccessors.getMethodIDOf(_classRef, "setImageResource", "(I)V");

  /// from: public void setImageResource(int resId)
  ///
  /// Sets a drawable as the content of this ImageView.
  /// <p class="note">This does Bitmap reading and decoding on the UI
  /// thread, which can cause a latency hiccup.  If that's a concern,
  /// consider using \#setImageDrawable(android.graphics.drawable.Drawable) or
  /// \#setImageBitmap(android.graphics.Bitmap) and
  /// android.graphics.BitmapFactory instead.
  ///
  ///@param resId the resource identifier of the drawable
  ///@attr ref android.R.styleable\#ImageView_src
  void setImageResource(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setImageResource, jni.JniType.voidType, [resId]).check();

  static final _id_setImageURI = jniAccessors.getMethodIDOf(
      _classRef, "setImageURI", "(Landroid/net/Uri;)V");

  /// from: public void setImageURI(android.net.Uri uri)
  ///
  /// Sets the content of this ImageView to the specified Uri.
  /// Note that you use this method to load images from a local Uri only.
  /// <p/>
  /// To learn how to display images from a remote Uri see: <a href="https://developer.android.com/topic/performance/graphics/index.html">Handling Bitmaps</a>
  /// <p/>
  /// <p class="note">This does Bitmap reading and decoding on the UI
  /// thread, which can cause a latency hiccup.  If that's a concern,
  /// consider using \#setImageDrawable(Drawable) or
  /// \#setImageBitmap(android.graphics.Bitmap) and
  /// android.graphics.BitmapFactory instead.
  ///
  ///
  /// <p class="note">On devices running SDK < 24, this method will fail to
  /// apply correct density scaling to images loaded from
  /// ContentResolver\#SCHEME_CONTENT content and
  /// ContentResolver\#SCHEME_FILE file schemes. Applications running
  /// on devices with SDK >= 24 <strong>MUST</strong> specify the
  /// {@code targetSdkVersion} in their manifest as 24 or above for density
  /// scaling to be applied to images loaded from these schemes.
  ///
  ///@param uri the Uri of an image, or {@code null} to clear the content
  ///
  /// This value may be {@code null}.
  void setImageURI(uri_.Uri uri) => jniAccessors.callMethodWithArgs(reference,
      _id_setImageURI, jni.JniType.voidType, [uri.reference]).check();

  static final _id_setImageDrawable = jniAccessors.getMethodIDOf(
      _classRef, "setImageDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setImageDrawable(android.graphics.drawable.Drawable drawable)
  ///
  /// Sets a drawable as the content of this ImageView.
  ///@param drawable the Drawable to set, or {@code null} to clear the
  ///                 content
  ///
  /// This value may be {@code null}.
  void setImageDrawable(drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImageDrawable,
          jni.JniType.voidType, [drawable.reference]).check();

  static final _id_setImageIcon = jniAccessors.getMethodIDOf(
      _classRef, "setImageIcon", "(Landroid/graphics/drawable/Icon;)V");

  /// from: public void setImageIcon(android.graphics.drawable.Icon icon)
  ///
  /// Sets the content of this ImageView to the specified Icon.
  ///
  /// <p class="note">Depending on the Icon type, this may do Bitmap reading
  /// and decoding on the UI thread, which can cause UI jank.  If that's a
  /// concern, consider using
  /// Icon\#loadDrawableAsync(Context, Icon.OnDrawableLoadedListener, Handler)
  /// and then \#setImageDrawable(android.graphics.drawable.Drawable)
  /// instead.
  ///
  ///@param icon an Icon holding the desired image, or {@code null} to clear
  ///             the content
  ///
  /// This value may be {@code null}.
  void setImageIcon(icon_.Icon icon) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setImageIcon,
      jni.JniType.voidType,
      [icon.reference]).check();

  static final _id_setImageTintList = jniAccessors.getMethodIDOf(
      _classRef, "setImageTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setImageTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the image drawable. Does not modify the current tint
  /// mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// Subsequent calls to \#setImageDrawable(Drawable) will automatically
  /// mutate the drawable and apply the specified tint and tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///
  /// _Note:_ The default tint mode used by this setter is NOT
  /// consistent with the default tint mode used by the
  /// android.R.styleable\#ImageView_tint android:tint
  /// attribute. If the {@code android:tint} attribute is specified, the
  /// default tint mode will be set to PorterDuff.Mode\#SRC_ATOP to
  /// ensure consistency with earlier versions of the platform.
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ImageView_tint
  ///@see \#getImageTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setImageTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImageTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_getImageTintList = jniAccessors.getMethodIDOf(
      _classRef, "getImageTintList", "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getImageTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the current android.content.res.ColorStateList used to tint the image Drawable,
  /// or null if no tint is applied.
  ///@return the tint applied to the image drawable
  ///@attr ref android.R.styleable\#ImageView_tint
  ///@see \#setImageTintList(ColorStateList)
  colorstatelist_.ColorStateList getImageTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getImageTintList, jni.JniType.objectType, []).object);

  static final _id_setImageTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setImageTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setImageTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setImageTintList(ColorStateList)} to the image drawable. The default
  /// mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ImageView_tintMode
  ///@see \#getImageTintMode()
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setImageTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImageTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_getImageTintMode = jniAccessors.getMethodIDOf(
      _classRef, "getImageTintMode", "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getImageTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the blending mode used to apply the tint to the image Drawable
  ///@return the blending mode used to apply the tint to the image Drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#ImageView_tintMode
  ///@see \#setImageTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getImageTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getImageTintMode, jni.JniType.objectType, []).object);

  static final _id_setImageBitmap = jniAccessors.getMethodIDOf(
      _classRef, "setImageBitmap", "(Landroid/graphics/Bitmap;)V");

  /// from: public void setImageBitmap(android.graphics.Bitmap bm)
  ///
  /// Sets a Bitmap as the content of this ImageView.
  ///@param bm The bitmap to set
  void setImageBitmap(bitmap_.Bitmap bm) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setImageBitmap,
      jni.JniType.voidType,
      [bm.reference]).check();

  static final _id_setImageState =
      jniAccessors.getMethodIDOf(_classRef, "setImageState", "([IZ)V");

  /// from: public void setImageState(int[] state, boolean merge)
  ///
  /// Set the state of the current android.graphics.drawable.StateListDrawable.
  /// For more information about State List Drawables, see: <a href="https://developer.android.com/guide/topics/resources/drawable-resource.html\#StateList">the Drawable Resource Guide</a>.
  ///@param state the state to set for the StateListDrawable
  ///@param merge if true, merges the state values for the state you specify into the current state
  void setImageState(jni.JniObject state, bool merge) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImageState,
          jni.JniType.voidType, [state.reference, merge]).check();

  static final _id_setSelected =
      jniAccessors.getMethodIDOf(_classRef, "setSelected", "(Z)V");

  /// from: public void setSelected(boolean selected)
  void setSelected(bool selected) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelected, jni.JniType.voidType, [selected]).check();

  static final _id_setImageLevel =
      jniAccessors.getMethodIDOf(_classRef, "setImageLevel", "(I)V");

  /// from: public void setImageLevel(int level)
  ///
  /// Sets the image level, when it is constructed from a
  /// android.graphics.drawable.LevelListDrawable.
  ///@param level The new level for the image.
  void setImageLevel(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_setImageLevel, jni.JniType.voidType, [level]).check();

  static final _id_setScaleType = jniAccessors.getMethodIDOf(
      _classRef, "setScaleType", "(Landroid/widget/ImageView\$ScaleType;)V");

  /// from: public void setScaleType(android.widget.ImageView.ScaleType scaleType)
  ///
  /// Controls how the image should be resized or moved to match the size
  /// of this ImageView.
  ///@param scaleType The desired scaling mode.
  ///@attr ref android.R.styleable\#ImageView_scaleType
  void setScaleType(ImageView_ScaleType scaleType) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScaleType,
          jni.JniType.voidType, [scaleType.reference]).check();

  static final _id_getScaleType = jniAccessors.getMethodIDOf(
      _classRef, "getScaleType", "()Landroid/widget/ImageView\$ScaleType;");

  /// from: public android.widget.ImageView.ScaleType getScaleType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current ScaleType that is used to scale the bounds of an image to the bounds of the ImageView.
  ///@return The ScaleType used to scale the image.
  ///@see ImageView.ScaleType
  ///@attr ref android.R.styleable\#ImageView_scaleType
  ImageView_ScaleType getScaleType() =>
      ImageView_ScaleType.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getScaleType, jni.JniType.objectType, []).object);

  static final _id_getImageMatrix = jniAccessors.getMethodIDOf(
      _classRef, "getImageMatrix", "()Landroid/graphics/Matrix;");

  /// from: public android.graphics.Matrix getImageMatrix()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the view's optional matrix. This is applied to the
  ///    view's drawable when it is drawn. If there is no matrix,
  ///    this method will return an identity matrix.
  ///    Do not change this matrix in place but make a copy.
  ///    If you want a different matrix applied to the drawable,
  ///    be sure to call setImageMatrix().
  matrix_.Matrix getImageMatrix() =>
      matrix_.Matrix.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getImageMatrix, jni.JniType.objectType, []).object);

  static final _id_setImageMatrix = jniAccessors.getMethodIDOf(
      _classRef, "setImageMatrix", "(Landroid/graphics/Matrix;)V");

  /// from: public void setImageMatrix(android.graphics.Matrix matrix)
  ///
  /// Adds a transformation Matrix that is applied
  /// to the view's drawable when it is drawn.  Allows custom scaling,
  /// translation, and perspective distortion.
  ///@param matrix The transformation parameters in matrix form.
  void setImageMatrix(matrix_.Matrix matrix) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setImageMatrix,
      jni.JniType.voidType,
      [matrix.reference]).check();

  static final _id_getCropToPadding =
      jniAccessors.getMethodIDOf(_classRef, "getCropToPadding", "()Z");

  /// from: public boolean getCropToPadding()
  ///
  /// Return whether this ImageView crops to padding.
  ///@return whether this ImageView crops to padding
  ///@see \#setCropToPadding(boolean)
  ///@attr ref android.R.styleable\#ImageView_cropToPadding
  bool getCropToPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getCropToPadding, jni.JniType.booleanType, []).boolean;

  static final _id_setCropToPadding =
      jniAccessors.getMethodIDOf(_classRef, "setCropToPadding", "(Z)V");

  /// from: public void setCropToPadding(boolean cropToPadding)
  ///
  /// Sets whether this ImageView will crop to padding.
  ///@param cropToPadding whether this ImageView will crop to padding
  ///@see \#getCropToPadding()
  ///@attr ref android.R.styleable\#ImageView_cropToPadding
  void setCropToPadding(bool cropToPadding) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCropToPadding,
      jni.JniType.voidType,
      [cropToPadding]).check();

  static final _id_onCreateDrawableState =
      jniAccessors.getMethodIDOf(_classRef, "onCreateDrawableState", "(I)[I");

  /// from: public int[] onCreateDrawableState(int extraSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onCreateDrawableState(int extraSpace) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateDrawableState,
          jni.JniType.objectType,
          [extraSpace]).object);

  static final _id_onRtlPropertiesChanged =
      jniAccessors.getMethodIDOf(_classRef, "onRtlPropertiesChanged", "(I)V");

  /// from: public void onRtlPropertiesChanged(int layoutDirection)
  void onRtlPropertiesChanged(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRtlPropertiesChanged,
          jni.JniType.voidType, [layoutDirection]).check();

  static final _id_onMeasure =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_setFrame =
      jniAccessors.getMethodIDOf(_classRef, "setFrame", "(IIII)Z");

  /// from: protected boolean setFrame(int l, int t, int r, int b)
  bool setFrame(int l, int t, int r, int b) => jniAccessors.callMethodWithArgs(
      reference, _id_setFrame, jni.JniType.booleanType, [l, t, r, b]).boolean;

  static final _id_drawableStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableStateChanged", "()V");

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_drawableStateChanged, jni.JniType.voidType, []).check();

  static final _id_drawableHotspotChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableHotspotChanged", "(FF)V");

  /// from: public void drawableHotspotChanged(float x, float y)
  void drawableHotspotChanged(double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawableHotspotChanged,
          jni.JniType.voidType, [x, y]).check();

  static final _id_onDraw = jniAccessors.getMethodIDOf(
      _classRef, "onDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_onDraw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getBaseline =
      jniAccessors.getMethodIDOf(_classRef, "getBaseline", "()I");

  /// from: public int getBaseline()
  ///
  /// Return the offset of the widget's text baseline from the widget's top
  /// boundary.
  ///
  ///@return the offset of the baseline within the widget's bounds or -1
  ///         if baseline alignment is not supported.
  int getBaseline() => jniAccessors.callMethodWithArgs(
      reference, _id_getBaseline, jni.JniType.intType, []).integer;

  static final _id_setBaseline =
      jniAccessors.getMethodIDOf(_classRef, "setBaseline", "(I)V");

  /// from: public void setBaseline(int baseline)
  ///
  /// Set the offset of the widget's text baseline from the widget's top
  /// boundary.  This value is overridden by the \#setBaselineAlignBottom(boolean)
  /// property.
  ///
  ///@param baseline The baseline to use, or -1 if none is to be provided.
  ///@see \#setBaseline(int)
  ///@attr ref android.R.styleable\#ImageView_baseline
  void setBaseline(int baseline) => jniAccessors.callMethodWithArgs(
      reference, _id_setBaseline, jni.JniType.voidType, [baseline]).check();

  static final _id_setBaselineAlignBottom =
      jniAccessors.getMethodIDOf(_classRef, "setBaselineAlignBottom", "(Z)V");

  /// from: public void setBaselineAlignBottom(boolean aligned)
  ///
  /// Sets whether the baseline of this view to the bottom of the view.
  /// Setting this value overrides any calls to setBaseline.
  ///@param aligned If true, the image view will be baseline aligned by its bottom edge.
  ///@attr ref android.R.styleable\#ImageView_baselineAlignBottom
  void setBaselineAlignBottom(bool aligned) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBaselineAlignBottom,
      jni.JniType.voidType,
      [aligned]).check();

  static final _id_getBaselineAlignBottom =
      jniAccessors.getMethodIDOf(_classRef, "getBaselineAlignBottom", "()Z");

  /// from: public boolean getBaselineAlignBottom()
  ///
  /// Checks whether this view's baseline is considered the bottom of the view.
  ///@return True if the ImageView's baseline is considered the bottom of the view, false if otherwise.
  ///@see \#setBaselineAlignBottom(boolean)
  bool getBaselineAlignBottom() => jniAccessors.callMethodWithArgs(reference,
      _id_getBaselineAlignBottom, jni.JniType.booleanType, []).boolean;

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(ILandroid/graphics/PorterDuff\$Mode;)V");

  /// from: public final void setColorFilter(int color, android.graphics.PorterDuff.Mode mode)
  ///
  /// Sets a tinting option for the image.
  ///@param color Color tint to apply.
  ///@param mode How to apply the color.  The standard mode is
  /// PorterDuff.Mode\#SRC_ATOP
  ///@attr ref android.R.styleable\#ImageView_tint
  void setColorFilter(int color, porterduff_.PorterDuff_Mode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [color, mode.reference]).check();

  static final _id_setColorFilter1 =
      jniAccessors.getMethodIDOf(_classRef, "setColorFilter", "(I)V");

  /// from: public final void setColorFilter(int color)
  ///
  /// Set a tinting option for the image. Assumes
  /// PorterDuff.Mode\#SRC_ATOP blending mode.
  ///@param color Color tint to apply.
  ///@attr ref android.R.styleable\#ImageView_tint
  void setColorFilter1(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setColorFilter1, jni.JniType.voidType, [color]).check();

  static final _id_clearColorFilter =
      jniAccessors.getMethodIDOf(_classRef, "clearColorFilter", "()V");

  /// from: public final void clearColorFilter()
  ///
  /// Removes the image's android.graphics.ColorFilter.
  ///@see \#setColorFilter(int)
  ///@see \#getColorFilter()
  void clearColorFilter() => jniAccessors.callMethodWithArgs(
      reference, _id_clearColorFilter, jni.JniType.voidType, []).check();

  static final _id_getColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "getColorFilter", "()Landroid/graphics/ColorFilter;");

  /// from: public android.graphics.ColorFilter getColorFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the active color filter for this ImageView.
  ///@return the active color filter for this ImageView
  ///@see \#setColorFilter(android.graphics.ColorFilter)
  colorfilter_.ColorFilter getColorFilter() =>
      colorfilter_.ColorFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorFilter, jni.JniType.objectType, []).object);

  static final _id_setColorFilter2 = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public void setColorFilter(android.graphics.ColorFilter cf)
  ///
  /// Apply an arbitrary colorfilter to the image.
  ///@param cf the colorfilter to apply (may be null)
  ///@see \#getColorFilter()
  void setColorFilter2(colorfilter_.ColorFilter cf) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter2,
          jni.JniType.voidType, [cf.reference]).check();

  static final _id_getImageAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getImageAlpha", "()I");

  /// from: public int getImageAlpha()
  ///
  /// Returns the alpha that will be applied to the drawable of this ImageView.
  ///@return the alpha value that will be applied to the drawable of this
  /// ImageView (between 0 and 255 inclusive, with 0 being transparent and
  /// 255 being opaque)
  ///@see \#setImageAlpha(int)
  int getImageAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getImageAlpha, jni.JniType.intType, []).integer;

  static final _id_setImageAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setImageAlpha", "(I)V");

  /// from: public void setImageAlpha(int alpha)
  ///
  /// Sets the alpha value that should be applied to the image.
  ///@param alpha the alpha value that should be applied to the image (between
  /// 0 and 255 inclusive, with 0 being transparent and 255 being opaque)
  ///@see \#getImageAlpha()
  void setImageAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setImageAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_setAlpha1 =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int alpha)
  ///
  /// Sets the alpha value that should be applied to the image.
  ///@param alpha the alpha value that should be applied to the image
  ///@deprecated use \#setImageAlpha(int) instead
  void setAlpha1(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha1, jni.JniType.voidType, [alpha]).check();

  static final _id_isOpaque =
      jniAccessors.getMethodIDOf(_classRef, "isOpaque", "()Z");

  /// from: public boolean isOpaque()
  bool isOpaque() => jniAccessors.callMethodWithArgs(
      reference, _id_isOpaque, jni.JniType.booleanType, []).boolean;

  static final _id_onVisibilityAggregated =
      jniAccessors.getMethodIDOf(_classRef, "onVisibilityAggregated", "(Z)V");

  /// from: public void onVisibilityAggregated(boolean isVisible)
  void onVisibilityAggregated(bool isVisible) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVisibilityAggregated,
          jni.JniType.voidType, [isVisible]).check();

  static final _id_setVisibility =
      jniAccessors.getMethodIDOf(_classRef, "setVisibility", "(I)V");

  /// from: public void setVisibility(int visibility)
  void setVisibility(int visibility) => jniAccessors.callMethodWithArgs(
      reference, _id_setVisibility, jni.JniType.voidType, [visibility]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);
}

/// from: android.widget.ImageView$ScaleType
///
/// Options for scaling the bounds of an image to the bounds of this view.
class ImageView_ScaleType extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/ImageView\$ScaleType");
  ImageView_ScaleType.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/widget/ImageView\$ScaleType;");

  /// from: static public android.widget.ImageView.ScaleType[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/widget/ImageView\$ScaleType;");

  /// from: static public android.widget.ImageView.ScaleType valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ImageView_ScaleType valueOf(jni.JniString name) =>
      ImageView_ScaleType.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);
}
