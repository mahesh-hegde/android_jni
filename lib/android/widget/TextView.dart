// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/View.dart" as view_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../graphics/Typeface.dart" as typeface_;

import "../text/method/MovementMethod.dart" as movementmethod_;

import "../text/Editable.dart" as editable_;

import "../text/Layout.dart" as layout_;

import "../text/method/KeyListener.dart" as keylistener_;

import "../text/method/TransformationMethod.dart" as transformationmethod_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../content/res/ColorStateList.dart" as colorstatelist_;

import "../graphics/PorterDuff.dart" as porterduff_;

import "../os/LocaleList.dart" as localelist_;

import "../content/res/Configuration.dart" as configuration_;

import "../text/PrecomputedText.dart" as precomputedtext_;

import "../text/TextPaint.dart" as textpaint_;

import "../os/Parcelable.dart" as parcelable_;

import "../text/Spannable.dart" as spannable_;

import "../os/Bundle.dart" as bundle_;

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/Rect.dart" as rect_;

import "../view/PointerIcon.dart" as pointericon_;

import "../view/MotionEvent.dart" as motionevent_;

import "../view/KeyEvent.dart" as keyevent_;

import "../view/inputmethod/InputConnection.dart" as inputconnection_;

import "../view/inputmethod/EditorInfo.dart" as editorinfo_;

import "../view/inputmethod/ExtractedTextRequest.dart" as extractedtextrequest_;

import "../view/inputmethod/ExtractedText.dart" as extractedtext_;

import "../view/inputmethod/CompletionInfo.dart" as completioninfo_;

import "../view/inputmethod/CorrectionInfo.dart" as correctioninfo_;

import "../text/TextUtils.dart" as textutils_;

import "../text/TextWatcher.dart" as textwatcher_;

import "../view/ContextMenu.dart" as contextmenu_;

import "Scroller.dart" as scroller_;

import "../view/ViewStructure.dart" as viewstructure_;

import "../view/autofill/AutofillValue.dart" as autofillvalue_;

import "../view/accessibility/AccessibilityNodeInfo.dart"
    as accessibilitynodeinfo_;

import "../view/accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "../view/ActionMode.dart" as actionmode_;

import "../view/textclassifier/TextClassifier.dart" as textclassifier_;

import "../view/DragEvent.dart" as dragevent_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.TextView
///
/// A user interface element that displays text to the user.
/// To provide user-editable text, see EditText.
///
/// The following code sample shows a typical use, with an XML layout
/// and code to modify the contents of the text view:
///
///
///
/// <pre>
/// &lt;LinearLayout
///      xmlns:android="http://schemas.android.com/apk/res/android"
///      android:layout_width="match_parent"
///      android:layout_height="match_parent"&gt;
///    &lt;TextView
///        android:id="@+id/text_view_id"
///        android:layout_height="wrap_content"
///        android:layout_width="wrap_content"
///        android:text="@string/hello" /&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
/// This code sample demonstrates how to modify the contents of the text view
/// defined in the previous XML layout:
///
///
/// <pre>
/// public class MainActivity extends Activity {
///
///    protected void onCreate(Bundle savedInstanceState) {
///         super.onCreate(savedInstanceState);
///         setContentView(R.layout.activity_main);
///         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);
///         helloTextView.setText(R.string.user_greeting);
///     }
/// }
/// </pre>
///
/// To customize the appearance of TextView, see <a href="https://developer.android.com/guide/topics/ui/themes.html">Styles and Themes</a>.
///
///
///
/// __XML attributes__
///
/// See android.R.styleable\#TextView TextView Attributes,
/// android.R.styleable\#View View Attributes
///@attr ref android.R.styleable\#TextView_text
///@attr ref android.R.styleable\#TextView_bufferType
///@attr ref android.R.styleable\#TextView_hint
///@attr ref android.R.styleable\#TextView_textColor
///@attr ref android.R.styleable\#TextView_textColorHighlight
///@attr ref android.R.styleable\#TextView_textColorHint
///@attr ref android.R.styleable\#TextView_textAppearance
///@attr ref android.R.styleable\#TextView_textColorLink
///@attr ref android.R.styleable\#TextView_textSize
///@attr ref android.R.styleable\#TextView_textScaleX
///@attr ref android.R.styleable\#TextView_fontFamily
///@attr ref android.R.styleable\#TextView_typeface
///@attr ref android.R.styleable\#TextView_textStyle
///@attr ref android.R.styleable\#TextView_cursorVisible
///@attr ref android.R.styleable\#TextView_maxLines
///@attr ref android.R.styleable\#TextView_maxHeight
///@attr ref android.R.styleable\#TextView_lines
///@attr ref android.R.styleable\#TextView_height
///@attr ref android.R.styleable\#TextView_minLines
///@attr ref android.R.styleable\#TextView_minHeight
///@attr ref android.R.styleable\#TextView_maxEms
///@attr ref android.R.styleable\#TextView_maxWidth
///@attr ref android.R.styleable\#TextView_ems
///@attr ref android.R.styleable\#TextView_width
///@attr ref android.R.styleable\#TextView_minEms
///@attr ref android.R.styleable\#TextView_minWidth
///@attr ref android.R.styleable\#TextView_gravity
///@attr ref android.R.styleable\#TextView_scrollHorizontally
///@attr ref android.R.styleable\#TextView_password
///@attr ref android.R.styleable\#TextView_singleLine
///@attr ref android.R.styleable\#TextView_selectAllOnFocus
///@attr ref android.R.styleable\#TextView_includeFontPadding
///@attr ref android.R.styleable\#TextView_maxLength
///@attr ref android.R.styleable\#TextView_shadowColor
///@attr ref android.R.styleable\#TextView_shadowDx
///@attr ref android.R.styleable\#TextView_shadowDy
///@attr ref android.R.styleable\#TextView_shadowRadius
///@attr ref android.R.styleable\#TextView_autoLink
///@attr ref android.R.styleable\#TextView_linksClickable
///@attr ref android.R.styleable\#TextView_numeric
///@attr ref android.R.styleable\#TextView_digits
///@attr ref android.R.styleable\#TextView_phoneNumber
///@attr ref android.R.styleable\#TextView_inputMethod
///@attr ref android.R.styleable\#TextView_capitalize
///@attr ref android.R.styleable\#TextView_autoText
///@attr ref android.R.styleable\#TextView_editable
///@attr ref android.R.styleable\#TextView_freezesText
///@attr ref android.R.styleable\#TextView_ellipsize
///@attr ref android.R.styleable\#TextView_drawableTop
///@attr ref android.R.styleable\#TextView_drawableBottom
///@attr ref android.R.styleable\#TextView_drawableRight
///@attr ref android.R.styleable\#TextView_drawableLeft
///@attr ref android.R.styleable\#TextView_drawableStart
///@attr ref android.R.styleable\#TextView_drawableEnd
///@attr ref android.R.styleable\#TextView_drawablePadding
///@attr ref android.R.styleable\#TextView_drawableTint
///@attr ref android.R.styleable\#TextView_drawableTintMode
///@attr ref android.R.styleable\#TextView_lineSpacingExtra
///@attr ref android.R.styleable\#TextView_lineSpacingMultiplier
///@attr ref android.R.styleable\#TextView_justificationMode
///@attr ref android.R.styleable\#TextView_marqueeRepeatLimit
///@attr ref android.R.styleable\#TextView_inputType
///@attr ref android.R.styleable\#TextView_imeOptions
///@attr ref android.R.styleable\#TextView_privateImeOptions
///@attr ref android.R.styleable\#TextView_imeActionLabel
///@attr ref android.R.styleable\#TextView_imeActionId
///@attr ref android.R.styleable\#TextView_editorExtras
///@attr ref android.R.styleable\#TextView_elegantTextHeight
///@attr ref android.R.styleable\#TextView_fallbackLineSpacing
///@attr ref android.R.styleable\#TextView_letterSpacing
///@attr ref android.R.styleable\#TextView_fontFeatureSettings
///@attr ref android.R.styleable\#TextView_breakStrategy
///@attr ref android.R.styleable\#TextView_hyphenationFrequency
///@attr ref android.R.styleable\#TextView_autoSizeTextType
///@attr ref android.R.styleable\#TextView_autoSizeMinTextSize
///@attr ref android.R.styleable\#TextView_autoSizeMaxTextSize
///@attr ref android.R.styleable\#TextView_autoSizeStepGranularity
///@attr ref android.R.styleable\#TextView_autoSizePresetSizes
class TextView extends view_.View {
  static final _classRef = jniAccessors.getClassOf("android/widget/TextView");
  TextView.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AUTO_SIZE_TEXT_TYPE_NONE
  ///
  /// The TextView does not auto-size text (default).
  static const AUTO_SIZE_TEXT_TYPE_NONE = 0;

  /// from: static public final int AUTO_SIZE_TEXT_TYPE_UNIFORM
  ///
  /// The TextView scales text size both horizontally and vertically to fit within the
  /// container.
  static const AUTO_SIZE_TEXT_TYPE_UNIFORM = 1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TextView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param attrs This value may be {@code null}.
  TextView.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param attrs This value may be {@code null}.
  TextView.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param attrs This value may be {@code null}.
  TextView.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_setAutoSizeTextTypeWithDefaults = jniAccessors.getMethodIDOf(
      _classRef, "setAutoSizeTextTypeWithDefaults", "(I)V");

  /// from: public void setAutoSizeTextTypeWithDefaults(int autoSizeTextType)
  ///
  /// Specify whether this widget should automatically scale the text to try to perfectly fit
  /// within the layout bounds by using the default auto-size configuration.
  ///@param autoSizeTextType the type of auto-size. Must be one of
  ///        TextView\#AUTO_SIZE_TEXT_TYPE_NONE or
  ///        TextView\#AUTO_SIZE_TEXT_TYPE_UNIFORM
  ///
  /// Value is android.widget.TextView\#AUTO_SIZE_TEXT_TYPE_NONE, or android.widget.TextView\#AUTO_SIZE_TEXT_TYPE_UNIFORM
  ///@throws IllegalArgumentException if <code>autoSizeTextType</code> is none of the types above.
  ///@attr ref android.R.styleable\#TextView_autoSizeTextType
  ///@see \#getAutoSizeTextType()
  void setAutoSizeTextTypeWithDefaults(int autoSizeTextType) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAutoSizeTextTypeWithDefaults,
          jni.JniType.voidType,
          [autoSizeTextType]).check();

  static final _id_setAutoSizeTextTypeUniformWithConfiguration =
      jniAccessors.getMethodIDOf(
          _classRef, "setAutoSizeTextTypeUniformWithConfiguration", "(IIII)V");

  /// from: public void setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize, int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit)
  ///
  /// Specify whether this widget should automatically scale the text to try to perfectly fit
  /// within the layout bounds. If all the configuration params are valid the type of auto-size is
  /// set to \#AUTO_SIZE_TEXT_TYPE_UNIFORM.
  ///@param autoSizeMinTextSize the minimum text size available for auto-size
  ///@param autoSizeMaxTextSize the maximum text size available for auto-size
  ///@param autoSizeStepGranularity the auto-size step granularity. It is used in conjunction with
  ///                                the minimum and maximum text size in order to build the set of
  ///                                text sizes the system uses to choose from when auto-sizing
  ///@param unit the desired dimension unit for all sizes above. See TypedValue for the
  ///             possible dimension units
  ///@throws IllegalArgumentException if any of the configuration params are invalid.
  ///@attr ref android.R.styleable\#TextView_autoSizeTextType
  ///@attr ref android.R.styleable\#TextView_autoSizeMinTextSize
  ///@attr ref android.R.styleable\#TextView_autoSizeMaxTextSize
  ///@attr ref android.R.styleable\#TextView_autoSizeStepGranularity
  ///@see \#setAutoSizeTextTypeWithDefaults(int)
  ///@see \#setAutoSizeTextTypeUniformWithPresetSizes(int[], int)
  ///@see \#getAutoSizeMinTextSize()
  ///@see \#getAutoSizeMaxTextSize()
  ///@see \#getAutoSizeStepGranularity()
  ///@see \#getAutoSizeTextAvailableSizes()
  void setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize,
          int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAutoSizeTextTypeUniformWithConfiguration,
          jni.JniType.voidType, [
        autoSizeMinTextSize,
        autoSizeMaxTextSize,
        autoSizeStepGranularity,
        unit
      ]).check();

  static final _id_setAutoSizeTextTypeUniformWithPresetSizes =
      jniAccessors.getMethodIDOf(
          _classRef, "setAutoSizeTextTypeUniformWithPresetSizes", "([II)V");

  /// from: public void setAutoSizeTextTypeUniformWithPresetSizes(int[] presetSizes, int unit)
  ///
  /// Specify whether this widget should automatically scale the text to try to perfectly fit
  /// within the layout bounds. If at least one value from the <code>presetSizes</code> is valid
  /// then the type of auto-size is set to \#AUTO_SIZE_TEXT_TYPE_UNIFORM.
  ///@param presetSizes an {@code int} array of sizes in pixels
  /// This value must never be {@code null}.
  ///@param unit the desired dimension unit for the preset sizes above. See TypedValue for
  ///             the possible dimension units
  ///@throws IllegalArgumentException if all of the <code>presetSizes</code> are invalid.
  ///@attr ref android.R.styleable\#TextView_autoSizeTextType
  ///@attr ref android.R.styleable\#TextView_autoSizePresetSizes
  ///@see \#setAutoSizeTextTypeWithDefaults(int)
  ///@see \#setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)
  ///@see \#getAutoSizeMinTextSize()
  ///@see \#getAutoSizeMaxTextSize()
  ///@see \#getAutoSizeTextAvailableSizes()
  void setAutoSizeTextTypeUniformWithPresetSizes(
          jni.JniObject presetSizes, int unit) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAutoSizeTextTypeUniformWithPresetSizes,
          jni.JniType.voidType,
          [presetSizes.reference, unit]).check();

  static final _id_getAutoSizeTextType =
      jniAccessors.getMethodIDOf(_classRef, "getAutoSizeTextType", "()I");

  /// from: public int getAutoSizeTextType()
  ///
  /// Returns the type of auto-size set for this widget.
  ///@return an {@code int} corresponding to one of the auto-size types:
  ///         TextView\#AUTO_SIZE_TEXT_TYPE_NONE or
  ///         TextView\#AUTO_SIZE_TEXT_TYPE_UNIFORM
  ///
  /// Value is android.widget.TextView\#AUTO_SIZE_TEXT_TYPE_NONE, or android.widget.TextView\#AUTO_SIZE_TEXT_TYPE_UNIFORM
  ///@attr ref android.R.styleable\#TextView_autoSizeTextType
  ///@see \#setAutoSizeTextTypeWithDefaults(int)
  ///@see \#setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)
  ///@see \#setAutoSizeTextTypeUniformWithPresetSizes(int[], int)
  int getAutoSizeTextType() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutoSizeTextType, jni.JniType.intType, []).integer;

  static final _id_getAutoSizeStepGranularity = jniAccessors.getMethodIDOf(
      _classRef, "getAutoSizeStepGranularity", "()I");

  /// from: public int getAutoSizeStepGranularity()
  ///
  /// @return the current auto-size step granularity in pixels.
  ///@attr ref android.R.styleable\#TextView_autoSizeStepGranularity
  ///@see \#setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)
  int getAutoSizeStepGranularity() => jniAccessors.callMethodWithArgs(reference,
      _id_getAutoSizeStepGranularity, jni.JniType.intType, []).integer;

  static final _id_getAutoSizeMinTextSize =
      jniAccessors.getMethodIDOf(_classRef, "getAutoSizeMinTextSize", "()I");

  /// from: public int getAutoSizeMinTextSize()
  ///
  /// @return the current auto-size minimum text size in pixels (the default is 12sp). Note that
  ///         if auto-size has not been configured this function returns {@code -1}.
  ///@attr ref android.R.styleable\#TextView_autoSizeMinTextSize
  ///@see \#setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)
  ///@see \#setAutoSizeTextTypeUniformWithPresetSizes(int[], int)
  int getAutoSizeMinTextSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutoSizeMinTextSize, jni.JniType.intType, []).integer;

  static final _id_getAutoSizeMaxTextSize =
      jniAccessors.getMethodIDOf(_classRef, "getAutoSizeMaxTextSize", "()I");

  /// from: public int getAutoSizeMaxTextSize()
  ///
  /// @return the current auto-size maximum text size in pixels (the default is 112sp). Note that
  ///         if auto-size has not been configured this function returns {@code -1}.
  ///@attr ref android.R.styleable\#TextView_autoSizeMaxTextSize
  ///@see \#setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)
  ///@see \#setAutoSizeTextTypeUniformWithPresetSizes(int[], int)
  int getAutoSizeMaxTextSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutoSizeMaxTextSize, jni.JniType.intType, []).integer;

  static final _id_getAutoSizeTextAvailableSizes = jniAccessors.getMethodIDOf(
      _classRef, "getAutoSizeTextAvailableSizes", "()[I");

  /// from: public int[] getAutoSizeTextAvailableSizes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the current auto-size {@code int} sizes array (in pixels).
  ///@see \#setAutoSizeTextTypeUniformWithConfiguration(int, int, int, int)
  ///@see \#setAutoSizeTextTypeUniformWithPresetSizes(int[], int)
  jni.JniObject getAutoSizeTextAvailableSizes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAutoSizeTextAvailableSizes,
          jni.JniType.objectType, []).object);

  static final _id_setEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)V");

  /// from: public void setEnabled(boolean enabled)
  void setEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled, jni.JniType.voidType, [enabled]).check();

  static final _id_setTypeface = jniAccessors.getMethodIDOf(
      _classRef, "setTypeface", "(Landroid/graphics/Typeface;I)V");

  /// from: public void setTypeface(android.graphics.Typeface tf, int style)
  ///
  /// Sets the typeface and style in which the text should be displayed,
  /// and turns on the fake bold and italic bits in the Paint if the
  /// Typeface that you provided does not have all the bits in the
  /// style that you specified.
  ///@attr ref android.R.styleable\#TextView_typeface
  ///@attr ref android.R.styleable\#TextView_textStyle
  ///@param tf This value may be {@code null}.
  ///@param style Value is android.graphics.Typeface\#NORMAL, android.graphics.Typeface\#BOLD, android.graphics.Typeface\#ITALIC, or android.graphics.Typeface\#BOLD_ITALIC
  void setTypeface(typeface_.Typeface tf, int style) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTypeface,
          jni.JniType.voidType, [tf.reference, style]).check();

  static final _id_getDefaultEditable =
      jniAccessors.getMethodIDOf(_classRef, "getDefaultEditable", "()Z");

  /// from: protected boolean getDefaultEditable()
  ///
  /// Subclasses override this to specify that they have a KeyListener
  /// by default even if not specifically called for in the XML options.
  bool getDefaultEditable() => jniAccessors.callMethodWithArgs(
      reference, _id_getDefaultEditable, jni.JniType.booleanType, []).boolean;

  static final _id_getDefaultMovementMethod = jniAccessors.getMethodIDOf(
      _classRef,
      "getDefaultMovementMethod",
      "()Landroid/text/method/MovementMethod;");

  /// from: protected android.text.method.MovementMethod getDefaultMovementMethod()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Subclasses override this to specify a default movement method.
  movementmethod_.MovementMethod getDefaultMovementMethod() =>
      movementmethod_.MovementMethod.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDefaultMovementMethod,
          jni.JniType.objectType, []).object);

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the text that TextView is displaying. If \#setText(CharSequence) was called
  /// with an argument of android.widget.TextView.BufferType\#SPANNABLE BufferType.SPANNABLE
  /// or android.widget.TextView.BufferType\#EDITABLE BufferType.EDITABLE, you can cast
  /// the return value from this method to Spannable or Editable, respectively.
  ///
  /// The content of the return value should not be modified. If you want a modifiable one, you
  /// should make your own copy first.
  ///
  ///@return The text displayed by the text view.
  ///@attr ref android.R.styleable\#TextView_text
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_length =
      jniAccessors.getMethodIDOf(_classRef, "length", "()I");

  /// from: public int length()
  ///
  /// Returns the length, in characters, of the text managed by this TextView
  ///@return The length of the text managed by the TextView in characters.
  int length() => jniAccessors.callMethodWithArgs(
      reference, _id_length, jni.JniType.intType, []).integer;

  static final _id_getEditableText = jniAccessors.getMethodIDOf(
      _classRef, "getEditableText", "()Landroid/text/Editable;");

  /// from: public android.text.Editable getEditableText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the text that TextView is displaying as an Editable object. If the text is not
  /// editable, null is returned.
  ///@see \#getText
  editable_.Editable getEditableText() =>
      editable_.Editable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getEditableText, jni.JniType.objectType, []).object);

  static final _id_getLineHeight =
      jniAccessors.getMethodIDOf(_classRef, "getLineHeight", "()I");

  /// from: public int getLineHeight()
  ///
  /// Gets the vertical distance between lines of text, in pixels.
  /// Note that markup within the text can cause individual lines
  /// to be taller or shorter than this height, and the layout may
  /// contain additional first-or last-line padding.
  ///@return The height of one standard line in pixels.
  int getLineHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getLineHeight, jni.JniType.intType, []).integer;

  static final _id_getLayout = jniAccessors.getMethodIDOf(
      _classRef, "getLayout", "()Landroid/text/Layout;");

  /// from: public final android.text.Layout getLayout()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the android.text.Layout that is currently being used to display the text.
  /// This value can be null if the text or width has recently changed.
  ///@return The Layout that is currently being used to display the text.
  layout_.Layout getLayout() =>
      layout_.Layout.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLayout, jni.JniType.objectType, []).object);

  static final _id_getKeyListener = jniAccessors.getMethodIDOf(
      _classRef, "getKeyListener", "()Landroid/text/method/KeyListener;");

  /// from: public final android.text.method.KeyListener getKeyListener()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current KeyListener for the TextView.
  /// This will frequently be null for non-EditText TextViews.
  ///@return the current key listener for this TextView.
  ///@attr ref android.R.styleable\#TextView_numeric
  ///@attr ref android.R.styleable\#TextView_digits
  ///@attr ref android.R.styleable\#TextView_phoneNumber
  ///@attr ref android.R.styleable\#TextView_inputMethod
  ///@attr ref android.R.styleable\#TextView_capitalize
  ///@attr ref android.R.styleable\#TextView_autoText
  keylistener_.KeyListener getKeyListener() =>
      keylistener_.KeyListener.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeyListener, jni.JniType.objectType, []).object);

  static final _id_setKeyListener = jniAccessors.getMethodIDOf(
      _classRef, "setKeyListener", "(Landroid/text/method/KeyListener;)V");

  /// from: public void setKeyListener(android.text.method.KeyListener input)
  ///
  /// Sets the key listener to be used with this TextView.  This can be null
  /// to disallow user input.  Note that this method has significant and
  /// subtle interactions with soft keyboards and other input method:
  /// see KeyListener\#getInputType() KeyListener.getInputType()
  /// for important details.  Calling this method will replace the current
  /// content type of the text view with the content type returned by the
  /// key listener.
  ///
  /// Be warned that if you want a TextView with a key listener or movement
  /// method not to be focusable, or if you want a TextView without a
  /// key listener or movement method to be focusable, you must call
  /// \#setFocusable again after calling this to get the focusability
  /// back the way you want it.
  ///@attr ref android.R.styleable\#TextView_numeric
  ///@attr ref android.R.styleable\#TextView_digits
  ///@attr ref android.R.styleable\#TextView_phoneNumber
  ///@attr ref android.R.styleable\#TextView_inputMethod
  ///@attr ref android.R.styleable\#TextView_capitalize
  ///@attr ref android.R.styleable\#TextView_autoText
  void setKeyListener(keylistener_.KeyListener input) =>
      jniAccessors.callMethodWithArgs(reference, _id_setKeyListener,
          jni.JniType.voidType, [input.reference]).check();

  static final _id_getMovementMethod = jniAccessors.getMethodIDOf(
      _classRef, "getMovementMethod", "()Landroid/text/method/MovementMethod;");

  /// from: public final android.text.method.MovementMethod getMovementMethod()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the android.text.method.MovementMethod being used for this TextView,
  /// which provides positioning, scrolling, and text selection functionality.
  /// This will frequently be null for non-EditText TextViews.
  ///@return the movement method being used for this TextView.
  ///@see android.text.method.MovementMethod
  movementmethod_.MovementMethod getMovementMethod() =>
      movementmethod_.MovementMethod.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMovementMethod, jni.JniType.objectType, []).object);

  static final _id_setMovementMethod = jniAccessors.getMethodIDOf(_classRef,
      "setMovementMethod", "(Landroid/text/method/MovementMethod;)V");

  /// from: public final void setMovementMethod(android.text.method.MovementMethod movement)
  ///
  /// Sets the android.text.method.MovementMethod for handling arrow key movement
  /// for this TextView. This can be null to disallow using the arrow keys to move the
  /// cursor or scroll the view.
  ///
  /// Be warned that if you want a TextView with a key listener or movement
  /// method not to be focusable, or if you want a TextView without a
  /// key listener or movement method to be focusable, you must call
  /// \#setFocusable again after calling this to get the focusability
  /// back the way you want it.
  void setMovementMethod(movementmethod_.MovementMethod movement) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMovementMethod,
          jni.JniType.voidType, [movement.reference]).check();

  static final _id_getTransformationMethod = jniAccessors.getMethodIDOf(
      _classRef,
      "getTransformationMethod",
      "()Landroid/text/method/TransformationMethod;");

  /// from: public final android.text.method.TransformationMethod getTransformationMethod()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current android.text.method.TransformationMethod for the TextView.
  /// This is frequently null, except for single-line and password fields.
  ///@return the current transformation method for this TextView.
  ///@attr ref android.R.styleable\#TextView_password
  ///@attr ref android.R.styleable\#TextView_singleLine
  transformationmethod_.TransformationMethod getTransformationMethod() =>
      transformationmethod_.TransformationMethod.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getTransformationMethod,
              jni.JniType.objectType, []).object);

  static final _id_setTransformationMethod = jniAccessors.getMethodIDOf(
      _classRef,
      "setTransformationMethod",
      "(Landroid/text/method/TransformationMethod;)V");

  /// from: public final void setTransformationMethod(android.text.method.TransformationMethod method)
  ///
  /// Sets the transformation that is applied to the text that this
  /// TextView is displaying.
  ///@attr ref android.R.styleable\#TextView_password
  ///@attr ref android.R.styleable\#TextView_singleLine
  void setTransformationMethod(
          transformationmethod_.TransformationMethod method) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTransformationMethod,
          jni.JniType.voidType, [method.reference]).check();

  static final _id_getCompoundPaddingTop =
      jniAccessors.getMethodIDOf(_classRef, "getCompoundPaddingTop", "()I");

  /// from: public int getCompoundPaddingTop()
  ///
  /// Returns the top padding of the view, plus space for the top
  /// Drawable if any.
  int getCompoundPaddingTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getCompoundPaddingTop, jni.JniType.intType, []).integer;

  static final _id_getCompoundPaddingBottom =
      jniAccessors.getMethodIDOf(_classRef, "getCompoundPaddingBottom", "()I");

  /// from: public int getCompoundPaddingBottom()
  ///
  /// Returns the bottom padding of the view, plus space for the bottom
  /// Drawable if any.
  int getCompoundPaddingBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getCompoundPaddingBottom, jni.JniType.intType, []).integer;

  static final _id_getCompoundPaddingLeft =
      jniAccessors.getMethodIDOf(_classRef, "getCompoundPaddingLeft", "()I");

  /// from: public int getCompoundPaddingLeft()
  ///
  /// Returns the left padding of the view, plus space for the left
  /// Drawable if any.
  int getCompoundPaddingLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getCompoundPaddingLeft, jni.JniType.intType, []).integer;

  static final _id_getCompoundPaddingRight =
      jniAccessors.getMethodIDOf(_classRef, "getCompoundPaddingRight", "()I");

  /// from: public int getCompoundPaddingRight()
  ///
  /// Returns the right padding of the view, plus space for the right
  /// Drawable if any.
  int getCompoundPaddingRight() => jniAccessors.callMethodWithArgs(
      reference, _id_getCompoundPaddingRight, jni.JniType.intType, []).integer;

  static final _id_getCompoundPaddingStart =
      jniAccessors.getMethodIDOf(_classRef, "getCompoundPaddingStart", "()I");

  /// from: public int getCompoundPaddingStart()
  ///
  /// Returns the start padding of the view, plus space for the start
  /// Drawable if any.
  int getCompoundPaddingStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getCompoundPaddingStart, jni.JniType.intType, []).integer;

  static final _id_getCompoundPaddingEnd =
      jniAccessors.getMethodIDOf(_classRef, "getCompoundPaddingEnd", "()I");

  /// from: public int getCompoundPaddingEnd()
  ///
  /// Returns the end padding of the view, plus space for the end
  /// Drawable if any.
  int getCompoundPaddingEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getCompoundPaddingEnd, jni.JniType.intType, []).integer;

  static final _id_getExtendedPaddingTop =
      jniAccessors.getMethodIDOf(_classRef, "getExtendedPaddingTop", "()I");

  /// from: public int getExtendedPaddingTop()
  ///
  /// Returns the extended top padding of the view, including both the
  /// top Drawable if any and any extra space to keep more than maxLines
  /// of text from showing.  It is only valid to call this after measuring.
  int getExtendedPaddingTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getExtendedPaddingTop, jni.JniType.intType, []).integer;

  static final _id_getExtendedPaddingBottom =
      jniAccessors.getMethodIDOf(_classRef, "getExtendedPaddingBottom", "()I");

  /// from: public int getExtendedPaddingBottom()
  ///
  /// Returns the extended bottom padding of the view, including both the
  /// bottom Drawable if any and any extra space to keep more than maxLines
  /// of text from showing.  It is only valid to call this after measuring.
  int getExtendedPaddingBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getExtendedPaddingBottom, jni.JniType.intType, []).integer;

  static final _id_getTotalPaddingLeft =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPaddingLeft", "()I");

  /// from: public int getTotalPaddingLeft()
  ///
  /// Returns the total left padding of the view, including the left
  /// Drawable if any.
  int getTotalPaddingLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPaddingLeft, jni.JniType.intType, []).integer;

  static final _id_getTotalPaddingRight =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPaddingRight", "()I");

  /// from: public int getTotalPaddingRight()
  ///
  /// Returns the total right padding of the view, including the right
  /// Drawable if any.
  int getTotalPaddingRight() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPaddingRight, jni.JniType.intType, []).integer;

  static final _id_getTotalPaddingStart =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPaddingStart", "()I");

  /// from: public int getTotalPaddingStart()
  ///
  /// Returns the total start padding of the view, including the start
  /// Drawable if any.
  int getTotalPaddingStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPaddingStart, jni.JniType.intType, []).integer;

  static final _id_getTotalPaddingEnd =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPaddingEnd", "()I");

  /// from: public int getTotalPaddingEnd()
  ///
  /// Returns the total end padding of the view, including the end
  /// Drawable if any.
  int getTotalPaddingEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPaddingEnd, jni.JniType.intType, []).integer;

  static final _id_getTotalPaddingTop =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPaddingTop", "()I");

  /// from: public int getTotalPaddingTop()
  ///
  /// Returns the total top padding of the view, including the top
  /// Drawable if any, the extra space to keep more than maxLines
  /// from showing, and the vertical offset for gravity, if any.
  int getTotalPaddingTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPaddingTop, jni.JniType.intType, []).integer;

  static final _id_getTotalPaddingBottom =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPaddingBottom", "()I");

  /// from: public int getTotalPaddingBottom()
  ///
  /// Returns the total bottom padding of the view, including the bottom
  /// Drawable if any, the extra space to keep more than maxLines
  /// from showing, and the vertical offset for gravity, if any.
  int getTotalPaddingBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPaddingBottom, jni.JniType.intType, []).integer;

  static final _id_setCompoundDrawables = jniAccessors.getMethodIDOf(
      _classRef,
      "setCompoundDrawables",
      "(Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setCompoundDrawables(android.graphics.drawable.Drawable left, android.graphics.drawable.Drawable top, android.graphics.drawable.Drawable right, android.graphics.drawable.Drawable bottom)
  ///
  /// Sets the Drawables (if any) to appear to the left of, above, to the
  /// right of, and below the text. Use {@code null} if you do not want a
  /// Drawable there. The Drawables must already have had
  /// Drawable\#setBounds called.
  ///
  /// Calling this method will overwrite any Drawables previously set using
  /// \#setCompoundDrawablesRelative or related methods.
  ///@attr ref android.R.styleable\#TextView_drawableLeft
  ///@attr ref android.R.styleable\#TextView_drawableTop
  ///@attr ref android.R.styleable\#TextView_drawableRight
  ///@attr ref android.R.styleable\#TextView_drawableBottom
  ///@param left This value may be {@code null}.
  ///@param top This value may be {@code null}.
  ///@param right This value may be {@code null}.
  ///@param bottom This value may be {@code null}.
  void setCompoundDrawables(drawable_.Drawable left, drawable_.Drawable top,
          drawable_.Drawable right, drawable_.Drawable bottom) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setCompoundDrawables, jni.JniType.voidType, [
        left.reference,
        top.reference,
        right.reference,
        bottom.reference
      ]).check();

  static final _id_setCompoundDrawablesWithIntrinsicBounds =
      jniAccessors.getMethodIDOf(
          _classRef, "setCompoundDrawablesWithIntrinsicBounds", "(IIII)V");

  /// from: public void setCompoundDrawablesWithIntrinsicBounds(int left, int top, int right, int bottom)
  ///
  /// Sets the Drawables (if any) to appear to the left of, above, to the
  /// right of, and below the text. Use 0 if you do not want a Drawable there.
  /// The Drawables' bounds will be set to their intrinsic bounds.
  ///
  /// Calling this method will overwrite any Drawables previously set using
  /// \#setCompoundDrawablesRelative or related methods.
  ///@param left Resource identifier of the left Drawable.
  ///@param top Resource identifier of the top Drawable.
  ///@param right Resource identifier of the right Drawable.
  ///@param bottom Resource identifier of the bottom Drawable.
  ///@attr ref android.R.styleable\#TextView_drawableLeft
  ///@attr ref android.R.styleable\#TextView_drawableTop
  ///@attr ref android.R.styleable\#TextView_drawableRight
  ///@attr ref android.R.styleable\#TextView_drawableBottom
  void setCompoundDrawablesWithIntrinsicBounds(
          int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCompoundDrawablesWithIntrinsicBounds,
          jni.JniType.voidType,
          [left, top, right, bottom]).check();

  static final _id_setCompoundDrawablesWithIntrinsicBounds1 =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setCompoundDrawablesWithIntrinsicBounds",
          "(Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setCompoundDrawablesWithIntrinsicBounds(android.graphics.drawable.Drawable left, android.graphics.drawable.Drawable top, android.graphics.drawable.Drawable right, android.graphics.drawable.Drawable bottom)
  ///
  /// Sets the Drawables (if any) to appear to the left of, above, to the
  /// right of, and below the text. Use {@code null} if you do not want a
  /// Drawable there. The Drawables' bounds will be set to their intrinsic
  /// bounds.
  ///
  /// Calling this method will overwrite any Drawables previously set using
  /// \#setCompoundDrawablesRelative or related methods.
  ///@attr ref android.R.styleable\#TextView_drawableLeft
  ///@attr ref android.R.styleable\#TextView_drawableTop
  ///@attr ref android.R.styleable\#TextView_drawableRight
  ///@attr ref android.R.styleable\#TextView_drawableBottom
  ///@param left This value may be {@code null}.
  ///@param top This value may be {@code null}.
  ///@param right This value may be {@code null}.
  ///@param bottom This value may be {@code null}.
  void setCompoundDrawablesWithIntrinsicBounds1(
          drawable_.Drawable left,
          drawable_.Drawable top,
          drawable_.Drawable right,
          drawable_.Drawable bottom) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_setCompoundDrawablesWithIntrinsicBounds1, jni.JniType.voidType, [
        left.reference,
        top.reference,
        right.reference,
        bottom.reference
      ]).check();

  static final _id_setCompoundDrawablesRelative = jniAccessors.getMethodIDOf(
      _classRef,
      "setCompoundDrawablesRelative",
      "(Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setCompoundDrawablesRelative(android.graphics.drawable.Drawable start, android.graphics.drawable.Drawable top, android.graphics.drawable.Drawable end, android.graphics.drawable.Drawable bottom)
  ///
  /// Sets the Drawables (if any) to appear to the start of, above, to the end
  /// of, and below the text. Use {@code null} if you do not want a Drawable
  /// there. The Drawables must already have had Drawable\#setBounds
  /// called.
  ///
  /// Calling this method will overwrite any Drawables previously set using
  /// \#setCompoundDrawables or related methods.
  ///@attr ref android.R.styleable\#TextView_drawableStart
  ///@attr ref android.R.styleable\#TextView_drawableTop
  ///@attr ref android.R.styleable\#TextView_drawableEnd
  ///@attr ref android.R.styleable\#TextView_drawableBottom
  ///@param start This value may be {@code null}.
  ///@param top This value may be {@code null}.
  ///@param end This value may be {@code null}.
  ///@param bottom This value may be {@code null}.
  void setCompoundDrawablesRelative(
          drawable_.Drawable start,
          drawable_.Drawable top,
          drawable_.Drawable end,
          drawable_.Drawable bottom) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setCompoundDrawablesRelative, jni.JniType.voidType, [
        start.reference,
        top.reference,
        end.reference,
        bottom.reference
      ]).check();

  static final _id_setCompoundDrawablesRelativeWithIntrinsicBounds =
      jniAccessors.getMethodIDOf(_classRef,
          "setCompoundDrawablesRelativeWithIntrinsicBounds", "(IIII)V");

  /// from: public void setCompoundDrawablesRelativeWithIntrinsicBounds(int start, int top, int end, int bottom)
  ///
  /// Sets the Drawables (if any) to appear to the start of, above, to the end
  /// of, and below the text. Use 0 if you do not want a Drawable there. The
  /// Drawables' bounds will be set to their intrinsic bounds.
  ///
  /// Calling this method will overwrite any Drawables previously set using
  /// \#setCompoundDrawables or related methods.
  ///@param start Resource identifier of the start Drawable.
  ///@param top Resource identifier of the top Drawable.
  ///@param end Resource identifier of the end Drawable.
  ///@param bottom Resource identifier of the bottom Drawable.
  ///@attr ref android.R.styleable\#TextView_drawableStart
  ///@attr ref android.R.styleable\#TextView_drawableTop
  ///@attr ref android.R.styleable\#TextView_drawableEnd
  ///@attr ref android.R.styleable\#TextView_drawableBottom
  void setCompoundDrawablesRelativeWithIntrinsicBounds(
          int start, int top, int end, int bottom) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCompoundDrawablesRelativeWithIntrinsicBounds,
          jni.JniType.voidType,
          [start, top, end, bottom]).check();

  static final _id_setCompoundDrawablesRelativeWithIntrinsicBounds1 =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setCompoundDrawablesRelativeWithIntrinsicBounds",
          "(Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setCompoundDrawablesRelativeWithIntrinsicBounds(android.graphics.drawable.Drawable start, android.graphics.drawable.Drawable top, android.graphics.drawable.Drawable end, android.graphics.drawable.Drawable bottom)
  ///
  /// Sets the Drawables (if any) to appear to the start of, above, to the end
  /// of, and below the text. Use {@code null} if you do not want a Drawable
  /// there. The Drawables' bounds will be set to their intrinsic bounds.
  ///
  /// Calling this method will overwrite any Drawables previously set using
  /// \#setCompoundDrawables or related methods.
  ///@attr ref android.R.styleable\#TextView_drawableStart
  ///@attr ref android.R.styleable\#TextView_drawableTop
  ///@attr ref android.R.styleable\#TextView_drawableEnd
  ///@attr ref android.R.styleable\#TextView_drawableBottom
  ///@param start This value may be {@code null}.
  ///@param top This value may be {@code null}.
  ///@param end This value may be {@code null}.
  ///@param bottom This value may be {@code null}.
  void setCompoundDrawablesRelativeWithIntrinsicBounds1(
          drawable_.Drawable start,
          drawable_.Drawable top,
          drawable_.Drawable end,
          drawable_.Drawable bottom) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCompoundDrawablesRelativeWithIntrinsicBounds1,
          jni.JniType.voidType, [
        start.reference,
        top.reference,
        end.reference,
        bottom.reference
      ]).check();

  static final _id_getCompoundDrawables = jniAccessors.getMethodIDOf(_classRef,
      "getCompoundDrawables", "()[Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable[] getCompoundDrawables()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns drawables for the left, top, right, and bottom borders.
  ///@attr ref android.R.styleable\#TextView_drawableLeft
  ///@attr ref android.R.styleable\#TextView_drawableTop
  ///@attr ref android.R.styleable\#TextView_drawableRight
  ///@attr ref android.R.styleable\#TextView_drawableBottom
  ///@return This value will never be {@code null}.
  jni.JniObject getCompoundDrawables() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCompoundDrawables, jni.JniType.objectType, []).object);

  static final _id_getCompoundDrawablesRelative = jniAccessors.getMethodIDOf(
      _classRef,
      "getCompoundDrawablesRelative",
      "()[Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable[] getCompoundDrawablesRelative()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns drawables for the start, top, end, and bottom borders.
  ///@attr ref android.R.styleable\#TextView_drawableStart
  ///@attr ref android.R.styleable\#TextView_drawableTop
  ///@attr ref android.R.styleable\#TextView_drawableEnd
  ///@attr ref android.R.styleable\#TextView_drawableBottom
  ///@return This value will never be {@code null}.
  jni.JniObject getCompoundDrawablesRelative() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCompoundDrawablesRelative, jni.JniType.objectType, []).object);

  static final _id_setCompoundDrawablePadding = jniAccessors.getMethodIDOf(
      _classRef, "setCompoundDrawablePadding", "(I)V");

  /// from: public void setCompoundDrawablePadding(int pad)
  ///
  /// Sets the size of the padding between the compound drawables and
  /// the text.
  ///@attr ref android.R.styleable\#TextView_drawablePadding
  void setCompoundDrawablePadding(int pad) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCompoundDrawablePadding,
      jni.JniType.voidType,
      [pad]).check();

  static final _id_getCompoundDrawablePadding = jniAccessors.getMethodIDOf(
      _classRef, "getCompoundDrawablePadding", "()I");

  /// from: public int getCompoundDrawablePadding()
  ///
  /// Returns the padding between the compound drawables and the text.
  ///@attr ref android.R.styleable\#TextView_drawablePadding
  int getCompoundDrawablePadding() => jniAccessors.callMethodWithArgs(reference,
      _id_getCompoundDrawablePadding, jni.JniType.intType, []).integer;

  static final _id_setCompoundDrawableTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "setCompoundDrawableTintList",
      "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setCompoundDrawableTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the compound drawables. Does not modify the
  /// current tint mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// Subsequent calls to
  /// \#setCompoundDrawables(Drawable, Drawable, Drawable, Drawable)
  /// and related methods will automatically mutate the drawables and apply
  /// the specified tint and tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#TextView_drawableTint
  ///@see \#getCompoundDrawableTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setCompoundDrawableTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCompoundDrawableTintList,
          jni.JniType.voidType,
          [tint.reference]).check();

  static final _id_getCompoundDrawableTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "getCompoundDrawableTintList",
      "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getCompoundDrawableTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the tint applied to the compound drawables
  ///@attr ref android.R.styleable\#TextView_drawableTint
  ///@see \#setCompoundDrawableTintList(ColorStateList)
  colorstatelist_.ColorStateList getCompoundDrawableTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCompoundDrawableTintList,
          jni.JniType.objectType, []).object);

  static final _id_setCompoundDrawableTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "setCompoundDrawableTintMode",
      "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setCompoundDrawableTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setCompoundDrawableTintList(ColorStateList) to the compound
  /// drawables. The default mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#TextView_drawableTintMode
  ///@see \#setCompoundDrawableTintList(ColorStateList)
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setCompoundDrawableTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCompoundDrawableTintMode,
          jni.JniType.voidType,
          [tintMode.reference]).check();

  static final _id_getCompoundDrawableTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "getCompoundDrawableTintMode",
      "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getCompoundDrawableTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the blending mode used to apply the tint to the compound
  /// drawables, if specified.
  ///@return the blending mode used to apply the tint to the compound
  ///         drawables
  ///@attr ref android.R.styleable\#TextView_drawableTintMode
  ///@see \#setCompoundDrawableTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getCompoundDrawableTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCompoundDrawableTintMode,
          jni.JniType.objectType, []).object);

  static final _id_setPadding =
      jniAccessors.getMethodIDOf(_classRef, "setPadding", "(IIII)V");

  /// from: public void setPadding(int left, int top, int right, int bottom)
  ///
  /// @inheritDoc
  void setPadding(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPadding,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_setPaddingRelative =
      jniAccessors.getMethodIDOf(_classRef, "setPaddingRelative", "(IIII)V");

  /// from: public void setPaddingRelative(int start, int top, int end, int bottom)
  ///
  /// @inheritDoc
  void setPaddingRelative(int start, int top, int end, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPaddingRelative,
          jni.JniType.voidType, [start, top, end, bottom]).check();

  static final _id_setFirstBaselineToTopHeight = jniAccessors.getMethodIDOf(
      _classRef, "setFirstBaselineToTopHeight", "(I)V");

  /// from: public void setFirstBaselineToTopHeight(int firstBaselineToTopHeight)
  ///
  /// Updates the top padding of the TextView so that {@code firstBaselineToTopHeight} is
  /// equal to the distance between the firt text baseline and the top of this TextView.
  /// <strong>Note</strong> that if {@code FontMetrics.top} or {@code FontMetrics.ascent} was
  /// already greater than {@code firstBaselineToTopHeight}, the top padding is not updated.
  ///@param firstBaselineToTopHeight distance between first baseline to top of the container
  ///      in pixels
  ///
  /// Value is 0 or greater
  ///@see \#getFirstBaselineToTopHeight()
  ///@see \#setPadding(int, int, int, int)
  ///@see \#setPaddingRelative(int, int, int, int)
  ///@attr ref android.R.styleable\#TextView_firstBaselineToTopHeight
  void setFirstBaselineToTopHeight(int firstBaselineToTopHeight) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setFirstBaselineToTopHeight,
          jni.JniType.voidType,
          [firstBaselineToTopHeight]).check();

  static final _id_setLastBaselineToBottomHeight = jniAccessors.getMethodIDOf(
      _classRef, "setLastBaselineToBottomHeight", "(I)V");

  /// from: public void setLastBaselineToBottomHeight(int lastBaselineToBottomHeight)
  ///
  /// Updates the bottom padding of the TextView so that {@code lastBaselineToBottomHeight} is
  /// equal to the distance between the last text baseline and the bottom of this TextView.
  /// <strong>Note</strong> that if {@code FontMetrics.bottom} or {@code FontMetrics.descent} was
  /// already greater than {@code lastBaselineToBottomHeight}, the bottom padding is not updated.
  ///@param lastBaselineToBottomHeight distance between last baseline to bottom of the container
  ///      in pixels
  ///
  /// Value is 0 or greater
  ///@see \#getLastBaselineToBottomHeight()
  ///@see \#setPadding(int, int, int, int)
  ///@see \#setPaddingRelative(int, int, int, int)
  ///@attr ref android.R.styleable\#TextView_lastBaselineToBottomHeight
  void setLastBaselineToBottomHeight(int lastBaselineToBottomHeight) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setLastBaselineToBottomHeight,
          jni.JniType.voidType,
          [lastBaselineToBottomHeight]).check();

  static final _id_getFirstBaselineToTopHeight = jniAccessors.getMethodIDOf(
      _classRef, "getFirstBaselineToTopHeight", "()I");

  /// from: public int getFirstBaselineToTopHeight()
  ///
  /// Returns the distance between the first text baseline and the top of this TextView.
  ///@see \#setFirstBaselineToTopHeight(int)
  ///@attr ref android.R.styleable\#TextView_firstBaselineToTopHeight
  int getFirstBaselineToTopHeight() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getFirstBaselineToTopHeight,
      jni.JniType.intType, []).integer;

  static final _id_getLastBaselineToBottomHeight = jniAccessors.getMethodIDOf(
      _classRef, "getLastBaselineToBottomHeight", "()I");

  /// from: public int getLastBaselineToBottomHeight()
  ///
  /// Returns the distance between the last text baseline and the bottom of this TextView.
  ///@see \#setLastBaselineToBottomHeight(int)
  ///@attr ref android.R.styleable\#TextView_lastBaselineToBottomHeight
  int getLastBaselineToBottomHeight() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLastBaselineToBottomHeight,
      jni.JniType.intType, []).integer;

  static final _id_getAutoLinkMask =
      jniAccessors.getMethodIDOf(_classRef, "getAutoLinkMask", "()I");

  /// from: public final int getAutoLinkMask()
  ///
  /// Gets the autolink mask of the text.  See android.text.util.Linkify\#ALL Linkify.ALL and peers for
  /// possible values.
  ///@attr ref android.R.styleable\#TextView_autoLink
  int getAutoLinkMask() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutoLinkMask, jni.JniType.intType, []).integer;

  static final _id_setTextAppearance =
      jniAccessors.getMethodIDOf(_classRef, "setTextAppearance", "(I)V");

  /// from: public void setTextAppearance(int resId)
  ///
  /// Sets the text appearance from the specified style resource.
  ///
  /// Use a framework-defined {@code TextAppearance} style like
  /// android.R.style\#TextAppearance_Material_Body1 @android:style/TextAppearance.Material.Body1
  /// or see android.R.styleable\#TextAppearance TextAppearance for the
  /// set of attributes that can be used in a custom style.
  ///@param resId the resource identifier of the style to apply
  ///@attr ref android.R.styleable\#TextView_textAppearance
  void setTextAppearance(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextAppearance, jni.JniType.voidType, [resId]).check();

  static final _id_setTextAppearance1 = jniAccessors.getMethodIDOf(
      _classRef, "setTextAppearance", "(Landroid/content/Context;I)V");

  /// from: public void setTextAppearance(android.content.Context context, int resId)
  ///
  /// Sets the text color, size, style, hint color, and highlight color
  /// from the specified TextAppearance resource.
  ///@deprecated Use \#setTextAppearance(int) instead.
  void setTextAppearance1(context_.Context context, int resId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextAppearance1,
          jni.JniType.voidType, [context.reference, resId]).check();

  static final _id_getTextLocale = jniAccessors.getMethodIDOf(
      _classRef, "getTextLocale", "()Ljava/util/Locale;");

  /// from: public java.util.Locale getTextLocale()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the default primary Locale of the text in this TextView. This will always be
  /// the first member of \#getTextLocales().
  ///@return the default primary Locale of the text in this TextView.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getTextLocale() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextLocale, jni.JniType.objectType, []).object);

  static final _id_getTextLocales = jniAccessors.getMethodIDOf(
      _classRef, "getTextLocales", "()Landroid/os/LocaleList;");

  /// from: public android.os.LocaleList getTextLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the default LocaleList of the text in this TextView.
  ///@return the default LocaleList of the text in this TextView.
  ///
  /// This value will never be {@code null}.
  localelist_.LocaleList getTextLocales() =>
      localelist_.LocaleList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextLocales, jni.JniType.objectType, []).object);

  static final _id_setTextLocale = jniAccessors.getMethodIDOf(
      _classRef, "setTextLocale", "(Ljava/util/Locale;)V");

  /// from: public void setTextLocale(java.util.Locale locale)
  ///
  /// Set the default Locale of the text in this TextView to a one-member
  /// LocaleList containing just the given Locale.
  ///@param locale the Locale for drawing text, must not be null.
  ///
  /// This value must never be {@code null}.
  ///@see \#setTextLocales
  void setTextLocale(jni.JniObject locale) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextLocale,
      jni.JniType.voidType,
      [locale.reference]).check();

  static final _id_setTextLocales = jniAccessors.getMethodIDOf(
      _classRef, "setTextLocales", "(Landroid/os/LocaleList;)V");

  /// from: public void setTextLocales(android.os.LocaleList locales)
  ///
  /// Set the default LocaleList of the text in this TextView to the given value.
  ///
  /// This value is used to choose appropriate typefaces for ambiguous characters (typically used
  /// for CJK locales to disambiguate Hanzi/Kanji/Hanja characters). It also affects
  /// other aspects of text display, including line breaking.
  ///@param locales the LocaleList for drawing text, must not be null or empty.
  ///
  /// This value must never be {@code null}.
  ///@see Paint\#setTextLocales
  void setTextLocales(localelist_.LocaleList locales) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextLocales,
          jni.JniType.voidType, [locales.reference]).check();

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: protected void onConfigurationChanged(android.content.res.Configuration newConfig)
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_getTextSize =
      jniAccessors.getMethodIDOf(_classRef, "getTextSize", "()F");

  /// from: public float getTextSize()
  ///
  /// @return the size (in pixels) of the default text size in this TextView.
  double getTextSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSize, jni.JniType.floatType, []).float;

  static final _id_setTextSize =
      jniAccessors.getMethodIDOf(_classRef, "setTextSize", "(F)V");

  /// from: public void setTextSize(float size)
  ///
  /// Set the default text size to the given value, interpreted as "scaled
  /// pixel" units.  This size is adjusted based on the current density and
  /// user font size preference.
  ///
  /// Note: if this TextView has the auto-size feature enabled than this function is no-op.
  ///@param size The scaled pixel size.
  ///@attr ref android.R.styleable\#TextView_textSize
  void setTextSize(double size) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextSize, jni.JniType.voidType, [size]).check();

  static final _id_setTextSize1 =
      jniAccessors.getMethodIDOf(_classRef, "setTextSize", "(IF)V");

  /// from: public void setTextSize(int unit, float size)
  ///
  /// Set the default text size to a given unit and value. See TypedValue for the possible dimension units.
  ///
  /// Note: if this TextView has the auto-size feature enabled than this function is no-op.
  ///@param unit The desired dimension unit.
  ///@param size The desired size in the given units.
  ///@attr ref android.R.styleable\#TextView_textSize
  void setTextSize1(int unit, double size) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextSize1, jni.JniType.voidType, [unit, size]).check();

  static final _id_getTextScaleX =
      jniAccessors.getMethodIDOf(_classRef, "getTextScaleX", "()F");

  /// from: public float getTextScaleX()
  ///
  /// Gets the extent by which text should be stretched horizontally.
  /// This will usually be 1.0.
  ///@return The horizontal scale factor.
  double getTextScaleX() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextScaleX, jni.JniType.floatType, []).float;

  static final _id_setTextScaleX =
      jniAccessors.getMethodIDOf(_classRef, "setTextScaleX", "(F)V");

  /// from: public void setTextScaleX(float size)
  ///
  /// Sets the horizontal scale factor for text. The default value
  /// is 1.0. Values greater than 1.0 stretch the text wider.
  /// Values less than 1.0 make the text narrower. By default, this value is 1.0.
  ///@param size The horizontal scale factor.
  ///@attr ref android.R.styleable\#TextView_textScaleX
  void setTextScaleX(double size) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextScaleX, jni.JniType.voidType, [size]).check();

  static final _id_setTypeface1 = jniAccessors.getMethodIDOf(
      _classRef, "setTypeface", "(Landroid/graphics/Typeface;)V");

  /// from: public void setTypeface(android.graphics.Typeface tf)
  ///
  /// Sets the typeface and style in which the text should be displayed.
  /// Note that not all Typeface families actually have bold and italic
  /// variants, so you may need to use
  /// \#setTypeface(Typeface, int) to get the appearance
  /// that you actually want.
  ///@see \#getTypeface()
  ///@attr ref android.R.styleable\#TextView_fontFamily
  ///@attr ref android.R.styleable\#TextView_typeface
  ///@attr ref android.R.styleable\#TextView_textStyle
  ///@param tf This value may be {@code null}.
  void setTypeface1(typeface_.Typeface tf) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTypeface1,
      jni.JniType.voidType,
      [tf.reference]).check();

  static final _id_getTypeface = jniAccessors.getMethodIDOf(
      _classRef, "getTypeface", "()Landroid/graphics/Typeface;");

  /// from: public android.graphics.Typeface getTypeface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current Typeface that is used to style the text.
  ///@return The current Typeface.
  ///@see \#setTypeface(Typeface)
  ///@attr ref android.R.styleable\#TextView_fontFamily
  ///@attr ref android.R.styleable\#TextView_typeface
  ///@attr ref android.R.styleable\#TextView_textStyle
  typeface_.Typeface getTypeface() =>
      typeface_.Typeface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTypeface, jni.JniType.objectType, []).object);

  static final _id_setElegantTextHeight =
      jniAccessors.getMethodIDOf(_classRef, "setElegantTextHeight", "(Z)V");

  /// from: public void setElegantTextHeight(boolean elegant)
  ///
  /// Set the TextView's elegant height metrics flag. This setting selects font
  /// variants that have not been compacted to fit Latin-based vertical
  /// metrics, and also increases top and bottom bounds to provide more space.
  ///@param elegant set the paint's elegant metrics flag.
  ///@see \#isElegantTextHeight()
  ///@see Paint\#isElegantTextHeight()
  ///@attr ref android.R.styleable\#TextView_elegantTextHeight
  void setElegantTextHeight(bool elegant) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setElegantTextHeight,
      jni.JniType.voidType,
      [elegant]).check();

  static final _id_setFallbackLineSpacing =
      jniAccessors.getMethodIDOf(_classRef, "setFallbackLineSpacing", "(Z)V");

  /// from: public void setFallbackLineSpacing(boolean enabled)
  ///
  /// Set whether to respect the ascent and descent of the fallback fonts that are used in
  /// displaying the text (which is needed to avoid text from consecutive lines running into
  /// each other). If set, fallback fonts that end up getting used can increase the ascent
  /// and descent of the lines that they are used on.
  /// <p/>
  /// It is required to be true if text could be in languages like Burmese or Tibetan where text
  /// is typically much taller or deeper than Latin text.
  ///@param enabled whether to expand linespacing based on fallback fonts, {@code true} by default
  ///@see StaticLayout.Builder\#setUseLineSpacingFromFallbacks(boolean)
  ///@attr ref android.R.styleable\#TextView_fallbackLineSpacing
  void setFallbackLineSpacing(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFallbackLineSpacing,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_isFallbackLineSpacing =
      jniAccessors.getMethodIDOf(_classRef, "isFallbackLineSpacing", "()Z");

  /// from: public boolean isFallbackLineSpacing()
  ///
  /// @return whether fallback line spacing is enabled, {@code true} by default
  ///@see \#setFallbackLineSpacing(boolean)
  ///@attr ref android.R.styleable\#TextView_fallbackLineSpacing
  bool isFallbackLineSpacing() => jniAccessors.callMethodWithArgs(reference,
      _id_isFallbackLineSpacing, jni.JniType.booleanType, []).boolean;

  static final _id_isElegantTextHeight =
      jniAccessors.getMethodIDOf(_classRef, "isElegantTextHeight", "()Z");

  /// from: public boolean isElegantTextHeight()
  ///
  /// Get the value of the TextView's elegant height metrics flag. This setting selects font
  /// variants that have not been compacted to fit Latin-based vertical
  /// metrics, and also increases top and bottom bounds to provide more space.
  ///@return {@code true} if the elegant height metrics flag is set.
  ///@see \#setElegantTextHeight(boolean)
  ///@see Paint\#setElegantTextHeight(boolean)
  bool isElegantTextHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_isElegantTextHeight, jni.JniType.booleanType, []).boolean;

  static final _id_getLetterSpacing =
      jniAccessors.getMethodIDOf(_classRef, "getLetterSpacing", "()F");

  /// from: public float getLetterSpacing()
  ///
  /// Gets the text letter-space value, which determines the spacing between characters.
  /// The value returned is in ems. Normally, this value is 0.0.
  ///@return The text letter-space value in ems.
  ///@see \#setLetterSpacing(float)
  ///@see Paint\#setLetterSpacing
  double getLetterSpacing() => jniAccessors.callMethodWithArgs(
      reference, _id_getLetterSpacing, jni.JniType.floatType, []).float;

  static final _id_setLetterSpacing =
      jniAccessors.getMethodIDOf(_classRef, "setLetterSpacing", "(F)V");

  /// from: public void setLetterSpacing(float letterSpacing)
  ///
  /// Sets text letter-spacing in em units.  Typical values
  /// for slight expansion will be around 0.05.  Negative values tighten text.
  ///@see \#getLetterSpacing()
  ///@see Paint\#getLetterSpacing
  ///@param letterSpacing A text letter-space value in ems.
  ///@attr ref android.R.styleable\#TextView_letterSpacing
  void setLetterSpacing(double letterSpacing) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLetterSpacing,
          jni.JniType.voidType, [letterSpacing]).check();

  static final _id_getFontFeatureSettings = jniAccessors.getMethodIDOf(
      _classRef, "getFontFeatureSettings", "()Ljava/lang/String;");

  /// from: public java.lang.String getFontFeatureSettings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the font feature settings. The format is the same as the CSS
  /// font-feature-settings attribute:
  /// <a href="https://www.w3.org/TR/css-fonts-3/\#font-feature-settings-prop">
  ///     https://www.w3.org/TR/css-fonts-3/\#font-feature-settings-prop</a>
  ///@return the currently set font feature settings.  Default is null.
  ///@see \#setFontFeatureSettings(String)
  ///@see Paint\#setFontFeatureSettings(String) Paint.setFontFeatureSettings(String)
  jni.JniString getFontFeatureSettings() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFontFeatureSettings, jni.JniType.objectType, []).object);

  static final _id_getFontVariationSettings = jniAccessors.getMethodIDOf(
      _classRef, "getFontVariationSettings", "()Ljava/lang/String;");

  /// from: public java.lang.String getFontVariationSettings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the font variation settings.
  ///@return the currently set font variation settings.  Returns null if no variation is
  /// specified.
  ///@see \#setFontVariationSettings(String)
  ///@see Paint\#setFontVariationSettings(String) Paint.setFontVariationSettings(String)
  jni.JniString getFontVariationSettings() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFontVariationSettings, jni.JniType.objectType, []).object);

  static final _id_setBreakStrategy =
      jniAccessors.getMethodIDOf(_classRef, "setBreakStrategy", "(I)V");

  /// from: public void setBreakStrategy(int breakStrategy)
  ///
  /// Sets the break strategy for breaking paragraphs into lines. The default value for
  /// TextView is Layout\#BREAK_STRATEGY_HIGH_QUALITY, and the default value for
  /// EditText is Layout\#BREAK_STRATEGY_SIMPLE, the latter to avoid the
  /// text "dancing" when being edited.
  ///@attr ref android.R.styleable\#TextView_breakStrategy
  ///@see \#getBreakStrategy()
  ///@param breakStrategy Value is android.text.Layout\#BREAK_STRATEGY_SIMPLE, android.text.Layout\#BREAK_STRATEGY_HIGH_QUALITY, or android.text.Layout\#BREAK_STRATEGY_BALANCED
  void setBreakStrategy(int breakStrategy) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBreakStrategy,
      jni.JniType.voidType,
      [breakStrategy]).check();

  static final _id_getBreakStrategy =
      jniAccessors.getMethodIDOf(_classRef, "getBreakStrategy", "()I");

  /// from: public int getBreakStrategy()
  ///
  /// Gets the current strategy for breaking paragraphs into lines.
  ///@return the current strategy for breaking paragraphs into lines.
  ///
  /// Value is android.text.Layout\#BREAK_STRATEGY_SIMPLE, android.text.Layout\#BREAK_STRATEGY_HIGH_QUALITY, or android.text.Layout\#BREAK_STRATEGY_BALANCED
  ///@attr ref android.R.styleable\#TextView_breakStrategy
  ///@see \#setBreakStrategy(int)
  int getBreakStrategy() => jniAccessors.callMethodWithArgs(
      reference, _id_getBreakStrategy, jni.JniType.intType, []).integer;

  static final _id_setHyphenationFrequency =
      jniAccessors.getMethodIDOf(_classRef, "setHyphenationFrequency", "(I)V");

  /// from: public void setHyphenationFrequency(int hyphenationFrequency)
  ///
  /// Sets the frequency of automatic hyphenation to use when determining word breaks.
  /// The default value for both TextView and EditText is
  /// Layout\#HYPHENATION_FREQUENCY_NORMAL.
  /// Note that the default hyphenation frequency value is set from the theme.
  ///@param hyphenationFrequency The hyphenation frequency to use.
  /// Value is android.text.Layout\#HYPHENATION_FREQUENCY_NORMAL, android.text.Layout\#HYPHENATION_FREQUENCY_FULL, or android.text.Layout\#HYPHENATION_FREQUENCY_NONE
  ///@attr ref android.R.styleable\#TextView_hyphenationFrequency
  ///@see \#getHyphenationFrequency()
  void setHyphenationFrequency(int hyphenationFrequency) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHyphenationFrequency,
          jni.JniType.voidType, [hyphenationFrequency]).check();

  static final _id_getHyphenationFrequency =
      jniAccessors.getMethodIDOf(_classRef, "getHyphenationFrequency", "()I");

  /// from: public int getHyphenationFrequency()
  ///
  /// Gets the current frequency of automatic hyphenation to be used when determining word breaks.
  ///@return the current frequency of automatic hyphenation to be used when determining word
  /// breaks.
  ///
  /// Value is android.text.Layout\#HYPHENATION_FREQUENCY_NORMAL, android.text.Layout\#HYPHENATION_FREQUENCY_FULL, or android.text.Layout\#HYPHENATION_FREQUENCY_NONE
  ///@attr ref android.R.styleable\#TextView_hyphenationFrequency
  ///@see \#setHyphenationFrequency(int)
  int getHyphenationFrequency() => jniAccessors.callMethodWithArgs(
      reference, _id_getHyphenationFrequency, jni.JniType.intType, []).integer;

  static final _id_getTextMetricsParams = jniAccessors.getMethodIDOf(_classRef,
      "getTextMetricsParams", "()Landroid/text/PrecomputedText\$Params;");

  /// from: public android.text.PrecomputedText.Params getTextMetricsParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the parameters for text layout precomputation, for use with PrecomputedText.
  ///@return a current PrecomputedText.Params
  /// This value will never be {@code null}.
  ///@see PrecomputedText
  precomputedtext_.PrecomputedText_Params getTextMetricsParams() =>
      precomputedtext_.PrecomputedText_Params.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getTextMetricsParams,
              jni.JniType.objectType, []).object);

  static final _id_setTextMetricsParams = jniAccessors.getMethodIDOf(_classRef,
      "setTextMetricsParams", "(Landroid/text/PrecomputedText\$Params;)V");

  /// from: public void setTextMetricsParams(android.text.PrecomputedText.Params params)
  ///
  /// Apply the text layout parameter.
  ///
  /// Update the TextView parameters to be compatible with PrecomputedText.Params.
  ///@see PrecomputedText
  ///@param params This value must never be {@code null}.
  void setTextMetricsParams(precomputedtext_.PrecomputedText_Params params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextMetricsParams,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_setJustificationMode =
      jniAccessors.getMethodIDOf(_classRef, "setJustificationMode", "(I)V");

  /// from: public void setJustificationMode(int justificationMode)
  ///
  /// Set justification mode. The default value is Layout\#JUSTIFICATION_MODE_NONE. If the
  /// last line is too short for justification, the last line will be displayed with the
  /// alignment set by android.view.View\#setTextAlignment.
  ///@see \#getJustificationMode()
  ///@param justificationMode Value is android.text.Layout\#JUSTIFICATION_MODE_NONE, or android.text.Layout\#JUSTIFICATION_MODE_INTER_WORD
  ///@return Value is android.text.Layout\#JUSTIFICATION_MODE_NONE, or android.text.Layout\#JUSTIFICATION_MODE_INTER_WORD
  void setJustificationMode(int justificationMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setJustificationMode,
          jni.JniType.voidType, [justificationMode]).check();

  static final _id_getJustificationMode =
      jniAccessors.getMethodIDOf(_classRef, "getJustificationMode", "()I");

  /// from: public int getJustificationMode()
  ///
  /// @return true if currently paragraph justification mode.
  ///
  /// Value is android.text.Layout\#JUSTIFICATION_MODE_NONE, or android.text.Layout\#JUSTIFICATION_MODE_INTER_WORD
  ///@see \#setJustificationMode(int)
  int getJustificationMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getJustificationMode, jni.JniType.intType, []).integer;

  static final _id_setFontFeatureSettings = jniAccessors.getMethodIDOf(
      _classRef, "setFontFeatureSettings", "(Ljava/lang/String;)V");

  /// from: public void setFontFeatureSettings(java.lang.String fontFeatureSettings)
  ///
  /// Sets font feature settings. The format is the same as the CSS
  /// font-feature-settings attribute:
  /// <a href="https://www.w3.org/TR/css-fonts-3/\#font-feature-settings-prop">
  ///     https://www.w3.org/TR/css-fonts-3/\#font-feature-settings-prop</a>
  ///@param fontFeatureSettings font feature settings represented as CSS compatible string
  ///
  /// This value may be {@code null}.
  ///@see \#getFontFeatureSettings()
  ///@see Paint\#getFontFeatureSettings() Paint.getFontFeatureSettings()
  ///@attr ref android.R.styleable\#TextView_fontFeatureSettings
  void setFontFeatureSettings(jni.JniString fontFeatureSettings) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFontFeatureSettings,
          jni.JniType.voidType, [fontFeatureSettings.reference]).check();

  static final _id_setFontVariationSettings = jniAccessors.getMethodIDOf(
      _classRef, "setFontVariationSettings", "(Ljava/lang/String;)Z");

  /// from: public boolean setFontVariationSettings(java.lang.String fontVariationSettings)
  ///
  /// Sets TrueType or OpenType font variation settings. The settings string is constructed from
  /// multiple pairs of axis tag and style values. The axis tag must contain four ASCII characters
  /// and must be wrapped with single quotes (U+0027) or double quotes (U+0022). Axis strings that
  /// are longer or shorter than four characters, or contain characters outside of U+0020..U+007E
  /// are invalid. If a specified axis name is not defined in the font, the settings will be
  /// ignored.
  ///
  ///
  /// Examples,
  /// <ul>
  /// <li>Set font width to 150.
  /// <pre>
  /// <code>
  ///   TextView textView = (TextView) findViewById(R.id.textView);
  ///   textView.setFontVariationSettings("'wdth' 150");
  /// </code>
  /// </pre>
  /// </li>
  ///
  /// <li>Set the font slant to 20 degrees and ask for italic style.
  /// <pre>
  /// <code>
  ///   TextView textView = (TextView) findViewById(R.id.textView);
  ///   textView.setFontVariationSettings("'slnt' 20, 'ital' 1");
  /// </code>
  /// </pre>
  ///
  ///
  /// </li>
  /// </ul>
  ///@param fontVariationSettings font variation settings. You can pass null or empty string as
  ///                              no variation settings.
  /// This value may be {@code null}.
  ///@return true if the given settings is effective to at least one font file underlying this
  ///         TextView. This function also returns true for empty settings string. Otherwise
  ///         returns false.
  ///@throws IllegalArgumentException If given string is not a valid font variation settings
  ///                                  format.
  ///@see \#getFontVariationSettings()
  ///@see FontVariationAxis
  bool setFontVariationSettings(jni.JniString fontVariationSettings) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFontVariationSettings,
          jni.JniType.booleanType, [fontVariationSettings.reference]).boolean;

  static final _id_setTextColor =
      jniAccessors.getMethodIDOf(_classRef, "setTextColor", "(I)V");

  /// from: public void setTextColor(int color)
  ///
  /// Sets the text color for all the states (normal, selected,
  /// focused) to be this color.
  ///@param color A color value in the form 0xAARRGGBB.
  /// Do not pass a resource ID. To get a color value from a resource ID, call
  /// android.support.v4.content.ContextCompat\#getColor(Context, int) getColor.
  ///@see \#setTextColor(ColorStateList)
  ///@see \#getTextColors()
  ///@attr ref android.R.styleable\#TextView_textColor
  void setTextColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextColor, jni.JniType.voidType, [color]).check();

  static final _id_setTextColor1 = jniAccessors.getMethodIDOf(
      _classRef, "setTextColor", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTextColor(android.content.res.ColorStateList colors)
  ///
  /// Sets the text color.
  ///@see \#setTextColor(int)
  ///@see \#getTextColors()
  ///@see \#setHintTextColor(ColorStateList)
  ///@see \#setLinkTextColor(ColorStateList)
  ///@attr ref android.R.styleable\#TextView_textColor
  void setTextColor1(colorstatelist_.ColorStateList colors) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextColor1,
          jni.JniType.voidType, [colors.reference]).check();

  static final _id_getTextColors = jniAccessors.getMethodIDOf(
      _classRef, "getTextColors", "()Landroid/content/res/ColorStateList;");

  /// from: public final android.content.res.ColorStateList getTextColors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the text colors for the different states (normal, selected, focused) of the TextView.
  ///@see \#setTextColor(ColorStateList)
  ///@see \#setTextColor(int)
  ///@attr ref android.R.styleable\#TextView_textColor
  colorstatelist_.ColorStateList getTextColors() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextColors, jni.JniType.objectType, []).object);

  static final _id_getCurrentTextColor =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentTextColor", "()I");

  /// from: public final int getCurrentTextColor()
  ///
  /// Return the current color selected for normal text.
  ///@return Returns the current text color.
  int getCurrentTextColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentTextColor, jni.JniType.intType, []).integer;

  static final _id_setHighlightColor =
      jniAccessors.getMethodIDOf(_classRef, "setHighlightColor", "(I)V");

  /// from: public void setHighlightColor(int color)
  ///
  /// Sets the color used to display the selection highlight.
  ///@attr ref android.R.styleable\#TextView_textColorHighlight
  void setHighlightColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setHighlightColor, jni.JniType.voidType, [color]).check();

  static final _id_getHighlightColor =
      jniAccessors.getMethodIDOf(_classRef, "getHighlightColor", "()I");

  /// from: public int getHighlightColor()
  ///
  /// @return the color used to display the selection highlight
  ///@see \#setHighlightColor(int)
  ///@attr ref android.R.styleable\#TextView_textColorHighlight
  int getHighlightColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getHighlightColor, jni.JniType.intType, []).integer;

  static final _id_setShowSoftInputOnFocus =
      jniAccessors.getMethodIDOf(_classRef, "setShowSoftInputOnFocus", "(Z)V");

  /// from: public final void setShowSoftInputOnFocus(boolean show)
  ///
  /// Sets whether the soft input method will be made visible when this
  /// TextView gets focused. The default is true.
  void setShowSoftInputOnFocus(bool show0) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setShowSoftInputOnFocus,
      jni.JniType.voidType,
      [show0]).check();

  static final _id_getShowSoftInputOnFocus =
      jniAccessors.getMethodIDOf(_classRef, "getShowSoftInputOnFocus", "()Z");

  /// from: public final boolean getShowSoftInputOnFocus()
  ///
  /// Returns whether the soft input method will be made visible when this
  /// TextView gets focused. The default is true.
  bool getShowSoftInputOnFocus() => jniAccessors.callMethodWithArgs(reference,
      _id_getShowSoftInputOnFocus, jni.JniType.booleanType, []).boolean;

  static final _id_setShadowLayer =
      jniAccessors.getMethodIDOf(_classRef, "setShadowLayer", "(FFFI)V");

  /// from: public void setShadowLayer(float radius, float dx, float dy, int color)
  ///
  /// Gives the text a shadow of the specified blur radius and color, the specified
  /// distance from its drawn position.
  ///
  /// The text shadow produced does not interact with the properties on view
  /// that are responsible for real time shadows,
  /// View\#getElevation() elevation and
  /// View\#getTranslationZ() translationZ.
  ///@see Paint\#setShadowLayer(float, float, float, int)
  ///@attr ref android.R.styleable\#TextView_shadowColor
  ///@attr ref android.R.styleable\#TextView_shadowDx
  ///@attr ref android.R.styleable\#TextView_shadowDy
  ///@attr ref android.R.styleable\#TextView_shadowRadius
  void setShadowLayer(double radius, double dx, double dy, int color) =>
      jniAccessors.callMethodWithArgs(reference, _id_setShadowLayer,
          jni.JniType.voidType, [radius, dx, dy, color]).check();

  static final _id_getShadowRadius =
      jniAccessors.getMethodIDOf(_classRef, "getShadowRadius", "()F");

  /// from: public float getShadowRadius()
  ///
  /// Gets the radius of the shadow layer.
  ///@return the radius of the shadow layer. If 0, the shadow layer is not visible
  ///@see \#setShadowLayer(float, float, float, int)
  ///@attr ref android.R.styleable\#TextView_shadowRadius
  double getShadowRadius() => jniAccessors.callMethodWithArgs(
      reference, _id_getShadowRadius, jni.JniType.floatType, []).float;

  static final _id_getShadowDx =
      jniAccessors.getMethodIDOf(_classRef, "getShadowDx", "()F");

  /// from: public float getShadowDx()
  ///
  /// @return the horizontal offset of the shadow layer
  ///@see \#setShadowLayer(float, float, float, int)
  ///@attr ref android.R.styleable\#TextView_shadowDx
  double getShadowDx() => jniAccessors.callMethodWithArgs(
      reference, _id_getShadowDx, jni.JniType.floatType, []).float;

  static final _id_getShadowDy =
      jniAccessors.getMethodIDOf(_classRef, "getShadowDy", "()F");

  /// from: public float getShadowDy()
  ///
  /// Gets the vertical offset of the shadow layer.
  ///@return The vertical offset of the shadow layer.
  ///@see \#setShadowLayer(float, float, float, int)
  ///@attr ref android.R.styleable\#TextView_shadowDy
  double getShadowDy() => jniAccessors.callMethodWithArgs(
      reference, _id_getShadowDy, jni.JniType.floatType, []).float;

  static final _id_getShadowColor =
      jniAccessors.getMethodIDOf(_classRef, "getShadowColor", "()I");

  /// from: public int getShadowColor()
  ///
  /// Gets the color of the shadow layer.
  ///@return the color of the shadow layer
  ///@see \#setShadowLayer(float, float, float, int)
  ///@attr ref android.R.styleable\#TextView_shadowColor
  int getShadowColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getShadowColor, jni.JniType.intType, []).integer;

  static final _id_getPaint = jniAccessors.getMethodIDOf(
      _classRef, "getPaint", "()Landroid/text/TextPaint;");

  /// from: public android.text.TextPaint getPaint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the TextPaint used for the text.
  /// Use this only to consult the Paint's properties and not to change them.
  ///@return The base paint used for the text.
  textpaint_.TextPaint getPaint() =>
      textpaint_.TextPaint.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPaint, jni.JniType.objectType, []).object);

  static final _id_setAutoLinkMask =
      jniAccessors.getMethodIDOf(_classRef, "setAutoLinkMask", "(I)V");

  /// from: public final void setAutoLinkMask(int mask)
  ///
  /// Sets the autolink mask of the text.  See android.text.util.Linkify\#ALL Linkify.ALL and peers for
  /// possible values.
  ///@attr ref android.R.styleable\#TextView_autoLink
  void setAutoLinkMask(int mask) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutoLinkMask, jni.JniType.voidType, [mask]).check();

  static final _id_setLinksClickable =
      jniAccessors.getMethodIDOf(_classRef, "setLinksClickable", "(Z)V");

  /// from: public final void setLinksClickable(boolean whether)
  ///
  /// Sets whether the movement method will automatically be set to
  /// LinkMovementMethod if \#setAutoLinkMask has been
  /// set to nonzero and links are detected in \#setText.
  /// The default is true.
  ///@attr ref android.R.styleable\#TextView_linksClickable
  void setLinksClickable(bool whether) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLinksClickable,
      jni.JniType.voidType,
      [whether]).check();

  static final _id_getLinksClickable =
      jniAccessors.getMethodIDOf(_classRef, "getLinksClickable", "()Z");

  /// from: public final boolean getLinksClickable()
  ///
  /// Returns whether the movement method will automatically be set to
  /// LinkMovementMethod if \#setAutoLinkMask has been
  /// set to nonzero and links are detected in \#setText.
  /// The default is true.
  ///@attr ref android.R.styleable\#TextView_linksClickable
  bool getLinksClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_getLinksClickable, jni.JniType.booleanType, []).boolean;

  static final _id_getUrls = jniAccessors.getMethodIDOf(
      _classRef, "getUrls", "()[Landroid/text/style/URLSpan;");

  /// from: public android.text.style.URLSpan[] getUrls()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of android.text.style.URLSpan URLSpans attached to the text
  /// (by Linkify or otherwise) if any.  You can call
  /// URLSpan\#getURL on them to find where they link to
  /// or use Spanned\#getSpanStart and Spanned\#getSpanEnd
  /// to find the region of the text they are attached to.
  jni.JniObject getUrls() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUrls, jni.JniType.objectType, []).object);

  static final _id_setHintTextColor =
      jniAccessors.getMethodIDOf(_classRef, "setHintTextColor", "(I)V");

  /// from: public final void setHintTextColor(int color)
  ///
  /// Sets the color of the hint text for all the states (disabled, focussed, selected...) of this
  /// TextView.
  ///@see \#setHintTextColor(ColorStateList)
  ///@see \#getHintTextColors()
  ///@see \#setTextColor(int)
  ///@attr ref android.R.styleable\#TextView_textColorHint
  void setHintTextColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setHintTextColor, jni.JniType.voidType, [color]).check();

  static final _id_setHintTextColor1 = jniAccessors.getMethodIDOf(
      _classRef, "setHintTextColor", "(Landroid/content/res/ColorStateList;)V");

  /// from: public final void setHintTextColor(android.content.res.ColorStateList colors)
  ///
  /// Sets the color of the hint text.
  ///@see \#getHintTextColors()
  ///@see \#setHintTextColor(int)
  ///@see \#setTextColor(ColorStateList)
  ///@see \#setLinkTextColor(ColorStateList)
  ///@attr ref android.R.styleable\#TextView_textColorHint
  void setHintTextColor1(colorstatelist_.ColorStateList colors) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHintTextColor1,
          jni.JniType.voidType, [colors.reference]).check();

  static final _id_getHintTextColors = jniAccessors.getMethodIDOf(
      _classRef, "getHintTextColors", "()Landroid/content/res/ColorStateList;");

  /// from: public final android.content.res.ColorStateList getHintTextColors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the color of the hint text, for the different states of this TextView.
  ///@see \#setHintTextColor(ColorStateList)
  ///@see \#setHintTextColor(int)
  ///@see \#setTextColor(ColorStateList)
  ///@see \#setLinkTextColor(ColorStateList)
  ///@attr ref android.R.styleable\#TextView_textColorHint
  colorstatelist_.ColorStateList getHintTextColors() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHintTextColors, jni.JniType.objectType, []).object);

  static final _id_getCurrentHintTextColor =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentHintTextColor", "()I");

  /// from: public final int getCurrentHintTextColor()
  ///
  /// Return the current color selected to paint the hint text.
  ///
  ///@return Returns the current hint text color.
  int getCurrentHintTextColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentHintTextColor, jni.JniType.intType, []).integer;

  static final _id_setLinkTextColor =
      jniAccessors.getMethodIDOf(_classRef, "setLinkTextColor", "(I)V");

  /// from: public final void setLinkTextColor(int color)
  ///
  /// Sets the color of links in the text.
  ///@see \#setLinkTextColor(ColorStateList)
  ///@see \#getLinkTextColors()
  ///@attr ref android.R.styleable\#TextView_textColorLink
  void setLinkTextColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setLinkTextColor, jni.JniType.voidType, [color]).check();

  static final _id_setLinkTextColor1 = jniAccessors.getMethodIDOf(
      _classRef, "setLinkTextColor", "(Landroid/content/res/ColorStateList;)V");

  /// from: public final void setLinkTextColor(android.content.res.ColorStateList colors)
  ///
  /// Sets the color of links in the text.
  ///@see \#setLinkTextColor(int)
  ///@see \#getLinkTextColors()
  ///@see \#setTextColor(ColorStateList)
  ///@see \#setHintTextColor(ColorStateList)
  ///@attr ref android.R.styleable\#TextView_textColorLink
  void setLinkTextColor1(colorstatelist_.ColorStateList colors) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLinkTextColor1,
          jni.JniType.voidType, [colors.reference]).check();

  static final _id_getLinkTextColors = jniAccessors.getMethodIDOf(
      _classRef, "getLinkTextColors", "()Landroid/content/res/ColorStateList;");

  /// from: public final android.content.res.ColorStateList getLinkTextColors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the list of colors used to paint the links in the text, for the different states of
  /// this TextView
  ///@see \#setLinkTextColor(ColorStateList)
  ///@see \#setLinkTextColor(int)
  ///@attr ref android.R.styleable\#TextView_textColorLink
  colorstatelist_.ColorStateList getLinkTextColors() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLinkTextColors, jni.JniType.objectType, []).object);

  static final _id_setGravity =
      jniAccessors.getMethodIDOf(_classRef, "setGravity", "(I)V");

  /// from: public void setGravity(int gravity)
  ///
  /// Sets the horizontal alignment of the text and the
  /// vertical gravity that will be used when there is extra space
  /// in the TextView beyond what is required for the text itself.
  ///@see android.view.Gravity
  ///@attr ref android.R.styleable\#TextView_gravity
  void setGravity(int gravity) => jniAccessors.callMethodWithArgs(
      reference, _id_setGravity, jni.JniType.voidType, [gravity]).check();

  static final _id_getGravity =
      jniAccessors.getMethodIDOf(_classRef, "getGravity", "()I");

  /// from: public int getGravity()
  ///
  /// Returns the horizontal and vertical alignment of this TextView.
  ///@see android.view.Gravity
  ///@attr ref android.R.styleable\#TextView_gravity
  int getGravity() => jniAccessors.callMethodWithArgs(
      reference, _id_getGravity, jni.JniType.intType, []).integer;

  static final _id_getPaintFlags =
      jniAccessors.getMethodIDOf(_classRef, "getPaintFlags", "()I");

  /// from: public int getPaintFlags()
  ///
  /// Gets the flags on the Paint being used to display the text.
  ///@return The flags on the Paint being used to display the text.
  ///@see Paint\#getFlags
  int getPaintFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getPaintFlags, jni.JniType.intType, []).integer;

  static final _id_setPaintFlags =
      jniAccessors.getMethodIDOf(_classRef, "setPaintFlags", "(I)V");

  /// from: public void setPaintFlags(int flags)
  ///
  /// Sets flags on the Paint being used to display the text and
  /// reflows the text if they are different from the old flags.
  ///@see Paint\#setFlags
  void setPaintFlags(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_setPaintFlags, jni.JniType.voidType, [flags]).check();

  static final _id_setHorizontallyScrolling =
      jniAccessors.getMethodIDOf(_classRef, "setHorizontallyScrolling", "(Z)V");

  /// from: public void setHorizontallyScrolling(boolean whether)
  ///
  /// Sets whether the text should be allowed to be wider than the
  /// View is.  If false, it will be wrapped to the width of the View.
  ///@attr ref android.R.styleable\#TextView_scrollHorizontally
  void setHorizontallyScrolling(bool whether) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHorizontallyScrolling,
          jni.JniType.voidType, [whether]).check();

  static final _id_setMinLines =
      jniAccessors.getMethodIDOf(_classRef, "setMinLines", "(I)V");

  /// from: public void setMinLines(int minLines)
  ///
  /// Sets the height of the TextView to be at least {@code minLines} tall.
  ///
  /// This value is used for height calculation if LayoutParams does not force TextView to have an
  /// exact height. Setting this value overrides other previous minimum height configurations such
  /// as \#setMinHeight(int) or \#setHeight(int). \#setSingleLine() will set
  /// this value to 1.
  ///@param minLines the minimum height of TextView in terms of number of lines
  ///@see \#getMinLines()
  ///@see \#setLines(int)
  ///@attr ref android.R.styleable\#TextView_minLines
  void setMinLines(int minLines) => jniAccessors.callMethodWithArgs(
      reference, _id_setMinLines, jni.JniType.voidType, [minLines]).check();

  static final _id_getMinLines =
      jniAccessors.getMethodIDOf(_classRef, "getMinLines", "()I");

  /// from: public int getMinLines()
  ///
  /// Returns the minimum height of TextView in terms of number of lines or -1 if the minimum
  /// height was set using \#setMinHeight(int) or \#setHeight(int).
  ///@return the minimum height of TextView in terms of number of lines or -1 if the minimum
  ///         height is not defined in lines
  ///@see \#setMinLines(int)
  ///@see \#setLines(int)
  ///@attr ref android.R.styleable\#TextView_minLines
  int getMinLines() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinLines, jni.JniType.intType, []).integer;

  static final _id_setMinHeight =
      jniAccessors.getMethodIDOf(_classRef, "setMinHeight", "(I)V");

  /// from: public void setMinHeight(int minPixels)
  ///
  /// Sets the height of the TextView to be at least {@code minPixels} tall.
  ///
  /// This value is used for height calculation if LayoutParams does not force TextView to have an
  /// exact height. Setting this value overrides previous minimum height configurations such as
  /// \#setMinLines(int) or \#setLines(int).
  ///
  /// The value given here is different than \#setMinimumHeight(int). Between
  /// {@code minHeight} and the value set in \#setMinimumHeight(int), the greater one is
  /// used to decide the final height.
  ///@param minPixels the minimum height of TextView in terms of pixels
  ///@see \#getMinHeight()
  ///@see \#setHeight(int)
  ///@attr ref android.R.styleable\#TextView_minHeight
  void setMinHeight(int minPixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setMinHeight, jni.JniType.voidType, [minPixels]).check();

  static final _id_getMinHeight =
      jniAccessors.getMethodIDOf(_classRef, "getMinHeight", "()I");

  /// from: public int getMinHeight()
  ///
  /// Returns the minimum height of TextView in terms of pixels or -1 if the minimum height was
  /// set using \#setMinLines(int) or \#setLines(int).
  ///@return the minimum height of TextView in terms of pixels or -1 if the minimum height is not
  ///         defined in pixels
  ///@see \#setMinHeight(int)
  ///@see \#setHeight(int)
  ///@attr ref android.R.styleable\#TextView_minHeight
  int getMinHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinHeight, jni.JniType.intType, []).integer;

  static final _id_setMaxLines =
      jniAccessors.getMethodIDOf(_classRef, "setMaxLines", "(I)V");

  /// from: public void setMaxLines(int maxLines)
  ///
  /// Sets the height of the TextView to be at most {@code maxLines} tall.
  ///
  /// This value is used for height calculation if LayoutParams does not force TextView to have an
  /// exact height. Setting this value overrides previous maximum height configurations such as
  /// \#setMaxHeight(int) or \#setLines(int).
  ///@param maxLines the maximum height of TextView in terms of number of lines
  ///@see \#getMaxLines()
  ///@see \#setLines(int)
  ///@attr ref android.R.styleable\#TextView_maxLines
  void setMaxLines(int maxLines) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxLines, jni.JniType.voidType, [maxLines]).check();

  static final _id_getMaxLines =
      jniAccessors.getMethodIDOf(_classRef, "getMaxLines", "()I");

  /// from: public int getMaxLines()
  ///
  /// Returns the maximum height of TextView in terms of number of lines or -1 if the
  /// maximum height was set using \#setMaxHeight(int) or \#setHeight(int).
  ///@return the maximum height of TextView in terms of number of lines. -1 if the maximum height
  ///         is not defined in lines.
  ///@see \#setMaxLines(int)
  ///@see \#setLines(int)
  ///@attr ref android.R.styleable\#TextView_maxLines
  int getMaxLines() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxLines, jni.JniType.intType, []).integer;

  static final _id_setMaxHeight =
      jniAccessors.getMethodIDOf(_classRef, "setMaxHeight", "(I)V");

  /// from: public void setMaxHeight(int maxPixels)
  ///
  /// Sets the height of the TextView to be at most {@code maxPixels} tall.
  ///
  /// This value is used for height calculation if LayoutParams does not force TextView to have an
  /// exact height. Setting this value overrides previous maximum height configurations such as
  /// \#setMaxLines(int) or \#setLines(int).
  ///@param maxPixels the maximum height of TextView in terms of pixels
  ///@see \#getMaxHeight()
  ///@see \#setHeight(int)
  ///@attr ref android.R.styleable\#TextView_maxHeight
  void setMaxHeight(int maxPixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxHeight, jni.JniType.voidType, [maxPixels]).check();

  static final _id_getMaxHeight =
      jniAccessors.getMethodIDOf(_classRef, "getMaxHeight", "()I");

  /// from: public int getMaxHeight()
  ///
  /// Returns the maximum height of TextView in terms of pixels or -1 if the maximum height was
  /// set using \#setMaxLines(int) or \#setLines(int).
  ///@return the maximum height of TextView in terms of pixels or -1 if the maximum height
  ///         is not defined in pixels
  ///@see \#setMaxHeight(int)
  ///@see \#setHeight(int)
  ///@attr ref android.R.styleable\#TextView_maxHeight
  int getMaxHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxHeight, jni.JniType.intType, []).integer;

  static final _id_setLines =
      jniAccessors.getMethodIDOf(_classRef, "setLines", "(I)V");

  /// from: public void setLines(int lines)
  ///
  /// Sets the height of the TextView to be exactly {@code lines} tall.
  ///
  /// This value is used for height calculation if LayoutParams does not force TextView to have an
  /// exact height. Setting this value overrides previous minimum/maximum height configurations
  /// such as \#setMinLines(int) or \#setMaxLines(int). \#setSingleLine() will
  /// set this value to 1.
  ///@param lines the exact height of the TextView in terms of lines
  ///@see \#setHeight(int)
  ///@attr ref android.R.styleable\#TextView_lines
  void setLines(int lines) => jniAccessors.callMethodWithArgs(
      reference, _id_setLines, jni.JniType.voidType, [lines]).check();

  static final _id_setHeight =
      jniAccessors.getMethodIDOf(_classRef, "setHeight", "(I)V");

  /// from: public void setHeight(int pixels)
  ///
  /// Sets the height of the TextView to be exactly <code>pixels</code> tall.
  ///
  /// This value is used for height calculation if LayoutParams does not force TextView to have an
  /// exact height. Setting this value overrides previous minimum/maximum height configurations
  /// such as \#setMinHeight(int) or \#setMaxHeight(int).
  ///@param pixels the exact height of the TextView in terms of pixels
  ///@see \#setLines(int)
  ///@attr ref android.R.styleable\#TextView_height
  void setHeight(int pixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setHeight, jni.JniType.voidType, [pixels]).check();

  static final _id_setMinEms =
      jniAccessors.getMethodIDOf(_classRef, "setMinEms", "(I)V");

  /// from: public void setMinEms(int minEms)
  ///
  /// Sets the width of the TextView to be at least {@code minEms} wide.
  ///
  /// This value is used for width calculation if LayoutParams does not force TextView to have an
  /// exact width. Setting this value overrides previous minimum width configurations such as
  /// \#setMinWidth(int) or \#setWidth(int).
  ///@param minEms the minimum width of TextView in terms of ems
  ///@see \#getMinEms()
  ///@see \#setEms(int)
  ///@attr ref android.R.styleable\#TextView_minEms
  void setMinEms(int minEms) => jniAccessors.callMethodWithArgs(
      reference, _id_setMinEms, jni.JniType.voidType, [minEms]).check();

  static final _id_getMinEms =
      jniAccessors.getMethodIDOf(_classRef, "getMinEms", "()I");

  /// from: public int getMinEms()
  ///
  /// Returns the minimum width of TextView in terms of ems or -1 if the minimum width was set
  /// using \#setMinWidth(int) or \#setWidth(int).
  ///@return the minimum width of TextView in terms of ems. -1 if the minimum width is not
  ///         defined in ems
  ///@see \#setMinEms(int)
  ///@see \#setEms(int)
  ///@attr ref android.R.styleable\#TextView_minEms
  int getMinEms() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinEms, jni.JniType.intType, []).integer;

  static final _id_setMinWidth =
      jniAccessors.getMethodIDOf(_classRef, "setMinWidth", "(I)V");

  /// from: public void setMinWidth(int minPixels)
  ///
  /// Sets the width of the TextView to be at least {@code minPixels} wide.
  ///
  /// This value is used for width calculation if LayoutParams does not force TextView to have an
  /// exact width. Setting this value overrides previous minimum width configurations such as
  /// \#setMinEms(int) or \#setEms(int).
  ///
  /// The value given here is different than \#setMinimumWidth(int). Between
  /// {@code minWidth} and the value set in \#setMinimumWidth(int), the greater one is used
  /// to decide the final width.
  ///@param minPixels the minimum width of TextView in terms of pixels
  ///@see \#getMinWidth()
  ///@see \#setWidth(int)
  ///@attr ref android.R.styleable\#TextView_minWidth
  void setMinWidth(int minPixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setMinWidth, jni.JniType.voidType, [minPixels]).check();

  static final _id_getMinWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMinWidth", "()I");

  /// from: public int getMinWidth()
  ///
  /// Returns the minimum width of TextView in terms of pixels or -1 if the minimum width was set
  /// using \#setMinEms(int) or \#setEms(int).
  ///@return the minimum width of TextView in terms of pixels or -1 if the minimum width is not
  ///         defined in pixels
  ///@see \#setMinWidth(int)
  ///@see \#setWidth(int)
  ///@attr ref android.R.styleable\#TextView_minWidth
  int getMinWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinWidth, jni.JniType.intType, []).integer;

  static final _id_setMaxEms =
      jniAccessors.getMethodIDOf(_classRef, "setMaxEms", "(I)V");

  /// from: public void setMaxEms(int maxEms)
  ///
  /// Sets the width of the TextView to be at most {@code maxEms} wide.
  ///
  /// This value is used for width calculation if LayoutParams does not force TextView to have an
  /// exact width. Setting this value overrides previous maximum width configurations such as
  /// \#setMaxWidth(int) or \#setWidth(int).
  ///@param maxEms the maximum width of TextView in terms of ems
  ///@see \#getMaxEms()
  ///@see \#setEms(int)
  ///@attr ref android.R.styleable\#TextView_maxEms
  void setMaxEms(int maxEms) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxEms, jni.JniType.voidType, [maxEms]).check();

  static final _id_getMaxEms =
      jniAccessors.getMethodIDOf(_classRef, "getMaxEms", "()I");

  /// from: public int getMaxEms()
  ///
  /// Returns the maximum width of TextView in terms of ems or -1 if the maximum width was set
  /// using \#setMaxWidth(int) or \#setWidth(int).
  ///@return the maximum width of TextView in terms of ems or -1 if the maximum width is not
  ///         defined in ems
  ///@see \#setMaxEms(int)
  ///@see \#setEms(int)
  ///@attr ref android.R.styleable\#TextView_maxEms
  int getMaxEms() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxEms, jni.JniType.intType, []).integer;

  static final _id_setMaxWidth =
      jniAccessors.getMethodIDOf(_classRef, "setMaxWidth", "(I)V");

  /// from: public void setMaxWidth(int maxPixels)
  ///
  /// Sets the width of the TextView to be at most {@code maxPixels} wide.
  ///
  /// This value is used for width calculation if LayoutParams does not force TextView to have an
  /// exact width. Setting this value overrides previous maximum width configurations such as
  /// \#setMaxEms(int) or \#setEms(int).
  ///@param maxPixels the maximum width of TextView in terms of pixels
  ///@see \#getMaxWidth()
  ///@see \#setWidth(int)
  ///@attr ref android.R.styleable\#TextView_maxWidth
  void setMaxWidth(int maxPixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxWidth, jni.JniType.voidType, [maxPixels]).check();

  static final _id_getMaxWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMaxWidth", "()I");

  /// from: public int getMaxWidth()
  ///
  /// Returns the maximum width of TextView in terms of pixels or -1 if the maximum width was set
  /// using \#setMaxEms(int) or \#setEms(int).
  ///@return the maximum width of TextView in terms of pixels. -1 if the maximum width is not
  ///         defined in pixels
  ///@see \#setMaxWidth(int)
  ///@see \#setWidth(int)
  ///@attr ref android.R.styleable\#TextView_maxWidth
  int getMaxWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxWidth, jni.JniType.intType, []).integer;

  static final _id_setEms =
      jniAccessors.getMethodIDOf(_classRef, "setEms", "(I)V");

  /// from: public void setEms(int ems)
  ///
  /// Sets the width of the TextView to be exactly {@code ems} wide.
  ///
  /// This value is used for width calculation if LayoutParams does not force TextView to have an
  /// exact width. Setting this value overrides previous minimum/maximum configurations such as
  /// \#setMinEms(int) or \#setMaxEms(int).
  ///@param ems the exact width of the TextView in terms of ems
  ///@see \#setWidth(int)
  ///@attr ref android.R.styleable\#TextView_ems
  void setEms(int ems) => jniAccessors.callMethodWithArgs(
      reference, _id_setEms, jni.JniType.voidType, [ems]).check();

  static final _id_setWidth =
      jniAccessors.getMethodIDOf(_classRef, "setWidth", "(I)V");

  /// from: public void setWidth(int pixels)
  ///
  /// Sets the width of the TextView to be exactly {@code pixels} wide.
  ///
  /// This value is used for width calculation if LayoutParams does not force TextView to have an
  /// exact width. Setting this value overrides previous minimum/maximum width configurations
  /// such as \#setMinWidth(int) or \#setMaxWidth(int).
  ///@param pixels the exact width of the TextView in terms of pixels
  ///@see \#setEms(int)
  ///@attr ref android.R.styleable\#TextView_width
  void setWidth(int pixels) => jniAccessors.callMethodWithArgs(
      reference, _id_setWidth, jni.JniType.voidType, [pixels]).check();

  static final _id_setLineSpacing =
      jniAccessors.getMethodIDOf(_classRef, "setLineSpacing", "(FF)V");

  /// from: public void setLineSpacing(float add, float mult)
  ///
  /// Sets line spacing for this TextView.  Each line other than the last line will have its height
  /// multiplied by {@code mult} and have {@code add} added to it.
  ///@param add The value in pixels that should be added to each line other than the last line.
  ///            This will be applied after the multiplier
  ///@param mult The value by which each line height other than the last line will be multiplied
  ///             by
  ///@attr ref android.R.styleable\#TextView_lineSpacingExtra
  ///@attr ref android.R.styleable\#TextView_lineSpacingMultiplier
  void setLineSpacing(double add, double mult) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLineSpacing,
          jni.JniType.voidType, [add, mult]).check();

  static final _id_getLineSpacingMultiplier =
      jniAccessors.getMethodIDOf(_classRef, "getLineSpacingMultiplier", "()F");

  /// from: public float getLineSpacingMultiplier()
  ///
  /// Gets the line spacing multiplier
  ///@return the value by which each line's height is multiplied to get its actual height.
  ///@see \#setLineSpacing(float, float)
  ///@see \#getLineSpacingExtra()
  ///@attr ref android.R.styleable\#TextView_lineSpacingMultiplier
  double getLineSpacingMultiplier() => jniAccessors.callMethodWithArgs(
      reference, _id_getLineSpacingMultiplier, jni.JniType.floatType, []).float;

  static final _id_getLineSpacingExtra =
      jniAccessors.getMethodIDOf(_classRef, "getLineSpacingExtra", "()F");

  /// from: public float getLineSpacingExtra()
  ///
  /// Gets the line spacing extra space
  ///@return the extra space that is added to the height of each lines of this TextView.
  ///@see \#setLineSpacing(float, float)
  ///@see \#getLineSpacingMultiplier()
  ///@attr ref android.R.styleable\#TextView_lineSpacingExtra
  double getLineSpacingExtra() => jniAccessors.callMethodWithArgs(
      reference, _id_getLineSpacingExtra, jni.JniType.floatType, []).float;

  static final _id_setLineHeight =
      jniAccessors.getMethodIDOf(_classRef, "setLineHeight", "(I)V");

  /// from: public void setLineHeight(int lineHeight)
  ///
  /// Sets an explicit line height for this TextView. This is equivalent to the vertical distance
  /// between subsequent baselines in the TextView.
  ///@param lineHeight the line height in pixels
  ///
  /// Value is 0 or greater
  ///@see \#setLineSpacing(float, float)
  ///@see \#getLineSpacing()
  ///@attr ref android.R.styleable\#TextView_lineHeight
  void setLineHeight(int lineHeight) => jniAccessors.callMethodWithArgs(
      reference, _id_setLineHeight, jni.JniType.voidType, [lineHeight]).check();

  static final _id_append = jniAccessors.getMethodIDOf(
      _classRef, "append", "(Ljava/lang/CharSequence;)V");

  /// from: public final void append(java.lang.CharSequence text)
  ///
  /// Convenience method to append the specified text to the TextView's
  /// display buffer, upgrading it to android.widget.TextView.BufferType\#EDITABLE
  /// if it was not already editable.
  ///@param text text to be appended to the already displayed text
  void append(jni.JniObject text) => jniAccessors.callMethodWithArgs(
      reference, _id_append, jni.JniType.voidType, [text.reference]).check();

  static final _id_append1 = jniAccessors.getMethodIDOf(
      _classRef, "append", "(Ljava/lang/CharSequence;II)V");

  /// from: public void append(java.lang.CharSequence text, int start, int end)
  ///
  /// Convenience method to append the specified text slice to the TextView's
  /// display buffer, upgrading it to android.widget.TextView.BufferType\#EDITABLE
  /// if it was not already editable.
  ///@param text text to be appended to the already displayed text
  ///@param start the index of the first character in the {@code text}
  ///@param end the index of the character following the last character in the {@code text}
  ///@see Appendable\#append(CharSequence, int, int)
  void append1(jni.JniObject text, int start, int end) =>
      jniAccessors.callMethodWithArgs(reference, _id_append1,
          jni.JniType.voidType, [text.reference, start, end]).check();

  static final _id_drawableStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableStateChanged", "()V");

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_drawableStateChanged, jni.JniType.voidType, []).check();

  static final _id_drawableHotspotChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableHotspotChanged", "(FF)V");

  /// from: public void drawableHotspotChanged(float x, float y)
  void drawableHotspotChanged(double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawableHotspotChanged,
          jni.JniType.voidType, [x, y]).check();

  static final _id_onSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  parcelable_.Parcelable onSaveInstanceState() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState, jni.JniType.objectType, []).object);

  static final _id_onRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: public void onRestoreInstanceState(android.os.Parcelable state)
  void onRestoreInstanceState(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_setFreezesText =
      jniAccessors.getMethodIDOf(_classRef, "setFreezesText", "(Z)V");

  /// from: public void setFreezesText(boolean freezesText)
  ///
  /// Control whether this text view saves its entire text contents when
  /// freezing to an icicle, in addition to dynamic state such as cursor
  /// position.  By default this is false, not saving the text.  Set to true
  /// if the text in the text view is not being saved somewhere else in
  /// persistent storage (such as in a content provider) so that if the
  /// view is later thawed the user will not lose their data. For
  /// android.widget.EditText it is always enabled, regardless of
  /// the value of the attribute.
  ///@param freezesText Controls whether a frozen icicle should include the
  /// entire text data: true to include it, false to not.
  ///@attr ref android.R.styleable\#TextView_freezesText
  void setFreezesText(bool freezesText) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFreezesText,
      jni.JniType.voidType,
      [freezesText]).check();

  static final _id_getFreezesText =
      jniAccessors.getMethodIDOf(_classRef, "getFreezesText", "()Z");

  /// from: public boolean getFreezesText()
  ///
  /// Return whether this text view is including its entire text contents
  /// in frozen icicles. For android.widget.EditText it always returns true.
  ///@return Returns true if text is included, false if it isn't.
  ///@see \#setFreezesText
  bool getFreezesText() => jniAccessors.callMethodWithArgs(
      reference, _id_getFreezesText, jni.JniType.booleanType, []).boolean;

  static final _id_setEditableFactory = jniAccessors.getMethodIDOf(
      _classRef, "setEditableFactory", "(Landroid/text/Editable\$Factory;)V");

  /// from: public final void setEditableFactory(android.text.Editable.Factory factory)
  ///
  /// Sets the Factory used to create new Editable Editables.
  ///@param factory android.text.Editable.Factory Editable.Factory to be used
  ///@see android.text.Editable.Factory
  ///@see android.widget.TextView.BufferType\#EDITABLE
  void setEditableFactory(editable_.Editable_Factory factory0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEditableFactory,
          jni.JniType.voidType, [factory0.reference]).check();

  static final _id_setSpannableFactory = jniAccessors.getMethodIDOf(
      _classRef, "setSpannableFactory", "(Landroid/text/Spannable\$Factory;)V");

  /// from: public final void setSpannableFactory(android.text.Spannable.Factory factory)
  ///
  /// Sets the Factory used to create new Spannable Spannables.
  ///@param factory android.text.Spannable.Factory Spannable.Factory to be used
  ///@see android.text.Spannable.Factory
  ///@see android.widget.TextView.BufferType\#SPANNABLE
  void setSpannableFactory(spannable_.Spannable_Factory factory0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSpannableFactory,
          jni.JniType.voidType, [factory0.reference]).check();

  static final _id_setText = jniAccessors.getMethodIDOf(
      _classRef, "setText", "(Ljava/lang/CharSequence;)V");

  /// from: public final void setText(java.lang.CharSequence text)
  ///
  /// Sets the text to be displayed. TextView _does not_ accept
  /// HTML-like formatting, which you can do with text strings in XML resource files.
  /// To style your strings, attach android.text.style.* objects to a
  /// android.text.SpannableString, or see the
  /// <a href="{@docRoot}guide/topics/resources/available-resources.html\#stringresources">
  /// Available Resource Types</a> documentation for an example of setting
  /// formatted text in the XML resource file.
  /// <p/>
  /// When required, TextView will use android.text.Spannable.Factory to create final or
  /// intermediate Spannable Spannables. Likewise it will use
  /// android.text.Editable.Factory to create final or intermediate
  /// Editable Editables.
  ///
  /// If the passed text is a PrecomputedText but the parameters used to create the
  /// PrecomputedText mismatches with this TextView, IllegalArgumentException is thrown. To ensure
  /// the parameters match, you can call TextView\#setTextMetricsParams before calling this.
  ///@param text text to be displayed
  ///@attr ref android.R.styleable\#TextView_text
  ///@throws IllegalArgumentException if the passed text is a PrecomputedText but the
  ///                                  parameters used to create the PrecomputedText mismatches
  ///                                  with this TextView.
  void setText(jni.JniObject text) => jniAccessors.callMethodWithArgs(
      reference, _id_setText, jni.JniType.voidType, [text.reference]).check();

  static final _id_setTextKeepState = jniAccessors.getMethodIDOf(
      _classRef, "setTextKeepState", "(Ljava/lang/CharSequence;)V");

  /// from: public final void setTextKeepState(java.lang.CharSequence text)
  ///
  /// Sets the text to be displayed but retains the cursor position. Same as
  /// \#setText(CharSequence) except that the cursor position (if any) is retained in the
  /// new text.
  /// <p/>
  /// When required, TextView will use android.text.Spannable.Factory to create final or
  /// intermediate Spannable Spannables. Likewise it will use
  /// android.text.Editable.Factory to create final or intermediate
  /// Editable Editables.
  ///@param text text to be displayed
  ///@see \#setText(CharSequence)
  void setTextKeepState(jni.JniObject text) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextKeepState,
      jni.JniType.voidType,
      [text.reference]).check();

  static final _id_setText1 = jniAccessors.getMethodIDOf(_classRef, "setText",
      "(Ljava/lang/CharSequence;Landroid/widget/TextView\$BufferType;)V");

  /// from: public void setText(java.lang.CharSequence text, android.widget.TextView.BufferType type)
  ///
  /// Sets the text to be displayed and the android.widget.TextView.BufferType.
  /// <p/>
  /// When required, TextView will use android.text.Spannable.Factory to create final or
  /// intermediate Spannable Spannables. Likewise it will use
  /// android.text.Editable.Factory to create final or intermediate
  /// Editable Editables.
  ///@param text text to be displayed
  ///@param type a android.widget.TextView.BufferType which defines whether the text is
  ///              stored as a static text, styleable/spannable text, or editable text
  ///@see \#setText(CharSequence)
  ///@see android.widget.TextView.BufferType
  ///@see \#setSpannableFactory(Spannable.Factory)
  ///@see \#setEditableFactory(Editable.Factory)
  ///@attr ref android.R.styleable\#TextView_text
  ///@attr ref android.R.styleable\#TextView_bufferType
  void setText1(jni.JniObject text, TextView_BufferType type) =>
      jniAccessors.callMethodWithArgs(reference, _id_setText1,
          jni.JniType.voidType, [text.reference, type.reference]).check();

  static final _id_setText2 =
      jniAccessors.getMethodIDOf(_classRef, "setText", "([CII)V");

  /// from: public final void setText(char[] text, int start, int len)
  ///
  /// Sets the TextView to display the specified slice of the specified
  /// char array. You must promise that you will not change the contents
  /// of the array except for right before another call to setText(),
  /// since the TextView has no way to know that the text
  /// has changed and that it needs to invalidate and re-layout.
  ///@param text char array to be displayed
  ///@param start start index in the char array
  ///@param len length of char count after {@code start}
  void setText2(jni.JniObject text, int start, int len) =>
      jniAccessors.callMethodWithArgs(reference, _id_setText2,
          jni.JniType.voidType, [text.reference, start, len]).check();

  static final _id_setTextKeepState1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setTextKeepState",
      "(Ljava/lang/CharSequence;Landroid/widget/TextView\$BufferType;)V");

  /// from: public final void setTextKeepState(java.lang.CharSequence text, android.widget.TextView.BufferType type)
  ///
  /// Sets the text to be displayed and the android.widget.TextView.BufferType but retains
  /// the cursor position. Same as
  /// \#setText(CharSequence, android.widget.TextView.BufferType) except that the cursor
  /// position (if any) is retained in the new text.
  /// <p/>
  /// When required, TextView will use android.text.Spannable.Factory to create final or
  /// intermediate Spannable Spannables. Likewise it will use
  /// android.text.Editable.Factory to create final or intermediate
  /// Editable Editables.
  ///@param text text to be displayed
  ///@param type a android.widget.TextView.BufferType which defines whether the text is
  ///              stored as a static text, styleable/spannable text, or editable text
  ///@see \#setText(CharSequence, android.widget.TextView.BufferType)
  void setTextKeepState1(jni.JniObject text, TextView_BufferType type) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextKeepState1,
          jni.JniType.voidType, [text.reference, type.reference]).check();

  static final _id_setText3 =
      jniAccessors.getMethodIDOf(_classRef, "setText", "(I)V");

  /// from: public final void setText(int resid)
  ///
  /// Sets the text to be displayed using a string resource identifier.
  ///@param resid the resource identifier of the string resource to be displayed
  ///@see \#setText(CharSequence)
  ///@attr ref android.R.styleable\#TextView_text
  void setText3(int resid) => jniAccessors.callMethodWithArgs(
      reference, _id_setText3, jni.JniType.voidType, [resid]).check();

  static final _id_setText4 = jniAccessors.getMethodIDOf(
      _classRef, "setText", "(ILandroid/widget/TextView\$BufferType;)V");

  /// from: public final void setText(int resid, android.widget.TextView.BufferType type)
  ///
  /// Sets the text to be displayed using a string resource identifier and the
  /// android.widget.TextView.BufferType.
  /// <p/>
  /// When required, TextView will use android.text.Spannable.Factory to create final or
  /// intermediate Spannable Spannables. Likewise it will use
  /// android.text.Editable.Factory to create final or intermediate
  /// Editable Editables.
  ///@param resid the resource identifier of the string resource to be displayed
  ///@param type a android.widget.TextView.BufferType which defines whether the text is
  ///              stored as a static text, styleable/spannable text, or editable text
  ///@see \#setText(int)
  ///@see \#setText(CharSequence)
  ///@see android.widget.TextView.BufferType
  ///@see \#setSpannableFactory(Spannable.Factory)
  ///@see \#setEditableFactory(Editable.Factory)
  ///@attr ref android.R.styleable\#TextView_text
  ///@attr ref android.R.styleable\#TextView_bufferType
  void setText4(int resid, TextView_BufferType type) =>
      jniAccessors.callMethodWithArgs(reference, _id_setText4,
          jni.JniType.voidType, [resid, type.reference]).check();

  static final _id_setHint = jniAccessors.getMethodIDOf(
      _classRef, "setHint", "(Ljava/lang/CharSequence;)V");

  /// from: public final void setHint(java.lang.CharSequence hint)
  ///
  /// Sets the text to be displayed when the text of the TextView is empty.
  /// Null means to use the normal empty text. The hint does not currently
  /// participate in determining the size of the view.
  ///@attr ref android.R.styleable\#TextView_hint
  void setHint(jni.JniObject hint) => jniAccessors.callMethodWithArgs(
      reference, _id_setHint, jni.JniType.voidType, [hint.reference]).check();

  static final _id_setHint1 =
      jniAccessors.getMethodIDOf(_classRef, "setHint", "(I)V");

  /// from: public final void setHint(int resid)
  ///
  /// Sets the text to be displayed when the text of the TextView is empty,
  /// from a resource.
  ///@attr ref android.R.styleable\#TextView_hint
  void setHint1(int resid) => jniAccessors.callMethodWithArgs(
      reference, _id_setHint1, jni.JniType.voidType, [resid]).check();

  static final _id_getHint = jniAccessors.getMethodIDOf(
      _classRef, "getHint", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getHint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the hint that is displayed when the text of the TextView
  /// is empty.
  ///@attr ref android.R.styleable\#TextView_hint
  jni.JniObject getHint() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHint, jni.JniType.objectType, []).object);

  static final _id_setInputType =
      jniAccessors.getMethodIDOf(_classRef, "setInputType", "(I)V");

  /// from: public void setInputType(int type)
  ///
  /// Set the type of the content with a constant as defined for EditorInfo\#inputType. This
  /// will take care of changing the key listener, by calling \#setKeyListener(KeyListener),
  /// to match the given content type.  If the given content type is EditorInfo\#TYPE_NULL
  /// then a soft keyboard will not be displayed for this text view.
  ///
  /// Note that the maximum number of displayed lines (see \#setMaxLines(int)) will be
  /// modified if you change the EditorInfo\#TYPE_TEXT_FLAG_MULTI_LINE flag of the input
  /// type.
  ///@see \#getInputType()
  ///@see \#setRawInputType(int)
  ///@see android.text.InputType
  ///@attr ref android.R.styleable\#TextView_inputType
  void setInputType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setInputType, jni.JniType.voidType, [type]).check();

  static final _id_setRawInputType =
      jniAccessors.getMethodIDOf(_classRef, "setRawInputType", "(I)V");

  /// from: public void setRawInputType(int type)
  ///
  /// Directly change the content type integer of the text view, without
  /// modifying any other state.
  ///@see \#setInputType(int)
  ///@see android.text.InputType
  ///@attr ref android.R.styleable\#TextView_inputType
  void setRawInputType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setRawInputType, jni.JniType.voidType, [type]).check();

  static final _id_getInputType =
      jniAccessors.getMethodIDOf(_classRef, "getInputType", "()I");

  /// from: public int getInputType()
  ///
  /// Get the type of the editable content.
  ///@see \#setInputType(int)
  ///@see android.text.InputType
  int getInputType() => jniAccessors.callMethodWithArgs(
      reference, _id_getInputType, jni.JniType.intType, []).integer;

  static final _id_setImeOptions =
      jniAccessors.getMethodIDOf(_classRef, "setImeOptions", "(I)V");

  /// from: public void setImeOptions(int imeOptions)
  ///
  /// Change the editor type integer associated with the text view, which
  /// is reported to an Input Method Editor (IME) with EditorInfo\#imeOptions
  /// when it has focus.
  ///@see \#getImeOptions
  ///@see android.view.inputmethod.EditorInfo
  ///@attr ref android.R.styleable\#TextView_imeOptions
  void setImeOptions(int imeOptions) => jniAccessors.callMethodWithArgs(
      reference, _id_setImeOptions, jni.JniType.voidType, [imeOptions]).check();

  static final _id_getImeOptions =
      jniAccessors.getMethodIDOf(_classRef, "getImeOptions", "()I");

  /// from: public int getImeOptions()
  ///
  /// Get the type of the Input Method Editor (IME).
  ///@return the type of the IME
  ///@see \#setImeOptions(int)
  ///@see android.view.inputmethod.EditorInfo
  int getImeOptions() => jniAccessors.callMethodWithArgs(
      reference, _id_getImeOptions, jni.JniType.intType, []).integer;

  static final _id_setImeActionLabel = jniAccessors.getMethodIDOf(
      _classRef, "setImeActionLabel", "(Ljava/lang/CharSequence;I)V");

  /// from: public void setImeActionLabel(java.lang.CharSequence label, int actionId)
  ///
  /// Change the custom IME action associated with the text view, which
  /// will be reported to an IME with EditorInfo\#actionLabel
  /// and EditorInfo\#actionId when it has focus.
  ///@see \#getImeActionLabel
  ///@see \#getImeActionId
  ///@see android.view.inputmethod.EditorInfo
  ///@attr ref android.R.styleable\#TextView_imeActionLabel
  ///@attr ref android.R.styleable\#TextView_imeActionId
  void setImeActionLabel(jni.JniObject label, int actionId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImeActionLabel,
          jni.JniType.voidType, [label.reference, actionId]).check();

  static final _id_getImeActionLabel = jniAccessors.getMethodIDOf(
      _classRef, "getImeActionLabel", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getImeActionLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the IME action label previous set with \#setImeActionLabel.
  ///@see \#setImeActionLabel
  ///@see android.view.inputmethod.EditorInfo
  jni.JniObject getImeActionLabel() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getImeActionLabel, jni.JniType.objectType, []).object);

  static final _id_getImeActionId =
      jniAccessors.getMethodIDOf(_classRef, "getImeActionId", "()I");

  /// from: public int getImeActionId()
  ///
  /// Get the IME action ID previous set with \#setImeActionLabel.
  ///@see \#setImeActionLabel
  ///@see android.view.inputmethod.EditorInfo
  int getImeActionId() => jniAccessors.callMethodWithArgs(
      reference, _id_getImeActionId, jni.JniType.intType, []).integer;

  static final _id_setOnEditorActionListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnEditorActionListener",
      "(Landroid/widget/TextView\$OnEditorActionListener;)V");

  /// from: public void setOnEditorActionListener(android.widget.TextView.OnEditorActionListener l)
  ///
  /// Set a special listener to be called when an action is performed
  /// on the text view.  This will be called when the enter key is pressed,
  /// or when an action supplied to the IME is selected by the user.  Setting
  /// this means that the normal hard key event will not insert a newline
  /// into the text view, even if it is multi-line; holding down the ALT
  /// modifier will, however, allow the user to insert a newline character.
  void setOnEditorActionListener(TextView_OnEditorActionListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnEditorActionListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_onEditorAction =
      jniAccessors.getMethodIDOf(_classRef, "onEditorAction", "(I)V");

  /// from: public void onEditorAction(int actionCode)
  ///
  /// Called when an attached input method calls
  /// InputConnection\#performEditorAction(int) InputConnection.performEditorAction()
  /// for this text view.  The default implementation will call your action
  /// listener supplied to \#setOnEditorActionListener, or perform
  /// a standard operation for EditorInfo\#IME_ACTION_NEXT EditorInfo.IME_ACTION_NEXT, EditorInfo\#IME_ACTION_PREVIOUS EditorInfo.IME_ACTION_PREVIOUS, or EditorInfo\#IME_ACTION_DONE EditorInfo.IME_ACTION_DONE.
  ///
  /// For backwards compatibility, if no IME options have been set and the
  /// text view would not normally advance focus on enter, then
  /// the NEXT and DONE actions received here will be turned into an enter
  /// key down/up pair to go through the normal key handling.
  ///@param actionCode The code of the action being performed.
  ///@see \#setOnEditorActionListener
  void onEditorAction(int actionCode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onEditorAction,
      jni.JniType.voidType,
      [actionCode]).check();

  static final _id_setPrivateImeOptions = jniAccessors.getMethodIDOf(
      _classRef, "setPrivateImeOptions", "(Ljava/lang/String;)V");

  /// from: public void setPrivateImeOptions(java.lang.String type)
  ///
  /// Set the private content type of the text, which is the
  /// EditorInfo\#privateImeOptions EditorInfo.privateImeOptions
  /// field that will be filled in when creating an input connection.
  ///@see \#getPrivateImeOptions()
  ///@see EditorInfo\#privateImeOptions
  ///@attr ref android.R.styleable\#TextView_privateImeOptions
  void setPrivateImeOptions(jni.JniString type) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPrivateImeOptions,
          jni.JniType.voidType, [type.reference]).check();

  static final _id_getPrivateImeOptions = jniAccessors.getMethodIDOf(
      _classRef, "getPrivateImeOptions", "()Ljava/lang/String;");

  /// from: public java.lang.String getPrivateImeOptions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the private type of the content.
  ///@see \#setPrivateImeOptions(String)
  ///@see EditorInfo\#privateImeOptions
  jni.JniString getPrivateImeOptions() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPrivateImeOptions, jni.JniType.objectType, []).object);

  static final _id_setInputExtras =
      jniAccessors.getMethodIDOf(_classRef, "setInputExtras", "(I)V");

  /// from: public void setInputExtras(int xmlResId)
  ///
  /// Set the extra input data of the text, which is the
  /// EditorInfo\#extras TextBoxAttribute.extras
  /// Bundle that will be filled in when creating an input connection.  The
  /// given integer is the resource identifier of an XML resource holding an
  /// android.R.styleable\#InputExtras &lt;input-extras&gt; XML tree.
  ///@see \#getInputExtras(boolean)
  ///@see EditorInfo\#extras
  ///@attr ref android.R.styleable\#TextView_editorExtras
  void setInputExtras(int xmlResId) => jniAccessors.callMethodWithArgs(
      reference, _id_setInputExtras, jni.JniType.voidType, [xmlResId]).check();

  static final _id_getInputExtras = jniAccessors.getMethodIDOf(
      _classRef, "getInputExtras", "(Z)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getInputExtras(boolean create)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the input extras currently associated with the text view, which
  /// can be viewed as well as modified.
  ///@param create If true, the extras will be created if they don't already
  /// exist.  Otherwise, null will be returned if none have been created.
  ///@see \#setInputExtras(int)
  ///@see EditorInfo\#extras
  ///@attr ref android.R.styleable\#TextView_editorExtras
  bundle_.Bundle getInputExtras(bool create) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInputExtras, jni.JniType.objectType, [create]).object);

  static final _id_setImeHintLocales = jniAccessors.getMethodIDOf(
      _classRef, "setImeHintLocales", "(Landroid/os/LocaleList;)V");

  /// from: public void setImeHintLocales(android.os.LocaleList hintLocales)
  ///
  /// Change "hint" locales associated with the text view, which will be reported to an IME with
  /// EditorInfo\#hintLocales when it has focus.
  ///
  /// Starting with Android O, this also causes internationalized listeners to be created (or
  /// change locale) based on the first locale in the input locale list.
  ///
  /// <strong>Note:</strong> If you want new "hint" to take effect immediately you need to
  /// call InputMethodManager\#restartInput(View).
  ///
  ///@param hintLocales List of the languages that the user is supposed to switch to no matter
  /// what input method subtype is currently used. Set {@code null} to clear the current "hint".
  /// This value may be {@code null}.
  ///@see \#getImeHintLocales()
  ///@see android.view.inputmethod.EditorInfo\#hintLocales
  void setImeHintLocales(localelist_.LocaleList hintLocales) =>
      jniAccessors.callMethodWithArgs(reference, _id_setImeHintLocales,
          jni.JniType.voidType, [hintLocales.reference]).check();

  static final _id_getImeHintLocales = jniAccessors.getMethodIDOf(
      _classRef, "getImeHintLocales", "()Landroid/os/LocaleList;");

  /// from: public android.os.LocaleList getImeHintLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The current languages list "hint". {@code null} when no "hint" is available.
  ///@see \#setImeHintLocales(LocaleList)
  ///@see android.view.inputmethod.EditorInfo\#hintLocales
  localelist_.LocaleList getImeHintLocales() =>
      localelist_.LocaleList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getImeHintLocales, jni.JniType.objectType, []).object);

  static final _id_getError = jniAccessors.getMethodIDOf(
      _classRef, "getError", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getError()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the error message that was set to be displayed with
  /// \#setError, or <code>null</code> if no error was set
  /// or if it the error was cleared by the widget after user input.
  jni.JniObject getError() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getError, jni.JniType.objectType, []).object);

  static final _id_setError = jniAccessors.getMethodIDOf(
      _classRef, "setError", "(Ljava/lang/CharSequence;)V");

  /// from: public void setError(java.lang.CharSequence error)
  ///
  /// Sets the right-hand compound drawable of the TextView to the "error"
  /// icon and sets an error message that will be displayed in a popup when
  /// the TextView has focus.  The icon and error message will be reset to
  /// null when any key events cause changes to the TextView's text.  If the
  /// <code>error</code> is <code>null</code>, the error message and icon
  /// will be cleared.
  void setError(jni.JniObject error) => jniAccessors.callMethodWithArgs(
      reference, _id_setError, jni.JniType.voidType, [error.reference]).check();

  static final _id_setError1 = jniAccessors.getMethodIDOf(_classRef, "setError",
      "(Ljava/lang/CharSequence;Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setError(java.lang.CharSequence error, android.graphics.drawable.Drawable icon)
  ///
  /// Sets the right-hand compound drawable of the TextView to the specified
  /// icon and sets an error message that will be displayed in a popup when
  /// the TextView has focus.  The icon and error message will be reset to
  /// null when any key events cause changes to the TextView's text.  The
  /// drawable must already have had Drawable\#setBounds set on it.
  /// If the <code>error</code> is <code>null</code>, the error message will
  /// be cleared (and you should provide a <code>null</code> icon as well).
  void setError1(jni.JniObject error, drawable_.Drawable icon) =>
      jniAccessors.callMethodWithArgs(reference, _id_setError1,
          jni.JniType.voidType, [error.reference, icon.reference]).check();

  static final _id_setFrame =
      jniAccessors.getMethodIDOf(_classRef, "setFrame", "(IIII)Z");

  /// from: protected boolean setFrame(int l, int t, int r, int b)
  bool setFrame(int l, int t, int r, int b) => jniAccessors.callMethodWithArgs(
      reference, _id_setFrame, jni.JniType.booleanType, [l, t, r, b]).boolean;

  static final _id_setFilters = jniAccessors.getMethodIDOf(
      _classRef, "setFilters", "([Landroid/text/InputFilter;)V");

  /// from: public void setFilters(android.text.InputFilter[] filters)
  ///
  /// Sets the list of input filters that will be used if the buffer is
  /// Editable. Has no effect otherwise.
  ///@attr ref android.R.styleable\#TextView_maxLength
  void setFilters(jni.JniObject filters) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFilters,
      jni.JniType.voidType,
      [filters.reference]).check();

  static final _id_getFilters = jniAccessors.getMethodIDOf(
      _classRef, "getFilters", "()[Landroid/text/InputFilter;");

  /// from: public android.text.InputFilter[] getFilters()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current list of input filters.
  ///@attr ref android.R.styleable\#TextView_maxLength
  jni.JniObject getFilters() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFilters, jni.JniType.objectType, []).object);

  static final _id_onPreDraw =
      jniAccessors.getMethodIDOf(_classRef, "onPreDraw", "()Z");

  /// from: public boolean onPreDraw()
  ///
  /// {@inheritDoc}
  bool onPreDraw() => jniAccessors.callMethodWithArgs(
      reference, _id_onPreDraw, jni.JniType.booleanType, []).boolean;

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onScreenStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "onScreenStateChanged", "(I)V");

  /// from: public void onScreenStateChanged(int screenState)
  void onScreenStateChanged(int screenState) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onScreenStateChanged,
      jni.JniType.voidType,
      [screenState]).check();

  static final _id_isPaddingOffsetRequired =
      jniAccessors.getMethodIDOf(_classRef, "isPaddingOffsetRequired", "()Z");

  /// from: protected boolean isPaddingOffsetRequired()
  bool isPaddingOffsetRequired() => jniAccessors.callMethodWithArgs(reference,
      _id_isPaddingOffsetRequired, jni.JniType.booleanType, []).boolean;

  static final _id_getLeftPaddingOffset =
      jniAccessors.getMethodIDOf(_classRef, "getLeftPaddingOffset", "()I");

  /// from: protected int getLeftPaddingOffset()
  int getLeftPaddingOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getLeftPaddingOffset, jni.JniType.intType, []).integer;

  static final _id_getTopPaddingOffset =
      jniAccessors.getMethodIDOf(_classRef, "getTopPaddingOffset", "()I");

  /// from: protected int getTopPaddingOffset()
  int getTopPaddingOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getTopPaddingOffset, jni.JniType.intType, []).integer;

  static final _id_getBottomPaddingOffset =
      jniAccessors.getMethodIDOf(_classRef, "getBottomPaddingOffset", "()I");

  /// from: protected int getBottomPaddingOffset()
  int getBottomPaddingOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getBottomPaddingOffset, jni.JniType.intType, []).integer;

  static final _id_getRightPaddingOffset =
      jniAccessors.getMethodIDOf(_classRef, "getRightPaddingOffset", "()I");

  /// from: protected int getRightPaddingOffset()
  int getRightPaddingOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getRightPaddingOffset, jni.JniType.intType, []).integer;

  static final _id_verifyDrawable = jniAccessors.getMethodIDOf(
      _classRef, "verifyDrawable", "(Landroid/graphics/drawable/Drawable;)Z");

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable who)
  ///
  /// @param who This value must never be {@code null}.
  bool verifyDrawable(drawable_.Drawable who) =>
      jniAccessors.callMethodWithArgs(reference, _id_verifyDrawable,
          jni.JniType.booleanType, [who.reference]).boolean;

  static final _id_jumpDrawablesToCurrentState = jniAccessors.getMethodIDOf(
      _classRef, "jumpDrawablesToCurrentState", "()V");

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_jumpDrawablesToCurrentState,
      jni.JniType.voidType, []).check();

  static final _id_invalidateDrawable = jniAccessors.getMethodIDOf(_classRef,
      "invalidateDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable drawable)
  ///
  /// @param drawable This value must never be {@code null}.
  void invalidateDrawable(drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateDrawable,
          jni.JniType.voidType, [drawable.reference]).check();

  static final _id_hasOverlappingRendering =
      jniAccessors.getMethodIDOf(_classRef, "hasOverlappingRendering", "()Z");

  /// from: public boolean hasOverlappingRendering()
  bool hasOverlappingRendering() => jniAccessors.callMethodWithArgs(reference,
      _id_hasOverlappingRendering, jni.JniType.booleanType, []).boolean;

  static final _id_isTextSelectable =
      jniAccessors.getMethodIDOf(_classRef, "isTextSelectable", "()Z");

  /// from: public boolean isTextSelectable()
  ///
  /// Returns the state of the {@code textIsSelectable} flag (See
  /// \#setTextIsSelectable setTextIsSelectable()). Although you have to set this flag
  /// to allow users to select and copy text in a non-editable TextView, the content of an
  /// EditText can always be selected, independently of the value of this flag.
  ///
  ///@return True if the text displayed in this TextView can be selected by the user.
  ///@attr ref android.R.styleable\#TextView_textIsSelectable
  bool isTextSelectable() => jniAccessors.callMethodWithArgs(
      reference, _id_isTextSelectable, jni.JniType.booleanType, []).boolean;

  static final _id_setTextIsSelectable =
      jniAccessors.getMethodIDOf(_classRef, "setTextIsSelectable", "(Z)V");

  /// from: public void setTextIsSelectable(boolean selectable)
  ///
  /// Sets whether the content of this view is selectable by the user. The default is
  /// {@code false}, meaning that the content is not selectable.
  ///
  /// When you use a TextView to display a useful piece of information to the user (such as a
  /// contact's address), make it selectable, so that the user can select and copy its
  /// content. You can also use set the XML attribute
  /// android.R.styleable\#TextView_textIsSelectable to "true".
  ///
  /// When you call this method to set the value of {@code textIsSelectable}, it sets
  /// the flags {@code focusable}, {@code focusableInTouchMode}, {@code clickable},
  /// and {@code longClickable} to the same value. These flags correspond to the attributes
  /// android.R.styleable\#View_focusable android:focusable,
  /// android.R.styleable\#View_focusableInTouchMode android:focusableInTouchMode,
  /// android.R.styleable\#View_clickable android:clickable, and
  /// android.R.styleable\#View_longClickable android:longClickable. To restore any of these
  /// flags to a state you had set previously, call one or more of the following methods:
  /// \#setFocusable(boolean) setFocusable(),
  /// \#setFocusableInTouchMode(boolean) setFocusableInTouchMode(),
  /// \#setClickable(boolean) setClickable() or
  /// \#setLongClickable(boolean) setLongClickable().
  ///@param selectable Whether the content of this TextView should be selectable.
  void setTextIsSelectable(bool selectable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextIsSelectable,
      jni.JniType.voidType,
      [selectable]).check();

  static final _id_onCreateDrawableState =
      jniAccessors.getMethodIDOf(_classRef, "onCreateDrawableState", "(I)[I");

  /// from: protected int[] onCreateDrawableState(int extraSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onCreateDrawableState(int extraSpace) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateDrawableState,
          jni.JniType.objectType,
          [extraSpace]).object);

  static final _id_onDraw = jniAccessors.getMethodIDOf(
      _classRef, "onDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_onDraw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getFocusedRect = jniAccessors.getMethodIDOf(
      _classRef, "getFocusedRect", "(Landroid/graphics/Rect;)V");

  /// from: public void getFocusedRect(android.graphics.Rect r)
  void getFocusedRect(rect_.Rect r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getFocusedRect,
      jni.JniType.voidType,
      [r.reference]).check();

  static final _id_getLineCount =
      jniAccessors.getMethodIDOf(_classRef, "getLineCount", "()I");

  /// from: public int getLineCount()
  ///
  /// Return the number of lines of text, or 0 if the internal Layout has not
  /// been built.
  int getLineCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getLineCount, jni.JniType.intType, []).integer;

  static final _id_getLineBounds = jniAccessors.getMethodIDOf(
      _classRef, "getLineBounds", "(ILandroid/graphics/Rect;)I");

  /// from: public int getLineBounds(int line, android.graphics.Rect bounds)
  ///
  /// Return the baseline for the specified line (0...getLineCount() - 1)
  /// If bounds is not null, return the top, left, right, bottom extents
  /// of the specified line in it. If the internal Layout has not been built,
  /// return 0 and set bounds to (0, 0, 0, 0)
  ///@param line which line to examine (0..getLineCount() - 1)
  ///@param bounds Optional. If not null, it returns the extent of the line
  ///@return the Y-coordinate of the baseline
  int getLineBounds(int line, rect_.Rect bounds) =>
      jniAccessors.callMethodWithArgs(reference, _id_getLineBounds,
          jni.JniType.intType, [line, bounds.reference]).integer;

  static final _id_getBaseline =
      jniAccessors.getMethodIDOf(_classRef, "getBaseline", "()I");

  /// from: public int getBaseline()
  int getBaseline() => jniAccessors.callMethodWithArgs(
      reference, _id_getBaseline, jni.JniType.intType, []).integer;

  static final _id_onResolvePointerIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "onResolvePointerIcon",
      "(Landroid/view/MotionEvent;I)Landroid/view/PointerIcon;");

  /// from: public android.view.PointerIcon onResolvePointerIcon(android.view.MotionEvent event, int pointerIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  pointericon_.PointerIcon onResolvePointerIcon(
          motionevent_.MotionEvent event, int pointerIndex) =>
      pointericon_.PointerIcon.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onResolvePointerIcon,
          jni.JniType.objectType,
          [event.reference, pointerIndex]).object);

  static final _id_onKeyPreIme = jniAccessors.getMethodIDOf(
      _classRef, "onKeyPreIme", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyPreIme(int keyCode, android.view.KeyEvent event)
  bool onKeyPreIme(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyPreIme,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyDown = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  bool onKeyDown(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyMultiple = jniAccessors.getMethodIDOf(
      _classRef, "onKeyMultiple", "(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  bool onKeyMultiple(int keyCode, int repeatCount, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onKeyMultiple,
          jni.JniType.booleanType,
          [keyCode, repeatCount, event.reference]).boolean;

  static final _id_onKeyUp = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  bool onKeyUp(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onCheckIsTextEditor =
      jniAccessors.getMethodIDOf(_classRef, "onCheckIsTextEditor", "()Z");

  /// from: public boolean onCheckIsTextEditor()
  bool onCheckIsTextEditor() => jniAccessors.callMethodWithArgs(
      reference, _id_onCheckIsTextEditor, jni.JniType.booleanType, []).boolean;

  static final _id_onCreateInputConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateInputConnection",
      "(Landroid/view/inputmethod/EditorInfo;)Landroid/view/inputmethod/InputConnection;");

  /// from: public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo outAttrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  inputconnection_.InputConnection onCreateInputConnection(
          editorinfo_.EditorInfo outAttrs) =>
      inputconnection_.InputConnection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateInputConnection,
          jni.JniType.objectType,
          [outAttrs.reference]).object);

  static final _id_extractText = jniAccessors.getMethodIDOf(
      _classRef,
      "extractText",
      "(Landroid/view/inputmethod/ExtractedTextRequest;Landroid/view/inputmethod/ExtractedText;)Z");

  /// from: public boolean extractText(android.view.inputmethod.ExtractedTextRequest request, android.view.inputmethod.ExtractedText outText)
  ///
  /// If this TextView contains editable content, extract a portion of it
  /// based on the information in <var>request</var> in to <var>outText</var>.
  ///@return Returns true if the text was successfully extracted, else false.
  bool extractText(extractedtextrequest_.ExtractedTextRequest request,
          extractedtext_.ExtractedText outText) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_extractText,
          jni.JniType.booleanType,
          [request.reference, outText.reference]).boolean;

  static final _id_setExtractedText = jniAccessors.getMethodIDOf(_classRef,
      "setExtractedText", "(Landroid/view/inputmethod/ExtractedText;)V");

  /// from: public void setExtractedText(android.view.inputmethod.ExtractedText text)
  ///
  /// Apply to this text view the given extracted text, as previously
  /// returned by \#extractText(ExtractedTextRequest, ExtractedText).
  void setExtractedText(extractedtext_.ExtractedText text) =>
      jniAccessors.callMethodWithArgs(reference, _id_setExtractedText,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_onCommitCompletion = jniAccessors.getMethodIDOf(_classRef,
      "onCommitCompletion", "(Landroid/view/inputmethod/CompletionInfo;)V");

  /// from: public void onCommitCompletion(android.view.inputmethod.CompletionInfo text)
  ///
  /// Called by the framework in response to a text completion from
  /// the current input method, provided by it calling
  /// InputConnection\#commitCompletion InputConnection.commitCompletion().  The default implementation does
  /// nothing; text views that are supporting auto-completion should override
  /// this to do their desired behavior.
  ///@param text The auto complete text the user has selected.
  void onCommitCompletion(completioninfo_.CompletionInfo text) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCommitCompletion,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_onCommitCorrection = jniAccessors.getMethodIDOf(_classRef,
      "onCommitCorrection", "(Landroid/view/inputmethod/CorrectionInfo;)V");

  /// from: public void onCommitCorrection(android.view.inputmethod.CorrectionInfo info)
  ///
  /// Called by the framework in response to a text auto-correction (such as fixing a typo using a
  /// dictionary) from the current input method, provided by it calling
  /// InputConnection\#commitCorrection(CorrectionInfo) InputConnection.commitCorrection().
  /// The default implementation flashes the background of the corrected word to provide
  /// feedback to the user.
  ///@param info The auto correct info about the text that was corrected.
  void onCommitCorrection(correctioninfo_.CorrectionInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCommitCorrection,
          jni.JniType.voidType, [info.reference]).check();

  static final _id_beginBatchEdit =
      jniAccessors.getMethodIDOf(_classRef, "beginBatchEdit", "()V");

  /// from: public void beginBatchEdit()
  void beginBatchEdit() => jniAccessors.callMethodWithArgs(
      reference, _id_beginBatchEdit, jni.JniType.voidType, []).check();

  static final _id_endBatchEdit =
      jniAccessors.getMethodIDOf(_classRef, "endBatchEdit", "()V");

  /// from: public void endBatchEdit()
  void endBatchEdit() => jniAccessors.callMethodWithArgs(
      reference, _id_endBatchEdit, jni.JniType.voidType, []).check();

  static final _id_onBeginBatchEdit =
      jniAccessors.getMethodIDOf(_classRef, "onBeginBatchEdit", "()V");

  /// from: public void onBeginBatchEdit()
  ///
  /// Called by the framework in response to a request to begin a batch
  /// of edit operations through a call to link \#beginBatchEdit().
  void onBeginBatchEdit() => jniAccessors.callMethodWithArgs(
      reference, _id_onBeginBatchEdit, jni.JniType.voidType, []).check();

  static final _id_onEndBatchEdit =
      jniAccessors.getMethodIDOf(_classRef, "onEndBatchEdit", "()V");

  /// from: public void onEndBatchEdit()
  ///
  /// Called by the framework in response to a request to end a batch
  /// of edit operations through a call to link \#endBatchEdit.
  void onEndBatchEdit() => jniAccessors.callMethodWithArgs(
      reference, _id_onEndBatchEdit, jni.JniType.voidType, []).check();

  static final _id_onPrivateIMECommand = jniAccessors.getMethodIDOf(_classRef,
      "onPrivateIMECommand", "(Ljava/lang/String;Landroid/os/Bundle;)Z");

  /// from: public boolean onPrivateIMECommand(java.lang.String action, android.os.Bundle data)
  ///
  /// Called by the framework in response to a private command from the
  /// current method, provided by it calling
  /// InputConnection\#performPrivateCommand InputConnection.performPrivateCommand().
  ///@param action The action name of the command.
  ///@param data Any additional data for the command.  This may be null.
  ///@return Return true if you handled the command, else false.
  bool onPrivateIMECommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrivateIMECommand,
          jni.JniType.booleanType, [action.reference, data.reference]).boolean;

  static final _id_setIncludeFontPadding =
      jniAccessors.getMethodIDOf(_classRef, "setIncludeFontPadding", "(Z)V");

  /// from: public void setIncludeFontPadding(boolean includepad)
  ///
  /// Set whether the TextView includes extra top and bottom padding to make
  /// room for accents that go above the normal ascent and descent.
  /// The default is true.
  ///@see \#getIncludeFontPadding()
  ///@attr ref android.R.styleable\#TextView_includeFontPadding
  void setIncludeFontPadding(bool includepad) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIncludeFontPadding,
          jni.JniType.voidType, [includepad]).check();

  static final _id_getIncludeFontPadding =
      jniAccessors.getMethodIDOf(_classRef, "getIncludeFontPadding", "()Z");

  /// from: public boolean getIncludeFontPadding()
  ///
  /// Gets whether the TextView includes extra top and bottom padding to make
  /// room for accents that go above the normal ascent and descent.
  ///@see \#setIncludeFontPadding(boolean)
  ///@attr ref android.R.styleable\#TextView_includeFontPadding
  bool getIncludeFontPadding() => jniAccessors.callMethodWithArgs(reference,
      _id_getIncludeFontPadding, jni.JniType.booleanType, []).boolean;

  static final _id_onMeasure =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int left, int top, int right, int bottom)
  void onLayout(bool changed, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, left, top, right, bottom]).check();

  static final _id_bringPointIntoView =
      jniAccessors.getMethodIDOf(_classRef, "bringPointIntoView", "(I)Z");

  /// from: public boolean bringPointIntoView(int offset)
  ///
  /// Move the point, specified by the offset, into the view if it is needed.
  /// This has to be called after layout. Returns true if anything changed.
  bool bringPointIntoView(int offset) => jniAccessors.callMethodWithArgs(
      reference,
      _id_bringPointIntoView,
      jni.JniType.booleanType,
      [offset]).boolean;

  static final _id_moveCursorToVisibleOffset =
      jniAccessors.getMethodIDOf(_classRef, "moveCursorToVisibleOffset", "()Z");

  /// from: public boolean moveCursorToVisibleOffset()
  ///
  /// Move the cursor, if needed, so that it is at an offset that is visible
  /// to the user.  This will not move the cursor if it represents more than
  /// one character (a selection range).  This will only work if the
  /// TextView contains spannable text; otherwise it will do nothing.
  ///@return True if the cursor was actually moved, false otherwise.
  bool moveCursorToVisibleOffset() => jniAccessors.callMethodWithArgs(reference,
      _id_moveCursorToVisibleOffset, jni.JniType.booleanType, []).boolean;

  static final _id_computeScroll =
      jniAccessors.getMethodIDOf(_classRef, "computeScroll", "()V");

  /// from: public void computeScroll()
  void computeScroll() => jniAccessors.callMethodWithArgs(
      reference, _id_computeScroll, jni.JniType.voidType, []).check();

  static final _id_debug =
      jniAccessors.getMethodIDOf(_classRef, "debug", "(I)V");

  /// from: public void debug(int depth)
  void debug(int depth) => jniAccessors.callMethodWithArgs(
      reference, _id_debug, jni.JniType.voidType, [depth]).check();

  static final _id_getSelectionStart =
      jniAccessors.getMethodIDOf(_classRef, "getSelectionStart", "()I");

  /// from: public int getSelectionStart()
  ///
  /// Convenience for Selection\#getSelectionStart.
  int getSelectionStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectionStart, jni.JniType.intType, []).integer;

  static final _id_getSelectionEnd =
      jniAccessors.getMethodIDOf(_classRef, "getSelectionEnd", "()I");

  /// from: public int getSelectionEnd()
  ///
  /// Convenience for Selection\#getSelectionEnd.
  int getSelectionEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectionEnd, jni.JniType.intType, []).integer;

  static final _id_hasSelection =
      jniAccessors.getMethodIDOf(_classRef, "hasSelection", "()Z");

  /// from: public boolean hasSelection()
  ///
  /// Return true iff there is a selection inside this text view.
  bool hasSelection() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSelection, jni.JniType.booleanType, []).boolean;

  static final _id_setSingleLine =
      jniAccessors.getMethodIDOf(_classRef, "setSingleLine", "()V");

  /// from: public void setSingleLine()
  ///
  /// Sets the properties of this field (lines, horizontally scrolling,
  /// transformation method) to be for a single-line input.
  ///@attr ref android.R.styleable\#TextView_singleLine
  void setSingleLine() => jniAccessors.callMethodWithArgs(
      reference, _id_setSingleLine, jni.JniType.voidType, []).check();

  static final _id_setAllCaps =
      jniAccessors.getMethodIDOf(_classRef, "setAllCaps", "(Z)V");

  /// from: public void setAllCaps(boolean allCaps)
  ///
  /// Sets the properties of this field to transform input to ALL CAPS
  /// display. This may use a "small caps" formatting if available.
  /// This setting will be ignored if this field is editable or selectable.
  ///
  /// This call replaces the current transformation method. Disabling this
  /// will not necessarily restore the previous behavior from before this
  /// was enabled.
  ///@see \#setTransformationMethod(TransformationMethod)
  ///@attr ref android.R.styleable\#TextView_textAllCaps
  void setAllCaps(bool allCaps) => jniAccessors.callMethodWithArgs(
      reference, _id_setAllCaps, jni.JniType.voidType, [allCaps]).check();

  static final _id_isAllCaps =
      jniAccessors.getMethodIDOf(_classRef, "isAllCaps", "()Z");

  /// from: public boolean isAllCaps()
  ///
  /// Checks whether the transformation method applied to this TextView is set to ALL CAPS.
  ///@return Whether the current transformation method is for ALL CAPS.
  ///@see \#setAllCaps(boolean)
  ///@see \#setTransformationMethod(TransformationMethod)
  bool isAllCaps() => jniAccessors.callMethodWithArgs(
      reference, _id_isAllCaps, jni.JniType.booleanType, []).boolean;

  static final _id_setSingleLine1 =
      jniAccessors.getMethodIDOf(_classRef, "setSingleLine", "(Z)V");

  /// from: public void setSingleLine(boolean singleLine)
  ///
  /// If true, sets the properties of this field (number of lines, horizontally scrolling,
  /// transformation method) to be for a single-line input; if false, restores these to the default
  /// conditions.
  ///
  /// Note that the default conditions are not necessarily those that were in effect prior this
  /// method, and you may want to reset these properties to your custom values.
  ///@attr ref android.R.styleable\#TextView_singleLine
  void setSingleLine1(bool singleLine) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSingleLine1,
      jni.JniType.voidType,
      [singleLine]).check();

  static final _id_setEllipsize = jniAccessors.getMethodIDOf(
      _classRef, "setEllipsize", "(Landroid/text/TextUtils\$TruncateAt;)V");

  /// from: public void setEllipsize(android.text.TextUtils.TruncateAt where)
  ///
  /// Causes words in the text that are longer than the view's width
  /// to be ellipsized instead of broken in the middle.  You may also
  /// want to \#setSingleLine or \#setHorizontallyScrolling
  /// to constrain the text to a single line.  Use <code>null</code>
  /// to turn off ellipsizing.
  ///
  /// If \#setMaxLines has been used to set two or more lines,
  /// only android.text.TextUtils.TruncateAt\#END and
  /// android.text.TextUtils.TruncateAt\#MARQUEE are supported
  /// (other ellipsizing types will not do anything).
  ///@attr ref android.R.styleable\#TextView_ellipsize
  void setEllipsize(textutils_.TextUtils_TruncateAt where) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEllipsize,
          jni.JniType.voidType, [where.reference]).check();

  static final _id_setMarqueeRepeatLimit =
      jniAccessors.getMethodIDOf(_classRef, "setMarqueeRepeatLimit", "(I)V");

  /// from: public void setMarqueeRepeatLimit(int marqueeLimit)
  ///
  /// Sets how many times to repeat the marquee animation. Only applied if the
  /// TextView has marquee enabled. Set to -1 to repeat indefinitely.
  ///@see \#getMarqueeRepeatLimit()
  ///@attr ref android.R.styleable\#TextView_marqueeRepeatLimit
  void setMarqueeRepeatLimit(int marqueeLimit) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMarqueeRepeatLimit,
          jni.JniType.voidType, [marqueeLimit]).check();

  static final _id_getMarqueeRepeatLimit =
      jniAccessors.getMethodIDOf(_classRef, "getMarqueeRepeatLimit", "()I");

  /// from: public int getMarqueeRepeatLimit()
  ///
  /// Gets the number of times the marquee animation is repeated. Only meaningful if the
  /// TextView has marquee enabled.
  ///@return the number of times the marquee animation is repeated. -1 if the animation
  /// repeats indefinitely
  ///@see \#setMarqueeRepeatLimit(int)
  ///@attr ref android.R.styleable\#TextView_marqueeRepeatLimit
  int getMarqueeRepeatLimit() => jniAccessors.callMethodWithArgs(
      reference, _id_getMarqueeRepeatLimit, jni.JniType.intType, []).integer;

  static final _id_getEllipsize = jniAccessors.getMethodIDOf(
      _classRef, "getEllipsize", "()Landroid/text/TextUtils\$TruncateAt;");

  /// from: public android.text.TextUtils.TruncateAt getEllipsize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns where, if anywhere, words that are longer than the view
  /// is wide should be ellipsized.
  textutils_.TextUtils_TruncateAt getEllipsize() =>
      textutils_.TextUtils_TruncateAt.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getEllipsize, jni.JniType.objectType, []).object);

  static final _id_setSelectAllOnFocus =
      jniAccessors.getMethodIDOf(_classRef, "setSelectAllOnFocus", "(Z)V");

  /// from: public void setSelectAllOnFocus(boolean selectAllOnFocus)
  ///
  /// Set the TextView so that when it takes focus, all the text is
  /// selected.
  ///@attr ref android.R.styleable\#TextView_selectAllOnFocus
  void setSelectAllOnFocus(bool selectAllOnFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSelectAllOnFocus,
          jni.JniType.voidType, [selectAllOnFocus]).check();

  static final _id_setCursorVisible =
      jniAccessors.getMethodIDOf(_classRef, "setCursorVisible", "(Z)V");

  /// from: public void setCursorVisible(boolean visible)
  ///
  /// Set whether the cursor is visible. The default is true. Note that this property only
  /// makes sense for editable TextView.
  ///@see \#isCursorVisible()
  ///@attr ref android.R.styleable\#TextView_cursorVisible
  void setCursorVisible(bool visible) => jniAccessors.callMethodWithArgs(
      reference, _id_setCursorVisible, jni.JniType.voidType, [visible]).check();

  static final _id_isCursorVisible =
      jniAccessors.getMethodIDOf(_classRef, "isCursorVisible", "()Z");

  /// from: public boolean isCursorVisible()
  ///
  /// @return whether or not the cursor is visible (assuming this TextView is editable)
  ///@see \#setCursorVisible(boolean)
  ///@attr ref android.R.styleable\#TextView_cursorVisible
  bool isCursorVisible() => jniAccessors.callMethodWithArgs(
      reference, _id_isCursorVisible, jni.JniType.booleanType, []).boolean;

  static final _id_onTextChanged = jniAccessors.getMethodIDOf(
      _classRef, "onTextChanged", "(Ljava/lang/CharSequence;III)V");

  /// from: protected void onTextChanged(java.lang.CharSequence text, int start, int lengthBefore, int lengthAfter)
  ///
  /// This method is called when the text is changed, in case any subclasses
  /// would like to know.
  ///
  /// Within <code>text</code>, the <code>lengthAfter</code> characters
  /// beginning at <code>start</code> have just replaced old text that had
  /// length <code>lengthBefore</code>. It is an error to attempt to make
  /// changes to <code>text</code> from this callback.
  ///@param text The text the TextView is displaying
  ///@param start The offset of the start of the range of the text that was
  /// modified
  ///@param lengthBefore The length of the former text that has been replaced
  ///@param lengthAfter The length of the replacement modified text
  void onTextChanged(
          jni.JniObject text, int start, int lengthBefore, int lengthAfter) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTextChanged,
          jni.JniType.voidType,
          [text.reference, start, lengthBefore, lengthAfter]).check();

  static final _id_onSelectionChanged =
      jniAccessors.getMethodIDOf(_classRef, "onSelectionChanged", "(II)V");

  /// from: protected void onSelectionChanged(int selStart, int selEnd)
  ///
  /// This method is called when the selection has changed, in case any
  /// subclasses would like to know.
  ///@param selStart The new selection start location.
  ///@param selEnd The new selection end location.
  void onSelectionChanged(int selStart, int selEnd) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSelectionChanged,
          jni.JniType.voidType, [selStart, selEnd]).check();

  static final _id_addTextChangedListener = jniAccessors.getMethodIDOf(
      _classRef, "addTextChangedListener", "(Landroid/text/TextWatcher;)V");

  /// from: public void addTextChangedListener(android.text.TextWatcher watcher)
  ///
  /// Adds a TextWatcher to the list of those whose methods are called
  /// whenever this TextView's text changes.
  ///
  /// In 1.0, the TextWatcher\#afterTextChanged method was erroneously
  /// not called after \#setText calls.  Now, doing \#setText
  /// if there are any text changed listeners forces the buffer type to
  /// Editable if it would not otherwise be and does call this method.
  void addTextChangedListener(textwatcher_.TextWatcher watcher) =>
      jniAccessors.callMethodWithArgs(reference, _id_addTextChangedListener,
          jni.JniType.voidType, [watcher.reference]).check();

  static final _id_removeTextChangedListener = jniAccessors.getMethodIDOf(
      _classRef, "removeTextChangedListener", "(Landroid/text/TextWatcher;)V");

  /// from: public void removeTextChangedListener(android.text.TextWatcher watcher)
  ///
  /// Removes the specified TextWatcher from the list of those whose
  /// methods are called
  /// whenever this TextView's text changes.
  void removeTextChangedListener(textwatcher_.TextWatcher watcher) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeTextChangedListener,
          jni.JniType.voidType, [watcher.reference]).check();

  static final _id_onFocusChanged = jniAccessors.getMethodIDOf(
      _classRef, "onFocusChanged", "(ZILandroid/graphics/Rect;)V");

  /// from: protected void onFocusChanged(boolean focused, int direction, android.graphics.Rect previouslyFocusedRect)
  void onFocusChanged(
          bool focused, int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFocusChanged,
          jni.JniType.voidType,
          [focused, direction, previouslyFocusedRect.reference]).check();

  static final _id_onWindowFocusChanged =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasWindowFocus)
  void onWindowFocusChanged(bool hasWindowFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowFocusChanged,
          jni.JniType.voidType, [hasWindowFocus]).check();

  static final _id_onVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "onVisibilityChanged", "(Landroid/view/View;I)V");

  /// from: protected void onVisibilityChanged(android.view.View changedView, int visibility)
  void onVisibilityChanged(view_.View changedView, int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVisibilityChanged,
          jni.JniType.voidType, [changedView.reference, visibility]).check();

  static final _id_clearComposingText =
      jniAccessors.getMethodIDOf(_classRef, "clearComposingText", "()V");

  /// from: public void clearComposingText()
  ///
  /// Use BaseInputConnection\#removeComposingSpans BaseInputConnection.removeComposingSpans() to remove any IME composing
  /// state from this text view.
  void clearComposingText() => jniAccessors.callMethodWithArgs(
      reference, _id_clearComposingText, jni.JniType.voidType, []).check();

  static final _id_setSelected =
      jniAccessors.getMethodIDOf(_classRef, "setSelected", "(Z)V");

  /// from: public void setSelected(boolean selected)
  void setSelected(bool selected) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelected, jni.JniType.voidType, [selected]).check();

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  bool onTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  bool onGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onCreateContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "onCreateContextMenu", "(Landroid/view/ContextMenu;)V");

  /// from: protected void onCreateContextMenu(android.view.ContextMenu menu)
  void onCreateContextMenu(contextmenu_.ContextMenu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreateContextMenu,
          jni.JniType.voidType, [menu.reference]).check();

  static final _id_showContextMenu =
      jniAccessors.getMethodIDOf(_classRef, "showContextMenu", "()Z");

  /// from: public boolean showContextMenu()
  bool showContextMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_showContextMenu, jni.JniType.booleanType, []).boolean;

  static final _id_showContextMenu1 =
      jniAccessors.getMethodIDOf(_classRef, "showContextMenu", "(FF)Z");

  /// from: public boolean showContextMenu(float x, float y)
  bool showContextMenu1(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_showContextMenu1, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_didTouchFocusSelect =
      jniAccessors.getMethodIDOf(_classRef, "didTouchFocusSelect", "()Z");

  /// from: public boolean didTouchFocusSelect()
  ///
  /// Returns true, only while processing a touch gesture, if the initial
  /// touch down event caused focus to move to the text view and as a result
  /// its selection changed.  Only valid while processing the touch gesture
  /// of interest, in an editable text view.
  bool didTouchFocusSelect() => jniAccessors.callMethodWithArgs(
      reference, _id_didTouchFocusSelect, jni.JniType.booleanType, []).boolean;

  static final _id_cancelLongPress =
      jniAccessors.getMethodIDOf(_classRef, "cancelLongPress", "()V");

  /// from: public void cancelLongPress()
  void cancelLongPress() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelLongPress, jni.JniType.voidType, []).check();

  static final _id_onTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  bool onTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_setScroller = jniAccessors.getMethodIDOf(
      _classRef, "setScroller", "(Landroid/widget/Scroller;)V");

  /// from: public void setScroller(android.widget.Scroller s)
  ///
  /// Sets the Scroller used for producing a scrolling animation
  ///@param s A Scroller instance
  void setScroller(scroller_.Scroller s) => jniAccessors.callMethodWithArgs(
      reference, _id_setScroller, jni.JniType.voidType, [s.reference]).check();

  static final _id_getLeftFadingEdgeStrength =
      jniAccessors.getMethodIDOf(_classRef, "getLeftFadingEdgeStrength", "()F");

  /// from: protected float getLeftFadingEdgeStrength()
  double getLeftFadingEdgeStrength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLeftFadingEdgeStrength,
      jni.JniType.floatType, []).float;

  static final _id_getRightFadingEdgeStrength = jniAccessors.getMethodIDOf(
      _classRef, "getRightFadingEdgeStrength", "()F");

  /// from: protected float getRightFadingEdgeStrength()
  double getRightFadingEdgeStrength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getRightFadingEdgeStrength,
      jni.JniType.floatType, []).float;

  static final _id_computeHorizontalScrollRange = jniAccessors.getMethodIDOf(
      _classRef, "computeHorizontalScrollRange", "()I");

  /// from: protected int computeHorizontalScrollRange()
  int computeHorizontalScrollRange() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeHorizontalScrollRange,
      jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollRange = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollRange", "()I");

  /// from: protected int computeVerticalScrollRange()
  int computeVerticalScrollRange() => jniAccessors.callMethodWithArgs(reference,
      _id_computeVerticalScrollRange, jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollExtent = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollExtent", "()I");

  /// from: protected int computeVerticalScrollExtent()
  int computeVerticalScrollExtent() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollExtent,
      jni.JniType.intType, []).integer;

  static final _id_findViewsWithText = jniAccessors.getMethodIDOf(_classRef,
      "findViewsWithText", "(Ljava/util/ArrayList;Ljava/lang/CharSequence;I)V");

  /// from: public void findViewsWithText(java.util.ArrayList<android.view.View> outViews, java.lang.CharSequence searched, int flags)
  void findViewsWithText(
          jni.JniObject outViews, jni.JniObject searched, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_findViewsWithText,
          jni.JniType.voidType,
          [outViews.reference, searched.reference, flags]).check();

  static final _id_onKeyShortcut = jniAccessors.getMethodIDOf(
      _classRef, "onKeyShortcut", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyShortcut(int keyCode, android.view.KeyEvent event)
  bool onKeyShortcut(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyShortcut,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_onProvideStructure = jniAccessors.getMethodIDOf(
      _classRef, "onProvideStructure", "(Landroid/view/ViewStructure;)V");

  /// from: public void onProvideStructure(android.view.ViewStructure structure)
  void onProvideStructure(viewstructure_.ViewStructure structure) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideStructure,
          jni.JniType.voidType, [structure.reference]).check();

  static final _id_onProvideAutofillStructure = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideAutofillStructure",
      "(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideAutofillStructure(android.view.ViewStructure structure, int flags)
  void onProvideAutofillStructure(
          viewstructure_.ViewStructure structure, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideAutofillStructure,
          jni.JniType.voidType, [structure.reference, flags]).check();

  static final _id_autofill = jniAccessors.getMethodIDOf(
      _classRef, "autofill", "(Landroid/view/autofill/AutofillValue;)V");

  /// from: public void autofill(android.view.autofill.AutofillValue value)
  void autofill(autofillvalue_.AutofillValue value) =>
      jniAccessors.callMethodWithArgs(reference, _id_autofill,
          jni.JniType.voidType, [value.reference]).check();

  static final _id_getAutofillType =
      jniAccessors.getMethodIDOf(_classRef, "getAutofillType", "()I");

  /// from: public int getAutofillType()
  ///
  /// @return Value is android.view.View\#AUTOFILL_TYPE_NONE, android.view.View\#AUTOFILL_TYPE_TEXT, android.view.View\#AUTOFILL_TYPE_TOGGLE, android.view.View\#AUTOFILL_TYPE_LIST, or android.view.View\#AUTOFILL_TYPE_DATE
  int getAutofillType() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutofillType, jni.JniType.intType, []).integer;

  static final _id_getAutofillValue = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillValue", "()Landroid/view/autofill/AutofillValue;");

  /// from: public android.view.autofill.AutofillValue getAutofillValue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the TextView's current text for AutoFill. The value is trimmed to 100K
  /// {@code char}s if longer.
  ///@return current text, {@code null} if the text is not editable
  ///@see View\#getAutofillValue()
  autofillvalue_.AutofillValue getAutofillValue() =>
      autofillvalue_.AutofillValue.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillValue, jni.JniType.objectType, []).object);

  static final _id_addExtraDataToAccessibilityNodeInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "addExtraDataToAccessibilityNodeInfo",
      "(Landroid/view/accessibility/AccessibilityNodeInfo;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void addExtraDataToAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo info, java.lang.String extraDataKey, android.os.Bundle arguments)
  void addExtraDataToAccessibilityNodeInfo(
          accessibilitynodeinfo_.AccessibilityNodeInfo info,
          jni.JniString extraDataKey,
          bundle_.Bundle arguments) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_addExtraDataToAccessibilityNodeInfo, jni.JniType.voidType, [
        info.reference,
        extraDataKey.reference,
        arguments.reference
      ]).check();

  static final _id_sendAccessibilityEventUnchecked = jniAccessors.getMethodIDOf(
      _classRef,
      "sendAccessibilityEventUnchecked",
      "(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent event)
  void sendAccessibilityEventUnchecked(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendAccessibilityEventUnchecked,
          jni.JniType.voidType,
          [event.reference]).check();

  static final _id_isInputMethodTarget =
      jniAccessors.getMethodIDOf(_classRef, "isInputMethodTarget", "()Z");

  /// from: public boolean isInputMethodTarget()
  ///
  /// Returns whether this text view is a current input method target.  The
  /// default implementation just checks with InputMethodManager.
  ///@return True if the TextView is a current input method target; false otherwise.
  bool isInputMethodTarget() => jniAccessors.callMethodWithArgs(
      reference, _id_isInputMethodTarget, jni.JniType.booleanType, []).boolean;

  static final _id_onTextContextMenuItem =
      jniAccessors.getMethodIDOf(_classRef, "onTextContextMenuItem", "(I)Z");

  /// from: public boolean onTextContextMenuItem(int id)
  ///
  /// Called when a context menu option for the text view is selected.  Currently
  /// this will be one of android.R.id\#selectAll, android.R.id\#cut,
  /// android.R.id\#copy, android.R.id\#paste or android.R.id\#shareText.
  ///@return true if the context menu item action was performed.
  bool onTextContextMenuItem(int id) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onTextContextMenuItem,
      jni.JniType.booleanType,
      [id]).boolean;

  static final _id_performLongClick =
      jniAccessors.getMethodIDOf(_classRef, "performLongClick", "()Z");

  /// from: public boolean performLongClick()
  bool performLongClick() => jniAccessors.callMethodWithArgs(
      reference, _id_performLongClick, jni.JniType.booleanType, []).boolean;

  static final _id_onScrollChanged =
      jniAccessors.getMethodIDOf(_classRef, "onScrollChanged", "(IIII)V");

  /// from: protected void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert)
  void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScrollChanged,
          jni.JniType.voidType, [horiz, vert, oldHoriz, oldVert]).check();

  static final _id_isSuggestionsEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isSuggestionsEnabled", "()Z");

  /// from: public boolean isSuggestionsEnabled()
  ///
  /// Return whether or not suggestions are enabled on this TextView. The suggestions are generated
  /// by the IME or by the spell checker as the user types. This is done by adding
  /// SuggestionSpans to the text.
  ///
  /// When suggestions are enabled (default), this list of suggestions will be displayed when the
  /// user asks for them on these parts of the text. This value depends on the inputType of this
  /// TextView.
  ///
  /// The class of the input type must be InputType\#TYPE_CLASS_TEXT.
  ///
  /// In addition, the type variation must be one of
  /// InputType\#TYPE_TEXT_VARIATION_NORMAL,
  /// InputType\#TYPE_TEXT_VARIATION_EMAIL_SUBJECT,
  /// InputType\#TYPE_TEXT_VARIATION_LONG_MESSAGE,
  /// InputType\#TYPE_TEXT_VARIATION_SHORT_MESSAGE or
  /// InputType\#TYPE_TEXT_VARIATION_WEB_EDIT_TEXT.
  ///
  /// And finally, the InputType\#TYPE_TEXT_FLAG_NO_SUGGESTIONS flag must <i>not</i> be set.
  ///@return true if the suggestions popup window is enabled, based on the inputType.
  bool isSuggestionsEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isSuggestionsEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setCustomSelectionActionModeCallback =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setCustomSelectionActionModeCallback",
          "(Landroid/view/ActionMode\$Callback;)V");

  /// from: public void setCustomSelectionActionModeCallback(android.view.ActionMode.Callback actionModeCallback)
  ///
  /// If provided, this ActionMode.Callback will be used to create the ActionMode when text
  /// selection is initiated in this View.
  ///
  /// The standard implementation populates the menu with a subset of Select All, Cut, Copy,
  /// Paste, Replace and Share actions, depending on what this View supports.
  ///
  /// A custom implementation can add new entries in the default menu in its
  /// android.view.ActionMode.Callback\#onPrepareActionMode(ActionMode, android.view.Menu)
  /// method. The default actions can also be removed from the menu using
  /// android.view.Menu\#removeItem(int) and passing android.R.id\#selectAll,
  /// android.R.id\#cut, android.R.id\#copy, android.R.id\#paste,
  /// android.R.id\#replaceText or android.R.id\#shareText ids as parameters.
  ///
  /// Returning false from
  /// android.view.ActionMode.Callback\#onCreateActionMode(ActionMode, android.view.Menu)
  /// will prevent the action mode from being started.
  ///
  /// Action click events should be handled by the custom implementation of
  /// android.view.ActionMode.Callback\#onActionItemClicked(ActionMode,
  /// android.view.MenuItem).
  ///
  /// Note that text selection mode is not started when a TextView receives focus and the
  /// android.R.attr\#selectAllOnFocus flag has been set. The content is highlighted in
  /// that case, to allow for quick replacement.
  void setCustomSelectionActionModeCallback(
          actionmode_.ActionMode_Callback actionModeCallback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCustomSelectionActionModeCallback,
          jni.JniType.voidType,
          [actionModeCallback.reference]).check();

  static final _id_getCustomSelectionActionModeCallback =
      jniAccessors.getMethodIDOf(
          _classRef,
          "getCustomSelectionActionModeCallback",
          "()Landroid/view/ActionMode\$Callback;");

  /// from: public android.view.ActionMode.Callback getCustomSelectionActionModeCallback()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the value set in \#setCustomSelectionActionModeCallback. Default is null.
  ///@return The current custom selection callback.
  actionmode_.ActionMode_Callback getCustomSelectionActionModeCallback() =>
      actionmode_.ActionMode_Callback.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCustomSelectionActionModeCallback,
          jni.JniType.objectType, []).object);

  static final _id_setCustomInsertionActionModeCallback =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setCustomInsertionActionModeCallback",
          "(Landroid/view/ActionMode\$Callback;)V");

  /// from: public void setCustomInsertionActionModeCallback(android.view.ActionMode.Callback actionModeCallback)
  ///
  /// If provided, this ActionMode.Callback will be used to create the ActionMode when text
  /// insertion is initiated in this View.
  /// The standard implementation populates the menu with a subset of Select All,
  /// Paste and Replace actions, depending on what this View supports.
  ///
  /// A custom implementation can add new entries in the default menu in its
  /// android.view.ActionMode.Callback\#onPrepareActionMode(android.view.ActionMode,
  /// android.view.Menu) method. The default actions can also be removed from the menu using
  /// android.view.Menu\#removeItem(int) and passing android.R.id\#selectAll,
  /// android.R.id\#paste or android.R.id\#replaceText ids as parameters.
  ///
  ///
  /// Returning false from
  /// android.view.ActionMode.Callback\#onCreateActionMode(android.view.ActionMode,
  /// android.view.Menu) will prevent the action mode from being started.
  ///
  ///
  /// Action click events should be handled by the custom implementation of
  /// android.view.ActionMode.Callback\#onActionItemClicked(android.view.ActionMode,
  /// android.view.MenuItem).
  ///
  ///
  /// Note that text insertion mode is not started when a TextView receives focus and the
  /// android.R.attr\#selectAllOnFocus flag has been set.
  ///
  void setCustomInsertionActionModeCallback(
          actionmode_.ActionMode_Callback actionModeCallback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCustomInsertionActionModeCallback,
          jni.JniType.voidType,
          [actionModeCallback.reference]).check();

  static final _id_getCustomInsertionActionModeCallback =
      jniAccessors.getMethodIDOf(
          _classRef,
          "getCustomInsertionActionModeCallback",
          "()Landroid/view/ActionMode\$Callback;");

  /// from: public android.view.ActionMode.Callback getCustomInsertionActionModeCallback()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the value set in \#setCustomInsertionActionModeCallback. Default is null.
  ///@return The current custom insertion callback.
  actionmode_.ActionMode_Callback getCustomInsertionActionModeCallback() =>
      actionmode_.ActionMode_Callback.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCustomInsertionActionModeCallback,
          jni.JniType.objectType, []).object);

  static final _id_setTextClassifier = jniAccessors.getMethodIDOf(_classRef,
      "setTextClassifier", "(Landroid/view/textclassifier/TextClassifier;)V");

  /// from: public void setTextClassifier(android.view.textclassifier.TextClassifier textClassifier)
  ///
  /// Sets the TextClassifier for this TextView.
  ///@param textClassifier This value may be {@code null}.
  void setTextClassifier(textclassifier_.TextClassifier textClassifier) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextClassifier,
          jni.JniType.voidType, [textClassifier.reference]).check();

  static final _id_getTextClassifier = jniAccessors.getMethodIDOf(_classRef,
      "getTextClassifier", "()Landroid/view/textclassifier/TextClassifier;");

  /// from: public android.view.textclassifier.TextClassifier getTextClassifier()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the TextClassifier used by this TextView.
  /// If no TextClassifier has been set, this TextView uses the default set by the
  /// TextClassificationManager.
  ///@return This value will never be {@code null}.
  textclassifier_.TextClassifier getTextClassifier() =>
      textclassifier_.TextClassifier.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextClassifier, jni.JniType.objectType, []).object);

  static final _id_getOffsetForPosition =
      jniAccessors.getMethodIDOf(_classRef, "getOffsetForPosition", "(FF)I");

  /// from: public int getOffsetForPosition(float x, float y)
  ///
  /// Get the character offset closest to the specified absolute position. A typical use case is to
  /// pass the result of MotionEvent\#getX() and MotionEvent\#getY() to this method.
  ///@param x The horizontal absolute position of a point on screen
  ///@param y The vertical absolute position of a point on screen
  ///@return the character offset for the character whose position is closest to the specified
  ///  position. Returns -1 if there is no layout.
  int getOffsetForPosition(double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_getOffsetForPosition,
          jni.JniType.intType, [x, y]).integer;

  static final _id_onDragEvent = jniAccessors.getMethodIDOf(
      _classRef, "onDragEvent", "(Landroid/view/DragEvent;)Z");

  /// from: public boolean onDragEvent(android.view.DragEvent event)
  bool onDragEvent(dragevent_.DragEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDragEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onRtlPropertiesChanged =
      jniAccessors.getMethodIDOf(_classRef, "onRtlPropertiesChanged", "(I)V");

  /// from: public void onRtlPropertiesChanged(int layoutDirection)
  void onRtlPropertiesChanged(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRtlPropertiesChanged,
          jni.JniType.voidType, [layoutDirection]).check();
}

/// from: android.widget.TextView$SavedState
///
/// User interface state that is stored by TextView for implementing
/// View\#onSaveInstanceState.
class TextView_SavedState extends view_.View_BaseSavedState {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/TextView\$SavedState");
  TextView_SavedState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR2 = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.widget.TextView.SavedState> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR2 =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR2, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/Parcelable;)V");

  /// from: void <init>(android.os.Parcelable superState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TextView_SavedState(parcelable_.Parcelable superState)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [superState.reference]).object);

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.widget.TextView$OnEditorActionListener
///
/// Interface definition for a callback to be invoked when an action is
/// performed on the editor.
class TextView_OnEditorActionListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/widget/TextView\$OnEditorActionListener");
  TextView_OnEditorActionListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onEditorAction = jniAccessors.getMethodIDOf(_classRef,
      "onEditorAction", "(Landroid/widget/TextView;ILandroid/view/KeyEvent;)Z");

  /// from: public abstract boolean onEditorAction(android.widget.TextView v, int actionId, android.view.KeyEvent event)
  ///
  /// Called when an action is being performed.
  ///@param v The view that was clicked.
  ///@param actionId Identifier of the action.  This will be either the
  /// identifier you supplied, or EditorInfo\#IME_NULL EditorInfo.IME_NULL if being called due to the enter key
  /// being pressed.
  ///@param event If triggered by an enter key, this is the event;
  /// otherwise, this is null.
  ///@return Return true if you have consumed the action, else false.
  bool onEditorAction(TextView v, int actionId, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onEditorAction,
          jni.JniType.booleanType,
          [v.reference, actionId, event.reference]).boolean;
}

/// from: android.widget.TextView$BufferType
///
/// Type of the text buffer that defines the characteristics of the text such as static,
/// styleable, or editable.
class TextView_BufferType extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/TextView\$BufferType");
  TextView_BufferType.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/widget/TextView\$BufferType;");

  /// from: static public android.widget.TextView.BufferType[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/widget/TextView\$BufferType;");

  /// from: static public android.widget.TextView.BufferType valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static TextView_BufferType valueOf(jni.JniString name) =>
      TextView_BufferType.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TextView_BufferType()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
