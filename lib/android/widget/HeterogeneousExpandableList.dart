// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.HeterogeneousExpandableList
///
/// Additional methods that when implemented make an
/// ExpandableListAdapter take advantage of the Adapter view type
/// mechanism.
///
/// An ExpandableListAdapter declares it has one view type for its group items
/// and one view type for its child items. Although adapted for most ExpandableListViews,
/// these values should be tuned for heterogeneous ExpandableListViews.
///
///
/// Lists that contain different types of group and/or child item views, should use an adapter that
/// implements this interface. This way, the recycled views that will be provided to
/// android.widget.ExpandableListAdapter\#getGroupView(int, boolean, View, ViewGroup)
/// and
/// android.widget.ExpandableListAdapter\#getChildView(int, int, boolean, View, ViewGroup)
/// will be of the appropriate group or child type, resulting in a more efficient reuse of the
/// previously created views.
class HeterogeneousExpandableList extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/HeterogeneousExpandableList");
  HeterogeneousExpandableList.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getGroupType =
      jniAccessors.getMethodIDOf(_classRef, "getGroupType", "(I)I");

  /// from: public abstract int getGroupType(int groupPosition)
  ///
  /// Get the type of group View that will be created by
  /// android.widget.ExpandableListAdapter\#getGroupView(int, boolean, View, ViewGroup)
  /// . for the specified group item.
  ///@param groupPosition the position of the group for which the type should be returned.
  ///@return An integer representing the type of group View. Two group views should share the same
  ///         type if one can be converted to the other in
  ///         android.widget.ExpandableListAdapter\#getGroupView(int, boolean, View, ViewGroup)
  ///         . Note: Integers must be in the range 0 to \#getGroupTypeCount - 1.
  ///         android.widget.Adapter\#IGNORE_ITEM_VIEW_TYPE can also be returned.
  ///@see android.widget.Adapter\#IGNORE_ITEM_VIEW_TYPE
  ///@see \#getGroupTypeCount()
  int getGroupType(int groupPosition) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getGroupType,
      jni.JniType.intType,
      [groupPosition]).integer;

  static final _id_getChildType =
      jniAccessors.getMethodIDOf(_classRef, "getChildType", "(II)I");

  /// from: public abstract int getChildType(int groupPosition, int childPosition)
  ///
  /// Get the type of child View that will be created by
  /// android.widget.ExpandableListAdapter\#getChildView(int, int, boolean, View, ViewGroup)
  /// for the specified child item.
  ///@param groupPosition the position of the group that the child resides in
  ///@param childPosition the position of the child with respect to other children in the group
  ///@return An integer representing the type of child View. Two child views should share the same
  ///         type if one can be converted to the other in
  ///         android.widget.ExpandableListAdapter\#getChildView(int, int, boolean, View, ViewGroup)
  ///         Note: Integers must be in the range 0 to \#getChildTypeCount - 1.
  ///         android.widget.Adapter\#IGNORE_ITEM_VIEW_TYPE can also be returned.
  ///@see android.widget.Adapter\#IGNORE_ITEM_VIEW_TYPE
  ///@see \#getChildTypeCount()
  int getChildType(int groupPosition, int childPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_getChildType,
          jni.JniType.intType, [groupPosition, childPosition]).integer;

  static final _id_getGroupTypeCount =
      jniAccessors.getMethodIDOf(_classRef, "getGroupTypeCount", "()I");

  /// from: public abstract int getGroupTypeCount()
  ///
  ///
  /// Returns the number of types of group Views that will be created by
  /// android.widget.ExpandableListAdapter\#getGroupView(int, boolean, View, ViewGroup)
  /// . Each type represents a set of views that can be converted in
  /// android.widget.ExpandableListAdapter\#getGroupView(int, boolean, View, ViewGroup)
  /// . If the adapter always returns the same type of View for all group items, this method should
  /// return 1.
  ///
  ///
  /// This method will only be called when the adapter is set on the AdapterView.
  ///@return The number of types of group Views that will be created by this adapter.
  ///@see \#getChildTypeCount()
  ///@see \#getGroupType(int)
  int getGroupTypeCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getGroupTypeCount, jni.JniType.intType, []).integer;

  static final _id_getChildTypeCount =
      jniAccessors.getMethodIDOf(_classRef, "getChildTypeCount", "()I");

  /// from: public abstract int getChildTypeCount()
  ///
  ///
  /// Returns the number of types of child Views that will be created by
  /// android.widget.ExpandableListAdapter\#getChildView(int, int, boolean, View, ViewGroup)
  /// . Each type represents a set of views that can be converted in
  /// android.widget.ExpandableListAdapter\#getChildView(int, int, boolean, View, ViewGroup)
  /// , for any group. If the adapter always returns the same type of View for
  /// all child items, this method should return 1.
  ///
  ///
  /// This method will only be called when the adapter is set on the AdapterView.
  ///@return The total number of types of child Views that will be created by this adapter.
  ///@see \#getGroupTypeCount()
  ///@see \#getChildType(int, int)
  int getChildTypeCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getChildTypeCount, jni.JniType.intType, []).integer;
}
