// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AdapterView.dart" as adapterview_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "SpinnerAdapter.dart" as spinneradapter_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../view/View.dart" as view_;

import "../util/SparseArray.dart" as sparsearray_;

import "../os/Parcelable.dart" as parcelable_;

import "../view/autofill/AutofillValue.dart" as autofillvalue_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.AbsSpinner
///
/// An abstract base class for spinner widgets. SDK users will probably not
/// need to use this class.
///@attr ref android.R.styleable\#AbsSpinner_entries
class AbsSpinner extends adapterview_.AdapterView {
  static final _classRef = jniAccessors.getClassOf("android/widget/AbsSpinner");
  AbsSpinner.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsSpinner(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsSpinner.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsSpinner.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbsSpinner.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_setAdapter1 = jniAccessors.getMethodIDOf(
      _classRef, "setAdapter", "(Landroid/widget/SpinnerAdapter;)V");

  /// from: public void setAdapter(android.widget.SpinnerAdapter adapter)
  ///
  /// The Adapter is used to provide the data which backs this Spinner.
  /// It also provides methods to transform spinner items based on their position
  /// relative to the selected item.
  ///@param adapter The SpinnerAdapter to use for this Spinner
  void setAdapter1(spinneradapter_.SpinnerAdapter adapter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAdapter1,
          jni.JniType.voidType, [adapter.reference]).check();

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  ///
  /// @see android.view.View\#measure(int, int) Figure out the dimensions of this Spinner. The width comes from
  /// the widthMeasureSpec as Spinnners can't have their width set to
  /// UNSPECIFIED. The height is based on the height of the selected item
  /// plus padding.
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_generateDefaultLayoutParams1 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateDefaultLayoutParams",
      "()Landroid/view/ViewGroup\$LayoutParams;");

  /// from: protected android.view.ViewGroup.LayoutParams generateDefaultLayoutParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  viewgroup_.ViewGroup_LayoutParams generateDefaultLayoutParams1() =>
      viewgroup_.ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateDefaultLayoutParams1,
          jni.JniType.objectType, []).object);

  static final _id_setSelection1 =
      jniAccessors.getMethodIDOf(_classRef, "setSelection", "(IZ)V");

  /// from: public void setSelection(int position, boolean animate)
  ///
  /// Jump directly to a specific item in the adapter data.
  void setSelection1(int position, bool animate) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSelection1,
          jni.JniType.voidType, [position, animate]).check();

  static final _id_setSelection =
      jniAccessors.getMethodIDOf(_classRef, "setSelection", "(I)V");

  /// from: public void setSelection(int position)
  void setSelection(int position) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelection, jni.JniType.voidType, [position]).check();

  static final _id_getSelectedView = jniAccessors.getMethodIDOf(
      _classRef, "getSelectedView", "()Landroid/view/View;");

  /// from: public android.view.View getSelectedView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  view_.View getSelectedView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSelectedView, jni.JniType.objectType, []).object);

  static final _id_requestLayout1 =
      jniAccessors.getMethodIDOf(_classRef, "requestLayout", "()V");

  /// from: public void requestLayout()
  ///
  /// Override to prevent spamming ourselves with layout requests
  /// as we place views
  ///@see android.view.View\#requestLayout()
  void requestLayout1() => jniAccessors.callMethodWithArgs(
      reference, _id_requestLayout1, jni.JniType.voidType, []).check();

  static final _id_getAdapter1 = jniAccessors.getMethodIDOf(
      _classRef, "getAdapter", "()Landroid/widget/SpinnerAdapter;");

  /// from: public android.widget.SpinnerAdapter getAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  spinneradapter_.SpinnerAdapter getAdapter1() =>
      spinneradapter_.SpinnerAdapter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAdapter1, jni.JniType.objectType, []).object);

  static final _id_getCount =
      jniAccessors.getMethodIDOf(_classRef, "getCount", "()I");

  /// from: public int getCount()
  int getCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getCount, jni.JniType.intType, []).integer;

  static final _id_pointToPosition =
      jniAccessors.getMethodIDOf(_classRef, "pointToPosition", "(II)I");

  /// from: public int pointToPosition(int x, int y)
  ///
  /// Maps a point to a position in the list.
  ///@param x X in local coordinate
  ///@param y Y in local coordinate
  ///@return The position of the item which contains the specified point, or
  ///         \#INVALID_POSITION if the point does not intersect an item.
  int pointToPosition(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_pointToPosition, jni.JniType.intType, [x, y]).integer;

  static final _id_dispatchRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchRestoreInstanceState",
      "(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchRestoreInstanceState(android.util.SparseArray<android.os.Parcelable> container)
  void dispatchRestoreInstanceState(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchRestoreInstanceState,
          jni.JniType.voidType,
          [container.reference]).check();

  static final _id_onSaveInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  parcelable_.Parcelable onSaveInstanceState1() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState1, jni.JniType.objectType, []).object);

  static final _id_onRestoreInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: public void onRestoreInstanceState(android.os.Parcelable state)
  void onRestoreInstanceState1(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState1,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_autofill2 = jniAccessors.getMethodIDOf(
      _classRef, "autofill", "(Landroid/view/autofill/AutofillValue;)V");

  /// from: public void autofill(android.view.autofill.AutofillValue value)
  void autofill2(autofillvalue_.AutofillValue value) =>
      jniAccessors.callMethodWithArgs(reference, _id_autofill2,
          jni.JniType.voidType, [value.reference]).check();

  static final _id_getAutofillType1 =
      jniAccessors.getMethodIDOf(_classRef, "getAutofillType", "()I");

  /// from: public int getAutofillType()
  ///
  /// @return Value is android.view.View\#AUTOFILL_TYPE_NONE, android.view.View\#AUTOFILL_TYPE_TEXT, android.view.View\#AUTOFILL_TYPE_TOGGLE, android.view.View\#AUTOFILL_TYPE_LIST, or android.view.View\#AUTOFILL_TYPE_DATE
  int getAutofillType1() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutofillType1, jni.JniType.intType, []).integer;

  static final _id_getAutofillValue1 = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillValue", "()Landroid/view/autofill/AutofillValue;");

  /// from: public android.view.autofill.AutofillValue getAutofillValue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  autofillvalue_.AutofillValue getAutofillValue1() =>
      autofillvalue_.AutofillValue.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillValue1, jni.JniType.objectType, []).object);
}
