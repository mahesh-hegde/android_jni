// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ImageView.dart" as imageview_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../graphics/Canvas.dart" as canvas_;

import "../net/Uri.dart" as uri_;

import "../os/Bundle.dart" as bundle_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../view/View.dart" as view_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.QuickContactBadge
///
/// Widget used to show an image with the standard QuickContact badge
/// and on-click behavior.
class QuickContactBadge extends imageview_.ImageView {
  static final _classRef =
      jniAccessors.getClassOf("android/widget/QuickContactBadge");
  QuickContactBadge.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_mExcludeMimes = jniAccessors.getFieldIDOf(
      _classRef, "mExcludeMimes", "[Ljava/lang/String;");

  /// from: protected java.lang.String[] mExcludeMimes
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get mExcludeMimes => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_mExcludeMimes, jni.JniType.objectType)
      .object);

  /// from: protected java.lang.String[] mExcludeMimes
  /// The returned object must be deleted after use, by calling the `delete` method.
  set mExcludeMimes(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_mExcludeMimes, value.reference);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  QuickContactBadge(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  QuickContactBadge.ctor1(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  QuickContactBadge.ctor2(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  QuickContactBadge.ctor3(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_drawableStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableStateChanged", "()V");

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_drawableStateChanged, jni.JniType.voidType, []).check();

  static final _id_drawableHotspotChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableHotspotChanged", "(FF)V");

  /// from: public void drawableHotspotChanged(float x, float y)
  void drawableHotspotChanged(double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawableHotspotChanged,
          jni.JniType.voidType, [x, y]).check();

  static final _id_setMode =
      jniAccessors.getMethodIDOf(_classRef, "setMode", "(I)V");

  /// from: public void setMode(int size)
  ///
  /// This call has no effect anymore, as there is only one QuickContact mode
  void setMode(int size) => jniAccessors.callMethodWithArgs(
      reference, _id_setMode, jni.JniType.voidType, [size]).check();

  static final _id_setPrioritizedMimeType = jniAccessors.getMethodIDOf(
      _classRef, "setPrioritizedMimeType", "(Ljava/lang/String;)V");

  /// from: public void setPrioritizedMimeType(java.lang.String prioritizedMimeType)
  ///
  /// Set which mimetype should be prioritized in the QuickContacts UI. For example, passing the
  /// value Email\#CONTENT_ITEM_TYPE can cause emails to be displayed more prominently in
  /// QuickContacts.
  void setPrioritizedMimeType(jni.JniString prioritizedMimeType) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPrioritizedMimeType,
          jni.JniType.voidType, [prioritizedMimeType.reference]).check();

  static final _id_onDraw = jniAccessors.getMethodIDOf(
      _classRef, "onDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_onDraw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_setImageToDefault =
      jniAccessors.getMethodIDOf(_classRef, "setImageToDefault", "()V");

  /// from: public void setImageToDefault()
  ///
  /// Resets the contact photo to the default state.
  void setImageToDefault() => jniAccessors.callMethodWithArgs(
      reference, _id_setImageToDefault, jni.JniType.voidType, []).check();

  static final _id_assignContactUri = jniAccessors.getMethodIDOf(
      _classRef, "assignContactUri", "(Landroid/net/Uri;)V");

  /// from: public void assignContactUri(android.net.Uri contactUri)
  ///
  /// Assign the contact uri that this QuickContactBadge should be associated
  /// with. Note that this is only used for displaying the QuickContact window and
  /// won't bind the contact's photo for you. Call \#setImageDrawable(Drawable) to set the
  /// photo.
  ///@param contactUri Either a Contacts\#CONTENT_URI or
  ///            Contacts\#CONTENT_LOOKUP_URI style URI.
  void assignContactUri(uri_.Uri contactUri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_assignContactUri,
      jni.JniType.voidType,
      [contactUri.reference]).check();

  static final _id_assignContactFromEmail = jniAccessors.getMethodIDOf(
      _classRef, "assignContactFromEmail", "(Ljava/lang/String;Z)V");

  /// from: public void assignContactFromEmail(java.lang.String emailAddress, boolean lazyLookup)
  ///
  /// Assign a contact based on an email address. This should only be used when
  /// the contact's URI is not available, as an extra query will have to be
  /// performed to lookup the URI based on the email.
  ///@param emailAddress The email address of the contact.
  ///@param lazyLookup If this is true, the lookup query will not be performed
  /// until this view is clicked.
  void assignContactFromEmail(jni.JniString emailAddress, bool lazyLookup) =>
      jniAccessors.callMethodWithArgs(reference, _id_assignContactFromEmail,
          jni.JniType.voidType, [emailAddress.reference, lazyLookup]).check();

  static final _id_assignContactFromEmail1 = jniAccessors.getMethodIDOf(
      _classRef,
      "assignContactFromEmail",
      "(Ljava/lang/String;ZLandroid/os/Bundle;)V");

  /// from: public void assignContactFromEmail(java.lang.String emailAddress, boolean lazyLookup, android.os.Bundle extras)
  ///
  /// Assign a contact based on an email address. This should only be used when
  /// the contact's URI is not available, as an extra query will have to be
  /// performed to lookup the URI based on the email.
  ///@param emailAddress The email address of the contact.
  ///@param lazyLookup If this is true, the lookup query will not be performed
  /// until this view is clicked.
  ///@param extras A bundle of extras to populate the contact edit page with if the contact
  /// is not found and the user chooses to add the email address to an existing contact or
  /// create a new contact. Uses the same string constants as those found in
  /// android.provider.ContactsContract.Intents.Insert
  void assignContactFromEmail1(
          jni.JniString emailAddress, bool lazyLookup, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_assignContactFromEmail1,
          jni.JniType.voidType,
          [emailAddress.reference, lazyLookup, extras.reference]).check();

  static final _id_assignContactFromPhone = jniAccessors.getMethodIDOf(
      _classRef, "assignContactFromPhone", "(Ljava/lang/String;Z)V");

  /// from: public void assignContactFromPhone(java.lang.String phoneNumber, boolean lazyLookup)
  ///
  /// Assign a contact based on a phone number. This should only be used when
  /// the contact's URI is not available, as an extra query will have to be
  /// performed to lookup the URI based on the phone number.
  ///@param phoneNumber The phone number of the contact.
  ///@param lazyLookup If this is true, the lookup query will not be performed
  /// until this view is clicked.
  void assignContactFromPhone(jni.JniString phoneNumber, bool lazyLookup) =>
      jniAccessors.callMethodWithArgs(reference, _id_assignContactFromPhone,
          jni.JniType.voidType, [phoneNumber.reference, lazyLookup]).check();

  static final _id_assignContactFromPhone1 = jniAccessors.getMethodIDOf(
      _classRef,
      "assignContactFromPhone",
      "(Ljava/lang/String;ZLandroid/os/Bundle;)V");

  /// from: public void assignContactFromPhone(java.lang.String phoneNumber, boolean lazyLookup, android.os.Bundle extras)
  ///
  /// Assign a contact based on a phone number. This should only be used when
  /// the contact's URI is not available, as an extra query will have to be
  /// performed to lookup the URI based on the phone number.
  ///@param phoneNumber The phone number of the contact.
  ///@param lazyLookup If this is true, the lookup query will not be performed
  /// until this view is clicked.
  ///@param extras A bundle of extras to populate the contact edit page with if the contact
  /// is not found and the user chooses to add the phone number to an existing contact or
  /// create a new contact. Uses the same string constants as those found in
  /// android.provider.ContactsContract.Intents.Insert
  void assignContactFromPhone1(
          jni.JniString phoneNumber, bool lazyLookup, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_assignContactFromPhone1,
          jni.JniType.voidType,
          [phoneNumber.reference, lazyLookup, extras.reference]).check();

  static final _id_setOverlay = jniAccessors.getMethodIDOf(
      _classRef, "setOverlay", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setOverlay(android.graphics.drawable.Drawable overlay)
  ///
  /// Assigns the drawable that is to be drawn on top of the assigned contact photo.
  ///@param overlay Drawable to be drawn over the assigned contact photo. Must have a non-zero
  ///         instrinsic width and height.
  void setOverlay(drawable_.Drawable overlay) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOverlay,
          jni.JniType.voidType, [overlay.reference]).check();

  static final _id_onClick = jniAccessors.getMethodIDOf(
      _classRef, "onClick", "(Landroid/view/View;)V");

  /// from: public void onClick(android.view.View v)
  void onClick(view_.View v) => jniAccessors.callMethodWithArgs(
      reference, _id_onClick, jni.JniType.voidType, [v.reference]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_setExcludeMimes = jniAccessors.getMethodIDOf(
      _classRef, "setExcludeMimes", "([Ljava/lang/String;)V");

  /// from: public void setExcludeMimes(java.lang.String[] excludeMimes)
  ///
  /// Set a list of specific MIME-types to exclude and not display. For
  /// example, this can be used to hide the Contacts\#CONTENT_ITEM_TYPE
  /// profile icon.
  void setExcludeMimes(jni.JniObject excludeMimes) =>
      jniAccessors.callMethodWithArgs(reference, _id_setExcludeMimes,
          jni.JniType.voidType, [excludeMimes.reference]).check();
}
