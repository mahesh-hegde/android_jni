// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/SurfaceView.dart" as surfaceview_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../net/Uri.dart" as uri_;

import "../media/AudioAttributes.dart" as audioattributes_;

import "../media/MediaFormat.dart" as mediaformat_;

import "MediaController.dart" as mediacontroller_;

import "../media/MediaPlayer.dart" as mediaplayer_;

import "../view/MotionEvent.dart" as motionevent_;

import "../view/KeyEvent.dart" as keyevent_;

import "../graphics/Canvas.dart" as canvas_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.widget.VideoView
///
/// Displays a video file.  The VideoView class
/// can load images from various sources (such as resources or content
/// providers), takes care of computing its measurement from the video so that
/// it can be used in any layout manager, and provides various display options
/// such as scaling and tinting.
///
/// _Note: VideoView does not retain its full state when going into the
/// background._  In particular, it does not restore the current play state,
/// play position, selected tracks, or any subtitle tracks added via
/// \#addSubtitleSource addSubtitleSource().  Applications should
/// save and restore these on their own in
/// android.app.Activity\#onSaveInstanceState and
/// android.app.Activity\#onRestoreInstanceState.
/// Also note that the audio session id (from \#getAudioSessionId) may
/// change from its previously returned value when the VideoView is restored.
///
/// By default, VideoView requests audio focus with AudioManager\#AUDIOFOCUS_GAIN. Use
/// \#setAudioFocusRequest(int) to change this behavior.
///
/// The default AudioAttributes used during playback have a usage of
/// AudioAttributes\#USAGE_MEDIA and a content type of
/// AudioAttributes\#CONTENT_TYPE_MOVIE, use \#setAudioAttributes(AudioAttributes) to
/// modify them.
class VideoView extends surfaceview_.SurfaceView {
  static final _classRef = jniAccessors.getClassOf("android/widget/VideoView");
  VideoView.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  VideoView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  VideoView.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  VideoView.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  VideoView.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_onMeasure =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_getAccessibilityClassName1 = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName1() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName1, jni.JniType.objectType, []).object);

  static final _id_resolveAdjustedSize =
      jniAccessors.getMethodIDOf(_classRef, "resolveAdjustedSize", "(II)I");

  /// from: public int resolveAdjustedSize(int desiredSize, int measureSpec)
  int resolveAdjustedSize(int desiredSize, int measureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_resolveAdjustedSize,
          jni.JniType.intType, [desiredSize, measureSpec]).integer;

  static final _id_setVideoPath = jniAccessors.getMethodIDOf(
      _classRef, "setVideoPath", "(Ljava/lang/String;)V");

  /// from: public void setVideoPath(java.lang.String path)
  ///
  /// Sets video path.
  ///@param path the path of the video.
  void setVideoPath(jni.JniString path) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVideoPath,
      jni.JniType.voidType,
      [path.reference]).check();

  static final _id_setVideoURI = jniAccessors.getMethodIDOf(
      _classRef, "setVideoURI", "(Landroid/net/Uri;)V");

  /// from: public void setVideoURI(android.net.Uri uri)
  ///
  /// Sets video URI.
  ///@param uri the URI of the video.
  void setVideoURI(uri_.Uri uri) => jniAccessors.callMethodWithArgs(reference,
      _id_setVideoURI, jni.JniType.voidType, [uri.reference]).check();

  static final _id_setVideoURI1 = jniAccessors.getMethodIDOf(
      _classRef, "setVideoURI", "(Landroid/net/Uri;Ljava/util/Map;)V");

  /// from: public void setVideoURI(android.net.Uri uri, java.util.Map<java.lang.String,java.lang.String> headers)
  ///
  /// Sets video URI using specific headers.
  ///@param uri the URI of the video.
  ///@param headers the headers for the URI request.
  ///                Note that the cross domain redirection is allowed by default, but that can be
  ///                changed with key/value pairs through the headers parameter with
  ///                "android-allow-cross-domain-redirect" as the key and "0" or "1" as the value
  ///                to disallow or allow cross domain redirection.
  void setVideoURI1(uri_.Uri uri, jni.JniObject headers) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVideoURI1,
          jni.JniType.voidType, [uri.reference, headers.reference]).check();

  static final _id_setAudioFocusRequest =
      jniAccessors.getMethodIDOf(_classRef, "setAudioFocusRequest", "(I)V");

  /// from: public void setAudioFocusRequest(int focusGain)
  ///
  /// Sets which type of audio focus will be requested during the playback, or configures playback
  /// to not request audio focus. Valid values for focus requests are
  /// AudioManager\#AUDIOFOCUS_GAIN, AudioManager\#AUDIOFOCUS_GAIN_TRANSIENT,
  /// AudioManager\#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK, and
  /// AudioManager\#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE. Or use
  /// AudioManager\#AUDIOFOCUS_NONE to express that audio focus should not be
  /// requested when playback starts. You can for instance use this when playing a silent animation
  /// through this class, and you don't want to affect other audio applications playing in the
  /// background.
  ///@param focusGain the type of audio focus gain that will be requested, or
  ///    AudioManager\#AUDIOFOCUS_NONE to disable the use audio focus during playback.
  void setAudioFocusRequest(int focusGain) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAudioFocusRequest,
      jni.JniType.voidType,
      [focusGain]).check();

  static final _id_setAudioAttributes = jniAccessors.getMethodIDOf(
      _classRef, "setAudioAttributes", "(Landroid/media/AudioAttributes;)V");

  /// from: public void setAudioAttributes(android.media.AudioAttributes attributes)
  ///
  /// Sets the AudioAttributes to be used during the playback of the video.
  ///@param attributes non-null <code>AudioAttributes</code>.
  ///
  /// This value must never be {@code null}.
  void setAudioAttributes(audioattributes_.AudioAttributes attributes) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAudioAttributes,
          jni.JniType.voidType, [attributes.reference]).check();

  static final _id_addSubtitleSource = jniAccessors.getMethodIDOf(
      _classRef,
      "addSubtitleSource",
      "(Ljava/io/InputStream;Landroid/media/MediaFormat;)V");

  /// from: public void addSubtitleSource(java.io.InputStream is, android.media.MediaFormat format)
  ///
  /// Adds an external subtitle source file (from the provided input stream.)
  ///
  /// Note that a single external subtitle source may contain multiple or no
  /// supported tracks in it. If the source contained at least one track in
  /// it, one will receive an MediaPlayer\#MEDIA_INFO_METADATA_UPDATE
  /// info message. Otherwise, if reading the source takes excessive time,
  /// one will receive a MediaPlayer\#MEDIA_INFO_SUBTITLE_TIMED_OUT
  /// message. If the source contained no supported track (including an empty
  /// source file or null input stream), one will receive a MediaPlayer\#MEDIA_INFO_UNSUPPORTED_SUBTITLE message. One can find the
  /// total number of available tracks using MediaPlayer\#getTrackInfo()
  /// to see what additional tracks become available after this method call.
  ///@param is input stream containing the subtitle data.  It will be
  ///               closed by the media framework.
  ///@param format the format of the subtitle track(s).  Must contain at least
  ///               the mime type (MediaFormat\#KEY_MIME) and the
  ///               language (MediaFormat\#KEY_LANGUAGE) of the file.
  ///               If the file itself contains the language information,
  ///               specify "und" for the language.
  void addSubtitleSource(jni.JniObject is0, mediaformat_.MediaFormat format) =>
      jniAccessors.callMethodWithArgs(reference, _id_addSubtitleSource,
          jni.JniType.voidType, [is0.reference, format.reference]).check();

  static final _id_stopPlayback =
      jniAccessors.getMethodIDOf(_classRef, "stopPlayback", "()V");

  /// from: public void stopPlayback()
  void stopPlayback() => jniAccessors.callMethodWithArgs(
      reference, _id_stopPlayback, jni.JniType.voidType, []).check();

  static final _id_setMediaController = jniAccessors.getMethodIDOf(
      _classRef, "setMediaController", "(Landroid/widget/MediaController;)V");

  /// from: public void setMediaController(android.widget.MediaController controller)
  void setMediaController(mediacontroller_.MediaController controller) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMediaController,
          jni.JniType.voidType, [controller.reference]).check();

  static final _id_setOnPreparedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnPreparedListener",
      "(Landroid/media/MediaPlayer\$OnPreparedListener;)V");

  /// from: public void setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener l)
  ///
  /// Register a callback to be invoked when the media file
  /// is loaded and ready to go.
  ///@param l The callback that will be run
  void setOnPreparedListener(mediaplayer_.MediaPlayer_OnPreparedListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnPreparedListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnCompletionListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnCompletionListener",
      "(Landroid/media/MediaPlayer\$OnCompletionListener;)V");

  /// from: public void setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener l)
  ///
  /// Register a callback to be invoked when the end of a media file
  /// has been reached during playback.
  ///@param l The callback that will be run
  void setOnCompletionListener(
          mediaplayer_.MediaPlayer_OnCompletionListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnCompletionListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnErrorListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnErrorListener", "(Landroid/media/MediaPlayer\$OnErrorListener;)V");

  /// from: public void setOnErrorListener(android.media.MediaPlayer.OnErrorListener l)
  ///
  /// Register a callback to be invoked when an error occurs
  /// during playback or setup.  If no listener is specified,
  /// or if the listener returned false, VideoView will inform
  /// the user of any errors.
  ///@param l The callback that will be run
  void setOnErrorListener(mediaplayer_.MediaPlayer_OnErrorListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnErrorListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnInfoListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnInfoListener", "(Landroid/media/MediaPlayer\$OnInfoListener;)V");

  /// from: public void setOnInfoListener(android.media.MediaPlayer.OnInfoListener l)
  ///
  /// Register a callback to be invoked when an informational event
  /// occurs during playback or setup.
  ///@param l The callback that will be run
  void setOnInfoListener(mediaplayer_.MediaPlayer_OnInfoListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnInfoListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_onTouchEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent ev)
  bool onTouchEvent1(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent1,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_onTrackballEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent ev)
  bool onTrackballEvent1(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTrackballEvent1,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_onKeyDown1 = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  bool onKeyDown1(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown1,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "()V");

  /// from: public void start()
  void start() => jniAccessors.callMethodWithArgs(
      reference, _id_start, jni.JniType.voidType, []).check();

  static final _id_pause =
      jniAccessors.getMethodIDOf(_classRef, "pause", "()V");

  /// from: public void pause()
  void pause() => jniAccessors.callMethodWithArgs(
      reference, _id_pause, jni.JniType.voidType, []).check();

  static final _id_suspend =
      jniAccessors.getMethodIDOf(_classRef, "suspend", "()V");

  /// from: public void suspend()
  void suspend() => jniAccessors.callMethodWithArgs(
      reference, _id_suspend, jni.JniType.voidType, []).check();

  static final _id_resume =
      jniAccessors.getMethodIDOf(_classRef, "resume", "()V");

  /// from: public void resume()
  void resume() => jniAccessors.callMethodWithArgs(
      reference, _id_resume, jni.JniType.voidType, []).check();

  static final _id_getDuration =
      jniAccessors.getMethodIDOf(_classRef, "getDuration", "()I");

  /// from: public int getDuration()
  int getDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getDuration, jni.JniType.intType, []).integer;

  static final _id_getCurrentPosition =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentPosition", "()I");

  /// from: public int getCurrentPosition()
  int getCurrentPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentPosition, jni.JniType.intType, []).integer;

  static final _id_seekTo =
      jniAccessors.getMethodIDOf(_classRef, "seekTo", "(I)V");

  /// from: public void seekTo(int msec)
  void seekTo(int msec) => jniAccessors.callMethodWithArgs(
      reference, _id_seekTo, jni.JniType.voidType, [msec]).check();

  static final _id_isPlaying =
      jniAccessors.getMethodIDOf(_classRef, "isPlaying", "()Z");

  /// from: public boolean isPlaying()
  bool isPlaying() => jniAccessors.callMethodWithArgs(
      reference, _id_isPlaying, jni.JniType.booleanType, []).boolean;

  static final _id_getBufferPercentage =
      jniAccessors.getMethodIDOf(_classRef, "getBufferPercentage", "()I");

  /// from: public int getBufferPercentage()
  int getBufferPercentage() => jniAccessors.callMethodWithArgs(
      reference, _id_getBufferPercentage, jni.JniType.intType, []).integer;

  static final _id_canPause =
      jniAccessors.getMethodIDOf(_classRef, "canPause", "()Z");

  /// from: public boolean canPause()
  bool canPause() => jniAccessors.callMethodWithArgs(
      reference, _id_canPause, jni.JniType.booleanType, []).boolean;

  static final _id_canSeekBackward =
      jniAccessors.getMethodIDOf(_classRef, "canSeekBackward", "()Z");

  /// from: public boolean canSeekBackward()
  bool canSeekBackward() => jniAccessors.callMethodWithArgs(
      reference, _id_canSeekBackward, jni.JniType.booleanType, []).boolean;

  static final _id_canSeekForward =
      jniAccessors.getMethodIDOf(_classRef, "canSeekForward", "()Z");

  /// from: public boolean canSeekForward()
  bool canSeekForward() => jniAccessors.callMethodWithArgs(
      reference, _id_canSeekForward, jni.JniType.booleanType, []).boolean;

  static final _id_getAudioSessionId =
      jniAccessors.getMethodIDOf(_classRef, "getAudioSessionId", "()I");

  /// from: public int getAudioSessionId()
  int getAudioSessionId() => jniAccessors.callMethodWithArgs(
      reference, _id_getAudioSessionId, jni.JniType.intType, []).integer;

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_onLayout1 =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int left, int top, int right, int bottom)
  void onLayout1(bool changed, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout1,
          jni.JniType.voidType, [changed, left, top, right, bottom]).check();

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();
}
