// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Conferenceable.dart" as conferenceable_;

import "../net/Uri.dart" as uri_;

import "CallAudioState.dart" as callaudiostate_;

import "Conference.dart" as conference_;

import "StatusHints.dart" as statushints_;

import "../os/Bundle.dart" as bundle_;

import "DisconnectCause.dart" as disconnectcause_;

import "../bluetooth/BluetoothDevice.dart" as bluetoothdevice_;

import "../view/Surface.dart" as surface_;

import "VideoProfile.dart" as videoprofile_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telecom.Connection
///
/// Represents a phone call or connection to a remote endpoint that carries voice and/or video
/// traffic.
///
/// Implementations create a custom subclass of {@code Connection} and return it to the framework
/// as the return value of
/// ConnectionService\#onCreateIncomingConnection(PhoneAccountHandle, ConnectionRequest)
/// or
/// ConnectionService\#onCreateOutgoingConnection(PhoneAccountHandle, ConnectionRequest).
/// Implementations are then responsible for updating the state of the {@code Connection}, and
/// must call \#destroy() to signal to the framework that the {@code Connection} is no
/// longer used and associated resources may be recovered.
///
/// Subclasses of {@code Connection} override the {@code on*} methods to provide the the
/// ConnectionService's implementation of calling functionality.  The {@code on*} methods are
/// called by Telecom to inform an instance of a {@code Connection} of actions specific to that
/// {@code Connection} instance.
///
/// Basic call support requires overriding the following methods: \#onAnswer(),
/// \#onDisconnect(), \#onReject(), \#onAbort()
///
/// Where a {@code Connection} has \#CAPABILITY_SUPPORT_HOLD, the \#onHold() and
/// \#onUnhold() methods should be overridden to provide hold support for the
/// {@code Connection}.
///
/// Where a {@code Connection} supports a variation of video calling (e.g. the
/// {@code CAPABILITY_SUPPORTS_VT_*} capability bits), \#onAnswer(int) should be overridden
/// to support answering a call as a video call.
///
/// Where a {@code Connection} has \#PROPERTY_IS_EXTERNAL_CALL and
/// \#CAPABILITY_CAN_PULL_CALL, \#onPullExternalCall() should be overridden to provide
/// support for pulling the external call.
///
/// Where a {@code Connection} supports conference calling \#onSeparate() should be
/// overridden.
///
/// There are a number of other {@code on*} methods which a {@code Connection} can choose to
/// implement, depending on whether it is concerned with the associated calls from Telecom.  If,
/// for example, call events from a InCallService are handled,
/// \#onCallEvent(String, Bundle) should be overridden.  Another example is
/// \#onExtrasChanged(Bundle), which should be overridden if the {@code Connection} wishes to
/// make use of extra information provided via the Call\#putExtras(Bundle) and
/// Call\#removeExtras(String...) methods.
class Connection extends conferenceable_.Conferenceable {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/Connection");
  Connection.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO
  ///
  /// When set, prevents a video call from being downgraded to an audio-only call.
  ///
  /// Should be set when the VideoState has the VideoProfile\#STATE_TX_ENABLED or
  /// VideoProfile\#STATE_RX_ENABLED bits set to indicate that the connection cannot be
  /// downgraded from a video call back to a VideoState of
  /// VideoProfile\#STATE_AUDIO_ONLY.
  ///
  /// Intuitively, a call which can be downgraded to audio should also have local and remote
  /// video
  /// capabilities (see \#CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL and
  /// \#CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL).
  static const CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO = 8388608;

  /// from: static public final int CAPABILITY_CAN_PAUSE_VIDEO
  ///
  /// For video calls, indicates whether the outgoing video for the call can be paused using
  /// the android.telecom.VideoProfile\#STATE_PAUSED VideoState.
  static const CAPABILITY_CAN_PAUSE_VIDEO = 1048576;

  /// from: static public final int CAPABILITY_CAN_PULL_CALL
  ///
  /// When set for an external connection, indicates that this {@code Connection} can be pulled
  /// from a remote device to the current device.
  ///
  /// Should only be set on a {@code Connection} where \#PROPERTY_IS_EXTERNAL_CALL
  /// is set.
  static const CAPABILITY_CAN_PULL_CALL = 16777216;

  /// from: static public final int CAPABILITY_CAN_SEND_RESPONSE_VIA_CONNECTION
  ///
  /// Indicates that the connection itself wants to handle any sort of reply response, rather than
  /// relying on SMS.
  static const CAPABILITY_CAN_SEND_RESPONSE_VIA_CONNECTION = 4194304;

  /// from: static public final int CAPABILITY_CAN_UPGRADE_TO_VIDEO
  ///
  /// Call can be upgraded to a video call.
  static const CAPABILITY_CAN_UPGRADE_TO_VIDEO = 524288;

  /// from: static public final int CAPABILITY_DISCONNECT_FROM_CONFERENCE
  ///
  /// Connection is able to be individually disconnected when in a {@code Conference}.
  static const CAPABILITY_DISCONNECT_FROM_CONFERENCE = 8192;

  /// from: static public final int CAPABILITY_HOLD
  ///
  /// Connection can currently be put on hold or unheld. This is distinct from
  /// \#CAPABILITY_SUPPORT_HOLD in that although a connection may support 'hold' most times,
  /// it does not at the moment support the function. This can be true while the call is in the
  /// state \#STATE_DIALING, for example. During this condition, an in-call UI may
  /// display a disabled 'hold' button.
  static const CAPABILITY_HOLD = 1;

  /// from: static public final int CAPABILITY_MANAGE_CONFERENCE
  ///
  /// Connection supports conference management. This capability only applies to
  /// Conferences which can have Connections as children.
  static const CAPABILITY_MANAGE_CONFERENCE = 128;

  /// from: static public final int CAPABILITY_MERGE_CONFERENCE
  ///
  /// Connections within a conference can be merged. A ConnectionService has the option to
  /// add a Conference before the child Connections are merged. This is how
  /// CDMA-based Connections are implemented. For these unmerged Conferences, this
  /// capability allows a merge button to be shown while the conference is in the foreground
  /// of the in-call UI.
  ///
  /// This is only intended for use by a Conference.
  static const CAPABILITY_MERGE_CONFERENCE = 4;

  /// from: static public final int CAPABILITY_MUTE
  ///
  /// Connection can be muted.
  static const CAPABILITY_MUTE = 64;

  /// from: static public final int CAPABILITY_RESPOND_VIA_TEXT
  ///
  /// Connection supports responding via text option.
  static const CAPABILITY_RESPOND_VIA_TEXT = 32;

  /// from: static public final int CAPABILITY_SEPARATE_FROM_CONFERENCE
  ///
  /// Connection is able to be separated from its parent {@code Conference}, if any.
  static const CAPABILITY_SEPARATE_FROM_CONFERENCE = 4096;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL
  ///
  /// Local device supports bidirectional video calling.
  static const CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL = 768;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_LOCAL_RX
  ///
  /// Local device supports receiving video.
  static const CAPABILITY_SUPPORTS_VT_LOCAL_RX = 256;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_LOCAL_TX
  ///
  /// Local device supports transmitting video.
  static const CAPABILITY_SUPPORTS_VT_LOCAL_TX = 512;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL
  ///
  /// Remote device supports bidirectional video calling.
  static const CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL = 3072;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_REMOTE_RX
  ///
  /// Remote device supports receiving video.
  static const CAPABILITY_SUPPORTS_VT_REMOTE_RX = 1024;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_REMOTE_TX
  ///
  /// Remote device supports transmitting video.
  static const CAPABILITY_SUPPORTS_VT_REMOTE_TX = 2048;

  /// from: static public final int CAPABILITY_SUPPORT_DEFLECT
  ///
  /// Call supports the deflect feature.
  static const CAPABILITY_SUPPORT_DEFLECT = 33554432;

  /// from: static public final int CAPABILITY_SUPPORT_HOLD
  ///
  /// Connection supports the hold feature.
  static const CAPABILITY_SUPPORT_HOLD = 2;

  /// from: static public final int CAPABILITY_SWAP_CONFERENCE
  ///
  /// Connections within a conference can be swapped between foreground and background.
  /// See \#CAPABILITY_MERGE_CONFERENCE for additional information.
  ///
  /// This is only intended for use by a Conference.
  static const CAPABILITY_SWAP_CONFERENCE = 8;

  /// from: static public final java.lang.String EVENT_CALL_MERGE_FAILED
  ///
  /// Connection event used to inform InCallServices when the merging of two calls has
  /// failed. The User Interface should use this message to inform the user of the error.
  ///
  /// Sent via \#sendConnectionEvent(String, Bundle).  The Bundle parameter is
  /// expected to be null when this connection event is used.
  static const EVENT_CALL_MERGE_FAILED =
      "android.telecom.event.CALL_MERGE_FAILED";

  /// from: static public final java.lang.String EVENT_CALL_PULL_FAILED
  ///
  /// Connection event used to inform InCallServices when pulling of an external call has
  /// failed.  The user interface should inform the user of the error.
  ///
  /// Expected to be used by the ConnectionService when the Call\#pullExternalCall()
  /// API is called on a Call with the properties
  /// Call.Details\#PROPERTY_IS_EXTERNAL_CALL and
  /// Call.Details\#CAPABILITY_CAN_PULL_CALL, but the ConnectionService could not
  /// pull the external call due to an error condition.
  ///
  /// Sent via \#sendConnectionEvent(String, Bundle).  The Bundle parameter is
  /// expected to be null when this connection event is used.
  static const EVENT_CALL_PULL_FAILED =
      "android.telecom.event.CALL_PULL_FAILED";

  /// from: static public final java.lang.String EXTRA_ANSWERING_DROPS_FG_CALL
  ///
  /// Boolean connection extra key set on a Connection in
  /// Connection\#STATE_RINGING state to indicate that answering the call will cause the
  /// current active foreground call to be dropped.
  static const EXTRA_ANSWERING_DROPS_FG_CALL =
      "android.telecom.extra.ANSWERING_DROPS_FG_CALL";

  /// from: static public final java.lang.String EXTRA_ANSWERING_DROPS_FG_CALL_APP_NAME
  ///
  /// String connection extra key set on a Connection in Connection\#STATE_RINGING
  /// state to indicate the name of the third-party app which is responsible for the current
  /// foreground call.
  ///
  /// Used when \#EXTRA_ANSWERING_DROPS_FG_CALL is true to ensure that the default Phone app
  /// is able to inform the user that answering the new incoming call will cause a call owned by
  /// another app to be dropped when the incoming call is answered.
  static const EXTRA_ANSWERING_DROPS_FG_CALL_APP_NAME =
      "android.telecom.extra.ANSWERING_DROPS_FG_CALL_APP_NAME";

  /// from: static public final java.lang.String EXTRA_CALL_SUBJECT
  ///
  /// Connection extra key used to store the subject for an incoming call.  The user interface can
  /// query this extra and display its contents for incoming calls.  Will only be used if the
  /// PhoneAccount supports the capability PhoneAccount\#CAPABILITY_CALL_SUBJECT.
  static const EXTRA_CALL_SUBJECT = "android.telecom.extra.CALL_SUBJECT";

  /// from: static public final java.lang.String EXTRA_CHILD_ADDRESS
  ///
  /// Connection extra key used to store a child number associated with the current connection.
  /// Used to communicate to the user interface that the connection was received via
  /// a child address (i.e. phone number) associated with the PhoneAccount's primary
  /// address.
  static const EXTRA_CHILD_ADDRESS = "android.telecom.extra.CHILD_ADDRESS";

  /// from: static public final java.lang.String EXTRA_LAST_FORWARDED_NUMBER
  ///
  /// Connection extra key used to store the last forwarded number associated with the current
  /// connection.  Used to communicate to the user interface that the connection was forwarded via
  /// the specified number.
  static const EXTRA_LAST_FORWARDED_NUMBER =
      "android.telecom.extra.LAST_FORWARDED_NUMBER";

  /// from: static public final int PROPERTY_HAS_CDMA_VOICE_PRIVACY
  ///
  /// Indicates that the connection has CDMA Enhanced Voice Privacy enabled.
  static const PROPERTY_HAS_CDMA_VOICE_PRIVACY = 32;

  /// from: static public final int PROPERTY_IS_EXTERNAL_CALL
  ///
  /// When set, indicates that the {@code Connection} does not actually exist locally for the
  /// ConnectionService.
  ///
  /// Consider, for example, a scenario where a user has two devices with the same phone number.
  /// When a user places a call on one devices, the telephony stack can represent that call on the
  /// other device by adding is to the ConnectionService with the
  /// \#PROPERTY_IS_EXTERNAL_CALL capability set.
  ///
  /// An ConnectionService should not assume that all InCallServices will handle
  /// external connections.  Only those InCallServices which have the
  /// TelecomManager\#METADATA_INCLUDE_EXTERNAL_CALLS metadata set to {@code true} in its
  /// manifest will see external connections.
  static const PROPERTY_IS_EXTERNAL_CALL = 16;

  /// from: static public final int PROPERTY_IS_RTT
  ///
  /// Set by the framework to indicate that a connection has an active RTT session associated with
  /// it.
  static const PROPERTY_IS_RTT = 256;

  /// from: static public final int PROPERTY_SELF_MANAGED
  ///
  /// Set by the framework to indicate that the Connection originated from a self-managed
  /// ConnectionService.
  ///
  /// See PhoneAccount\#CAPABILITY_SELF_MANAGED.
  static const PROPERTY_SELF_MANAGED = 128;

  /// from: static public final int STATE_ACTIVE
  ///
  /// A connection is active. Both parties are connected to the call and can actively communicate.
  static const STATE_ACTIVE = 4;

  /// from: static public final int STATE_DIALING
  ///
  /// An outgoing connection is in the dialing state. In this state the other party has not yet
  /// answered the call and the user traditionally hears a ringback tone.
  static const STATE_DIALING = 3;

  /// from: static public final int STATE_DISCONNECTED
  ///
  /// A connection has been disconnected. This is the final state once the user has been
  /// disconnected from a call either locally, remotely or by an error in the service.
  static const STATE_DISCONNECTED = 6;

  /// from: static public final int STATE_HOLDING
  ///
  /// A connection is on hold.
  static const STATE_HOLDING = 5;

  /// from: static public final int STATE_INITIALIZING
  ///
  /// The connection is initializing. This is generally the first state for a {@code Connection}
  /// returned by a ConnectionService.
  static const STATE_INITIALIZING = 0;

  /// from: static public final int STATE_NEW
  ///
  /// The connection is new and not connected.
  static const STATE_NEW = 1;

  /// from: static public final int STATE_PULLING_CALL
  ///
  /// The state of an external connection which is in the process of being pulled from a remote
  /// device to the local device.
  ///
  /// A connection can only be in this state if the \#PROPERTY_IS_EXTERNAL_CALL property and
  /// \#CAPABILITY_CAN_PULL_CALL capability bits are set on the connection.
  static const STATE_PULLING_CALL = 7;

  /// from: static public final int STATE_RINGING
  ///
  /// An incoming connection is in the ringing state. During this state, the user's ringer or
  /// vibration feature will be activated.
  static const STATE_RINGING = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Connection.
  Connection()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_capabilitiesToString = jniAccessors.getStaticMethodIDOf(
      _classRef, "capabilitiesToString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String capabilitiesToString(int capabilities)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Renders a set of capability bits ({@code CAPABILITY_*}) as a human readable string.
  ///@param capabilities A capability bit field.
  ///@return A human readable string representation.
  static jni.JniString capabilitiesToString(int capabilities) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_capabilitiesToString,
          jni.JniType.objectType,
          [capabilities]).object);

  static final _id_propertiesToString = jniAccessors.getStaticMethodIDOf(
      _classRef, "propertiesToString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String propertiesToString(int properties)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Renders a set of property bits ({@code PROPERTY_*}) as a human readable string.
  ///@param properties A property bit field.
  ///@return A human readable string representation.
  static jni.JniString propertiesToString(int properties) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_propertiesToString, jni.JniType.objectType, [properties]).object);

  static final _id_getAddress = jniAccessors.getMethodIDOf(
      _classRef, "getAddress", "()Landroid/net/Uri;");

  /// from: public final android.net.Uri getAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The address (e.g., phone number) to which this Connection is currently communicating.
  uri_.Uri getAddress() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getAddress, jni.JniType.objectType, []).object);

  static final _id_getAddressPresentation =
      jniAccessors.getMethodIDOf(_classRef, "getAddressPresentation", "()I");

  /// from: public final int getAddressPresentation()
  ///
  /// @return The presentation requirements for the address.
  ///         See TelecomManager for valid values.
  int getAddressPresentation() => jniAccessors.callMethodWithArgs(
      reference, _id_getAddressPresentation, jni.JniType.intType, []).integer;

  static final _id_getCallerDisplayName = jniAccessors.getMethodIDOf(
      _classRef, "getCallerDisplayName", "()Ljava/lang/String;");

  /// from: public final java.lang.String getCallerDisplayName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The caller display name (CNAP).
  jni.JniString getCallerDisplayName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCallerDisplayName, jni.JniType.objectType, []).object);

  static final _id_getCallerDisplayNamePresentation = jniAccessors
      .getMethodIDOf(_classRef, "getCallerDisplayNamePresentation", "()I");

  /// from: public final int getCallerDisplayNamePresentation()
  ///
  /// @return The presentation requirements for the handle.
  ///         See TelecomManager for valid values.
  int getCallerDisplayNamePresentation() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCallerDisplayNamePresentation,
      jni.JniType.intType, []).integer;

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public final int getState()
  ///
  /// @return The state of this Connection.
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_getCallAudioState = jniAccessors.getMethodIDOf(
      _classRef, "getCallAudioState", "()Landroid/telecom/CallAudioState;");

  /// from: public final android.telecom.CallAudioState getCallAudioState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The audio state of the connection, describing how its audio is currently
  ///         being routed by the system. This is {@code null} if this Connection
  ///         does not directly know about its audio state.
  callaudiostate_.CallAudioState getCallAudioState() =>
      callaudiostate_.CallAudioState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallAudioState, jni.JniType.objectType, []).object);

  static final _id_getConference = jniAccessors.getMethodIDOf(
      _classRef, "getConference", "()Landroid/telecom/Conference;");

  /// from: public final android.telecom.Conference getConference()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The conference that this connection is a part of.  Null if it is not part of any
  ///         conference.
  conference_.Conference getConference() =>
      conference_.Conference.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConference, jni.JniType.objectType, []).object);

  static final _id_isRingbackRequested =
      jniAccessors.getMethodIDOf(_classRef, "isRingbackRequested", "()Z");

  /// from: public final boolean isRingbackRequested()
  ///
  /// Returns whether this connection is requesting that the system play a ringback tone
  /// on its behalf.
  bool isRingbackRequested() => jniAccessors.callMethodWithArgs(
      reference, _id_isRingbackRequested, jni.JniType.booleanType, []).boolean;

  static final _id_getAudioModeIsVoip =
      jniAccessors.getMethodIDOf(_classRef, "getAudioModeIsVoip", "()Z");

  /// from: public final boolean getAudioModeIsVoip()
  ///
  /// @return True if the connection's audio mode is VOIP.
  bool getAudioModeIsVoip() => jniAccessors.callMethodWithArgs(
      reference, _id_getAudioModeIsVoip, jni.JniType.booleanType, []).boolean;

  static final _id_getStatusHints = jniAccessors.getMethodIDOf(
      _classRef, "getStatusHints", "()Landroid/telecom/StatusHints;");

  /// from: public final android.telecom.StatusHints getStatusHints()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The status hints for this connection.
  statushints_.StatusHints getStatusHints() =>
      statushints_.StatusHints.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStatusHints, jni.JniType.objectType, []).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public final android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the extras associated with this connection.
  ///
  /// Extras should be updated using \#putExtras(Bundle).
  ///
  /// Telecom or an InCallService can also update the extras via
  /// android.telecom.Call\#putExtras(Bundle), and
  /// Call\#removeExtras(List).
  ///
  /// The connection is notified of changes to the extras made by Telecom or an
  /// InCallService by \#onExtrasChanged(Bundle).
  ///@return The extras associated with this connection.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_getDisconnectCause = jniAccessors.getMethodIDOf(
      _classRef, "getDisconnectCause", "()Landroid/telecom/DisconnectCause;");

  /// from: public final android.telecom.DisconnectCause getDisconnectCause()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The DisconnectCause for this connection.
  disconnectcause_.DisconnectCause getDisconnectCause() =>
      disconnectcause_.DisconnectCause.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDisconnectCause,
          jni.JniType.objectType, []).object);

  static final _id_stateToString = jniAccessors.getStaticMethodIDOf(
      _classRef, "stateToString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String stateToString(int state)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param state An integer value of a {@code STATE_*} constant.
  ///@return A string representation of the value.
  static jni.JniString stateToString(int state) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_stateToString, jni.JniType.objectType, [state]).object);

  static final _id_getConnectionCapabilities =
      jniAccessors.getMethodIDOf(_classRef, "getConnectionCapabilities", "()I");

  /// from: public final int getConnectionCapabilities()
  ///
  /// Returns the connection's capabilities, as a bit mask of the {@code CAPABILITY_*} constants.
  int getConnectionCapabilities() => jniAccessors.callMethodWithArgs(reference,
      _id_getConnectionCapabilities, jni.JniType.intType, []).integer;

  static final _id_getConnectionProperties =
      jniAccessors.getMethodIDOf(_classRef, "getConnectionProperties", "()I");

  /// from: public final int getConnectionProperties()
  ///
  /// Returns the connection's properties, as a bit mask of the {@code PROPERTY_*} constants.
  int getConnectionProperties() => jniAccessors.callMethodWithArgs(
      reference, _id_getConnectionProperties, jni.JniType.intType, []).integer;

  static final _id_setAddress = jniAccessors.getMethodIDOf(
      _classRef, "setAddress", "(Landroid/net/Uri;I)V");

  /// from: public final void setAddress(android.net.Uri address, int presentation)
  ///
  /// Sets the value of the \#getAddress() property.
  ///@param address The new address.
  ///@param presentation The presentation requirements for the address.
  ///        See TelecomManager for valid values.
  void setAddress(uri_.Uri address, int presentation) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAddress,
          jni.JniType.voidType, [address.reference, presentation]).check();

  static final _id_setCallerDisplayName = jniAccessors.getMethodIDOf(
      _classRef, "setCallerDisplayName", "(Ljava/lang/String;I)V");

  /// from: public final void setCallerDisplayName(java.lang.String callerDisplayName, int presentation)
  ///
  /// Sets the caller display name (CNAP).
  ///@param callerDisplayName The new display name.
  ///@param presentation The presentation requirements for the handle.
  ///        See TelecomManager for valid values.
  void setCallerDisplayName(
          jni.JniString callerDisplayName, int presentation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCallerDisplayName,
          jni.JniType.voidType,
          [callerDisplayName.reference, presentation]).check();

  static final _id_setVideoState =
      jniAccessors.getMethodIDOf(_classRef, "setVideoState", "(I)V");

  /// from: public final void setVideoState(int videoState)
  ///
  /// Set the video state for the connection.
  /// Valid values: VideoProfile\#STATE_AUDIO_ONLY,
  /// VideoProfile\#STATE_BIDIRECTIONAL,
  /// VideoProfile\#STATE_TX_ENABLED,
  /// VideoProfile\#STATE_RX_ENABLED.
  ///@param videoState The new video state.
  void setVideoState(int videoState) => jniAccessors.callMethodWithArgs(
      reference, _id_setVideoState, jni.JniType.voidType, [videoState]).check();

  static final _id_setActive =
      jniAccessors.getMethodIDOf(_classRef, "setActive", "()V");

  /// from: public final void setActive()
  ///
  /// Sets state to active (e.g., an ongoing connection where two or more parties can actively
  /// communicate).
  void setActive() => jniAccessors.callMethodWithArgs(
      reference, _id_setActive, jni.JniType.voidType, []).check();

  static final _id_setRinging =
      jniAccessors.getMethodIDOf(_classRef, "setRinging", "()V");

  /// from: public final void setRinging()
  ///
  /// Sets state to ringing (e.g., an inbound ringing connection).
  void setRinging() => jniAccessors.callMethodWithArgs(
      reference, _id_setRinging, jni.JniType.voidType, []).check();

  static final _id_setInitializing =
      jniAccessors.getMethodIDOf(_classRef, "setInitializing", "()V");

  /// from: public final void setInitializing()
  ///
  /// Sets state to initializing (this Connection is not yet ready to be used).
  void setInitializing() => jniAccessors.callMethodWithArgs(
      reference, _id_setInitializing, jni.JniType.voidType, []).check();

  static final _id_setInitialized =
      jniAccessors.getMethodIDOf(_classRef, "setInitialized", "()V");

  /// from: public final void setInitialized()
  ///
  /// Sets state to initialized (the Connection has been set up and is now ready to be used).
  void setInitialized() => jniAccessors.callMethodWithArgs(
      reference, _id_setInitialized, jni.JniType.voidType, []).check();

  static final _id_setDialing =
      jniAccessors.getMethodIDOf(_classRef, "setDialing", "()V");

  /// from: public final void setDialing()
  ///
  /// Sets state to dialing (e.g., dialing an outbound connection).
  void setDialing() => jniAccessors.callMethodWithArgs(
      reference, _id_setDialing, jni.JniType.voidType, []).check();

  static final _id_setPulling =
      jniAccessors.getMethodIDOf(_classRef, "setPulling", "()V");

  /// from: public final void setPulling()
  ///
  /// Sets state to pulling (e.g.&nbsp;the connection is being pulled to the local device from another
  /// device).  Only applicable for Connections with
  /// Connection\#PROPERTY_IS_EXTERNAL_CALL and Connection\#CAPABILITY_CAN_PULL_CALL.
  void setPulling() => jniAccessors.callMethodWithArgs(
      reference, _id_setPulling, jni.JniType.voidType, []).check();

  static final _id_setOnHold =
      jniAccessors.getMethodIDOf(_classRef, "setOnHold", "()V");

  /// from: public final void setOnHold()
  ///
  /// Sets state to be on hold.
  void setOnHold() => jniAccessors.callMethodWithArgs(
      reference, _id_setOnHold, jni.JniType.voidType, []).check();

  static final _id_setVideoProvider = jniAccessors.getMethodIDOf(_classRef,
      "setVideoProvider", "(Landroid/telecom/Connection\$VideoProvider;)V");

  /// from: public final void setVideoProvider(android.telecom.Connection.VideoProvider videoProvider)
  ///
  /// Sets the video connection provider.
  ///@param videoProvider The video provider.
  void setVideoProvider(Connection_VideoProvider videoProvider) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVideoProvider,
          jni.JniType.voidType, [videoProvider.reference]).check();

  static final _id_getVideoProvider = jniAccessors.getMethodIDOf(_classRef,
      "getVideoProvider", "()Landroid/telecom/Connection\$VideoProvider;");

  /// from: public final android.telecom.Connection.VideoProvider getVideoProvider()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Connection_VideoProvider getVideoProvider() =>
      Connection_VideoProvider.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getVideoProvider, jni.JniType.objectType, []).object);

  static final _id_setDisconnected = jniAccessors.getMethodIDOf(
      _classRef, "setDisconnected", "(Landroid/telecom/DisconnectCause;)V");

  /// from: public final void setDisconnected(android.telecom.DisconnectCause disconnectCause)
  ///
  /// Sets state to disconnected.
  ///@param disconnectCause The reason for the disconnection, as specified by
  ///         DisconnectCause.
  void setDisconnected(disconnectcause_.DisconnectCause disconnectCause) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisconnected,
          jni.JniType.voidType, [disconnectCause.reference]).check();

  static final _id_setPostDialWait = jniAccessors.getMethodIDOf(
      _classRef, "setPostDialWait", "(Ljava/lang/String;)V");

  /// from: public final void setPostDialWait(java.lang.String remaining)
  ///
  /// Informs listeners that this {@code Connection} is in a post-dial wait state. This is done
  /// when (a) the {@code Connection} is issuing a DTMF sequence; (b) it has encountered a "wait"
  /// character; and (c) it wishes to inform the In-Call app that it is waiting for the end-user
  /// to send an \#onPostDialContinue(boolean) signal.
  ///@param remaining The DTMF character sequence remaining to be emitted once the
  ///         \#onPostDialContinue(boolean) is received, including any "wait" characters
  ///         that remaining sequence may contain.
  void setPostDialWait(jni.JniString remaining) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPostDialWait,
          jni.JniType.voidType, [remaining.reference]).check();

  static final _id_setNextPostDialChar =
      jniAccessors.getMethodIDOf(_classRef, "setNextPostDialChar", "(C)V");

  /// from: public final void setNextPostDialChar(char nextChar)
  ///
  /// Informs listeners that this {@code Connection} has processed a character in the post-dial
  /// started state. This is done when (a) the {@code Connection} is issuing a DTMF sequence;
  /// and (b) it wishes to signal Telecom to play the corresponding DTMF tone locally.
  ///@param nextChar The DTMF character that was just processed by the {@code Connection}.
  void setNextPostDialChar(int nextChar) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setNextPostDialChar,
      jni.JniType.voidType,
      [nextChar]).check();

  static final _id_setRingbackRequested =
      jniAccessors.getMethodIDOf(_classRef, "setRingbackRequested", "(Z)V");

  /// from: public final void setRingbackRequested(boolean ringback)
  ///
  /// Requests that the framework play a ringback tone. This is to be invoked by implementations
  /// that do not play a ringback tone themselves in the connection's audio stream.
  ///@param ringback Whether the ringback tone is to be played.
  void setRingbackRequested(bool ringback) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRingbackRequested,
      jni.JniType.voidType,
      [ringback]).check();

  static final _id_setConnectionCapabilities = jniAccessors.getMethodIDOf(
      _classRef, "setConnectionCapabilities", "(I)V");

  /// from: public final void setConnectionCapabilities(int connectionCapabilities)
  ///
  /// Sets the connection's capabilities as a bit mask of the {@code CAPABILITY_*} constants.
  ///@param connectionCapabilities The new connection capabilities.
  void setConnectionCapabilities(int connectionCapabilities) =>
      jniAccessors.callMethodWithArgs(reference, _id_setConnectionCapabilities,
          jni.JniType.voidType, [connectionCapabilities]).check();

  static final _id_setConnectionProperties =
      jniAccessors.getMethodIDOf(_classRef, "setConnectionProperties", "(I)V");

  /// from: public final void setConnectionProperties(int connectionProperties)
  ///
  /// Sets the connection's properties as a bit mask of the {@code PROPERTY_*} constants.
  ///@param connectionProperties The new connection properties.
  void setConnectionProperties(int connectionProperties) =>
      jniAccessors.callMethodWithArgs(reference, _id_setConnectionProperties,
          jni.JniType.voidType, [connectionProperties]).check();

  static final _id_destroy =
      jniAccessors.getMethodIDOf(_classRef, "destroy", "()V");

  /// from: public final void destroy()
  ///
  /// Tears down the Connection object.
  void destroy() => jniAccessors.callMethodWithArgs(
      reference, _id_destroy, jni.JniType.voidType, []).check();

  static final _id_setAudioModeIsVoip =
      jniAccessors.getMethodIDOf(_classRef, "setAudioModeIsVoip", "(Z)V");

  /// from: public final void setAudioModeIsVoip(boolean isVoip)
  ///
  /// Requests that the framework use VOIP audio mode for this connection.
  ///@param isVoip True if the audio mode is VOIP.
  void setAudioModeIsVoip(bool isVoip) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAudioModeIsVoip,
      jni.JniType.voidType,
      [isVoip]).check();

  static final _id_setStatusHints = jniAccessors.getMethodIDOf(
      _classRef, "setStatusHints", "(Landroid/telecom/StatusHints;)V");

  /// from: public final void setStatusHints(android.telecom.StatusHints statusHints)
  ///
  /// Sets the label and icon status to display in the in-call UI.
  ///@param statusHints The status label and icon to set.
  void setStatusHints(statushints_.StatusHints statusHints) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStatusHints,
          jni.JniType.voidType, [statusHints.reference]).check();

  static final _id_setConferenceableConnections = jniAccessors.getMethodIDOf(
      _classRef, "setConferenceableConnections", "(Ljava/util/List;)V");

  /// from: public final void setConferenceableConnections(java.util.List<android.telecom.Connection> conferenceableConnections)
  ///
  /// Sets the connections with which this connection can be conferenced.
  ///@param conferenceableConnections The set of connections this connection can conference with.
  void setConferenceableConnections(jni.JniObject conferenceableConnections) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setConferenceableConnections,
          jni.JniType.voidType,
          [conferenceableConnections.reference]).check();

  static final _id_setConferenceables = jniAccessors.getMethodIDOf(
      _classRef, "setConferenceables", "(Ljava/util/List;)V");

  /// from: public final void setConferenceables(java.util.List<android.telecom.Conferenceable> conferenceables)
  ///
  /// Similar to \#setConferenceableConnections(java.util.List), sets a list of connections
  /// or conferences with which this connection can be conferenced.
  ///@param conferenceables The conferenceables.
  void setConferenceables(jni.JniObject conferenceables) =>
      jniAccessors.callMethodWithArgs(reference, _id_setConferenceables,
          jni.JniType.voidType, [conferenceables.reference]).check();

  static final _id_getConferenceables = jniAccessors.getMethodIDOf(
      _classRef, "getConferenceables", "()Ljava/util/List;");

  /// from: public final java.util.List<android.telecom.Conferenceable> getConferenceables()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the connections or conferences with which this connection can be conferenced.
  jni.JniObject getConferenceables() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConferenceables, jni.JniType.objectType, []).object);

  static final _id_setExtras = jniAccessors.getMethodIDOf(
      _classRef, "setExtras", "(Landroid/os/Bundle;)V");

  /// from: public final void setExtras(android.os.Bundle extras)
  ///
  /// Set some extras that can be associated with this {@code Connection}.
  ///
  /// New or existing keys are replaced in the {@code Connection} extras.  Keys which are no longer
  /// in the new extras, but were present the last time {@code setExtras} was called are removed.
  ///
  /// Alternatively you may use the \#putExtras(Bundle), and
  /// \#removeExtras(String...) methods to modify the extras.
  ///
  /// No assumptions should be made as to how an In-Call UI or service will handle these extras.
  /// Keys should be fully qualified (e.g., com.example.MY_EXTRA) to avoid conflicts.
  ///@param extras The extras associated with this {@code Connection}.
  ///
  /// This value may be {@code null}.
  void setExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_putExtras = jniAccessors.getMethodIDOf(
      _classRef, "putExtras", "(Landroid/os/Bundle;)V");

  /// from: public final void putExtras(android.os.Bundle extras)
  ///
  /// Adds some extras to this {@code Connection}.  Existing keys are replaced and new ones are
  /// added.
  ///
  /// No assumptions should be made as to how an In-Call UI or service will handle these extras.
  /// Keys should be fully qualified (e.g., com.example.MY_EXTRA) to avoid conflicts.
  ///@param extras The extras to add.
  ///
  /// This value must never be {@code null}.
  void putExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_putExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_removeExtras = jniAccessors.getMethodIDOf(
      _classRef, "removeExtras", "(Ljava/util/List;)V");

  /// from: public final void removeExtras(java.util.List<java.lang.String> keys)
  ///
  /// Removes extras from this {@code Connection}.
  ///@param keys The keys of the extras to remove.
  void removeExtras(jni.JniObject keys) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeExtras,
      jni.JniType.voidType,
      [keys.reference]).check();

  static final _id_removeExtras1 = jniAccessors.getMethodIDOf(
      _classRef, "removeExtras", "([Ljava/lang/String;)V");

  /// from: public final void removeExtras(java.lang.String[] keys)
  ///
  /// Removes extras from this {@code Connection}.
  ///@param keys The keys of the extras to remove.
  void removeExtras1(jni.JniObject keys) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeExtras1,
      jni.JniType.voidType,
      [keys.reference]).check();

  static final _id_setAudioRoute =
      jniAccessors.getMethodIDOf(_classRef, "setAudioRoute", "(I)V");

  /// from: public final void setAudioRoute(int route)
  ///
  /// Sets the audio route (speaker, bluetooth, etc...).  When this request is honored, there will
  /// be change to the \#getCallAudioState().
  ///
  /// Used by self-managed ConnectionServices which wish to change the audio route for a
  /// self-managed Connection (see PhoneAccount\#CAPABILITY_SELF_MANAGED.)
  ///
  /// See also InCallService\#setAudioRoute(int).
  ///@param route The audio route to use (one of CallAudioState\#ROUTE_BLUETOOTH,
  ///              CallAudioState\#ROUTE_EARPIECE, CallAudioState\#ROUTE_SPEAKER, or
  ///              CallAudioState\#ROUTE_WIRED_HEADSET).
  void setAudioRoute(int route) => jniAccessors.callMethodWithArgs(
      reference, _id_setAudioRoute, jni.JniType.voidType, [route]).check();

  static final _id_requestBluetoothAudio = jniAccessors.getMethodIDOf(_classRef,
      "requestBluetoothAudio", "(Landroid/bluetooth/BluetoothDevice;)V");

  /// from: public void requestBluetoothAudio(android.bluetooth.BluetoothDevice bluetoothDevice)
  ///
  /// Request audio routing to a specific bluetooth device. Calling this method may result in
  /// the device routing audio to a different bluetooth device than the one specified if the
  /// bluetooth stack is unable to route audio to the requested device.
  /// A list of available devices can be obtained via
  /// CallAudioState\#getSupportedBluetoothDevices()
  ///
  ///
  /// Used by self-managed ConnectionServices which wish to use bluetooth audio for a
  /// self-managed Connection (see PhoneAccount\#CAPABILITY_SELF_MANAGED.)
  ///
  /// See also InCallService\#requestBluetoothAudio(BluetoothDevice)
  ///@param bluetoothDevice The bluetooth device to connect to.
  ///
  /// This value must never be {@code null}.
  void requestBluetoothAudio(
          bluetoothdevice_.BluetoothDevice bluetoothDevice) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestBluetoothAudio,
          jni.JniType.voidType, [bluetoothDevice.reference]).check();

  static final _id_sendRttInitiationSuccess =
      jniAccessors.getMethodIDOf(_classRef, "sendRttInitiationSuccess", "()V");

  /// from: public final void sendRttInitiationSuccess()
  ///
  /// Informs listeners that a previously requested RTT session via
  /// ConnectionRequest\#isRequestingRtt() or
  /// \#onStartRtt(RttTextStream) has succeeded.
  void sendRttInitiationSuccess() => jniAccessors.callMethodWithArgs(reference,
      _id_sendRttInitiationSuccess, jni.JniType.voidType, []).check();

  static final _id_sendRttInitiationFailure =
      jniAccessors.getMethodIDOf(_classRef, "sendRttInitiationFailure", "(I)V");

  /// from: public final void sendRttInitiationFailure(int reason)
  ///
  /// Informs listeners that a previously requested RTT session via
  /// ConnectionRequest\#isRequestingRtt() or \#onStartRtt(RttTextStream)
  /// has failed.
  ///@param reason One of the reason codes defined in RttModifyStatus, with the
  ///               exception of RttModifyStatus\#SESSION_MODIFY_REQUEST_SUCCESS.
  void sendRttInitiationFailure(int reason) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendRttInitiationFailure,
      jni.JniType.voidType,
      [reason]).check();

  static final _id_sendRttSessionRemotelyTerminated = jniAccessors
      .getMethodIDOf(_classRef, "sendRttSessionRemotelyTerminated", "()V");

  /// from: public final void sendRttSessionRemotelyTerminated()
  ///
  /// Informs listeners that a currently active RTT session has been terminated by the remote
  /// side of the coll.
  void sendRttSessionRemotelyTerminated() => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendRttSessionRemotelyTerminated,
      jni.JniType.voidType, []).check();

  static final _id_sendRemoteRttRequest =
      jniAccessors.getMethodIDOf(_classRef, "sendRemoteRttRequest", "()V");

  /// from: public final void sendRemoteRttRequest()
  ///
  /// Informs listeners that the remote side of the call has requested an upgrade to include an
  /// RTT session in the call.
  void sendRemoteRttRequest() => jniAccessors.callMethodWithArgs(
      reference, _id_sendRemoteRttRequest, jni.JniType.voidType, []).check();

  static final _id_onCallAudioStateChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onCallAudioStateChanged",
      "(Landroid/telecom/CallAudioState;)V");

  /// from: public void onCallAudioStateChanged(android.telecom.CallAudioState state)
  ///
  /// Notifies this Connection that the \#getCallAudioState() property has a new value.
  ///@param state The new connection audio state.
  void onCallAudioStateChanged(callaudiostate_.CallAudioState state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCallAudioStateChanged,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_onStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "onStateChanged", "(I)V");

  /// from: public void onStateChanged(int state)
  ///
  /// Notifies this Connection of an internal state change. This method is called after the
  /// state is changed.
  ///@param state The new state, one of the {@code STATE_*} constants.
  void onStateChanged(int state) => jniAccessors.callMethodWithArgs(
      reference, _id_onStateChanged, jni.JniType.voidType, [state]).check();

  static final _id_onPlayDtmfTone =
      jniAccessors.getMethodIDOf(_classRef, "onPlayDtmfTone", "(C)V");

  /// from: public void onPlayDtmfTone(char c)
  ///
  /// Notifies this Connection of a request to play a DTMF tone.
  ///@param c A DTMF character.
  void onPlayDtmfTone(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_onPlayDtmfTone, jni.JniType.voidType, [c]).check();

  static final _id_onStopDtmfTone =
      jniAccessors.getMethodIDOf(_classRef, "onStopDtmfTone", "()V");

  /// from: public void onStopDtmfTone()
  ///
  /// Notifies this Connection of a request to stop any currently playing DTMF tones.
  void onStopDtmfTone() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopDtmfTone, jni.JniType.voidType, []).check();

  static final _id_onDisconnect =
      jniAccessors.getMethodIDOf(_classRef, "onDisconnect", "()V");

  /// from: public void onDisconnect()
  ///
  /// Notifies this Connection of a request to disconnect.
  void onDisconnect() => jniAccessors.callMethodWithArgs(
      reference, _id_onDisconnect, jni.JniType.voidType, []).check();

  static final _id_onSeparate =
      jniAccessors.getMethodIDOf(_classRef, "onSeparate", "()V");

  /// from: public void onSeparate()
  ///
  /// Notifies this Connection of a request to separate from its parent conference.
  void onSeparate() => jniAccessors.callMethodWithArgs(
      reference, _id_onSeparate, jni.JniType.voidType, []).check();

  static final _id_onAbort =
      jniAccessors.getMethodIDOf(_classRef, "onAbort", "()V");

  /// from: public void onAbort()
  ///
  /// Notifies this Connection of a request to abort.
  void onAbort() => jniAccessors.callMethodWithArgs(
      reference, _id_onAbort, jni.JniType.voidType, []).check();

  static final _id_onHold =
      jniAccessors.getMethodIDOf(_classRef, "onHold", "()V");

  /// from: public void onHold()
  ///
  /// Notifies this Connection of a request to hold.
  void onHold() => jniAccessors.callMethodWithArgs(
      reference, _id_onHold, jni.JniType.voidType, []).check();

  static final _id_onUnhold =
      jniAccessors.getMethodIDOf(_classRef, "onUnhold", "()V");

  /// from: public void onUnhold()
  ///
  /// Notifies this Connection of a request to exit a hold state.
  void onUnhold() => jniAccessors.callMethodWithArgs(
      reference, _id_onUnhold, jni.JniType.voidType, []).check();

  static final _id_onAnswer =
      jniAccessors.getMethodIDOf(_classRef, "onAnswer", "(I)V");

  /// from: public void onAnswer(int videoState)
  ///
  /// Notifies this Connection, which is in \#STATE_RINGING, of
  /// a request to accept.
  ///
  /// For managed ConnectionServices, this will be called when the user answers a call via
  /// the default dialer's InCallService.
  ///
  /// Although a self-managed ConnectionService provides its own incoming call UI, the
  /// Telecom framework may request that the call is answered in the following circumstances:
  /// <ul>
  ///     <li>The user chooses to answer an incoming call via a Bluetooth device.</li>
  ///     <li>A car mode InCallService is in use which has declared
  ///     TelecomManager\#METADATA_INCLUDE_SELF_MANAGED_CALLS in its manifest.  Such an
  ///     InCallService will be able to see calls from self-managed
  ///     ConnectionServices, and will be able to display an incoming call UI on their
  ///     behalf.</li>
  /// </ul>
  ///@param videoState The video state in which to answer the connection.
  void onAnswer(int videoState) => jniAccessors.callMethodWithArgs(
      reference, _id_onAnswer, jni.JniType.voidType, [videoState]).check();

  static final _id_onAnswer1 =
      jniAccessors.getMethodIDOf(_classRef, "onAnswer", "()V");

  /// from: public void onAnswer()
  ///
  /// Notifies this Connection, which is in \#STATE_RINGING, of
  /// a request to accept.
  ///
  /// For managed ConnectionServices, this will be called when the user answers a call via
  /// the default dialer's InCallService.
  ///
  /// Although a self-managed ConnectionService provides its own incoming call UI, the
  /// Telecom framework may request that the call is answered in the following circumstances:
  /// <ul>
  ///     <li>The user chooses to answer an incoming call via a Bluetooth device.</li>
  ///     <li>A car mode InCallService is in use which has declared
  ///     TelecomManager\#METADATA_INCLUDE_SELF_MANAGED_CALLS in its manifest.  Such an
  ///     InCallService will be able to see calls from self-managed
  ///     ConnectionServices, and will be able to display an incoming call UI on their
  ///     behalf.</li>
  /// </ul>
  void onAnswer1() => jniAccessors.callMethodWithArgs(
      reference, _id_onAnswer1, jni.JniType.voidType, []).check();

  static final _id_onDeflect = jniAccessors.getMethodIDOf(
      _classRef, "onDeflect", "(Landroid/net/Uri;)V");

  /// from: public void onDeflect(android.net.Uri address)
  ///
  /// Notifies this Connection, which is in \#STATE_RINGING, of
  /// a request to deflect.
  void onDeflect(uri_.Uri address) => jniAccessors.callMethodWithArgs(reference,
      _id_onDeflect, jni.JniType.voidType, [address.reference]).check();

  static final _id_onReject =
      jniAccessors.getMethodIDOf(_classRef, "onReject", "()V");

  /// from: public void onReject()
  ///
  /// Notifies this Connection, which is in \#STATE_RINGING, of
  /// a request to reject.
  ///
  /// For managed ConnectionServices, this will be called when the user rejects a call via
  /// the default dialer's InCallService.
  ///
  /// Although a self-managed ConnectionService provides its own incoming call UI, the
  /// Telecom framework may request that the call is rejected in the following circumstances:
  /// <ul>
  ///     <li>The user chooses to reject an incoming call via a Bluetooth device.</li>
  ///     <li>A car mode InCallService is in use which has declared
  ///     TelecomManager\#METADATA_INCLUDE_SELF_MANAGED_CALLS in its manifest.  Such an
  ///     InCallService will be able to see calls from self-managed
  ///     ConnectionServices, and will be able to display an incoming call UI on their
  ///     behalf.</li>
  /// </ul>
  void onReject() => jniAccessors.callMethodWithArgs(
      reference, _id_onReject, jni.JniType.voidType, []).check();

  static final _id_onReject1 = jniAccessors.getMethodIDOf(
      _classRef, "onReject", "(Ljava/lang/String;)V");

  /// from: public void onReject(java.lang.String replyMessage)
  ///
  /// Notifies this Connection, which is in \#STATE_RINGING, of
  /// a request to reject with a message.
  void onReject1(jni.JniString replyMessage) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onReject1,
      jni.JniType.voidType,
      [replyMessage.reference]).check();

  static final _id_onPostDialContinue =
      jniAccessors.getMethodIDOf(_classRef, "onPostDialContinue", "(Z)V");

  /// from: public void onPostDialContinue(boolean proceed)
  ///
  /// Notifies this Connection whether the user wishes to proceed with the post-dial DTMF codes.
  void onPostDialContinue(bool proceed) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onPostDialContinue,
      jni.JniType.voidType,
      [proceed]).check();

  static final _id_onPullExternalCall =
      jniAccessors.getMethodIDOf(_classRef, "onPullExternalCall", "()V");

  /// from: public void onPullExternalCall()
  ///
  /// Notifies this Connection of a request to pull an external call to the local device.
  ///
  /// The InCallService issues a request to pull an external call to the local device via
  /// Call\#pullExternalCall().
  ///
  /// For a Connection to be pulled, both the Connection\#CAPABILITY_CAN_PULL_CALL
  /// capability and Connection\#PROPERTY_IS_EXTERNAL_CALL property bits must be set.
  ///
  /// For more information on external calls, see Connection\#PROPERTY_IS_EXTERNAL_CALL.
  void onPullExternalCall() => jniAccessors.callMethodWithArgs(
      reference, _id_onPullExternalCall, jni.JniType.voidType, []).check();

  static final _id_onCallEvent = jniAccessors.getMethodIDOf(
      _classRef, "onCallEvent", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onCallEvent(java.lang.String event, android.os.Bundle extras)
  ///
  /// Notifies this Connection of a Call event initiated from an InCallService.
  ///
  /// The InCallService issues a Call event via Call\#sendCallEvent(String, Bundle).
  ///
  /// Where possible, the Connection should make an attempt to handle Call events which
  /// are part of the {@code android.telecom.*} namespace.  The Connection should ignore any events
  /// it does not wish to handle.  Unexpected events should be handled gracefully, as it is
  /// possible that a InCallService has defined its own Call events which a Connection is
  /// not aware of.
  ///
  /// See also Call\#sendCallEvent(String, Bundle).
  ///@param event The call event.
  ///@param extras Extras associated with the call event.
  void onCallEvent(jni.JniString event, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCallEvent,
          jni.JniType.voidType, [event.reference, extras.reference]).check();

  static final _id_onHandoverComplete =
      jniAccessors.getMethodIDOf(_classRef, "onHandoverComplete", "()V");

  /// from: public void onHandoverComplete()
  ///
  /// Notifies this Connection that a handover has completed.
  ///
  /// A handover is initiated with android.telecom.Call\#handoverTo(PhoneAccountHandle, int,
  /// Bundle) on the initiating side of the handover, and
  /// TelecomManager\#acceptHandover(Uri, int, PhoneAccountHandle).
  void onHandoverComplete() => jniAccessors.callMethodWithArgs(
      reference, _id_onHandoverComplete, jni.JniType.voidType, []).check();

  static final _id_onExtrasChanged = jniAccessors.getMethodIDOf(
      _classRef, "onExtrasChanged", "(Landroid/os/Bundle;)V");

  /// from: public void onExtrasChanged(android.os.Bundle extras)
  ///
  /// Notifies this Connection of a change to the extras made outside the
  /// ConnectionService.
  ///
  /// These extras changes can originate from Telecom itself, or from an InCallService via
  /// the android.telecom.Call\#putExtras(Bundle) and
  /// Call\#removeExtras(List).
  ///@param extras The new extras bundle.
  void onExtrasChanged(bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onExtrasChanged,
          jni.JniType.voidType, [extras.reference]).check();

  static final _id_onShowIncomingCallUi =
      jniAccessors.getMethodIDOf(_classRef, "onShowIncomingCallUi", "()V");

  /// from: public void onShowIncomingCallUi()
  ///
  /// Notifies this Connection that its ConnectionService is responsible for
  /// displaying its incoming call user interface for the Connection.
  ///
  /// Will only be called for incoming calls added via a self-managed ConnectionService
  /// (see PhoneAccount\#CAPABILITY_SELF_MANAGED), where the ConnectionService
  /// should show its own incoming call user interface.
  ///
  /// Where there are ongoing calls in other self-managed ConnectionServices, or in a
  /// regular ConnectionService, and it is not possible to hold these other calls, the
  /// Telecom framework will display its own incoming call user interface to allow the user to
  /// choose whether to answer the new incoming call and disconnect other ongoing calls, or to
  /// reject the new incoming call.
  ///
  /// You should trigger the display of the incoming call user interface for your application by
  /// showing a Notification with a full-screen Intent specified.
  /// For example:
  /// <pre><code>
  ///     // Create an intent which triggers your fullscreen incoming call user interface.
  ///     Intent intent = new Intent(Intent.ACTION_MAIN, null);
  ///     intent.setFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION | Intent.FLAG_ACTIVITY_NEW_TASK);
  ///     intent.setClass(context, YourIncomingCallActivity.class);
  ///     PendingIntent pendingIntent = PendingIntent.getActivity(context, 1, intent, 0);
  ///
  ///     // Build the notification as an ongoing high priority item; this ensures it will show as
  ///     // a heads up notification which slides down over top of the current content.
  ///     final Notification.Builder builder = new Notification.Builder(context);
  ///     builder.setOngoing(true);
  ///     builder.setPriority(Notification.PRIORITY_HIGH);
  ///
  ///     // Set notification content intent to take user to fullscreen UI if user taps on the
  ///     // notification body.
  ///     builder.setContentIntent(pendingIntent);
  ///     // Set full screen intent to trigger display of the fullscreen UI when the notification
  ///     // manager deems it appropriate.
  ///     builder.setFullScreenIntent(pendingIntent, true);
  ///
  ///     // Setup notification content.
  ///     builder.setSmallIcon( yourIconResourceId );
  ///     builder.setContentTitle("Your notification title");
  ///     builder.setContentText("Your notification content.");
  ///
  ///     // Use builder.addAction(..) to add buttons to answer or reject the call.
  ///
  ///     NotificationManager notificationManager = mContext.getSystemService(
  ///         NotificationManager.class);
  ///     notificationManager.notify(YOUR_TAG, YOUR_ID, builder.build());
  /// </code></pre>
  void onShowIncomingCallUi() => jniAccessors.callMethodWithArgs(
      reference, _id_onShowIncomingCallUi, jni.JniType.voidType, []).check();

  static final _id_onStartRtt = jniAccessors.getMethodIDOf(_classRef,
      "onStartRtt", "(Landroid/telecom/Connection\$RttTextStream;)V");

  /// from: public void onStartRtt(android.telecom.Connection.RttTextStream rttTextStream)
  ///
  /// Notifies this Connection that the user has requested an RTT session.
  /// The connection service should call \#sendRttInitiationSuccess or
  /// \#sendRttInitiationFailure to inform Telecom of the success or failure of the
  /// request, respectively.
  ///@param rttTextStream The object that should be used to send text to or receive text from
  ///                      the in-call app.
  ///
  /// This value must never be {@code null}.
  void onStartRtt(Connection_RttTextStream rttTextStream) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartRtt,
          jni.JniType.voidType, [rttTextStream.reference]).check();

  static final _id_onStopRtt =
      jniAccessors.getMethodIDOf(_classRef, "onStopRtt", "()V");

  /// from: public void onStopRtt()
  ///
  /// Notifies this Connection that it should terminate any existing RTT communication
  /// channel. No response to Telecom is needed for this method.
  void onStopRtt() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopRtt, jni.JniType.voidType, []).check();

  static final _id_handleRttUpgradeResponse = jniAccessors.getMethodIDOf(
      _classRef,
      "handleRttUpgradeResponse",
      "(Landroid/telecom/Connection\$RttTextStream;)V");

  /// from: public void handleRttUpgradeResponse(android.telecom.Connection.RttTextStream rttTextStream)
  ///
  /// Notifies this connection of a response to a previous remotely-initiated RTT upgrade
  /// request sent via \#sendRemoteRttRequest. Acceptance of the request is
  /// indicated by the supplied RttTextStream being non-null, and rejection is
  /// indicated by {@code rttTextStream} being {@code null}
  ///@param rttTextStream The object that should be used to send text to or receive text from
  ///                      the in-call app.
  ///
  /// This value may be {@code null}.
  void handleRttUpgradeResponse(Connection_RttTextStream rttTextStream) =>
      jniAccessors.callMethodWithArgs(reference, _id_handleRttUpgradeResponse,
          jni.JniType.voidType, [rttTextStream.reference]).check();

  static final _id_createFailedConnection = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFailedConnection",
      "(Landroid/telecom/DisconnectCause;)Landroid/telecom/Connection;");

  /// from: static public android.telecom.Connection createFailedConnection(android.telecom.DisconnectCause disconnectCause)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a {@code Connection} which represents a failed connection attempt. The returned
  /// {@code Connection} will have a android.telecom.DisconnectCause and as specified,
  /// and a \#getState() of \#STATE_DISCONNECTED.
  ///
  /// The returned {@code Connection} can be assumed to \#destroy() itself when appropriate,
  /// so users of this method need not maintain a reference to its return value to destroy it.
  ///@param disconnectCause The disconnect cause, ({@see android.telecomm.DisconnectCause}).
  ///@return A {@code Connection} which indicates failure.
  static Connection createFailedConnection(
          disconnectcause_.DisconnectCause disconnectCause) =>
      Connection.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFailedConnection,
          jni.JniType.objectType,
          [disconnectCause.reference]).object);

  static final _id_createCanceledConnection = jniAccessors.getStaticMethodIDOf(
      _classRef, "createCanceledConnection", "()Landroid/telecom/Connection;");

  /// from: static public android.telecom.Connection createCanceledConnection()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a {@code Connection} which represents a canceled connection attempt. The returned
  /// {@code Connection} will have state \#STATE_DISCONNECTED, and cannot be moved out of
  /// that state. This connection should not be used for anything, and no other
  /// {@code Connection}s should be attempted.
  ///
  /// so users of this method need not maintain a reference to its return value to destroy it.
  ///@return A {@code Connection} which indicates that the underlying connection should
  /// be canceled.
  static Connection createCanceledConnection() =>
      Connection.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_createCanceledConnection, jni.JniType.objectType, []).object);

  static final _id_sendConnectionEvent = jniAccessors.getMethodIDOf(_classRef,
      "sendConnectionEvent", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void sendConnectionEvent(java.lang.String event, android.os.Bundle extras)
  ///
  /// Sends an event associated with this {@code Connection} with associated event extras to the
  /// InCallService.
  ///
  /// Connection events are used to communicate point in time information from a
  /// ConnectionService to a InCallService implementations.  An example of a
  /// custom connection event includes notifying the UI when a WIFI call has been handed over to
  /// LTE, which the InCall UI might use to inform the user that billing charges may apply.  The
  /// Android Telephony framework will send the \#EVENT_CALL_MERGE_FAILED connection event
  /// when a call to Call\#mergeConference() has failed to complete successfully.  A
  /// connection event could also be used to trigger UI in the InCallService which prompts
  /// the user to make a choice (e.g. whether they want to incur roaming costs for making a call),
  /// which is communicated back via Call\#sendCallEvent(String, Bundle).
  ///
  /// Events are exposed to InCallService implementations via
  /// Call.Callback\#onConnectionEvent(Call, String, Bundle).
  ///
  /// No assumptions should be made as to how an In-Call UI or service will handle these events.
  /// The ConnectionService must assume that the In-Call UI could even chose to ignore
  /// some events altogether.
  ///
  /// Events should be fully qualified (e.g. {@code com.example.event.MY_EVENT}) to avoid
  /// conflicts between ConnectionService implementations.  Further, custom
  /// ConnectionService implementations shall not re-purpose events in the
  /// {@code android.*} namespace, nor shall they define new event types in this namespace.  When
  /// defining a custom event type, ensure the contents of the extras Bundle is clearly
  /// defined.  Extra keys for this bundle should be named similar to the event type (e.g.
  /// {@code com.example.extra.MY_EXTRA}).
  ///
  ///  When defining events and the associated extras, it is important to keep their behavior
  /// consistent when the associated ConnectionService is updated.  Support for deprecated
  /// events/extras should me maintained to ensure backwards compatibility with older
  /// InCallService implementations which were built to support the older behavior.
  ///@param event The connection event.
  ///@param extras Optional bundle containing extra information associated with the event.
  void sendConnectionEvent(jni.JniString event, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendConnectionEvent,
          jni.JniType.voidType, [event.reference, extras.reference]).check();
}

/// from: android.telecom.Connection$VideoProvider
///
/// Provides a means of controlling the video session associated with a Connection.
///
/// Implementations create a custom subclass of VideoProvider and the
/// ConnectionService creates an instance sets it on the Connection using
/// Connection\#setVideoProvider(VideoProvider).  Any connection which supports video
/// should set the VideoProvider.
///
/// The VideoProvider serves two primary purposes: it provides a means for Telecom and
/// InCallService implementations to issue requests related to the video session;
/// it provides a means for the ConnectionService to report events and information
/// related to the video session to Telecom and the InCallService implementations.
///
/// InCallService implementations interact with the VideoProvider via
/// android.telecom.InCallService.VideoCall.
class Connection_VideoProvider extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/Connection\$VideoProvider");
  Connection_VideoProvider.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SESSION_EVENT_CAMERA_FAILURE
  ///
  /// A camera failure has occurred for the selected camera.  The VideoProvider can use
  /// this as a cue to inform the user the camera is not available.
  ///@see \#handleCallSessionEvent(int)
  static const SESSION_EVENT_CAMERA_FAILURE = 5;

  /// from: static public final int SESSION_EVENT_CAMERA_PERMISSION_ERROR
  ///
  /// Session event raised by Telecom when
  /// android.telecom.InCallService.VideoCall\#setCamera(String) is called and the
  /// caller does not have the necessary android.Manifest.permission\#CAMERA permission.
  ///@see \#handleCallSessionEvent(int)
  static const SESSION_EVENT_CAMERA_PERMISSION_ERROR = 7;

  /// from: static public final int SESSION_EVENT_CAMERA_READY
  ///
  /// Issued after \#SESSION_EVENT_CAMERA_FAILURE when the camera is once again ready
  /// for operation.  The VideoProvider can use this as a cue to inform the user that
  /// the camera has become available again.
  ///@see \#handleCallSessionEvent(int)
  static const SESSION_EVENT_CAMERA_READY = 6;

  /// from: static public final int SESSION_EVENT_RX_PAUSE
  ///
  /// Video is not being received (no protocol pause was issued).
  ///@see \#handleCallSessionEvent(int)
  static const SESSION_EVENT_RX_PAUSE = 1;

  /// from: static public final int SESSION_EVENT_RX_RESUME
  ///
  /// Video reception has resumed after a \#SESSION_EVENT_RX_PAUSE.
  ///@see \#handleCallSessionEvent(int)
  static const SESSION_EVENT_RX_RESUME = 2;

  /// from: static public final int SESSION_EVENT_TX_START
  ///
  /// Video transmission has begun. This occurs after a negotiated start of video transmission
  /// when the underlying protocol has actually begun transmitting video to the remote party.
  ///@see \#handleCallSessionEvent(int)
  static const SESSION_EVENT_TX_START = 3;

  /// from: static public final int SESSION_EVENT_TX_STOP
  ///
  /// Video transmission has stopped. This occurs after a negotiated stop of video transmission
  /// when the underlying protocol has actually stopped transmitting video to the remote party.
  ///@see \#handleCallSessionEvent(int)
  static const SESSION_EVENT_TX_STOP = 4;

  /// from: static public final int SESSION_MODIFY_REQUEST_FAIL
  ///
  /// Session modify request failed.
  ///@see \#receiveSessionModifyResponse(int, VideoProfile, VideoProfile)
  static const SESSION_MODIFY_REQUEST_FAIL = 2;

  /// from: static public final int SESSION_MODIFY_REQUEST_INVALID
  ///
  /// Session modify request ignored due to invalid parameters.
  ///@see \#receiveSessionModifyResponse(int, VideoProfile, VideoProfile)
  static const SESSION_MODIFY_REQUEST_INVALID = 3;

  /// from: static public final int SESSION_MODIFY_REQUEST_REJECTED_BY_REMOTE
  ///
  /// Session modify request rejected by remote user.
  ///@see \#receiveSessionModifyResponse(int, VideoProfile, VideoProfile)
  static const SESSION_MODIFY_REQUEST_REJECTED_BY_REMOTE = 5;

  /// from: static public final int SESSION_MODIFY_REQUEST_SUCCESS
  ///
  /// Session modify request was successful.
  ///@see \#receiveSessionModifyResponse(int, VideoProfile, VideoProfile)
  static const SESSION_MODIFY_REQUEST_SUCCESS = 1;

  /// from: static public final int SESSION_MODIFY_REQUEST_TIMED_OUT
  ///
  /// Session modify request timed out.
  ///@see \#receiveSessionModifyResponse(int, VideoProfile, VideoProfile)
  static const SESSION_MODIFY_REQUEST_TIMED_OUT = 4;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Connection_VideoProvider()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onSetCamera = jniAccessors.getMethodIDOf(
      _classRef, "onSetCamera", "(Ljava/lang/String;)V");

  /// from: public abstract void onSetCamera(java.lang.String cameraId)
  ///
  /// Sets the camera to be used for the outgoing video.
  ///
  /// The VideoProvider should respond by communicating the capabilities of the chosen
  /// camera via
  /// VideoProvider\#changeCameraCapabilities(VideoProfile.CameraCapabilities).
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#setCamera(String).
  ///@param cameraId The id of the camera (use ids as reported by
  /// CameraManager\#getCameraIdList()).
  void onSetCamera(jni.JniString cameraId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSetCamera,
      jni.JniType.voidType,
      [cameraId.reference]).check();

  static final _id_onSetPreviewSurface = jniAccessors.getMethodIDOf(
      _classRef, "onSetPreviewSurface", "(Landroid/view/Surface;)V");

  /// from: public abstract void onSetPreviewSurface(android.view.Surface surface)
  ///
  /// Sets the surface to be used for displaying a preview of what the user's camera is
  /// currently capturing.  When video transmission is enabled, this is the video signal which
  /// is sent to the remote device.
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#setPreviewSurface(Surface).
  ///@param surface The Surface.
  void onSetPreviewSurface(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSetPreviewSurface,
          jni.JniType.voidType, [surface.reference]).check();

  static final _id_onSetDisplaySurface = jniAccessors.getMethodIDOf(
      _classRef, "onSetDisplaySurface", "(Landroid/view/Surface;)V");

  /// from: public abstract void onSetDisplaySurface(android.view.Surface surface)
  ///
  /// Sets the surface to be used for displaying the video received from the remote device.
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#setDisplaySurface(Surface).
  ///@param surface The Surface.
  void onSetDisplaySurface(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSetDisplaySurface,
          jni.JniType.voidType, [surface.reference]).check();

  static final _id_onSetDeviceOrientation =
      jniAccessors.getMethodIDOf(_classRef, "onSetDeviceOrientation", "(I)V");

  /// from: public abstract void onSetDeviceOrientation(int rotation)
  ///
  /// Sets the device orientation, in degrees.  Assumes that a standard portrait orientation of
  /// the device is 0 degrees.
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#setDeviceOrientation(int).
  ///@param rotation The device orientation, in degrees.
  void onSetDeviceOrientation(int rotation) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSetDeviceOrientation,
      jni.JniType.voidType,
      [rotation]).check();

  static final _id_onSetZoom =
      jniAccessors.getMethodIDOf(_classRef, "onSetZoom", "(F)V");

  /// from: public abstract void onSetZoom(float value)
  ///
  /// Sets camera zoom ratio.
  ///
  /// Sent from the InCallService via InCallService.VideoCall\#setZoom(float).
  ///@param value The camera zoom ratio.
  void onSetZoom(double value) => jniAccessors.callMethodWithArgs(
      reference, _id_onSetZoom, jni.JniType.voidType, [value]).check();

  static final _id_onSendSessionModifyRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendSessionModifyRequest",
      "(Landroid/telecom/VideoProfile;Landroid/telecom/VideoProfile;)V");

  /// from: public abstract void onSendSessionModifyRequest(android.telecom.VideoProfile fromProfile, android.telecom.VideoProfile toProfile)
  ///
  /// Issues a request to modify the properties of the current video session.
  ///
  /// Example scenarios include: requesting an audio-only call to be upgraded to a
  /// bi-directional video call, turning on or off the user's camera, sending a pause signal
  /// when the InCallService is no longer the foreground application.
  ///
  /// If the VideoProvider determines a request to be invalid, it should call
  /// \#receiveSessionModifyResponse(int, VideoProfile, VideoProfile) to report the
  /// invalid request back to the InCallService.
  ///
  /// Where a request requires confirmation from the user of the peer device, the
  /// VideoProvider must communicate the request to the peer device and handle the
  /// user's response.  \#receiveSessionModifyResponse(int, VideoProfile, VideoProfile)
  /// is used to inform the InCallService of the result of the request.
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#sendSessionModifyRequest(VideoProfile).
  ///@param fromProfile The video profile prior to the request.
  ///@param toProfile The video profile with the requested changes made.
  void onSendSessionModifyRequest(videoprofile_.VideoProfile fromProfile,
          videoprofile_.VideoProfile toProfile) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSendSessionModifyRequest,
          jni.JniType.voidType,
          [fromProfile.reference, toProfile.reference]).check();

  static final _id_onSendSessionModifyResponse = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendSessionModifyResponse",
      "(Landroid/telecom/VideoProfile;)V");

  /// from: public abstract void onSendSessionModifyResponse(android.telecom.VideoProfile responseProfile)
  ///
  /// Provides a response to a request to change the current video session properties.
  ///
  /// For example, if the peer requests and upgrade from an audio-only call to a bi-directional
  /// video call, could decline the request and keep the call as audio-only.
  /// In such a scenario, the {@code responseProfile} would have a video state of
  /// VideoProfile\#STATE_AUDIO_ONLY.  If the user had decided to accept the request,
  /// the video state would be VideoProfile\#STATE_BIDIRECTIONAL.
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#sendSessionModifyResponse(VideoProfile) in response to
  /// a InCallService.VideoCall.Callback\#onSessionModifyRequestReceived(VideoProfile)
  /// callback.
  ///@param responseProfile The response video profile.
  void onSendSessionModifyResponse(
          videoprofile_.VideoProfile responseProfile) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSendSessionModifyResponse,
          jni.JniType.voidType,
          [responseProfile.reference]).check();

  static final _id_onRequestCameraCapabilities = jniAccessors.getMethodIDOf(
      _classRef, "onRequestCameraCapabilities", "()V");

  /// from: public abstract void onRequestCameraCapabilities()
  ///
  /// Issues a request to the VideoProvider to retrieve the camera capabilities.
  ///
  /// The VideoProvider should respond by communicating the capabilities of the chosen
  /// camera via
  /// VideoProvider\#changeCameraCapabilities(VideoProfile.CameraCapabilities).
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#requestCameraCapabilities().
  void onRequestCameraCapabilities() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRequestCameraCapabilities,
      jni.JniType.voidType, []).check();

  static final _id_onRequestConnectionDataUsage = jniAccessors.getMethodIDOf(
      _classRef, "onRequestConnectionDataUsage", "()V");

  /// from: public abstract void onRequestConnectionDataUsage()
  ///
  /// Issues a request to the VideoProvider to retrieve the current data usage for the
  /// video component of the current Connection.
  ///
  /// The VideoProvider should respond by communicating current data usage, in bytes,
  /// via VideoProvider\#setCallDataUsage(long).
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#requestCallDataUsage().
  void onRequestConnectionDataUsage() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRequestConnectionDataUsage,
      jni.JniType.voidType, []).check();

  static final _id_onSetPauseImage = jniAccessors.getMethodIDOf(
      _classRef, "onSetPauseImage", "(Landroid/net/Uri;)V");

  /// from: public abstract void onSetPauseImage(android.net.Uri uri)
  ///
  /// Provides the VideoProvider with the Uri of an image to be displayed to
  /// the peer device when the video signal is paused.
  ///
  /// Sent from the InCallService via
  /// InCallService.VideoCall\#setPauseImage(Uri).
  ///@param uri URI of image to display.
  void onSetPauseImage(uri_.Uri uri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSetPauseImage,
      jni.JniType.voidType,
      [uri.reference]).check();

  static final _id_receiveSessionModifyRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "receiveSessionModifyRequest",
      "(Landroid/telecom/VideoProfile;)V");

  /// from: public void receiveSessionModifyRequest(android.telecom.VideoProfile videoProfile)
  ///
  /// Used to inform listening InCallService implementations when the
  /// VideoProvider receives a session modification request.
  ///
  /// Received by the InCallService via
  /// InCallService.VideoCall.Callback\#onSessionModifyRequestReceived(VideoProfile),
  ///@param videoProfile The requested video profile.
  ///@see \#onSendSessionModifyRequest(VideoProfile, VideoProfile)
  void receiveSessionModifyRequest(videoprofile_.VideoProfile videoProfile) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_receiveSessionModifyRequest,
          jni.JniType.voidType,
          [videoProfile.reference]).check();

  static final _id_receiveSessionModifyResponse = jniAccessors.getMethodIDOf(
      _classRef,
      "receiveSessionModifyResponse",
      "(ILandroid/telecom/VideoProfile;Landroid/telecom/VideoProfile;)V");

  /// from: public void receiveSessionModifyResponse(int status, android.telecom.VideoProfile requestedProfile, android.telecom.VideoProfile responseProfile)
  ///
  /// Used to inform listening InCallService implementations when the
  /// VideoProvider receives a response to a session modification request.
  ///
  /// Received by the InCallService via
  /// InCallService.VideoCall.Callback\#onSessionModifyResponseReceived(int,
  /// VideoProfile, VideoProfile).
  ///@param status Status of the session modify request.  Valid values are
  ///               VideoProvider\#SESSION_MODIFY_REQUEST_SUCCESS,
  ///               VideoProvider\#SESSION_MODIFY_REQUEST_FAIL,
  ///               VideoProvider\#SESSION_MODIFY_REQUEST_INVALID,
  ///               VideoProvider\#SESSION_MODIFY_REQUEST_TIMED_OUT,
  ///               VideoProvider\#SESSION_MODIFY_REQUEST_REJECTED_BY_REMOTE
  ///@param requestedProfile The original request which was sent to the peer device.
  ///@param responseProfile The actual profile changes agreed to by the peer device.
  ///@see \#onSendSessionModifyRequest(VideoProfile, VideoProfile)
  void receiveSessionModifyResponse(
          int status,
          videoprofile_.VideoProfile requestedProfile,
          videoprofile_.VideoProfile responseProfile) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_receiveSessionModifyResponse, jni.JniType.voidType, [
        status,
        requestedProfile.reference,
        responseProfile.reference
      ]).check();

  static final _id_handleCallSessionEvent =
      jniAccessors.getMethodIDOf(_classRef, "handleCallSessionEvent", "(I)V");

  /// from: public void handleCallSessionEvent(int event)
  ///
  /// Used to inform listening InCallService implementations when the
  /// VideoProvider reports a call session event.
  ///
  /// Received by the InCallService via
  /// InCallService.VideoCall.Callback\#onCallSessionEvent(int).
  ///@param event The event.  Valid values are: VideoProvider\#SESSION_EVENT_RX_PAUSE,
  ///      VideoProvider\#SESSION_EVENT_RX_RESUME,
  ///      VideoProvider\#SESSION_EVENT_TX_START,
  ///      VideoProvider\#SESSION_EVENT_TX_STOP,
  ///      VideoProvider\#SESSION_EVENT_CAMERA_FAILURE,
  ///      VideoProvider\#SESSION_EVENT_CAMERA_READY,
  ///      VideoProvider\#SESSION_EVENT_CAMERA_FAILURE.
  void handleCallSessionEvent(int event) => jniAccessors.callMethodWithArgs(
      reference,
      _id_handleCallSessionEvent,
      jni.JniType.voidType,
      [event]).check();

  static final _id_changePeerDimensions =
      jniAccessors.getMethodIDOf(_classRef, "changePeerDimensions", "(II)V");

  /// from: public void changePeerDimensions(int width, int height)
  ///
  /// Used to inform listening InCallService implementations when the dimensions of the
  /// peer's video have changed.
  ///
  /// This could occur if, for example, the peer rotates their device, changing the aspect
  /// ratio of the video, or if the user switches between the back and front cameras.
  ///
  /// Received by the InCallService via
  /// InCallService.VideoCall.Callback\#onPeerDimensionsChanged(int, int).
  ///@param width The updated peer video width.
  ///@param height The updated peer video height.
  void changePeerDimensions(int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_changePeerDimensions,
          jni.JniType.voidType, [width, height]).check();

  static final _id_setCallDataUsage =
      jniAccessors.getMethodIDOf(_classRef, "setCallDataUsage", "(J)V");

  /// from: public void setCallDataUsage(long dataUsage)
  ///
  /// Used to inform listening InCallService implementations when the data usage of the
  /// video associated with the current Connection has changed.
  ///
  /// This could be in response to a preview request via
  /// \#onRequestConnectionDataUsage(), or as a periodic update by the
  /// VideoProvider.  Where periodic updates of data usage are provided, they should be
  /// provided at most for every 1 MB of data transferred and no more than once every 10 sec.
  ///
  /// Received by the InCallService via
  /// InCallService.VideoCall.Callback\#onCallDataUsageChanged(long).
  ///@param dataUsage The updated data usage (in bytes).  Reported as the cumulative bytes
  ///                  used since the start of the call.
  void setCallDataUsage(int dataUsage) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCallDataUsage,
      jni.JniType.voidType,
      [dataUsage]).check();

  static final _id_changeCameraCapabilities = jniAccessors.getMethodIDOf(
      _classRef,
      "changeCameraCapabilities",
      "(Landroid/telecom/VideoProfile\$CameraCapabilities;)V");

  /// from: public void changeCameraCapabilities(android.telecom.VideoProfile.CameraCapabilities cameraCapabilities)
  ///
  /// Used to inform listening InCallService implementations when the capabilities of
  /// the current camera have changed.
  ///
  /// The VideoProvider should call this in response to
  /// VideoProvider\#onRequestCameraCapabilities(), or when the current camera is
  /// changed via VideoProvider\#onSetCamera(String).
  ///
  /// Received by the InCallService via
  /// InCallService.VideoCall.Callback\#onCameraCapabilitiesChanged(
  /// VideoProfile.CameraCapabilities).
  ///@param cameraCapabilities The new camera capabilities.
  void changeCameraCapabilities(
          videoprofile_.VideoProfile_CameraCapabilities cameraCapabilities) =>
      jniAccessors.callMethodWithArgs(reference, _id_changeCameraCapabilities,
          jni.JniType.voidType, [cameraCapabilities.reference]).check();

  static final _id_changeVideoQuality =
      jniAccessors.getMethodIDOf(_classRef, "changeVideoQuality", "(I)V");

  /// from: public void changeVideoQuality(int videoQuality)
  ///
  /// Used to inform listening InCallService implementations when the video quality
  /// of the call has changed.
  ///
  /// Received by the InCallService via
  /// InCallService.VideoCall.Callback\#onVideoQualityChanged(int).
  ///@param videoQuality The updated video quality.  Valid values:
  ///      VideoProfile\#QUALITY_HIGH,
  ///      VideoProfile\#QUALITY_MEDIUM,
  ///      VideoProfile\#QUALITY_LOW,
  ///      VideoProfile\#QUALITY_DEFAULT.
  void changeVideoQuality(int videoQuality) => jniAccessors.callMethodWithArgs(
      reference,
      _id_changeVideoQuality,
      jni.JniType.voidType,
      [videoQuality]).check();
}

/// from: android.telecom.Connection$RttTextStream
///
/// Provides methods to read and write RTT data to/from the in-call app.
class Connection_RttTextStream extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/Connection\$RttTextStream");
  Connection_RttTextStream.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_write =
      jniAccessors.getMethodIDOf(_classRef, "write", "(Ljava/lang/String;)V");

  /// from: public void write(java.lang.String input)
  ///
  /// Writes the string {@param input} into the text stream to the UI for this RTT call. Since
  /// RTT transmits text in real-time, this method should be called as often as text snippets
  /// are received from the remote user, even if it is only one character.
  ///
  /// This method is not thread-safe -- calling it from multiple threads simultaneously may
  /// lead to interleaved text.
  ///@param input The message to send to the in-call app.
  void write(jni.JniString input) => jniAccessors.callMethodWithArgs(
      reference, _id_write, jni.JniType.voidType, [input.reference]).check();

  static final _id_read =
      jniAccessors.getMethodIDOf(_classRef, "read", "()Ljava/lang/String;");

  /// from: public java.lang.String read()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reads a string from the in-call app, blocking if there is no data available. Returns
  /// {@code null} if the RTT conversation has been terminated and there is no further data
  /// to read.
  ///
  /// This method is not thread-safe -- calling it from multiple threads simultaneously may
  /// lead to interleaved text.
  ///@return A string containing text entered by the user, or {@code null} if the
  /// conversation has been terminated or if there was an error while reading.
  jni.JniString read() => jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_read, jni.JniType.objectType, []).object);

  static final _id_readImmediately = jniAccessors.getMethodIDOf(
      _classRef, "readImmediately", "()Ljava/lang/String;");

  /// from: public java.lang.String readImmediately()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Non-blocking version of \#read(). Returns {@code null} if there is nothing to
  /// be read.
  ///@return A string containing text entered by the user, or {@code null} if the user has
  /// not entered any new text yet.
  jni.JniString readImmediately() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readImmediately, jni.JniType.objectType, []).object);
}

/// from: android.telecom.Connection$RttModifyStatus
///
/// Provides constants to represent the results of responses to session modify requests sent via
/// Call\#sendRttRequest()
class Connection_RttModifyStatus extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/Connection\$RttModifyStatus");
  Connection_RttModifyStatus.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SESSION_MODIFY_REQUEST_FAIL
  ///
  /// Session modify request failed.
  static const SESSION_MODIFY_REQUEST_FAIL = 2;

  /// from: static public final int SESSION_MODIFY_REQUEST_INVALID
  ///
  /// Session modify request ignored due to invalid parameters.
  static const SESSION_MODIFY_REQUEST_INVALID = 3;

  /// from: static public final int SESSION_MODIFY_REQUEST_REJECTED_BY_REMOTE
  ///
  /// Session modify request rejected by remote user.
  static const SESSION_MODIFY_REQUEST_REJECTED_BY_REMOTE = 5;

  /// from: static public final int SESSION_MODIFY_REQUEST_SUCCESS
  ///
  /// Session modify request was successful.
  static const SESSION_MODIFY_REQUEST_SUCCESS = 1;

  /// from: static public final int SESSION_MODIFY_REQUEST_TIMED_OUT
  ///
  /// Session modify request timed out.
  static const SESSION_MODIFY_REQUEST_TIMED_OUT = 4;
}
