// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Conferenceable.dart" as conferenceable_;

import "PhoneAccountHandle.dart" as phoneaccounthandle_;

import "CallAudioState.dart" as callaudiostate_;

import "Connection.dart" as connection_;

import "DisconnectCause.dart" as disconnectcause_;

import "StatusHints.dart" as statushints_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telecom.Conference
///
/// Represents a conference call which can contain any number of Connection objects.
class Conference extends conferenceable_.Conferenceable {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/Conference");
  Conference.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final long CONNECT_TIME_NOT_SPECIFIED
  ///
  /// Used to indicate that the conference connection time is not specified.  If not specified,
  /// Telecom will set the connect time.
  static const CONNECT_TIME_NOT_SPECIFIED = 0;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/telecom/PhoneAccountHandle;)V");

  /// from: public void <init>(android.telecom.PhoneAccountHandle phoneAccount)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new Conference with a mandatory PhoneAccountHandle
  ///@param phoneAccount The {@code PhoneAccountHandle} associated with the conference.
  Conference(phoneaccounthandle_.PhoneAccountHandle phoneAccount)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [phoneAccount.reference]).object);

  static final _id_getPhoneAccountHandle = jniAccessors.getMethodIDOf(_classRef,
      "getPhoneAccountHandle", "()Landroid/telecom/PhoneAccountHandle;");

  /// from: public final android.telecom.PhoneAccountHandle getPhoneAccountHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the PhoneAccountHandle the conference call is being placed through.
  ///@return A {@code PhoneAccountHandle} object representing the PhoneAccount of the conference.
  phoneaccounthandle_.PhoneAccountHandle getPhoneAccountHandle() =>
      phoneaccounthandle_.PhoneAccountHandle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getPhoneAccountHandle,
              jni.JniType.objectType, []).object);

  static final _id_getConnections = jniAccessors.getMethodIDOf(
      _classRef, "getConnections", "()Ljava/util/List;");

  /// from: public final java.util.List<android.telecom.Connection> getConnections()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of connections currently associated with the conference call.
  ///@return A list of {@code Connection} objects which represent the children of the conference.
  jni.JniObject getConnections() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConnections, jni.JniType.objectType, []).object);

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public final int getState()
  ///
  /// Gets the state of the conference call. See Connection for valid values.
  ///@return A constant representing the state the conference call is currently in.
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_getConnectionCapabilities =
      jniAccessors.getMethodIDOf(_classRef, "getConnectionCapabilities", "()I");

  /// from: public final int getConnectionCapabilities()
  ///
  /// Returns the capabilities of the conference. See {@code CAPABILITY_*} constants in class
  /// Connection for valid values.
  ///@return A bitmask of the capabilities of the conference call.
  int getConnectionCapabilities() => jniAccessors.callMethodWithArgs(reference,
      _id_getConnectionCapabilities, jni.JniType.intType, []).integer;

  static final _id_getConnectionProperties =
      jniAccessors.getMethodIDOf(_classRef, "getConnectionProperties", "()I");

  /// from: public final int getConnectionProperties()
  ///
  /// Returns the properties of the conference. See {@code PROPERTY_*} constants in class
  /// Connection for valid values.
  ///@return A bitmask of the properties of the conference call.
  int getConnectionProperties() => jniAccessors.callMethodWithArgs(
      reference, _id_getConnectionProperties, jni.JniType.intType, []).integer;

  static final _id_getCallAudioState = jniAccessors.getMethodIDOf(
      _classRef, "getCallAudioState", "()Landroid/telecom/CallAudioState;");

  /// from: public final android.telecom.CallAudioState getCallAudioState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The audio state of the conference, describing how its audio is currently
  ///         being routed by the system. This is {@code null} if this Conference
  ///         does not directly know about its audio state.
  callaudiostate_.CallAudioState getCallAudioState() =>
      callaudiostate_.CallAudioState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallAudioState, jni.JniType.objectType, []).object);

  static final _id_getVideoProvider = jniAccessors.getMethodIDOf(_classRef,
      "getVideoProvider", "()Landroid/telecom/Connection\$VideoProvider;");

  /// from: public android.telecom.Connection.VideoProvider getVideoProvider()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns VideoProvider of the primary call. This can be null.
  connection_.Connection_VideoProvider getVideoProvider() =>
      connection_.Connection_VideoProvider.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getVideoProvider,
              jni.JniType.objectType, []).object);

  static final _id_getVideoState =
      jniAccessors.getMethodIDOf(_classRef, "getVideoState", "()I");

  /// from: public int getVideoState()
  ///
  /// Returns video state of the primary call.
  int getVideoState() => jniAccessors.callMethodWithArgs(
      reference, _id_getVideoState, jni.JniType.intType, []).integer;

  static final _id_onDisconnect =
      jniAccessors.getMethodIDOf(_classRef, "onDisconnect", "()V");

  /// from: public void onDisconnect()
  ///
  /// Notifies the Conference when the Conference and all it's Connections should
  /// be disconnected.
  void onDisconnect() => jniAccessors.callMethodWithArgs(
      reference, _id_onDisconnect, jni.JniType.voidType, []).check();

  static final _id_onSeparate = jniAccessors.getMethodIDOf(
      _classRef, "onSeparate", "(Landroid/telecom/Connection;)V");

  /// from: public void onSeparate(android.telecom.Connection connection)
  ///
  /// Notifies the Conference when the specified Connection should be separated
  /// from the conference call.
  ///@param connection The connection to separate.
  void onSeparate(connection_.Connection connection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSeparate,
          jni.JniType.voidType, [connection.reference]).check();

  static final _id_onMerge = jniAccessors.getMethodIDOf(
      _classRef, "onMerge", "(Landroid/telecom/Connection;)V");

  /// from: public void onMerge(android.telecom.Connection connection)
  ///
  /// Notifies the Conference when the specified Connection should merged with the
  /// conference call.
  ///@param connection The {@code Connection} to merge.
  void onMerge(connection_.Connection connection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMerge,
          jni.JniType.voidType, [connection.reference]).check();

  static final _id_onHold =
      jniAccessors.getMethodIDOf(_classRef, "onHold", "()V");

  /// from: public void onHold()
  ///
  /// Notifies the Conference when it should be put on hold.
  void onHold() => jniAccessors.callMethodWithArgs(
      reference, _id_onHold, jni.JniType.voidType, []).check();

  static final _id_onUnhold =
      jniAccessors.getMethodIDOf(_classRef, "onUnhold", "()V");

  /// from: public void onUnhold()
  ///
  /// Notifies the Conference when it should be moved from a held to active state.
  void onUnhold() => jniAccessors.callMethodWithArgs(
      reference, _id_onUnhold, jni.JniType.voidType, []).check();

  static final _id_onMerge1 =
      jniAccessors.getMethodIDOf(_classRef, "onMerge", "()V");

  /// from: public void onMerge()
  ///
  /// Notifies the Conference when the child calls should be merged.  Only invoked if the
  /// conference contains the capability Connection\#CAPABILITY_MERGE_CONFERENCE.
  void onMerge1() => jniAccessors.callMethodWithArgs(
      reference, _id_onMerge1, jni.JniType.voidType, []).check();

  static final _id_onSwap =
      jniAccessors.getMethodIDOf(_classRef, "onSwap", "()V");

  /// from: public void onSwap()
  ///
  /// Notifies the Conference when the child calls should be swapped. Only invoked if the
  /// conference contains the capability Connection\#CAPABILITY_SWAP_CONFERENCE.
  void onSwap() => jniAccessors.callMethodWithArgs(
      reference, _id_onSwap, jni.JniType.voidType, []).check();

  static final _id_onPlayDtmfTone =
      jniAccessors.getMethodIDOf(_classRef, "onPlayDtmfTone", "(C)V");

  /// from: public void onPlayDtmfTone(char c)
  ///
  /// Notifies the Conference of a request to play a DTMF tone.
  ///@param c A DTMF character.
  void onPlayDtmfTone(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_onPlayDtmfTone, jni.JniType.voidType, [c]).check();

  static final _id_onStopDtmfTone =
      jniAccessors.getMethodIDOf(_classRef, "onStopDtmfTone", "()V");

  /// from: public void onStopDtmfTone()
  ///
  /// Notifies the Conference of a request to stop any currently playing DTMF tones.
  void onStopDtmfTone() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopDtmfTone, jni.JniType.voidType, []).check();

  static final _id_onCallAudioStateChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onCallAudioStateChanged",
      "(Landroid/telecom/CallAudioState;)V");

  /// from: public void onCallAudioStateChanged(android.telecom.CallAudioState state)
  ///
  /// Notifies the Conference that the \#getCallAudioState() property has a new
  /// value.
  ///@param state The new call audio state.
  void onCallAudioStateChanged(callaudiostate_.CallAudioState state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCallAudioStateChanged,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_onConnectionAdded = jniAccessors.getMethodIDOf(
      _classRef, "onConnectionAdded", "(Landroid/telecom/Connection;)V");

  /// from: public void onConnectionAdded(android.telecom.Connection connection)
  ///
  /// Notifies the Conference that a Connection has been added to it.
  ///@param connection The newly added connection.
  void onConnectionAdded(connection_.Connection connection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConnectionAdded,
          jni.JniType.voidType, [connection.reference]).check();

  static final _id_setOnHold =
      jniAccessors.getMethodIDOf(_classRef, "setOnHold", "()V");

  /// from: public final void setOnHold()
  ///
  /// Sets state to be on hold.
  void setOnHold() => jniAccessors.callMethodWithArgs(
      reference, _id_setOnHold, jni.JniType.voidType, []).check();

  static final _id_setDialing =
      jniAccessors.getMethodIDOf(_classRef, "setDialing", "()V");

  /// from: public final void setDialing()
  ///
  /// Sets state to be dialing.
  void setDialing() => jniAccessors.callMethodWithArgs(
      reference, _id_setDialing, jni.JniType.voidType, []).check();

  static final _id_setActive =
      jniAccessors.getMethodIDOf(_classRef, "setActive", "()V");

  /// from: public final void setActive()
  ///
  /// Sets state to be active.
  void setActive() => jniAccessors.callMethodWithArgs(
      reference, _id_setActive, jni.JniType.voidType, []).check();

  static final _id_setDisconnected = jniAccessors.getMethodIDOf(
      _classRef, "setDisconnected", "(Landroid/telecom/DisconnectCause;)V");

  /// from: public final void setDisconnected(android.telecom.DisconnectCause disconnectCause)
  ///
  /// Sets state to disconnected.
  ///@param disconnectCause The reason for the disconnection, as described by
  ///     android.telecom.DisconnectCause.
  void setDisconnected(disconnectcause_.DisconnectCause disconnectCause) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisconnected,
          jni.JniType.voidType, [disconnectCause.reference]).check();

  static final _id_getDisconnectCause = jniAccessors.getMethodIDOf(
      _classRef, "getDisconnectCause", "()Landroid/telecom/DisconnectCause;");

  /// from: public final android.telecom.DisconnectCause getDisconnectCause()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The DisconnectCause for this connection.
  disconnectcause_.DisconnectCause getDisconnectCause() =>
      disconnectcause_.DisconnectCause.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDisconnectCause,
          jni.JniType.objectType, []).object);

  static final _id_setConnectionCapabilities = jniAccessors.getMethodIDOf(
      _classRef, "setConnectionCapabilities", "(I)V");

  /// from: public final void setConnectionCapabilities(int connectionCapabilities)
  ///
  /// Sets the capabilities of a conference. See {@code CAPABILITY_*} constants of class
  /// Connection for valid values.
  ///@param connectionCapabilities A bitmask of the {@code Capabilities} of the conference call.
  void setConnectionCapabilities(int connectionCapabilities) =>
      jniAccessors.callMethodWithArgs(reference, _id_setConnectionCapabilities,
          jni.JniType.voidType, [connectionCapabilities]).check();

  static final _id_setConnectionProperties =
      jniAccessors.getMethodIDOf(_classRef, "setConnectionProperties", "(I)V");

  /// from: public final void setConnectionProperties(int connectionProperties)
  ///
  /// Sets the properties of a conference. See {@code PROPERTY_*} constants of class
  /// Connection for valid values.
  ///@param connectionProperties A bitmask of the {@code Properties} of the conference call.
  void setConnectionProperties(int connectionProperties) =>
      jniAccessors.callMethodWithArgs(reference, _id_setConnectionProperties,
          jni.JniType.voidType, [connectionProperties]).check();

  static final _id_addConnection = jniAccessors.getMethodIDOf(
      _classRef, "addConnection", "(Landroid/telecom/Connection;)Z");

  /// from: public final boolean addConnection(android.telecom.Connection connection)
  ///
  /// Adds the specified connection as a child of this conference.
  ///@param connection The connection to add.
  ///@return True if the connection was successfully added.
  bool addConnection(connection_.Connection connection) =>
      jniAccessors.callMethodWithArgs(reference, _id_addConnection,
          jni.JniType.booleanType, [connection.reference]).boolean;

  static final _id_removeConnection = jniAccessors.getMethodIDOf(
      _classRef, "removeConnection", "(Landroid/telecom/Connection;)V");

  /// from: public final void removeConnection(android.telecom.Connection connection)
  ///
  /// Removes the specified connection as a child of this conference.
  ///@param connection The connection to remove.
  void removeConnection(connection_.Connection connection) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeConnection,
          jni.JniType.voidType, [connection.reference]).check();

  static final _id_setConferenceableConnections = jniAccessors.getMethodIDOf(
      _classRef, "setConferenceableConnections", "(Ljava/util/List;)V");

  /// from: public final void setConferenceableConnections(java.util.List<android.telecom.Connection> conferenceableConnections)
  ///
  /// Sets the connections with which this connection can be conferenced.
  ///@param conferenceableConnections The set of connections this connection can conference with.
  void setConferenceableConnections(jni.JniObject conferenceableConnections) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setConferenceableConnections,
          jni.JniType.voidType,
          [conferenceableConnections.reference]).check();

  static final _id_setVideoState = jniAccessors.getMethodIDOf(
      _classRef, "setVideoState", "(Landroid/telecom/Connection;I)V");

  /// from: public final void setVideoState(android.telecom.Connection c, int videoState)
  ///
  /// Set the video state for the conference.
  /// Valid values: VideoProfile\#STATE_AUDIO_ONLY,
  /// VideoProfile\#STATE_BIDIRECTIONAL,
  /// VideoProfile\#STATE_TX_ENABLED,
  /// VideoProfile\#STATE_RX_ENABLED.
  ///@param videoState The new video state.
  void setVideoState(connection_.Connection c, int videoState) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVideoState,
          jni.JniType.voidType, [c.reference, videoState]).check();

  static final _id_setVideoProvider = jniAccessors.getMethodIDOf(
      _classRef,
      "setVideoProvider",
      "(Landroid/telecom/Connection;Landroid/telecom/Connection\$VideoProvider;)V");

  /// from: public final void setVideoProvider(android.telecom.Connection c, android.telecom.Connection.VideoProvider videoProvider)
  ///
  /// Sets the video connection provider.
  ///@param videoProvider The video provider.
  void setVideoProvider(connection_.Connection c,
          connection_.Connection_VideoProvider videoProvider) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVideoProvider,
          jni.JniType.voidType, [c.reference, videoProvider.reference]).check();

  static final _id_getConferenceableConnections = jniAccessors.getMethodIDOf(
      _classRef, "getConferenceableConnections", "()Ljava/util/List;");

  /// from: public final java.util.List<android.telecom.Connection> getConferenceableConnections()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the connections with which this connection can be conferenced.
  jni.JniObject getConferenceableConnections() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConferenceableConnections, jni.JniType.objectType, []).object);

  static final _id_destroy =
      jniAccessors.getMethodIDOf(_classRef, "destroy", "()V");

  /// from: public final void destroy()
  ///
  /// Tears down the conference object and any of its current connections.
  void destroy() => jniAccessors.callMethodWithArgs(
      reference, _id_destroy, jni.JniType.voidType, []).check();

  static final _id_setConnectionTime =
      jniAccessors.getMethodIDOf(_classRef, "setConnectionTime", "(J)V");

  /// from: public final void setConnectionTime(long connectionTimeMillis)
  ///
  /// Sets the connection start time of the {@code Conference}.  This is used in the call log to
  /// indicate the date and time when the conference took place.
  ///
  /// Should be specified in wall-clock time returned by System\#currentTimeMillis().
  ///
  /// When setting the connection time, you should always set the connection elapsed time via
  /// \#setConnectionStartElapsedRealTime(long) to ensure the duration is reflected.
  ///@param connectionTimeMillis The connection time, in milliseconds, as returned by
  ///                             System\#currentTimeMillis().
  void setConnectionTime(int connectionTimeMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_setConnectionTime,
          jni.JniType.voidType, [connectionTimeMillis]).check();

  static final _id_setConnectionStartElapsedRealTime = jniAccessors
      .getMethodIDOf(_classRef, "setConnectionStartElapsedRealTime", "(J)V");

  /// from: public final void setConnectionStartElapsedRealTime(long connectionStartElapsedRealTime)
  ///
  /// Sets the start time of the Conference which is the basis for the determining the
  /// duration of the Conference.
  ///
  /// You should use a value returned by SystemClock\#elapsedRealtime() to ensure that time
  /// zone changes do not impact the conference duration.
  ///
  /// When setting this, you should also set the connection time via
  /// \#setConnectionTime(long).
  ///@param connectionStartElapsedRealTime The connection time, as measured by
  /// SystemClock\#elapsedRealtime().
  void setConnectionStartElapsedRealTime(int connectionStartElapsedRealTime) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setConnectionStartElapsedRealTime,
          jni.JniType.voidType,
          [connectionStartElapsedRealTime]).check();

  static final _id_getConnectionTime =
      jniAccessors.getMethodIDOf(_classRef, "getConnectionTime", "()J");

  /// from: public final long getConnectionTime()
  ///
  /// Retrieves the connection start time of the {@code Conference}, if specified.  A value of
  /// \#CONNECT_TIME_NOT_SPECIFIED indicates that Telecom should determine the start time
  /// of the conference.
  ///@return The time at which the {@code Conference} was connected.
  int getConnectionTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getConnectionTime, jni.JniType.longType, []).long;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_setStatusHints = jniAccessors.getMethodIDOf(
      _classRef, "setStatusHints", "(Landroid/telecom/StatusHints;)V");

  /// from: public final void setStatusHints(android.telecom.StatusHints statusHints)
  ///
  /// Sets the label and icon status to display in the InCall UI.
  ///@param statusHints The status label and icon to set.
  void setStatusHints(statushints_.StatusHints statusHints) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStatusHints,
          jni.JniType.voidType, [statusHints.reference]).check();

  static final _id_getStatusHints = jniAccessors.getMethodIDOf(
      _classRef, "getStatusHints", "()Landroid/telecom/StatusHints;");

  /// from: public final android.telecom.StatusHints getStatusHints()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The status hints for this conference.
  statushints_.StatusHints getStatusHints() =>
      statushints_.StatusHints.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStatusHints, jni.JniType.objectType, []).object);

  static final _id_setExtras = jniAccessors.getMethodIDOf(
      _classRef, "setExtras", "(Landroid/os/Bundle;)V");

  /// from: public final void setExtras(android.os.Bundle extras)
  ///
  /// Replaces all the extras associated with this {@code Conference}.
  ///
  /// New or existing keys are replaced in the {@code Conference} extras.  Keys which are no longer
  /// in the new extras, but were present the last time {@code setExtras} was called are removed.
  ///
  /// Alternatively you may use the \#putExtras(Bundle), and
  /// \#removeExtras(String...) methods to modify the extras.
  ///
  /// No assumptions should be made as to how an In-Call UI or service will handle these extras.
  /// Keys should be fully qualified (e.g., com.example.extras.MY_EXTRA) to avoid conflicts.
  ///@param extras The extras associated with this {@code Conference}.
  ///
  /// This value may be {@code null}.
  void setExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_putExtras = jniAccessors.getMethodIDOf(
      _classRef, "putExtras", "(Landroid/os/Bundle;)V");

  /// from: public final void putExtras(android.os.Bundle extras)
  ///
  /// Adds some extras to this Conference.  Existing keys are replaced and new ones are
  /// added.
  ///
  /// No assumptions should be made as to how an In-Call UI or service will handle these extras.
  /// Keys should be fully qualified (e.g., com.example.MY_EXTRA) to avoid conflicts.
  ///@param extras The extras to add.
  ///
  /// This value must never be {@code null}.
  void putExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_putExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_removeExtras = jniAccessors.getMethodIDOf(
      _classRef, "removeExtras", "(Ljava/util/List;)V");

  /// from: public final void removeExtras(java.util.List<java.lang.String> keys)
  ///
  /// Removes extras from this Conference.
  ///@param keys The keys of the extras to remove.
  void removeExtras(jni.JniObject keys) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeExtras,
      jni.JniType.voidType,
      [keys.reference]).check();

  static final _id_removeExtras1 = jniAccessors.getMethodIDOf(
      _classRef, "removeExtras", "([Ljava/lang/String;)V");

  /// from: public final void removeExtras(java.lang.String[] keys)
  ///
  /// Removes extras from this Conference.
  ///@param keys The keys of the extras to remove.
  void removeExtras1(jni.JniObject keys) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeExtras1,
      jni.JniType.voidType,
      [keys.reference]).check();

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public final android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the extras associated with this conference.
  ///
  /// Extras should be updated using \#putExtras(Bundle) and \#removeExtras(List).
  ///
  /// Telecom or an InCallService can also update the extras via
  /// android.telecom.Call\#putExtras(Bundle), and
  /// Call\#removeExtras(List).
  ///
  /// The conference is notified of changes to the extras made by Telecom or an
  /// InCallService by \#onExtrasChanged(Bundle).
  ///@return The extras associated with this connection.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_onExtrasChanged = jniAccessors.getMethodIDOf(
      _classRef, "onExtrasChanged", "(Landroid/os/Bundle;)V");

  /// from: public void onExtrasChanged(android.os.Bundle extras)
  ///
  /// Notifies this Conference of a change to the extras made outside the
  /// ConnectionService.
  ///
  /// These extras changes can originate from Telecom itself, or from an InCallService via
  /// android.telecom.Call\#putExtras(Bundle), and
  /// Call\#removeExtras(List).
  ///@param extras The new extras bundle.
  void onExtrasChanged(bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onExtrasChanged,
          jni.JniType.voidType, [extras.reference]).check();
}
