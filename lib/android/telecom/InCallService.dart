// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../app/Service.dart" as service_;

import "../os/IBinder.dart" as ibinder_;

import "../content/Intent.dart" as intent_;

import "CallAudioState.dart" as callaudiostate_;

import "../bluetooth/BluetoothDevice.dart" as bluetoothdevice_;

import "Call.dart" as call_;

import "../os/Bundle.dart" as bundle_;

import "../os/Handler.dart" as handler_;

import "../view/Surface.dart" as surface_;

import "VideoProfile.dart" as videoprofile_;

import "../net/Uri.dart" as uri_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telecom.InCallService
///
/// This service is implemented by any app that wishes to provide the user-interface for managing
/// phone calls. Telecom binds to this service while there exists a live (active or incoming) call,
/// and uses it to notify the in-call app of any live and recently disconnected calls. An app must
/// first be set as the default phone app (See TelecomManager\#getDefaultDialerPackage())
/// before the telecom service will bind to its {@code InCallService} implementation.
///
/// Below is an example manifest registration for an {@code InCallService}. The meta-data
/// (TelecomManager\#METADATA_IN_CALL_SERVICE_UI) indicates that this particular
/// {@code InCallService} implementation intends to replace the built-in in-call UI.
/// <pre>
/// {@code
/// <service android:name="your.package.YourInCallServiceImplementation"
///          android:permission="android.permission.BIND_INCALL_SERVICE">
///      <meta-data android:name="android.telecom.IN_CALL_SERVICE_UI" android:value="true" />
///      <intent-filter>
///          <action android:name="android.telecom.InCallService"/>
///      </intent-filter>
/// </service>
/// }
/// </pre>
///
/// In addition to implementing the InCallService API, you must also declare an activity in
/// your manifest which handles the Intent\#ACTION_DIAL intent.  The example below illustrates
/// how this is done:
/// <pre>
/// {@code
/// <activity android:name="your.package.YourDialerActivity"
///           android:label="@string/yourDialerActivityLabel">
///      <intent-filter>
///           <action android:name="android.intent.action.DIAL" />
///           <category android:name="android.intent.category.DEFAULT" />
///      </intent-filter>
/// </activity>
/// }
/// </pre>
///
/// When a user installs your application and runs it for the first time, you should prompt the user
/// to see if they would like your application to be the new default phone app.  See the
/// TelecomManager\#ACTION_CHANGE_DEFAULT_DIALER intent documentation for more information on
/// how to do this.
class InCallService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/InCallService");
  InCallService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent that must be declared as handled by the service.
  static const SERVICE_INTERFACE = "android.telecom.InCallService";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InCallService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_onUnbind = jniAccessors.getMethodIDOf(
      _classRef, "onUnbind", "(Landroid/content/Intent;)Z");

  /// from: public boolean onUnbind(android.content.Intent intent)
  bool onUnbind(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onUnbind,
      jni.JniType.booleanType,
      [intent.reference]).boolean;

  static final _id_getCalls =
      jniAccessors.getMethodIDOf(_classRef, "getCalls", "()Ljava/util/List;");

  /// from: public final java.util.List<android.telecom.Call> getCalls()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains the current list of {@code Call}s to be displayed by this in-call service.
  ///@return A list of the relevant {@code Call}s.
  jni.JniObject getCalls() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCalls, jni.JniType.objectType, []).object);

  static final _id_canAddCall =
      jniAccessors.getMethodIDOf(_classRef, "canAddCall", "()Z");

  /// from: public final boolean canAddCall()
  ///
  /// Returns if the device can support additional calls.
  ///@return Whether the phone supports adding more calls.
  bool canAddCall() => jniAccessors.callMethodWithArgs(
      reference, _id_canAddCall, jni.JniType.booleanType, []).boolean;

  static final _id_getCallAudioState = jniAccessors.getMethodIDOf(
      _classRef, "getCallAudioState", "()Landroid/telecom/CallAudioState;");

  /// from: public final android.telecom.CallAudioState getCallAudioState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains the current phone call audio state.
  ///@return An object encapsulating the audio state. Returns null if the service is not
  ///         fully initialized.
  callaudiostate_.CallAudioState getCallAudioState() =>
      callaudiostate_.CallAudioState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallAudioState, jni.JniType.objectType, []).object);

  static final _id_setMuted =
      jniAccessors.getMethodIDOf(_classRef, "setMuted", "(Z)V");

  /// from: public final void setMuted(boolean state)
  ///
  /// Sets the microphone mute state. When this request is honored, there will be change to
  /// the \#getCallAudioState().
  ///@param state {@code true} if the microphone should be muted; {@code false} otherwise.
  void setMuted(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setMuted, jni.JniType.voidType, [state]).check();

  static final _id_setAudioRoute =
      jniAccessors.getMethodIDOf(_classRef, "setAudioRoute", "(I)V");

  /// from: public final void setAudioRoute(int route)
  ///
  /// Sets the audio route (speaker, bluetooth, etc...).  When this request is honored, there will
  /// be change to the \#getCallAudioState().
  ///@param route The audio route to use.
  void setAudioRoute(int route) => jniAccessors.callMethodWithArgs(
      reference, _id_setAudioRoute, jni.JniType.voidType, [route]).check();

  static final _id_requestBluetoothAudio = jniAccessors.getMethodIDOf(_classRef,
      "requestBluetoothAudio", "(Landroid/bluetooth/BluetoothDevice;)V");

  /// from: public final void requestBluetoothAudio(android.bluetooth.BluetoothDevice bluetoothDevice)
  ///
  /// Request audio routing to a specific bluetooth device. Calling this method may result in
  /// the device routing audio to a different bluetooth device than the one specified if the
  /// bluetooth stack is unable to route audio to the requested device.
  /// A list of available devices can be obtained via
  /// CallAudioState\#getSupportedBluetoothDevices()
  ///@param bluetoothDevice The bluetooth device to connect to.
  ///
  /// This value must never be {@code null}.
  void requestBluetoothAudio(
          bluetoothdevice_.BluetoothDevice bluetoothDevice) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestBluetoothAudio,
          jni.JniType.voidType, [bluetoothDevice.reference]).check();

  static final _id_onCallAudioStateChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onCallAudioStateChanged",
      "(Landroid/telecom/CallAudioState;)V");

  /// from: public void onCallAudioStateChanged(android.telecom.CallAudioState audioState)
  ///
  /// Called when the audio state changes.
  ///@param audioState The new CallAudioState.
  void onCallAudioStateChanged(callaudiostate_.CallAudioState audioState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCallAudioStateChanged,
          jni.JniType.voidType, [audioState.reference]).check();

  static final _id_onBringToForeground =
      jniAccessors.getMethodIDOf(_classRef, "onBringToForeground", "(Z)V");

  /// from: public void onBringToForeground(boolean showDialpad)
  ///
  /// Called to bring the in-call screen to the foreground. The in-call experience should
  /// respond immediately by coming to the foreground to inform the user of the state of
  /// ongoing {@code Call}s.
  ///@param showDialpad If true, put up the dialpad when the screen is shown.
  void onBringToForeground(bool showDialpad) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBringToForeground,
      jni.JniType.voidType,
      [showDialpad]).check();

  static final _id_onCallAdded = jniAccessors.getMethodIDOf(
      _classRef, "onCallAdded", "(Landroid/telecom/Call;)V");

  /// from: public void onCallAdded(android.telecom.Call call)
  ///
  /// Called when a {@code Call} has been added to this in-call session. The in-call user
  /// experience should add necessary state listeners to the specified {@code Call} and
  /// immediately start to show the user information about the existence
  /// and nature of this {@code Call}. Subsequent invocations of \#getCalls() will
  /// include this {@code Call}.
  ///@param call A newly added {@code Call}.
  void onCallAdded(call_.Call call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCallAdded,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onCallRemoved = jniAccessors.getMethodIDOf(
      _classRef, "onCallRemoved", "(Landroid/telecom/Call;)V");

  /// from: public void onCallRemoved(android.telecom.Call call)
  ///
  /// Called when a {@code Call} has been removed from this in-call session. The in-call user
  /// experience should remove any state listeners from the specified {@code Call} and
  /// immediately stop displaying any information about this {@code Call}.
  /// Subsequent invocations of \#getCalls() will no longer include this {@code Call}.
  ///@param call A newly removed {@code Call}.
  void onCallRemoved(call_.Call call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCallRemoved,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onCanAddCallChanged =
      jniAccessors.getMethodIDOf(_classRef, "onCanAddCallChanged", "(Z)V");

  /// from: public void onCanAddCallChanged(boolean canAddCall)
  ///
  /// Called when the ability to add more calls changes.  If the phone cannot
  /// support more calls then {@code canAddCall} is set to {@code false}.  If it can, then it
  /// is set to {@code true}. This can be used to control the visibility of UI to add more calls.
  ///@param canAddCall Indicates whether an additional call can be added.
  void onCanAddCallChanged(bool canAddCall) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCanAddCallChanged,
      jni.JniType.voidType,
      [canAddCall]).check();

  static final _id_onSilenceRinger =
      jniAccessors.getMethodIDOf(_classRef, "onSilenceRinger", "()V");

  /// from: public void onSilenceRinger()
  ///
  /// Called to silence the ringer if a ringing call exists.
  void onSilenceRinger() => jniAccessors.callMethodWithArgs(
      reference, _id_onSilenceRinger, jni.JniType.voidType, []).check();

  static final _id_onConnectionEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onConnectionEvent",
      "(Landroid/telecom/Call;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onConnectionEvent(android.telecom.Call call, java.lang.String event, android.os.Bundle extras)
  ///
  /// Unused; to handle connection events issued by a ConnectionService, implement the
  /// android.telecom.Call.Callback\#onConnectionEvent(Call, String, Bundle) callback.
  ///
  /// See Connection\#sendConnectionEvent(String, Bundle).
  ///@param call The call the event is associated with.
  ///@param event The event.
  ///@param extras Any associated extras.
  void onConnectionEvent(
          call_.Call call, jni.JniString event, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onConnectionEvent,
          jni.JniType.voidType,
          [call.reference, event.reference, extras.reference]).check();
}

/// from: android.telecom.InCallService$VideoCall
///
/// Used to issue commands to the Connection.VideoProvider associated with a
/// Call.
class InCallService_VideoCall extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/InCallService\$VideoCall");
  InCallService_VideoCall.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InCallService_VideoCall()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_registerCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerCallback",
      "(Landroid/telecom/InCallService\$VideoCall\$Callback;)V");

  /// from: public abstract void registerCallback(android.telecom.InCallService.VideoCall.Callback callback)
  ///
  /// Registers a callback to receive commands and state changes for video calls.
  ///@param callback The video call callback.
  void registerCallback(InCallService_VideoCall_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_registerCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerCallback",
      "(Landroid/telecom/InCallService\$VideoCall\$Callback;Landroid/os/Handler;)V");

  /// from: public abstract void registerCallback(android.telecom.InCallService.VideoCall.Callback callback, android.os.Handler handler)
  ///
  /// Registers a callback to receive commands and state changes for video calls.
  ///@param callback The video call callback.
  ///@param handler A handler which commands and status changes will be delivered to.
  void registerCallback1(InCallService_VideoCall_Callback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerCallback1,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterCallback",
      "(Landroid/telecom/InCallService\$VideoCall\$Callback;)V");

  /// from: public abstract void unregisterCallback(android.telecom.InCallService.VideoCall.Callback callback)
  ///
  /// Clears the video call callback set via \#registerCallback.
  ///@param callback The video call callback to clear.
  void unregisterCallback(InCallService_VideoCall_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_setCamera = jniAccessors.getMethodIDOf(
      _classRef, "setCamera", "(Ljava/lang/String;)V");

  /// from: public abstract void setCamera(java.lang.String cameraId)
  ///
  /// Sets the camera to be used for the outgoing video.
  ///
  /// Handled by Connection.VideoProvider\#onSetCamera(String).
  ///@param cameraId The id of the camera (use ids as reported by
  /// CameraManager\#getCameraIdList()).
  void setCamera(jni.JniString cameraId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCamera,
      jni.JniType.voidType,
      [cameraId.reference]).check();

  static final _id_setPreviewSurface = jniAccessors.getMethodIDOf(
      _classRef, "setPreviewSurface", "(Landroid/view/Surface;)V");

  /// from: public abstract void setPreviewSurface(android.view.Surface surface)
  ///
  /// Sets the surface to be used for displaying a preview of what the user's camera is
  /// currently capturing.  When video transmission is enabled, this is the video signal which
  /// is sent to the remote device.
  ///
  /// Handled by Connection.VideoProvider\#onSetPreviewSurface(Surface).
  ///@param surface The Surface.
  void setPreviewSurface(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreviewSurface,
          jni.JniType.voidType, [surface.reference]).check();

  static final _id_setDisplaySurface = jniAccessors.getMethodIDOf(
      _classRef, "setDisplaySurface", "(Landroid/view/Surface;)V");

  /// from: public abstract void setDisplaySurface(android.view.Surface surface)
  ///
  /// Sets the surface to be used for displaying the video received from the remote device.
  ///
  /// Handled by Connection.VideoProvider\#onSetDisplaySurface(Surface).
  ///@param surface The Surface.
  void setDisplaySurface(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisplaySurface,
          jni.JniType.voidType, [surface.reference]).check();

  static final _id_setDeviceOrientation =
      jniAccessors.getMethodIDOf(_classRef, "setDeviceOrientation", "(I)V");

  /// from: public abstract void setDeviceOrientation(int rotation)
  ///
  /// Sets the device orientation, in degrees.  Assumes that a standard portrait orientation of
  /// the device is 0 degrees.
  ///
  /// Handled by Connection.VideoProvider\#onSetDeviceOrientation(int).
  ///@param rotation The device orientation, in degrees.
  void setDeviceOrientation(int rotation) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDeviceOrientation,
      jni.JniType.voidType,
      [rotation]).check();

  static final _id_setZoom =
      jniAccessors.getMethodIDOf(_classRef, "setZoom", "(F)V");

  /// from: public abstract void setZoom(float value)
  ///
  /// Sets camera zoom ratio.
  ///
  /// Handled by Connection.VideoProvider\#onSetZoom(float).
  ///@param value The camera zoom ratio.
  void setZoom(double value) => jniAccessors.callMethodWithArgs(
      reference, _id_setZoom, jni.JniType.voidType, [value]).check();

  static final _id_sendSessionModifyRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "sendSessionModifyRequest",
      "(Landroid/telecom/VideoProfile;)V");

  /// from: public abstract void sendSessionModifyRequest(android.telecom.VideoProfile requestProfile)
  ///
  /// Issues a request to modify the properties of the current video session.
  ///
  /// Example scenarios include: requesting an audio-only call to be upgraded to a
  /// bi-directional video call, turning on or off the user's camera, sending a pause signal
  /// when the InCallService is no longer the foreground application.
  ///
  /// Handled by
  /// Connection.VideoProvider\#onSendSessionModifyRequest(VideoProfile, VideoProfile).
  ///@param requestProfile The requested call video properties.
  void sendSessionModifyRequest(videoprofile_.VideoProfile requestProfile) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendSessionModifyRequest,
          jni.JniType.voidType, [requestProfile.reference]).check();

  static final _id_sendSessionModifyResponse = jniAccessors.getMethodIDOf(
      _classRef,
      "sendSessionModifyResponse",
      "(Landroid/telecom/VideoProfile;)V");

  /// from: public abstract void sendSessionModifyResponse(android.telecom.VideoProfile responseProfile)
  ///
  /// Provides a response to a request to change the current call video session
  /// properties.  This should be called in response to a request the InCallService has
  /// received via VideoCall.Callback\#onSessionModifyRequestReceived.
  ///
  /// Handled by
  /// Connection.VideoProvider\#onSendSessionModifyResponse(VideoProfile).
  ///@param responseProfile The response call video properties.
  void sendSessionModifyResponse(videoprofile_.VideoProfile responseProfile) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendSessionModifyResponse,
          jni.JniType.voidType, [responseProfile.reference]).check();

  static final _id_requestCameraCapabilities =
      jniAccessors.getMethodIDOf(_classRef, "requestCameraCapabilities", "()V");

  /// from: public abstract void requestCameraCapabilities()
  ///
  /// Issues a request to the Connection.VideoProvider to retrieve the capabilities
  /// of the current camera.  The current camera is selected using
  /// VideoCall\#setCamera(String).
  ///
  /// Camera capabilities are reported to the caller via
  /// VideoCall.Callback\#onCameraCapabilitiesChanged(VideoProfile.CameraCapabilities).
  ///
  /// Handled by Connection.VideoProvider\#onRequestCameraCapabilities().
  void requestCameraCapabilities() => jniAccessors.callMethodWithArgs(reference,
      _id_requestCameraCapabilities, jni.JniType.voidType, []).check();

  static final _id_requestCallDataUsage =
      jniAccessors.getMethodIDOf(_classRef, "requestCallDataUsage", "()V");

  /// from: public abstract void requestCallDataUsage()
  ///
  /// Issues a request to the Connection.VideoProvider to retrieve the cumulative data
  /// usage for the video component of the current call (in bytes).  Data usage is reported
  /// to the caller via VideoCall.Callback\#onCallDataUsageChanged.
  ///
  /// Handled by Connection.VideoProvider\#onRequestConnectionDataUsage().
  void requestCallDataUsage() => jniAccessors.callMethodWithArgs(
      reference, _id_requestCallDataUsage, jni.JniType.voidType, []).check();

  static final _id_setPauseImage = jniAccessors.getMethodIDOf(
      _classRef, "setPauseImage", "(Landroid/net/Uri;)V");

  /// from: public abstract void setPauseImage(android.net.Uri uri)
  ///
  /// Provides the Connection.VideoProvider with the Uri of an image to be
  /// displayed to the peer device when the video signal is paused.
  ///
  /// Handled by Connection.VideoProvider\#onSetPauseImage(Uri).
  ///@param uri URI of image to display.
  void setPauseImage(uri_.Uri uri) => jniAccessors.callMethodWithArgs(reference,
      _id_setPauseImage, jni.JniType.voidType, [uri.reference]).check();
}

/// from: android.telecom.InCallService$VideoCall$Callback
///
/// The InCallService extends this class to provide a means of receiving callbacks
/// from the Connection.VideoProvider.
///
/// When the InCallService receives the
/// Call.Callback\#onVideoCallChanged(Call, VideoCall) callback, it should create an
/// instance its VideoCall.Callback implementation and set it on the
/// VideoCall using VideoCall\#registerCallback(Callback).
class InCallService_VideoCall_Callback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/telecom/InCallService\$VideoCall\$Callback");
  InCallService_VideoCall_Callback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InCallService_VideoCall_Callback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onSessionModifyRequestReceived = jniAccessors.getMethodIDOf(
      _classRef,
      "onSessionModifyRequestReceived",
      "(Landroid/telecom/VideoProfile;)V");

  /// from: public abstract void onSessionModifyRequestReceived(android.telecom.VideoProfile videoProfile)
  ///
  /// Called when the Connection.VideoProvider receives a session modification
  /// request from the peer device.
  ///
  /// The InCallService may potentially prompt the user to confirm whether they
  /// wish to accept the request, or decide to automatically accept the request.  In either
  /// case the InCallService should call
  /// VideoCall\#sendSessionModifyResponse(VideoProfile) to indicate the video
  /// profile agreed upon.
  ///
  /// Callback originates from
  /// Connection.VideoProvider\#receiveSessionModifyRequest(VideoProfile).
  ///@param videoProfile The requested video profile.
  void onSessionModifyRequestReceived(
          videoprofile_.VideoProfile videoProfile) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSessionModifyRequestReceived,
          jni.JniType.voidType,
          [videoProfile.reference]).check();

  static final _id_onSessionModifyResponseReceived = jniAccessors.getMethodIDOf(
      _classRef,
      "onSessionModifyResponseReceived",
      "(ILandroid/telecom/VideoProfile;Landroid/telecom/VideoProfile;)V");

  /// from: public abstract void onSessionModifyResponseReceived(int status, android.telecom.VideoProfile requestedProfile, android.telecom.VideoProfile responseProfile)
  ///
  /// Called when the Connection.VideoProvider receives a response to a session
  /// modification request previously sent to the peer device.
  ///
  /// The new video state should not be considered active by the InCallService
  /// until the Call video state changes (the
  /// Call.Callback\#onDetailsChanged(Call, Call.Details) callback is triggered
  /// when the video state changes).
  ///
  /// Callback originates from
  /// Connection.VideoProvider\#receiveSessionModifyResponse(int, VideoProfile,
  ///      VideoProfile).
  ///@param status Status of the session modify request.  Valid values are
  ///      Connection.VideoProvider\#SESSION_MODIFY_REQUEST_SUCCESS,
  ///      Connection.VideoProvider\#SESSION_MODIFY_REQUEST_FAIL,
  ///      Connection.VideoProvider\#SESSION_MODIFY_REQUEST_INVALID,
  ///      Connection.VideoProvider\#SESSION_MODIFY_REQUEST_TIMED_OUT,
  ///      Connection.VideoProvider\#SESSION_MODIFY_REQUEST_REJECTED_BY_REMOTE.
  ///@param requestedProfile The original request which was sent to the peer device.
  ///@param responseProfile The actual profile changes made by the peer device.
  void onSessionModifyResponseReceived(
          int status,
          videoprofile_.VideoProfile requestedProfile,
          videoprofile_.VideoProfile responseProfile) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_onSessionModifyResponseReceived, jni.JniType.voidType, [
        status,
        requestedProfile.reference,
        responseProfile.reference
      ]).check();

  static final _id_onCallSessionEvent =
      jniAccessors.getMethodIDOf(_classRef, "onCallSessionEvent", "(I)V");

  /// from: public abstract void onCallSessionEvent(int event)
  ///
  /// Handles events related to the current video session which the InCallService
  /// may wish to handle. These are separate from requested changes to the session due to
  /// the underlying protocol or connection.
  ///
  /// Callback originates from
  /// Connection.VideoProvider\#handleCallSessionEvent(int).
  ///@param event The event.  Valid values are:
  ///      Connection.VideoProvider\#SESSION_EVENT_RX_PAUSE,
  ///      Connection.VideoProvider\#SESSION_EVENT_RX_RESUME,
  ///      Connection.VideoProvider\#SESSION_EVENT_TX_START,
  ///      Connection.VideoProvider\#SESSION_EVENT_TX_STOP,
  ///      Connection.VideoProvider\#SESSION_EVENT_CAMERA_FAILURE,
  ///      Connection.VideoProvider\#SESSION_EVENT_CAMERA_READY,
  ///      Connection.VideoProvider\#SESSION_EVENT_CAMERA_PERMISSION_ERROR.
  void onCallSessionEvent(int event) => jniAccessors.callMethodWithArgs(
      reference, _id_onCallSessionEvent, jni.JniType.voidType, [event]).check();

  static final _id_onPeerDimensionsChanged =
      jniAccessors.getMethodIDOf(_classRef, "onPeerDimensionsChanged", "(II)V");

  /// from: public abstract void onPeerDimensionsChanged(int width, int height)
  ///
  /// Handles a change to the video dimensions from the peer device. This could happen if,
  /// for example, the peer changes orientation of their device, or switches cameras.
  ///
  /// Callback originates from
  /// Connection.VideoProvider\#changePeerDimensions(int, int).
  ///@param width The updated peer video width.
  ///@param height The updated peer video height.
  void onPeerDimensionsChanged(int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPeerDimensionsChanged,
          jni.JniType.voidType, [width, height]).check();

  static final _id_onVideoQualityChanged =
      jniAccessors.getMethodIDOf(_classRef, "onVideoQualityChanged", "(I)V");

  /// from: public abstract void onVideoQualityChanged(int videoQuality)
  ///
  /// Handles a change to the video quality.
  ///
  /// Callback originates from Connection.VideoProvider\#changeVideoQuality(int).
  ///@param videoQuality The updated peer video quality.  Valid values:
  ///      VideoProfile\#QUALITY_HIGH,
  ///      VideoProfile\#QUALITY_MEDIUM,
  ///      VideoProfile\#QUALITY_LOW,
  ///      VideoProfile\#QUALITY_DEFAULT.
  void onVideoQualityChanged(int videoQuality) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVideoQualityChanged,
          jni.JniType.voidType, [videoQuality]).check();

  static final _id_onCallDataUsageChanged =
      jniAccessors.getMethodIDOf(_classRef, "onCallDataUsageChanged", "(J)V");

  /// from: public abstract void onCallDataUsageChanged(long dataUsage)
  ///
  /// Handles an update to the total data used for the current video session.
  ///
  /// Used by the Connection.VideoProvider in response to
  /// VideoCall\#requestCallDataUsage().  May also be called periodically by the
  /// Connection.VideoProvider.
  ///
  /// Callback originates from Connection.VideoProvider\#setCallDataUsage(long).
  ///@param dataUsage The updated data usage (in bytes).
  void onCallDataUsageChanged(int dataUsage) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCallDataUsageChanged,
      jni.JniType.voidType,
      [dataUsage]).check();

  static final _id_onCameraCapabilitiesChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onCameraCapabilitiesChanged",
      "(Landroid/telecom/VideoProfile\$CameraCapabilities;)V");

  /// from: public abstract void onCameraCapabilitiesChanged(android.telecom.VideoProfile.CameraCapabilities cameraCapabilities)
  ///
  /// Handles a change in the capabilities of the currently selected camera.
  ///
  /// Used by the Connection.VideoProvider in response to
  /// VideoCall\#requestCameraCapabilities().  The Connection.VideoProvider
  /// may also report the camera capabilities after a call to
  /// VideoCall\#setCamera(String).
  ///
  /// Callback originates from
  /// Connection.VideoProvider\#changeCameraCapabilities(
  ///      VideoProfile.CameraCapabilities).
  ///@param cameraCapabilities The changed camera capabilities.
  void onCameraCapabilitiesChanged(
          videoprofile_.VideoProfile_CameraCapabilities cameraCapabilities) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCameraCapabilitiesChanged,
          jni.JniType.voidType,
          [cameraCapabilities.reference]).check();
}
