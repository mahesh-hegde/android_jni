// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../net/Uri.dart" as uri_;

import "PhoneAccountHandle.dart" as phoneaccounthandle_;

import "../os/Bundle.dart" as bundle_;

import "InCallService.dart" as incallservice_;

import "../os/Handler.dart" as handler_;

import "DisconnectCause.dart" as disconnectcause_;

import "GatewayInfo.dart" as gatewayinfo_;

import "StatusHints.dart" as statushints_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telecom.Call
///
/// Represents an ongoing phone call that the in-call app should present to the user.
class Call extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/telecom/Call");
  Call.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String AVAILABLE_PHONE_ACCOUNTS
  ///
  /// The key to retrieve the optional {@code PhoneAccount}s Telecom can bundle with its Call
  /// extras. Used to pass the phone accounts to display on the front end to the user in order to
  /// select phone accounts to (for example) place a call.
  static const AVAILABLE_PHONE_ACCOUNTS = "selectPhoneAccountAccounts";

  /// from: static public final java.lang.String EXTRA_LAST_EMERGENCY_CALLBACK_TIME_MILLIS
  ///
  /// Extra key used to indicate the time (in milliseconds since midnight, January 1, 1970 UTC)
  /// when the last outgoing emergency call was made.  This is used to identify potential emergency
  /// callbacks.
  static const EXTRA_LAST_EMERGENCY_CALLBACK_TIME_MILLIS =
      "android.telecom.extra.LAST_EMERGENCY_CALLBACK_TIME_MILLIS";

  /// from: static public final int STATE_ACTIVE
  ///
  /// The state of a {@code Call} when actively supporting conversation.
  static const STATE_ACTIVE = 4;

  /// from: static public final int STATE_CONNECTING
  ///
  /// The initial state of an outgoing {@code Call}.
  /// Common transitions are to \#STATE_DIALING state for a successful call or
  /// \#STATE_DISCONNECTED if it failed.
  static const STATE_CONNECTING = 9;

  /// from: static public final int STATE_DIALING
  ///
  /// The state of an outgoing {@code Call} when dialing the remote number, but not yet connected.
  static const STATE_DIALING = 1;

  /// from: static public final int STATE_DISCONNECTED
  ///
  /// The state of a {@code Call} when no further voice or other communication is being
  /// transmitted, the remote side has been or will inevitably be informed that the {@code Call}
  /// is no longer active, and the local data transport has or inevitably will release resources
  /// associated with this {@code Call}.
  static const STATE_DISCONNECTED = 7;

  /// from: static public final int STATE_DISCONNECTING
  ///
  /// The state of a {@code Call} when the user has initiated a disconnection of the call, but the
  /// call has not yet been disconnected by the underlying {@code ConnectionService}.  The next
  /// state of the call is (potentially) \#STATE_DISCONNECTED.
  static const STATE_DISCONNECTING = 10;

  /// from: static public final int STATE_HOLDING
  ///
  /// The state of a {@code Call} when in a holding state.
  static const STATE_HOLDING = 3;

  /// from: static public final int STATE_NEW
  ///
  /// The state of a {@code Call} when newly created.
  static const STATE_NEW = 0;

  /// from: static public final int STATE_PULLING_CALL
  ///
  /// The state of an external call which is in the process of being pulled from a remote device to
  /// the local device.
  ///
  /// A call can only be in this state if the Details\#PROPERTY_IS_EXTERNAL_CALL property
  /// and Details\#CAPABILITY_CAN_PULL_CALL capability are set on the call.
  ///
  /// An InCallService will only see this state if it has the
  /// TelecomManager\#METADATA_INCLUDE_EXTERNAL_CALLS metadata set to {@code true} in its
  /// manifest.
  static const STATE_PULLING_CALL = 11;

  /// from: static public final int STATE_RINGING
  ///
  /// The state of an incoming {@code Call} when ringing locally, but not yet connected.
  static const STATE_RINGING = 2;

  /// from: static public final int STATE_SELECT_PHONE_ACCOUNT
  ///
  /// The state of an outgoing {@code Call} when waiting on user to select a
  /// PhoneAccount through which to place the call.
  static const STATE_SELECT_PHONE_ACCOUNT = 8;

  static final _id_getRemainingPostDialSequence = jniAccessors.getMethodIDOf(
      _classRef, "getRemainingPostDialSequence", "()Ljava/lang/String;");

  /// from: public java.lang.String getRemainingPostDialSequence()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains the post-dial sequence remaining to be emitted by this {@code Call}, if any.
  ///@return The remaining post-dial sequence, or {@code null} if there is no post-dial sequence
  /// remaining or this {@code Call} is not in a post-dial state.
  jni.JniString getRemainingPostDialSequence() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRemainingPostDialSequence, jni.JniType.objectType, []).object);

  static final _id_answer =
      jniAccessors.getMethodIDOf(_classRef, "answer", "(I)V");

  /// from: public void answer(int videoState)
  ///
  /// Instructs this \#STATE_RINGING {@code Call} to answer.
  ///@param videoState The video state in which to answer the call.
  ///
  /// Value is either <code>0</code> or a combination of android.telecom.VideoProfile\#STATE_AUDIO_ONLY, android.telecom.VideoProfile\#STATE_TX_ENABLED, android.telecom.VideoProfile\#STATE_RX_ENABLED, android.telecom.VideoProfile\#STATE_BIDIRECTIONAL, and android.telecom.VideoProfile\#STATE_PAUSED
  void answer(int videoState) => jniAccessors.callMethodWithArgs(
      reference, _id_answer, jni.JniType.voidType, [videoState]).check();

  static final _id_deflect =
      jniAccessors.getMethodIDOf(_classRef, "deflect", "(Landroid/net/Uri;)V");

  /// from: public void deflect(android.net.Uri address)
  ///
  /// Instructs this \#STATE_RINGING {@code Call} to deflect.
  ///@param address The address to which the call will be deflected.
  void deflect(uri_.Uri address) => jniAccessors.callMethodWithArgs(reference,
      _id_deflect, jni.JniType.voidType, [address.reference]).check();

  static final _id_reject =
      jniAccessors.getMethodIDOf(_classRef, "reject", "(ZLjava/lang/String;)V");

  /// from: public void reject(boolean rejectWithMessage, java.lang.String textMessage)
  ///
  /// Instructs this \#STATE_RINGING {@code Call} to reject.
  ///@param rejectWithMessage Whether to reject with a text message.
  ///@param textMessage An optional text message with which to respond.
  void reject(bool rejectWithMessage, jni.JniString textMessage) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_reject,
          jni.JniType.voidType,
          [rejectWithMessage, textMessage.reference]).check();

  static final _id_disconnect =
      jniAccessors.getMethodIDOf(_classRef, "disconnect", "()V");

  /// from: public void disconnect()
  ///
  /// Instructs this {@code Call} to disconnect.
  void disconnect() => jniAccessors.callMethodWithArgs(
      reference, _id_disconnect, jni.JniType.voidType, []).check();

  static final _id_hold = jniAccessors.getMethodIDOf(_classRef, "hold", "()V");

  /// from: public void hold()
  ///
  /// Instructs this {@code Call} to go on hold.
  void hold() => jniAccessors.callMethodWithArgs(
      reference, _id_hold, jni.JniType.voidType, []).check();

  static final _id_unhold =
      jniAccessors.getMethodIDOf(_classRef, "unhold", "()V");

  /// from: public void unhold()
  ///
  /// Instructs this \#STATE_HOLDING call to release from hold.
  void unhold() => jniAccessors.callMethodWithArgs(
      reference, _id_unhold, jni.JniType.voidType, []).check();

  static final _id_playDtmfTone =
      jniAccessors.getMethodIDOf(_classRef, "playDtmfTone", "(C)V");

  /// from: public void playDtmfTone(char digit)
  ///
  /// Instructs this {@code Call} to play a dual-tone multi-frequency signaling (DTMF) tone.
  ///
  /// Any other currently playing DTMF tone in the specified call is immediately stopped.
  ///@param digit A character representing the DTMF digit for which to play the tone. This
  ///         value must be one of {@code '0'} through {@code '9'}, {@code '*'} or {@code '\#'}.
  void playDtmfTone(int digit) => jniAccessors.callMethodWithArgs(
      reference, _id_playDtmfTone, jni.JniType.voidType, [digit]).check();

  static final _id_stopDtmfTone =
      jniAccessors.getMethodIDOf(_classRef, "stopDtmfTone", "()V");

  /// from: public void stopDtmfTone()
  ///
  /// Instructs this {@code Call} to stop any dual-tone multi-frequency signaling (DTMF) tone
  /// currently playing.
  ///
  /// DTMF tones are played by calling \#playDtmfTone(char). If no DTMF tone is
  /// currently playing, this method will do nothing.
  void stopDtmfTone() => jniAccessors.callMethodWithArgs(
      reference, _id_stopDtmfTone, jni.JniType.voidType, []).check();

  static final _id_postDialContinue =
      jniAccessors.getMethodIDOf(_classRef, "postDialContinue", "(Z)V");

  /// from: public void postDialContinue(boolean proceed)
  ///
  /// Instructs this {@code Call} to continue playing a post-dial DTMF string.
  ///
  /// A post-dial DTMF string is a string of digits entered after a phone number, when dialed,
  /// that are immediately sent as DTMF tones to the recipient as soon as the connection is made.
  ///
  /// If the DTMF string contains a TelecomManager\#DTMF_CHARACTER_PAUSE symbol, this
  /// {@code Call} will temporarily pause playing the tones for a pre-defined period of time.
  ///
  /// If the DTMF string contains a TelecomManager\#DTMF_CHARACTER_WAIT symbol, this
  /// {@code Call} will pause playing the tones and notify callbacks via
  /// Callback\#onPostDialWait(Call, String). At this point, the in-call app
  /// should display to the user an indication of this state and an affordance to continue
  /// the postdial sequence. When the user decides to continue the postdial sequence, the in-call
  /// app should invoke the \#postDialContinue(boolean) method.
  ///@param proceed Whether or not to continue with the post-dial sequence.
  void postDialContinue(bool proceed) => jniAccessors.callMethodWithArgs(
      reference, _id_postDialContinue, jni.JniType.voidType, [proceed]).check();

  static final _id_phoneAccountSelected = jniAccessors.getMethodIDOf(_classRef,
      "phoneAccountSelected", "(Landroid/telecom/PhoneAccountHandle;Z)V");

  /// from: public void phoneAccountSelected(android.telecom.PhoneAccountHandle accountHandle, boolean setDefault)
  ///
  /// Notifies this {@code Call} that an account has been selected and to proceed with placing
  /// an outgoing call. Optionally sets this account as the default account.
  void phoneAccountSelected(
          phoneaccounthandle_.PhoneAccountHandle accountHandle,
          bool setDefault) =>
      jniAccessors.callMethodWithArgs(reference, _id_phoneAccountSelected,
          jni.JniType.voidType, [accountHandle.reference, setDefault]).check();

  static final _id_conference = jniAccessors.getMethodIDOf(
      _classRef, "conference", "(Landroid/telecom/Call;)V");

  /// from: public void conference(android.telecom.Call callToConferenceWith)
  ///
  /// Instructs this {@code Call} to enter a conference.
  ///@param callToConferenceWith The other call with which to conference.
  void conference(Call callToConferenceWith) => jniAccessors.callMethodWithArgs(
      reference,
      _id_conference,
      jni.JniType.voidType,
      [callToConferenceWith.reference]).check();

  static final _id_splitFromConference =
      jniAccessors.getMethodIDOf(_classRef, "splitFromConference", "()V");

  /// from: public void splitFromConference()
  ///
  /// Instructs this {@code Call} to split from any conference call with which it may be
  /// connected.
  void splitFromConference() => jniAccessors.callMethodWithArgs(
      reference, _id_splitFromConference, jni.JniType.voidType, []).check();

  static final _id_mergeConference =
      jniAccessors.getMethodIDOf(_classRef, "mergeConference", "()V");

  /// from: public void mergeConference()
  ///
  /// Merges the calls within this conference. See Details\#CAPABILITY_MERGE_CONFERENCE.
  void mergeConference() => jniAccessors.callMethodWithArgs(
      reference, _id_mergeConference, jni.JniType.voidType, []).check();

  static final _id_swapConference =
      jniAccessors.getMethodIDOf(_classRef, "swapConference", "()V");

  /// from: public void swapConference()
  ///
  /// Swaps the calls within this conference. See Details\#CAPABILITY_SWAP_CONFERENCE.
  void swapConference() => jniAccessors.callMethodWithArgs(
      reference, _id_swapConference, jni.JniType.voidType, []).check();

  static final _id_pullExternalCall =
      jniAccessors.getMethodIDOf(_classRef, "pullExternalCall", "()V");

  /// from: public void pullExternalCall()
  ///
  /// Initiates a request to the ConnectionService to pull an external call to the local
  /// device.
  ///
  /// Calls to this method are ignored if the call does not have the
  /// Call.Details\#PROPERTY_IS_EXTERNAL_CALL property set.
  ///
  /// An InCallService will only see calls which support this method if it has the
  /// TelecomManager\#METADATA_INCLUDE_EXTERNAL_CALLS metadata set to {@code true}
  /// in its manifest.
  void pullExternalCall() => jniAccessors.callMethodWithArgs(
      reference, _id_pullExternalCall, jni.JniType.voidType, []).check();

  static final _id_sendCallEvent = jniAccessors.getMethodIDOf(
      _classRef, "sendCallEvent", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void sendCallEvent(java.lang.String event, android.os.Bundle extras)
  ///
  /// Sends a {@code Call} event from this {@code Call} to the associated Connection in
  /// the ConnectionService.
  ///
  /// Call events are used to communicate point in time information from an InCallService
  /// to a ConnectionService.  A ConnectionService implementation could define
  /// events which enable the InCallService, for example, toggle a unique feature of the
  /// ConnectionService.
  ///
  /// A ConnectionService can communicate to the InCallService using
  /// Connection\#sendConnectionEvent(String, Bundle).
  ///
  /// Events are exposed to ConnectionService implementations via
  /// android.telecom.Connection\#onCallEvent(String, Bundle).
  ///
  /// No assumptions should be made as to how a ConnectionService will handle these events.
  /// The InCallService must assume that the ConnectionService could chose to
  /// ignore some events altogether.
  ///
  /// Events should be fully qualified (e.g., {@code com.example.event.MY_EVENT}) to avoid
  /// conflicts between InCallService implementations.  Further, InCallService
  /// implementations shall not re-purpose events in the {@code android.*} namespace, nor shall
  /// they define their own event types in this namespace.  When defining a custom event type,
  /// ensure the contents of the extras Bundle is clearly defined.  Extra keys for this
  /// bundle should be named similar to the event type (e.g. {@code com.example.extra.MY_EXTRA}).
  ///
  /// When defining events and the associated extras, it is important to keep their behavior
  /// consistent when the associated InCallService is updated.  Support for deprecated
  /// events/extras should me maintained to ensure backwards compatibility with older
  /// ConnectionService implementations which were built to support the older behavior.
  ///@param event The connection event.
  ///@param extras Bundle containing extra information associated with the event.
  void sendCallEvent(jni.JniString event, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendCallEvent,
          jni.JniType.voidType, [event.reference, extras.reference]).check();

  static final _id_sendRttRequest =
      jniAccessors.getMethodIDOf(_classRef, "sendRttRequest", "()V");

  /// from: public void sendRttRequest()
  ///
  /// Sends an RTT upgrade request to the remote end of the connection. Success is not
  /// guaranteed, and notification of success will be via the
  /// Callback\#onRttStatusChanged(Call, boolean, RttCall) callback.
  void sendRttRequest() => jniAccessors.callMethodWithArgs(
      reference, _id_sendRttRequest, jni.JniType.voidType, []).check();

  static final _id_respondToRttRequest =
      jniAccessors.getMethodIDOf(_classRef, "respondToRttRequest", "(IZ)V");

  /// from: public void respondToRttRequest(int id, boolean accept)
  ///
  /// Responds to an RTT request received via the Callback\#onRttRequest(Call, int) )}
  /// callback.
  /// The ID used here should be the same as the ID that was received via the callback.
  ///@param id The request ID received via Callback\#onRttRequest(Call, int)
  ///@param accept {@code true} if the RTT request should be accepted, {@code false} otherwise.
  void respondToRttRequest(int id, bool accept) =>
      jniAccessors.callMethodWithArgs(reference, _id_respondToRttRequest,
          jni.JniType.voidType, [id, accept]).check();

  static final _id_handoverTo = jniAccessors.getMethodIDOf(
      _classRef,
      "handoverTo",
      "(Landroid/telecom/PhoneAccountHandle;ILandroid/os/Bundle;)V");

  /// from: public void handoverTo(android.telecom.PhoneAccountHandle toHandle, int videoState, android.os.Bundle extras)
  ///
  /// Initiates a handover of this Call to the ConnectionService identified
  /// by {@code toHandle}.  The videoState specified indicates the desired video state after the
  /// handover.
  ///
  /// A call handover is the process where an ongoing call is transferred from one app (i.e.
  /// ConnectionService to another app.  The user could, for example, choose to continue a
  /// mobile network call in a video calling app.  The mobile network call via the Telephony stack
  /// is referred to as the source of the handover, and the video calling app is referred to as the
  /// destination.
  ///
  /// When considering a handover scenario the device this method is called on is considered the
  /// _initiating_ device (since the user initiates the handover from this device), and the
  /// other device is considered the _receiving_ device.
  ///
  /// When this method is called on the _initiating_ device, the Telecom framework will bind
  /// to the ConnectionService defined by the {@code toHandle} PhoneAccountHandle
  /// and invoke
  /// ConnectionService\#onCreateOutgoingHandoverConnection(PhoneAccountHandle,
  /// ConnectionRequest) to inform the destination app that a request has been made to handover a
  /// call to it.  The app returns an instance of Connection to represent the handover call
  /// At this point the app should display UI to indicate to the user that a call
  /// handover is in process.
  ///
  /// The destination app is responsible for communicating the handover request from the
  /// _initiating_ device to the _receiving_ device.
  ///
  /// When the app on the _receiving_ device receives the handover request, it calls
  /// TelecomManager\#acceptHandover(Uri, int, PhoneAccountHandle) to continue the handover
  /// process from the _initiating_ device to the _receiving_ device.  At this point
  /// the destination app on the _receiving_ device should show UI to allow the user to
  /// choose whether they want to continue their call in the destination app.
  ///
  /// When the destination app on the _receiving_ device calls
  /// TelecomManager\#acceptHandover(Uri, int, PhoneAccountHandle), Telecom will bind to its
  /// ConnectionService and call
  /// ConnectionService\#onCreateIncomingHandoverConnection(PhoneAccountHandle,
  /// ConnectionRequest) to inform it of the handover request.  The app returns an instance of
  /// Connection to represent the handover call.
  ///
  /// If the user of the _receiving_ device accepts the handover, the app calls
  /// Connection\#setActive() to complete the handover process; Telecom will disconnect the
  /// original call.  If the user rejects the handover, the app calls
  /// Connection\#setDisconnected(DisconnectCause) and specifies a DisconnectCause
  /// of DisconnectCause\#CANCELED to indicate that the handover has been cancelled.
  ///
  /// Telecom will only allow handovers from PhoneAccounts which declare
  /// PhoneAccount\#EXTRA_SUPPORTS_HANDOVER_FROM.  Similarly, the PhoneAccount
  /// specified by {@code toHandle} must declare PhoneAccount\#EXTRA_SUPPORTS_HANDOVER_TO.
  ///
  /// Errors in the handover process are reported to the InCallService via
  /// Callback\#onHandoverFailed(Call, int).  Errors in the handover process are reported to
  /// the involved ConnectionServices via
  /// ConnectionService\#onHandoverFailed(ConnectionRequest, int).
  ///@param toHandle PhoneAccountHandle of the ConnectionService to handover
  ///                 this call to.
  ///@param videoState Indicates the video state desired after the handover (see the
  ///               {@code STATE_*} constants defined in VideoProfile).
  /// Value is either <code>0</code> or a combination of android.telecom.VideoProfile\#STATE_AUDIO_ONLY, android.telecom.VideoProfile\#STATE_TX_ENABLED, android.telecom.VideoProfile\#STATE_RX_ENABLED, android.telecom.VideoProfile\#STATE_BIDIRECTIONAL, and android.telecom.VideoProfile\#STATE_PAUSED
  ///@param extras Bundle containing extra information to be passed to the
  ///               ConnectionService
  void handoverTo(phoneaccounthandle_.PhoneAccountHandle toHandle,
          int videoState, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_handoverTo,
          jni.JniType.voidType,
          [toHandle.reference, videoState, extras.reference]).check();

  static final _id_stopRtt =
      jniAccessors.getMethodIDOf(_classRef, "stopRtt", "()V");

  /// from: public void stopRtt()
  ///
  /// Terminate the RTT session on this call. The resulting state change will be notified via
  /// the Callback\#onRttStatusChanged(Call, boolean, RttCall) callback.
  void stopRtt() => jniAccessors.callMethodWithArgs(
      reference, _id_stopRtt, jni.JniType.voidType, []).check();

  static final _id_putExtras = jniAccessors.getMethodIDOf(
      _classRef, "putExtras", "(Landroid/os/Bundle;)V");

  /// from: public void putExtras(android.os.Bundle extras)
  ///
  /// Adds some extras to this Call.  Existing keys are replaced and new ones are
  /// added.
  ///
  /// No assumptions should be made as to how an In-Call UI or service will handle these
  /// extras.  Keys should be fully qualified (e.g., com.example.MY_EXTRA) to avoid conflicts.
  ///@param extras The extras to add.
  void putExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_putExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_removeExtras = jniAccessors.getMethodIDOf(
      _classRef, "removeExtras", "(Ljava/util/List;)V");

  /// from: public void removeExtras(java.util.List<java.lang.String> keys)
  ///
  /// Removes extras from this Call.
  ///@param keys The keys of the extras to remove.
  void removeExtras(jni.JniObject keys) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeExtras,
      jni.JniType.voidType,
      [keys.reference]).check();

  static final _id_removeExtras1 = jniAccessors.getMethodIDOf(
      _classRef, "removeExtras", "([Ljava/lang/String;)V");

  /// from: public void removeExtras(java.lang.String[] keys)
  ///
  /// Removes extras from this Call.
  ///@param keys The keys of the extras to remove.
  void removeExtras1(jni.JniObject keys) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeExtras1,
      jni.JniType.voidType,
      [keys.reference]).check();

  static final _id_getParent = jniAccessors.getMethodIDOf(
      _classRef, "getParent", "()Landroid/telecom/Call;");

  /// from: public android.telecom.Call getParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains the parent of this {@code Call} in a conference, if any.
  ///@return The parent {@code Call}, or {@code null} if this {@code Call} is not a
  /// child of any conference {@code Call}s.
  Call getParent() => Call.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getParent, jni.JniType.objectType, []).object);

  static final _id_getChildren = jniAccessors.getMethodIDOf(
      _classRef, "getChildren", "()Ljava/util/List;");

  /// from: public java.util.List<android.telecom.Call> getChildren()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains the children of this conference {@code Call}, if any.
  ///@return The children of this {@code Call} if this {@code Call} is a conference, or an empty
  /// {@code List} otherwise.
  jni.JniObject getChildren() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChildren, jni.JniType.objectType, []).object);

  static final _id_getConferenceableCalls = jniAccessors.getMethodIDOf(
      _classRef, "getConferenceableCalls", "()Ljava/util/List;");

  /// from: public java.util.List<android.telecom.Call> getConferenceableCalls()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of {@code Call}s with which this {@code Call} is allowed to conference.
  ///@return The list of conferenceable {@code Call}s.
  jni.JniObject getConferenceableCalls() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConferenceableCalls, jni.JniType.objectType, []).object);

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public int getState()
  ///
  /// Obtains the state of this {@code Call}.
  ///@return A state value, chosen from the {@code STATE_*} constants.
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_getCannedTextResponses = jniAccessors.getMethodIDOf(
      _classRef, "getCannedTextResponses", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getCannedTextResponses()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a list of canned, pre-configured message responses to present to the user as
  /// ways of rejecting this {@code Call} using via a text message.
  ///@see \#reject(boolean, String)
  ///@return A list of canned text message responses.
  jni.JniObject getCannedTextResponses() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCannedTextResponses, jni.JniType.objectType, []).object);

  static final _id_getVideoCall = jniAccessors.getMethodIDOf(_classRef,
      "getVideoCall", "()Landroid/telecom/InCallService\$VideoCall;");

  /// from: public android.telecom.InCallService.VideoCall getVideoCall()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains an object that can be used to display video from this {@code Call}.
  ///@return An {@code Call.VideoCall}.
  incallservice_.InCallService_VideoCall getVideoCall() =>
      incallservice_.InCallService_VideoCall.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getVideoCall, jni.JniType.objectType, []).object);

  static final _id_getDetails = jniAccessors.getMethodIDOf(
      _classRef, "getDetails", "()Landroid/telecom/Call\$Details;");

  /// from: public android.telecom.Call.Details getDetails()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains an object containing call details.
  ///@return A Details object. Depending on the state of the {@code Call}, the
  /// result may be {@code null}.
  Call_Details getDetails() =>
      Call_Details.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDetails, jni.JniType.objectType, []).object);

  static final _id_getRttCall = jniAccessors.getMethodIDOf(
      _classRef, "getRttCall", "()Landroid/telecom/Call\$RttCall;");

  /// from: public android.telecom.Call.RttCall getRttCall()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns this call's RttCall object. The RttCall instance is used to send and
  /// receive RTT text data, as well as to change the RTT mode.
  ///@return A Call.RttCall. {@code null} if there is no active RTT connection.
  Call_RttCall getRttCall() =>
      Call_RttCall.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRttCall, jni.JniType.objectType, []).object);

  static final _id_isRttActive =
      jniAccessors.getMethodIDOf(_classRef, "isRttActive", "()Z");

  /// from: public boolean isRttActive()
  ///
  /// Returns whether this call has an active RTT connection.
  ///@return true if there is a connection, false otherwise.
  bool isRttActive() => jniAccessors.callMethodWithArgs(
      reference, _id_isRttActive, jni.JniType.booleanType, []).boolean;

  static final _id_registerCallback = jniAccessors.getMethodIDOf(
      _classRef, "registerCallback", "(Landroid/telecom/Call\$Callback;)V");

  /// from: public void registerCallback(android.telecom.Call.Callback callback)
  ///
  /// Registers a callback to this {@code Call}.
  ///@param callback A {@code Callback}.
  void registerCallback(Call_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_registerCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerCallback",
      "(Landroid/telecom/Call\$Callback;Landroid/os/Handler;)V");

  /// from: public void registerCallback(android.telecom.Call.Callback callback, android.os.Handler handler)
  ///
  /// Registers a callback to this {@code Call}.
  ///@param callback A {@code Callback}.
  ///@param handler A handler which command and status changes will be delivered to.
  void registerCallback1(Call_Callback callback, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerCallback1,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterCallback = jniAccessors.getMethodIDOf(
      _classRef, "unregisterCallback", "(Landroid/telecom/Call\$Callback;)V");

  /// from: public void unregisterCallback(android.telecom.Call.Callback callback)
  ///
  /// Unregisters a callback from this {@code Call}.
  ///@param callback A {@code Callback}.
  void unregisterCallback(Call_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.telecom.Call$RttCall
///
/// A class that holds the state that describes the state of the RTT channel to the remote
/// party, if it is active.
class Call_RttCall extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/Call\$RttCall");
  Call_RttCall.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int RTT_MODE_FULL
  ///
  /// Indicates that there should be a bidirectional audio stream between the two parties
  /// on the call.
  static const RTT_MODE_FULL = 1;

  /// from: static public final int RTT_MODE_HCO
  ///
  /// Indicates that the local user should be able to hear the audio stream from the remote
  /// user, but not vice versa. Equivalent to muting the microphone.
  static const RTT_MODE_HCO = 2;

  /// from: static public final int RTT_MODE_VCO
  ///
  /// Indicates that the remote user should be able to hear the audio stream from the local
  /// user, but not vice versa. Equivalent to setting the volume to zero.
  static const RTT_MODE_VCO = 3;

  static final _id_getRttAudioMode =
      jniAccessors.getMethodIDOf(_classRef, "getRttAudioMode", "()I");

  /// from: public int getRttAudioMode()
  ///
  /// Returns the current RTT audio mode.
  ///@return Current RTT audio mode. One of \#RTT_MODE_FULL, \#RTT_MODE_VCO, or
  /// \#RTT_MODE_HCO.
  int getRttAudioMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getRttAudioMode, jni.JniType.intType, []).integer;

  static final _id_setRttMode =
      jniAccessors.getMethodIDOf(_classRef, "setRttMode", "(I)V");

  /// from: public void setRttMode(int mode)
  ///
  /// Sets the RTT audio mode. The requested mode change will be communicated through
  /// Callback\#onRttModeChanged(Call, int).
  ///@param mode The desired RTT audio mode, one of \#RTT_MODE_FULL,
  /// \#RTT_MODE_VCO, or \#RTT_MODE_HCO.
  ///
  /// Value is android.telecom.Call.RttCall.RTT_MODE_INVALID, android.telecom.Call.RttCall\#RTT_MODE_FULL, android.telecom.Call.RttCall\#RTT_MODE_HCO, or android.telecom.Call.RttCall\#RTT_MODE_VCO
  void setRttMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setRttMode, jni.JniType.voidType, [mode]).check();

  static final _id_write =
      jniAccessors.getMethodIDOf(_classRef, "write", "(Ljava/lang/String;)V");

  /// from: public void write(java.lang.String input)
  ///
  /// Writes the string {@param input} into the outgoing text stream for this RTT call. Since
  /// RTT transmits text in real-time, this method should be called once for each character
  /// the user enters into the device.
  ///
  /// This method is not thread-safe -- calling it from multiple threads simultaneously may
  /// lead to interleaved text.
  ///@param input The message to send to the remote user.
  void write(jni.JniString input) => jniAccessors.callMethodWithArgs(
      reference, _id_write, jni.JniType.voidType, [input.reference]).check();

  static final _id_read =
      jniAccessors.getMethodIDOf(_classRef, "read", "()Ljava/lang/String;");

  /// from: public java.lang.String read()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reads a string from the remote user, blocking if there is no data available. Returns
  /// {@code null} if the RTT conversation has been terminated and there is no further data
  /// to read.
  ///
  /// This method is not thread-safe -- calling it from multiple threads simultaneously may
  /// lead to interleaved text.
  ///@return A string containing text sent by the remote user, or {@code null} if the
  /// conversation has been terminated or if there was an error while reading.
  jni.JniString read() => jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_read, jni.JniType.objectType, []).object);

  static final _id_readImmediately = jniAccessors.getMethodIDOf(
      _classRef, "readImmediately", "()Ljava/lang/String;");

  /// from: public java.lang.String readImmediately()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Non-blocking version of \#read(). Returns {@code null} if there is nothing to
  /// be read.
  ///@return A string containing text entered by the user, or {@code null} if the user has
  /// not entered any new text yet.
  jni.JniString readImmediately() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readImmediately, jni.JniType.objectType, []).object);
}

/// from: android.telecom.Call$Details
class Call_Details extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/Call\$Details");
  Call_Details.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO
  ///
  /// When set, prevents a video {@code Call} from being downgraded to an audio-only call.
  ///
  /// Should be set when the VideoState has the VideoProfile\#STATE_TX_ENABLED or
  /// VideoProfile\#STATE_RX_ENABLED bits set to indicate that the connection cannot be
  /// downgraded from a video call back to a VideoState of
  /// VideoProfile\#STATE_AUDIO_ONLY.
  ///
  /// Intuitively, a call which can be downgraded to audio should also have local and remote
  /// video
  /// capabilities (see \#CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL and
  /// \#CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL).
  static const CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO = 4194304;

  /// from: static public final int CAPABILITY_CAN_PAUSE_VIDEO
  ///
  /// For video calls, indicates whether the outgoing video for the call can be paused using
  /// the android.telecom.VideoProfile\#STATE_PAUSED VideoState.
  static const CAPABILITY_CAN_PAUSE_VIDEO = 1048576;

  /// from: static public final int CAPABILITY_CAN_PULL_CALL
  ///
  /// When set for an external call, indicates that this {@code Call} can be pulled from a
  /// remote device to the current device.
  ///
  /// Should only be set on a {@code Call} where \#PROPERTY_IS_EXTERNAL_CALL is set.
  ///
  /// An InCallService will only see calls with this capability if it has the
  /// TelecomManager\#METADATA_INCLUDE_EXTERNAL_CALLS metadata set to {@code true}
  /// in its manifest.
  ///
  /// See Connection\#CAPABILITY_CAN_PULL_CALL and
  /// Connection\#PROPERTY_IS_EXTERNAL_CALL.
  static const CAPABILITY_CAN_PULL_CALL = 8388608;

  /// from: static public final int CAPABILITY_DISCONNECT_FROM_CONFERENCE
  ///
  /// Call is able to be individually disconnected when in a {@code Conference}.
  static const CAPABILITY_DISCONNECT_FROM_CONFERENCE = 8192;

  /// from: static public final int CAPABILITY_HOLD
  ///
  /// Call can currently be put on hold or unheld.
  static const CAPABILITY_HOLD = 1;

  /// from: static public final int CAPABILITY_MANAGE_CONFERENCE
  ///
  /// Call supports conference call management. This capability only applies to Conference
  /// calls which can have Connections as children.
  static const CAPABILITY_MANAGE_CONFERENCE = 128;

  /// from: static public final int CAPABILITY_MERGE_CONFERENCE
  ///
  /// Calls within a conference can be merged. A ConnectionService has the option to
  /// add a Conference call before the child Connections are merged. This is how
  /// CDMA-based Connections are implemented. For these unmerged Conferences, this
  /// capability allows a merge button to be shown while the conference call is in the foreground
  /// of the in-call UI.
  ///
  /// This is only intended for use by a Conference.
  static const CAPABILITY_MERGE_CONFERENCE = 4;

  /// from: static public final int CAPABILITY_MUTE
  ///
  /// Call can be muted.
  static const CAPABILITY_MUTE = 64;

  /// from: static public final int CAPABILITY_RESPOND_VIA_TEXT
  ///
  /// Call supports responding via text option.
  static const CAPABILITY_RESPOND_VIA_TEXT = 32;

  /// from: static public final int CAPABILITY_SEPARATE_FROM_CONFERENCE
  ///
  /// Call is able to be separated from its parent {@code Conference}, if any.
  static const CAPABILITY_SEPARATE_FROM_CONFERENCE = 4096;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL
  ///
  /// Local device supports bidirectional video calling.
  static const CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL = 768;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_LOCAL_RX
  ///
  /// Local device supports receiving video.
  static const CAPABILITY_SUPPORTS_VT_LOCAL_RX = 256;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_LOCAL_TX
  ///
  /// Local device supports transmitting video.
  static const CAPABILITY_SUPPORTS_VT_LOCAL_TX = 512;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL
  ///
  /// Remote device supports bidirectional video calling.
  static const CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL = 3072;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_REMOTE_RX
  ///
  /// Remote device supports receiving video.
  static const CAPABILITY_SUPPORTS_VT_REMOTE_RX = 1024;

  /// from: static public final int CAPABILITY_SUPPORTS_VT_REMOTE_TX
  ///
  /// Remote device supports transmitting video.
  static const CAPABILITY_SUPPORTS_VT_REMOTE_TX = 2048;

  /// from: static public final int CAPABILITY_SUPPORT_DEFLECT
  ///
  /// Call supports the deflect feature.
  static const CAPABILITY_SUPPORT_DEFLECT = 16777216;

  /// from: static public final int CAPABILITY_SUPPORT_HOLD
  ///
  /// Call supports the hold feature.
  static const CAPABILITY_SUPPORT_HOLD = 2;

  /// from: static public final int CAPABILITY_SWAP_CONFERENCE
  ///
  /// Calls within a conference can be swapped between foreground and background.
  /// See \#CAPABILITY_MERGE_CONFERENCE for additional information.
  ///
  /// This is only intended for use by a Conference.
  static const CAPABILITY_SWAP_CONFERENCE = 8;

  /// from: static public final int PROPERTY_CONFERENCE
  ///
  /// Whether the call is currently a conference.
  static const PROPERTY_CONFERENCE = 1;

  /// from: static public final int PROPERTY_EMERGENCY_CALLBACK_MODE
  ///
  /// Whether the call is made while the device is in emergency callback mode.
  static const PROPERTY_EMERGENCY_CALLBACK_MODE = 4;

  /// from: static public final int PROPERTY_ENTERPRISE_CALL
  ///
  /// Whether the call is associated with the work profile.
  static const PROPERTY_ENTERPRISE_CALL = 32;

  /// from: static public final int PROPERTY_GENERIC_CONFERENCE
  ///
  /// Whether the call is a generic conference, where we do not know the precise state of
  /// participants in the conference (eg. on CDMA).
  static const PROPERTY_GENERIC_CONFERENCE = 2;

  /// from: static public final int PROPERTY_HAS_CDMA_VOICE_PRIVACY
  ///
  /// Indicates that the call has CDMA Enhanced Voice Privacy enabled.
  static const PROPERTY_HAS_CDMA_VOICE_PRIVACY = 128;

  /// from: static public final int PROPERTY_HIGH_DEF_AUDIO
  ///
  /// Call is using high definition audio.
  static const PROPERTY_HIGH_DEF_AUDIO = 16;

  /// from: static public final int PROPERTY_IS_EXTERNAL_CALL
  ///
  /// When set, indicates that this {@code Call} does not actually exist locally for the
  /// ConnectionService.
  ///
  /// Consider, for example, a scenario where a user has two phones with the same phone number.
  /// When a user places a call on one device, the telephony stack can represent that call on
  /// the other device by adding it to the ConnectionService with the
  /// Connection\#PROPERTY_IS_EXTERNAL_CALL property set.
  ///
  /// An InCallService will only see calls with this property if it has the
  /// TelecomManager\#METADATA_INCLUDE_EXTERNAL_CALLS metadata set to {@code true}
  /// in its manifest.
  ///
  /// See Connection\#PROPERTY_IS_EXTERNAL_CALL.
  static const PROPERTY_IS_EXTERNAL_CALL = 64;

  /// from: static public final int PROPERTY_RTT
  ///
  /// Indicates that the call is an RTT call. Use \#getRttCall() to get the
  /// RttCall object that is used to send and receive text.
  static const PROPERTY_RTT = 1024;

  /// from: static public final int PROPERTY_SELF_MANAGED
  ///
  /// Indicates that the call is from a self-managed ConnectionService.
  ///
  /// See also Connection\#PROPERTY_SELF_MANAGED
  static const PROPERTY_SELF_MANAGED = 256;

  /// from: static public final int PROPERTY_WIFI
  ///
  /// Connection is using WIFI.
  static const PROPERTY_WIFI = 8;

  static final _id_can =
      jniAccessors.getStaticMethodIDOf(_classRef, "can", "(II)Z");

  /// from: static public boolean can(int capabilities, int capability)
  ///
  /// Whether the supplied capabilities  supports the specified capability.
  ///@param capabilities A bit field of capabilities.
  ///@param capability The capability to check capabilities for.
  ///@return Whether the specified capability is supported.
  static bool can(int capabilities, int capability) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_can,
          jni.JniType.booleanType, [capabilities, capability]).boolean;

  static final _id_can1 = jniAccessors.getMethodIDOf(_classRef, "can", "(I)Z");

  /// from: public boolean can(int capability)
  ///
  /// Whether the capabilities of this {@code Details} supports the specified capability.
  ///@param capability The capability to check capabilities for.
  ///@return Whether the specified capability is supported.
  bool can1(int capability) => jniAccessors.callMethodWithArgs(
      reference, _id_can1, jni.JniType.booleanType, [capability]).boolean;

  static final _id_capabilitiesToString = jniAccessors.getStaticMethodIDOf(
      _classRef, "capabilitiesToString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String capabilitiesToString(int capabilities)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Render a set of capability bits ({@code CAPABILITY_*}) as a human readable string.
  ///@param capabilities A capability bit field.
  ///@return A human readable string representation.
  static jni.JniString capabilitiesToString(int capabilities) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_capabilitiesToString,
          jni.JniType.objectType,
          [capabilities]).object);

  static final _id_hasProperty =
      jniAccessors.getStaticMethodIDOf(_classRef, "hasProperty", "(II)Z");

  /// from: static public boolean hasProperty(int properties, int property)
  ///
  /// Whether the supplied properties includes the specified property.
  ///@param properties A bit field of properties.
  ///@param property The property to check properties for.
  ///@return Whether the specified property is supported.
  static bool hasProperty(int properties, int property) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_hasProperty,
          jni.JniType.booleanType, [properties, property]).boolean;

  static final _id_hasProperty1 =
      jniAccessors.getMethodIDOf(_classRef, "hasProperty", "(I)Z");

  /// from: public boolean hasProperty(int property)
  ///
  /// Whether the properties of this {@code Details} includes the specified property.
  ///@param property The property to check properties for.
  ///@return Whether the specified property is supported.
  bool hasProperty1(int property) => jniAccessors.callMethodWithArgs(
      reference, _id_hasProperty1, jni.JniType.booleanType, [property]).boolean;

  static final _id_propertiesToString = jniAccessors.getStaticMethodIDOf(
      _classRef, "propertiesToString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String propertiesToString(int properties)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Render a set of property bits ({@code PROPERTY_*}) as a human readable string.
  ///@param properties A property bit field.
  ///@return A human readable string representation.
  static jni.JniString propertiesToString(int properties) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_propertiesToString, jni.JniType.objectType, [properties]).object);

  static final _id_getHandle =
      jniAccessors.getMethodIDOf(_classRef, "getHandle", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The handle (e.g., phone number) to which the {@code Call} is currently
  /// connected.
  uri_.Uri getHandle() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getHandle, jni.JniType.objectType, []).object);

  static final _id_getHandlePresentation =
      jniAccessors.getMethodIDOf(_classRef, "getHandlePresentation", "()I");

  /// from: public int getHandlePresentation()
  ///
  /// @return The presentation requirements for the handle. See
  /// TelecomManager for valid values.
  int getHandlePresentation() => jniAccessors.callMethodWithArgs(
      reference, _id_getHandlePresentation, jni.JniType.intType, []).integer;

  static final _id_getCallerDisplayName = jniAccessors.getMethodIDOf(
      _classRef, "getCallerDisplayName", "()Ljava/lang/String;");

  /// from: public java.lang.String getCallerDisplayName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The display name for the caller.
  jni.JniString getCallerDisplayName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCallerDisplayName, jni.JniType.objectType, []).object);

  static final _id_getCallerDisplayNamePresentation = jniAccessors
      .getMethodIDOf(_classRef, "getCallerDisplayNamePresentation", "()I");

  /// from: public int getCallerDisplayNamePresentation()
  ///
  /// @return The presentation requirements for the caller display name. See
  /// TelecomManager for valid values.
  int getCallerDisplayNamePresentation() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCallerDisplayNamePresentation,
      jni.JniType.intType, []).integer;

  static final _id_getAccountHandle = jniAccessors.getMethodIDOf(
      _classRef, "getAccountHandle", "()Landroid/telecom/PhoneAccountHandle;");

  /// from: public android.telecom.PhoneAccountHandle getAccountHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The {@code PhoneAccountHandle} whereby the {@code Call} is currently being
  /// routed.
  phoneaccounthandle_.PhoneAccountHandle getAccountHandle() =>
      phoneaccounthandle_.PhoneAccountHandle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getAccountHandle,
              jni.JniType.objectType, []).object);

  static final _id_getCallCapabilities =
      jniAccessors.getMethodIDOf(_classRef, "getCallCapabilities", "()I");

  /// from: public int getCallCapabilities()
  ///
  /// @return A bitmask of the capabilities of the {@code Call}, as defined by the various
  ///         {@code CAPABILITY_*} constants in this class.
  int getCallCapabilities() => jniAccessors.callMethodWithArgs(
      reference, _id_getCallCapabilities, jni.JniType.intType, []).integer;

  static final _id_getCallProperties =
      jniAccessors.getMethodIDOf(_classRef, "getCallProperties", "()I");

  /// from: public int getCallProperties()
  ///
  /// @return A bitmask of the properties of the {@code Call}, as defined by the various
  ///         {@code PROPERTY_*} constants in this class.
  int getCallProperties() => jniAccessors.callMethodWithArgs(
      reference, _id_getCallProperties, jni.JniType.intType, []).integer;

  static final _id_getDisconnectCause = jniAccessors.getMethodIDOf(
      _classRef, "getDisconnectCause", "()Landroid/telecom/DisconnectCause;");

  /// from: public android.telecom.DisconnectCause getDisconnectCause()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return For a \#STATE_DISCONNECTED {@code Call}, the disconnect cause expressed
  /// by android.telecom.DisconnectCause.
  disconnectcause_.DisconnectCause getDisconnectCause() =>
      disconnectcause_.DisconnectCause.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDisconnectCause,
          jni.JniType.objectType, []).object);

  static final _id_getConnectTimeMillis =
      jniAccessors.getMethodIDOf(_classRef, "getConnectTimeMillis", "()J");

  /// from: public final long getConnectTimeMillis()
  ///
  /// Returns the time the Call connected (i.e. became active).  This information is
  /// updated periodically, but user interfaces should not rely on this to display the "call
  /// time clock".  For the time when the call was first added to Telecom, see
  /// \#getCreationTimeMillis().
  ///@return The time the Call connected in milliseconds since the epoch.
  int getConnectTimeMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getConnectTimeMillis, jni.JniType.longType, []).long;

  static final _id_getGatewayInfo = jniAccessors.getMethodIDOf(
      _classRef, "getGatewayInfo", "()Landroid/telecom/GatewayInfo;");

  /// from: public android.telecom.GatewayInfo getGatewayInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return Information about any calling gateway the {@code Call} may be using.
  gatewayinfo_.GatewayInfo getGatewayInfo() =>
      gatewayinfo_.GatewayInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getGatewayInfo, jni.JniType.objectType, []).object);

  static final _id_getVideoState =
      jniAccessors.getMethodIDOf(_classRef, "getVideoState", "()I");

  /// from: public int getVideoState()
  ///
  /// @return The video state of the {@code Call}.
  int getVideoState() => jniAccessors.callMethodWithArgs(
      reference, _id_getVideoState, jni.JniType.intType, []).integer;

  static final _id_getStatusHints = jniAccessors.getMethodIDOf(
      _classRef, "getStatusHints", "()Landroid/telecom/StatusHints;");

  /// from: public android.telecom.StatusHints getStatusHints()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The current android.telecom.StatusHints, or {@code null} if none
  /// have been set.
  statushints_.StatusHints getStatusHints() =>
      statushints_.StatusHints.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStatusHints, jni.JniType.objectType, []).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The extras associated with this call.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_getIntentExtras = jniAccessors.getMethodIDOf(
      _classRef, "getIntentExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getIntentExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The extras used with the original intent to place this call.
  bundle_.Bundle getIntentExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIntentExtras, jni.JniType.objectType, []).object);

  static final _id_getCreationTimeMillis =
      jniAccessors.getMethodIDOf(_classRef, "getCreationTimeMillis", "()J");

  /// from: public long getCreationTimeMillis()
  ///
  /// Returns the time when the call was first created and added to Telecom.  This is the same
  /// time that is logged as the start time in the Call Log (see
  /// android.provider.CallLog.Calls\#DATE).  To determine when the call was connected
  /// (became active), see \#getConnectTimeMillis().
  ///@return The creation time of the call, in millis since the epoch.
  int getCreationTimeMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getCreationTimeMillis, jni.JniType.longType, []).long;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.telecom.Call$Callback
///
/// Defines callbacks which inform the InCallService of changes to a Call.
/// These callbacks can originate from the Telecom framework, or a ConnectionService
/// implementation.
///
/// You can handle these callbacks by extending the Callback class and overriding the
/// callbacks that your InCallService is interested in.  The callback methods include the
/// Call for which the callback applies, allowing reuse of a single instance of your
/// Callback implementation, if desired.
///
/// Use Call\#registerCallback(Callback) to register your callback(s).  Ensure
/// Call\#unregisterCallback(Callback) is called when you no longer require callbacks
/// (typically in InCallService\#onCallRemoved(Call)).
/// Note: Callbacks which occur before you call Call\#registerCallback(Callback) will not
/// reach your implementation of Callback, so it is important to register your callback
/// as soon as your InCallService is notified of a new call via
/// InCallService\#onCallAdded(Call).
class Call_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/Call\$Callback");
  Call_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int HANDOVER_FAILURE_DEST_APP_REJECTED
  ///
  /// Handover failure reason returned via \#onHandoverFailed(Call, int) when the app
  /// to handover the call to rejects the handover request.
  ///
  /// Will be returned when Call\#handoverTo(PhoneAccountHandle, int, Bundle) is called
  /// and the destination PhoneAccountHandle's ConnectionService returns a
  /// {@code null} Connection from
  /// ConnectionService\#onCreateOutgoingHandoverConnection(PhoneAccountHandle,
  /// ConnectionRequest).
  ///
  /// For more information on call handovers, see
  /// \#handoverTo(PhoneAccountHandle, int, Bundle).
  static const HANDOVER_FAILURE_DEST_APP_REJECTED = 1;

  /// from: static public final int HANDOVER_FAILURE_NOT_SUPPORTED
  ///
  /// Handover failure reason returned via \#onHandoverFailed(Call, int) when a handover
  /// is initiated but the source or destination app does not support handover.
  ///
  /// Will be returned when a handover is requested via
  /// \#handoverTo(PhoneAccountHandle, int, Bundle) and the destination
  /// PhoneAccountHandle does not declare
  /// PhoneAccount\#EXTRA_SUPPORTS_HANDOVER_TO.  May also be returned when a handover is
  /// requested at the PhoneAccountHandle for the current call (i.e. the source call's
  /// Details\#getAccountHandle()) does not declare
  /// PhoneAccount\#EXTRA_SUPPORTS_HANDOVER_FROM.
  ///
  /// For more information on call handovers, see
  /// \#handoverTo(PhoneAccountHandle, int, Bundle).
  static const HANDOVER_FAILURE_NOT_SUPPORTED = 2;

  /// from: static public final int HANDOVER_FAILURE_ONGOING_EMERGENCY_CALL
  ///
  /// Handover failure reason returned via \#onHandoverFailed(Call, int) when there
  /// is ongoing emergency call.
  ///
  /// This error code is returned when \#handoverTo(PhoneAccountHandle, int, Bundle) is
  /// called on an emergency call, or if any other call is an emergency call.
  ///
  /// Handovers are not permitted while there are ongoing emergency calls.
  ///
  /// For more information on call handovers, see
  /// \#handoverTo(PhoneAccountHandle, int, Bundle).
  static const HANDOVER_FAILURE_ONGOING_EMERGENCY_CALL = 4;

  /// from: static public final int HANDOVER_FAILURE_UNKNOWN
  ///
  /// Handover failure reason returned via \#onHandoverFailed(Call, int) when a handover
  /// fails for an unknown reason.
  ///
  /// For more information on call handovers, see
  /// \#handoverTo(PhoneAccountHandle, int, Bundle).
  static const HANDOVER_FAILURE_UNKNOWN = 5;

  /// from: static public final int HANDOVER_FAILURE_USER_REJECTED
  ///
  /// Handover failure reason returned via \#onHandoverFailed(Call, int) when the remote
  /// user rejects the handover request.
  ///
  /// For more information on call handovers, see
  /// \#handoverTo(PhoneAccountHandle, int, Bundle).
  static const HANDOVER_FAILURE_USER_REJECTED = 3;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Call_Callback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onStateChanged = jniAccessors.getMethodIDOf(
      _classRef, "onStateChanged", "(Landroid/telecom/Call;I)V");

  /// from: public void onStateChanged(android.telecom.Call call, int state)
  ///
  /// Invoked when the state of this {@code Call} has changed. See \#getState().
  ///@param call The {@code Call} invoking this method.
  ///@param state The new state of the {@code Call}.
  void onStateChanged(Call call, int state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStateChanged,
      jni.JniType.voidType,
      [call.reference, state]).check();

  static final _id_onParentChanged = jniAccessors.getMethodIDOf(_classRef,
      "onParentChanged", "(Landroid/telecom/Call;Landroid/telecom/Call;)V");

  /// from: public void onParentChanged(android.telecom.Call call, android.telecom.Call parent)
  ///
  /// Invoked when the parent of this {@code Call} has changed. See \#getParent().
  ///@param call The {@code Call} invoking this method.
  ///@param parent The new parent of the {@code Call}.
  void onParentChanged(Call call, Call parent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onParentChanged,
          jni.JniType.voidType, [call.reference, parent.reference]).check();

  static final _id_onChildrenChanged = jniAccessors.getMethodIDOf(_classRef,
      "onChildrenChanged", "(Landroid/telecom/Call;Ljava/util/List;)V");

  /// from: public void onChildrenChanged(android.telecom.Call call, java.util.List<android.telecom.Call> children)
  ///
  /// Invoked when the children of this {@code Call} have changed. See \#getChildren().
  ///@param call The {@code Call} invoking this method.
  ///@param children The new children of the {@code Call}.
  void onChildrenChanged(Call call, jni.JniObject children) =>
      jniAccessors.callMethodWithArgs(reference, _id_onChildrenChanged,
          jni.JniType.voidType, [call.reference, children.reference]).check();

  static final _id_onDetailsChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onDetailsChanged",
      "(Landroid/telecom/Call;Landroid/telecom/Call\$Details;)V");

  /// from: public void onDetailsChanged(android.telecom.Call call, android.telecom.Call.Details details)
  ///
  /// Invoked when the details of this {@code Call} have changed. See \#getDetails().
  ///@param call The {@code Call} invoking this method.
  ///@param details A {@code Details} object describing the {@code Call}.
  void onDetailsChanged(Call call, Call_Details details) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDetailsChanged,
          jni.JniType.voidType, [call.reference, details.reference]).check();

  static final _id_onCannedTextResponsesLoaded = jniAccessors.getMethodIDOf(
      _classRef,
      "onCannedTextResponsesLoaded",
      "(Landroid/telecom/Call;Ljava/util/List;)V");

  /// from: public void onCannedTextResponsesLoaded(android.telecom.Call call, java.util.List<java.lang.String> cannedTextResponses)
  ///
  /// Invoked when the text messages that can be used as responses to the incoming
  /// {@code Call} are loaded from the relevant database.
  /// See \#getCannedTextResponses().
  ///@param call The {@code Call} invoking this method.
  ///@param cannedTextResponses The text messages useable as responses.
  void onCannedTextResponsesLoaded(
          Call call, jni.JniObject cannedTextResponses) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCannedTextResponsesLoaded,
          jni.JniType.voidType,
          [call.reference, cannedTextResponses.reference]).check();

  static final _id_onPostDialWait = jniAccessors.getMethodIDOf(_classRef,
      "onPostDialWait", "(Landroid/telecom/Call;Ljava/lang/String;)V");

  /// from: public void onPostDialWait(android.telecom.Call call, java.lang.String remainingPostDialSequence)
  ///
  /// Invoked when the post-dial sequence in the outgoing {@code Call} has reached a pause
  /// character. This causes the post-dial signals to stop pending user confirmation. An
  /// implementation should present this choice to the user and invoke
  /// \#postDialContinue(boolean) when the user makes the choice.
  ///@param call The {@code Call} invoking this method.
  ///@param remainingPostDialSequence The post-dial characters that remain to be sent.
  void onPostDialWait(Call call, jni.JniString remainingPostDialSequence) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPostDialWait,
          jni.JniType.voidType,
          [call.reference, remainingPostDialSequence.reference]).check();

  static final _id_onVideoCallChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onVideoCallChanged",
      "(Landroid/telecom/Call;Landroid/telecom/InCallService\$VideoCall;)V");

  /// from: public void onVideoCallChanged(android.telecom.Call call, android.telecom.InCallService.VideoCall videoCall)
  ///
  /// Invoked when the {@code Call.VideoCall} of the {@code Call} has changed.
  ///@param call The {@code Call} invoking this method.
  ///@param videoCall The {@code Call.VideoCall} associated with the {@code Call}.
  void onVideoCallChanged(
          Call call, incallservice_.InCallService_VideoCall videoCall) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVideoCallChanged,
          jni.JniType.voidType, [call.reference, videoCall.reference]).check();

  static final _id_onCallDestroyed = jniAccessors.getMethodIDOf(
      _classRef, "onCallDestroyed", "(Landroid/telecom/Call;)V");

  /// from: public void onCallDestroyed(android.telecom.Call call)
  ///
  /// Invoked when the {@code Call} is destroyed. Clients should refrain from cleaning
  /// up their UI for the {@code Call} in response to state transitions. Specifically,
  /// clients should not assume that a \#onStateChanged(Call, int) with a state of
  /// \#STATE_DISCONNECTED is the final notification the {@code Call} will send. Rather,
  /// clients should wait for this method to be invoked.
  ///@param call The {@code Call} being destroyed.
  void onCallDestroyed(Call call) => jniAccessors.callMethodWithArgs(reference,
      _id_onCallDestroyed, jni.JniType.voidType, [call.reference]).check();

  static final _id_onConferenceableCallsChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConferenceableCallsChanged",
      "(Landroid/telecom/Call;Ljava/util/List;)V");

  /// from: public void onConferenceableCallsChanged(android.telecom.Call call, java.util.List<android.telecom.Call> conferenceableCalls)
  ///
  /// Invoked upon changes to the set of {@code Call}s with which this {@code Call} can be
  /// conferenced.
  ///@param call The {@code Call} being updated.
  ///@param conferenceableCalls The {@code Call}s with which this {@code Call} can be
  ///          conferenced.
  void onConferenceableCallsChanged(
          Call call, jni.JniObject conferenceableCalls) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onConferenceableCallsChanged,
          jni.JniType.voidType,
          [call.reference, conferenceableCalls.reference]).check();

  static final _id_onConnectionEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onConnectionEvent",
      "(Landroid/telecom/Call;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onConnectionEvent(android.telecom.Call call, java.lang.String event, android.os.Bundle extras)
  ///
  /// Invoked when a Call receives an event from its associated Connection.
  ///
  /// Where possible, the Call should make an attempt to handle Connection events which
  /// are part of the {@code android.telecom.*} namespace.  The Call should ignore any events
  /// it does not wish to handle.  Unexpected events should be handled gracefully, as it is
  /// possible that a ConnectionService has defined its own Connection events which a
  /// Call is not aware of.
  ///
  /// See Connection\#sendConnectionEvent(String, Bundle).
  ///@param call The {@code Call} receiving the event.
  ///@param event The event.
  ///@param extras Extras associated with the connection event.
  void onConnectionEvent(
          Call call, jni.JniString event, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onConnectionEvent,
          jni.JniType.voidType,
          [call.reference, event.reference, extras.reference]).check();

  static final _id_onRttModeChanged = jniAccessors.getMethodIDOf(
      _classRef, "onRttModeChanged", "(Landroid/telecom/Call;I)V");

  /// from: public void onRttModeChanged(android.telecom.Call call, int mode)
  ///
  /// Invoked when the RTT mode changes for this call.
  ///@param call The call whose RTT mode has changed.
  ///@param mode the new RTT mode, one of
  /// RttCall\#RTT_MODE_FULL, RttCall\#RTT_MODE_HCO,
  ///             or RttCall\#RTT_MODE_VCO
  void onRttModeChanged(Call call, int mode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRttModeChanged,
      jni.JniType.voidType,
      [call.reference, mode]).check();

  static final _id_onRttStatusChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onRttStatusChanged",
      "(Landroid/telecom/Call;ZLandroid/telecom/Call\$RttCall;)V");

  /// from: public void onRttStatusChanged(android.telecom.Call call, boolean enabled, android.telecom.Call.RttCall rttCall)
  ///
  /// Invoked when the call's RTT status changes, either from off to on or from on to off.
  ///@param call The call whose RTT status has changed.
  ///@param enabled whether RTT is now enabled or disabled
  ///@param rttCall the RttCall object to use for reading and writing if RTT is now
  ///                on, null otherwise.
  void onRttStatusChanged(Call call, bool enabled, Call_RttCall rttCall) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRttStatusChanged,
          jni.JniType.voidType,
          [call.reference, enabled, rttCall.reference]).check();

  static final _id_onRttRequest = jniAccessors.getMethodIDOf(
      _classRef, "onRttRequest", "(Landroid/telecom/Call;I)V");

  /// from: public void onRttRequest(android.telecom.Call call, int id)
  ///
  /// Invoked when the remote end of the connection has requested that an RTT communication
  /// channel be opened. A response to this should be sent via \#respondToRttRequest
  /// with the same ID that this method is invoked with.
  ///@param call The call which the RTT request was placed on
  ///@param id The ID of the request.
  void onRttRequest(Call call, int id) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRttRequest,
      jni.JniType.voidType,
      [call.reference, id]).check();

  static final _id_onRttInitiationFailure = jniAccessors.getMethodIDOf(
      _classRef, "onRttInitiationFailure", "(Landroid/telecom/Call;I)V");

  /// from: public void onRttInitiationFailure(android.telecom.Call call, int reason)
  ///
  /// Invoked when the RTT session failed to initiate for some reason, including rejection
  /// by the remote party.
  ///@param call The call which the RTT initiation failure occurred on.
  ///@param reason One of the status codes defined in
  ///               android.telecom.Connection.RttModifyStatus, with the exception of
  ///               android.telecom.Connection.RttModifyStatus\#SESSION_MODIFY_REQUEST_SUCCESS.
  void onRttInitiationFailure(Call call, int reason) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRttInitiationFailure,
          jni.JniType.voidType, [call.reference, reason]).check();

  static final _id_onHandoverComplete = jniAccessors.getMethodIDOf(
      _classRef, "onHandoverComplete", "(Landroid/telecom/Call;)V");

  /// from: public void onHandoverComplete(android.telecom.Call call)
  ///
  /// Invoked when Call handover from one PhoneAccount to other PhoneAccount
  /// has completed successfully.
  ///
  /// For a full discussion of the handover process and the APIs involved, see
  /// android.telecom.Call\#handoverTo(PhoneAccountHandle, int, Bundle).
  ///@param call The call which had initiated handover.
  void onHandoverComplete(Call call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onHandoverComplete,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onHandoverFailed = jniAccessors.getMethodIDOf(
      _classRef, "onHandoverFailed", "(Landroid/telecom/Call;I)V");

  /// from: public void onHandoverFailed(android.telecom.Call call, int failureReason)
  ///
  /// Invoked when Call handover from one PhoneAccount to other PhoneAccount
  /// has failed.
  ///
  /// For a full discussion of the handover process and the APIs involved, see
  /// android.telecom.Call\#handoverTo(PhoneAccountHandle, int, Bundle).
  ///@param call The call which had initiated handover.
  ///@param failureReason Error reason for failure.
  ///
  /// Value is android.telecom.Call.Callback\#HANDOVER_FAILURE_DEST_APP_REJECTED, android.telecom.Call.Callback\#HANDOVER_FAILURE_NOT_SUPPORTED, android.telecom.Call.Callback\#HANDOVER_FAILURE_USER_REJECTED, android.telecom.Call.Callback\#HANDOVER_FAILURE_ONGOING_EMERGENCY_CALL, or android.telecom.Call.Callback\#HANDOVER_FAILURE_UNKNOWN
  void onHandoverFailed(Call call, int failureReason) =>
      jniAccessors.callMethodWithArgs(reference, _id_onHandoverFailed,
          jni.JniType.voidType, [call.reference, failureReason]).check();
}
