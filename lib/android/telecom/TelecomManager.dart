// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "PhoneAccountHandle.dart" as phoneaccounthandle_;

import "PhoneAccount.dart" as phoneaccount_;

import "../os/Bundle.dart" as bundle_;

import "../net/Uri.dart" as uri_;

import "../content/Intent.dart" as intent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telecom.TelecomManager
///
/// Provides access to information about active calls and registration/call-management functionality.
/// Apps can use methods in this class to determine the current call state.
///
/// Apps do not instantiate this class directly; instead, they retrieve a reference to an instance
/// through Context\#getSystemService Context.getSystemService(Context.TELECOM_SERVICE).
///
/// Note that access to some telecom information is permission-protected. Your app cannot access the
/// protected information or gain access to protected functionality unless it has the appropriate
/// permissions declared in its manifest file. Where permissions apply, they are noted in the method
/// descriptions.
class TelecomManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/TelecomManager");
  TelecomManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CHANGE_DEFAULT_DIALER
  ///
  /// Activity action: Shows a dialog asking the user whether or not they want to replace the
  /// current default Dialer with the one specified in
  /// \#EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME.
  ///
  /// Usage example:
  /// <pre>
  /// Intent intent = new Intent(TelecomManager.ACTION_CHANGE_DEFAULT_DIALER);
  /// intent.putExtra(TelecomManager.EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME,
  ///         getActivity().getPackageName());
  /// startActivity(intent);
  /// </pre>
  static const ACTION_CHANGE_DEFAULT_DIALER =
      "android.telecom.action.CHANGE_DEFAULT_DIALER";

  /// from: static public final java.lang.String ACTION_CHANGE_PHONE_ACCOUNTS
  ///
  /// The android.content.Intent action used to show the settings page used to configure
  /// PhoneAccount preferences.
  static const ACTION_CHANGE_PHONE_ACCOUNTS =
      "android.telecom.action.CHANGE_PHONE_ACCOUNTS";

  /// from: static public final java.lang.String ACTION_CONFIGURE_PHONE_ACCOUNT
  ///
  /// An android.content.Intent action sent by the telecom framework to start a
  /// configuration dialog for a registered PhoneAccount. There is no default dialog
  /// and each app that registers a PhoneAccount should provide one if desired.
  ///
  /// A user can access the list of enabled android.telecom.PhoneAccounts through the Phone
  /// app's settings menu. For each entry, the settings app will add a click action. When
  /// triggered, the click-action will start this intent along with the extra
  /// \#EXTRA_PHONE_ACCOUNT_HANDLE to indicate the PhoneAccount to configure. If the
  /// PhoneAccount package does not register an android.app.Activity for this
  /// intent, then it will not be sent.
  static const ACTION_CONFIGURE_PHONE_ACCOUNT =
      "android.telecom.action.CONFIGURE_PHONE_ACCOUNT";

  /// from: static public final java.lang.String ACTION_DEFAULT_DIALER_CHANGED
  ///
  /// Broadcast intent action indicating that the current default dialer has changed.
  /// The string extra \#EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME will contain the
  /// name of the package that the default dialer was changed to.
  ///@see \#EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME
  static const ACTION_DEFAULT_DIALER_CHANGED =
      "android.telecom.action.DEFAULT_DIALER_CHANGED";

  /// from: static public final java.lang.String ACTION_INCOMING_CALL
  ///
  /// Activity action: Starts the UI for handing an incoming call. This intent starts the in-call
  /// UI by notifying the Telecom system that an incoming call exists for a specific call service
  /// (see android.telecom.ConnectionService). Telecom reads the Intent extras to find
  /// and bind to the appropriate android.telecom.ConnectionService which Telecom will
  /// ultimately use to control and get information about the call.
  ///
  /// Input: get*Extra field \#EXTRA_PHONE_ACCOUNT_HANDLE contains the component name of the
  /// android.telecom.ConnectionService that Telecom should bind to. Telecom will then
  /// ask the connection service for more information about the call prior to showing any UI.
  ///@deprecated Use \#addNewIncomingCall instead.
  static const ACTION_INCOMING_CALL = "android.telecom.action.INCOMING_CALL";

  /// from: static public final java.lang.String ACTION_PHONE_ACCOUNT_REGISTERED
  ///
  /// android.content.Intent action used indicate that a new phone account was just
  /// registered.
  ///
  /// The Intent Intent\#getExtras() extras will contain \#EXTRA_PHONE_ACCOUNT_HANDLE
  /// to indicate which PhoneAccount was registered.
  ///
  /// Will only be sent to the default dialer app (see \#getDefaultDialerPackage()).
  static const ACTION_PHONE_ACCOUNT_REGISTERED =
      "android.telecom.action.PHONE_ACCOUNT_REGISTERED";

  /// from: static public final java.lang.String ACTION_PHONE_ACCOUNT_UNREGISTERED
  ///
  /// android.content.Intent action used indicate that a phone account was just
  /// unregistered.
  ///
  /// The Intent Intent\#getExtras() extras will contain \#EXTRA_PHONE_ACCOUNT_HANDLE
  /// to indicate which PhoneAccount was unregistered.
  ///
  /// Will only be sent to the default dialer app (see \#getDefaultDialerPackage()).
  static const ACTION_PHONE_ACCOUNT_UNREGISTERED =
      "android.telecom.action.PHONE_ACCOUNT_UNREGISTERED";

  /// from: static public final java.lang.String ACTION_SHOW_CALL_ACCESSIBILITY_SETTINGS
  ///
  /// The android.content.Intent action used to show the call accessibility settings page.
  static const ACTION_SHOW_CALL_ACCESSIBILITY_SETTINGS =
      "android.telecom.action.SHOW_CALL_ACCESSIBILITY_SETTINGS";

  /// from: static public final java.lang.String ACTION_SHOW_CALL_SETTINGS
  ///
  /// The android.content.Intent action used to show the call settings page.
  static const ACTION_SHOW_CALL_SETTINGS =
      "android.telecom.action.SHOW_CALL_SETTINGS";

  /// from: static public final java.lang.String ACTION_SHOW_MISSED_CALLS_NOTIFICATION
  ///
  /// Broadcast intent action for letting custom component know to show the missed call
  /// notification. If no custom component exists then this is sent to the default dialer which
  /// should post a missed-call notification.
  static const ACTION_SHOW_MISSED_CALLS_NOTIFICATION =
      "android.telecom.action.SHOW_MISSED_CALLS_NOTIFICATION";

  /// from: static public final java.lang.String ACTION_SHOW_RESPOND_VIA_SMS_SETTINGS
  ///
  /// The android.content.Intent action used to show the respond via SMS settings page.
  static const ACTION_SHOW_RESPOND_VIA_SMS_SETTINGS =
      "android.telecom.action.SHOW_RESPOND_VIA_SMS_SETTINGS";

  /// from: static public final char DTMF_CHARACTER_PAUSE
  ///
  /// The dual tone multi-frequency signaling character sent to indicate the dialing system should
  /// pause for a predefined period.
  static const DTMF_CHARACTER_PAUSE = ",";

  /// from: static public final char DTMF_CHARACTER_WAIT
  ///
  /// The dual-tone multi-frequency signaling character sent to indicate the dialing system should
  /// wait for user confirmation before proceeding.
  static const DTMF_CHARACTER_WAIT = ";";

  /// from: static public final java.lang.String EXTRA_CALL_BACK_NUMBER
  ///
  /// The number which the party on the other side of the line will see (and use to return the
  /// call).
  ///
  /// ConnectionServices which interact with RemoteConnections should only populate
  /// this if the android.telephony.TelephonyManager\#getLine1Number() value, as that is the
  /// user's expected caller ID.
  static const EXTRA_CALL_BACK_NUMBER =
      "android.telecom.extra.CALL_BACK_NUMBER";

  /// from: static public final java.lang.String EXTRA_CALL_DISCONNECT_CAUSE
  ///
  /// Optional extra for android.telephony.TelephonyManager\#ACTION_PHONE_STATE_CHANGED
  /// containing the disconnect code.
  static const EXTRA_CALL_DISCONNECT_CAUSE =
      "android.telecom.extra.CALL_DISCONNECT_CAUSE";

  /// from: static public final java.lang.String EXTRA_CALL_DISCONNECT_MESSAGE
  ///
  /// Optional extra for android.telephony.TelephonyManager\#ACTION_PHONE_STATE_CHANGED
  /// containing the disconnect message.
  static const EXTRA_CALL_DISCONNECT_MESSAGE =
      "android.telecom.extra.CALL_DISCONNECT_MESSAGE";

  /// from: static public final java.lang.String EXTRA_CALL_SUBJECT
  ///
  /// Optional extra for android.content.Intent\#ACTION_CALL containing a string call
  /// subject which will be associated with an outgoing call.  Should only be specified if the
  /// PhoneAccount supports the capability PhoneAccount\#CAPABILITY_CALL_SUBJECT.
  static const EXTRA_CALL_SUBJECT = "android.telecom.extra.CALL_SUBJECT";

  /// from: static public final java.lang.String EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME
  ///
  /// Extra value used to provide the package name for \#ACTION_CHANGE_DEFAULT_DIALER.
  static const EXTRA_CHANGE_DEFAULT_DIALER_PACKAGE_NAME =
      "android.telecom.extra.CHANGE_DEFAULT_DIALER_PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_INCOMING_CALL_ADDRESS
  ///
  /// The extra used by a ConnectionService to provide the handle of the caller that
  /// has initiated a new incoming call.
  static const EXTRA_INCOMING_CALL_ADDRESS =
      "android.telecom.extra.INCOMING_CALL_ADDRESS";

  /// from: static public final java.lang.String EXTRA_INCOMING_CALL_EXTRAS
  ///
  /// Optional extra for \#ACTION_INCOMING_CALL containing a Bundle which contains
  /// metadata about the call. This Bundle will be returned to the
  /// ConnectionService.
  static const EXTRA_INCOMING_CALL_EXTRAS =
      "android.telecom.extra.INCOMING_CALL_EXTRAS";

  /// from: static public final java.lang.String EXTRA_INCOMING_VIDEO_STATE
  ///
  /// Optional extra for \#addNewIncomingCall(PhoneAccountHandle, Bundle) containing an
  /// integer that determines the requested video state for an incoming call.
  /// Valid options:
  /// VideoProfile\#STATE_AUDIO_ONLY,
  /// VideoProfile\#STATE_BIDIRECTIONAL,
  /// VideoProfile\#STATE_RX_ENABLED,
  /// VideoProfile\#STATE_TX_ENABLED.
  static const EXTRA_INCOMING_VIDEO_STATE =
      "android.telecom.extra.INCOMING_VIDEO_STATE";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_COUNT
  ///
  /// The number of calls associated with the notification. If the number is zero then the missed
  /// call notification should be dismissed.
  static const EXTRA_NOTIFICATION_COUNT =
      "android.telecom.extra.NOTIFICATION_COUNT";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_PHONE_NUMBER
  ///
  /// The number associated with the missed calls. This number is only relevant
  /// when EXTRA_NOTIFICATION_COUNT is 1.
  static const EXTRA_NOTIFICATION_PHONE_NUMBER =
      "android.telecom.extra.NOTIFICATION_PHONE_NUMBER";

  /// from: static public final java.lang.String EXTRA_OUTGOING_CALL_EXTRAS
  ///
  /// Optional extra for android.content.Intent\#ACTION_CALL and
  /// android.content.Intent\#ACTION_DIAL {@code Intent} containing a Bundle
  /// which contains metadata about the call. This Bundle will be saved into
  /// {@code Call.Details} and passed to the ConnectionService when placing the call.
  static const EXTRA_OUTGOING_CALL_EXTRAS =
      "android.telecom.extra.OUTGOING_CALL_EXTRAS";

  /// from: static public final java.lang.String EXTRA_PHONE_ACCOUNT_HANDLE
  ///
  /// The extra used with an android.content.Intent\#ACTION_CALL and
  /// android.content.Intent\#ACTION_DIAL {@code Intent} to specify a
  /// PhoneAccountHandle to use when making the call.
  /// <p class="note">
  /// Retrieve with android.content.Intent\#getParcelableExtra(String).
  static const EXTRA_PHONE_ACCOUNT_HANDLE =
      "android.telecom.extra.PHONE_ACCOUNT_HANDLE";

  /// from: static public final java.lang.String EXTRA_START_CALL_WITH_RTT
  ///
  /// A boolean extra, which when set on the Intent\#ACTION_CALL intent or on the bundle
  /// passed into \#placeCall(Uri, Bundle), indicates that the call should be initiated with
  /// an RTT session open. See android.telecom.Call.RttCall for more information on RTT.
  static const EXTRA_START_CALL_WITH_RTT =
      "android.telecom.extra.START_CALL_WITH_RTT";

  /// from: static public final java.lang.String EXTRA_START_CALL_WITH_SPEAKERPHONE
  ///
  /// Optional extra for android.content.Intent\#ACTION_CALL containing a boolean that
  /// determines whether the speakerphone should be automatically turned on for an outgoing call.
  static const EXTRA_START_CALL_WITH_SPEAKERPHONE =
      "android.telecom.extra.START_CALL_WITH_SPEAKERPHONE";

  /// from: static public final java.lang.String EXTRA_START_CALL_WITH_VIDEO_STATE
  ///
  /// Optional extra for android.content.Intent\#ACTION_CALL containing an integer that
  /// determines the desired video state for an outgoing call.
  /// Valid options:
  /// VideoProfile\#STATE_AUDIO_ONLY,
  /// VideoProfile\#STATE_BIDIRECTIONAL,
  /// VideoProfile\#STATE_RX_ENABLED,
  /// VideoProfile\#STATE_TX_ENABLED.
  static const EXTRA_START_CALL_WITH_VIDEO_STATE =
      "android.telecom.extra.START_CALL_WITH_VIDEO_STATE";

  /// from: static public final java.lang.String GATEWAY_ORIGINAL_ADDRESS
  ///
  /// An optional android.content.Intent\#ACTION_CALL intent extra corresponding to the
  /// original address to dial for the call. This is used when an alternative gateway address is
  /// provided to recall the original address.
  /// The value is a android.net.Uri.
  ///
  /// (See \#GATEWAY_PROVIDER_PACKAGE for details)
  static const GATEWAY_ORIGINAL_ADDRESS =
      "android.telecom.extra.GATEWAY_ORIGINAL_ADDRESS";

  /// from: static public final java.lang.String GATEWAY_PROVIDER_PACKAGE
  ///
  /// An optional android.content.Intent\#ACTION_CALL intent extra denoting the
  /// package name of the app specifying an alternative gateway for the call.
  /// The value is a string.
  ///
  /// (The following comment corresponds to the all GATEWAY_* extras)
  /// An app which sends the android.content.Intent\#ACTION_CALL intent can specify an
  /// alternative address to dial which is different from the one specified and displayed to
  /// the user. This alternative address is referred to as the gateway address.
  static const GATEWAY_PROVIDER_PACKAGE =
      "android.telecom.extra.GATEWAY_PROVIDER_PACKAGE";

  /// from: static public final java.lang.String METADATA_INCLUDE_EXTERNAL_CALLS
  ///
  /// A boolean meta-data value indicating whether an InCallService wants to be informed of
  /// calls which have the Call.Details\#PROPERTY_IS_EXTERNAL_CALL property.  An external
  /// call is one which a ConnectionService knows about, but is not connected to directly.
  /// Dialer implementations (see \#getDefaultDialerPackage()) which would like to be
  /// informed of external calls should set this meta-data to {@code true} in the manifest
  /// registration of their InCallService.  By default, the InCallService will NOT
  /// be informed of external calls.
  static const METADATA_INCLUDE_EXTERNAL_CALLS =
      "android.telecom.INCLUDE_EXTERNAL_CALLS";

  /// from: static public final java.lang.String METADATA_INCLUDE_SELF_MANAGED_CALLS
  ///
  /// A boolean meta-data value indicating whether an InCallService wants to be informed of
  /// calls which have the Call.Details\#PROPERTY_SELF_MANAGED property.  A self-managed
  /// call is one which originates from a self-managed ConnectionService which has chosen
  /// to implement its own call user interface.  An InCallService implementation which
  /// would like to be informed of external calls should set this meta-data to {@code true} in the
  /// manifest registration of their InCallService.  By default, the InCallService
  /// will NOT be informed about self-managed calls.
  ///
  /// An InCallService which receives self-managed calls is free to view and control the
  /// state of calls in the self-managed ConnectionService.  An example use-case is
  /// exposing these calls to an automotive device via its companion app.
  ///
  /// This meta-data can only be set for an InCallService which also sets
  /// \#METADATA_IN_CALL_SERVICE_UI. Only the default phone/dialer app, or a car-mode
  /// InCallService can see self-managed calls.
  ///
  /// See also Connection\#PROPERTY_SELF_MANAGED.
  static const METADATA_INCLUDE_SELF_MANAGED_CALLS =
      "android.telecom.INCLUDE_SELF_MANAGED_CALLS";

  /// from: static public final java.lang.String METADATA_IN_CALL_SERVICE_RINGING
  ///
  /// A boolean meta-data value indicating whether an InCallService implements ringing.
  /// Dialer implementations (see \#getDefaultDialerPackage()) which would also like to
  /// override the system provided ringing should set this meta-data to {@code true} in the
  /// manifest registration of their InCallService.
  static const METADATA_IN_CALL_SERVICE_RINGING =
      "android.telecom.IN_CALL_SERVICE_RINGING";

  /// from: static public final java.lang.String METADATA_IN_CALL_SERVICE_UI
  ///
  /// A boolean meta-data value indicating whether an InCallService implements an
  /// in-call user interface. Dialer implementations (see \#getDefaultDialerPackage()) which
  /// would also like to replace the in-call interface should set this meta-data to {@code true} in
  /// the manifest registration of their InCallService.
  static const METADATA_IN_CALL_SERVICE_UI =
      "android.telecom.IN_CALL_SERVICE_UI";

  /// from: static public final int PRESENTATION_ALLOWED
  ///
  /// Indicates that the address or number of a call is allowed to be displayed for caller ID.
  static const PRESENTATION_ALLOWED = 1;

  /// from: static public final int PRESENTATION_PAYPHONE
  ///
  /// Indicates that the address or number of a call belongs to a pay phone.
  static const PRESENTATION_PAYPHONE = 4;

  /// from: static public final int PRESENTATION_RESTRICTED
  ///
  /// Indicates that the address or number of a call is blocked by the other party.
  static const PRESENTATION_RESTRICTED = 2;

  /// from: static public final int PRESENTATION_UNKNOWN
  ///
  /// Indicates that the address or number of a call is not specified or known by the carrier.
  static const PRESENTATION_UNKNOWN = 3;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  TelecomManager(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_getDefaultOutgoingPhoneAccount = jniAccessors.getMethodIDOf(
      _classRef,
      "getDefaultOutgoingPhoneAccount",
      "(Ljava/lang/String;)Landroid/telecom/PhoneAccountHandle;");

  /// from: public android.telecom.PhoneAccountHandle getDefaultOutgoingPhoneAccount(java.lang.String uriScheme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the PhoneAccount which will be used to place outgoing calls to addresses with
  /// the specified {@code uriScheme}. This PhoneAccount will always be a member of the
  /// list which is returned from invoking \#getCallCapablePhoneAccounts(). The specific
  /// account returned depends on the following priorities:
  /// <ul>
  /// <li> If the user-selected default PhoneAccount supports the specified scheme, it will
  /// be returned.
  /// </li>
  /// <li> If there exists only one PhoneAccount that supports the specified scheme, it
  /// will be returned.
  /// </li>
  /// </ul>
  ///
  /// If no PhoneAccount fits the criteria above, this method will return {@code null}.
  ///
  /// Requires permission: android.Manifest.permission\#READ_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param uriScheme The URI scheme.
  ///@return The PhoneAccountHandle corresponding to the account to be used.
  phoneaccounthandle_.PhoneAccountHandle getDefaultOutgoingPhoneAccount(
          jni.JniString uriScheme) =>
      phoneaccounthandle_.PhoneAccountHandle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getDefaultOutgoingPhoneAccount,
              jni.JniType.objectType, [uriScheme.reference]).object);

  static final _id_getSimCallManager = jniAccessors.getMethodIDOf(
      _classRef, "getSimCallManager", "()Landroid/telecom/PhoneAccountHandle;");

  /// from: public android.telecom.PhoneAccountHandle getSimCallManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current SIM call manager. Apps must be prepared for this method to return
  /// {@code null}, indicating that there currently exists no user-chosen default
  /// {@code PhoneAccount}.
  ///@return The phone account handle of the current sim call manager.
  phoneaccounthandle_.PhoneAccountHandle getSimCallManager() =>
      phoneaccounthandle_.PhoneAccountHandle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getSimCallManager,
              jni.JniType.objectType, []).object);

  static final _id_getCallCapablePhoneAccounts = jniAccessors.getMethodIDOf(
      _classRef, "getCallCapablePhoneAccounts", "()Ljava/util/List;");

  /// from: public java.util.List<android.telecom.PhoneAccountHandle> getCallCapablePhoneAccounts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of PhoneAccountHandles which can be used to make and receive phone
  /// calls. The returned list includes only those accounts which have been explicitly enabled
  /// by the user.
  ///
  /// Requires permission: android.Manifest.permission\#READ_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@see \#EXTRA_PHONE_ACCOUNT_HANDLE
  ///@return A list of {@code PhoneAccountHandle} objects.
  jni.JniObject getCallCapablePhoneAccounts() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCallCapablePhoneAccounts, jni.JniType.objectType, []).object);

  static final _id_getSelfManagedPhoneAccounts = jniAccessors.getMethodIDOf(
      _classRef, "getSelfManagedPhoneAccounts", "()Ljava/util/List;");

  /// from: public java.util.List<android.telecom.PhoneAccountHandle> getSelfManagedPhoneAccounts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of PhoneAccountHandles for self-managed ConnectionServices.
  ///
  /// Self-Managed ConnectionServices have a PhoneAccount with
  /// PhoneAccount\#CAPABILITY_SELF_MANAGED.
  ///
  /// Requires permission android.Manifest.permission\#READ_PHONE_STATE, or that the caller
  /// is the default dialer app.
  ///
  /// A SecurityException will be thrown if a called is not the default dialer, or lacks
  /// the android.Manifest.permission\#READ_PHONE_STATE permission.
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@return A list of {@code PhoneAccountHandle} objects.
  jni.JniObject getSelfManagedPhoneAccounts() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSelfManagedPhoneAccounts, jni.JniType.objectType, []).object);

  static final _id_getPhoneAccount = jniAccessors.getMethodIDOf(
      _classRef,
      "getPhoneAccount",
      "(Landroid/telecom/PhoneAccountHandle;)Landroid/telecom/PhoneAccount;");

  /// from: public android.telecom.PhoneAccount getPhoneAccount(android.telecom.PhoneAccountHandle account)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the PhoneAccount for a specified PhoneAccountHandle. Object includes
  /// resources which can be used in a user interface.
  ///@param account The PhoneAccountHandle.
  ///@return The PhoneAccount object.
  phoneaccount_.PhoneAccount getPhoneAccount(
          phoneaccounthandle_.PhoneAccountHandle account) =>
      phoneaccount_.PhoneAccount.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPhoneAccount,
          jni.JniType.objectType,
          [account.reference]).object);

  static final _id_registerPhoneAccount = jniAccessors.getMethodIDOf(
      _classRef, "registerPhoneAccount", "(Landroid/telecom/PhoneAccount;)V");

  /// from: public void registerPhoneAccount(android.telecom.PhoneAccount account)
  ///
  /// Register a PhoneAccount for use by the system that will be stored in Device Encrypted
  /// storage. When registering PhoneAccounts, existing registrations will be overwritten
  /// if the PhoneAccountHandle matches that of a PhoneAccount which is already
  /// registered. Once registered, the PhoneAccount is listed to the user as an option
  /// when placing calls. The user may still need to enable the PhoneAccount within
  /// the phone app settings before the account is usable.
  ///
  /// A SecurityException will be thrown if an app tries to register a
  /// PhoneAccountHandle where the package name specified within
  /// PhoneAccountHandle\#getComponentName() does not match the package name of the app.
  ///@param account The complete PhoneAccount.
  void registerPhoneAccount(phoneaccount_.PhoneAccount account) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerPhoneAccount,
          jni.JniType.voidType, [account.reference]).check();

  static final _id_unregisterPhoneAccount = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterPhoneAccount",
      "(Landroid/telecom/PhoneAccountHandle;)V");

  /// from: public void unregisterPhoneAccount(android.telecom.PhoneAccountHandle accountHandle)
  ///
  /// Remove a PhoneAccount registration from the system.
  ///@param accountHandle A PhoneAccountHandle for the PhoneAccount to unregister.
  void unregisterPhoneAccount(
          phoneaccounthandle_.PhoneAccountHandle accountHandle) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterPhoneAccount,
          jni.JniType.voidType, [accountHandle.reference]).check();

  static final _id_getDefaultDialerPackage = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultDialerPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getDefaultDialerPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to determine the currently selected default dialer package.
  ///@return package name for the default dialer package or null if no package has been
  ///         selected as the default dialer.
  jni.JniString getDefaultDialerPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDefaultDialerPackage, jni.JniType.objectType, []).object);

  static final _id_isVoiceMailNumber = jniAccessors.getMethodIDOf(
      _classRef,
      "isVoiceMailNumber",
      "(Landroid/telecom/PhoneAccountHandle;Ljava/lang/String;)Z");

  /// from: public boolean isVoiceMailNumber(android.telecom.PhoneAccountHandle accountHandle, java.lang.String number)
  ///
  /// Return whether a given phone number is the configured voicemail number for a
  /// particular phone account.
  ///
  /// Requires permission: android.Manifest.permission\#READ_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param accountHandle The handle for the account to check the voicemail number against
  ///@param number The number to look up.
  bool isVoiceMailNumber(phoneaccounthandle_.PhoneAccountHandle accountHandle,
          jni.JniString number) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isVoiceMailNumber,
          jni.JniType.booleanType,
          [accountHandle.reference, number.reference]).boolean;

  static final _id_getVoiceMailNumber = jniAccessors.getMethodIDOf(
      _classRef,
      "getVoiceMailNumber",
      "(Landroid/telecom/PhoneAccountHandle;)Ljava/lang/String;");

  /// from: public java.lang.String getVoiceMailNumber(android.telecom.PhoneAccountHandle accountHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the voicemail number for a given phone account.
  ///
  /// Requires permission: android.Manifest.permission\#READ_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param accountHandle The handle for the phone account.
  ///@return The voicemail number for the phone account, and {@code null} if one has not been
  ///         configured.
  jni.JniString getVoiceMailNumber(
          phoneaccounthandle_.PhoneAccountHandle accountHandle) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getVoiceMailNumber,
          jni.JniType.objectType,
          [accountHandle.reference]).object);

  static final _id_getLine1Number = jniAccessors.getMethodIDOf(
      _classRef,
      "getLine1Number",
      "(Landroid/telecom/PhoneAccountHandle;)Ljava/lang/String;");

  /// from: public java.lang.String getLine1Number(android.telecom.PhoneAccountHandle accountHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the line 1 phone number for given phone account.
  ///
  /// Requires permission: android.Manifest.permission\#READ_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param accountHandle The handle for the account retrieve a number for.
  ///@return A string representation of the line 1 phone number.
  jni.JniString getLine1Number(
          phoneaccounthandle_.PhoneAccountHandle accountHandle) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLine1Number,
          jni.JniType.objectType,
          [accountHandle.reference]).object);

  static final _id_isInCall =
      jniAccessors.getMethodIDOf(_classRef, "isInCall", "()Z");

  /// from: public boolean isInCall()
  ///
  /// Returns whether there is an ongoing phone call (can be in dialing, ringing, active or holding
  /// states) originating from either a manager or self-managed ConnectionService.
  ///
  /// Requires permission: android.Manifest.permission\#READ_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@return {@code true} if there is an ongoing call in either a managed or self-managed
  ///      ConnectionService, {@code false} otherwise.
  bool isInCall() => jniAccessors.callMethodWithArgs(
      reference, _id_isInCall, jni.JniType.booleanType, []).boolean;

  static final _id_isInManagedCall =
      jniAccessors.getMethodIDOf(_classRef, "isInManagedCall", "()Z");

  /// from: public boolean isInManagedCall()
  ///
  /// Returns whether there is an ongoing call originating from a managed
  /// ConnectionService.  An ongoing call can be in dialing, ringing, active or holding
  /// states.
  ///
  /// If you also need to know if there are ongoing self-managed calls, use \#isInCall()
  /// instead.
  ///
  /// Requires permission: android.Manifest.permission\#READ_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@return {@code true} if there is an ongoing call in a managed ConnectionService,
  ///      {@code false} otherwise.
  bool isInManagedCall() => jniAccessors.callMethodWithArgs(
      reference, _id_isInManagedCall, jni.JniType.booleanType, []).boolean;

  static final _id_endCall =
      jniAccessors.getMethodIDOf(_classRef, "endCall", "()Z");

  /// from: public boolean endCall()
  ///
  /// Ends the foreground call on the device.
  ///
  /// If there is a ringing call, calling this method rejects the ringing call.  Otherwise the
  /// foreground call is ended.
  ///
  /// Requires permission android.Manifest.permission\#ANSWER_PHONE_CALLS.
  ///
  /// Requires android.Manifest.permission\#ANSWER_PHONE_CALLS
  ///@return {@code true} if there is a call which will be rejected or terminated, {@code false}
  /// otherwise.
  bool endCall() => jniAccessors.callMethodWithArgs(
      reference, _id_endCall, jni.JniType.booleanType, []).boolean;

  static final _id_acceptRingingCall =
      jniAccessors.getMethodIDOf(_classRef, "acceptRingingCall", "()V");

  /// from: public void acceptRingingCall()
  ///
  /// If there is a ringing incoming call, this method accepts the call on behalf of the user.
  ///
  /// If the incoming call is a video call, the call will be answered with the same video state as
  /// the incoming call requests.  This means, for example, that an incoming call requesting
  /// VideoProfile\#STATE_BIDIRECTIONAL will be answered, accepting that state.
  ///
  /// Requires permission: android.Manifest.permission\#MODIFY_PHONE_STATE or
  /// android.Manifest.permission\#ANSWER_PHONE_CALLS
  ///
  /// Requires android.Manifest.permission\#ANSWER_PHONE_CALLS or android.Manifest.permission\#MODIFY_PHONE_STATE
  void acceptRingingCall() => jniAccessors.callMethodWithArgs(
      reference, _id_acceptRingingCall, jni.JniType.voidType, []).check();

  static final _id_acceptRingingCall1 =
      jniAccessors.getMethodIDOf(_classRef, "acceptRingingCall", "(I)V");

  /// from: public void acceptRingingCall(int videoState)
  ///
  /// If there is a ringing incoming call, this method accepts the call on behalf of the user,
  /// with the specified video state.
  ///
  /// Requires permission: android.Manifest.permission\#MODIFY_PHONE_STATE or
  /// android.Manifest.permission\#ANSWER_PHONE_CALLS
  ///
  /// Requires android.Manifest.permission\#ANSWER_PHONE_CALLS or android.Manifest.permission\#MODIFY_PHONE_STATE
  ///@param videoState The desired video state to answer the call with.
  void acceptRingingCall1(int videoState) => jniAccessors.callMethodWithArgs(
      reference,
      _id_acceptRingingCall1,
      jni.JniType.voidType,
      [videoState]).check();

  static final _id_silenceRinger =
      jniAccessors.getMethodIDOf(_classRef, "silenceRinger", "()V");

  /// from: public void silenceRinger()
  ///
  /// Silences the ringer if a ringing call exists.
  ///
  /// Requires permission: android.Manifest.permission\#MODIFY_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  void silenceRinger() => jniAccessors.callMethodWithArgs(
      reference, _id_silenceRinger, jni.JniType.voidType, []).check();

  static final _id_isTtySupported =
      jniAccessors.getMethodIDOf(_classRef, "isTtySupported", "()Z");

  /// from: public boolean isTtySupported()
  ///
  /// Returns whether TTY is supported on this device.
  ///
  /// Requires android.Manifest.permission\#READ_PRIVILEGED_PHONE_STATE or android.Manifest.permission\#READ_PHONE_STATE
  bool isTtySupported() => jniAccessors.callMethodWithArgs(
      reference, _id_isTtySupported, jni.JniType.booleanType, []).boolean;

  static final _id_addNewIncomingCall = jniAccessors.getMethodIDOf(
      _classRef,
      "addNewIncomingCall",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/os/Bundle;)V");

  /// from: public void addNewIncomingCall(android.telecom.PhoneAccountHandle phoneAccount, android.os.Bundle extras)
  ///
  /// Registers a new incoming call. A ConnectionService should invoke this method when it
  /// has an incoming call. For managed ConnectionServices, the specified
  /// PhoneAccountHandle must have been registered with \#registerPhoneAccount and
  /// the user must have enabled the corresponding PhoneAccount.  This can be checked using
  /// \#getPhoneAccount. Self-managed ConnectionServices must have
  /// android.Manifest.permission\#MANAGE_OWN_CALLS to add a new incoming call.
  ///
  /// The incoming call you are adding is assumed to have a video state of
  /// VideoProfile\#STATE_AUDIO_ONLY, unless the extra value
  /// \#EXTRA_INCOMING_VIDEO_STATE is specified.
  ///
  /// Once invoked, this method will cause the system to bind to the ConnectionService
  /// associated with the PhoneAccountHandle and request additional information about the
  /// call (See ConnectionService\#onCreateIncomingConnection) before starting the incoming
  /// call UI.
  ///
  /// For a managed ConnectionService, a SecurityException will be thrown if either
  /// the PhoneAccountHandle does not correspond to a registered PhoneAccount or
  /// the associated PhoneAccount is not currently enabled by the user.
  ///
  /// For a self-managed ConnectionService, a SecurityException will be thrown if
  /// the PhoneAccount has PhoneAccount\#CAPABILITY_SELF_MANAGED and the calling app
  /// does not have android.Manifest.permission\#MANAGE_OWN_CALLS.
  ///@param phoneAccount A PhoneAccountHandle registered with
  ///            \#registerPhoneAccount.
  ///@param extras A bundle that will be passed through to
  ///            ConnectionService\#onCreateIncomingConnection.
  void addNewIncomingCall(phoneaccounthandle_.PhoneAccountHandle phoneAccount,
          bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addNewIncomingCall,
          jni.JniType.voidType,
          [phoneAccount.reference, extras.reference]).check();

  static final _id_handleMmi = jniAccessors.getMethodIDOf(
      _classRef, "handleMmi", "(Ljava/lang/String;)Z");

  /// from: public boolean handleMmi(java.lang.String dialString)
  ///
  /// Processes the specified dial string as an MMI code.
  /// MMI codes are any sequence of characters entered into the dialpad that contain a "*" or "\#".
  /// Some of these sequences launch special behavior through handled by Telephony.
  /// This method uses the default subscription.
  ///
  /// Requires that the method-caller be set as the system dialer app.
  ///
  ///
  ///
  /// Requires permission: android.Manifest.permission\#MODIFY_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  ///@param dialString The digits to dial.
  ///@return True if the digits were processed as an MMI code, false otherwise.
  bool handleMmi(jni.JniString dialString) => jniAccessors.callMethodWithArgs(
      reference,
      _id_handleMmi,
      jni.JniType.booleanType,
      [dialString.reference]).boolean;

  static final _id_handleMmi1 = jniAccessors.getMethodIDOf(_classRef,
      "handleMmi", "(Ljava/lang/String;Landroid/telecom/PhoneAccountHandle;)Z");

  /// from: public boolean handleMmi(java.lang.String dialString, android.telecom.PhoneAccountHandle accountHandle)
  ///
  /// Processes the specified dial string as an MMI code.
  /// MMI codes are any sequence of characters entered into the dialpad that contain a "*" or "\#".
  /// Some of these sequences launch special behavior through handled by Telephony.
  ///
  /// Requires that the method-caller be set as the system dialer app.
  ///
  ///
  ///
  /// Requires permission: android.Manifest.permission\#MODIFY_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  ///@param accountHandle The handle for the account the MMI code should apply to.
  ///@param dialString The digits to dial.
  ///@return True if the digits were processed as an MMI code, false otherwise.
  bool handleMmi1(jni.JniString dialString,
          phoneaccounthandle_.PhoneAccountHandle accountHandle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_handleMmi1,
          jni.JniType.booleanType,
          [dialString.reference, accountHandle.reference]).boolean;

  static final _id_getAdnUriForPhoneAccount = jniAccessors.getMethodIDOf(
      _classRef,
      "getAdnUriForPhoneAccount",
      "(Landroid/telecom/PhoneAccountHandle;)Landroid/net/Uri;");

  /// from: public android.net.Uri getAdnUriForPhoneAccount(android.telecom.PhoneAccountHandle accountHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Requires permission: android.Manifest.permission\#MODIFY_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  ///@param accountHandle The handle for the account to derive an adn query URI for or
  /// {@code null} to return a URI which will use the default account.
  ///@return The URI (with the content:// scheme) specific to the specified PhoneAccount
  /// for the the content retrieve.
  uri_.Uri getAdnUriForPhoneAccount(
          phoneaccounthandle_.PhoneAccountHandle accountHandle) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAdnUriForPhoneAccount,
          jni.JniType.objectType,
          [accountHandle.reference]).object);

  static final _id_cancelMissedCallsNotification = jniAccessors.getMethodIDOf(
      _classRef, "cancelMissedCallsNotification", "()V");

  /// from: public void cancelMissedCallsNotification()
  ///
  /// Removes the missed-call notification if one is present.
  ///
  /// Requires that the method-caller be set as the system dialer app.
  ///
  ///
  ///
  /// Requires permission: android.Manifest.permission\#MODIFY_PHONE_STATE
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  void cancelMissedCallsNotification() => jniAccessors.callMethodWithArgs(
      reference,
      _id_cancelMissedCallsNotification,
      jni.JniType.voidType, []).check();

  static final _id_showInCallScreen =
      jniAccessors.getMethodIDOf(_classRef, "showInCallScreen", "(Z)V");

  /// from: public void showInCallScreen(boolean showDialpad)
  ///
  /// Brings the in-call screen to the foreground if there is an ongoing call. If there is
  /// currently no ongoing call, then this method does nothing.
  ///
  /// Requires that the method-caller be set as the system dialer app or have the
  /// android.Manifest.permission\#READ_PHONE_STATE permission.
  ///
  ///
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param showDialpad Brings up the in-call dialpad as part of showing the in-call screen.
  void showInCallScreen(bool showDialpad) => jniAccessors.callMethodWithArgs(
      reference,
      _id_showInCallScreen,
      jni.JniType.voidType,
      [showDialpad]).check();

  static final _id_placeCall = jniAccessors.getMethodIDOf(
      _classRef, "placeCall", "(Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void placeCall(android.net.Uri address, android.os.Bundle extras)
  ///
  /// Places a new outgoing call to the provided address using the system telecom service with
  /// the specified extras.
  ///
  /// This method is equivalent to placing an outgoing call using Intent\#ACTION_CALL,
  /// except that the outgoing call will always be sent via the system telecom service. If
  /// method-caller is either the user selected default dialer app or preloaded system dialer
  /// app, then emergency calls will also be allowed.
  ///
  /// Placing a call via a managed ConnectionService requires permission:
  /// android.Manifest.permission\#CALL_PHONE
  ///
  /// Usage example:
  /// <pre>
  /// Uri uri = Uri.fromParts("tel", "12345", null);
  /// Bundle extras = new Bundle();
  /// extras.putBoolean(TelecomManager.EXTRA_START_CALL_WITH_SPEAKERPHONE, true);
  /// telecomManager.placeCall(uri, extras);
  /// </pre>
  ///
  /// The following keys are supported in the supplied extras.
  /// <ul>
  ///   <li>\#EXTRA_OUTGOING_CALL_EXTRAS</li>
  ///   <li>\#EXTRA_PHONE_ACCOUNT_HANDLE</li>
  ///   <li>\#EXTRA_START_CALL_WITH_SPEAKERPHONE</li>
  ///   <li>\#EXTRA_START_CALL_WITH_VIDEO_STATE</li>
  /// </ul>
  ///
  /// An app which implements the self-managed ConnectionService API uses
  /// \#placeCall(Uri, Bundle) to inform Telecom of a new outgoing call.  A self-managed
  /// ConnectionService must include \#EXTRA_PHONE_ACCOUNT_HANDLE to specify its
  /// associated android.telecom.PhoneAccountHandle.
  ///
  /// Self-managed ConnectionServices require permission
  /// android.Manifest.permission\#MANAGE_OWN_CALLS.
  ///
  /// Requires android.Manifest.permission\#CALL_PHONE or android.Manifest.permission\#MANAGE_OWN_CALLS
  ///@param address The address to make the call to.
  ///@param extras Bundle of extras to use with the call.
  void placeCall(uri_.Uri address, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_placeCall,
          jni.JniType.voidType, [address.reference, extras.reference]).check();

  static final _id_createManageBlockedNumbersIntent =
      jniAccessors.getMethodIDOf(_classRef, "createManageBlockedNumbersIntent",
          "()Landroid/content/Intent;");

  /// from: public android.content.Intent createManageBlockedNumbersIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the Intent which can be used with Context\#startActivity(Intent) to
  /// launch the activity to manage blocked numbers.
  ///  The activity will display the UI to manage blocked numbers only if
  /// android.provider.BlockedNumberContract\#canCurrentUserBlockNumbers(Context) returns
  /// {@code true} for the current user.
  intent_.Intent createManageBlockedNumbersIntent() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createManageBlockedNumbersIntent,
          jni.JniType.objectType, []).object);

  static final _id_isIncomingCallPermitted = jniAccessors.getMethodIDOf(
      _classRef,
      "isIncomingCallPermitted",
      "(Landroid/telecom/PhoneAccountHandle;)Z");

  /// from: public boolean isIncomingCallPermitted(android.telecom.PhoneAccountHandle phoneAccountHandle)
  ///
  /// Determines whether Telecom would permit an incoming call to be added via the
  /// \#addNewIncomingCall(PhoneAccountHandle, Bundle) API for the specified
  /// PhoneAccountHandle.
  ///
  /// A ConnectionService may not add a call for the specified PhoneAccountHandle
  /// in the following situations:
  /// <ul>
  ///     <li>PhoneAccount does not have property
  ///     PhoneAccount\#CAPABILITY_SELF_MANAGED set (i.e. it is a managed
  ///     ConnectionService), and the active or held call limit has
  ///     been reached.</li>
  ///     <li>There is an ongoing emergency call.</li>
  /// </ul>
  ///@param phoneAccountHandle The PhoneAccountHandle the call will be added for.
  ///@return {@code true} if telecom will permit an incoming call to be added, {@code false}
  ///      otherwise.
  bool isIncomingCallPermitted(
          phoneaccounthandle_.PhoneAccountHandle phoneAccountHandle) =>
      jniAccessors.callMethodWithArgs(reference, _id_isIncomingCallPermitted,
          jni.JniType.booleanType, [phoneAccountHandle.reference]).boolean;

  static final _id_isOutgoingCallPermitted = jniAccessors.getMethodIDOf(
      _classRef,
      "isOutgoingCallPermitted",
      "(Landroid/telecom/PhoneAccountHandle;)Z");

  /// from: public boolean isOutgoingCallPermitted(android.telecom.PhoneAccountHandle phoneAccountHandle)
  ///
  /// Determines whether Telecom would permit an outgoing call to be placed via the
  /// \#placeCall(Uri, Bundle) API for the specified PhoneAccountHandle.
  ///
  /// A ConnectionService may not place a call for the specified PhoneAccountHandle
  /// in the following situations:
  /// <ul>
  ///     <li>PhoneAccount does not have property
  ///     PhoneAccount\#CAPABILITY_SELF_MANAGED set (i.e. it is a managed
  ///     ConnectionService), and the active, held or ringing call limit has
  ///     been reached.</li>
  ///     <li>PhoneAccount has property PhoneAccount\#CAPABILITY_SELF_MANAGED set
  ///     (i.e. it is a self-managed ConnectionService and there is an ongoing call in
  ///     another ConnectionService.</li>
  ///     <li>There is an ongoing emergency call.</li>
  /// </ul>
  ///@param phoneAccountHandle The PhoneAccountHandle the call will be added for.
  ///@return {@code true} if telecom will permit an outgoing call to be placed, {@code false}
  ///      otherwise.
  bool isOutgoingCallPermitted(
          phoneaccounthandle_.PhoneAccountHandle phoneAccountHandle) =>
      jniAccessors.callMethodWithArgs(reference, _id_isOutgoingCallPermitted,
          jni.JniType.booleanType, [phoneAccountHandle.reference]).boolean;

  static final _id_acceptHandover = jniAccessors.getMethodIDOf(
      _classRef,
      "acceptHandover",
      "(Landroid/net/Uri;ILandroid/telecom/PhoneAccountHandle;)V");

  /// from: public void acceptHandover(android.net.Uri srcAddr, int videoState, android.telecom.PhoneAccountHandle destAcct)
  ///
  /// Called by an app to indicate that it wishes to accept the handover of an ongoing call to a
  /// PhoneAccountHandle it defines.
  ///
  /// A call handover is the process where an ongoing call is transferred from one app (i.e.
  /// ConnectionService to another app.  The user could, for example, choose to continue a
  /// mobile network call in a video calling app.  The mobile network call via the Telephony stack
  /// is referred to as the source of the handover, and the video calling app is referred to as the
  /// destination.
  ///
  /// When considering a handover scenario the _initiating_ device is where a user initiated
  /// the handover process (e.g. by calling android.telecom.Call\#handoverTo(
  /// PhoneAccountHandle, int, Bundle), and the other device is considered the _receiving_
  /// device.
  ///
  /// For a full discussion of the handover process and the APIs involved, see
  /// android.telecom.Call\#handoverTo(PhoneAccountHandle, int, Bundle).
  ///
  /// This method is called from the _receiving_ side of a handover to indicate a desire to
  /// accept the handover of an ongoing call to another ConnectionService identified by
  /// PhoneAccountHandle destAcct. For managed ConnectionServices, the specified
  /// PhoneAccountHandle must have been registered with \#registerPhoneAccount and
  /// the user must have enabled the corresponding PhoneAccount.  This can be checked using
  /// \#getPhoneAccount. Self-managed ConnectionServices must have
  /// android.Manifest.permission\#MANAGE_OWN_CALLS to handover a call to it.
  ///
  /// Once invoked, this method will cause the system to bind to the ConnectionService
  /// associated with the PhoneAccountHandle destAcct and call
  /// (See ConnectionService\#onCreateIncomingHandoverConnection).
  ///
  /// For a managed ConnectionService, a SecurityException will be thrown if either
  /// the PhoneAccountHandle destAcct does not correspond to a registered
  /// PhoneAccount or the associated PhoneAccount is not currently enabled by the
  /// user.
  ///
  /// For a self-managed ConnectionService, a SecurityException will be thrown if
  /// the calling app does not have android.Manifest.permission\#MANAGE_OWN_CALLS.
  ///@param srcAddr The android.net.Uri of the ongoing call to handover to the caller\u2019s
  ///                ConnectionService.
  ///@param videoState Video state after the handover.
  /// Value is either <code>0</code> or a combination of android.telecom.VideoProfile\#STATE_AUDIO_ONLY, android.telecom.VideoProfile\#STATE_TX_ENABLED, android.telecom.VideoProfile\#STATE_RX_ENABLED, android.telecom.VideoProfile\#STATE_BIDIRECTIONAL, and android.telecom.VideoProfile\#STATE_PAUSED
  ///@param destAcct The PhoneAccountHandle registered to the calling package.
  void acceptHandover(uri_.Uri srcAddr, int videoState,
          phoneaccounthandle_.PhoneAccountHandle destAcct) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_acceptHandover,
          jni.JniType.voidType,
          [srcAddr.reference, videoState, destAcct.reference]).check();
}
