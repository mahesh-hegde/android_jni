// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../app/Service.dart" as service_;

import "../os/IBinder.dart" as ibinder_;

import "../content/Intent.dart" as intent_;

import "RemoteConnection.dart" as remoteconnection_;

import "PhoneAccountHandle.dart" as phoneaccounthandle_;

import "ConnectionRequest.dart" as connectionrequest_;

import "Conference.dart" as conference_;

import "Connection.dart" as connection_;

import "RemoteConference.dart" as remoteconference_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telecom.ConnectionService
///
/// An abstract service that should be implemented by any apps which either:
/// <ol>
///     <li>Can make phone calls (VoIP or otherwise) and want those calls to be integrated into the
///     built-in phone app.  Referred to as a __system managed__ ConnectionService.</li>
///     <li>Are a standalone calling app and don't want their calls to be integrated into the
///     built-in phone app.  Referred to as a __self managed__ ConnectionService.</li>
/// </ol>
/// Once implemented, the ConnectionService needs to take the following steps so that Telecom
/// will bind to it:
///
/// 1. <i>Registration in AndroidManifest.xml</i>
/// <br/>
/// <pre>
/// &lt;service android:name="com.example.package.MyConnectionService"
///    android:label="@string/some_label_for_my_connection_service"
///    android:permission="android.permission.BIND_TELECOM_CONNECTION_SERVICE"&gt;
///  &lt;intent-filter&gt;
///   &lt;action android:name="android.telecom.ConnectionService" /&gt;
///  &lt;/intent-filter&gt;
/// &lt;/service&gt;
/// </pre>
///
/// 2. <i> Registration of PhoneAccount with TelecomManager.</i>
/// <br/>
/// See PhoneAccount and TelecomManager\#registerPhoneAccount for more information.
///
/// System managed ConnectionServices must be enabled by the user in the phone app settings
/// before Telecom will bind to them.  Self-manged ConnectionServices must be granted the
/// appropriate permission before Telecom will bind to them.
///
/// Once registered and enabled by the user in the phone app settings or granted permission, telecom
/// will bind to a ConnectionService implementation when it wants that
/// ConnectionService to place a call or the service has indicated that is has an incoming
/// call through TelecomManager\#addNewIncomingCall. The ConnectionService can then
/// expect a call to \#onCreateIncomingConnection or \#onCreateOutgoingConnection
/// wherein it should provide a new instance of a Connection object.  It is through this
/// Connection object that telecom receives state updates and the ConnectionService
/// receives call-commands such as answer, reject, hold and disconnect.
///
/// When there are no more live calls, telecom will unbind from the ConnectionService.
class ConnectionService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/telecom/ConnectionService");
  ConnectionService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent that must be declared as handled by the service.
  static const SERVICE_INTERFACE = "android.telecom.ConnectionService";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ConnectionService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_onUnbind = jniAccessors.getMethodIDOf(
      _classRef, "onUnbind", "(Landroid/content/Intent;)Z");

  /// from: public boolean onUnbind(android.content.Intent intent)
  ///
  /// {@inheritDoc}
  bool onUnbind(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onUnbind,
      jni.JniType.booleanType,
      [intent.reference]).boolean;

  static final _id_createRemoteIncomingConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "createRemoteIncomingConnection",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/ConnectionRequest;)Landroid/telecom/RemoteConnection;");

  /// from: public final android.telecom.RemoteConnection createRemoteIncomingConnection(android.telecom.PhoneAccountHandle connectionManagerPhoneAccount, android.telecom.ConnectionRequest request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Ask some other {@code ConnectionService} to create a {@code RemoteConnection} given an
  /// incoming request. This is used by {@code ConnectionService}s that are registered with
  /// PhoneAccount\#CAPABILITY_CONNECTION_MANAGER and want to be able to manage
  /// SIM-based incoming calls.
  ///@param connectionManagerPhoneAccount See description at
  ///         \#onCreateOutgoingConnection(PhoneAccountHandle, ConnectionRequest).
  ///@param request Details about the incoming call.
  ///@return The {@code Connection} object to satisfy this call, or {@code null} to
  ///         not handle the call.
  remoteconnection_.RemoteConnection createRemoteIncomingConnection(
          phoneaccounthandle_.PhoneAccountHandle connectionManagerPhoneAccount,
          connectionrequest_.ConnectionRequest request) =>
      remoteconnection_.RemoteConnection.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createRemoteIncomingConnection,
              jni.JniType.objectType, [
        connectionManagerPhoneAccount.reference,
        request.reference
      ]).object);

  static final _id_createRemoteOutgoingConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "createRemoteOutgoingConnection",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/ConnectionRequest;)Landroid/telecom/RemoteConnection;");

  /// from: public final android.telecom.RemoteConnection createRemoteOutgoingConnection(android.telecom.PhoneAccountHandle connectionManagerPhoneAccount, android.telecom.ConnectionRequest request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Ask some other {@code ConnectionService} to create a {@code RemoteConnection} given an
  /// outgoing request. This is used by {@code ConnectionService}s that are registered with
  /// PhoneAccount\#CAPABILITY_CONNECTION_MANAGER and want to be able to use the
  /// SIM-based {@code ConnectionService} to place its outgoing calls.
  ///@param connectionManagerPhoneAccount See description at
  ///         \#onCreateOutgoingConnection(PhoneAccountHandle, ConnectionRequest).
  ///@param request Details about the outgoing call.
  ///@return The {@code Connection} object to satisfy this call, or {@code null} to
  ///         not handle the call.
  remoteconnection_.RemoteConnection createRemoteOutgoingConnection(
          phoneaccounthandle_.PhoneAccountHandle connectionManagerPhoneAccount,
          connectionrequest_.ConnectionRequest request) =>
      remoteconnection_.RemoteConnection.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createRemoteOutgoingConnection,
              jni.JniType.objectType, [
        connectionManagerPhoneAccount.reference,
        request.reference
      ]).object);

  static final _id_conferenceRemoteConnections = jniAccessors.getMethodIDOf(
      _classRef,
      "conferenceRemoteConnections",
      "(Landroid/telecom/RemoteConnection;Landroid/telecom/RemoteConnection;)V");

  /// from: public final void conferenceRemoteConnections(android.telecom.RemoteConnection remoteConnection1, android.telecom.RemoteConnection remoteConnection2)
  ///
  /// Indicates to the relevant {@code RemoteConnectionService} that the specified
  /// RemoteConnections should be merged into a conference call.
  ///
  /// If the conference request is successful, the method \#onRemoteConferenceAdded will
  /// be invoked.
  ///@param remoteConnection1 The first of the remote connections to conference.
  ///@param remoteConnection2 The second of the remote connections to conference.
  void conferenceRemoteConnections(
          remoteconnection_.RemoteConnection remoteConnection1,
          remoteconnection_.RemoteConnection remoteConnection2) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_conferenceRemoteConnections,
          jni.JniType.voidType,
          [remoteConnection1.reference, remoteConnection2.reference]).check();

  static final _id_addConference = jniAccessors.getMethodIDOf(
      _classRef, "addConference", "(Landroid/telecom/Conference;)V");

  /// from: public final void addConference(android.telecom.Conference conference)
  ///
  /// Adds a new conference call. When a conference call is created either as a result of an
  /// explicit request via \#onConference or otherwise, the connection service should supply
  /// an instance of Conference by invoking this method. A conference call provided by this
  /// method will persist until Conference\#destroy is invoked on the conference instance.
  ///@param conference The new conference object.
  void addConference(conference_.Conference conference) =>
      jniAccessors.callMethodWithArgs(reference, _id_addConference,
          jni.JniType.voidType, [conference.reference]).check();

  static final _id_addExistingConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "addExistingConnection",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/Connection;)V");

  /// from: public final void addExistingConnection(android.telecom.PhoneAccountHandle phoneAccountHandle, android.telecom.Connection connection)
  ///
  /// Adds a connection created by the ConnectionService and informs telecom of the new
  /// connection.
  ///@param phoneAccountHandle The phone account handle for the connection.
  ///@param connection The connection to add.
  void addExistingConnection(
          phoneaccounthandle_.PhoneAccountHandle phoneAccountHandle,
          connection_.Connection connection) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addExistingConnection,
          jni.JniType.voidType,
          [phoneAccountHandle.reference, connection.reference]).check();

  static final _id_connectionServiceFocusReleased = jniAccessors.getMethodIDOf(
      _classRef, "connectionServiceFocusReleased", "()V");

  /// from: public final void connectionServiceFocusReleased()
  ///
  /// Call to inform Telecom that your ConnectionService has released call resources (e.g
  /// microphone, camera).
  ///@see ConnectionService\#onConnectionServiceFocusLost()
  void connectionServiceFocusReleased() => jniAccessors.callMethodWithArgs(
      reference,
      _id_connectionServiceFocusReleased,
      jni.JniType.voidType, []).check();

  static final _id_getAllConnections = jniAccessors.getMethodIDOf(
      _classRef, "getAllConnections", "()Ljava/util/Collection;");

  /// from: public final java.util.Collection<android.telecom.Connection> getAllConnections()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all the active {@code Connection}s for which this {@code ConnectionService}
  /// has taken responsibility.
  ///@return A collection of {@code Connection}s created by this {@code ConnectionService}.
  jni.JniObject getAllConnections() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllConnections, jni.JniType.objectType, []).object);

  static final _id_getAllConferences = jniAccessors.getMethodIDOf(
      _classRef, "getAllConferences", "()Ljava/util/Collection;");

  /// from: public final java.util.Collection<android.telecom.Conference> getAllConferences()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all the active {@code Conference}s for which this {@code ConnectionService}
  /// has taken responsibility.
  ///@return A collection of {@code Conference}s created by this {@code ConnectionService}.
  jni.JniObject getAllConferences() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllConferences, jni.JniType.objectType, []).object);

  static final _id_onCreateIncomingConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateIncomingConnection",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/ConnectionRequest;)Landroid/telecom/Connection;");

  /// from: public android.telecom.Connection onCreateIncomingConnection(android.telecom.PhoneAccountHandle connectionManagerPhoneAccount, android.telecom.ConnectionRequest request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a {@code Connection} given an incoming request. This is used to attach to existing
  /// incoming calls.
  ///@param connectionManagerPhoneAccount See description at
  ///         \#onCreateOutgoingConnection(PhoneAccountHandle, ConnectionRequest).
  ///@param request Details about the incoming call.
  ///@return The {@code Connection} object to satisfy this call, or {@code null} to
  ///         not handle the call.
  connection_.Connection onCreateIncomingConnection(
          phoneaccounthandle_.PhoneAccountHandle connectionManagerPhoneAccount,
          connectionrequest_.ConnectionRequest request) =>
      connection_.Connection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateIncomingConnection,
          jni.JniType.objectType,
          [connectionManagerPhoneAccount.reference, request.reference]).object);

  static final _id_onCreateIncomingConnectionFailed = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateIncomingConnectionFailed",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/ConnectionRequest;)V");

  /// from: public void onCreateIncomingConnectionFailed(android.telecom.PhoneAccountHandle connectionManagerPhoneAccount, android.telecom.ConnectionRequest request)
  ///
  /// Called by Telecom to inform the ConnectionService that its request to create a new
  /// incoming Connection was denied.
  ///
  /// Used when a self-managed ConnectionService attempts to create a new incoming
  /// Connection, but Telecom has determined that the call cannot be allowed at this time.
  /// The ConnectionService is responsible for silently rejecting the new incoming
  /// Connection.
  ///
  /// See TelecomManager\#isIncomingCallPermitted(PhoneAccountHandle) for more information.
  ///@param connectionManagerPhoneAccount See description at
  ///         \#onCreateOutgoingConnection(PhoneAccountHandle, ConnectionRequest).
  ///@param request The incoming connection request.
  void onCreateIncomingConnectionFailed(
          phoneaccounthandle_.PhoneAccountHandle connectionManagerPhoneAccount,
          connectionrequest_.ConnectionRequest request) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateIncomingConnectionFailed,
          jni.JniType.voidType,
          [connectionManagerPhoneAccount.reference, request.reference]).check();

  static final _id_onCreateOutgoingConnectionFailed = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateOutgoingConnectionFailed",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/ConnectionRequest;)V");

  /// from: public void onCreateOutgoingConnectionFailed(android.telecom.PhoneAccountHandle connectionManagerPhoneAccount, android.telecom.ConnectionRequest request)
  ///
  /// Called by Telecom to inform the ConnectionService that its request to create a new
  /// outgoing Connection was denied.
  ///
  /// Used when a self-managed ConnectionService attempts to create a new outgoing
  /// Connection, but Telecom has determined that the call cannot be placed at this time.
  /// The ConnectionService is responisible for informing the user that the
  /// Connection cannot be made at this time.
  ///
  /// See TelecomManager\#isOutgoingCallPermitted(PhoneAccountHandle) for more information.
  ///@param connectionManagerPhoneAccount See description at
  ///         \#onCreateOutgoingConnection(PhoneAccountHandle, ConnectionRequest).
  ///@param request The outgoing connection request.
  void onCreateOutgoingConnectionFailed(
          phoneaccounthandle_.PhoneAccountHandle connectionManagerPhoneAccount,
          connectionrequest_.ConnectionRequest request) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateOutgoingConnectionFailed,
          jni.JniType.voidType,
          [connectionManagerPhoneAccount.reference, request.reference]).check();

  static final _id_onCreateOutgoingConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateOutgoingConnection",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/ConnectionRequest;)Landroid/telecom/Connection;");

  /// from: public android.telecom.Connection onCreateOutgoingConnection(android.telecom.PhoneAccountHandle connectionManagerPhoneAccount, android.telecom.ConnectionRequest request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a {@code Connection} given an outgoing request. This is used to initiate new
  /// outgoing calls.
  ///@param connectionManagerPhoneAccount The connection manager account to use for managing
  ///         this call.
  ///
  ///         If this parameter is not {@code null}, it means that this {@code ConnectionService}
  ///         has registered one or more {@code PhoneAccount}s having
  ///         PhoneAccount\#CAPABILITY_CONNECTION_MANAGER. This parameter will contain
  ///         one of these {@code PhoneAccount}s, while the {@code request} will contain another
  ///         (usually but not always distinct) {@code PhoneAccount} to be used for actually
  ///         making the connection.
  ///
  ///         If this parameter is {@code null}, it means that this {@code ConnectionService} is
  ///         being asked to make a direct connection. The
  ///         ConnectionRequest\#getAccountHandle() of parameter {@code request} will be
  ///         a {@code PhoneAccount} registered by this {@code ConnectionService} to use for
  ///         making the connection.
  ///@param request Details about the outgoing call.
  ///@return The {@code Connection} object to satisfy this call, or the result of an invocation
  ///         of Connection\#createFailedConnection(DisconnectCause) to not handle the call.
  connection_.Connection onCreateOutgoingConnection(
          phoneaccounthandle_.PhoneAccountHandle connectionManagerPhoneAccount,
          connectionrequest_.ConnectionRequest request) =>
      connection_.Connection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateOutgoingConnection,
          jni.JniType.objectType,
          [connectionManagerPhoneAccount.reference, request.reference]).object);

  static final _id_onCreateOutgoingHandoverConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateOutgoingHandoverConnection",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/ConnectionRequest;)Landroid/telecom/Connection;");

  /// from: public android.telecom.Connection onCreateOutgoingHandoverConnection(android.telecom.PhoneAccountHandle fromPhoneAccountHandle, android.telecom.ConnectionRequest request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by Telecom to request that a ConnectionService creates an instance of an
  /// outgoing handover Connection.
  ///
  /// A call handover is the process where an ongoing call is transferred from one app (i.e.
  /// ConnectionService to another app.  The user could, for example, choose to continue a
  /// mobile network call in a video calling app.  The mobile network call via the Telephony stack
  /// is referred to as the source of the handover, and the video calling app is referred to as the
  /// destination.
  ///
  /// When considering a handover scenario the _initiating_ device is where a user initiated
  /// the handover process (e.g. by calling android.telecom.Call\#handoverTo(
  /// PhoneAccountHandle, int, Bundle), and the other device is considered the _receiving_
  /// device.
  ///
  /// This method is called on the destination ConnectionService on _initiating_
  /// device when the user initiates a handover request from one app to another.  The user request
  /// originates in the InCallService via
  /// android.telecom.Call\#handoverTo(PhoneAccountHandle, int, Bundle).
  ///
  /// For a full discussion of the handover process and the APIs involved, see
  /// android.telecom.Call\#handoverTo(PhoneAccountHandle, int, Bundle).
  ///
  /// Implementations of this method should return an instance of Connection which
  /// represents the handover.  If your app does not wish to accept a handover to it at this time,
  /// you can return {@code null}.  The code below shows an example of how this is done.
  /// <pre>
  /// {@code
  /// public Connection onCreateIncomingHandoverConnection(PhoneAccountHandle
  ///     fromPhoneAccountHandle, ConnectionRequest request) {
  ///   if (!isHandoverAvailable()) {
  ///       return null;
  ///   }
  ///   MyConnection connection = new MyConnection();
  ///   connection.setAddress(request.getAddress(), TelecomManager.PRESENTATION_ALLOWED);
  ///   connection.setVideoState(request.getVideoState());
  ///   return connection;
  /// }
  /// }
  /// </pre>
  ///@param fromPhoneAccountHandle PhoneAccountHandle associated with the
  ///                               ConnectionService which needs to handover the call.
  ///@param request Details about the call to handover.
  ///@return Connection instance corresponding to the handover call.
  connection_.Connection onCreateOutgoingHandoverConnection(
          phoneaccounthandle_.PhoneAccountHandle fromPhoneAccountHandle,
          connectionrequest_.ConnectionRequest request) =>
      connection_.Connection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateOutgoingHandoverConnection,
          jni.JniType.objectType,
          [fromPhoneAccountHandle.reference, request.reference]).object);

  static final _id_onCreateIncomingHandoverConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateIncomingHandoverConnection",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/telecom/ConnectionRequest;)Landroid/telecom/Connection;");

  /// from: public android.telecom.Connection onCreateIncomingHandoverConnection(android.telecom.PhoneAccountHandle fromPhoneAccountHandle, android.telecom.ConnectionRequest request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by Telecom to request that a ConnectionService creates an instance of an
  /// incoming handover Connection.
  ///
  /// A call handover is the process where an ongoing call is transferred from one app (i.e.
  /// ConnectionService to another app.  The user could, for example, choose to continue a
  /// mobile network call in a video calling app.  The mobile network call via the Telephony stack
  /// is referred to as the source of the handover, and the video calling app is referred to as the
  /// destination.
  ///
  /// When considering a handover scenario the _initiating_ device is where a user initiated
  /// the handover process (e.g. by calling android.telecom.Call\#handoverTo(
  /// PhoneAccountHandle, int, Bundle), and the other device is considered the _receiving_
  /// device.
  ///
  /// This method is called on the destination app on the _receiving_ device when the
  /// destination app calls TelecomManager\#acceptHandover(Uri, int, PhoneAccountHandle) to
  /// accept an incoming handover from the _initiating_ device.
  ///
  /// For a full discussion of the handover process and the APIs involved, see
  /// android.telecom.Call\#handoverTo(PhoneAccountHandle, int, Bundle).
  ///
  /// Implementations of this method should return an instance of Connection which
  /// represents the handover.  The code below shows an example of how this is done.
  /// <pre>
  /// {@code
  /// public Connection onCreateIncomingHandoverConnection(PhoneAccountHandle
  ///     fromPhoneAccountHandle, ConnectionRequest request) {
  ///   // Given that your app requested to accept the handover, you should not return null here.
  ///   MyConnection connection = new MyConnection();
  ///   connection.setAddress(request.getAddress(), TelecomManager.PRESENTATION_ALLOWED);
  ///   connection.setVideoState(request.getVideoState());
  ///   return connection;
  /// }
  /// }
  /// </pre>
  ///@param fromPhoneAccountHandle PhoneAccountHandle associated with the
  ///                               ConnectionService which needs to handover the call.
  ///@param request Details about the call which needs to be handover.
  ///@return Connection instance corresponding to the handover call.
  connection_.Connection onCreateIncomingHandoverConnection(
          phoneaccounthandle_.PhoneAccountHandle fromPhoneAccountHandle,
          connectionrequest_.ConnectionRequest request) =>
      connection_.Connection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateIncomingHandoverConnection,
          jni.JniType.objectType,
          [fromPhoneAccountHandle.reference, request.reference]).object);

  static final _id_onHandoverFailed = jniAccessors.getMethodIDOf(
      _classRef, "onHandoverFailed", "(Landroid/telecom/ConnectionRequest;I)V");

  /// from: public void onHandoverFailed(android.telecom.ConnectionRequest request, int error)
  ///
  /// Called by Telecom in response to a {@code TelecomManager\#acceptHandover()}
  /// invocation which failed.
  ///
  /// For a full discussion of the handover process and the APIs involved, see
  /// android.telecom.Call\#handoverTo(PhoneAccountHandle, int, Bundle)
  ///@param request Details about the call which failed to handover.
  ///@param error Reason for handover failure.  Will be one of the
  ///
  /// Value is android.telecom.Call.Callback\#HANDOVER_FAILURE_DEST_APP_REJECTED, android.telecom.Call.Callback\#HANDOVER_FAILURE_NOT_SUPPORTED, android.telecom.Call.Callback\#HANDOVER_FAILURE_USER_REJECTED, android.telecom.Call.Callback\#HANDOVER_FAILURE_ONGOING_EMERGENCY_CALL, or android.telecom.Call.Callback\#HANDOVER_FAILURE_UNKNOWN
  void onHandoverFailed(
          connectionrequest_.ConnectionRequest request, int error) =>
      jniAccessors.callMethodWithArgs(reference, _id_onHandoverFailed,
          jni.JniType.voidType, [request.reference, error]).check();

  static final _id_onConference = jniAccessors.getMethodIDOf(
      _classRef,
      "onConference",
      "(Landroid/telecom/Connection;Landroid/telecom/Connection;)V");

  /// from: public void onConference(android.telecom.Connection connection1, android.telecom.Connection connection2)
  ///
  /// Conference two specified connections. Invoked when the user has made a request to merge the
  /// specified connections into a conference call. In response, the connection service should
  /// create an instance of Conference and pass it into \#addConference.
  ///@param connection1 A connection to merge into a conference call.
  ///@param connection2 A connection to merge into a conference call.
  void onConference(connection_.Connection connection1,
          connection_.Connection connection2) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onConference,
          jni.JniType.voidType,
          [connection1.reference, connection2.reference]).check();

  static final _id_onRemoteConferenceAdded = jniAccessors.getMethodIDOf(
      _classRef,
      "onRemoteConferenceAdded",
      "(Landroid/telecom/RemoteConference;)V");

  /// from: public void onRemoteConferenceAdded(android.telecom.RemoteConference conference)
  ///
  /// Indicates that a remote conference has been created for existing RemoteConnections.
  /// When this method is invoked, this ConnectionService should create its own
  /// representation of the conference call and send it to telecom using \#addConference.
  ///
  /// This is only relevant to ConnectionServices which are registered with
  /// PhoneAccount\#CAPABILITY_CONNECTION_MANAGER.
  ///@param conference The remote conference call.
  void onRemoteConferenceAdded(remoteconference_.RemoteConference conference) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRemoteConferenceAdded,
          jni.JniType.voidType, [conference.reference]).check();

  static final _id_onRemoteExistingConnectionAdded = jniAccessors.getMethodIDOf(
      _classRef,
      "onRemoteExistingConnectionAdded",
      "(Landroid/telecom/RemoteConnection;)V");

  /// from: public void onRemoteExistingConnectionAdded(android.telecom.RemoteConnection connection)
  ///
  /// Called when an existing connection is added remotely.
  ///@param connection The existing connection which was added.
  void onRemoteExistingConnectionAdded(
          remoteconnection_.RemoteConnection connection) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRemoteExistingConnectionAdded,
          jni.JniType.voidType,
          [connection.reference]).check();

  static final _id_onConnectionServiceFocusLost = jniAccessors.getMethodIDOf(
      _classRef, "onConnectionServiceFocusLost", "()V");

  /// from: public void onConnectionServiceFocusLost()
  ///
  /// Called when the ConnectionService has lost the call focus.
  /// The ConnectionService should release the call resources and invokes
  /// ConnectionService\#connectionServiceFocusReleased() to inform telecom that it has
  /// released the call resources.
  void onConnectionServiceFocusLost() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onConnectionServiceFocusLost,
      jni.JniType.voidType, []).check();

  static final _id_onConnectionServiceFocusGained = jniAccessors.getMethodIDOf(
      _classRef, "onConnectionServiceFocusGained", "()V");

  /// from: public void onConnectionServiceFocusGained()
  ///
  /// Called when the ConnectionService has gained the call focus. The
  /// ConnectionService can acquire the call resources at this time.
  void onConnectionServiceFocusGained() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onConnectionServiceFocusGained,
      jni.JniType.voidType, []).check();
}
