// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "TimeInterpolator.dart" as timeinterpolator_;

import "Animator.dart" as animator_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../view/View.dart" as view_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.animation.LayoutTransition
///
/// This class enables automatic animations on layout changes in ViewGroup objects. To enable
/// transitions for a layout container, create a LayoutTransition object and set it on any
/// ViewGroup by calling ViewGroup\#setLayoutTransition(LayoutTransition). This will cause
/// default animations to run whenever items are added to or removed from that container. To specify
/// custom animations, use the LayoutTransition\#setAnimator(int, Animator) setAnimator() method.
///
/// One of the core concepts of these transition animations is that there are two types of
/// changes that cause the transition and four different animations that run because of
/// those changes. The changes that trigger the transition are items being added to a container
/// (referred to as an "appearing" transition) or removed from a container (also known as
/// "disappearing"). Setting the visibility of views (between GONE and VISIBLE) will trigger
/// the same add/remove logic. The animations that run due to those events are one that animates
/// items being added, one that animates items being removed, and two that animate the other
/// items in the container that change due to the add/remove occurrence. Users of
/// the transition may want different animations for the changing items depending on whether
/// they are changing due to an appearing or disappearing event, so there is one animation for
/// each of these variations of the changing event. Most of the API of this class is concerned
/// with setting up the basic properties of the animations used in these four situations,
/// or with setting up custom animations for any or all of the four.
///
///
/// By default, the DISAPPEARING animation begins immediately, as does the CHANGE_APPEARING
/// animation. The other animations begin after a delay that is set to the default duration
/// of the animations. This behavior facilitates a sequence of animations in transitions as
/// follows: when an item is being added to a layout, the other children of that container will
/// move first (thus creating space for the new item), then the appearing animation will run to
/// animate the item being added. Conversely, when an item is removed from a container, the
/// animation to remove it will run first, then the animations of the other children in the
/// layout will run (closing the gap created in the layout when the item was removed). If this
/// default choreography behavior is not desired, the \#setDuration(int, long) and
/// \#setStartDelay(int, long) of any or all of the animations can be changed as
/// appropriate. Keep in mind, however, that if you start an APPEARING animation before a
/// DISAPPEARING animation is completed, the DISAPPEARING animation stops, and any effects from
/// the DISAPPEARING animation are reverted. If you instead start a DISAPPEARING animation
/// before an APPEARING animation is completed, a similar set of effects occurs for the
/// APPEARING animation.
///
///
/// The animations specified for the transition, both the defaults and any custom animations
/// set on the transition object, are templates only. That is, these animations exist to hold the
/// basic animation properties, such as the duration, start delay, and properties being animated.
/// But the actual target object, as well as the start and end values for those properties, are
/// set automatically in the process of setting up the transition each time it runs. Each of the
/// animations is cloned from the original copy and the clone is then populated with the dynamic
/// values of the target being animated (such as one of the items in a layout container that is
/// moving as a result of the layout event) as well as the values that are changing (such as the
/// position and size of that object). The actual values that are pushed to each animation
/// depends on what properties are specified for the animation. For example, the default
/// CHANGE_APPEARING animation animates the <code>left</code>, <code>top</code>, <code>right</code>,
/// <code>bottom</code>, <code>scrollX</code>, and <code>scrollY</code> properties.
/// Values for these properties are updated with the pre- and post-layout
/// values when the transition begins. Custom animations will be similarly populated with
/// the target and values being animated, assuming they use ObjectAnimator objects with
/// property names that are known on the target object.
///
///
/// This class, and the associated XML flag for containers, animateLayoutChanges="true",
/// provides a simple utility meant for automating changes in straightforward situations.
/// Using LayoutTransition at multiple levels of a nested view hierarchy may not work due to the
/// interrelationship of the various levels of layout. Also, a container that is being scrolled
/// at the same time as items are being added or removed is probably not a good candidate for
/// this utility, because the before/after locations calculated by LayoutTransition
/// may not match the actual locations when the animations finish due to the container
/// being scrolled as the animations are running. You can work around that
/// particular issue by disabling the 'changing' animations by setting the CHANGE_APPEARING
/// and CHANGE_DISAPPEARING animations to null, and setting the startDelay of the
/// other animations appropriately.
///
class LayoutTransition extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/animation/LayoutTransition");
  LayoutTransition.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int APPEARING
  ///
  /// A flag indicating the animation that runs on those items that are appearing
  /// in the container.
  static const APPEARING = 2;

  /// from: static public final int CHANGE_APPEARING
  ///
  /// A flag indicating the animation that runs on those items that are changing
  /// due to a new item appearing in the container.
  static const CHANGE_APPEARING = 0;

  /// from: static public final int CHANGE_DISAPPEARING
  ///
  /// A flag indicating the animation that runs on those items that are changing
  /// due to an item disappearing from the container.
  static const CHANGE_DISAPPEARING = 1;

  /// from: static public final int CHANGING
  ///
  /// A flag indicating the animation that runs on those items that are changing
  /// due to a layout change not caused by items being added to or removed
  /// from the container. This transition type is not enabled by default; it can be
  /// enabled via \#enableTransitionType(int).
  static const CHANGING = 4;

  /// from: static public final int DISAPPEARING
  ///
  /// A flag indicating the animation that runs on those items that are disappearing
  /// from the container.
  static const DISAPPEARING = 3;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a LayoutTransition object. By default, the object will listen to layout
  /// events on any ViewGroup that it is set on and will run default animations for each
  /// type of layout event.
  LayoutTransition()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setDuration =
      jniAccessors.getMethodIDOf(_classRef, "setDuration", "(J)V");

  /// from: public void setDuration(long duration)
  ///
  /// Sets the duration to be used by all animations of this transition object. If you want to
  /// set the duration of just one of the animations in particular, use the
  /// \#setDuration(int, long) method.
  ///@param duration The length of time, in milliseconds, that the transition animations
  /// should last.
  void setDuration(int duration) => jniAccessors.callMethodWithArgs(
      reference, _id_setDuration, jni.JniType.voidType, [duration]).check();

  static final _id_enableTransitionType =
      jniAccessors.getMethodIDOf(_classRef, "enableTransitionType", "(I)V");

  /// from: public void enableTransitionType(int transitionType)
  ///
  /// Enables the specified transitionType for this LayoutTransition object.
  /// By default, a LayoutTransition listens for changes in children being
  /// added/remove/hidden/shown in the container, and runs the animations associated with
  /// those events. That is, all transition types besides \#CHANGING are enabled by default.
  /// You can also enable \#CHANGING animations by calling this method with the
  /// \#CHANGING transitionType.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING.
  void enableTransitionType(int transitionType) =>
      jniAccessors.callMethodWithArgs(reference, _id_enableTransitionType,
          jni.JniType.voidType, [transitionType]).check();

  static final _id_disableTransitionType =
      jniAccessors.getMethodIDOf(_classRef, "disableTransitionType", "(I)V");

  /// from: public void disableTransitionType(int transitionType)
  ///
  /// Disables the specified transitionType for this LayoutTransition object.
  /// By default, all transition types except \#CHANGING are enabled.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING.
  void disableTransitionType(int transitionType) =>
      jniAccessors.callMethodWithArgs(reference, _id_disableTransitionType,
          jni.JniType.voidType, [transitionType]).check();

  static final _id_isTransitionTypeEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isTransitionTypeEnabled", "(I)Z");

  /// from: public boolean isTransitionTypeEnabled(int transitionType)
  ///
  /// Returns whether the specified transitionType is enabled for this LayoutTransition object.
  /// By default, all transition types except \#CHANGING are enabled.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING.
  ///@return true if the specified transitionType is currently enabled, false otherwise.
  bool isTransitionTypeEnabled(int transitionType) =>
      jniAccessors.callMethodWithArgs(reference, _id_isTransitionTypeEnabled,
          jni.JniType.booleanType, [transitionType]).boolean;

  static final _id_setStartDelay =
      jniAccessors.getMethodIDOf(_classRef, "setStartDelay", "(IJ)V");

  /// from: public void setStartDelay(int transitionType, long delay)
  ///
  /// Sets the start delay on one of the animation objects used by this transition. The
  /// <code>transitionType</code> parameter determines the animation whose start delay
  /// is being set.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING, which determines
  /// the animation whose start delay is being set.
  ///@param delay The length of time, in milliseconds, to delay before starting the animation.
  ///@see Animator\#setStartDelay(long)
  void setStartDelay(int transitionType, int delay) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStartDelay,
          jni.JniType.voidType, [transitionType, delay]).check();

  static final _id_getStartDelay =
      jniAccessors.getMethodIDOf(_classRef, "getStartDelay", "(I)J");

  /// from: public long getStartDelay(int transitionType)
  ///
  /// Gets the start delay on one of the animation objects used by this transition. The
  /// <code>transitionType</code> parameter determines the animation whose start delay
  /// is returned.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING, which determines
  /// the animation whose start delay is returned.
  ///@return long The start delay of the specified animation.
  ///@see Animator\#getStartDelay()
  int getStartDelay(int transitionType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getStartDelay,
      jni.JniType.longType,
      [transitionType]).long;

  static final _id_setDuration1 =
      jniAccessors.getMethodIDOf(_classRef, "setDuration", "(IJ)V");

  /// from: public void setDuration(int transitionType, long duration)
  ///
  /// Sets the duration on one of the animation objects used by this transition. The
  /// <code>transitionType</code> parameter determines the animation whose duration
  /// is being set.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING, which determines
  /// the animation whose duration is being set.
  ///@param duration The length of time, in milliseconds, that the specified animation should run.
  ///@see Animator\#setDuration(long)
  void setDuration1(int transitionType, int duration) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDuration1,
          jni.JniType.voidType, [transitionType, duration]).check();

  static final _id_getDuration =
      jniAccessors.getMethodIDOf(_classRef, "getDuration", "(I)J");

  /// from: public long getDuration(int transitionType)
  ///
  /// Gets the duration on one of the animation objects used by this transition. The
  /// <code>transitionType</code> parameter determines the animation whose duration
  /// is returned.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING, which determines
  /// the animation whose duration is returned.
  ///@return long The duration of the specified animation.
  ///@see Animator\#getDuration()
  int getDuration(int transitionType) => jniAccessors.callMethodWithArgs(
      reference, _id_getDuration, jni.JniType.longType, [transitionType]).long;

  static final _id_setStagger =
      jniAccessors.getMethodIDOf(_classRef, "setStagger", "(IJ)V");

  /// from: public void setStagger(int transitionType, long duration)
  ///
  /// Sets the length of time to delay between starting each animation during one of the
  /// change animations.
  ///@param transitionType A value of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING, or
  /// \#CHANGING.
  ///@param duration The length of time, in milliseconds, to delay before launching the next
  /// animation in the sequence.
  void setStagger(int transitionType, int duration) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStagger,
          jni.JniType.voidType, [transitionType, duration]).check();

  static final _id_getStagger =
      jniAccessors.getMethodIDOf(_classRef, "getStagger", "(I)J");

  /// from: public long getStagger(int transitionType)
  ///
  /// Gets the length of time to delay between starting each animation during one of the
  /// change animations.
  ///@param transitionType A value of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING, or
  /// \#CHANGING.
  ///@return long The length of time, in milliseconds, to delay before launching the next
  /// animation in the sequence.
  int getStagger(int transitionType) => jniAccessors.callMethodWithArgs(
      reference, _id_getStagger, jni.JniType.longType, [transitionType]).long;

  static final _id_setInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "setInterpolator", "(ILandroid/animation/TimeInterpolator;)V");

  /// from: public void setInterpolator(int transitionType, android.animation.TimeInterpolator interpolator)
  ///
  /// Sets the interpolator on one of the animation objects used by this transition. The
  /// <code>transitionType</code> parameter determines the animation whose interpolator
  /// is being set.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING, which determines
  /// the animation whose interpolator is being set.
  ///@param interpolator The interpolator that the specified animation should use.
  ///@see Animator\#setInterpolator(TimeInterpolator)
  void setInterpolator(int transitionType,
          timeinterpolator_.TimeInterpolator interpolator) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setInterpolator,
          jni.JniType.voidType,
          [transitionType, interpolator.reference]).check();

  static final _id_getInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "getInterpolator", "(I)Landroid/animation/TimeInterpolator;");

  /// from: public android.animation.TimeInterpolator getInterpolator(int transitionType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the interpolator on one of the animation objects used by this transition. The
  /// <code>transitionType</code> parameter determines the animation whose interpolator
  /// is returned.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING, which determines
  /// the animation whose interpolator is being returned.
  ///@return TimeInterpolator The interpolator that the specified animation uses.
  ///@see Animator\#setInterpolator(TimeInterpolator)
  timeinterpolator_.TimeInterpolator getInterpolator(int transitionType) =>
      timeinterpolator_.TimeInterpolator.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getInterpolator,
              jni.JniType.objectType, [transitionType]).object);

  static final _id_setAnimator = jniAccessors.getMethodIDOf(
      _classRef, "setAnimator", "(ILandroid/animation/Animator;)V");

  /// from: public void setAnimator(int transitionType, android.animation.Animator animator)
  ///
  /// Sets the animation used during one of the transition types that may run. Any
  /// Animator object can be used, but to be most useful in the context of layout
  /// transitions, the animation should either be a ObjectAnimator or a AnimatorSet
  /// of animations including PropertyAnimators. Also, these ObjectAnimator objects
  /// should be able to get and set values on their target objects automatically. For
  /// example, a ObjectAnimator that animates the property "left" is able to set and get the
  /// <code>left</code> property from the View objects being animated by the layout
  /// transition. The transition works by setting target objects and properties
  /// dynamically, according to the pre- and post-layoout values of those objects, so
  /// having animations that can handle those properties appropriately will work best
  /// for custom animation. The dynamic setting of values is only the case for the
  /// CHANGE animations; the APPEARING and DISAPPEARING animations are simply run with
  /// the values they have.
  ///
  /// It is also worth noting that any and all animations (and their underlying
  /// PropertyValuesHolder objects) will have their start and end values set according
  /// to the pre- and post-layout values. So, for example, a custom animation on "alpha"
  /// as the CHANGE_APPEARING animation will inherit the real value of alpha on the target
  /// object (presumably 1) as its starting and ending value when the animation begins.
  /// Animations which need to use values at the beginning and end that may not match the
  /// values queried when the transition begins may need to use a different mechanism
  /// than a standard ObjectAnimator object.
  ///
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING, which determines the
  /// animation whose animator is being set.
  ///@param animator The animation being assigned. A value of <code>null</code> means that no
  /// animation will be run for the specified transitionType.
  void setAnimator(int transitionType, animator_.Animator animator) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAnimator,
          jni.JniType.voidType, [transitionType, animator.reference]).check();

  static final _id_getAnimator = jniAccessors.getMethodIDOf(
      _classRef, "getAnimator", "(I)Landroid/animation/Animator;");

  /// from: public android.animation.Animator getAnimator(int transitionType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the animation used during one of the transition types that may run.
  ///@param transitionType One of \#CHANGE_APPEARING, \#CHANGE_DISAPPEARING,
  /// \#CHANGING, \#APPEARING, or \#DISAPPEARING, which determines
  /// the animation whose animator is being returned.
  ///@return Animator The animation being used for the given transition type.
  ///@see \#setAnimator(int, Animator)
  animator_.Animator getAnimator(int transitionType) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAnimator, jni.JniType.objectType, [transitionType]).object);

  static final _id_setAnimateParentHierarchy = jniAccessors.getMethodIDOf(
      _classRef, "setAnimateParentHierarchy", "(Z)V");

  /// from: public void setAnimateParentHierarchy(boolean animateParentHierarchy)
  ///
  /// This flag controls whether CHANGE_APPEARING or CHANGE_DISAPPEARING animations will
  /// cause the default changing animation to be run on the parent hierarchy as well. This allows
  /// containers of transitioning views to also transition, which may be necessary in situations
  /// where the containers bounds change between the before/after states and may clip their
  /// children during the transition animations. For example, layouts with wrap_content will
  /// adjust their bounds according to the dimensions of their children.
  ///
  /// The default changing transitions animate the bounds and scroll positions of the
  /// target views. These are the animations that will run on the parent hierarchy, not
  /// the custom animations that happen to be set on the transition. This allows custom
  /// behavior for the children of the transitioning container, but uses standard behavior
  /// of resizing/rescrolling on any changing parents.
  ///@param animateParentHierarchy A boolean value indicating whether the parents of
  /// transitioning views should also be animated during the transition. Default value is true.
  void setAnimateParentHierarchy(bool animateParentHierarchy) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAnimateParentHierarchy,
          jni.JniType.voidType, [animateParentHierarchy]).check();

  static final _id_isChangingLayout =
      jniAccessors.getMethodIDOf(_classRef, "isChangingLayout", "()Z");

  /// from: public boolean isChangingLayout()
  ///
  /// Returns true if animations are running which animate layout-related properties. This
  /// essentially means that either CHANGE_APPEARING or CHANGE_DISAPPEARING animations
  /// are running, since these animations operate on layout-related properties.
  ///@return true if CHANGE_APPEARING or CHANGE_DISAPPEARING animations are currently
  /// running.
  bool isChangingLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_isChangingLayout, jni.JniType.booleanType, []).boolean;

  static final _id_isRunning =
      jniAccessors.getMethodIDOf(_classRef, "isRunning", "()Z");

  /// from: public boolean isRunning()
  ///
  /// Returns true if any of the animations in this transition are currently running.
  ///@return true if any animations in the transition are running.
  bool isRunning() => jniAccessors.callMethodWithArgs(
      reference, _id_isRunning, jni.JniType.booleanType, []).boolean;

  static final _id_addChild = jniAccessors.getMethodIDOf(
      _classRef, "addChild", "(Landroid/view/ViewGroup;Landroid/view/View;)V");

  /// from: public void addChild(android.view.ViewGroup parent, android.view.View child)
  ///
  /// This method is called by ViewGroup when a child view is about to be added to the
  /// container. This callback starts the process of a transition; we grab the starting
  /// values, listen for changes to all of the children of the container, and start appropriate
  /// animations.
  ///@param parent The ViewGroup to which the View is being added.
  ///@param child The View being added to the ViewGroup.
  void addChild(viewgroup_.ViewGroup parent, view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_addChild,
          jni.JniType.voidType, [parent.reference, child.reference]).check();

  static final _id_showChild = jniAccessors.getMethodIDOf(
      _classRef, "showChild", "(Landroid/view/ViewGroup;Landroid/view/View;)V");

  /// from: public void showChild(android.view.ViewGroup parent, android.view.View child)
  ///
  /// @deprecated Use \#showChild(android.view.ViewGroup, android.view.View, int).
  void showChild(viewgroup_.ViewGroup parent, view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_showChild,
          jni.JniType.voidType, [parent.reference, child.reference]).check();

  static final _id_showChild1 = jniAccessors.getMethodIDOf(_classRef,
      "showChild", "(Landroid/view/ViewGroup;Landroid/view/View;I)V");

  /// from: public void showChild(android.view.ViewGroup parent, android.view.View child, int oldVisibility)
  ///
  /// This method is called by ViewGroup when a child view is about to be made visible in the
  /// container. This callback starts the process of a transition; we grab the starting
  /// values, listen for changes to all of the children of the container, and start appropriate
  /// animations.
  ///@param parent The ViewGroup in which the View is being made visible.
  ///@param child The View being made visible.
  ///@param oldVisibility The previous visibility value of the child View, either
  /// View\#GONE or View\#INVISIBLE.
  void showChild1(
          viewgroup_.ViewGroup parent, view_.View child, int oldVisibility) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_showChild1,
          jni.JniType.voidType,
          [parent.reference, child.reference, oldVisibility]).check();

  static final _id_removeChild = jniAccessors.getMethodIDOf(_classRef,
      "removeChild", "(Landroid/view/ViewGroup;Landroid/view/View;)V");

  /// from: public void removeChild(android.view.ViewGroup parent, android.view.View child)
  ///
  /// This method is called by ViewGroup when a child view is about to be removed from the
  /// container. This callback starts the process of a transition; we grab the starting
  /// values, listen for changes to all of the children of the container, and start appropriate
  /// animations.
  ///@param parent The ViewGroup from which the View is being removed.
  ///@param child The View being removed from the ViewGroup.
  void removeChild(viewgroup_.ViewGroup parent, view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeChild,
          jni.JniType.voidType, [parent.reference, child.reference]).check();

  static final _id_hideChild = jniAccessors.getMethodIDOf(
      _classRef, "hideChild", "(Landroid/view/ViewGroup;Landroid/view/View;)V");

  /// from: public void hideChild(android.view.ViewGroup parent, android.view.View child)
  ///
  /// @deprecated Use \#hideChild(android.view.ViewGroup, android.view.View, int).
  void hideChild(viewgroup_.ViewGroup parent, view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_hideChild,
          jni.JniType.voidType, [parent.reference, child.reference]).check();

  static final _id_hideChild1 = jniAccessors.getMethodIDOf(_classRef,
      "hideChild", "(Landroid/view/ViewGroup;Landroid/view/View;I)V");

  /// from: public void hideChild(android.view.ViewGroup parent, android.view.View child, int newVisibility)
  ///
  /// This method is called by ViewGroup when a child view is about to be hidden in
  /// container. This callback starts the process of a transition; we grab the starting
  /// values, listen for changes to all of the children of the container, and start appropriate
  /// animations.
  ///@param parent The parent ViewGroup of the View being hidden.
  ///@param child The View being hidden.
  ///@param newVisibility The new visibility value of the child View, either
  /// View\#GONE or View\#INVISIBLE.
  void hideChild1(
          viewgroup_.ViewGroup parent, view_.View child, int newVisibility) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_hideChild1,
          jni.JniType.voidType,
          [parent.reference, child.reference, newVisibility]).check();

  static final _id_addTransitionListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addTransitionListener",
      "(Landroid/animation/LayoutTransition\$TransitionListener;)V");

  /// from: public void addTransitionListener(android.animation.LayoutTransition.TransitionListener listener)
  ///
  /// Add a listener that will be called when the bounds of the view change due to
  /// layout processing.
  ///@param listener The listener that will be called when layout bounds change.
  void addTransitionListener(LayoutTransition_TransitionListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addTransitionListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_removeTransitionListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeTransitionListener",
      "(Landroid/animation/LayoutTransition\$TransitionListener;)V");

  /// from: public void removeTransitionListener(android.animation.LayoutTransition.TransitionListener listener)
  ///
  /// Remove a listener for layout changes.
  ///@param listener The listener for layout bounds change.
  void removeTransitionListener(LayoutTransition_TransitionListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeTransitionListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_getTransitionListeners = jniAccessors.getMethodIDOf(
      _classRef, "getTransitionListeners", "()Ljava/util/List;");

  /// from: public java.util.List<android.animation.LayoutTransition.TransitionListener> getTransitionListeners()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current list of listeners for layout changes.
  ///@return
  jni.JniObject getTransitionListeners() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTransitionListeners, jni.JniType.objectType, []).object);
}

/// from: android.animation.LayoutTransition$TransitionListener
///
/// This interface is used for listening to starting and ending events for transitions.
class LayoutTransition_TransitionListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/animation/LayoutTransition\$TransitionListener");
  LayoutTransition_TransitionListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_startTransition = jniAccessors.getMethodIDOf(
      _classRef,
      "startTransition",
      "(Landroid/animation/LayoutTransition;Landroid/view/ViewGroup;Landroid/view/View;I)V");

  /// from: public abstract void startTransition(android.animation.LayoutTransition transition, android.view.ViewGroup container, android.view.View view, int transitionType)
  ///
  /// This event is sent to listeners when any type of transition animation begins.
  ///@param transition The LayoutTransition sending out the event.
  ///@param container The ViewGroup on which the transition is playing.
  ///@param view The View object being affected by the transition animation.
  ///@param transitionType The type of transition that is beginning,
  /// android.animation.LayoutTransition\#APPEARING,
  /// android.animation.LayoutTransition\#DISAPPEARING,
  /// android.animation.LayoutTransition\#CHANGE_APPEARING, or
  /// android.animation.LayoutTransition\#CHANGE_DISAPPEARING.
  void startTransition(
          LayoutTransition transition,
          viewgroup_.ViewGroup container,
          view_.View view,
          int transitionType) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startTransition, jni.JniType.voidType, [
        transition.reference,
        container.reference,
        view.reference,
        transitionType
      ]).check();

  static final _id_endTransition = jniAccessors.getMethodIDOf(
      _classRef,
      "endTransition",
      "(Landroid/animation/LayoutTransition;Landroid/view/ViewGroup;Landroid/view/View;I)V");

  /// from: public abstract void endTransition(android.animation.LayoutTransition transition, android.view.ViewGroup container, android.view.View view, int transitionType)
  ///
  /// This event is sent to listeners when any type of transition animation ends.
  ///@param transition The LayoutTransition sending out the event.
  ///@param container The ViewGroup on which the transition is playing.
  ///@param view The View object being affected by the transition animation.
  ///@param transitionType The type of transition that is ending,
  /// android.animation.LayoutTransition\#APPEARING,
  /// android.animation.LayoutTransition\#DISAPPEARING,
  /// android.animation.LayoutTransition\#CHANGE_APPEARING, or
  /// android.animation.LayoutTransition\#CHANGE_DISAPPEARING.
  void endTransition(
          LayoutTransition transition,
          viewgroup_.ViewGroup container,
          view_.View view,
          int transitionType) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_endTransition, jni.JniType.voidType, [
        transition.reference,
        container.reference,
        view.reference,
        transitionType
      ]).check();
}
