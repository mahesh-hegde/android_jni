// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Animator.dart" as animator_;

import "TypeEvaluator.dart" as typeevaluator_;

import "TimeInterpolator.dart" as timeinterpolator_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.animation.ValueAnimator
///
/// This class provides a simple timing engine for running animations
/// which calculate animated values and set them on target objects.
///
/// There is a single timing pulse that all animations use. It runs in a
/// custom handler to ensure that property changes happen on the UI thread.
///
///
/// By default, ValueAnimator uses non-linear time interpolation, via the
/// AccelerateDecelerateInterpolator class, which accelerates into and decelerates
/// out of an animation. This behavior can be changed by calling
/// ValueAnimator\#setInterpolator(TimeInterpolator).
///
///
/// Animators can be created from either code or resource files. Here is an example
/// of a ValueAnimator resource file:
///
///
/// {@sample development/samples/ApiDemos/res/anim/animator.xml ValueAnimatorResources}
///
/// Starting from API 23, it is also possible to use a combination of PropertyValuesHolder
/// and Keyframe resource tags to create a multi-step animation.
/// Note that you can specify explicit fractional values (from 0 to 1) for
/// each keyframe to determine when, in the overall duration, the animation should arrive at that
/// value. Alternatively, you can leave the fractions off and the keyframes will be equally
/// distributed within the total duration:
///
///
/// {@sample development/samples/ApiDemos/res/anim/value_animator_pvh_kf.xml
/// ValueAnimatorKeyframeResources}
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about animating with {@code ValueAnimator}, read the
/// <a href="{@docRoot}guide/topics/graphics/prop-animation.html\#value-animator">Property
/// Animation</a> developer guide.
///
/// </div>
class ValueAnimator extends animator_.Animator {
  static final _classRef =
      jniAccessors.getClassOf("android/animation/ValueAnimator");
  ValueAnimator.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int INFINITE
  ///
  /// This value used used with the \#setRepeatCount(int) property to repeat
  /// the animation indefinitely.
  static const INFINITE = -1;

  /// from: static public final int RESTART
  ///
  /// When the animation reaches the end and <code>repeatCount</code> is INFINITE
  /// or a positive value, the animation restarts from the beginning.
  static const RESTART = 1;

  /// from: static public final int REVERSE
  ///
  /// When the animation reaches the end and <code>repeatCount</code> is INFINITE
  /// or a positive value, the animation reverses direction on every iteration.
  static const REVERSE = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ValueAnimator object. This default constructor is primarily for
  /// use internally; the factory methods which take parameters are more generally
  /// useful.
  ValueAnimator()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_areAnimatorsEnabled =
      jniAccessors.getStaticMethodIDOf(_classRef, "areAnimatorsEnabled", "()Z");

  /// from: static public boolean areAnimatorsEnabled()
  ///
  /// Returns whether animators are currently enabled, system-wide. By default, all
  /// animators are enabled. This can change if either the user sets a Developer Option
  /// to set the animator duration scale to 0 or by Battery Savery mode being enabled
  /// (which disables all animations).
  ///
  /// Developers should not typically need to call this method, but should an app wish
  /// to show a different experience when animators are disabled, this return value
  /// can be used as a decider of which experience to offer.
  ///@return boolean Whether animators are currently enabled. The default value is
  /// <code>true</code>.
  static bool areAnimatorsEnabled() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_areAnimatorsEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_ofInt = jniAccessors.getStaticMethodIDOf(
      _classRef, "ofInt", "([I)Landroid/animation/ValueAnimator;");

  /// from: static public android.animation.ValueAnimator ofInt(int[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs and returns a ValueAnimator that animates between int values. A single
  /// value implies that that value is the one being animated to. However, this is not typically
  /// useful in a ValueAnimator object because there is no way for the object to determine the
  /// starting value for the animation (unlike ObjectAnimator, which can derive that value
  /// from the target object and property being animated). Therefore, there should typically
  /// be two or more values.
  ///@param values A set of values that the animation will animate between over time.
  ///@return A ValueAnimator object that is set up to animate between the given values.
  static ValueAnimator ofInt(jni.JniObject values) =>
      ValueAnimator.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_ofInt, jni.JniType.objectType, [values.reference]).object);

  static final _id_ofArgb = jniAccessors.getStaticMethodIDOf(
      _classRef, "ofArgb", "([I)Landroid/animation/ValueAnimator;");

  /// from: static public android.animation.ValueAnimator ofArgb(int[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs and returns a ValueAnimator that animates between color values. A single
  /// value implies that that value is the one being animated to. However, this is not typically
  /// useful in a ValueAnimator object because there is no way for the object to determine the
  /// starting value for the animation (unlike ObjectAnimator, which can derive that value
  /// from the target object and property being animated). Therefore, there should typically
  /// be two or more values.
  ///@param values A set of values that the animation will animate between over time.
  ///@return A ValueAnimator object that is set up to animate between the given values.
  static ValueAnimator ofArgb(jni.JniObject values) =>
      ValueAnimator.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_ofArgb, jni.JniType.objectType, [values.reference]).object);

  static final _id_ofFloat = jniAccessors.getStaticMethodIDOf(
      _classRef, "ofFloat", "([F)Landroid/animation/ValueAnimator;");

  /// from: static public android.animation.ValueAnimator ofFloat(float[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs and returns a ValueAnimator that animates between float values. A single
  /// value implies that that value is the one being animated to. However, this is not typically
  /// useful in a ValueAnimator object because there is no way for the object to determine the
  /// starting value for the animation (unlike ObjectAnimator, which can derive that value
  /// from the target object and property being animated). Therefore, there should typically
  /// be two or more values.
  ///@param values A set of values that the animation will animate between over time.
  ///@return A ValueAnimator object that is set up to animate between the given values.
  static ValueAnimator ofFloat(jni.JniObject values) =>
      ValueAnimator.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_ofFloat, jni.JniType.objectType, [values.reference]).object);

  static final _id_ofPropertyValuesHolder = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "ofPropertyValuesHolder",
      "([Landroid/animation/PropertyValuesHolder;)Landroid/animation/ValueAnimator;");

  /// from: static public android.animation.ValueAnimator ofPropertyValuesHolder(android.animation.PropertyValuesHolder[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs and returns a ValueAnimator that animates between the values
  /// specified in the PropertyValuesHolder objects.
  ///@param values A set of PropertyValuesHolder objects whose values will be animated
  /// between over time.
  ///@return A ValueAnimator object that is set up to animate between the given values.
  static ValueAnimator ofPropertyValuesHolder(jni.JniObject values) =>
      ValueAnimator.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_ofPropertyValuesHolder,
          jni.JniType.objectType,
          [values.reference]).object);

  static final _id_ofObject = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "ofObject",
      "(Landroid/animation/TypeEvaluator;[Ljava/lang/Object;)Landroid/animation/ValueAnimator;");

  /// from: static public android.animation.ValueAnimator ofObject(android.animation.TypeEvaluator evaluator, java.lang.Object[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs and returns a ValueAnimator that animates between Object values. A single
  /// value implies that that value is the one being animated to. However, this is not typically
  /// useful in a ValueAnimator object because there is no way for the object to determine the
  /// starting value for the animation (unlike ObjectAnimator, which can derive that value
  /// from the target object and property being animated). Therefore, there should typically
  /// be two or more values.
  ///
  /// <strong>Note:</strong> The Object values are stored as references to the original
  /// objects, which means that changes to those objects after this method is called will
  /// affect the values on the animator. If the objects will be mutated externally after
  /// this method is called, callers should pass a copy of those objects instead.
  ///
  /// Since ValueAnimator does not know how to animate between arbitrary Objects, this
  /// factory method also takes a TypeEvaluator object that the ValueAnimator will use
  /// to perform that interpolation.
  ///@param evaluator A TypeEvaluator that will be called on each animation frame to
  /// provide the ncessry interpolation between the Object values to derive the animated
  /// value.
  ///@param values A set of values that the animation will animate between over time.
  ///@return A ValueAnimator object that is set up to animate between the given values.
  static ValueAnimator ofObject(
          typeevaluator_.TypeEvaluator evaluator, jni.JniObject values) =>
      ValueAnimator.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_ofObject,
          jni.JniType.objectType,
          [evaluator.reference, values.reference]).object);

  static final _id_setIntValues =
      jniAccessors.getMethodIDOf(_classRef, "setIntValues", "([I)V");

  /// from: public void setIntValues(int[] values)
  ///
  /// Sets int values that will be animated between. A single
  /// value implies that that value is the one being animated to. However, this is not typically
  /// useful in a ValueAnimator object because there is no way for the object to determine the
  /// starting value for the animation (unlike ObjectAnimator, which can derive that value
  /// from the target object and property being animated). Therefore, there should typically
  /// be two or more values.
  ///
  /// If there are already multiple sets of values defined for this ValueAnimator via more
  /// than one PropertyValuesHolder object, this method will set the values for the first
  /// of those objects.
  ///
  ///@param values A set of values that the animation will animate between over time.
  void setIntValues(jni.JniObject values) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIntValues,
      jni.JniType.voidType,
      [values.reference]).check();

  static final _id_setFloatValues =
      jniAccessors.getMethodIDOf(_classRef, "setFloatValues", "([F)V");

  /// from: public void setFloatValues(float[] values)
  ///
  /// Sets float values that will be animated between. A single
  /// value implies that that value is the one being animated to. However, this is not typically
  /// useful in a ValueAnimator object because there is no way for the object to determine the
  /// starting value for the animation (unlike ObjectAnimator, which can derive that value
  /// from the target object and property being animated). Therefore, there should typically
  /// be two or more values.
  ///
  /// If there are already multiple sets of values defined for this ValueAnimator via more
  /// than one PropertyValuesHolder object, this method will set the values for the first
  /// of those objects.
  ///
  ///@param values A set of values that the animation will animate between over time.
  void setFloatValues(jni.JniObject values) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFloatValues,
      jni.JniType.voidType,
      [values.reference]).check();

  static final _id_setObjectValues = jniAccessors.getMethodIDOf(
      _classRef, "setObjectValues", "([Ljava/lang/Object;)V");

  /// from: public void setObjectValues(java.lang.Object[] values)
  ///
  /// Sets the values to animate between for this animation. A single
  /// value implies that that value is the one being animated to. However, this is not typically
  /// useful in a ValueAnimator object because there is no way for the object to determine the
  /// starting value for the animation (unlike ObjectAnimator, which can derive that value
  /// from the target object and property being animated). Therefore, there should typically
  /// be two or more values.
  ///
  /// <strong>Note:</strong> The Object values are stored as references to the original
  /// objects, which means that changes to those objects after this method is called will
  /// affect the values on the animator. If the objects will be mutated externally after
  /// this method is called, callers should pass a copy of those objects instead.
  ///
  /// If there are already multiple sets of values defined for this ValueAnimator via more
  /// than one PropertyValuesHolder object, this method will set the values for the first
  /// of those objects.
  ///
  ///
  /// There should be a TypeEvaluator set on the ValueAnimator that knows how to interpolate
  /// between these value objects. ValueAnimator only knows how to interpolate between the
  /// primitive types specified in the other setValues() methods.
  ///
  ///@param values The set of values to animate between.
  void setObjectValues(jni.JniObject values) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setObjectValues,
      jni.JniType.voidType,
      [values.reference]).check();

  static final _id_setValues = jniAccessors.getMethodIDOf(
      _classRef, "setValues", "([Landroid/animation/PropertyValuesHolder;)V");

  /// from: public void setValues(android.animation.PropertyValuesHolder[] values)
  ///
  /// Sets the values, per property, being animated between. This function is called internally
  /// by the constructors of ValueAnimator that take a list of values. But a ValueAnimator can
  /// be constructed without values and this method can be called to set the values manually
  /// instead.
  ///@param values The set of values, per property, being animated between.
  void setValues(jni.JniObject values) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setValues,
      jni.JniType.voidType,
      [values.reference]).check();

  static final _id_getValues = jniAccessors.getMethodIDOf(
      _classRef, "getValues", "()[Landroid/animation/PropertyValuesHolder;");

  /// from: public android.animation.PropertyValuesHolder[] getValues()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the values that this ValueAnimator animates between. These values are stored in
  /// PropertyValuesHolder objects, even if the ValueAnimator was created with a simple list
  /// of value objects instead.
  ///@return PropertyValuesHolder[] An array of PropertyValuesHolder objects which hold the
  /// values, per property, that define the animation.
  jni.JniObject getValues() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getValues, jni.JniType.objectType, []).object);

  static final _id_setDuration1 = jniAccessors.getMethodIDOf(
      _classRef, "setDuration", "(J)Landroid/animation/ValueAnimator;");

  /// from: public android.animation.ValueAnimator setDuration(long duration)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the length of the animation. The default duration is 300 milliseconds.
  ///@param duration The length of the animation, in milliseconds. This value cannot
  /// be negative.
  ///@return ValueAnimator The object called with setDuration(). This return
  /// value makes it easier to compose statements together that construct and then set the
  /// duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
  ValueAnimator setDuration1(int duration) =>
      ValueAnimator.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setDuration1, jni.JniType.objectType, [duration]).object);

  static final _id_getDuration =
      jniAccessors.getMethodIDOf(_classRef, "getDuration", "()J");

  /// from: public long getDuration()
  ///
  /// Gets the length of the animation. The default duration is 300 milliseconds.
  ///@return The length of the animation, in milliseconds.
  int getDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getDuration, jni.JniType.longType, []).long;

  static final _id_getTotalDuration =
      jniAccessors.getMethodIDOf(_classRef, "getTotalDuration", "()J");

  /// from: public long getTotalDuration()
  int getTotalDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalDuration, jni.JniType.longType, []).long;

  static final _id_setCurrentPlayTime =
      jniAccessors.getMethodIDOf(_classRef, "setCurrentPlayTime", "(J)V");

  /// from: public void setCurrentPlayTime(long playTime)
  ///
  /// Sets the position of the animation to the specified point in time. This time should
  /// be between 0 and the total duration of the animation, including any repetition. If
  /// the animation has not yet been started, then it will not advance forward after it is
  /// set to this time; it will simply set the time to this value and perform any appropriate
  /// actions based on that time. If the animation is already running, then setCurrentPlayTime()
  /// will set the current playing time to this value and continue playing from that point.
  ///@param playTime The time, in milliseconds, to which the animation is advanced or rewound.
  void setCurrentPlayTime(int playTime) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCurrentPlayTime,
      jni.JniType.voidType,
      [playTime]).check();

  static final _id_setCurrentFraction =
      jniAccessors.getMethodIDOf(_classRef, "setCurrentFraction", "(F)V");

  /// from: public void setCurrentFraction(float fraction)
  ///
  /// Sets the position of the animation to the specified fraction. This fraction should
  /// be between 0 and the total fraction of the animation, including any repetition. That is,
  /// a fraction of 0 will position the animation at the beginning, a value of 1 at the end,
  /// and a value of 2 at the end of a reversing animator that repeats once. If
  /// the animation has not yet been started, then it will not advance forward after it is
  /// set to this fraction; it will simply set the fraction to this value and perform any
  /// appropriate actions based on that fraction. If the animation is already running, then
  /// setCurrentFraction() will set the current fraction to this value and continue
  /// playing from that point. Animator.AnimatorListener events are not called
  /// due to changing the fraction; those events are only processed while the animation
  /// is running.
  ///@param fraction The fraction to which the animation is advanced or rewound. Values
  /// outside the range of 0 to the maximum fraction for the animator will be clamped to
  /// the correct range.
  void setCurrentFraction(double fraction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCurrentFraction,
      jni.JniType.voidType,
      [fraction]).check();

  static final _id_getCurrentPlayTime =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentPlayTime", "()J");

  /// from: public long getCurrentPlayTime()
  ///
  /// Gets the current position of the animation in time, which is equal to the current
  /// time minus the time that the animation started. An animation that is not yet started will
  /// return a value of zero, unless the animation has has its play time set via
  /// \#setCurrentPlayTime(long) or \#setCurrentFraction(float), in which case
  /// it will return the time that was set.
  ///@return The current position in time of the animation.
  int getCurrentPlayTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentPlayTime, jni.JniType.longType, []).long;

  static final _id_getStartDelay =
      jniAccessors.getMethodIDOf(_classRef, "getStartDelay", "()J");

  /// from: public long getStartDelay()
  ///
  /// The amount of time, in milliseconds, to delay starting the animation after
  /// \#start() is called.
  ///@return the number of milliseconds to delay running the animation
  int getStartDelay() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartDelay, jni.JniType.longType, []).long;

  static final _id_setStartDelay =
      jniAccessors.getMethodIDOf(_classRef, "setStartDelay", "(J)V");

  /// from: public void setStartDelay(long startDelay)
  ///
  /// The amount of time, in milliseconds, to delay starting the animation after
  /// \#start() is called. Note that the start delay should always be non-negative. Any
  /// negative start delay will be clamped to 0 on N and above.
  ///@param startDelay The amount of the delay, in milliseconds
  void setStartDelay(int startDelay) => jniAccessors.callMethodWithArgs(
      reference, _id_setStartDelay, jni.JniType.voidType, [startDelay]).check();

  static final _id_getFrameDelay =
      jniAccessors.getStaticMethodIDOf(_classRef, "getFrameDelay", "()J");

  /// from: static public long getFrameDelay()
  ///
  /// The amount of time, in milliseconds, between each frame of the animation. This is a
  /// requested time that the animation will attempt to honor, but the actual delay between
  /// frames may be different, depending on system load and capabilities. This is a static
  /// function because the same delay will be applied to all animations, since they are all
  /// run off of a single timing loop.
  ///
  /// The frame delay may be ignored when the animation system uses an external timing
  /// source, such as the display refresh rate (vsync), to govern animations.
  ///
  /// Note that this method should be called from the same thread that \#start() is
  /// called in order to check the frame delay for that animation. A runtime exception will be
  /// thrown if the calling thread does not have a Looper.
  ///@return the requested time between frames, in milliseconds
  static int getFrameDelay() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getFrameDelay, jni.JniType.longType, []).long;

  static final _id_setFrameDelay =
      jniAccessors.getStaticMethodIDOf(_classRef, "setFrameDelay", "(J)V");

  /// from: static public void setFrameDelay(long frameDelay)
  ///
  /// The amount of time, in milliseconds, between each frame of the animation. This is a
  /// requested time that the animation will attempt to honor, but the actual delay between
  /// frames may be different, depending on system load and capabilities. This is a static
  /// function because the same delay will be applied to all animations, since they are all
  /// run off of a single timing loop.
  ///
  /// The frame delay may be ignored when the animation system uses an external timing
  /// source, such as the display refresh rate (vsync), to govern animations.
  ///
  /// Note that this method should be called from the same thread that \#start() is
  /// called in order to have the new frame delay take effect on that animation. A runtime
  /// exception will be thrown if the calling thread does not have a Looper.
  ///@param frameDelay the requested time between frames, in milliseconds
  static void setFrameDelay(int frameDelay) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_setFrameDelay,
          jni.JniType.voidType, [frameDelay]).check();

  static final _id_getAnimatedValue = jniAccessors.getMethodIDOf(
      _classRef, "getAnimatedValue", "()Ljava/lang/Object;");

  /// from: public java.lang.Object getAnimatedValue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The most recent value calculated by this <code>ValueAnimator</code> when there is just one
  /// property being animated. This value is only sensible while the animation is running. The main
  /// purpose for this read-only property is to retrieve the value from the <code>ValueAnimator</code>
  /// during a call to AnimatorUpdateListener\#onAnimationUpdate(ValueAnimator), which
  /// is called during each animation frame, immediately after the value is calculated.
  ///@return animatedValue The value most recently calculated by this <code>ValueAnimator</code> for
  /// the single property being animated. If there are several properties being animated
  /// (specified by several PropertyValuesHolder objects in the constructor), this function
  /// returns the animated value for the first of those objects.
  jni.JniObject getAnimatedValue() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAnimatedValue, jni.JniType.objectType, []).object);

  static final _id_getAnimatedValue1 = jniAccessors.getMethodIDOf(
      _classRef, "getAnimatedValue", "(Ljava/lang/String;)Ljava/lang/Object;");

  /// from: public java.lang.Object getAnimatedValue(java.lang.String propertyName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The most recent value calculated by this <code>ValueAnimator</code> for <code>propertyName</code>.
  /// The main purpose for this read-only property is to retrieve the value from the
  /// <code>ValueAnimator</code> during a call to
  /// AnimatorUpdateListener\#onAnimationUpdate(ValueAnimator), which
  /// is called during each animation frame, immediately after the value is calculated.
  ///@return animatedValue The value most recently calculated for the named property
  /// by this <code>ValueAnimator</code>.
  jni.JniObject getAnimatedValue1(jni.JniString propertyName) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAnimatedValue1,
          jni.JniType.objectType,
          [propertyName.reference]).object);

  static final _id_setRepeatCount =
      jniAccessors.getMethodIDOf(_classRef, "setRepeatCount", "(I)V");

  /// from: public void setRepeatCount(int value)
  ///
  /// Sets how many times the animation should be repeated. If the repeat
  /// count is 0, the animation is never repeated. If the repeat count is
  /// greater than 0 or \#INFINITE, the repeat mode will be taken
  /// into account. The repeat count is 0 by default.
  ///@param value the number of times the animation should be repeated
  void setRepeatCount(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_setRepeatCount, jni.JniType.voidType, [value]).check();

  static final _id_getRepeatCount =
      jniAccessors.getMethodIDOf(_classRef, "getRepeatCount", "()I");

  /// from: public int getRepeatCount()
  ///
  /// Defines how many times the animation should repeat. The default value
  /// is 0.
  ///@return the number of times the animation should repeat, or \#INFINITE
  int getRepeatCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRepeatCount, jni.JniType.intType, []).integer;

  static final _id_setRepeatMode =
      jniAccessors.getMethodIDOf(_classRef, "setRepeatMode", "(I)V");

  /// from: public void setRepeatMode(int value)
  ///
  /// Defines what this animation should do when it reaches the end. This
  /// setting is applied only when the repeat count is either greater than
  /// 0 or \#INFINITE. Defaults to \#RESTART.
  ///@param value \#RESTART or \#REVERSE
  ///
  /// Value is android.animation.ValueAnimator\#RESTART, or android.animation.ValueAnimator\#REVERSE
  void setRepeatMode(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_setRepeatMode, jni.JniType.voidType, [value]).check();

  static final _id_getRepeatMode =
      jniAccessors.getMethodIDOf(_classRef, "getRepeatMode", "()I");

  /// from: public int getRepeatMode()
  ///
  /// Defines what this animation should do when it reaches the end.
  ///@return either one of \#REVERSE or \#RESTART
  ///
  /// Value is android.animation.ValueAnimator\#RESTART, or android.animation.ValueAnimator\#REVERSE
  int getRepeatMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getRepeatMode, jni.JniType.intType, []).integer;

  static final _id_addUpdateListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addUpdateListener",
      "(Landroid/animation/ValueAnimator\$AnimatorUpdateListener;)V");

  /// from: public void addUpdateListener(android.animation.ValueAnimator.AnimatorUpdateListener listener)
  ///
  /// Adds a listener to the set of listeners that are sent update events through the life of
  /// an animation. This method is called on all listeners for every frame of the animation,
  /// after the values for the animation have been calculated.
  ///@param listener the listener to be added to the current set of listeners for this animation.
  void addUpdateListener(ValueAnimator_AnimatorUpdateListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addUpdateListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_removeAllUpdateListeners =
      jniAccessors.getMethodIDOf(_classRef, "removeAllUpdateListeners", "()V");

  /// from: public void removeAllUpdateListeners()
  ///
  /// Removes all listeners from the set listening to frame updates for this animation.
  void removeAllUpdateListeners() => jniAccessors.callMethodWithArgs(reference,
      _id_removeAllUpdateListeners, jni.JniType.voidType, []).check();

  static final _id_removeUpdateListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeUpdateListener",
      "(Landroid/animation/ValueAnimator\$AnimatorUpdateListener;)V");

  /// from: public void removeUpdateListener(android.animation.ValueAnimator.AnimatorUpdateListener listener)
  ///
  /// Removes a listener from the set listening to frame updates for this animation.
  ///@param listener the listener to be removed from the current set of update listeners
  /// for this animation.
  void removeUpdateListener(ValueAnimator_AnimatorUpdateListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeUpdateListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "setInterpolator", "(Landroid/animation/TimeInterpolator;)V");

  /// from: public void setInterpolator(android.animation.TimeInterpolator value)
  ///
  /// The time interpolator used in calculating the elapsed fraction of this animation. The
  /// interpolator determines whether the animation runs with linear or non-linear motion,
  /// such as acceleration and deceleration. The default value is
  /// android.view.animation.AccelerateDecelerateInterpolator
  ///@param value the interpolator to be used by this animation. A value of <code>null</code>
  /// will result in linear interpolation.
  void setInterpolator(timeinterpolator_.TimeInterpolator value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInterpolator,
          jni.JniType.voidType, [value.reference]).check();

  static final _id_getInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "getInterpolator", "()Landroid/animation/TimeInterpolator;");

  /// from: public android.animation.TimeInterpolator getInterpolator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the timing interpolator that this ValueAnimator uses.
  ///@return The timing interpolator for this ValueAnimator.
  timeinterpolator_.TimeInterpolator getInterpolator() =>
      timeinterpolator_.TimeInterpolator.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getInterpolator,
              jni.JniType.objectType, []).object);

  static final _id_setEvaluator = jniAccessors.getMethodIDOf(
      _classRef, "setEvaluator", "(Landroid/animation/TypeEvaluator;)V");

  /// from: public void setEvaluator(android.animation.TypeEvaluator value)
  ///
  /// The type evaluator to be used when calculating the animated values of this animation.
  /// The system will automatically assign a float or int evaluator based on the type
  /// of <code>startValue</code> and <code>endValue</code> in the constructor. But if these values
  /// are not one of these primitive types, or if different evaluation is desired (such as is
  /// necessary with int values that represent colors), a custom evaluator needs to be assigned.
  /// For example, when running an animation on color values, the ArgbEvaluator
  /// should be used to get correct RGB color interpolation.
  ///
  /// If this ValueAnimator has only one set of values being animated between, this evaluator
  /// will be used for that set. If there are several sets of values being animated, which is
  /// the case if PropertyValuesHolder objects were set on the ValueAnimator, then the evaluator
  /// is assigned just to the first PropertyValuesHolder object.
  ///
  ///@param value the evaluator to be used this animation
  void setEvaluator(typeevaluator_.TypeEvaluator value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEvaluator,
          jni.JniType.voidType, [value.reference]).check();

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "()V");

  /// from: public void start()
  void start() => jniAccessors.callMethodWithArgs(
      reference, _id_start, jni.JniType.voidType, []).check();

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "()V");

  /// from: public void cancel()
  void cancel() => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, []).check();

  static final _id_end = jniAccessors.getMethodIDOf(_classRef, "end", "()V");

  /// from: public void end()
  void end() => jniAccessors
      .callMethodWithArgs(reference, _id_end, jni.JniType.voidType, []).check();

  static final _id_resume =
      jniAccessors.getMethodIDOf(_classRef, "resume", "()V");

  /// from: public void resume()
  void resume() => jniAccessors.callMethodWithArgs(
      reference, _id_resume, jni.JniType.voidType, []).check();

  static final _id_pause =
      jniAccessors.getMethodIDOf(_classRef, "pause", "()V");

  /// from: public void pause()
  void pause() => jniAccessors.callMethodWithArgs(
      reference, _id_pause, jni.JniType.voidType, []).check();

  static final _id_isRunning =
      jniAccessors.getMethodIDOf(_classRef, "isRunning", "()Z");

  /// from: public boolean isRunning()
  bool isRunning() => jniAccessors.callMethodWithArgs(
      reference, _id_isRunning, jni.JniType.booleanType, []).boolean;

  static final _id_isStarted =
      jniAccessors.getMethodIDOf(_classRef, "isStarted", "()Z");

  /// from: public boolean isStarted()
  bool isStarted() => jniAccessors.callMethodWithArgs(
      reference, _id_isStarted, jni.JniType.booleanType, []).boolean;

  static final _id_reverse =
      jniAccessors.getMethodIDOf(_classRef, "reverse", "()V");

  /// from: public void reverse()
  ///
  /// Plays the ValueAnimator in reverse. If the animation is already running,
  /// it will stop itself and play backwards from the point reached when reverse was called.
  /// If the animation is not currently running, then it will start from the end and
  /// play backwards. This behavior is only set for the current animation; future playing
  /// of the animation will use the default behavior of playing forward.
  void reverse() => jniAccessors.callMethodWithArgs(
      reference, _id_reverse, jni.JniType.voidType, []).check();

  static final _id_getAnimatedFraction =
      jniAccessors.getMethodIDOf(_classRef, "getAnimatedFraction", "()F");

  /// from: public float getAnimatedFraction()
  ///
  /// Returns the current animation fraction, which is the elapsed/interpolated fraction used in
  /// the most recent frame update on the animation.
  ///@return Elapsed/interpolated fraction of the animation.
  double getAnimatedFraction() => jniAccessors.callMethodWithArgs(
      reference, _id_getAnimatedFraction, jni.JniType.floatType, []).float;

  static final _id_clone1 = jniAccessors.getMethodIDOf(
      _classRef, "clone", "()Landroid/animation/ValueAnimator;");

  /// from: public android.animation.ValueAnimator clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ValueAnimator clone1() =>
      ValueAnimator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone1, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.animation.ValueAnimator$AnimatorUpdateListener
///
/// Implementors of this interface can add themselves as update listeners
/// to an <code>ValueAnimator</code> instance to receive callbacks on every animation
/// frame, after the current frame's values have been calculated for that
/// <code>ValueAnimator</code>.
class ValueAnimator_AnimatorUpdateListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/animation/ValueAnimator\$AnimatorUpdateListener");
  ValueAnimator_AnimatorUpdateListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onAnimationUpdate = jniAccessors.getMethodIDOf(
      _classRef, "onAnimationUpdate", "(Landroid/animation/ValueAnimator;)V");

  /// from: public abstract void onAnimationUpdate(android.animation.ValueAnimator animation)
  ///
  /// Notifies the occurrence of another frame of the animation.
  ///
  ///@param animation The animation which was repeated.
  void onAnimationUpdate(ValueAnimator animation) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAnimationUpdate,
          jni.JniType.voidType, [animation.reference]).check();
}
