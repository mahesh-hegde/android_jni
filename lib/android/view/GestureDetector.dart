// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Handler.dart" as handler_;

import "../content/Context.dart" as context_;

import "MotionEvent.dart" as motionevent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.GestureDetector
///
/// Detects various gestures and events using the supplied MotionEvents.
/// The OnGestureListener callback will notify users when a particular
/// motion event has occurred. This class should only be used with MotionEvents
/// reported via touch (don't use for trackball events).
///
/// To use this class:
/// <ul>
///  <li>Create an instance of the {@code GestureDetector} for your View
///  <li>In the View\#onTouchEvent(MotionEvent) method ensure you call
///          \#onTouchEvent(MotionEvent). The methods defined in your callback
///          will be executed when the events occur.
///  <li>If listening for OnContextClickListener\#onContextClick(MotionEvent)
///          you must call \#onGenericMotionEvent(MotionEvent)
///          in View\#onGenericMotionEvent(MotionEvent).
/// </ul>
class GestureDetector extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/GestureDetector");
  GestureDetector.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/view/GestureDetector\$OnGestureListener;Landroid/os/Handler;)V");

  /// from: public void <init>(android.view.GestureDetector.OnGestureListener listener, android.os.Handler handler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a GestureDetector with the supplied listener.
  /// This variant of the constructor should be used from a non-UI thread
  /// (as it allows specifying the Handler).
  ///@param listener the listener invoked for all the callbacks, this must
  /// not be null.
  ///@param handler the handler to use
  ///@throws NullPointerException if either {@code listener} or
  /// {@code handler} is null.
  ///@deprecated Use \#GestureDetector(android.content.Context,
  ///      android.view.GestureDetector.OnGestureListener, android.os.Handler) instead.
  GestureDetector(
      GestureDetector_OnGestureListener listener, handler_.Handler handler)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [listener.reference, handler.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/view/GestureDetector\$OnGestureListener;)V");

  /// from: public void <init>(android.view.GestureDetector.OnGestureListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a GestureDetector with the supplied listener.
  /// You may only use this constructor from a UI thread (this is the usual situation).
  ///@see android.os.Handler\#Handler()
  ///@param listener the listener invoked for all the callbacks, this must
  /// not be null.
  ///@throws NullPointerException if {@code listener} is null.
  ///@deprecated Use \#GestureDetector(android.content.Context,
  ///      android.view.GestureDetector.OnGestureListener) instead.
  GestureDetector.ctor1(GestureDetector_OnGestureListener listener)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [listener.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/GestureDetector\$OnGestureListener;)V");

  /// from: public void <init>(android.content.Context context, android.view.GestureDetector.OnGestureListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a GestureDetector with the supplied listener.
  /// You may only use this constructor from a android.os.Looper thread.
  ///@see android.os.Handler\#Handler()
  ///@param context the application's context
  ///@param listener the listener invoked for all the callbacks, this must
  /// not be null.
  ///@throws NullPointerException if {@code listener} is null.
  GestureDetector.ctor2(
      context_.Context context, GestureDetector_OnGestureListener listener)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, listener.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/GestureDetector\$OnGestureListener;Landroid/os/Handler;)V");

  /// from: public void <init>(android.content.Context context, android.view.GestureDetector.OnGestureListener listener, android.os.Handler handler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a GestureDetector with the supplied listener that runs deferred events on the
  /// thread associated with the supplied android.os.Handler.
  ///@see android.os.Handler\#Handler()
  ///@param context the application's context
  ///@param listener the listener invoked for all the callbacks, this must
  /// not be null.
  ///@param handler the handler to use for running deferred listener events.
  ///@throws NullPointerException if {@code listener} is null.
  GestureDetector.ctor3(context_.Context context,
      GestureDetector_OnGestureListener listener, handler_.Handler handler)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3,
            [context.reference, listener.reference, handler.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/GestureDetector\$OnGestureListener;Landroid/os/Handler;Z)V");

  /// from: public void <init>(android.content.Context context, android.view.GestureDetector.OnGestureListener listener, android.os.Handler handler, boolean unused)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a GestureDetector with the supplied listener that runs deferred events on the
  /// thread associated with the supplied android.os.Handler.
  ///@see android.os.Handler\#Handler()
  ///@param context the application's context
  ///@param listener the listener invoked for all the callbacks, this must
  /// not be null.
  ///@param handler the handler to use for running deferred listener events.
  ///@param unused currently not used.
  ///@throws NullPointerException if {@code listener} is null.
  GestureDetector.ctor4(
      context_.Context context,
      GestureDetector_OnGestureListener listener,
      handler_.Handler handler,
      bool unused)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor4, [
          context.reference,
          listener.reference,
          handler.reference,
          unused
        ]).object);

  static final _id_setOnDoubleTapListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDoubleTapListener",
      "(Landroid/view/GestureDetector\$OnDoubleTapListener;)V");

  /// from: public void setOnDoubleTapListener(android.view.GestureDetector.OnDoubleTapListener onDoubleTapListener)
  ///
  /// Sets the listener which will be called for double-tap and related
  /// gestures.
  ///@param onDoubleTapListener the listener invoked for all the callbacks, or
  ///        null to stop listening for double-tap gestures.
  void setOnDoubleTapListener(
          GestureDetector_OnDoubleTapListener onDoubleTapListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDoubleTapListener,
          jni.JniType.voidType, [onDoubleTapListener.reference]).check();

  static final _id_setContextClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setContextClickListener",
      "(Landroid/view/GestureDetector\$OnContextClickListener;)V");

  /// from: public void setContextClickListener(android.view.GestureDetector.OnContextClickListener onContextClickListener)
  ///
  /// Sets the listener which will be called for context clicks.
  ///@param onContextClickListener the listener invoked for all the callbacks, or null to stop
  ///            listening for context clicks.
  void setContextClickListener(
          GestureDetector_OnContextClickListener onContextClickListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContextClickListener,
          jni.JniType.voidType, [onContextClickListener.reference]).check();

  static final _id_setIsLongpressEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setIsLongpressEnabled", "(Z)V");

  /// from: public void setIsLongpressEnabled(boolean isLongpressEnabled)
  ///
  /// Set whether longpress is enabled, if this is enabled when a user
  /// presses and holds down you get a longpress event and nothing further.
  /// If it's disabled the user can press and hold down and then later
  /// moved their finger and you will get scroll events. By default
  /// longpress is enabled.
  ///@param isLongpressEnabled whether longpress should be enabled.
  void setIsLongpressEnabled(bool isLongpressEnabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIsLongpressEnabled,
          jni.JniType.voidType, [isLongpressEnabled]).check();

  static final _id_isLongpressEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isLongpressEnabled", "()Z");

  /// from: public boolean isLongpressEnabled()
  ///
  /// @return true if longpress is enabled, else false.
  bool isLongpressEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isLongpressEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent ev)
  ///
  /// Analyzes the given motion event and if applicable triggers the
  /// appropriate callbacks on the OnGestureListener supplied.
  ///@param ev The current motion event.
  ///@return true if the OnGestureListener consumed the event,
  ///              else false.
  bool onTouchEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_onGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent ev)
  ///
  /// Analyzes the given generic motion event and if applicable triggers the
  /// appropriate callbacks on the OnGestureListener supplied.
  ///@param ev The current motion event.
  ///@return true if the OnGestureListener consumed the event,
  ///              else false.
  bool onGenericMotionEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;
}

/// from: android.view.GestureDetector$SimpleOnGestureListener
///
/// A convenience class to extend when you only want to listen for a subset
/// of all the gestures. This implements all methods in the
/// OnGestureListener, OnDoubleTapListener, and OnContextClickListener
/// but does nothing and return {@code false} for all applicable methods.
class GestureDetector_SimpleOnGestureListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/GestureDetector\$SimpleOnGestureListener");
  GestureDetector_SimpleOnGestureListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GestureDetector_SimpleOnGestureListener()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onSingleTapUp = jniAccessors.getMethodIDOf(
      _classRef, "onSingleTapUp", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onSingleTapUp(android.view.MotionEvent e)
  bool onSingleTapUp(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSingleTapUp,
          jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onLongPress = jniAccessors.getMethodIDOf(
      _classRef, "onLongPress", "(Landroid/view/MotionEvent;)V");

  /// from: public void onLongPress(android.view.MotionEvent e)
  void onLongPress(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLongPress,
          jni.JniType.voidType, [e.reference]).check();

  static final _id_onScroll = jniAccessors.getMethodIDOf(_classRef, "onScroll",
      "(Landroid/view/MotionEvent;Landroid/view/MotionEvent;FF)Z");

  /// from: public boolean onScroll(android.view.MotionEvent e1, android.view.MotionEvent e2, float distanceX, float distanceY)
  bool onScroll(motionevent_.MotionEvent e1, motionevent_.MotionEvent e2,
          double distanceX, double distanceY) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onScroll,
          jni.JniType.booleanType,
          [e1.reference, e2.reference, distanceX, distanceY]).boolean;

  static final _id_onFling = jniAccessors.getMethodIDOf(_classRef, "onFling",
      "(Landroid/view/MotionEvent;Landroid/view/MotionEvent;FF)Z");

  /// from: public boolean onFling(android.view.MotionEvent e1, android.view.MotionEvent e2, float velocityX, float velocityY)
  bool onFling(motionevent_.MotionEvent e1, motionevent_.MotionEvent e2,
          double velocityX, double velocityY) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFling,
          jni.JniType.booleanType,
          [e1.reference, e2.reference, velocityX, velocityY]).boolean;

  static final _id_onShowPress = jniAccessors.getMethodIDOf(
      _classRef, "onShowPress", "(Landroid/view/MotionEvent;)V");

  /// from: public void onShowPress(android.view.MotionEvent e)
  void onShowPress(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onShowPress,
          jni.JniType.voidType, [e.reference]).check();

  static final _id_onDown = jniAccessors.getMethodIDOf(
      _classRef, "onDown", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onDown(android.view.MotionEvent e)
  bool onDown(motionevent_.MotionEvent e) => jniAccessors.callMethodWithArgs(
      reference, _id_onDown, jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onDoubleTap = jniAccessors.getMethodIDOf(
      _classRef, "onDoubleTap", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onDoubleTap(android.view.MotionEvent e)
  bool onDoubleTap(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDoubleTap,
          jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onDoubleTapEvent = jniAccessors.getMethodIDOf(
      _classRef, "onDoubleTapEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onDoubleTapEvent(android.view.MotionEvent e)
  bool onDoubleTapEvent(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDoubleTapEvent,
          jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onSingleTapConfirmed = jniAccessors.getMethodIDOf(
      _classRef, "onSingleTapConfirmed", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onSingleTapConfirmed(android.view.MotionEvent e)
  bool onSingleTapConfirmed(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSingleTapConfirmed,
          jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onContextClick = jniAccessors.getMethodIDOf(
      _classRef, "onContextClick", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onContextClick(android.view.MotionEvent e)
  bool onContextClick(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onContextClick,
          jni.JniType.booleanType, [e.reference]).boolean;
}

/// from: android.view.GestureDetector$OnGestureListener
///
/// The listener that is used to notify when gestures occur.
/// If you want to listen for all the different gestures then implement
/// this interface. If you only want to listen for a subset it might
/// be easier to extend SimpleOnGestureListener.
class GestureDetector_OnGestureListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/GestureDetector\$OnGestureListener");
  GestureDetector_OnGestureListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onDown = jniAccessors.getMethodIDOf(
      _classRef, "onDown", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onDown(android.view.MotionEvent e)
  ///
  /// Notified when a tap occurs with the down MotionEvent
  /// that triggered it. This will be triggered immediately for
  /// every down event. All other events should be preceded by this.
  ///@param e The down motion event.
  bool onDown(motionevent_.MotionEvent e) => jniAccessors.callMethodWithArgs(
      reference, _id_onDown, jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onShowPress = jniAccessors.getMethodIDOf(
      _classRef, "onShowPress", "(Landroid/view/MotionEvent;)V");

  /// from: public abstract void onShowPress(android.view.MotionEvent e)
  ///
  /// The user has performed a down MotionEvent and not performed
  /// a move or up yet. This event is commonly used to provide visual
  /// feedback to the user to let them know that their action has been
  /// recognized i.e. highlight an element.
  ///@param e The down motion event
  void onShowPress(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onShowPress,
          jni.JniType.voidType, [e.reference]).check();

  static final _id_onSingleTapUp = jniAccessors.getMethodIDOf(
      _classRef, "onSingleTapUp", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onSingleTapUp(android.view.MotionEvent e)
  ///
  /// Notified when a tap occurs with the up MotionEvent
  /// that triggered it.
  ///@param e The up motion event that completed the first tap
  ///@return true if the event is consumed, else false
  bool onSingleTapUp(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSingleTapUp,
          jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onScroll = jniAccessors.getMethodIDOf(_classRef, "onScroll",
      "(Landroid/view/MotionEvent;Landroid/view/MotionEvent;FF)Z");

  /// from: public abstract boolean onScroll(android.view.MotionEvent e1, android.view.MotionEvent e2, float distanceX, float distanceY)
  ///
  /// Notified when a scroll occurs with the initial on down MotionEvent and the
  /// current move MotionEvent. The distance in x and y is also supplied for
  /// convenience.
  ///@param e1 The first down motion event that started the scrolling.
  ///@param e2 The move motion event that triggered the current onScroll.
  ///@param distanceX The distance along the X axis that has been scrolled since the last
  ///              call to onScroll. This is NOT the distance between {@code e1}
  ///              and {@code e2}.
  ///@param distanceY The distance along the Y axis that has been scrolled since the last
  ///              call to onScroll. This is NOT the distance between {@code e1}
  ///              and {@code e2}.
  ///@return true if the event is consumed, else false
  bool onScroll(motionevent_.MotionEvent e1, motionevent_.MotionEvent e2,
          double distanceX, double distanceY) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onScroll,
          jni.JniType.booleanType,
          [e1.reference, e2.reference, distanceX, distanceY]).boolean;

  static final _id_onLongPress = jniAccessors.getMethodIDOf(
      _classRef, "onLongPress", "(Landroid/view/MotionEvent;)V");

  /// from: public abstract void onLongPress(android.view.MotionEvent e)
  ///
  /// Notified when a long press occurs with the initial on down MotionEvent
  /// that trigged it.
  ///@param e The initial on down motion event that started the longpress.
  void onLongPress(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLongPress,
          jni.JniType.voidType, [e.reference]).check();

  static final _id_onFling = jniAccessors.getMethodIDOf(_classRef, "onFling",
      "(Landroid/view/MotionEvent;Landroid/view/MotionEvent;FF)Z");

  /// from: public abstract boolean onFling(android.view.MotionEvent e1, android.view.MotionEvent e2, float velocityX, float velocityY)
  ///
  /// Notified of a fling event when it occurs with the initial on down MotionEvent
  /// and the matching up MotionEvent. The calculated velocity is supplied along
  /// the x and y axis in pixels per second.
  ///@param e1 The first down motion event that started the fling.
  ///@param e2 The move motion event that triggered the current onFling.
  ///@param velocityX The velocity of this fling measured in pixels per second
  ///              along the x axis.
  ///@param velocityY The velocity of this fling measured in pixels per second
  ///              along the y axis.
  ///@return true if the event is consumed, else false
  bool onFling(motionevent_.MotionEvent e1, motionevent_.MotionEvent e2,
          double velocityX, double velocityY) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFling,
          jni.JniType.booleanType,
          [e1.reference, e2.reference, velocityX, velocityY]).boolean;
}

/// from: android.view.GestureDetector$OnDoubleTapListener
///
/// The listener that is used to notify when a double-tap or a confirmed
/// single-tap occur.
class GestureDetector_OnDoubleTapListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/GestureDetector\$OnDoubleTapListener");
  GestureDetector_OnDoubleTapListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onSingleTapConfirmed = jniAccessors.getMethodIDOf(
      _classRef, "onSingleTapConfirmed", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onSingleTapConfirmed(android.view.MotionEvent e)
  ///
  /// Notified when a single-tap occurs.
  ///
  /// Unlike OnGestureListener\#onSingleTapUp(MotionEvent), this
  /// will only be called after the detector is confident that the user's
  /// first tap is not followed by a second tap leading to a double-tap
  /// gesture.
  ///@param e The down motion event of the single-tap.
  ///@return true if the event is consumed, else false
  bool onSingleTapConfirmed(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSingleTapConfirmed,
          jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onDoubleTap = jniAccessors.getMethodIDOf(
      _classRef, "onDoubleTap", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onDoubleTap(android.view.MotionEvent e)
  ///
  /// Notified when a double-tap occurs.
  ///@param e The down motion event of the first tap of the double-tap.
  ///@return true if the event is consumed, else false
  bool onDoubleTap(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDoubleTap,
          jni.JniType.booleanType, [e.reference]).boolean;

  static final _id_onDoubleTapEvent = jniAccessors.getMethodIDOf(
      _classRef, "onDoubleTapEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onDoubleTapEvent(android.view.MotionEvent e)
  ///
  /// Notified when an event within a double-tap gesture occurs, including
  /// the down, move, and up events.
  ///@param e The motion event that occurred during the double-tap gesture.
  ///@return true if the event is consumed, else false
  bool onDoubleTapEvent(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDoubleTapEvent,
          jni.JniType.booleanType, [e.reference]).boolean;
}

/// from: android.view.GestureDetector$OnContextClickListener
///
/// The listener that is used to notify when a context click occurs. When listening for a
/// context click ensure that you call \#onGenericMotionEvent(MotionEvent) in
/// View\#onGenericMotionEvent(MotionEvent).
class GestureDetector_OnContextClickListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/GestureDetector\$OnContextClickListener");
  GestureDetector_OnContextClickListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onContextClick = jniAccessors.getMethodIDOf(
      _classRef, "onContextClick", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onContextClick(android.view.MotionEvent e)
  ///
  /// Notified when a context click occurs.
  ///@param e The motion event that occurred during the context click.
  ///@return true if the event is consumed, else false
  bool onContextClick(motionevent_.MotionEvent e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onContextClick,
          jni.JniType.booleanType, [e.reference]).boolean;
}
