// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../graphics/Rect.dart" as rect_;

import "View.dart" as view_;

import "MotionEvent.dart" as motionevent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.TouchDelegate
///
/// Helper class to handle situations where you want a view to have a larger touch area than its
/// actual view bounds. The view whose touch area is changed is called the delegate view. This
/// class should be used by an ancestor of the delegate. To use a TouchDelegate, first create an
/// instance that specifies the bounds that should be mapped to the delegate and the delegate
/// view itself.
///
/// The ancestor should then forward all of its touch events received in its
/// android.view.View\#onTouchEvent(MotionEvent) to \#onTouchEvent(MotionEvent).
///
///
class TouchDelegate extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/TouchDelegate");
  TouchDelegate.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ABOVE
  ///
  /// The touchable region of the View extends above its actual extent.
  static const ABOVE = 1;

  /// from: static public final int BELOW
  ///
  /// The touchable region of the View extends below its actual extent.
  static const BELOW = 2;

  /// from: static public final int TO_LEFT
  ///
  /// The touchable region of the View extends to the left of its actual extent.
  static const TO_LEFT = 4;

  /// from: static public final int TO_RIGHT
  ///
  /// The touchable region of the View extends to the right of its actual extent.
  static const TO_RIGHT = 8;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Rect;Landroid/view/View;)V");

  /// from: public void <init>(android.graphics.Rect bounds, android.view.View delegateView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor
  ///@param bounds Bounds in local coordinates of the containing view that should be mapped to
  ///        the delegate view
  ///@param delegateView The view that should receive motion events
  TouchDelegate(rect_.Rect bounds, view_.View delegateView)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [bounds.reference, delegateView.reference]).object);

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  ///
  /// Will forward touch events to the delegate view if the event is within the bounds
  /// specified in the constructor.
  ///@param event The touch event to forward
  ///@return True if the event was forwarded to the delegate, false otherwise.
  bool onTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;
}
