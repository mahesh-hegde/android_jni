// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "MenuItem.dart" as menuitem_;

import "SubMenu.dart" as submenu_;

import "../content/ComponentName.dart" as componentname_;

import "../content/Intent.dart" as intent_;

import "KeyEvent.dart" as keyevent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.Menu
///
/// Interface for managing the items in a menu.
///
/// By default, every Activity supports an options menu of actions or options.
/// You can add items to this menu and handle clicks on your additions. The
/// easiest way of adding menu items is inflating an XML file into the
/// Menu via MenuInflater. The easiest way of attaching code to
/// clicks is via Activity\#onOptionsItemSelected(MenuItem) and
/// Activity\#onContextItemSelected(MenuItem).
///
/// Different menu types support different features:
/// <ol>
/// <li>__Context menus__: Do not support item shortcuts and item icons.
/// <li>__Options menus__: The __icon menus__ do not support item check
/// marks and only show the item's
/// MenuItem\#setTitleCondensed(CharSequence) condensed title. The
/// __expanded menus__ (only available if six or more menu items are visible,
/// reached via the 'More' item in the icon menu) do not show item icons, and
/// item check marks are discouraged.
/// <li>__Sub menus__: Do not support item icons, or nested sub menus.
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating menus, read the
/// <a href="{@docRoot}guide/topics/ui/menus.html">Menus</a> developer guide.
///
/// </div>
class Menu extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/Menu");
  Menu.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CATEGORY_ALTERNATIVE
  ///
  /// Category code for the order integer for items/groups that are
  /// alternative actions on the data that is currently displayed -- or/add
  /// this with your base value.
  static const CATEGORY_ALTERNATIVE = 262144;

  /// from: static public final int CATEGORY_CONTAINER
  ///
  /// Category code for the order integer for items/groups that are part of a
  /// container -- or/add this with your base value.
  static const CATEGORY_CONTAINER = 65536;

  /// from: static public final int CATEGORY_SECONDARY
  ///
  /// Category code for the order integer for items/groups that are
  /// user-supplied secondary (infrequently used) options -- or/add this with
  /// your base value.
  static const CATEGORY_SECONDARY = 196608;

  /// from: static public final int CATEGORY_SYSTEM
  ///
  /// Category code for the order integer for items/groups that are provided by
  /// the system -- or/add this with your base value.
  static const CATEGORY_SYSTEM = 131072;

  /// from: static public final int FIRST
  ///
  /// First value for group and item identifier integers.
  static const FIRST = 1;

  /// from: static public final int FLAG_ALWAYS_PERFORM_CLOSE
  ///
  /// Flag for \#performShortcut(int, KeyEvent, int): if set, always
  /// close the menu after executing the shortcut. Closing the menu also resets
  /// the prepared state.
  static const FLAG_ALWAYS_PERFORM_CLOSE = 2;

  /// from: static public final int FLAG_APPEND_TO_GROUP
  ///
  /// Flag for \#addIntentOptions: if set, do not automatically remove
  /// any existing menu items in the same group.
  static const FLAG_APPEND_TO_GROUP = 1;

  /// from: static public final int FLAG_PERFORM_NO_CLOSE
  ///
  /// Flag for \#performShortcut: if set, do not close the menu after
  /// executing the shortcut.
  static const FLAG_PERFORM_NO_CLOSE = 1;

  /// from: static public final int NONE
  ///
  /// Value to use for group and item identifier integers when you don't care
  /// about them.
  static const NONE = 0;

  /// from: static public final int SUPPORTED_MODIFIERS_MASK
  ///
  /// A mask of all supported modifiers for MenuItem's keyboard shortcuts
  static const SUPPORTED_MODIFIERS_MASK = 69647;

  static final _id_add = jniAccessors.getMethodIDOf(
      _classRef, "add", "(Ljava/lang/CharSequence;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem add(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new item to the menu. This item displays the given title for its
  /// label.
  ///@param title The text to display for the item.
  ///@return The newly added menu item.
  menuitem_.MenuItem add(jni.JniObject title) =>
      menuitem_.MenuItem.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_add, jni.JniType.objectType, [title.reference]).object);

  static final _id_add1 = jniAccessors.getMethodIDOf(
      _classRef, "add", "(I)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem add(int titleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new item to the menu. This item displays the given title for its
  /// label.
  ///@param titleRes Resource identifier of title string.
  ///@return The newly added menu item.
  menuitem_.MenuItem add1(int titleRes) =>
      menuitem_.MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_add1, jni.JniType.objectType, [titleRes]).object);

  static final _id_add2 = jniAccessors.getMethodIDOf(
      _classRef, "add", "(IIILjava/lang/CharSequence;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem add(int groupId, int itemId, int order, java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new item to the menu. This item displays the given title for its
  /// label.
  ///@param groupId The group identifier that this item should be part of.
  ///        This can be used to define groups of items for batch state
  ///        changes. Normally use \#NONE if an item should not be in a
  ///        group.
  ///@param itemId Unique item ID. Use \#NONE if you do not need a
  ///        unique ID.
  ///@param order The order for the item. Use \#NONE if you do not care
  ///        about the order. See MenuItem\#getOrder().
  ///@param title The text to display for the item.
  ///@return The newly added menu item.
  menuitem_.MenuItem add2(
          int groupId, int itemId, int order, jni.JniObject title) =>
      menuitem_.MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_add2,
          jni.JniType.objectType,
          [groupId, itemId, order, title.reference]).object);

  static final _id_add3 = jniAccessors.getMethodIDOf(
      _classRef, "add", "(IIII)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem add(int groupId, int itemId, int order, int titleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Variation on \#add(int, int, int, CharSequence) that takes a
  /// string resource identifier instead of the string itself.
  ///@param groupId The group identifier that this item should be part of.
  ///        This can also be used to define groups of items for batch state
  ///        changes. Normally use \#NONE if an item should not be in a
  ///        group.
  ///@param itemId Unique item ID. Use \#NONE if you do not need a
  ///        unique ID.
  ///@param order The order for the item. Use \#NONE if you do not care
  ///        about the order. See MenuItem\#getOrder().
  ///@param titleRes Resource identifier of title string.
  ///@return The newly added menu item.
  menuitem_.MenuItem add3(int groupId, int itemId, int order, int titleRes) =>
      menuitem_.MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_add3,
          jni.JniType.objectType,
          [groupId, itemId, order, titleRes]).object);

  static final _id_addSubMenu = jniAccessors.getMethodIDOf(_classRef,
      "addSubMenu", "(Ljava/lang/CharSequence;)Landroid/view/SubMenu;");

  /// from: public abstract android.view.SubMenu addSubMenu(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new sub-menu to the menu. This item displays the given title for
  /// its label. To modify other attributes on the submenu's menu item, use
  /// SubMenu\#getItem().
  ///@param title The text to display for the item.
  ///@return The newly added sub-menu
  submenu_.SubMenu addSubMenu(jni.JniObject title) =>
      submenu_.SubMenu.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addSubMenu, jni.JniType.objectType, [title.reference]).object);

  static final _id_addSubMenu1 = jniAccessors.getMethodIDOf(
      _classRef, "addSubMenu", "(I)Landroid/view/SubMenu;");

  /// from: public abstract android.view.SubMenu addSubMenu(int titleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new sub-menu to the menu. This item displays the given title for
  /// its label. To modify other attributes on the submenu's menu item, use
  /// SubMenu\#getItem().
  ///@param titleRes Resource identifier of title string.
  ///@return The newly added sub-menu
  submenu_.SubMenu addSubMenu1(int titleRes) =>
      submenu_.SubMenu.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addSubMenu1, jni.JniType.objectType, [titleRes]).object);

  static final _id_addSubMenu2 = jniAccessors.getMethodIDOf(_classRef,
      "addSubMenu", "(IIILjava/lang/CharSequence;)Landroid/view/SubMenu;");

  /// from: public abstract android.view.SubMenu addSubMenu(int groupId, int itemId, int order, java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new sub-menu to the menu. This item displays the given
  /// <var>title</var> for its label. To modify other attributes on the
  /// submenu's menu item, use SubMenu\#getItem().
  ///
  /// Note that you can only have one level of sub-menus, i.e. you cannnot add
  /// a subMenu to a subMenu: An UnsupportedOperationException will be
  /// thrown if you try.
  ///@param groupId The group identifier that this item should be part of.
  ///        This can also be used to define groups of items for batch state
  ///        changes. Normally use \#NONE if an item should not be in a
  ///        group.
  ///@param itemId Unique item ID. Use \#NONE if you do not need a
  ///        unique ID.
  ///@param order The order for the item. Use \#NONE if you do not care
  ///        about the order. See MenuItem\#getOrder().
  ///@param title The text to display for the item.
  ///@return The newly added sub-menu
  submenu_.SubMenu addSubMenu2(
          int groupId, int itemId, int order, jni.JniObject title) =>
      submenu_.SubMenu.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addSubMenu2,
          jni.JniType.objectType,
          [groupId, itemId, order, title.reference]).object);

  static final _id_addSubMenu3 = jniAccessors.getMethodIDOf(
      _classRef, "addSubMenu", "(IIII)Landroid/view/SubMenu;");

  /// from: public abstract android.view.SubMenu addSubMenu(int groupId, int itemId, int order, int titleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Variation on \#addSubMenu(int, int, int, CharSequence) that takes
  /// a string resource identifier for the title instead of the string itself.
  ///@param groupId The group identifier that this item should be part of.
  ///        This can also be used to define groups of items for batch state
  ///        changes. Normally use \#NONE if an item should not be in a group.
  ///@param itemId Unique item ID. Use \#NONE if you do not need a unique ID.
  ///@param order The order for the item. Use \#NONE if you do not care about the
  ///        order. See MenuItem\#getOrder().
  ///@param titleRes Resource identifier of title string.
  ///@return The newly added sub-menu
  submenu_.SubMenu addSubMenu3(
          int groupId, int itemId, int order, int titleRes) =>
      submenu_.SubMenu.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addSubMenu3,
          jni.JniType.objectType,
          [groupId, itemId, order, titleRes]).object);

  static final _id_addIntentOptions = jniAccessors.getMethodIDOf(
      _classRef,
      "addIntentOptions",
      "(IIILandroid/content/ComponentName;[Landroid/content/Intent;Landroid/content/Intent;I[Landroid/view/MenuItem;)I");

  /// from: public abstract int addIntentOptions(int groupId, int itemId, int order, android.content.ComponentName caller, android.content.Intent[] specifics, android.content.Intent intent, int flags, android.view.MenuItem[] outSpecificItems)
  ///
  /// Add a group of menu items corresponding to actions that can be performed
  /// for a particular Intent. The Intent is most often configured with a null
  /// action, the data that the current activity is working with, and includes
  /// either the Intent\#CATEGORY_ALTERNATIVE or
  /// Intent\#CATEGORY_SELECTED_ALTERNATIVE to find activities that have
  /// said they would like to be included as optional action. You can, however,
  /// use any Intent you want.
  ///
  ///
  /// See android.content.pm.PackageManager\#queryIntentActivityOptions
  /// for more * details on the <var>caller</var>, <var>specifics</var>, and
  /// <var>intent</var> arguments. The list returned by that function is used
  /// to populate the resulting menu items.
  ///
  ///
  /// All of the menu items of possible options for the intent will be added
  /// with the given group and id. You can use the group to control ordering of
  /// the items in relation to other items in the menu. Normally this function
  /// will automatically remove any existing items in the menu in the same
  /// group and place a divider above and below the added items; this behavior
  /// can be modified with the <var>flags</var> parameter. For each of the
  /// generated items MenuItem\#setIntent is called to associate the
  /// appropriate Intent with the item; this means the activity will
  /// automatically be started for you without having to do anything else.
  ///@param groupId The group identifier that the items should be part of.
  ///        This can also be used to define groups of items for batch state
  ///        changes. Normally use \#NONE if the items should not be in
  ///        a group.
  ///@param itemId Unique item ID. Use \#NONE if you do not need a
  ///        unique ID.
  ///@param order The order for the items. Use \#NONE if you do not
  ///        care about the order. See MenuItem\#getOrder().
  ///@param caller The current activity component name as defined by
  ///        queryIntentActivityOptions().
  ///@param specifics Specific items to place first as defined by
  ///        queryIntentActivityOptions().
  ///@param intent Intent describing the kinds of items to populate in the
  ///        list as defined by queryIntentActivityOptions().
  ///@param flags Additional options controlling how the items are added.
  ///@param outSpecificItems Optional array in which to place the menu items
  ///        that were generated for each of the <var>specifics</var> that were
  ///        requested. Entries may be null if no activity was found for that
  ///        specific action.
  ///@return The number of menu items that were added.
  ///@see \#FLAG_APPEND_TO_GROUP
  ///@see MenuItem\#setIntent
  ///@see android.content.pm.PackageManager\#queryIntentActivityOptions
  int addIntentOptions(
          int groupId,
          int itemId,
          int order,
          componentname_.ComponentName caller,
          jni.JniObject specifics,
          intent_.Intent intent,
          int flags,
          jni.JniObject outSpecificItems) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_addIntentOptions, jni.JniType.intType, [
        groupId,
        itemId,
        order,
        caller.reference,
        specifics.reference,
        intent.reference,
        flags,
        outSpecificItems.reference
      ]).integer;

  static final _id_removeItem =
      jniAccessors.getMethodIDOf(_classRef, "removeItem", "(I)V");

  /// from: public abstract void removeItem(int id)
  ///
  /// Remove the item with the given identifier.
  ///@param id The item to be removed.  If there is no item with this
  ///           identifier, nothing happens.
  void removeItem(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_removeItem, jni.JniType.voidType, [id]).check();

  static final _id_removeGroup =
      jniAccessors.getMethodIDOf(_classRef, "removeGroup", "(I)V");

  /// from: public abstract void removeGroup(int groupId)
  ///
  /// Remove all items in the given group.
  ///@param groupId The group to be removed.  If there are no items in this
  ///           group, nothing happens.
  void removeGroup(int groupId) => jniAccessors.callMethodWithArgs(
      reference, _id_removeGroup, jni.JniType.voidType, [groupId]).check();

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public abstract void clear()
  ///
  /// Remove all existing items from the menu, leaving it empty as if it had
  /// just been created.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_setGroupCheckable =
      jniAccessors.getMethodIDOf(_classRef, "setGroupCheckable", "(IZZ)V");

  /// from: public abstract void setGroupCheckable(int group, boolean checkable, boolean exclusive)
  ///
  /// Control whether a particular group of items can show a check mark.  This
  /// is similar to calling MenuItem\#setCheckable on all of the menu items
  /// with the given group identifier, but in addition you can control whether
  /// this group contains a mutually-exclusive set items.  This should be called
  /// after the items of the group have been added to the menu.
  ///@param group The group of items to operate on.
  ///@param checkable Set to true to allow a check mark, false to
  ///                  disallow.  The default is false.
  ///@param exclusive If set to true, only one item in this group can be
  ///                  checked at a time; checking an item will automatically
  ///                  uncheck all others in the group.  If set to false, each
  ///                  item can be checked independently of the others.
  ///@see MenuItem\#setCheckable
  ///@see MenuItem\#setChecked
  void setGroupCheckable(int group, bool checkable, bool exclusive) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGroupCheckable,
          jni.JniType.voidType, [group, checkable, exclusive]).check();

  static final _id_setGroupVisible =
      jniAccessors.getMethodIDOf(_classRef, "setGroupVisible", "(IZ)V");

  /// from: public abstract void setGroupVisible(int group, boolean visible)
  ///
  /// Show or hide all menu items that are in the given group.
  ///@param group The group of items to operate on.
  ///@param visible If true the items are visible, else they are hidden.
  ///@see MenuItem\#setVisible
  void setGroupVisible(int group, bool visible) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGroupVisible,
          jni.JniType.voidType, [group, visible]).check();

  static final _id_setGroupEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setGroupEnabled", "(IZ)V");

  /// from: public abstract void setGroupEnabled(int group, boolean enabled)
  ///
  /// Enable or disable all menu items that are in the given group.
  ///@param group The group of items to operate on.
  ///@param enabled If true the items will be enabled, else they will be disabled.
  ///@see MenuItem\#setEnabled
  void setGroupEnabled(int group, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGroupEnabled,
          jni.JniType.voidType, [group, enabled]).check();

  static final _id_hasVisibleItems =
      jniAccessors.getMethodIDOf(_classRef, "hasVisibleItems", "()Z");

  /// from: public abstract boolean hasVisibleItems()
  ///
  /// Return whether the menu currently has item items that are visible.
  ///@return True if there is one or more item visible,
  ///         else false.
  bool hasVisibleItems() => jniAccessors.callMethodWithArgs(
      reference, _id_hasVisibleItems, jni.JniType.booleanType, []).boolean;

  static final _id_findItem = jniAccessors.getMethodIDOf(
      _classRef, "findItem", "(I)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem findItem(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the menu item with a particular identifier.
  ///@param id The identifier to find.
  ///@return The menu item object, or null if there is no item with
  ///         this identifier.
  menuitem_.MenuItem findItem(int id) =>
      menuitem_.MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_findItem, jni.JniType.objectType, [id]).object);

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: public abstract int size()
  ///
  /// Get the number of items in the menu.  Note that this will change any
  /// times items are added or removed from the menu.
  ///@return The item count.
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.intType, []).integer;

  static final _id_getItem = jniAccessors.getMethodIDOf(
      _classRef, "getItem", "(I)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem getItem(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the menu item at the given index.
  ///@param index The index of the menu item to return.
  ///@return The menu item.
  ///@exception IndexOutOfBoundsException when {@code index < 0 || >= size()}
  menuitem_.MenuItem getItem(int index) =>
      menuitem_.MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getItem, jni.JniType.objectType, [index]).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public abstract void close()
  ///
  /// Closes the menu, if open.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_performShortcut = jniAccessors.getMethodIDOf(
      _classRef, "performShortcut", "(ILandroid/view/KeyEvent;I)Z");

  /// from: public abstract boolean performShortcut(int keyCode, android.view.KeyEvent event, int flags)
  ///
  /// Execute the menu item action associated with the given shortcut
  /// character.
  ///@param keyCode The keycode of the shortcut key.
  ///@param event Key event message.
  ///@param flags Additional option flags or 0.
  ///@return If the given shortcut exists and is shown, returns
  ///         true; else returns false.
  ///@see \#FLAG_PERFORM_NO_CLOSE
  bool performShortcut(int keyCode, keyevent_.KeyEvent event, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_performShortcut,
          jni.JniType.booleanType, [keyCode, event.reference, flags]).boolean;

  static final _id_isShortcutKey = jniAccessors.getMethodIDOf(
      _classRef, "isShortcutKey", "(ILandroid/view/KeyEvent;)Z");

  /// from: public abstract boolean isShortcutKey(int keyCode, android.view.KeyEvent event)
  ///
  /// Is a keypress one of the defined shortcut keys for this window.
  ///@param keyCode the key code from KeyEvent to check.
  ///@param event the KeyEvent to use to help check.
  bool isShortcutKey(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_isShortcutKey,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_performIdentifierAction =
      jniAccessors.getMethodIDOf(_classRef, "performIdentifierAction", "(II)Z");

  /// from: public abstract boolean performIdentifierAction(int id, int flags)
  ///
  /// Execute the menu item action associated with the given menu identifier.
  ///@param id Identifier associated with the menu item.
  ///@param flags Additional option flags or 0.
  ///@return If the given identifier exists and is shown, returns
  ///         true; else returns false.
  ///@see \#FLAG_PERFORM_NO_CLOSE
  bool performIdentifierAction(int id, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_performIdentifierAction,
          jni.JniType.booleanType, [id, flags]).boolean;

  static final _id_setQwertyMode =
      jniAccessors.getMethodIDOf(_classRef, "setQwertyMode", "(Z)V");

  /// from: public abstract void setQwertyMode(boolean isQwerty)
  ///
  /// Control whether the menu should be running in qwerty mode (alphabetic
  /// shortcuts) or 12-key mode (numeric shortcuts).
  ///@param isQwerty If true the menu will use alphabetic shortcuts; else it
  ///                 will use numeric shortcuts.
  void setQwertyMode(bool isQwerty) => jniAccessors.callMethodWithArgs(
      reference, _id_setQwertyMode, jni.JniType.voidType, [isQwerty]).check();

  static final _id_setGroupDividerEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setGroupDividerEnabled", "(Z)V");

  /// from: default public void setGroupDividerEnabled(boolean groupDividerEnabled)
  ///
  /// Enable or disable the group dividers.
  void setGroupDividerEnabled(bool groupDividerEnabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGroupDividerEnabled,
          jni.JniType.voidType, [groupDividerEnabled]).check();
}
