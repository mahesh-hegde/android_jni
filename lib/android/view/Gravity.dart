// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../graphics/Rect.dart" as rect_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.Gravity
///
/// Standard constants and tools for placing an object within a potentially
/// larger container.
class Gravity extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/Gravity");
  Gravity.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AXIS_CLIP
  ///
  /// Raw bit controlling whether the right/bottom edge is clipped to its
  /// container, based on the gravity direction being applied.
  static const AXIS_CLIP = 8;

  /// from: static public final int AXIS_PULL_AFTER
  ///
  /// Raw bit controlling how the right/bottom edge is placed.
  static const AXIS_PULL_AFTER = 4;

  /// from: static public final int AXIS_PULL_BEFORE
  ///
  /// Raw bit controlling how the left/top edge is placed.
  static const AXIS_PULL_BEFORE = 2;

  /// from: static public final int AXIS_SPECIFIED
  ///
  /// Raw bit indicating the gravity for an axis has been specified.
  static const AXIS_SPECIFIED = 1;

  /// from: static public final int AXIS_X_SHIFT
  ///
  /// Bits defining the horizontal axis.
  static const AXIS_X_SHIFT = 0;

  /// from: static public final int AXIS_Y_SHIFT
  ///
  /// Bits defining the vertical axis.
  static const AXIS_Y_SHIFT = 4;

  /// from: static public final int BOTTOM
  ///
  /// Push object to the bottom of its container, not changing its size.
  static const BOTTOM = 80;

  /// from: static public final int CENTER
  ///
  /// Place the object in the center of its container in both the vertical
  ///  and horizontal axis, not changing its size.
  static const CENTER = 17;

  /// from: static public final int CENTER_HORIZONTAL
  ///
  /// Place object in the horizontal center of its container, not changing its
  ///  size.
  static const CENTER_HORIZONTAL = 1;

  /// from: static public final int CENTER_VERTICAL
  ///
  /// Place object in the vertical center of its container, not changing its
  ///  size.
  static const CENTER_VERTICAL = 16;

  /// from: static public final int CLIP_HORIZONTAL
  ///
  /// Flag to clip the edges of the object to its container along the
  ///  horizontal axis.
  static const CLIP_HORIZONTAL = 8;

  /// from: static public final int CLIP_VERTICAL
  ///
  /// Flag to clip the edges of the object to its container along the
  ///  vertical axis.
  static const CLIP_VERTICAL = 128;

  /// from: static public final int DISPLAY_CLIP_HORIZONTAL
  ///
  /// Special constant to enable clipping to an overall display along the
  ///  horizontal dimension.  This is not applied by default by
  ///  \#apply(int, int, int, Rect, int, int, Rect); you must do so
  ///  yourself by calling \#applyDisplay.
  static const DISPLAY_CLIP_HORIZONTAL = 16777216;

  /// from: static public final int DISPLAY_CLIP_VERTICAL
  ///
  /// Special constant to enable clipping to an overall display along the
  ///  vertical dimension.  This is not applied by default by
  ///  \#apply(int, int, int, Rect, int, int, Rect); you must do so
  ///  yourself by calling \#applyDisplay.
  static const DISPLAY_CLIP_VERTICAL = 268435456;

  /// from: static public final int END
  ///
  /// Push object to x-axis position at the end of its container, not changing its size.
  static const END = 8388613;

  /// from: static public final int FILL
  ///
  /// Grow the horizontal and vertical size of the object if needed so it
  ///  completely fills its container.
  static const FILL = 119;

  /// from: static public final int FILL_HORIZONTAL
  ///
  /// Grow the horizontal size of the object if needed so it completely fills
  ///  its container.
  static const FILL_HORIZONTAL = 7;

  /// from: static public final int FILL_VERTICAL
  ///
  /// Grow the vertical size of the object if needed so it completely fills
  ///  its container.
  static const FILL_VERTICAL = 112;

  /// from: static public final int HORIZONTAL_GRAVITY_MASK
  ///
  /// Binary mask to get the absolute horizontal gravity of a gravity.
  static const HORIZONTAL_GRAVITY_MASK = 7;

  /// from: static public final int LEFT
  ///
  /// Push object to the left of its container, not changing its size.
  static const LEFT = 3;

  /// from: static public final int NO_GRAVITY
  ///
  /// Constant indicating that no gravity has been set
  static const NO_GRAVITY = 0;

  /// from: static public final int RELATIVE_HORIZONTAL_GRAVITY_MASK
  ///
  /// Binary mask for the horizontal gravity and script specific direction bit.
  static const RELATIVE_HORIZONTAL_GRAVITY_MASK = 8388615;

  /// from: static public final int RELATIVE_LAYOUT_DIRECTION
  ///
  /// Raw bit controlling whether the layout direction is relative or not (START/END instead of
  /// absolute LEFT/RIGHT).
  static const RELATIVE_LAYOUT_DIRECTION = 8388608;

  /// from: static public final int RIGHT
  ///
  /// Push object to the right of its container, not changing its size.
  static const RIGHT = 5;

  /// from: static public final int START
  ///
  /// Push object to x-axis position at the start of its container, not changing its size.
  static const START = 8388611;

  /// from: static public final int TOP
  ///
  /// Push object to the top of its container, not changing its size.
  static const TOP = 48;

  /// from: static public final int VERTICAL_GRAVITY_MASK
  ///
  /// Binary mask to get the vertical gravity of a gravity.
  static const VERTICAL_GRAVITY_MASK = 112;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Gravity()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_apply = jniAccessors.getStaticMethodIDOf(_classRef, "apply",
      "(IIILandroid/graphics/Rect;Landroid/graphics/Rect;)V");

  /// from: static public void apply(int gravity, int w, int h, android.graphics.Rect container, android.graphics.Rect outRect)
  ///
  /// Apply a gravity constant to an object. This supposes that the layout direction is LTR.
  ///@param gravity The desired placement of the object, as defined by the
  ///                constants in this class.
  ///@param w The horizontal size of the object.
  ///@param h The vertical size of the object.
  ///@param container The frame of the containing space, in which the object
  ///                  will be placed.  Should be large enough to contain the
  ///                  width and height of the object.
  ///@param outRect Receives the computed frame of the object in its
  ///                container.
  static void apply(int gravity, int w, int h, rect_.Rect container,
          rect_.Rect outRect) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_apply,
          jni.JniType.voidType,
          [gravity, w, h, container.reference, outRect.reference]).check();

  static final _id_apply1 = jniAccessors.getStaticMethodIDOf(_classRef, "apply",
      "(IIILandroid/graphics/Rect;Landroid/graphics/Rect;I)V");

  /// from: static public void apply(int gravity, int w, int h, android.graphics.Rect container, android.graphics.Rect outRect, int layoutDirection)
  ///
  /// Apply a gravity constant to an object and take care if layout direction is RTL or not.
  ///@param gravity The desired placement of the object, as defined by the
  ///                constants in this class.
  ///@param w The horizontal size of the object.
  ///@param h The vertical size of the object.
  ///@param container The frame of the containing space, in which the object
  ///                  will be placed.  Should be large enough to contain the
  ///                  width and height of the object.
  ///@param outRect Receives the computed frame of the object in its
  ///                container.
  ///@param layoutDirection The layout direction.
  ///@see View\#LAYOUT_DIRECTION_LTR
  ///@see View\#LAYOUT_DIRECTION_RTL
  static void apply1(int gravity, int w, int h, rect_.Rect container,
          rect_.Rect outRect, int layoutDirection) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_apply1, jni.JniType.voidType, [
        gravity,
        w,
        h,
        container.reference,
        outRect.reference,
        layoutDirection
      ]).check();

  static final _id_apply2 = jniAccessors.getStaticMethodIDOf(_classRef, "apply",
      "(IIILandroid/graphics/Rect;IILandroid/graphics/Rect;)V");

  /// from: static public void apply(int gravity, int w, int h, android.graphics.Rect container, int xAdj, int yAdj, android.graphics.Rect outRect)
  ///
  /// Apply a gravity constant to an object.
  ///@param gravity The desired placement of the object, as defined by the
  ///                constants in this class.
  ///@param w The horizontal size of the object.
  ///@param h The vertical size of the object.
  ///@param container The frame of the containing space, in which the object
  ///                  will be placed.  Should be large enough to contain the
  ///                  width and height of the object.
  ///@param xAdj Offset to apply to the X axis.  If gravity is LEFT this
  ///             pushes it to the right; if gravity is RIGHT it pushes it to
  ///             the left; if gravity is CENTER_HORIZONTAL it pushes it to the
  ///             right or left; otherwise it is ignored.
  ///@param yAdj Offset to apply to the Y axis.  If gravity is TOP this pushes
  ///             it down; if gravity is BOTTOM it pushes it up; if gravity is
  ///             CENTER_VERTICAL it pushes it down or up; otherwise it is
  ///             ignored.
  ///@param outRect Receives the computed frame of the object in its
  ///                container.
  static void apply2(int gravity, int w, int h, rect_.Rect container, int xAdj,
          int yAdj, rect_.Rect outRect) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_apply2, jni.JniType.voidType, [
        gravity,
        w,
        h,
        container.reference,
        xAdj,
        yAdj,
        outRect.reference
      ]).check();

  static final _id_apply3 = jniAccessors.getStaticMethodIDOf(_classRef, "apply",
      "(IIILandroid/graphics/Rect;IILandroid/graphics/Rect;I)V");

  /// from: static public void apply(int gravity, int w, int h, android.graphics.Rect container, int xAdj, int yAdj, android.graphics.Rect outRect, int layoutDirection)
  ///
  /// Apply a gravity constant to an object.
  ///@param gravity The desired placement of the object, as defined by the
  ///                constants in this class.
  ///@param w The horizontal size of the object.
  ///@param h The vertical size of the object.
  ///@param container The frame of the containing space, in which the object
  ///                  will be placed.  Should be large enough to contain the
  ///                  width and height of the object.
  ///@param xAdj Offset to apply to the X axis.  If gravity is LEFT this
  ///             pushes it to the right; if gravity is RIGHT it pushes it to
  ///             the left; if gravity is CENTER_HORIZONTAL it pushes it to the
  ///             right or left; otherwise it is ignored.
  ///@param yAdj Offset to apply to the Y axis.  If gravity is TOP this pushes
  ///             it down; if gravity is BOTTOM it pushes it up; if gravity is
  ///             CENTER_VERTICAL it pushes it down or up; otherwise it is
  ///             ignored.
  ///@param outRect Receives the computed frame of the object in its
  ///                container.
  ///@param layoutDirection The layout direction.
  ///@see View\#LAYOUT_DIRECTION_LTR
  ///@see View\#LAYOUT_DIRECTION_RTL
  static void apply3(int gravity, int w, int h, rect_.Rect container, int xAdj,
          int yAdj, rect_.Rect outRect, int layoutDirection) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_apply3, jni.JniType.voidType, [
        gravity,
        w,
        h,
        container.reference,
        xAdj,
        yAdj,
        outRect.reference,
        layoutDirection
      ]).check();

  static final _id_applyDisplay = jniAccessors.getStaticMethodIDOf(_classRef,
      "applyDisplay", "(ILandroid/graphics/Rect;Landroid/graphics/Rect;)V");

  /// from: static public void applyDisplay(int gravity, android.graphics.Rect display, android.graphics.Rect inoutObj)
  ///
  /// Apply additional gravity behavior based on the overall "display" that an
  /// object exists in.  This can be used after
  /// \#apply(int, int, int, Rect, int, int, Rect) to place the object
  /// within a visible display.  By default this moves or clips the object
  /// to be visible in the display; the gravity flags
  /// \#DISPLAY_CLIP_HORIZONTAL and \#DISPLAY_CLIP_VERTICAL
  /// can be used to change this behavior.
  ///@param gravity Gravity constants to modify the placement within the
  /// display.
  ///@param display The rectangle of the display in which the object is
  /// being placed.
  ///@param inoutObj Supplies the current object position; returns with it
  /// modified if needed to fit in the display.
  static void applyDisplay(
          int gravity, rect_.Rect display, rect_.Rect inoutObj) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_applyDisplay,
          jni.JniType.voidType,
          [gravity, display.reference, inoutObj.reference]).check();

  static final _id_applyDisplay1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "applyDisplay", "(ILandroid/graphics/Rect;Landroid/graphics/Rect;I)V");

  /// from: static public void applyDisplay(int gravity, android.graphics.Rect display, android.graphics.Rect inoutObj, int layoutDirection)
  ///
  /// Apply additional gravity behavior based on the overall "display" that an
  /// object exists in.  This can be used after
  /// \#apply(int, int, int, Rect, int, int, Rect) to place the object
  /// within a visible display.  By default this moves or clips the object
  /// to be visible in the display; the gravity flags
  /// \#DISPLAY_CLIP_HORIZONTAL and \#DISPLAY_CLIP_VERTICAL
  /// can be used to change this behavior.
  ///@param gravity Gravity constants to modify the placement within the
  /// display.
  ///@param display The rectangle of the display in which the object is
  /// being placed.
  ///@param inoutObj Supplies the current object position; returns with it
  /// modified if needed to fit in the display.
  ///@param layoutDirection The layout direction.
  ///@see View\#LAYOUT_DIRECTION_LTR
  ///@see View\#LAYOUT_DIRECTION_RTL
  static void applyDisplay1(int gravity, rect_.Rect display,
          rect_.Rect inoutObj, int layoutDirection) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_applyDisplay1, jni.JniType.voidType, [
        gravity,
        display.reference,
        inoutObj.reference,
        layoutDirection
      ]).check();

  static final _id_isVertical =
      jniAccessors.getStaticMethodIDOf(_classRef, "isVertical", "(I)Z");

  /// from: static public boolean isVertical(int gravity)
  ///
  /// Indicate whether the supplied gravity has a vertical pull.
  ///
  ///@param gravity the gravity to check for vertical pull
  ///@return true if the supplied gravity has a vertical pull
  static bool isVertical(int gravity) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isVertical, jni.JniType.booleanType, [gravity]).boolean;

  static final _id_isHorizontal =
      jniAccessors.getStaticMethodIDOf(_classRef, "isHorizontal", "(I)Z");

  /// from: static public boolean isHorizontal(int gravity)
  ///
  /// Indicate whether the supplied gravity has an horizontal pull.
  ///
  ///@param gravity the gravity to check for horizontal pull
  ///@return true if the supplied gravity has an horizontal pull
  static bool isHorizontal(int gravity) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isHorizontal,
          jni.JniType.booleanType, [gravity]).boolean;

  static final _id_getAbsoluteGravity = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAbsoluteGravity", "(II)I");

  /// from: static public int getAbsoluteGravity(int gravity, int layoutDirection)
  ///
  /// Convert script specific gravity to absolute horizontal value.
  ///
  ///
  /// if horizontal direction is LTR, then START will set LEFT and END will set RIGHT.
  /// if horizontal direction is RTL, then START will set RIGHT and END will set LEFT.
  ///@param gravity The gravity to convert to absolute (horizontal) values.
  ///@param layoutDirection The layout direction.
  ///@return gravity converted to absolute (horizontal) values.
  static int getAbsoluteGravity(int gravity, int layoutDirection) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getAbsoluteGravity,
          jni.JniType.intType, [gravity, layoutDirection]).integer;
}
