// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "View.dart" as view_;

import "ViewGroup.dart" as viewgroup_;

import "../util/AttributeSet.dart" as attributeset_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.LayoutInflater
///
/// Instantiates a layout XML file into its corresponding android.view.View
/// objects. It is never used directly. Instead, use
/// android.app.Activity\#getLayoutInflater() or
/// Context\#getSystemService to retrieve a standard LayoutInflater instance
/// that is already hooked up to the current context and correctly configured
/// for the device you are running on.
///
///
/// To create a new LayoutInflater with an additional Factory for your
/// own views, you can use \#cloneInContext to clone an existing
/// ViewFactory, and then call \#setFactory on it to include your
/// Factory.
///
///
/// For performance reasons, view inflation relies heavily on pre-processing of
/// XML files that is done at build time. Therefore, it is not currently possible
/// to use LayoutInflater with an XmlPullParser over a plain XML file at runtime;
/// it only works with an XmlPullParser returned from a compiled resource
/// (R._something_ file.)
class LayoutInflater extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/LayoutInflater");
  LayoutInflater.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: protected void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new LayoutInflater instance associated with a particular Context.
  /// Applications will almost always want to use
  /// Context\#getSystemService Context.getSystemService() to retrieve
  /// the standard Context\#LAYOUT_INFLATER_SERVICE Context.INFLATER_SERVICE.
  ///@param context The Context in which this LayoutInflater will create its
  /// Views; most importantly, this supplies the theme from which the default
  /// values for their attributes are retrieved.
  LayoutInflater(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/view/LayoutInflater;Landroid/content/Context;)V");

  /// from: protected void <init>(android.view.LayoutInflater original, android.content.Context newContext)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new LayoutInflater instance that is a copy of an existing
  /// LayoutInflater, optionally with its Context changed.  For use in
  /// implementing \#cloneInContext.
  ///@param original The original LayoutInflater to copy.
  ///@param newContext The new Context to use.
  LayoutInflater.ctor1(LayoutInflater original, context_.Context newContext)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [original.reference, newContext.reference]).object);

  static final _id_from = jniAccessors.getStaticMethodIDOf(_classRef, "from",
      "(Landroid/content/Context;)Landroid/view/LayoutInflater;");

  /// from: static public android.view.LayoutInflater from(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains the LayoutInflater from the given context.
  static LayoutInflater from(context_.Context context) =>
      LayoutInflater.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_from, jni.JniType.objectType, [context.reference]).object);

  static final _id_cloneInContext = jniAccessors.getMethodIDOf(
      _classRef,
      "cloneInContext",
      "(Landroid/content/Context;)Landroid/view/LayoutInflater;");

  /// from: public abstract android.view.LayoutInflater cloneInContext(android.content.Context newContext)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a copy of the existing LayoutInflater object, with the copy
  /// pointing to a different Context than the original.  This is used by
  /// ContextThemeWrapper to create a new LayoutInflater to go along
  /// with the new Context theme.
  ///@param newContext The new Context to associate with the new LayoutInflater.
  /// May be the same as the original Context if desired.
  ///@return Returns a brand spanking new LayoutInflater object associated with
  /// the given Context.
  LayoutInflater cloneInContext(context_.Context newContext) =>
      LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_cloneInContext,
          jni.JniType.objectType,
          [newContext.reference]).object);

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the context we are running in, for access to resources, class
  /// loader, etc.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getFactory = jniAccessors.getMethodIDOf(
      _classRef, "getFactory", "()Landroid/view/LayoutInflater\$Factory;");

  /// from: public final android.view.LayoutInflater.Factory getFactory()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current Factory (or null). This is called on each element
  /// name. If the factory returns a View, add that to the hierarchy. If it
  /// returns null, proceed to call onCreateView(name).
  LayoutInflater_Factory getFactory() =>
      LayoutInflater_Factory.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFactory, jni.JniType.objectType, []).object);

  static final _id_getFactory2 = jniAccessors.getMethodIDOf(
      _classRef, "getFactory2", "()Landroid/view/LayoutInflater\$Factory2;");

  /// from: public final android.view.LayoutInflater.Factory2 getFactory2()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current Factory2.  Returns null if no factory is set
  /// or the set factory does not implement the Factory2 interface.
  /// This is called on each element
  /// name. If the factory returns a View, add that to the hierarchy. If it
  /// returns null, proceed to call onCreateView(name).
  LayoutInflater_Factory2 getFactory2() =>
      LayoutInflater_Factory2.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFactory2, jni.JniType.objectType, []).object);

  static final _id_setFactory = jniAccessors.getMethodIDOf(
      _classRef, "setFactory", "(Landroid/view/LayoutInflater\$Factory;)V");

  /// from: public void setFactory(android.view.LayoutInflater.Factory factory)
  ///
  /// Attach a custom Factory interface for creating views while using
  /// this LayoutInflater.  This must not be null, and can only be set once;
  /// after setting, you can not change the factory.  This is
  /// called on each element name as the xml is parsed. If the factory returns
  /// a View, that is added to the hierarchy. If it returns null, the next
  /// factory default \#onCreateView method is called.
  ///
  /// If you have an existing
  /// LayoutInflater and want to add your own factory to it, use
  /// \#cloneInContext to clone the existing instance and then you
  /// can use this function (once) on the returned new instance.  This will
  /// merge your own factory with whatever factory the original instance is
  /// using.
  void setFactory(LayoutInflater_Factory factory0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFactory,
          jni.JniType.voidType, [factory0.reference]).check();

  static final _id_setFactory2 = jniAccessors.getMethodIDOf(
      _classRef, "setFactory2", "(Landroid/view/LayoutInflater\$Factory2;)V");

  /// from: public void setFactory2(android.view.LayoutInflater.Factory2 factory)
  ///
  /// Like \#setFactory, but allows you to set a Factory2
  /// interface.
  void setFactory2(LayoutInflater_Factory2 factory0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFactory2,
          jni.JniType.voidType, [factory0.reference]).check();

  static final _id_getFilter = jniAccessors.getMethodIDOf(
      _classRef, "getFilter", "()Landroid/view/LayoutInflater\$Filter;");

  /// from: public android.view.LayoutInflater.Filter getFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The Filter currently used by this LayoutInflater to restrict the set of Views
  /// that are allowed to be inflated.
  LayoutInflater_Filter getFilter() =>
      LayoutInflater_Filter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFilter, jni.JniType.objectType, []).object);

  static final _id_setFilter = jniAccessors.getMethodIDOf(
      _classRef, "setFilter", "(Landroid/view/LayoutInflater\$Filter;)V");

  /// from: public void setFilter(android.view.LayoutInflater.Filter filter)
  ///
  /// Sets the Filter to by this LayoutInflater. If a view is attempted to be inflated
  /// which is not allowed by the Filter, the \#inflate(int, ViewGroup) call will
  /// throw an InflateException. This filter will replace any previous filter set on this
  /// LayoutInflater.
  ///@param filter The Filter which restricts the set of Views that are allowed to be inflated.
  ///        This filter will replace any previous filter set on this LayoutInflater.
  void setFilter(LayoutInflater_Filter filter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFilter,
          jni.JniType.voidType, [filter.reference]).check();

  static final _id_inflate = jniAccessors.getMethodIDOf(
      _classRef, "inflate", "(ILandroid/view/ViewGroup;)Landroid/view/View;");

  /// from: public android.view.View inflate(int resource, android.view.ViewGroup root)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inflate a new view hierarchy from the specified xml resource. Throws
  /// InflateException if there is an error.
  ///@param resource ID for an XML layout resource to load (e.g.,
  ///        <code>R.layout.main_page</code>)
  ///@param root Optional view to be the parent of the generated hierarchy.
  /// This value may be {@code null}.
  ///@return The root View of the inflated hierarchy. If root was supplied,
  ///         this is the root View; otherwise it is the root of the inflated
  ///         XML file.
  view_.View inflate(int resource, viewgroup_.ViewGroup root) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference, _id_inflate,
          jni.JniType.objectType, [resource, root.reference]).object);

  static final _id_inflate1 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Lorg/xmlpull/v1/XmlPullParser;Landroid/view/ViewGroup;)Landroid/view/View;");

  /// from: public android.view.View inflate(org.xmlpull.v1.XmlPullParser parser, android.view.ViewGroup root)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inflate a new view hierarchy from the specified xml node. Throws
  /// InflateException if there is an error. *
  ///
  /// _<strong>Important</strong>_&nbsp;&nbsp;&nbsp;For performance
  /// reasons, view inflation relies heavily on pre-processing of XML files
  /// that is done at build time. Therefore, it is not currently possible to
  /// use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
  ///@param parser XML dom node containing the description of the view
  ///        hierarchy.
  ///@param root Optional view to be the parent of the generated hierarchy.
  /// This value may be {@code null}.
  ///@return The root View of the inflated hierarchy. If root was supplied,
  ///         this is the root View; otherwise it is the root of the inflated
  ///         XML file.
  view_.View inflate1(jni.JniObject parser, viewgroup_.ViewGroup root) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_inflate1,
          jni.JniType.objectType,
          [parser.reference, root.reference]).object);

  static final _id_inflate2 = jniAccessors.getMethodIDOf(
      _classRef, "inflate", "(ILandroid/view/ViewGroup;Z)Landroid/view/View;");

  /// from: public android.view.View inflate(int resource, android.view.ViewGroup root, boolean attachToRoot)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inflate a new view hierarchy from the specified xml resource. Throws
  /// InflateException if there is an error.
  ///@param resource ID for an XML layout resource to load (e.g.,
  ///        <code>R.layout.main_page</code>)
  ///@param root Optional view to be the parent of the generated hierarchy (if
  ///        _attachToRoot_ is true), or else simply an object that
  ///        provides a set of LayoutParams values for root of the returned
  ///        hierarchy (if _attachToRoot_ is false.)
  /// This value may be {@code null}.
  ///@param attachToRoot Whether the inflated hierarchy should be attached to
  ///        the root parameter? If false, root is only used to create the
  ///        correct subclass of LayoutParams for the root view in the XML.
  ///@return The root View of the inflated hierarchy. If root was supplied and
  ///         attachToRoot is true, this is root; otherwise it is the root of
  ///         the inflated XML file.
  view_.View inflate2(
          int resource, viewgroup_.ViewGroup root, bool attachToRoot) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_inflate2,
          jni.JniType.objectType,
          [resource, root.reference, attachToRoot]).object);

  static final _id_inflate3 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Lorg/xmlpull/v1/XmlPullParser;Landroid/view/ViewGroup;Z)Landroid/view/View;");

  /// from: public android.view.View inflate(org.xmlpull.v1.XmlPullParser parser, android.view.ViewGroup root, boolean attachToRoot)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inflate a new view hierarchy from the specified XML node. Throws
  /// InflateException if there is an error.
  ///
  /// _<strong>Important</strong>_&nbsp;&nbsp;&nbsp;For performance
  /// reasons, view inflation relies heavily on pre-processing of XML files
  /// that is done at build time. Therefore, it is not currently possible to
  /// use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
  ///@param parser XML dom node containing the description of the view
  ///        hierarchy.
  ///@param root Optional view to be the parent of the generated hierarchy (if
  ///        _attachToRoot_ is true), or else simply an object that
  ///        provides a set of LayoutParams values for root of the returned
  ///        hierarchy (if _attachToRoot_ is false.)
  /// This value may be {@code null}.
  ///@param attachToRoot Whether the inflated hierarchy should be attached to
  ///        the root parameter? If false, root is only used to create the
  ///        correct subclass of LayoutParams for the root view in the XML.
  ///@return The root View of the inflated hierarchy. If root was supplied and
  ///         attachToRoot is true, this is root; otherwise it is the root of
  ///         the inflated XML file.
  view_.View inflate3(
          jni.JniObject parser, viewgroup_.ViewGroup root, bool attachToRoot) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_inflate3,
          jni.JniType.objectType,
          [parser.reference, root.reference, attachToRoot]).object);

  static final _id_createView = jniAccessors.getMethodIDOf(
      _classRef,
      "createView",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/util/AttributeSet;)Landroid/view/View;");

  /// from: public final android.view.View createView(java.lang.String name, java.lang.String prefix, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Low-level function for instantiating a view by name. This attempts to
  /// instantiate a view class of the given <var>name</var> found in this
  /// LayoutInflater's ClassLoader.
  ///
  ///
  /// There are two things that can happen in an error case: either the
  /// exception describing the error will be thrown, or a null will be
  /// returned. You must deal with both possibilities -- the former will happen
  /// the first time createView() is called for a class of a particular name,
  /// the latter every time there-after for that class name.
  ///@param name The full name of the class to be instantiated.
  ///@param attrs The XML attributes supplied for this instance.
  ///@return View The newly instantiated view, or null.
  view_.View createView(jni.JniString name, jni.JniString prefix,
          attributeset_.AttributeSet attrs) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createView,
          jni.JniType.objectType,
          [name.reference, prefix.reference, attrs.reference]).object);

  static final _id_onCreateView = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Ljava/lang/String;Landroid/util/AttributeSet;)Landroid/view/View;");

  /// from: protected android.view.View onCreateView(java.lang.String name, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This routine is responsible for creating the correct subclass of View
  /// given the xml element name. Override it to handle custom view objects. If
  /// you override this in your subclass be sure to call through to
  /// super.onCreateView(name) for names you do not recognize.
  ///@param name The fully qualified class name of the View to be create.
  ///@param attrs An AttributeSet of attributes to apply to the View.
  ///@return View The View created.
  view_.View onCreateView(
          jni.JniString name, attributeset_.AttributeSet attrs) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateView,
          jni.JniType.objectType,
          [name.reference, attrs.reference]).object);

  static final _id_onCreateView1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Landroid/view/View;Ljava/lang/String;Landroid/util/AttributeSet;)Landroid/view/View;");

  /// from: protected android.view.View onCreateView(android.view.View parent, java.lang.String name, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Version of \#onCreateView(String, AttributeSet) that also
  /// takes the future parent of the view being constructed.  The default
  /// implementation simply calls \#onCreateView(String, AttributeSet).
  ///@param parent The future parent of the returned view.  _Note that
  /// this may be null._
  ///@param name The fully qualified class name of the View to be create.
  ///@param attrs An AttributeSet of attributes to apply to the View.
  ///@return View The View created.
  view_.View onCreateView1(view_.View parent, jni.JniString name,
          attributeset_.AttributeSet attrs) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateView1,
          jni.JniType.objectType,
          [parent.reference, name.reference, attrs.reference]).object);
}

/// from: android.view.LayoutInflater$Filter
///
/// Hook to allow clients of the LayoutInflater to restrict the set of Views that are allowed
/// to be inflated.
class LayoutInflater_Filter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/LayoutInflater\$Filter");
  LayoutInflater_Filter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onLoadClass = jniAccessors.getMethodIDOf(
      _classRef, "onLoadClass", "(Ljava/lang/Class;)Z");

  /// from: public abstract boolean onLoadClass(java.lang.Class clazz)
  ///
  /// Hook to allow clients of the LayoutInflater to restrict the set of Views
  /// that are allowed to be inflated.
  ///@param clazz The class object for the View that is about to be inflated
  ///@return True if this class is allowed to be inflated, or false otherwise
  bool onLoadClass(jni.JniObject clazz) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onLoadClass,
      jni.JniType.booleanType,
      [clazz.reference]).boolean;
}

/// from: android.view.LayoutInflater$Factory2
class LayoutInflater_Factory2 extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/LayoutInflater\$Factory2");
  LayoutInflater_Factory2.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onCreateView = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Landroid/view/View;Ljava/lang/String;Landroid/content/Context;Landroid/util/AttributeSet;)Landroid/view/View;");

  /// from: public abstract android.view.View onCreateView(android.view.View parent, java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Version of \#onCreateView(String, Context, AttributeSet)
  /// that also supplies the parent that the view created view will be
  /// placed in.
  ///@param parent The parent that the created view will be placed
  /// in; _note that this may be null_.
  ///@param name Tag name to be inflated.
  ///@param context The context the view is being created in.
  ///@param attrs Inflation attributes as specified in XML file.
  ///@return View Newly created view. Return null for the default
  ///         behavior.
  view_.View onCreateView(view_.View parent, jni.JniString name,
          context_.Context context, attributeset_.AttributeSet attrs) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCreateView, jni.JniType.objectType, [
        parent.reference,
        name.reference,
        context.reference,
        attrs.reference
      ]).object);
}

/// from: android.view.LayoutInflater$Factory
class LayoutInflater_Factory extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/LayoutInflater\$Factory");
  LayoutInflater_Factory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onCreateView = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Ljava/lang/String;Landroid/content/Context;Landroid/util/AttributeSet;)Landroid/view/View;");

  /// from: public abstract android.view.View onCreateView(java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Hook you can supply that is called when inflating from a LayoutInflater.
  /// You can use this to customize the tag names available in your XML
  /// layout files.
  ///
  ///
  /// Note that it is good practice to prefix these custom names with your
  /// package (i.e., com.coolcompany.apps) to avoid conflicts with system
  /// names.
  ///@param name Tag name to be inflated.
  ///@param context The context the view is being created in.
  ///@param attrs Inflation attributes as specified in XML file.
  ///@return View Newly created view. Return null for the default
  ///         behavior.
  view_.View onCreateView(jni.JniString name, context_.Context context,
          attributeset_.AttributeSet attrs) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateView,
          jni.JniType.objectType,
          [name.reference, context.reference, attrs.reference]).object);
}
