// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/Rect.dart" as rect_;

import "Surface.dart" as surface_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.SurfaceHolder
///
/// Abstract interface to someone holding a display surface.  Allows you to
/// control the surface size and format, edit the pixels in the surface, and
/// monitor changes to the surface.  This interface is typically available
/// through the SurfaceView class.
///
/// When using this interface from a thread other than the one running
/// its SurfaceView, you will want to carefully read the
/// methods
/// \#lockCanvas and Callback\#surfaceCreated Callback.surfaceCreated().
class SurfaceHolder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/SurfaceHolder");
  SurfaceHolder.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SURFACE_TYPE_GPU
  ///
  /// @deprecated this is ignored, this value is set automatically when needed.
  static const SURFACE_TYPE_GPU = 2;

  /// from: static public final int SURFACE_TYPE_HARDWARE
  ///
  /// @deprecated this is ignored, this value is set automatically when needed.
  static const SURFACE_TYPE_HARDWARE = 1;

  /// from: static public final int SURFACE_TYPE_NORMAL
  ///
  /// @deprecated this is ignored, this value is set automatically when needed.
  static const SURFACE_TYPE_NORMAL = 0;

  /// from: static public final int SURFACE_TYPE_PUSH_BUFFERS
  ///
  /// @deprecated this is ignored, this value is set automatically when needed.
  static const SURFACE_TYPE_PUSH_BUFFERS = 3;

  static final _id_addCallback = jniAccessors.getMethodIDOf(
      _classRef, "addCallback", "(Landroid/view/SurfaceHolder\$Callback;)V");

  /// from: public abstract void addCallback(android.view.SurfaceHolder.Callback callback)
  ///
  /// Add a Callback interface for this holder.  There can several Callback
  /// interfaces associated with a holder.
  ///@param callback The new Callback interface.
  void addCallback(SurfaceHolder_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_addCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_removeCallback = jniAccessors.getMethodIDOf(
      _classRef, "removeCallback", "(Landroid/view/SurfaceHolder\$Callback;)V");

  /// from: public abstract void removeCallback(android.view.SurfaceHolder.Callback callback)
  ///
  /// Removes a previously added Callback interface from this holder.
  ///@param callback The Callback interface to remove.
  void removeCallback(SurfaceHolder_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_isCreating =
      jniAccessors.getMethodIDOf(_classRef, "isCreating", "()Z");

  /// from: public abstract boolean isCreating()
  ///
  /// Use this method to find out if the surface is in the process of being
  /// created from Callback methods. This is intended to be used with
  /// Callback\#surfaceChanged.
  ///@return true if the surface is in the process of being created.
  bool isCreating() => jniAccessors.callMethodWithArgs(
      reference, _id_isCreating, jni.JniType.booleanType, []).boolean;

  static final _id_setType =
      jniAccessors.getMethodIDOf(_classRef, "setType", "(I)V");

  /// from: public abstract void setType(int type)
  ///
  /// Sets the surface's type.
  ///@deprecated this is ignored, this value is set automatically when needed.
  void setType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setType, jni.JniType.voidType, [type]).check();

  static final _id_setFixedSize =
      jniAccessors.getMethodIDOf(_classRef, "setFixedSize", "(II)V");

  /// from: public abstract void setFixedSize(int width, int height)
  ///
  /// Make the surface a fixed size.  It will never change from this size.
  /// When working with a SurfaceView, this must be called from the
  /// same thread running the SurfaceView's window.
  ///@param width The surface's width.
  ///@param height The surface's height.
  void setFixedSize(int width, int height) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFixedSize,
      jni.JniType.voidType,
      [width, height]).check();

  static final _id_setSizeFromLayout =
      jniAccessors.getMethodIDOf(_classRef, "setSizeFromLayout", "()V");

  /// from: public abstract void setSizeFromLayout()
  ///
  /// Allow the surface to resized based on layout of its container (this is
  /// the default).  When this is enabled, you should monitor
  /// Callback\#surfaceChanged for changes to the size of the surface.
  /// When working with a SurfaceView, this must be called from the
  /// same thread running the SurfaceView's window.
  void setSizeFromLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_setSizeFromLayout, jni.JniType.voidType, []).check();

  static final _id_setFormat =
      jniAccessors.getMethodIDOf(_classRef, "setFormat", "(I)V");

  /// from: public abstract void setFormat(int format)
  ///
  /// Set the desired PixelFormat of the surface.  The default is OPAQUE.
  /// When working with a SurfaceView, this must be called from the
  /// same thread running the SurfaceView's window.
  ///@param format A constant from PixelFormat.
  ///@see android.graphics.PixelFormat
  void setFormat(int format) => jniAccessors.callMethodWithArgs(
      reference, _id_setFormat, jni.JniType.voidType, [format]).check();

  static final _id_setKeepScreenOn =
      jniAccessors.getMethodIDOf(_classRef, "setKeepScreenOn", "(Z)V");

  /// from: public abstract void setKeepScreenOn(boolean screenOn)
  ///
  /// Enable or disable option to keep the screen turned on while this
  /// surface is displayed.  The default is false, allowing it to turn off.
  /// This is safe to call from any thread.
  ///@param screenOn Set to true to force the screen to stay on, false
  /// to allow it to turn off.
  void setKeepScreenOn(bool screenOn) => jniAccessors.callMethodWithArgs(
      reference, _id_setKeepScreenOn, jni.JniType.voidType, [screenOn]).check();

  static final _id_lockCanvas = jniAccessors.getMethodIDOf(
      _classRef, "lockCanvas", "()Landroid/graphics/Canvas;");

  /// from: public abstract android.graphics.Canvas lockCanvas()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start editing the pixels in the surface.  The returned Canvas can be used
  /// to draw into the surface's bitmap.  A null is returned if the surface has
  /// not been created or otherwise cannot be edited.  You will usually need
  /// to implement Callback\#surfaceCreated Callback.surfaceCreated
  /// to find out when the Surface is available for use.
  ///
  /// The content of the Surface is never preserved between unlockCanvas() and
  /// lockCanvas(), for this reason, every pixel within the Surface area
  /// must be written. The only exception to this rule is when a dirty
  /// rectangle is specified, in which case, non-dirty pixels will be
  /// preserved.
  ///
  /// If you call this repeatedly when the Surface is not ready (before
  /// Callback\#surfaceCreated Callback.surfaceCreated or after
  /// Callback\#surfaceDestroyed Callback.surfaceDestroyed), your calls
  /// will be throttled to a slow rate in order to avoid consuming CPU.
  ///
  /// If null is not returned, this function internally holds a lock until
  /// the corresponding \#unlockCanvasAndPost call, preventing
  /// SurfaceView from creating, destroying, or modifying the surface
  /// while it is being drawn.  This can be more convenient than accessing
  /// the Surface directly, as you do not need to do special synchronization
  /// with a drawing thread in Callback\#surfaceDestroyed Callback.surfaceDestroyed.
  ///@return Canvas Use to draw into the surface.
  canvas_.Canvas lockCanvas() =>
      canvas_.Canvas.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_lockCanvas, jni.JniType.objectType, []).object);

  static final _id_lockCanvas1 = jniAccessors.getMethodIDOf(_classRef,
      "lockCanvas", "(Landroid/graphics/Rect;)Landroid/graphics/Canvas;");

  /// from: public abstract android.graphics.Canvas lockCanvas(android.graphics.Rect dirty)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Just like \#lockCanvas() but allows specification of a dirty rectangle.
  /// Every
  /// pixel within that rectangle must be written; however pixels outside
  /// the dirty rectangle will be preserved by the next call to lockCanvas().
  ///@see android.view.SurfaceHolder\#lockCanvas
  ///@param dirty Area of the Surface that will be modified.
  ///@return Canvas Use to draw into the surface.
  canvas_.Canvas lockCanvas1(rect_.Rect dirty) =>
      canvas_.Canvas.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_lockCanvas1, jni.JniType.objectType, [dirty.reference]).object);

  static final _id_lockHardwareCanvas = jniAccessors.getMethodIDOf(
      _classRef, "lockHardwareCanvas", "()Landroid/graphics/Canvas;");

  /// from: default public android.graphics.Canvas lockHardwareCanvas()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Just like \#lockCanvas() but the returned canvas is hardware-accelerated.
  ///
  /// See the <a href="{@docRoot}guide/topics/graphics/hardware-accel.html\#unsupported">
  /// unsupported drawing operations</a> for a list of what is and isn't
  /// supported in a hardware-accelerated canvas.
  ///@return Canvas Use to draw into the surface.
  ///@throws IllegalStateException If the canvas cannot be locked.
  canvas_.Canvas lockHardwareCanvas() =>
      canvas_.Canvas.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_lockHardwareCanvas, jni.JniType.objectType, []).object);

  static final _id_unlockCanvasAndPost = jniAccessors.getMethodIDOf(
      _classRef, "unlockCanvasAndPost", "(Landroid/graphics/Canvas;)V");

  /// from: public abstract void unlockCanvasAndPost(android.graphics.Canvas canvas)
  ///
  /// Finish editing pixels in the surface.  After this call, the surface's
  /// current pixels will be shown on the screen, but its content is lost,
  /// in particular there is no guarantee that the content of the Surface
  /// will remain unchanged when lockCanvas() is called again.
  ///@see \#lockCanvas()
  ///@param canvas The Canvas previously returned by lockCanvas().
  void unlockCanvasAndPost(canvas_.Canvas canvas) =>
      jniAccessors.callMethodWithArgs(reference, _id_unlockCanvasAndPost,
          jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getSurfaceFrame = jniAccessors.getMethodIDOf(
      _classRef, "getSurfaceFrame", "()Landroid/graphics/Rect;");

  /// from: public abstract android.graphics.Rect getSurfaceFrame()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current size of the surface.  Note: do not modify the
  /// returned Rect.  This is only safe to call from the thread of
  /// SurfaceView's window, or while inside of
  /// \#lockCanvas().
  ///@return Rect The surface's dimensions.  The left and top are always 0.
  rect_.Rect getSurfaceFrame() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurfaceFrame, jni.JniType.objectType, []).object);

  static final _id_getSurface = jniAccessors.getMethodIDOf(
      _classRef, "getSurface", "()Landroid/view/Surface;");

  /// from: public abstract android.view.Surface getSurface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Direct access to the surface object.  The Surface may not always be
  /// available -- for example when using a SurfaceView the holder's
  /// Surface is not created until the view has been attached to the window
  /// manager and performed a layout in order to determine the dimensions
  /// and screen position of the Surface.    You will thus usually need
  /// to implement Callback\#surfaceCreated Callback.surfaceCreated
  /// to find out when the Surface is available for use.
  ///
  /// Note that if you directly access the Surface from another thread,
  /// it is critical that you correctly implement
  /// Callback\#surfaceCreated Callback.surfaceCreated and
  /// Callback\#surfaceDestroyed Callback.surfaceDestroyed to ensure
  /// that thread only accesses the Surface while it is valid, and that the
  /// Surface does not get destroyed while the thread is using it.
  ///
  /// This method is intended to be used by frameworks which often need
  /// direct access to the Surface object (usually to pass it to native code).
  ///@return Surface The surface.
  surface_.Surface getSurface() =>
      surface_.Surface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurface, jni.JniType.objectType, []).object);
}

/// from: android.view.SurfaceHolder$Callback2
///
/// Additional callbacks that can be received for Callback.
class SurfaceHolder_Callback2 extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/SurfaceHolder\$Callback2");
  SurfaceHolder_Callback2.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_surfaceRedrawNeeded = jniAccessors.getMethodIDOf(
      _classRef, "surfaceRedrawNeeded", "(Landroid/view/SurfaceHolder;)V");

  /// from: public abstract void surfaceRedrawNeeded(android.view.SurfaceHolder holder)
  ///
  /// Called when the application needs to redraw the content of its
  /// surface, after it is resized or for some other reason.  By not
  /// returning from here until the redraw is complete, you can ensure that
  /// the user will not see your surface in a bad state (at its new
  /// size before it has been correctly drawn that way).  This will
  /// typically be preceeded by a call to \#surfaceChanged.
  ///
  /// As of O, \#surfaceRedrawNeededAsync may be implemented
  /// to provide a non-blocking implementation. If \#surfaceRedrawNeededAsync
  /// is not implemented, then this will be called instead.
  ///@param holder The SurfaceHolder whose surface has changed.
  void surfaceRedrawNeeded(SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_surfaceRedrawNeeded,
          jni.JniType.voidType, [holder.reference]).check();

  static final _id_surfaceRedrawNeededAsync = jniAccessors.getMethodIDOf(
      _classRef,
      "surfaceRedrawNeededAsync",
      "(Landroid/view/SurfaceHolder;Ljava/lang/Runnable;)V");

  /// from: default public void surfaceRedrawNeededAsync(android.view.SurfaceHolder holder, java.lang.Runnable drawingFinished)
  ///
  /// An alternative to surfaceRedrawNeeded where it is not required to block
  /// until the redraw is complete. You should initiate the redraw, and return,
  /// later invoking drawingFinished when your redraw is complete.
  ///
  /// This can be useful to avoid blocking your main application thread on rendering.
  ///
  /// As of O, if this is implemented \#surfaceRedrawNeeded will not be called.
  /// However it is still recommended to implement \#surfaceRedrawNeeded for
  /// compatibility with older versions of the platform.
  ///@param holder The SurfaceHolder which needs redrawing.
  ///@param drawingFinished A runnable to signal completion. This may be invoked
  /// from any thread.
  void surfaceRedrawNeededAsync(
          SurfaceHolder holder, jni.JniObject drawingFinished) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_surfaceRedrawNeededAsync,
          jni.JniType.voidType,
          [holder.reference, drawingFinished.reference]).check();
}

/// from: android.view.SurfaceHolder$Callback
///
/// A client may implement this interface to receive information about
/// changes to the surface.  When used with a SurfaceView, the
/// Surface being held is only available between calls to
/// \#surfaceCreated(SurfaceHolder) and
/// \#surfaceDestroyed(SurfaceHolder).  The Callback is set with
/// SurfaceHolder\#addCallback SurfaceHolder.addCallback method.
class SurfaceHolder_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/SurfaceHolder\$Callback");
  SurfaceHolder_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_surfaceCreated = jniAccessors.getMethodIDOf(
      _classRef, "surfaceCreated", "(Landroid/view/SurfaceHolder;)V");

  /// from: public abstract void surfaceCreated(android.view.SurfaceHolder holder)
  ///
  /// This is called immediately after the surface is first created.
  /// Implementations of this should start up whatever rendering code
  /// they desire.  Note that only one thread can ever draw into
  /// a Surface, so you should not draw into the Surface here
  /// if your normal rendering will be in another thread.
  ///@param holder The SurfaceHolder whose surface is being created.
  void surfaceCreated(SurfaceHolder holder) => jniAccessors.callMethodWithArgs(
      reference,
      _id_surfaceCreated,
      jni.JniType.voidType,
      [holder.reference]).check();

  static final _id_surfaceChanged = jniAccessors.getMethodIDOf(
      _classRef, "surfaceChanged", "(Landroid/view/SurfaceHolder;III)V");

  /// from: public abstract void surfaceChanged(android.view.SurfaceHolder holder, int format, int width, int height)
  ///
  /// This is called immediately after any structural changes (format or
  /// size) have been made to the surface.  You should at this point update
  /// the imagery in the surface.  This method is always called at least
  /// once, after \#surfaceCreated.
  ///@param holder The SurfaceHolder whose surface has changed.
  ///@param format The new PixelFormat of the surface.
  ///@param width The new width of the surface.
  ///@param height The new height of the surface.
  void surfaceChanged(
          SurfaceHolder holder, int format, int width, int height) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_surfaceChanged,
          jni.JniType.voidType,
          [holder.reference, format, width, height]).check();

  static final _id_surfaceDestroyed = jniAccessors.getMethodIDOf(
      _classRef, "surfaceDestroyed", "(Landroid/view/SurfaceHolder;)V");

  /// from: public abstract void surfaceDestroyed(android.view.SurfaceHolder holder)
  ///
  /// This is called immediately before a surface is being destroyed. After
  /// returning from this call, you should no longer try to access this
  /// surface.  If you have a rendering thread that directly accesses
  /// the surface, you must ensure that thread is no longer touching the
  /// Surface before returning from this function.
  ///@param holder The SurfaceHolder whose surface is being destroyed.
  void surfaceDestroyed(SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_surfaceDestroyed,
          jni.JniType.voidType, [holder.reference]).check();
}

/// from: android.view.SurfaceHolder$BadSurfaceTypeException
///
/// Exception that is thrown from \#lockCanvas when called on a Surface
/// whose type is SURFACE_TYPE_PUSH_BUFFERS.
class SurfaceHolder_BadSurfaceTypeException extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/SurfaceHolder\$BadSurfaceTypeException");
  SurfaceHolder_BadSurfaceTypeException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SurfaceHolder_BadSurfaceTypeException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SurfaceHolder_BadSurfaceTypeException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);
}
