// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.ViewConfiguration
///
/// Contains methods to standard constants used in the UI for timeouts, sizes, and distances.
class ViewConfiguration extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ViewConfiguration");
  ViewConfiguration.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use android.view.ViewConfiguration\#get(android.content.Context) instead.
  ViewConfiguration()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_get0 = jniAccessors.getStaticMethodIDOf(_classRef, "get",
      "(Landroid/content/Context;)Landroid/view/ViewConfiguration;");

  /// from: static public android.view.ViewConfiguration get(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a configuration for the specified context. The configuration depends on
  /// various parameters of the context, like the dimension of the display or the
  /// density of the display.
  ///@param context The application context used to initialize the view configuration.
  static ViewConfiguration get0(context_.Context context) =>
      ViewConfiguration.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_get0, jni.JniType.objectType, [context.reference]).object);

  static final _id_getScrollBarSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "getScrollBarSize", "()I");

  /// from: static public int getScrollBarSize()
  ///
  /// @return The width of the horizontal scrollbar and the height of the vertical
  ///         scrollbar in dips
  ///@deprecated Use \#getScaledScrollBarSize() instead.
  static int getScrollBarSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getScrollBarSize, jni.JniType.intType, []).integer;

  static final _id_getScaledScrollBarSize =
      jniAccessors.getMethodIDOf(_classRef, "getScaledScrollBarSize", "()I");

  /// from: public int getScaledScrollBarSize()
  ///
  /// @return The width of the horizontal scrollbar and the height of the vertical
  ///         scrollbar in pixels
  int getScaledScrollBarSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaledScrollBarSize, jni.JniType.intType, []).integer;

  static final _id_getScrollBarFadeDuration = jniAccessors.getStaticMethodIDOf(
      _classRef, "getScrollBarFadeDuration", "()I");

  /// from: static public int getScrollBarFadeDuration()
  ///
  /// @return Duration of the fade when scrollbars fade away in milliseconds
  static int getScrollBarFadeDuration() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getScrollBarFadeDuration, jni.JniType.intType, []).integer;

  static final _id_getScrollDefaultDelay = jniAccessors.getStaticMethodIDOf(
      _classRef, "getScrollDefaultDelay", "()I");

  /// from: static public int getScrollDefaultDelay()
  ///
  /// @return Default delay before the scrollbars fade in milliseconds
  static int getScrollDefaultDelay() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getScrollDefaultDelay, jni.JniType.intType, []).integer;

  static final _id_getFadingEdgeLength =
      jniAccessors.getStaticMethodIDOf(_classRef, "getFadingEdgeLength", "()I");

  /// from: static public int getFadingEdgeLength()
  ///
  /// @return the length of the fading edges in dips
  ///@deprecated Use \#getScaledFadingEdgeLength() instead.
  static int getFadingEdgeLength() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getFadingEdgeLength, jni.JniType.intType, []).integer;

  static final _id_getScaledFadingEdgeLength =
      jniAccessors.getMethodIDOf(_classRef, "getScaledFadingEdgeLength", "()I");

  /// from: public int getScaledFadingEdgeLength()
  ///
  /// @return the length of the fading edges in pixels
  int getScaledFadingEdgeLength() => jniAccessors.callMethodWithArgs(reference,
      _id_getScaledFadingEdgeLength, jni.JniType.intType, []).integer;

  static final _id_getPressedStateDuration = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPressedStateDuration", "()I");

  /// from: static public int getPressedStateDuration()
  ///
  /// @return the duration in milliseconds of the pressed state in child
  /// components.
  static int getPressedStateDuration() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getPressedStateDuration, jni.JniType.intType, []).integer;

  static final _id_getLongPressTimeout =
      jniAccessors.getStaticMethodIDOf(_classRef, "getLongPressTimeout", "()I");

  /// from: static public int getLongPressTimeout()
  ///
  /// @return the duration in milliseconds before a press turns into
  /// a long press
  static int getLongPressTimeout() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getLongPressTimeout, jni.JniType.intType, []).integer;

  static final _id_getKeyRepeatTimeout =
      jniAccessors.getStaticMethodIDOf(_classRef, "getKeyRepeatTimeout", "()I");

  /// from: static public int getKeyRepeatTimeout()
  ///
  /// @return the time before the first key repeat in milliseconds.
  static int getKeyRepeatTimeout() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getKeyRepeatTimeout, jni.JniType.intType, []).integer;

  static final _id_getKeyRepeatDelay =
      jniAccessors.getStaticMethodIDOf(_classRef, "getKeyRepeatDelay", "()I");

  /// from: static public int getKeyRepeatDelay()
  ///
  /// @return the time between successive key repeats in milliseconds.
  static int getKeyRepeatDelay() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getKeyRepeatDelay, jni.JniType.intType, []).integer;

  static final _id_getTapTimeout =
      jniAccessors.getStaticMethodIDOf(_classRef, "getTapTimeout", "()I");

  /// from: static public int getTapTimeout()
  ///
  /// @return the duration in milliseconds we will wait to see if a touch event
  /// is a tap or a scroll. If the user does not move within this interval, it is
  /// considered to be a tap.
  static int getTapTimeout() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getTapTimeout, jni.JniType.intType, []).integer;

  static final _id_getJumpTapTimeout =
      jniAccessors.getStaticMethodIDOf(_classRef, "getJumpTapTimeout", "()I");

  /// from: static public int getJumpTapTimeout()
  ///
  /// @return the duration in milliseconds we will wait to see if a touch event
  /// is a jump tap. If the user does not move within this interval, it is
  /// considered to be a tap.
  static int getJumpTapTimeout() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getJumpTapTimeout, jni.JniType.intType, []).integer;

  static final _id_getDoubleTapTimeout =
      jniAccessors.getStaticMethodIDOf(_classRef, "getDoubleTapTimeout", "()I");

  /// from: static public int getDoubleTapTimeout()
  ///
  /// @return the duration in milliseconds between the first tap's up event and
  /// the second tap's down event for an interaction to be considered a
  /// double-tap.
  static int getDoubleTapTimeout() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getDoubleTapTimeout, jni.JniType.intType, []).integer;

  static final _id_getEdgeSlop =
      jniAccessors.getStaticMethodIDOf(_classRef, "getEdgeSlop", "()I");

  /// from: static public int getEdgeSlop()
  ///
  /// @return Inset in dips to look for touchable content when the user touches the edge of the
  ///         screen
  ///@deprecated Use \#getScaledEdgeSlop() instead.
  static int getEdgeSlop() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getEdgeSlop, jni.JniType.intType, []).integer;

  static final _id_getScaledEdgeSlop =
      jniAccessors.getMethodIDOf(_classRef, "getScaledEdgeSlop", "()I");

  /// from: public int getScaledEdgeSlop()
  ///
  /// @return Inset in pixels to look for touchable content when the user touches the edge of the
  ///         screen
  int getScaledEdgeSlop() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaledEdgeSlop, jni.JniType.intType, []).integer;

  static final _id_getTouchSlop =
      jniAccessors.getStaticMethodIDOf(_classRef, "getTouchSlop", "()I");

  /// from: static public int getTouchSlop()
  ///
  /// @return Distance in dips a touch can wander before we think the user is scrolling
  ///@deprecated Use \#getScaledTouchSlop() instead.
  static int getTouchSlop() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getTouchSlop, jni.JniType.intType, []).integer;

  static final _id_getScaledTouchSlop =
      jniAccessors.getMethodIDOf(_classRef, "getScaledTouchSlop", "()I");

  /// from: public int getScaledTouchSlop()
  ///
  /// @return Distance in pixels a touch can wander before we think the user is scrolling
  int getScaledTouchSlop() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaledTouchSlop, jni.JniType.intType, []).integer;

  static final _id_getScaledHoverSlop =
      jniAccessors.getMethodIDOf(_classRef, "getScaledHoverSlop", "()I");

  /// from: public int getScaledHoverSlop()
  ///
  /// @return Distance in pixels a hover can wander while it is still considered "stationary".
  int getScaledHoverSlop() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaledHoverSlop, jni.JniType.intType, []).integer;

  static final _id_getScaledPagingTouchSlop =
      jniAccessors.getMethodIDOf(_classRef, "getScaledPagingTouchSlop", "()I");

  /// from: public int getScaledPagingTouchSlop()
  ///
  /// @return Distance in pixels a touch can wander before we think the user is scrolling a full
  /// page
  int getScaledPagingTouchSlop() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaledPagingTouchSlop, jni.JniType.intType, []).integer;

  static final _id_getScaledDoubleTapSlop =
      jniAccessors.getMethodIDOf(_classRef, "getScaledDoubleTapSlop", "()I");

  /// from: public int getScaledDoubleTapSlop()
  ///
  /// @return Distance in pixels between the first touch and second touch to still be
  ///         considered a double tap
  int getScaledDoubleTapSlop() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaledDoubleTapSlop, jni.JniType.intType, []).integer;

  static final _id_getWindowTouchSlop =
      jniAccessors.getStaticMethodIDOf(_classRef, "getWindowTouchSlop", "()I");

  /// from: static public int getWindowTouchSlop()
  ///
  /// @return Distance in dips a touch must be outside the bounds of a window for it
  /// to be counted as outside the window for purposes of dismissing that
  /// window.
  ///@deprecated Use \#getScaledWindowTouchSlop() instead.
  static int getWindowTouchSlop() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getWindowTouchSlop, jni.JniType.intType, []).integer;

  static final _id_getScaledWindowTouchSlop =
      jniAccessors.getMethodIDOf(_classRef, "getScaledWindowTouchSlop", "()I");

  /// from: public int getScaledWindowTouchSlop()
  ///
  /// @return Distance in pixels a touch must be outside the bounds of a window for it
  /// to be counted as outside the window for purposes of dismissing that window.
  int getScaledWindowTouchSlop() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaledWindowTouchSlop, jni.JniType.intType, []).integer;

  static final _id_getMinimumFlingVelocity = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMinimumFlingVelocity", "()I");

  /// from: static public int getMinimumFlingVelocity()
  ///
  /// @return Minimum velocity to initiate a fling, as measured in dips per second.
  ///@deprecated Use \#getScaledMinimumFlingVelocity() instead.
  static int getMinimumFlingVelocity() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMinimumFlingVelocity, jni.JniType.intType, []).integer;

  static final _id_getScaledMinimumFlingVelocity = jniAccessors.getMethodIDOf(
      _classRef, "getScaledMinimumFlingVelocity", "()I");

  /// from: public int getScaledMinimumFlingVelocity()
  ///
  /// @return Minimum velocity to initiate a fling, as measured in pixels per second.
  int getScaledMinimumFlingVelocity() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledMinimumFlingVelocity,
      jni.JniType.intType, []).integer;

  static final _id_getMaximumFlingVelocity = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMaximumFlingVelocity", "()I");

  /// from: static public int getMaximumFlingVelocity()
  ///
  /// @return Maximum velocity to initiate a fling, as measured in dips per second.
  ///@deprecated Use \#getScaledMaximumFlingVelocity() instead.
  static int getMaximumFlingVelocity() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMaximumFlingVelocity, jni.JniType.intType, []).integer;

  static final _id_getScaledMaximumFlingVelocity = jniAccessors.getMethodIDOf(
      _classRef, "getScaledMaximumFlingVelocity", "()I");

  /// from: public int getScaledMaximumFlingVelocity()
  ///
  /// @return Maximum velocity to initiate a fling, as measured in pixels per second.
  int getScaledMaximumFlingVelocity() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledMaximumFlingVelocity,
      jni.JniType.intType, []).integer;

  static final _id_getScaledHorizontalScrollFactor = jniAccessors.getMethodIDOf(
      _classRef, "getScaledHorizontalScrollFactor", "()F");

  /// from: public float getScaledHorizontalScrollFactor()
  ///
  /// @return Amount to scroll in response to a horizontal MotionEvent\#ACTION_SCROLL event.
  /// Multiply this by the event's axis value to obtain the number of pixels to be scrolled.
  double getScaledHorizontalScrollFactor() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledHorizontalScrollFactor,
      jni.JniType.floatType, []).float;

  static final _id_getScaledVerticalScrollFactor = jniAccessors.getMethodIDOf(
      _classRef, "getScaledVerticalScrollFactor", "()F");

  /// from: public float getScaledVerticalScrollFactor()
  ///
  /// @return Amount to scroll in response to a vertical MotionEvent\#ACTION_SCROLL event.
  /// Multiply this by the event's axis value to obtain the number of pixels to be scrolled.
  double getScaledVerticalScrollFactor() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledVerticalScrollFactor,
      jni.JniType.floatType, []).float;

  static final _id_getMaximumDrawingCacheSize = jniAccessors
      .getStaticMethodIDOf(_classRef, "getMaximumDrawingCacheSize", "()I");

  /// from: static public int getMaximumDrawingCacheSize()
  ///
  /// The maximum drawing cache size expressed in bytes.
  ///@return the maximum size of View's drawing cache expressed in bytes
  ///@deprecated Use \#getScaledMaximumDrawingCacheSize() instead.
  static int getMaximumDrawingCacheSize() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getMaximumDrawingCacheSize, jni.JniType.intType, []).integer;

  static final _id_getScaledMaximumDrawingCacheSize = jniAccessors
      .getMethodIDOf(_classRef, "getScaledMaximumDrawingCacheSize", "()I");

  /// from: public int getScaledMaximumDrawingCacheSize()
  ///
  /// The maximum drawing cache size expressed in bytes.
  ///@return the maximum size of View's drawing cache expressed in bytes
  int getScaledMaximumDrawingCacheSize() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledMaximumDrawingCacheSize,
      jni.JniType.intType, []).integer;

  static final _id_getScaledOverscrollDistance = jniAccessors.getMethodIDOf(
      _classRef, "getScaledOverscrollDistance", "()I");

  /// from: public int getScaledOverscrollDistance()
  ///
  /// @return The maximum distance a View should overscroll by when showing edge effects (in
  /// pixels).
  int getScaledOverscrollDistance() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledOverscrollDistance,
      jni.JniType.intType, []).integer;

  static final _id_getScaledOverflingDistance = jniAccessors.getMethodIDOf(
      _classRef, "getScaledOverflingDistance", "()I");

  /// from: public int getScaledOverflingDistance()
  ///
  /// @return The maximum distance a View should overfling by when showing edge effects (in
  /// pixels).
  int getScaledOverflingDistance() => jniAccessors.callMethodWithArgs(reference,
      _id_getScaledOverflingDistance, jni.JniType.intType, []).integer;

  static final _id_getZoomControlsTimeout = jniAccessors.getStaticMethodIDOf(
      _classRef, "getZoomControlsTimeout", "()J");

  /// from: static public long getZoomControlsTimeout()
  ///
  /// The amount of time that the zoom controls should be
  /// displayed on the screen expressed in milliseconds.
  ///@return the time the zoom controls should be visible expressed
  /// in milliseconds.
  static int getZoomControlsTimeout() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getZoomControlsTimeout, jni.JniType.longType, []).long;

  static final _id_getGlobalActionKeyTimeout = jniAccessors.getStaticMethodIDOf(
      _classRef, "getGlobalActionKeyTimeout", "()J");

  /// from: static public long getGlobalActionKeyTimeout()
  ///
  /// The amount of time a user needs to press the relevant key to bring up
  /// the global actions dialog.
  ///@return how long a user needs to press the relevant key to bring up
  ///   the global actions dialog.
  ///@deprecated This timeout should not be used by applications
  static int getGlobalActionKeyTimeout() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getGlobalActionKeyTimeout, jni.JniType.longType, []).long;

  static final _id_getScrollFriction =
      jniAccessors.getStaticMethodIDOf(_classRef, "getScrollFriction", "()F");

  /// from: static public float getScrollFriction()
  ///
  /// The amount of friction applied to scrolls and flings.
  ///@return A scalar dimensionless value representing the coefficient of
  ///         friction.
  static double getScrollFriction() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getScrollFriction, jni.JniType.floatType, []).float;

  static final _id_getDefaultActionModeHideDuration =
      jniAccessors.getStaticMethodIDOf(
          _classRef, "getDefaultActionModeHideDuration", "()J");

  /// from: static public long getDefaultActionModeHideDuration()
  ///
  /// @return the default duration in milliseconds for ActionMode\#hide(long).
  static int getDefaultActionModeHideDuration() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getDefaultActionModeHideDuration, jni.JniType.longType, []).long;

  static final _id_hasPermanentMenuKey =
      jniAccessors.getMethodIDOf(_classRef, "hasPermanentMenuKey", "()Z");

  /// from: public boolean hasPermanentMenuKey()
  ///
  /// Report if the device has a permanent menu key available to the user.
  ///
  /// As of Android 3.0, devices may not have a permanent menu key available.
  /// Apps should use the action bar to present menu options to users.
  /// However, there are some apps where the action bar is inappropriate
  /// or undesirable. This method may be used to detect if a menu key is present.
  /// If not, applications should provide another on-screen affordance to access
  /// functionality.
  ///@return true if a permanent menu key is present, false otherwise.
  bool hasPermanentMenuKey() => jniAccessors.callMethodWithArgs(
      reference, _id_hasPermanentMenuKey, jni.JniType.booleanType, []).boolean;

  static final _id_shouldShowMenuShortcutsWhenKeyboardPresent =
      jniAccessors.getMethodIDOf(
          _classRef, "shouldShowMenuShortcutsWhenKeyboardPresent", "()Z");

  /// from: public boolean shouldShowMenuShortcutsWhenKeyboardPresent()
  ///
  /// Check if shortcuts should be displayed in menus.
  ///@return {@code True} if shortcuts should be displayed in menus.
  bool shouldShowMenuShortcutsWhenKeyboardPresent() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_shouldShowMenuShortcutsWhenKeyboardPresent,
          jni.JniType.booleanType, []).boolean;
}
