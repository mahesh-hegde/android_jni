// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../View.dart" as view_;

import "../../os/Bundle.dart" as bundle_;

import "AccessibilityWindowInfo.dart" as accessibilitywindowinfo_;

import "../../graphics/Rect.dart" as rect_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.accessibility.AccessibilityNodeInfo
///
/// This class represents a node of the window content as well as actions that
/// can be requested from its source. From the point of view of an
/// android.accessibilityservice.AccessibilityService a window's content is
/// presented as a tree of accessibility node infos, which may or may not map one-to-one
/// to the view hierarchy. In other words, a custom view is free to report itself as
/// a tree of accessibility node info.
///
///
///
/// Once an accessibility node info is delivered to an accessibility service it is
/// made immutable and calling a state mutation method generates an error.
///
///
///
/// Please refer to android.accessibilityservice.AccessibilityService for
/// details about how to obtain a handle to window content as a tree of accessibility
/// node info as well as details about the security model.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about making applications accessible, read the
/// <a href="{@docRoot}guide/topics/ui/accessibility/index.html">Accessibility</a>
/// developer guide.
///
/// </div>
///@see android.accessibilityservice.AccessibilityService
///@see AccessibilityEvent
///@see AccessibilityManager
class AccessibilityNodeInfo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/accessibility/AccessibilityNodeInfo");
  AccessibilityNodeInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ACTION_ACCESSIBILITY_FOCUS
  ///
  /// Action that gives accessibility focus to the node.
  static const ACTION_ACCESSIBILITY_FOCUS = 64;

  /// from: static public final java.lang.String ACTION_ARGUMENT_COLUMN_INT
  ///
  /// Argument for specifying the collection column to make visible on screen.
  ///
  /// <strong>Type:</strong> int<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_SCROLL_TO_POSITION</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_SCROLL_TO_POSITION
  static const ACTION_ARGUMENT_COLUMN_INT =
      "android.view.accessibility.action.ARGUMENT_COLUMN_INT";

  /// from: static public final java.lang.String ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN
  ///
  /// Argument for whether when moving at granularity to extend the selection
  /// or to move it otherwise.
  ///
  /// <strong>Type:</strong> boolean<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_NEXT_AT_MOVEMENT_GRANULARITY</li>
  ///     <li>AccessibilityAction\#ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_NEXT_AT_MOVEMENT_GRANULARITY
  ///@see AccessibilityAction\#ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY
  static const ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN =
      "ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN";

  /// from: static public final java.lang.String ACTION_ARGUMENT_HTML_ELEMENT_STRING
  ///
  /// Argument for which HTML element to get moving to the next/previous HTML element.
  ///
  /// <strong>Type:</strong> String<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_NEXT_HTML_ELEMENT</li>
  ///     <li>AccessibilityAction\#ACTION_PREVIOUS_HTML_ELEMENT</li>
  /// </ul>
  ///
  ///
  ///@see AccessibilityAction\#ACTION_NEXT_HTML_ELEMENT
  ///@see AccessibilityAction\#ACTION_PREVIOUS_HTML_ELEMENT
  static const ACTION_ARGUMENT_HTML_ELEMENT_STRING =
      "ACTION_ARGUMENT_HTML_ELEMENT_STRING";

  /// from: static public final java.lang.String ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT
  ///
  /// Argument for which movement granularity to be used when traversing the node text.
  ///
  /// <strong>Type:</strong> int<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_NEXT_AT_MOVEMENT_GRANULARITY</li>
  ///     <li>AccessibilityAction\#ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY</li>
  /// </ul>
  ///
  ///
  ///@see AccessibilityAction\#ACTION_NEXT_AT_MOVEMENT_GRANULARITY
  ///@see AccessibilityAction\#ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY
  static const ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT =
      "ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT";

  /// from: static public final java.lang.String ACTION_ARGUMENT_MOVE_WINDOW_X
  ///
  /// Argument for specifying the x coordinate to which to move a window.
  ///
  /// <strong>Type:</strong> int<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_MOVE_WINDOW</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_MOVE_WINDOW
  static const ACTION_ARGUMENT_MOVE_WINDOW_X = "ACTION_ARGUMENT_MOVE_WINDOW_X";

  /// from: static public final java.lang.String ACTION_ARGUMENT_MOVE_WINDOW_Y
  ///
  /// Argument for specifying the y coordinate to which to move a window.
  ///
  /// <strong>Type:</strong> int<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_MOVE_WINDOW</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_MOVE_WINDOW
  static const ACTION_ARGUMENT_MOVE_WINDOW_Y = "ACTION_ARGUMENT_MOVE_WINDOW_Y";

  /// from: static public final java.lang.String ACTION_ARGUMENT_PROGRESS_VALUE
  ///
  /// Argument for specifying the progress value to set.
  ///
  /// <strong>Type:</strong> float<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_SET_PROGRESS</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_SET_PROGRESS
  static const ACTION_ARGUMENT_PROGRESS_VALUE =
      "android.view.accessibility.action.ARGUMENT_PROGRESS_VALUE";

  /// from: static public final java.lang.String ACTION_ARGUMENT_ROW_INT
  ///
  /// Argument for specifying the collection row to make visible on screen.
  ///
  /// <strong>Type:</strong> int<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_SCROLL_TO_POSITION</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_SCROLL_TO_POSITION
  static const ACTION_ARGUMENT_ROW_INT =
      "android.view.accessibility.action.ARGUMENT_ROW_INT";

  /// from: static public final java.lang.String ACTION_ARGUMENT_SELECTION_END_INT
  ///
  /// Argument for specifying the selection end.
  ///
  /// <strong>Type:</strong> int<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_SET_SELECTION</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_SET_SELECTION
  static const ACTION_ARGUMENT_SELECTION_END_INT =
      "ACTION_ARGUMENT_SELECTION_END_INT";

  /// from: static public final java.lang.String ACTION_ARGUMENT_SELECTION_START_INT
  ///
  /// Argument for specifying the selection start.
  ///
  /// <strong>Type:</strong> int<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_SET_SELECTION</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_SET_SELECTION
  static const ACTION_ARGUMENT_SELECTION_START_INT =
      "ACTION_ARGUMENT_SELECTION_START_INT";

  /// from: static public final java.lang.String ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE
  ///
  /// Argument for specifying the text content to set.
  ///
  /// <strong>Type:</strong> CharSequence<br>
  /// <strong>Actions:</strong>
  /// <ul>
  ///     <li>AccessibilityAction\#ACTION_SET_TEXT</li>
  /// </ul>
  ///@see AccessibilityAction\#ACTION_SET_TEXT
  static const ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE =
      "ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE";

  /// from: static public final int ACTION_CLEAR_ACCESSIBILITY_FOCUS
  ///
  /// Action that clears accessibility focus of the node.
  static const ACTION_CLEAR_ACCESSIBILITY_FOCUS = 128;

  /// from: static public final int ACTION_CLEAR_FOCUS
  ///
  /// Action that clears input focus of the node.
  static const ACTION_CLEAR_FOCUS = 2;

  /// from: static public final int ACTION_CLEAR_SELECTION
  ///
  /// Action that deselects the node.
  static const ACTION_CLEAR_SELECTION = 8;

  /// from: static public final int ACTION_CLICK
  ///
  /// Action that clicks on the node info.
  ///
  /// See AccessibilityAction\#ACTION_CLICK
  static const ACTION_CLICK = 16;

  /// from: static public final int ACTION_COLLAPSE
  ///
  /// Action to collapse an expandable node.
  static const ACTION_COLLAPSE = 524288;

  /// from: static public final int ACTION_COPY
  ///
  /// Action to copy the current selection to the clipboard.
  static const ACTION_COPY = 16384;

  /// from: static public final int ACTION_CUT
  ///
  /// Action to cut the current selection and place it to the clipboard.
  static const ACTION_CUT = 65536;

  /// from: static public final int ACTION_DISMISS
  ///
  /// Action to dismiss a dismissable node.
  static const ACTION_DISMISS = 1048576;

  /// from: static public final int ACTION_EXPAND
  ///
  /// Action to expand an expandable node.
  static const ACTION_EXPAND = 262144;

  /// from: static public final int ACTION_FOCUS
  ///
  /// Action that gives input focus to the node.
  static const ACTION_FOCUS = 1;

  /// from: static public final int ACTION_LONG_CLICK
  ///
  /// Action that long clicks on the node.
  static const ACTION_LONG_CLICK = 32;

  /// from: static public final int ACTION_NEXT_AT_MOVEMENT_GRANULARITY
  ///
  /// Action that requests to go to the next entity in this node's text
  /// at a given movement granularity. For example, move to the next character,
  /// word, etc.
  ///
  /// <strong>Arguments:</strong> \#ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT<,
  /// \#ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN<br>
  /// <strong>Example:</strong> Move to the previous character and do not extend selection.
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT,
  ///           AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER);
  ///   arguments.putBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN,
  ///           false);
  ///   info.performAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY, arguments);
  /// </code></pre>
  ///
  ///
  ///
  ///@see \#ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT
  ///@see \#ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN
  ///@see \#setMovementGranularities(int)
  ///@see \#getMovementGranularities()
  ///@see \#MOVEMENT_GRANULARITY_CHARACTER
  ///@see \#MOVEMENT_GRANULARITY_WORD
  ///@see \#MOVEMENT_GRANULARITY_LINE
  ///@see \#MOVEMENT_GRANULARITY_PARAGRAPH
  ///@see \#MOVEMENT_GRANULARITY_PAGE
  static const ACTION_NEXT_AT_MOVEMENT_GRANULARITY = 256;

  /// from: static public final int ACTION_NEXT_HTML_ELEMENT
  ///
  /// Action to move to the next HTML element of a given type. For example, move
  /// to the BUTTON, INPUT, TABLE, etc.
  ///
  /// <strong>Arguments:</strong> \#ACTION_ARGUMENT_HTML_ELEMENT_STRING<br>
  /// <strong>Example:</strong>
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putString(AccessibilityNodeInfo.ACTION_ARGUMENT_HTML_ELEMENT_STRING, "BUTTON");
  ///   info.performAction(AccessibilityNodeInfo.ACTION_NEXT_HTML_ELEMENT, arguments);
  /// </code></pre>
  ///
  ///
  ///
  static const ACTION_NEXT_HTML_ELEMENT = 1024;

  /// from: static public final int ACTION_PASTE
  ///
  /// Action to paste the current clipboard content.
  static const ACTION_PASTE = 32768;

  /// from: static public final int ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY
  ///
  /// Action that requests to go to the previous entity in this node's text
  /// at a given movement granularity. For example, move to the next character,
  /// word, etc.
  ///
  /// <strong>Arguments:</strong> \#ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT<,
  /// \#ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN<br>
  /// <strong>Example:</strong> Move to the next character and do not extend selection.
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT,
  ///           AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER);
  ///   arguments.putBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN,
  ///           false);
  ///   info.performAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY,
  ///           arguments);
  /// </code></pre>
  ///
  ///
  ///
  ///@see \#ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT
  ///@see \#ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN
  ///@see \#setMovementGranularities(int)
  ///@see \#getMovementGranularities()
  ///@see \#MOVEMENT_GRANULARITY_CHARACTER
  ///@see \#MOVEMENT_GRANULARITY_WORD
  ///@see \#MOVEMENT_GRANULARITY_LINE
  ///@see \#MOVEMENT_GRANULARITY_PARAGRAPH
  ///@see \#MOVEMENT_GRANULARITY_PAGE
  static const ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY = 512;

  /// from: static public final int ACTION_PREVIOUS_HTML_ELEMENT
  ///
  /// Action to move to the previous HTML element of a given type. For example, move
  /// to the BUTTON, INPUT, TABLE, etc.
  ///
  /// <strong>Arguments:</strong> \#ACTION_ARGUMENT_HTML_ELEMENT_STRING<br>
  /// <strong>Example:</strong>
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putString(AccessibilityNodeInfo.ACTION_ARGUMENT_HTML_ELEMENT_STRING, "BUTTON");
  ///   info.performAction(AccessibilityNodeInfo.ACTION_PREVIOUS_HTML_ELEMENT, arguments);
  /// </code></pre>
  ///
  ///
  ///
  static const ACTION_PREVIOUS_HTML_ELEMENT = 2048;

  /// from: static public final int ACTION_SCROLL_BACKWARD
  ///
  /// Action to scroll the node content backward.
  static const ACTION_SCROLL_BACKWARD = 8192;

  /// from: static public final int ACTION_SCROLL_FORWARD
  ///
  /// Action to scroll the node content forward.
  static const ACTION_SCROLL_FORWARD = 4096;

  /// from: static public final int ACTION_SELECT
  ///
  /// Action that selects the node.
  static const ACTION_SELECT = 4;

  /// from: static public final int ACTION_SET_SELECTION
  ///
  /// Action to set the selection. Performing this action with no arguments
  /// clears the selection.
  ///
  /// <strong>Arguments:</strong>
  /// \#ACTION_ARGUMENT_SELECTION_START_INT,
  /// \#ACTION_ARGUMENT_SELECTION_END_INT<br>
  /// <strong>Example:</strong>
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, 1);
  ///   arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, 2);
  ///   info.performAction(AccessibilityNodeInfo.ACTION_SET_SELECTION, arguments);
  /// </code></pre>
  ///
  ///
  ///
  ///@see \#ACTION_ARGUMENT_SELECTION_START_INT
  ///@see \#ACTION_ARGUMENT_SELECTION_END_INT
  static const ACTION_SET_SELECTION = 131072;

  /// from: static public final int ACTION_SET_TEXT
  ///
  /// Action that sets the text of the node. Performing the action without argument, using <code>
  /// null</code> or empty CharSequence will clear the text. This action will also put the
  /// cursor at the end of text.
  ///
  /// <strong>Arguments:</strong>
  /// \#ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE<br>
  /// <strong>Example:</strong>
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE,
  ///       "android");
  ///   info.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, arguments);
  /// </code></pre>
  ///
  static const ACTION_SET_TEXT = 2097152;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.accessibility.AccessibilityNodeInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see android.os.Parcelable.Creator
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_LENGTH
  ///
  /// Integer argument specifying the end index of the requested text location data. Must be
  /// positive.
  ///
  /// {@see EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY}
  static const EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_LENGTH =
      "android.view.accessibility.extra.DATA_TEXT_CHARACTER_LOCATION_ARG_LENGTH";

  /// from: static public final java.lang.String EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_START_INDEX
  ///
  /// Integer argument specifying the start index of the requested text location data. Must be
  /// valid inside the CharSequence returned by \#getText().
  ///
  /// {@see EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY}
  static const EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_START_INDEX =
      "android.view.accessibility.extra.DATA_TEXT_CHARACTER_LOCATION_ARG_START_INDEX";

  /// from: static public final java.lang.String EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY
  ///
  /// Key used to request and locate extra data for text character location. This key requests that
  /// an array of android.graphics.RectFs be added to the extras. This request is made with
  /// \#refreshWithExtraData(String, Bundle). The arguments taken by this request are two
  /// integers: \#EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_START_INDEX and
  /// \#EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_LENGTH. The starting index must be valid
  /// inside the CharSequence returned by \#getText(), and the length must be positive.
  ///
  /// The data can be retrieved from the {@code Bundle} returned by \#getExtras() using this
  /// string as a key for Bundle\#getParcelableArray(String). The
  /// android.graphics.RectF will be null for characters that either do not exist or are
  /// off the screen.
  ///
  /// {@see \#refreshWithExtraData(String, Bundle)}
  static const EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY =
      "android.view.accessibility.extra.DATA_TEXT_CHARACTER_LOCATION_KEY";

  /// from: static public final int FOCUS_ACCESSIBILITY
  ///
  /// The accessibility focus.
  static const FOCUS_ACCESSIBILITY = 2;

  /// from: static public final int FOCUS_INPUT
  ///
  /// The input focus.
  static const FOCUS_INPUT = 1;

  /// from: static public final int MOVEMENT_GRANULARITY_CHARACTER
  ///
  /// Movement granularity bit for traversing the text of a node by character.
  static const MOVEMENT_GRANULARITY_CHARACTER = 1;

  /// from: static public final int MOVEMENT_GRANULARITY_LINE
  ///
  /// Movement granularity bit for traversing the text of a node by line.
  static const MOVEMENT_GRANULARITY_LINE = 4;

  /// from: static public final int MOVEMENT_GRANULARITY_PAGE
  ///
  /// Movement granularity bit for traversing the text of a node by page.
  static const MOVEMENT_GRANULARITY_PAGE = 16;

  /// from: static public final int MOVEMENT_GRANULARITY_PARAGRAPH
  ///
  /// Movement granularity bit for traversing the text of a node by paragraph.
  static const MOVEMENT_GRANULARITY_PARAGRAPH = 8;

  /// from: static public final int MOVEMENT_GRANULARITY_WORD
  ///
  /// Movement granularity bit for traversing the text of a node by word.
  static const MOVEMENT_GRANULARITY_WORD = 2;

  static final _id_setSource = jniAccessors.getMethodIDOf(
      _classRef, "setSource", "(Landroid/view/View;)V");

  /// from: public void setSource(android.view.View source)
  ///
  /// Sets the source.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param source The info source.
  void setSource(view_.View source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSource,
      jni.JniType.voidType,
      [source.reference]).check();

  static final _id_setSource1 = jniAccessors.getMethodIDOf(
      _classRef, "setSource", "(Landroid/view/View;I)V");

  /// from: public void setSource(android.view.View root, int virtualDescendantId)
  ///
  /// Sets the source to be a virtual descendant of the given <code>root</code>.
  /// If <code>virtualDescendantId</code> is View\#NO_ID the root
  /// is set as the source.
  ///
  /// A virtual descendant is an imaginary View that is reported as a part of the view
  /// hierarchy for accessibility purposes. This enables custom views that draw complex
  /// content to report themselves as a tree of virtual views, thus conveying their
  /// logical structure.
  ///
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param root The root of the virtual subtree.
  ///@param virtualDescendantId The id of the virtual descendant.
  void setSource1(view_.View root, int virtualDescendantId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSource1,
          jni.JniType.voidType, [root.reference, virtualDescendantId]).check();

  static final _id_findFocus = jniAccessors.getMethodIDOf(_classRef,
      "findFocus", "(I)Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo findFocus(int focus)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the view that has the specified focus type. The search starts from
  /// the view represented by this node info.
  ///@param focus The focus to find. One of \#FOCUS_INPUT or
  ///         \#FOCUS_ACCESSIBILITY.
  ///@return The node info of the focused view or null.
  ///@see \#FOCUS_INPUT
  ///@see \#FOCUS_ACCESSIBILITY
  AccessibilityNodeInfo findFocus(int focus) =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_findFocus, jni.JniType.objectType, [focus]).object);

  static final _id_focusSearch = jniAccessors.getMethodIDOf(_classRef,
      "focusSearch", "(I)Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo focusSearch(int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Searches for the nearest view in the specified direction that can take
  /// the input focus.
  ///@param direction The direction. Can be one of:
  ///     View\#FOCUS_DOWN,
  ///     View\#FOCUS_UP,
  ///     View\#FOCUS_LEFT,
  ///     View\#FOCUS_RIGHT,
  ///     View\#FOCUS_FORWARD,
  ///     View\#FOCUS_BACKWARD.
  ///@return The node info for the view that can take accessibility focus.
  AccessibilityNodeInfo focusSearch(int direction) =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_focusSearch, jni.JniType.objectType, [direction]).object);

  static final _id_getWindowId =
      jniAccessors.getMethodIDOf(_classRef, "getWindowId", "()I");

  /// from: public int getWindowId()
  ///
  /// Gets the id of the window from which the info comes from.
  ///@return The window id.
  int getWindowId() => jniAccessors.callMethodWithArgs(
      reference, _id_getWindowId, jni.JniType.intType, []).integer;

  static final _id_refresh =
      jniAccessors.getMethodIDOf(_classRef, "refresh", "()Z");

  /// from: public boolean refresh()
  ///
  /// Refreshes this info with the latest state of the view it represents.
  ///@return {@code true} if the refresh succeeded. {@code false} if the View represented
  /// by this node is no longer in the view tree (and thus this node is obsolete and should be
  /// recycled).
  bool refresh() => jniAccessors.callMethodWithArgs(
      reference, _id_refresh, jni.JniType.booleanType, []).boolean;

  static final _id_refreshWithExtraData = jniAccessors.getMethodIDOf(_classRef,
      "refreshWithExtraData", "(Ljava/lang/String;Landroid/os/Bundle;)Z");

  /// from: public boolean refreshWithExtraData(java.lang.String extraDataKey, android.os.Bundle args)
  ///
  /// Refreshes this info with the latest state of the view it represents, and request new
  /// data be added by the View.
  ///@param extraDataKey The extra data requested. Data that must be requested
  ///                     with this mechanism is generally expensive to retrieve, so should only be
  ///                     requested when needed. See
  ///                     \#EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY and
  ///                     \#getAvailableExtraData().
  ///@param args A bundle of arguments for the request. These depend on the particular request.
  ///@return {@code true} if the refresh succeeded. {@code false} if the View represented
  /// by this node is no longer in the view tree (and thus this node is obsolete and should be
  /// recycled).
  bool refreshWithExtraData(jni.JniString extraDataKey, bundle_.Bundle args) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_refreshWithExtraData,
          jni.JniType.booleanType,
          [extraDataKey.reference, args.reference]).boolean;

  static final _id_getChildCount =
      jniAccessors.getMethodIDOf(_classRef, "getChildCount", "()I");

  /// from: public int getChildCount()
  ///
  /// Gets the number of children.
  ///@return The child count.
  int getChildCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getChildCount, jni.JniType.intType, []).integer;

  static final _id_getChild = jniAccessors.getMethodIDOf(_classRef, "getChild",
      "(I)Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo getChild(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the child at given index.
  ///
  ///   <strong>Note:</strong> It is a client responsibility to recycle the
  ///     received info by calling AccessibilityNodeInfo\#recycle()
  ///     to avoid creating of multiple instances.
  ///
  ///
  ///@param index The child index.
  ///@return The child node.
  ///@throws IllegalStateException If called outside of an AccessibilityService.
  AccessibilityNodeInfo getChild(int index) =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChild, jni.JniType.objectType, [index]).object);

  static final _id_addChild = jniAccessors.getMethodIDOf(
      _classRef, "addChild", "(Landroid/view/View;)V");

  /// from: public void addChild(android.view.View child)
  ///
  /// Adds a child.
  ///
  /// <strong>Note:</strong> Cannot be called from an
  /// android.accessibilityservice.AccessibilityService.
  /// This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param child The child.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void addChild(view_.View child) => jniAccessors.callMethodWithArgs(
      reference, _id_addChild, jni.JniType.voidType, [child.reference]).check();

  static final _id_removeChild = jniAccessors.getMethodIDOf(
      _classRef, "removeChild", "(Landroid/view/View;)Z");

  /// from: public boolean removeChild(android.view.View child)
  ///
  /// Removes a child. If the child was not previously added to the node,
  /// calling this method has no effect.
  ///
  /// <strong>Note:</strong> Cannot be called from an
  /// android.accessibilityservice.AccessibilityService.
  /// This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param child The child.
  ///@return true if the child was present
  ///@throws IllegalStateException If called from an AccessibilityService.
  bool removeChild(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeChild,
      jni.JniType.booleanType,
      [child.reference]).boolean;

  static final _id_addChild1 = jniAccessors.getMethodIDOf(
      _classRef, "addChild", "(Landroid/view/View;I)V");

  /// from: public void addChild(android.view.View root, int virtualDescendantId)
  ///
  /// Adds a virtual child which is a descendant of the given <code>root</code>.
  /// If <code>virtualDescendantId</code> is View\#NO_ID the root
  /// is added as a child.
  ///
  /// A virtual descendant is an imaginary View that is reported as a part of the view
  /// hierarchy for accessibility purposes. This enables custom views that draw complex
  /// content to report them selves as a tree of virtual views, thus conveying their
  /// logical structure.
  ///
  ///
  ///@param root The root of the virtual subtree.
  ///@param virtualDescendantId The id of the virtual child.
  void addChild1(view_.View root, int virtualDescendantId) =>
      jniAccessors.callMethodWithArgs(reference, _id_addChild1,
          jni.JniType.voidType, [root.reference, virtualDescendantId]).check();

  static final _id_removeChild1 = jniAccessors.getMethodIDOf(
      _classRef, "removeChild", "(Landroid/view/View;I)Z");

  /// from: public boolean removeChild(android.view.View root, int virtualDescendantId)
  ///
  /// Removes a virtual child which is a descendant of the given
  /// <code>root</code>. If the child was not previously added to the node,
  /// calling this method has no effect.
  ///@param root The root of the virtual subtree.
  ///@param virtualDescendantId The id of the virtual child.
  ///@return true if the child was present
  ///@see \#addChild(View, int)
  bool removeChild1(view_.View root, int virtualDescendantId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeChild1,
          jni.JniType.booleanType,
          [root.reference, virtualDescendantId]).boolean;

  static final _id_getActionList = jniAccessors.getMethodIDOf(
      _classRef, "getActionList", "()Ljava/util/List;");

  /// from: public java.util.List<android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction> getActionList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the actions that can be performed on the node.
  jni.JniObject getActionList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActionList, jni.JniType.objectType, []).object);

  static final _id_getActions =
      jniAccessors.getMethodIDOf(_classRef, "getActions", "()I");

  /// from: public int getActions()
  ///
  /// Gets the actions that can be performed on the node.
  ///@return The bit mask of with actions.
  ///@see AccessibilityNodeInfo\#ACTION_FOCUS
  ///@see AccessibilityNodeInfo\#ACTION_CLEAR_FOCUS
  ///@see AccessibilityNodeInfo\#ACTION_SELECT
  ///@see AccessibilityNodeInfo\#ACTION_CLEAR_SELECTION
  ///@see AccessibilityNodeInfo\#ACTION_ACCESSIBILITY_FOCUS
  ///@see AccessibilityNodeInfo\#ACTION_CLEAR_ACCESSIBILITY_FOCUS
  ///@see AccessibilityNodeInfo\#ACTION_CLICK
  ///@see AccessibilityNodeInfo\#ACTION_LONG_CLICK
  ///@see AccessibilityNodeInfo\#ACTION_NEXT_AT_MOVEMENT_GRANULARITY
  ///@see AccessibilityNodeInfo\#ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY
  ///@see AccessibilityNodeInfo\#ACTION_NEXT_HTML_ELEMENT
  ///@see AccessibilityNodeInfo\#ACTION_PREVIOUS_HTML_ELEMENT
  ///@see AccessibilityNodeInfo\#ACTION_SCROLL_FORWARD
  ///@see AccessibilityNodeInfo\#ACTION_SCROLL_BACKWARD
  ///@deprecated Use \#getActionList().
  int getActions() => jniAccessors.callMethodWithArgs(
      reference, _id_getActions, jni.JniType.intType, []).integer;

  static final _id_addAction = jniAccessors.getMethodIDOf(
      _classRef,
      "addAction",
      "(Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;)V");

  /// from: public void addAction(android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction action)
  ///
  /// Adds an action that can be performed on the node.
  ///
  /// To add a standard action use the static constants on AccessibilityAction.
  /// To add a custom action create a new AccessibilityAction by passing in a
  /// resource id from your application as the action id and an optional label that
  /// describes the action. To override one of the standard actions use as the action
  /// id of a standard action id such as \#ACTION_CLICK and an optional label that
  /// describes the action.
  ///
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param action The action.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void addAction(AccessibilityNodeInfo_AccessibilityAction action) =>
      jniAccessors.callMethodWithArgs(reference, _id_addAction,
          jni.JniType.voidType, [action.reference]).check();

  static final _id_addAction1 =
      jniAccessors.getMethodIDOf(_classRef, "addAction", "(I)V");

  /// from: public void addAction(int action)
  ///
  /// Adds an action that can be performed on the node.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param action The action.
  ///@throws IllegalStateException If called from an AccessibilityService.
  ///@throws IllegalArgumentException If the argument is not one of the standard actions.
  ///@deprecated This has been deprecated for \#addAction(AccessibilityAction)
  void addAction1(int action) => jniAccessors.callMethodWithArgs(
      reference, _id_addAction1, jni.JniType.voidType, [action]).check();

  static final _id_removeAction =
      jniAccessors.getMethodIDOf(_classRef, "removeAction", "(I)V");

  /// from: public void removeAction(int action)
  ///
  /// Removes an action that can be performed on the node. If the action was
  /// not already added to the node, calling this method has no effect.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param action The action to be removed.
  ///@throws IllegalStateException If called from an AccessibilityService.
  ///@deprecated Use \#removeAction(AccessibilityAction)
  void removeAction(int action) => jniAccessors.callMethodWithArgs(
      reference, _id_removeAction, jni.JniType.voidType, [action]).check();

  static final _id_removeAction1 = jniAccessors.getMethodIDOf(
      _classRef,
      "removeAction",
      "(Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;)Z");

  /// from: public boolean removeAction(android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction action)
  ///
  /// Removes an action that can be performed on the node. If the action was
  /// not already added to the node, calling this method has no effect.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param action The action to be removed.
  ///@return The action removed from the list of actions.
  ///@throws IllegalStateException If called from an AccessibilityService.
  bool removeAction1(AccessibilityNodeInfo_AccessibilityAction action) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeAction1,
          jni.JniType.booleanType, [action.reference]).boolean;

  static final _id_getTraversalBefore = jniAccessors.getMethodIDOf(
      _classRef,
      "getTraversalBefore",
      "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo getTraversalBefore()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node before which this one is visited during traversal. A screen-reader
  /// must visit the content of this node before the content of the one it precedes.
  ///@return The succeeding node if such or <code>null</code>.
  ///@see \#setTraversalBefore(android.view.View)
  ///@see \#setTraversalBefore(android.view.View, int)
  AccessibilityNodeInfo getTraversalBefore() =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTraversalBefore, jni.JniType.objectType, []).object);

  static final _id_setTraversalBefore = jniAccessors.getMethodIDOf(
      _classRef, "setTraversalBefore", "(Landroid/view/View;)V");

  /// from: public void setTraversalBefore(android.view.View view)
  ///
  /// Sets the view before whose node this one should be visited during traversal. A
  /// screen-reader must visit the content of this node before the content of the one
  /// it precedes.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param view The view providing the preceding node.
  ///@see \#getTraversalBefore()
  void setTraversalBefore(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTraversalBefore,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setTraversalBefore1 = jniAccessors.getMethodIDOf(
      _classRef, "setTraversalBefore", "(Landroid/view/View;I)V");

  /// from: public void setTraversalBefore(android.view.View root, int virtualDescendantId)
  ///
  /// Sets the node before which this one is visited during traversal. A screen-reader
  /// must visit the content of this node before the content of the one it precedes.
  /// The successor is a virtual descendant of the given <code>root</code>. If
  /// <code>virtualDescendantId</code> equals to View\#NO_ID the root is set
  /// as the successor.
  ///
  /// A virtual descendant is an imaginary View that is reported as a part of the view
  /// hierarchy for accessibility purposes. This enables custom views that draw complex
  /// content to report them selves as a tree of virtual views, thus conveying their
  /// logical structure.
  ///
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param root The root of the virtual subtree.
  ///@param virtualDescendantId The id of the virtual descendant.
  void setTraversalBefore1(view_.View root, int virtualDescendantId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTraversalBefore1,
          jni.JniType.voidType, [root.reference, virtualDescendantId]).check();

  static final _id_getTraversalAfter = jniAccessors.getMethodIDOf(
      _classRef,
      "getTraversalAfter",
      "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo getTraversalAfter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node after which this one is visited in accessibility traversal.
  /// A screen-reader must visit the content of the other node before the content
  /// of this one.
  ///@return The succeeding node if such or <code>null</code>.
  ///@see \#setTraversalAfter(android.view.View)
  ///@see \#setTraversalAfter(android.view.View, int)
  AccessibilityNodeInfo getTraversalAfter() =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTraversalAfter, jni.JniType.objectType, []).object);

  static final _id_setTraversalAfter = jniAccessors.getMethodIDOf(
      _classRef, "setTraversalAfter", "(Landroid/view/View;)V");

  /// from: public void setTraversalAfter(android.view.View view)
  ///
  /// Sets the view whose node is visited after this one in accessibility traversal.
  /// A screen-reader must visit the content of the other node before the content
  /// of this one.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param view The previous view.
  ///@see \#getTraversalAfter()
  void setTraversalAfter(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTraversalAfter,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setTraversalAfter1 = jniAccessors.getMethodIDOf(
      _classRef, "setTraversalAfter", "(Landroid/view/View;I)V");

  /// from: public void setTraversalAfter(android.view.View root, int virtualDescendantId)
  ///
  /// Sets the node after which this one is visited in accessibility traversal.
  /// A screen-reader must visit the content of the other node before the content
  /// of this one. If <code>virtualDescendantId</code> equals to View\#NO_ID
  /// the root is set as the predecessor.
  ///
  /// A virtual descendant is an imaginary View that is reported as a part of the view
  /// hierarchy for accessibility purposes. This enables custom views that draw complex
  /// content to report them selves as a tree of virtual views, thus conveying their
  /// logical structure.
  ///
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param root The root of the virtual subtree.
  ///@param virtualDescendantId The id of the virtual descendant.
  void setTraversalAfter1(view_.View root, int virtualDescendantId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTraversalAfter1,
          jni.JniType.voidType, [root.reference, virtualDescendantId]).check();

  static final _id_getAvailableExtraData = jniAccessors.getMethodIDOf(
      _classRef, "getAvailableExtraData", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getAvailableExtraData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the extra data available for this node.
  ///
  /// Some data that is useful for some accessibility services is expensive to compute, and would
  /// place undue overhead on apps to compute all the time. That data can be requested with
  /// \#refreshWithExtraData(String, Bundle).
  ///@return An unmodifiable list of keys corresponding to extra data that can be requested.
  ///@see \#EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY
  jni.JniObject getAvailableExtraData() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAvailableExtraData, jni.JniType.objectType, []).object);

  static final _id_setAvailableExtraData = jniAccessors.getMethodIDOf(
      _classRef, "setAvailableExtraData", "(Ljava/util/List;)V");

  /// from: public void setAvailableExtraData(java.util.List<java.lang.String> extraDataKeys)
  ///
  /// Set the extra data available for this node.
  ///
  /// <strong>Note:</strong> When a {@code View} passes in a non-empty list, it promises that
  /// it will populate the node's extras with corresponding pieces of information in
  /// View\#addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo, String, Bundle).
  ///
  /// <strong>Note:</strong> Cannot be called from an
  /// android.accessibilityservice.AccessibilityService.
  /// This class is made immutable before being delivered to an AccessibilityService.
  ///@param extraDataKeys A list of types of extra data that are available.
  ///@see \#getAvailableExtraData()
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setAvailableExtraData(jni.JniObject extraDataKeys) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAvailableExtraData,
          jni.JniType.voidType, [extraDataKeys.reference]).check();

  static final _id_setMaxTextLength =
      jniAccessors.getMethodIDOf(_classRef, "setMaxTextLength", "(I)V");

  /// from: public void setMaxTextLength(int max)
  ///
  /// Sets the maximum text length, or -1 for no limit.
  ///
  /// Typically used to indicate that an editable text field has a limit on
  /// the number of characters entered.
  ///
  /// <strong>Note:</strong> Cannot be called from an
  /// android.accessibilityservice.AccessibilityService.
  /// This class is made immutable before being delivered to an AccessibilityService.
  ///@param max The maximum text length.
  ///@see \#getMaxTextLength()
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setMaxTextLength(int max) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxTextLength, jni.JniType.voidType, [max]).check();

  static final _id_getMaxTextLength =
      jniAccessors.getMethodIDOf(_classRef, "getMaxTextLength", "()I");

  /// from: public int getMaxTextLength()
  ///
  /// Returns the maximum text length for this node.
  ///@return The maximum text length, or -1 for no limit.
  ///@see \#setMaxTextLength(int)
  int getMaxTextLength() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxTextLength, jni.JniType.intType, []).integer;

  static final _id_setMovementGranularities =
      jniAccessors.getMethodIDOf(_classRef, "setMovementGranularities", "(I)V");

  /// from: public void setMovementGranularities(int granularities)
  ///
  /// Sets the movement granularities for traversing the text of this node.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param granularities The bit mask with granularities.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setMovementGranularities(int granularities) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMovementGranularities,
          jni.JniType.voidType, [granularities]).check();

  static final _id_getMovementGranularities =
      jniAccessors.getMethodIDOf(_classRef, "getMovementGranularities", "()I");

  /// from: public int getMovementGranularities()
  ///
  /// Gets the movement granularities for traversing the text of this node.
  ///@return The bit mask with granularities.
  int getMovementGranularities() => jniAccessors.callMethodWithArgs(
      reference, _id_getMovementGranularities, jni.JniType.intType, []).integer;

  static final _id_performAction =
      jniAccessors.getMethodIDOf(_classRef, "performAction", "(I)Z");

  /// from: public boolean performAction(int action)
  ///
  /// Performs an action on the node.
  ///
  ///   <strong>Note:</strong> An action can be performed only if the request is made
  ///   from an android.accessibilityservice.AccessibilityService.
  ///
  ///
  ///@param action The action to perform.
  ///@return True if the action was performed.
  ///@throws IllegalStateException If called outside of an AccessibilityService.
  bool performAction(int action) => jniAccessors.callMethodWithArgs(
      reference, _id_performAction, jni.JniType.booleanType, [action]).boolean;

  static final _id_performAction1 = jniAccessors.getMethodIDOf(
      _classRef, "performAction", "(ILandroid/os/Bundle;)Z");

  /// from: public boolean performAction(int action, android.os.Bundle arguments)
  ///
  /// Performs an action on the node.
  ///
  ///   <strong>Note:</strong> An action can be performed only if the request is made
  ///   from an android.accessibilityservice.AccessibilityService.
  ///
  ///
  ///@param action The action to perform.
  ///@param arguments A bundle with additional arguments.
  ///@return True if the action was performed.
  ///@throws IllegalStateException If called outside of an AccessibilityService.
  bool performAction1(int action, bundle_.Bundle arguments) =>
      jniAccessors.callMethodWithArgs(reference, _id_performAction1,
          jni.JniType.booleanType, [action, arguments.reference]).boolean;

  static final _id_findAccessibilityNodeInfosByText =
      jniAccessors.getMethodIDOf(_classRef, "findAccessibilityNodeInfosByText",
          "(Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List<android.view.accessibility.AccessibilityNodeInfo> findAccessibilityNodeInfosByText(java.lang.String text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds AccessibilityNodeInfos by text. The match is case
  /// insensitive containment. The search is relative to this info i.e.
  /// this info is the root of the traversed tree.
  ///
  ///
  ///   <strong>Note:</strong> It is a client responsibility to recycle the
  ///     received info by calling AccessibilityNodeInfo\#recycle()
  ///     to avoid creating of multiple instances.
  ///
  ///
  ///@param text The searched text.
  ///@return A list of node info.
  jni.JniObject findAccessibilityNodeInfosByText(jni.JniString text) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findAccessibilityNodeInfosByText,
          jni.JniType.objectType,
          [text.reference]).object);

  static final _id_findAccessibilityNodeInfosByViewId =
      jniAccessors.getMethodIDOf(
          _classRef,
          "findAccessibilityNodeInfosByViewId",
          "(Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List<android.view.accessibility.AccessibilityNodeInfo> findAccessibilityNodeInfosByViewId(java.lang.String viewId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds AccessibilityNodeInfos by the fully qualified view id's resource
  /// name where a fully qualified id is of the from "package:id/id_resource_name".
  /// For example, if the target application's package is "foo.bar" and the id
  /// resource name is "baz", the fully qualified resource id is "foo.bar:id/baz".
  ///
  ///
  ///   <strong>Note:</strong> It is a client responsibility to recycle the
  ///     received info by calling AccessibilityNodeInfo\#recycle()
  ///     to avoid creating of multiple instances.
  ///
  ///
  ///
  ///   <strong>Note:</strong> The primary usage of this API is for UI test automation
  ///   and in order to report the fully qualified view id if an AccessibilityNodeInfo
  ///   the client has to set the AccessibilityServiceInfo\#FLAG_REPORT_VIEW_IDS
  ///   flag when configuring his android.accessibilityservice.AccessibilityService.
  ///
  ///
  ///@param viewId The fully qualified resource name of the view id to find.
  ///@return A list of node info.
  jni.JniObject findAccessibilityNodeInfosByViewId(jni.JniString viewId) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findAccessibilityNodeInfosByViewId,
          jni.JniType.objectType,
          [viewId.reference]).object);

  static final _id_getWindow = jniAccessors.getMethodIDOf(_classRef,
      "getWindow", "()Landroid/view/accessibility/AccessibilityWindowInfo;");

  /// from: public android.view.accessibility.AccessibilityWindowInfo getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the window to which this node belongs.
  ///@return The window.
  ///@see android.accessibilityservice.AccessibilityService\#getWindows()
  accessibilitywindowinfo_.AccessibilityWindowInfo getWindow() =>
      accessibilitywindowinfo_.AccessibilityWindowInfo.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_getParent = jniAccessors.getMethodIDOf(_classRef,
      "getParent", "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo getParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the parent.
  ///
  ///   <strong>Note:</strong> It is a client responsibility to recycle the
  ///     received info by calling AccessibilityNodeInfo\#recycle()
  ///     to avoid creating of multiple instances.
  ///
  ///
  ///@return The parent.
  AccessibilityNodeInfo getParent() =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getParent, jni.JniType.objectType, []).object);

  static final _id_setParent = jniAccessors.getMethodIDOf(
      _classRef, "setParent", "(Landroid/view/View;)V");

  /// from: public void setParent(android.view.View parent)
  ///
  /// Sets the parent.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param parent The parent.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setParent(view_.View parent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setParent,
      jni.JniType.voidType,
      [parent.reference]).check();

  static final _id_setParent1 = jniAccessors.getMethodIDOf(
      _classRef, "setParent", "(Landroid/view/View;I)V");

  /// from: public void setParent(android.view.View root, int virtualDescendantId)
  ///
  /// Sets the parent to be a virtual descendant of the given <code>root</code>.
  /// If <code>virtualDescendantId</code> equals to View\#NO_ID the root
  /// is set as the parent.
  ///
  /// A virtual descendant is an imaginary View that is reported as a part of the view
  /// hierarchy for accessibility purposes. This enables custom views that draw complex
  /// content to report them selves as a tree of virtual views, thus conveying their
  /// logical structure.
  ///
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param root The root of the virtual subtree.
  ///@param virtualDescendantId The id of the virtual descendant.
  void setParent1(view_.View root, int virtualDescendantId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setParent1,
          jni.JniType.voidType, [root.reference, virtualDescendantId]).check();

  static final _id_getBoundsInParent = jniAccessors.getMethodIDOf(
      _classRef, "getBoundsInParent", "(Landroid/graphics/Rect;)V");

  /// from: public void getBoundsInParent(android.graphics.Rect outBounds)
  ///
  /// Gets the node bounds in parent coordinates.
  ///@param outBounds The output node bounds.
  void getBoundsInParent(rect_.Rect outBounds) =>
      jniAccessors.callMethodWithArgs(reference, _id_getBoundsInParent,
          jni.JniType.voidType, [outBounds.reference]).check();

  static final _id_setBoundsInParent = jniAccessors.getMethodIDOf(
      _classRef, "setBoundsInParent", "(Landroid/graphics/Rect;)V");

  /// from: public void setBoundsInParent(android.graphics.Rect bounds)
  ///
  /// Sets the node bounds in parent coordinates.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param bounds The node bounds.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setBoundsInParent(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBoundsInParent,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_getBoundsInScreen = jniAccessors.getMethodIDOf(
      _classRef, "getBoundsInScreen", "(Landroid/graphics/Rect;)V");

  /// from: public void getBoundsInScreen(android.graphics.Rect outBounds)
  ///
  /// Gets the node bounds in screen coordinates.
  ///@param outBounds The output node bounds.
  void getBoundsInScreen(rect_.Rect outBounds) =>
      jniAccessors.callMethodWithArgs(reference, _id_getBoundsInScreen,
          jni.JniType.voidType, [outBounds.reference]).check();

  static final _id_setBoundsInScreen = jniAccessors.getMethodIDOf(
      _classRef, "setBoundsInScreen", "(Landroid/graphics/Rect;)V");

  /// from: public void setBoundsInScreen(android.graphics.Rect bounds)
  ///
  /// Sets the node bounds in screen coordinates.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param bounds The node bounds.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setBoundsInScreen(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBoundsInScreen,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_isCheckable =
      jniAccessors.getMethodIDOf(_classRef, "isCheckable", "()Z");

  /// from: public boolean isCheckable()
  ///
  /// Gets whether this node is checkable.
  ///@return True if the node is checkable.
  bool isCheckable() => jniAccessors.callMethodWithArgs(
      reference, _id_isCheckable, jni.JniType.booleanType, []).boolean;

  static final _id_setCheckable =
      jniAccessors.getMethodIDOf(_classRef, "setCheckable", "(Z)V");

  /// from: public void setCheckable(boolean checkable)
  ///
  /// Sets whether this node is checkable.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param checkable True if the node is checkable.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setCheckable(bool checkable) => jniAccessors.callMethodWithArgs(
      reference, _id_setCheckable, jni.JniType.voidType, [checkable]).check();

  static final _id_isChecked =
      jniAccessors.getMethodIDOf(_classRef, "isChecked", "()Z");

  /// from: public boolean isChecked()
  ///
  /// Gets whether this node is checked.
  ///@return True if the node is checked.
  bool isChecked() => jniAccessors.callMethodWithArgs(
      reference, _id_isChecked, jni.JniType.booleanType, []).boolean;

  static final _id_setChecked =
      jniAccessors.getMethodIDOf(_classRef, "setChecked", "(Z)V");

  /// from: public void setChecked(boolean checked)
  ///
  /// Sets whether this node is checked.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param checked True if the node is checked.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setChecked(bool checked) => jniAccessors.callMethodWithArgs(
      reference, _id_setChecked, jni.JniType.voidType, [checked]).check();

  static final _id_isFocusable =
      jniAccessors.getMethodIDOf(_classRef, "isFocusable", "()Z");

  /// from: public boolean isFocusable()
  ///
  /// Gets whether this node is focusable.
  ///@return True if the node is focusable.
  bool isFocusable() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocusable, jni.JniType.booleanType, []).boolean;

  static final _id_setFocusable =
      jniAccessors.getMethodIDOf(_classRef, "setFocusable", "(Z)V");

  /// from: public void setFocusable(boolean focusable)
  ///
  /// Sets whether this node is focusable.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param focusable True if the node is focusable.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setFocusable(bool focusable) => jniAccessors.callMethodWithArgs(
      reference, _id_setFocusable, jni.JniType.voidType, [focusable]).check();

  static final _id_isFocused =
      jniAccessors.getMethodIDOf(_classRef, "isFocused", "()Z");

  /// from: public boolean isFocused()
  ///
  /// Gets whether this node is focused.
  ///@return True if the node is focused.
  bool isFocused() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocused, jni.JniType.booleanType, []).boolean;

  static final _id_setFocused =
      jniAccessors.getMethodIDOf(_classRef, "setFocused", "(Z)V");

  /// from: public void setFocused(boolean focused)
  ///
  /// Sets whether this node is focused.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param focused True if the node is focused.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setFocused(bool focused) => jniAccessors.callMethodWithArgs(
      reference, _id_setFocused, jni.JniType.voidType, [focused]).check();

  static final _id_isVisibleToUser =
      jniAccessors.getMethodIDOf(_classRef, "isVisibleToUser", "()Z");

  /// from: public boolean isVisibleToUser()
  ///
  /// Gets whether this node is visible to the user.
  ///@return Whether the node is visible to the user.
  bool isVisibleToUser() => jniAccessors.callMethodWithArgs(
      reference, _id_isVisibleToUser, jni.JniType.booleanType, []).boolean;

  static final _id_setVisibleToUser =
      jniAccessors.getMethodIDOf(_classRef, "setVisibleToUser", "(Z)V");

  /// from: public void setVisibleToUser(boolean visibleToUser)
  ///
  /// Sets whether this node is visible to the user.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param visibleToUser Whether the node is visible to the user.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setVisibleToUser(bool visibleToUser) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVisibleToUser,
      jni.JniType.voidType,
      [visibleToUser]).check();

  static final _id_isAccessibilityFocused =
      jniAccessors.getMethodIDOf(_classRef, "isAccessibilityFocused", "()Z");

  /// from: public boolean isAccessibilityFocused()
  ///
  /// Gets whether this node is accessibility focused.
  ///@return True if the node is accessibility focused.
  bool isAccessibilityFocused() => jniAccessors.callMethodWithArgs(reference,
      _id_isAccessibilityFocused, jni.JniType.booleanType, []).boolean;

  static final _id_setAccessibilityFocused =
      jniAccessors.getMethodIDOf(_classRef, "setAccessibilityFocused", "(Z)V");

  /// from: public void setAccessibilityFocused(boolean focused)
  ///
  /// Sets whether this node is accessibility focused.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param focused True if the node is accessibility focused.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setAccessibilityFocused(bool focused) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAccessibilityFocused,
      jni.JniType.voidType,
      [focused]).check();

  static final _id_isSelected =
      jniAccessors.getMethodIDOf(_classRef, "isSelected", "()Z");

  /// from: public boolean isSelected()
  ///
  /// Gets whether this node is selected.
  ///@return True if the node is selected.
  bool isSelected() => jniAccessors.callMethodWithArgs(
      reference, _id_isSelected, jni.JniType.booleanType, []).boolean;

  static final _id_setSelected =
      jniAccessors.getMethodIDOf(_classRef, "setSelected", "(Z)V");

  /// from: public void setSelected(boolean selected)
  ///
  /// Sets whether this node is selected.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param selected True if the node is selected.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setSelected(bool selected) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelected, jni.JniType.voidType, [selected]).check();

  static final _id_isClickable =
      jniAccessors.getMethodIDOf(_classRef, "isClickable", "()Z");

  /// from: public boolean isClickable()
  ///
  /// Gets whether this node is clickable.
  ///@return True if the node is clickable.
  bool isClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isClickable, jni.JniType.booleanType, []).boolean;

  static final _id_setClickable =
      jniAccessors.getMethodIDOf(_classRef, "setClickable", "(Z)V");

  /// from: public void setClickable(boolean clickable)
  ///
  /// Sets whether this node is clickable.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param clickable True if the node is clickable.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setClickable(bool clickable) => jniAccessors.callMethodWithArgs(
      reference, _id_setClickable, jni.JniType.voidType, [clickable]).check();

  static final _id_isLongClickable =
      jniAccessors.getMethodIDOf(_classRef, "isLongClickable", "()Z");

  /// from: public boolean isLongClickable()
  ///
  /// Gets whether this node is long clickable.
  ///@return True if the node is long clickable.
  bool isLongClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isLongClickable, jni.JniType.booleanType, []).boolean;

  static final _id_setLongClickable =
      jniAccessors.getMethodIDOf(_classRef, "setLongClickable", "(Z)V");

  /// from: public void setLongClickable(boolean longClickable)
  ///
  /// Sets whether this node is long clickable.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param longClickable True if the node is long clickable.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setLongClickable(bool longClickable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLongClickable,
      jni.JniType.voidType,
      [longClickable]).check();

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Gets whether this node is enabled.
  ///@return True if the node is enabled.
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)V");

  /// from: public void setEnabled(boolean enabled)
  ///
  /// Sets whether this node is enabled.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param enabled True if the node is enabled.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled, jni.JniType.voidType, [enabled]).check();

  static final _id_isPassword =
      jniAccessors.getMethodIDOf(_classRef, "isPassword", "()Z");

  /// from: public boolean isPassword()
  ///
  /// Gets whether this node is a password.
  ///@return True if the node is a password.
  bool isPassword() => jniAccessors.callMethodWithArgs(
      reference, _id_isPassword, jni.JniType.booleanType, []).boolean;

  static final _id_setPassword =
      jniAccessors.getMethodIDOf(_classRef, "setPassword", "(Z)V");

  /// from: public void setPassword(boolean password)
  ///
  /// Sets whether this node is a password.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param password True if the node is a password.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setPassword(bool password) => jniAccessors.callMethodWithArgs(
      reference, _id_setPassword, jni.JniType.voidType, [password]).check();

  static final _id_isScrollable =
      jniAccessors.getMethodIDOf(_classRef, "isScrollable", "()Z");

  /// from: public boolean isScrollable()
  ///
  /// Gets if the node is scrollable.
  ///@return True if the node is scrollable, false otherwise.
  bool isScrollable() => jniAccessors.callMethodWithArgs(
      reference, _id_isScrollable, jni.JniType.booleanType, []).boolean;

  static final _id_setScrollable =
      jniAccessors.getMethodIDOf(_classRef, "setScrollable", "(Z)V");

  /// from: public void setScrollable(boolean scrollable)
  ///
  /// Sets if the node is scrollable.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param scrollable True if the node is scrollable, false otherwise.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setScrollable(bool scrollable) => jniAccessors.callMethodWithArgs(
      reference, _id_setScrollable, jni.JniType.voidType, [scrollable]).check();

  static final _id_isEditable =
      jniAccessors.getMethodIDOf(_classRef, "isEditable", "()Z");

  /// from: public boolean isEditable()
  ///
  /// Gets if the node is editable.
  ///@return True if the node is editable, false otherwise.
  bool isEditable() => jniAccessors.callMethodWithArgs(
      reference, _id_isEditable, jni.JniType.booleanType, []).boolean;

  static final _id_setEditable =
      jniAccessors.getMethodIDOf(_classRef, "setEditable", "(Z)V");

  /// from: public void setEditable(boolean editable)
  ///
  /// Sets whether this node is editable.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param editable True if the node is editable.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setEditable(bool editable) => jniAccessors.callMethodWithArgs(
      reference, _id_setEditable, jni.JniType.voidType, [editable]).check();

  static final _id_setPaneTitle = jniAccessors.getMethodIDOf(
      _classRef, "setPaneTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public void setPaneTitle(java.lang.CharSequence paneTitle)
  ///
  /// If this node represents a visually distinct region of the screen that may update separately
  /// from the rest of the window, it is considered a pane. Set the pane title to indicate that
  /// the node is a pane, and to provide a title for it.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param paneTitle The title of the pane represented by this node.
  ///
  /// This value may be {@code null}.
  void setPaneTitle(jni.JniObject paneTitle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPaneTitle,
      jni.JniType.voidType,
      [paneTitle.reference]).check();

  static final _id_getPaneTitle = jniAccessors.getMethodIDOf(
      _classRef, "getPaneTitle", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getPaneTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the title of the pane represented by this node.
  ///@return The title of the pane represented by this node, or {@code null} if this node does
  ///         not represent a pane.
  jni.JniObject getPaneTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPaneTitle, jni.JniType.objectType, []).object);

  static final _id_getDrawingOrder =
      jniAccessors.getMethodIDOf(_classRef, "getDrawingOrder", "()I");

  /// from: public int getDrawingOrder()
  ///
  /// Get the drawing order of the view corresponding it this node.
  ///
  /// Drawing order is determined only within the node's parent, so this index is only relative
  /// to its siblings.
  ///
  /// In some cases, the drawing order is essentially simultaneous, so it is possible for two
  /// siblings to return the same value. It is also possible that values will be skipped.
  ///@return The drawing position of the view corresponding to this node relative to its siblings.
  int getDrawingOrder() => jniAccessors.callMethodWithArgs(
      reference, _id_getDrawingOrder, jni.JniType.intType, []).integer;

  static final _id_setDrawingOrder =
      jniAccessors.getMethodIDOf(_classRef, "setDrawingOrder", "(I)V");

  /// from: public void setDrawingOrder(int drawingOrderInParent)
  ///
  /// Set the drawing order of the view corresponding it this node.
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param drawingOrderInParent
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setDrawingOrder(int drawingOrderInParent) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDrawingOrder,
          jni.JniType.voidType, [drawingOrderInParent]).check();

  static final _id_getCollectionInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getCollectionInfo",
      "()Landroid/view/accessibility/AccessibilityNodeInfo\$CollectionInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo.CollectionInfo getCollectionInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the collection info if the node is a collection. A collection
  /// child is always a collection item.
  ///@return The collection info.
  AccessibilityNodeInfo_CollectionInfo getCollectionInfo() =>
      AccessibilityNodeInfo_CollectionInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getCollectionInfo,
              jni.JniType.objectType, []).object);

  static final _id_setCollectionInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "setCollectionInfo",
      "(Landroid/view/accessibility/AccessibilityNodeInfo\$CollectionInfo;)V");

  /// from: public void setCollectionInfo(android.view.accessibility.AccessibilityNodeInfo.CollectionInfo collectionInfo)
  ///
  /// Sets the collection info if the node is a collection. A collection
  /// child is always a collection item.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param collectionInfo The collection info.
  void setCollectionInfo(AccessibilityNodeInfo_CollectionInfo collectionInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCollectionInfo,
          jni.JniType.voidType, [collectionInfo.reference]).check();

  static final _id_getCollectionItemInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getCollectionItemInfo",
      "()Landroid/view/accessibility/AccessibilityNodeInfo\$CollectionItemInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo getCollectionItemInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the collection item info if the node is a collection item. A collection
  /// item is always a child of a collection.
  ///@return The collection item info.
  AccessibilityNodeInfo_CollectionItemInfo getCollectionItemInfo() =>
      AccessibilityNodeInfo_CollectionItemInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getCollectionItemInfo,
              jni.JniType.objectType, []).object);

  static final _id_setCollectionItemInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "setCollectionItemInfo",
      "(Landroid/view/accessibility/AccessibilityNodeInfo\$CollectionItemInfo;)V");

  /// from: public void setCollectionItemInfo(android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo collectionItemInfo)
  ///
  /// Sets the collection item info if the node is a collection item. A collection
  /// item is always a child of a collection.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  void setCollectionItemInfo(
          AccessibilityNodeInfo_CollectionItemInfo collectionItemInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCollectionItemInfo,
          jni.JniType.voidType, [collectionItemInfo.reference]).check();

  static final _id_getRangeInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getRangeInfo",
      "()Landroid/view/accessibility/AccessibilityNodeInfo\$RangeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo.RangeInfo getRangeInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the range info if this node is a range.
  ///@return The range.
  AccessibilityNodeInfo_RangeInfo getRangeInfo() =>
      AccessibilityNodeInfo_RangeInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRangeInfo, jni.JniType.objectType, []).object);

  static final _id_setRangeInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "setRangeInfo",
      "(Landroid/view/accessibility/AccessibilityNodeInfo\$RangeInfo;)V");

  /// from: public void setRangeInfo(android.view.accessibility.AccessibilityNodeInfo.RangeInfo rangeInfo)
  ///
  /// Sets the range info if this node is a range.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param rangeInfo The range info.
  void setRangeInfo(AccessibilityNodeInfo_RangeInfo rangeInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRangeInfo,
          jni.JniType.voidType, [rangeInfo.reference]).check();

  static final _id_isContentInvalid =
      jniAccessors.getMethodIDOf(_classRef, "isContentInvalid", "()Z");

  /// from: public boolean isContentInvalid()
  ///
  /// Gets if the content of this node is invalid. For example,
  /// a date is not well-formed.
  ///@return If the node content is invalid.
  bool isContentInvalid() => jniAccessors.callMethodWithArgs(
      reference, _id_isContentInvalid, jni.JniType.booleanType, []).boolean;

  static final _id_setContentInvalid =
      jniAccessors.getMethodIDOf(_classRef, "setContentInvalid", "(Z)V");

  /// from: public void setContentInvalid(boolean contentInvalid)
  ///
  /// Sets if the content of this node is invalid. For example,
  /// a date is not well-formed.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param contentInvalid If the node content is invalid.
  void setContentInvalid(bool contentInvalid) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentInvalid,
          jni.JniType.voidType, [contentInvalid]).check();

  static final _id_isContextClickable =
      jniAccessors.getMethodIDOf(_classRef, "isContextClickable", "()Z");

  /// from: public boolean isContextClickable()
  ///
  /// Gets whether this node is context clickable.
  ///@return True if the node is context clickable.
  bool isContextClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isContextClickable, jni.JniType.booleanType, []).boolean;

  static final _id_setContextClickable =
      jniAccessors.getMethodIDOf(_classRef, "setContextClickable", "(Z)V");

  /// from: public void setContextClickable(boolean contextClickable)
  ///
  /// Sets whether this node is context clickable.
  ///
  /// <strong>Note:</strong> Cannot be called from an
  /// android.accessibilityservice.AccessibilityService. This class is made immutable
  /// before being delivered to an AccessibilityService.
  ///
  ///
  ///@param contextClickable True if the node is context clickable.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setContextClickable(bool contextClickable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContextClickable,
          jni.JniType.voidType, [contextClickable]).check();

  static final _id_getLiveRegion =
      jniAccessors.getMethodIDOf(_classRef, "getLiveRegion", "()I");

  /// from: public int getLiveRegion()
  ///
  /// Gets the node's live region mode.
  ///
  /// A live region is a node that contains information that is important for
  /// the user and when it changes the user should be notified. For example,
  /// in a login screen with a TextView that displays an "incorrect password"
  /// notification, that view should be marked as a live region with mode
  /// View\#ACCESSIBILITY_LIVE_REGION_POLITE.
  ///
  /// It is the responsibility of the accessibility service to monitor
  /// AccessibilityEvent\#TYPE_WINDOW_CONTENT_CHANGED events indicating
  /// changes to live region nodes and their children.
  ///@return The live region mode, or
  ///         View\#ACCESSIBILITY_LIVE_REGION_NONE if the view is not a
  ///         live region.
  ///@see android.view.View\#getAccessibilityLiveRegion()
  int getLiveRegion() => jniAccessors.callMethodWithArgs(
      reference, _id_getLiveRegion, jni.JniType.intType, []).integer;

  static final _id_setLiveRegion =
      jniAccessors.getMethodIDOf(_classRef, "setLiveRegion", "(I)V");

  /// from: public void setLiveRegion(int mode)
  ///
  /// Sets the node's live region mode.
  ///
  /// <strong>Note:</strong> Cannot be called from an
  /// android.accessibilityservice.AccessibilityService. This class is
  /// made immutable before being delivered to an AccessibilityService.
  ///@param mode The live region mode, or
  ///        View\#ACCESSIBILITY_LIVE_REGION_NONE if the view is not a
  ///        live region.
  ///@see android.view.View\#setAccessibilityLiveRegion(int)
  void setLiveRegion(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setLiveRegion, jni.JniType.voidType, [mode]).check();

  static final _id_isMultiLine =
      jniAccessors.getMethodIDOf(_classRef, "isMultiLine", "()Z");

  /// from: public boolean isMultiLine()
  ///
  /// Gets if the node is a multi line editable text.
  ///@return True if the node is multi line.
  bool isMultiLine() => jniAccessors.callMethodWithArgs(
      reference, _id_isMultiLine, jni.JniType.booleanType, []).boolean;

  static final _id_setMultiLine =
      jniAccessors.getMethodIDOf(_classRef, "setMultiLine", "(Z)V");

  /// from: public void setMultiLine(boolean multiLine)
  ///
  /// Sets if the node is a multi line editable text.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param multiLine True if the node is multi line.
  void setMultiLine(bool multiLine) => jniAccessors.callMethodWithArgs(
      reference, _id_setMultiLine, jni.JniType.voidType, [multiLine]).check();

  static final _id_canOpenPopup =
      jniAccessors.getMethodIDOf(_classRef, "canOpenPopup", "()Z");

  /// from: public boolean canOpenPopup()
  ///
  /// Gets if this node opens a popup or a dialog.
  ///@return If the the node opens a popup.
  bool canOpenPopup() => jniAccessors.callMethodWithArgs(
      reference, _id_canOpenPopup, jni.JniType.booleanType, []).boolean;

  static final _id_setCanOpenPopup =
      jniAccessors.getMethodIDOf(_classRef, "setCanOpenPopup", "(Z)V");

  /// from: public void setCanOpenPopup(boolean opensPopup)
  ///
  /// Sets if this node opens a popup or a dialog.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param opensPopup If the the node opens a popup.
  void setCanOpenPopup(bool opensPopup) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCanOpenPopup,
      jni.JniType.voidType,
      [opensPopup]).check();

  static final _id_isDismissable =
      jniAccessors.getMethodIDOf(_classRef, "isDismissable", "()Z");

  /// from: public boolean isDismissable()
  ///
  /// Gets if the node can be dismissed.
  ///@return If the node can be dismissed.
  bool isDismissable() => jniAccessors.callMethodWithArgs(
      reference, _id_isDismissable, jni.JniType.booleanType, []).boolean;

  static final _id_setDismissable =
      jniAccessors.getMethodIDOf(_classRef, "setDismissable", "(Z)V");

  /// from: public void setDismissable(boolean dismissable)
  ///
  /// Sets if the node can be dismissed.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param dismissable If the node can be dismissed.
  void setDismissable(bool dismissable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDismissable,
      jni.JniType.voidType,
      [dismissable]).check();

  static final _id_isImportantForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "isImportantForAccessibility", "()Z");

  /// from: public boolean isImportantForAccessibility()
  ///
  /// Returns whether the node originates from a view considered important for accessibility.
  ///@return {@code true} if the node originates from a view considered important for
  ///         accessibility, {@code false} otherwise
  ///@see View\#isImportantForAccessibility()
  bool isImportantForAccessibility() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isImportantForAccessibility,
      jni.JniType.booleanType, []).boolean;

  static final _id_setImportantForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "setImportantForAccessibility", "(Z)V");

  /// from: public void setImportantForAccessibility(boolean important)
  ///
  /// Sets whether the node is considered important for accessibility.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param important {@code true} if the node is considered important for accessibility,
  ///                  {@code false} otherwise
  void setImportantForAccessibility(bool important) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setImportantForAccessibility,
          jni.JniType.voidType,
          [important]).check();

  static final _id_isScreenReaderFocusable =
      jniAccessors.getMethodIDOf(_classRef, "isScreenReaderFocusable", "()Z");

  /// from: public boolean isScreenReaderFocusable()
  ///
  /// Returns whether the node is explicitly marked as a focusable unit by a screen reader. Note
  /// that {@code false} indicates that it is not explicitly marked, not that the node is not
  /// a focusable unit. Screen readers should generally use other signals, such as
  /// \#isFocusable(), or the presence of text in a node, to determine what should receive
  /// focus.
  ///@return {@code true} if the node is specifically marked as a focusable unit for screen
  ///         readers, {@code false} otherwise.
  ///@see View\#isScreenReaderFocusable()
  bool isScreenReaderFocusable() => jniAccessors.callMethodWithArgs(reference,
      _id_isScreenReaderFocusable, jni.JniType.booleanType, []).boolean;

  static final _id_setScreenReaderFocusable =
      jniAccessors.getMethodIDOf(_classRef, "setScreenReaderFocusable", "(Z)V");

  /// from: public void setScreenReaderFocusable(boolean screenReaderFocusable)
  ///
  /// Sets whether the node should be considered a focusable unit by a screen reader.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param screenReaderFocusable {@code true} if the node is a focusable unit for screen readers,
  ///                              {@code false} otherwise.
  void setScreenReaderFocusable(bool screenReaderFocusable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScreenReaderFocusable,
          jni.JniType.voidType, [screenReaderFocusable]).check();

  static final _id_isShowingHintText =
      jniAccessors.getMethodIDOf(_classRef, "isShowingHintText", "()Z");

  /// from: public boolean isShowingHintText()
  ///
  /// Returns whether the node's text represents a hint for the user to enter text. It should only
  /// be {@code true} if the node has editable text.
  ///@return {@code true} if the text in the node represents a hint to the user, {@code false}
  /// otherwise.
  bool isShowingHintText() => jniAccessors.callMethodWithArgs(
      reference, _id_isShowingHintText, jni.JniType.booleanType, []).boolean;

  static final _id_setShowingHintText =
      jniAccessors.getMethodIDOf(_classRef, "setShowingHintText", "(Z)V");

  /// from: public void setShowingHintText(boolean showingHintText)
  ///
  /// Sets whether the node's text represents a hint for the user to enter text. It should only
  /// be {@code true} if the node has editable text.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param showingHintText {@code true} if the text in the node represents a hint to the user,
  /// {@code false} otherwise.
  void setShowingHintText(bool showingHintText) =>
      jniAccessors.callMethodWithArgs(reference, _id_setShowingHintText,
          jni.JniType.voidType, [showingHintText]).check();

  static final _id_isHeading =
      jniAccessors.getMethodIDOf(_classRef, "isHeading", "()Z");

  /// from: public boolean isHeading()
  ///
  /// Returns whether node represents a heading.
  /// <strong>Note:</strong> Returns {@code true} if either \#setHeading(boolean)
  /// marks this node as a heading or if the node has a CollectionItemInfo that marks
  /// it as such, to accomodate apps that use the now-deprecated API.
  ///
  ///@return {@code true} if the node is a heading, {@code false} otherwise.
  bool isHeading() => jniAccessors.callMethodWithArgs(
      reference, _id_isHeading, jni.JniType.booleanType, []).boolean;

  static final _id_setHeading =
      jniAccessors.getMethodIDOf(_classRef, "setHeading", "(Z)V");

  /// from: public void setHeading(boolean isHeading)
  ///
  /// Sets whether the node represents a heading.
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param isHeading {@code true} if the node is a heading, {@code false} otherwise.
  void setHeading(bool isHeading) => jniAccessors.callMethodWithArgs(
      reference, _id_setHeading, jni.JniType.voidType, [isHeading]).check();

  static final _id_getPackageName = jniAccessors.getMethodIDOf(
      _classRef, "getPackageName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the package this node comes from.
  ///@return The package name.
  jni.JniObject getPackageName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPackageName, jni.JniType.objectType, []).object);

  static final _id_setPackageName = jniAccessors.getMethodIDOf(
      _classRef, "setPackageName", "(Ljava/lang/CharSequence;)V");

  /// from: public void setPackageName(java.lang.CharSequence packageName)
  ///
  /// Sets the package this node comes from.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param packageName The package name.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setPackageName(jni.JniObject packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPackageName,
          jni.JniType.voidType, [packageName.reference]).check();

  static final _id_getClassName = jniAccessors.getMethodIDOf(
      _classRef, "getClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the class this node comes from.
  ///@return The class name.
  jni.JniObject getClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClassName, jni.JniType.objectType, []).object);

  static final _id_setClassName = jniAccessors.getMethodIDOf(
      _classRef, "setClassName", "(Ljava/lang/CharSequence;)V");

  /// from: public void setClassName(java.lang.CharSequence className)
  ///
  /// Sets the class this node comes from.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param className The class name.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setClassName(jni.JniObject className) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClassName,
      jni.JniType.voidType,
      [className.reference]).check();

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the text of this node.
  ///
  ///   <strong>Note:</strong> If the text contains ClickableSpans or URLSpans,
  ///   these spans will have been replaced with ones whose ClickableSpan\#onClick(View)
  ///   can be called from an AccessibilityService. When called from a service, the
  ///   View argument is ignored and the corresponding span will be found on the view that
  ///   this {@code AccessibilityNodeInfo} represents and called with that view as its argument.
  ///
  ///   This treatment of ClickableSpans means that the text returned from this method may
  ///   different slightly one passed to \#setText(CharSequence), although they will be
  ///   equivalent according to TextUtils\#equals(CharSequence, CharSequence). The
  ///   ClickableSpan\#onClick(View) of any spans, however, will generally not work outside
  ///   of an accessibility service.
  ///
  ///
  ///@return The text.
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_setText = jniAccessors.getMethodIDOf(
      _classRef, "setText", "(Ljava/lang/CharSequence;)V");

  /// from: public void setText(java.lang.CharSequence text)
  ///
  /// Sets the text of this node.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param text The text.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setText(jni.JniObject text) => jniAccessors.callMethodWithArgs(
      reference, _id_setText, jni.JniType.voidType, [text.reference]).check();

  static final _id_getHintText = jniAccessors.getMethodIDOf(
      _classRef, "getHintText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getHintText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the hint text of this node. Only applies to nodes where text can be entered.
  ///@return The hint text.
  jni.JniObject getHintText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHintText, jni.JniType.objectType, []).object);

  static final _id_setHintText = jniAccessors.getMethodIDOf(
      _classRef, "setHintText", "(Ljava/lang/CharSequence;)V");

  /// from: public void setHintText(java.lang.CharSequence hintText)
  ///
  /// Sets the hint text of this node. Only applies to nodes where text can be entered.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param hintText The hint text for this mode.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setHintText(jni.JniObject hintText) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setHintText,
      jni.JniType.voidType,
      [hintText.reference]).check();

  static final _id_setError = jniAccessors.getMethodIDOf(
      _classRef, "setError", "(Ljava/lang/CharSequence;)V");

  /// from: public void setError(java.lang.CharSequence error)
  ///
  /// Sets the error text of this node.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param error The error text.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setError(jni.JniObject error) => jniAccessors.callMethodWithArgs(
      reference, _id_setError, jni.JniType.voidType, [error.reference]).check();

  static final _id_getError = jniAccessors.getMethodIDOf(
      _classRef, "getError", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getError()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the error text of this node.
  ///@return The error text.
  jni.JniObject getError() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getError, jni.JniType.objectType, []).object);

  static final _id_getContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "getContentDescription", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getContentDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the content description of this node.
  ///@return The content description.
  jni.JniObject getContentDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getContentDescription, jni.JniType.objectType, []).object);

  static final _id_setContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "setContentDescription", "(Ljava/lang/CharSequence;)V");

  /// from: public void setContentDescription(java.lang.CharSequence contentDescription)
  ///
  /// Sets the content description of this node.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param contentDescription The content description.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setContentDescription(jni.JniObject contentDescription) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentDescription,
          jni.JniType.voidType, [contentDescription.reference]).check();

  static final _id_getTooltipText = jniAccessors.getMethodIDOf(
      _classRef, "getTooltipText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTooltipText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the tooltip text of this node.
  ///@return The tooltip text.
  ///
  /// This value may be {@code null}.
  jni.JniObject getTooltipText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTooltipText, jni.JniType.objectType, []).object);

  static final _id_setTooltipText = jniAccessors.getMethodIDOf(
      _classRef, "setTooltipText", "(Ljava/lang/CharSequence;)V");

  /// from: public void setTooltipText(java.lang.CharSequence tooltipText)
  ///
  /// Sets the tooltip text of this node.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param tooltipText The tooltip text.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setTooltipText(jni.JniObject tooltipText) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTooltipText,
          jni.JniType.voidType, [tooltipText.reference]).check();

  static final _id_setLabelFor = jniAccessors.getMethodIDOf(
      _classRef, "setLabelFor", "(Landroid/view/View;)V");

  /// from: public void setLabelFor(android.view.View labeled)
  ///
  /// Sets the view for which the view represented by this info serves as a
  /// label for accessibility purposes.
  ///@param labeled The view for which this info serves as a label.
  void setLabelFor(view_.View labeled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLabelFor,
      jni.JniType.voidType,
      [labeled.reference]).check();

  static final _id_setLabelFor1 = jniAccessors.getMethodIDOf(
      _classRef, "setLabelFor", "(Landroid/view/View;I)V");

  /// from: public void setLabelFor(android.view.View root, int virtualDescendantId)
  ///
  /// Sets the view for which the view represented by this info serves as a
  /// label for accessibility purposes. If <code>virtualDescendantId</code>
  /// is View\#NO_ID the root is set as the labeled.
  ///
  /// A virtual descendant is an imaginary View that is reported as a part of the view
  /// hierarchy for accessibility purposes. This enables custom views that draw complex
  /// content to report themselves as a tree of virtual views, thus conveying their
  /// logical structure.
  ///
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param root The root whose virtual descendant serves as a label.
  ///@param virtualDescendantId The id of the virtual descendant.
  void setLabelFor1(view_.View root, int virtualDescendantId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLabelFor1,
          jni.JniType.voidType, [root.reference, virtualDescendantId]).check();

  static final _id_getLabelFor = jniAccessors.getMethodIDOf(_classRef,
      "getLabelFor", "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo getLabelFor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node info for which the view represented by this info serves as
  /// a label for accessibility purposes.
  ///
  ///   <strong>Note:</strong> It is a client responsibility to recycle the
  ///     received info by calling AccessibilityNodeInfo\#recycle()
  ///     to avoid creating of multiple instances.
  ///
  ///
  ///@return The labeled info.
  AccessibilityNodeInfo getLabelFor() =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLabelFor, jni.JniType.objectType, []).object);

  static final _id_setLabeledBy = jniAccessors.getMethodIDOf(
      _classRef, "setLabeledBy", "(Landroid/view/View;)V");

  /// from: public void setLabeledBy(android.view.View label)
  ///
  /// Sets the view which serves as the label of the view represented by
  /// this info for accessibility purposes.
  ///@param label The view that labels this node's source.
  void setLabeledBy(view_.View label) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLabeledBy,
      jni.JniType.voidType,
      [label.reference]).check();

  static final _id_setLabeledBy1 = jniAccessors.getMethodIDOf(
      _classRef, "setLabeledBy", "(Landroid/view/View;I)V");

  /// from: public void setLabeledBy(android.view.View root, int virtualDescendantId)
  ///
  /// Sets the view which serves as the label of the view represented by
  /// this info for accessibility purposes. If <code>virtualDescendantId</code>
  /// is View\#NO_ID the root is set as the label.
  ///
  /// A virtual descendant is an imaginary View that is reported as a part of the view
  /// hierarchy for accessibility purposes. This enables custom views that draw complex
  /// content to report themselves as a tree of virtual views, thus conveying their
  /// logical structure.
  ///
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param root The root whose virtual descendant labels this node's source.
  ///@param virtualDescendantId The id of the virtual descendant.
  void setLabeledBy1(view_.View root, int virtualDescendantId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLabeledBy1,
          jni.JniType.voidType, [root.reference, virtualDescendantId]).check();

  static final _id_getLabeledBy = jniAccessors.getMethodIDOf(_classRef,
      "getLabeledBy", "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo getLabeledBy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the node info which serves as the label of the view represented by
  /// this info for accessibility purposes.
  ///
  ///   <strong>Note:</strong> It is a client responsibility to recycle the
  ///     received info by calling AccessibilityNodeInfo\#recycle()
  ///     to avoid creating of multiple instances.
  ///
  ///
  ///@return The label.
  AccessibilityNodeInfo getLabeledBy() =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLabeledBy, jni.JniType.objectType, []).object);

  static final _id_setViewIdResourceName = jniAccessors.getMethodIDOf(
      _classRef, "setViewIdResourceName", "(Ljava/lang/String;)V");

  /// from: public void setViewIdResourceName(java.lang.String viewIdResName)
  ///
  /// Sets the fully qualified resource name of the source view's id.
  ///
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param viewIdResName The id resource name.
  void setViewIdResourceName(jni.JniString viewIdResName) =>
      jniAccessors.callMethodWithArgs(reference, _id_setViewIdResourceName,
          jni.JniType.voidType, [viewIdResName.reference]).check();

  static final _id_getViewIdResourceName = jniAccessors.getMethodIDOf(
      _classRef, "getViewIdResourceName", "()Ljava/lang/String;");

  /// from: public java.lang.String getViewIdResourceName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the fully qualified resource name of the source view's id.
  ///
  ///
  ///   <strong>Note:</strong> The primary usage of this API is for UI test automation
  ///   and in order to report the source view id of an AccessibilityNodeInfo the
  ///   client has to set the AccessibilityServiceInfo\#FLAG_REPORT_VIEW_IDS
  ///   flag when configuring his android.accessibilityservice.AccessibilityService.
  ///
  ///
  ///@return The id resource name.
  jni.JniString getViewIdResourceName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getViewIdResourceName, jni.JniType.objectType, []).object);

  static final _id_getTextSelectionStart =
      jniAccessors.getMethodIDOf(_classRef, "getTextSelectionStart", "()I");

  /// from: public int getTextSelectionStart()
  ///
  /// Gets the text selection start or the cursor position.
  ///
  /// If no text is selected, both this method and
  /// AccessibilityNodeInfo\#getTextSelectionEnd() return the same value:
  /// the current location of the cursor.
  ///
  ///
  ///@return The text selection start, the cursor location if there is no selection, or -1 if
  ///         there is no text selection and no cursor.
  int getTextSelectionStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSelectionStart, jni.JniType.intType, []).integer;

  static final _id_getTextSelectionEnd =
      jniAccessors.getMethodIDOf(_classRef, "getTextSelectionEnd", "()I");

  /// from: public int getTextSelectionEnd()
  ///
  /// Gets the text selection end if text is selected.
  ///
  /// If no text is selected, both this method and
  /// AccessibilityNodeInfo\#getTextSelectionStart() return the same value:
  /// the current location of the cursor.
  ///
  ///
  ///@return The text selection end, the cursor location if there is no selection, or -1 if
  ///         there is no text selection and no cursor.
  int getTextSelectionEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSelectionEnd, jni.JniType.intType, []).integer;

  static final _id_setTextSelection =
      jniAccessors.getMethodIDOf(_classRef, "setTextSelection", "(II)V");

  /// from: public void setTextSelection(int start, int end)
  ///
  /// Sets the text selection start and end.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an AccessibilityService.
  ///
  ///
  ///@param start The text selection start.
  ///@param end The text selection end.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setTextSelection(int start, int end) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextSelection,
      jni.JniType.voidType,
      [start, end]).check();

  static final _id_getInputType =
      jniAccessors.getMethodIDOf(_classRef, "getInputType", "()I");

  /// from: public int getInputType()
  ///
  /// Gets the input type of the source as defined by InputType.
  ///@return The input type.
  int getInputType() => jniAccessors.callMethodWithArgs(
      reference, _id_getInputType, jni.JniType.intType, []).integer;

  static final _id_setInputType =
      jniAccessors.getMethodIDOf(_classRef, "setInputType", "(I)V");

  /// from: public void setInputType(int inputType)
  ///
  /// Sets the input type of the source as defined by InputType.
  ///
  ///   <strong>Note:</strong> Cannot be called from an
  ///   android.accessibilityservice.AccessibilityService.
  ///   This class is made immutable before being delivered to an
  ///   AccessibilityService.
  ///
  ///
  ///@param inputType The input type.
  ///@throws IllegalStateException If called from an AccessibilityService.
  void setInputType(int inputType) => jniAccessors.callMethodWithArgs(
      reference, _id_setInputType, jni.JniType.voidType, [inputType]).check();

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an optional bundle with extra data. The bundle
  /// is lazily created and never <code>null</code>.
  ///
  /// <strong>Note:</strong> It is recommended to use the package
  /// name of your application as a prefix for the keys to avoid
  /// collisions which may confuse an accessibility service if the
  /// same key has different meaning when emitted from different
  /// applications.
  ///
  ///
  ///@return The bundle.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  ///
  /// {@inheritDoc}
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_obtain = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(Landroid/view/View;)Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo obtain(android.view.View source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a cached instance if such is available otherwise a new one
  /// and sets the source.
  ///@param source The source view.
  ///@return An instance.
  ///@see \#setSource(View)
  static AccessibilityNodeInfo obtain(view_.View source) =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_obtain,
          jni.JniType.objectType,
          [source.reference]).object);

  static final _id_obtain1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(Landroid/view/View;I)Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo obtain(android.view.View root, int virtualDescendantId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a cached instance if such is available otherwise a new one
  /// and sets the source.
  ///@param root The root of the virtual subtree.
  ///@param virtualDescendantId The id of the virtual descendant.
  ///@return An instance.
  ///@see \#setSource(View, int)
  static AccessibilityNodeInfo obtain1(
          view_.View root, int virtualDescendantId) =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_obtain1,
          jni.JniType.objectType,
          [root.reference, virtualDescendantId]).object);

  static final _id_obtain2 = jniAccessors.getStaticMethodIDOf(_classRef,
      "obtain", "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo obtain()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a cached instance if such is available otherwise a new one.
  ///@return An instance.
  static AccessibilityNodeInfo obtain2() =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_obtain2, jni.JniType.objectType, []).object);

  static final _id_obtain3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(Landroid/view/accessibility/AccessibilityNodeInfo;)Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo obtain(android.view.accessibility.AccessibilityNodeInfo info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a cached instance if such is available or a new one is
  /// create. The returned instance is initialized from the given
  /// <code>info</code>.
  ///@param info The other info.
  ///@return An instance.
  static AccessibilityNodeInfo obtain3(AccessibilityNodeInfo info) =>
      AccessibilityNodeInfo.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_obtain3,
          jni.JniType.objectType,
          [info.reference]).object);

  static final _id_recycle =
      jniAccessors.getMethodIDOf(_classRef, "recycle", "()V");

  /// from: public void recycle()
  ///
  /// Return an instance back to be reused.
  ///
  /// <strong>Note:</strong> You must not touch the object after calling this function.
  ///@throws IllegalStateException If the info is already recycled.
  void recycle() => jniAccessors.callMethodWithArgs(
      reference, _id_recycle, jni.JniType.voidType, []).check();

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  ///
  /// {@inheritDoc}
  ///
  ///   <strong>Note:</strong> After the instance is written to a parcel it
  ///      is recycled. You must not touch the object after calling this function.
  ///
  ///
  void writeToParcel(parcel_.Parcel parcel, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [parcel.reference, flags]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(jni.JniObject object) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [object.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.view.accessibility.AccessibilityNodeInfo$RangeInfo
///
/// Class with information if a node is a range. Use
/// RangeInfo\#obtain(int, float, float, float) to get an instance. Recycling is
/// handled by the AccessibilityNodeInfo to which this object is attached.
class AccessibilityNodeInfo_RangeInfo extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/accessibility/AccessibilityNodeInfo\$RangeInfo");
  AccessibilityNodeInfo_RangeInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int RANGE_TYPE_FLOAT
  ///
  /// Range type: float.
  static const RANGE_TYPE_FLOAT = 1;

  /// from: static public final int RANGE_TYPE_INT
  ///
  /// Range type: integer.
  static const RANGE_TYPE_INT = 0;

  /// from: static public final int RANGE_TYPE_PERCENT
  ///
  /// Range type: percent with values from zero to one.
  static const RANGE_TYPE_PERCENT = 2;

  static final _id_obtain = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(IFFF)Landroid/view/accessibility/AccessibilityNodeInfo\$RangeInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo.RangeInfo obtain(int type, float min, float max, float current)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a pooled instance.
  ///@param type The type of the range.
  ///@param min The minimum value. Use {@code Float.NEGATIVE_INFINITY} if the range has no
  ///            minimum.
  ///@param max The maximum value. Use {@code Float.POSITIVE_INFINITY} if the range has no
  ///            maximum.
  ///@param current The current value.
  static AccessibilityNodeInfo_RangeInfo obtain(
          int type, double min, double max, double current) =>
      AccessibilityNodeInfo_RangeInfo.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_obtain,
              jni.JniType.objectType, [type, min, max, current]).object);

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()I");

  /// from: public int getType()
  ///
  /// Gets the range type.
  ///@return The range type.
  ///@see \#RANGE_TYPE_INT
  ///@see \#RANGE_TYPE_FLOAT
  ///@see \#RANGE_TYPE_PERCENT
  int getType() => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, []).integer;

  static final _id_getMin =
      jniAccessors.getMethodIDOf(_classRef, "getMin", "()F");

  /// from: public float getMin()
  ///
  /// Gets the minimum value.
  ///@return The minimum value, or {@code Float.NEGATIVE_INFINITY} if no minimum exists.
  double getMin() => jniAccessors.callMethodWithArgs(
      reference, _id_getMin, jni.JniType.floatType, []).float;

  static final _id_getMax =
      jniAccessors.getMethodIDOf(_classRef, "getMax", "()F");

  /// from: public float getMax()
  ///
  /// Gets the maximum value.
  ///@return The maximum value, or {@code Float.POSITIVE_INFINITY} if no maximum exists.
  double getMax() => jniAccessors.callMethodWithArgs(
      reference, _id_getMax, jni.JniType.floatType, []).float;

  static final _id_getCurrent =
      jniAccessors.getMethodIDOf(_classRef, "getCurrent", "()F");

  /// from: public float getCurrent()
  ///
  /// Gets the current value.
  ///@return The current value.
  double getCurrent() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrent, jni.JniType.floatType, []).float;
}

/// from: android.view.accessibility.AccessibilityNodeInfo$CollectionItemInfo
///
/// Class with information if a node is a collection item. Use
/// CollectionItemInfo\#obtain(int, int, int, int, boolean)
/// to get an instance. Recycling is handled by the AccessibilityNodeInfo to which this
/// object is attached.
///
/// A collection item is contained in a collection, it starts at
/// a given row and column in the collection, and spans one or
/// more rows and columns. For example, a header of two related
/// table columns starts at the first row and the first column,
/// spans one row and two columns.
///
///
class AccessibilityNodeInfo_CollectionItemInfo extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/accessibility/AccessibilityNodeInfo\$CollectionItemInfo");
  AccessibilityNodeInfo_CollectionItemInfo.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_obtain = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(IIIIZ)Landroid/view/accessibility/AccessibilityNodeInfo\$CollectionItemInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo obtain(int rowIndex, int rowSpan, int columnIndex, int columnSpan, boolean heading)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a pooled instance.
  ///@param rowIndex The row index at which the item is located.
  ///@param rowSpan The number of rows the item spans.
  ///@param columnIndex The column index at which the item is located.
  ///@param columnSpan The number of columns the item spans.
  ///@param heading Whether the item is a heading. (Prefer
  ///                AccessibilityNodeInfo\#setHeading(boolean)).
  static AccessibilityNodeInfo_CollectionItemInfo obtain(int rowIndex,
          int rowSpan, int columnIndex, int columnSpan, bool heading) =>
      AccessibilityNodeInfo_CollectionItemInfo.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_obtain,
              jni.JniType.objectType,
              [rowIndex, rowSpan, columnIndex, columnSpan, heading]).object);

  static final _id_obtain1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(IIIIZZ)Landroid/view/accessibility/AccessibilityNodeInfo\$CollectionItemInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo obtain(int rowIndex, int rowSpan, int columnIndex, int columnSpan, boolean heading, boolean selected)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a pooled instance.
  ///@param rowIndex The row index at which the item is located.
  ///@param rowSpan The number of rows the item spans.
  ///@param columnIndex The column index at which the item is located.
  ///@param columnSpan The number of columns the item spans.
  ///@param heading Whether the item is a heading. (Prefer
  ///                AccessibilityNodeInfo\#setHeading(boolean))
  ///@param selected Whether the item is selected.
  static AccessibilityNodeInfo_CollectionItemInfo obtain1(
          int rowIndex,
          int rowSpan,
          int columnIndex,
          int columnSpan,
          bool heading,
          bool selected) =>
      AccessibilityNodeInfo_CollectionItemInfo.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef, _id_obtain1, jni.JniType.objectType, [
        rowIndex,
        rowSpan,
        columnIndex,
        columnSpan,
        heading,
        selected
      ]).object);

  static final _id_getColumnIndex =
      jniAccessors.getMethodIDOf(_classRef, "getColumnIndex", "()I");

  /// from: public int getColumnIndex()
  ///
  /// Gets the column index at which the item is located.
  ///@return The column index.
  int getColumnIndex() => jniAccessors.callMethodWithArgs(
      reference, _id_getColumnIndex, jni.JniType.intType, []).integer;

  static final _id_getRowIndex =
      jniAccessors.getMethodIDOf(_classRef, "getRowIndex", "()I");

  /// from: public int getRowIndex()
  ///
  /// Gets the row index at which the item is located.
  ///@return The row index.
  int getRowIndex() => jniAccessors.callMethodWithArgs(
      reference, _id_getRowIndex, jni.JniType.intType, []).integer;

  static final _id_getColumnSpan =
      jniAccessors.getMethodIDOf(_classRef, "getColumnSpan", "()I");

  /// from: public int getColumnSpan()
  ///
  /// Gets the number of columns the item spans.
  ///@return The column span.
  int getColumnSpan() => jniAccessors.callMethodWithArgs(
      reference, _id_getColumnSpan, jni.JniType.intType, []).integer;

  static final _id_getRowSpan =
      jniAccessors.getMethodIDOf(_classRef, "getRowSpan", "()I");

  /// from: public int getRowSpan()
  ///
  /// Gets the number of rows the item spans.
  ///@return The row span.
  int getRowSpan() => jniAccessors.callMethodWithArgs(
      reference, _id_getRowSpan, jni.JniType.intType, []).integer;

  static final _id_isHeading =
      jniAccessors.getMethodIDOf(_classRef, "isHeading", "()Z");

  /// from: public boolean isHeading()
  ///
  /// Gets if the collection item is a heading. For example, section
  /// heading, table header, etc.
  ///@return If the item is a heading.
  ///@deprecated Use AccessibilityNodeInfo\#isHeading()
  bool isHeading() => jniAccessors.callMethodWithArgs(
      reference, _id_isHeading, jni.JniType.booleanType, []).boolean;

  static final _id_isSelected =
      jniAccessors.getMethodIDOf(_classRef, "isSelected", "()Z");

  /// from: public boolean isSelected()
  ///
  /// Gets if the collection item is selected.
  ///@return If the item is selected.
  bool isSelected() => jniAccessors.callMethodWithArgs(
      reference, _id_isSelected, jni.JniType.booleanType, []).boolean;
}

/// from: android.view.accessibility.AccessibilityNodeInfo$CollectionInfo
///
/// Class with information if a node is a collection. Use
/// CollectionInfo\#obtain(int, int, boolean) to get an instance. Recycling is
/// handled by the AccessibilityNodeInfo to which this object is attached.
///
/// A collection of items has rows and columns and may be hierarchical.
/// For example, a horizontal list is a collection with one column, as
/// many rows as the list items, and is not hierarchical; A table is a
/// collection with several rows, several columns, and is not hierarchical;
/// A vertical tree is a hierarchical collection with one column and
/// as many rows as the first level children.
///
///
class AccessibilityNodeInfo_CollectionInfo extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/accessibility/AccessibilityNodeInfo\$CollectionInfo");
  AccessibilityNodeInfo_CollectionInfo.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int SELECTION_MODE_MULTIPLE
  ///
  /// Selection mode where multiple items may be selected.
  static const SELECTION_MODE_MULTIPLE = 2;

  /// from: static public final int SELECTION_MODE_NONE
  ///
  /// Selection mode where items are not selectable.
  static const SELECTION_MODE_NONE = 0;

  /// from: static public final int SELECTION_MODE_SINGLE
  ///
  /// Selection mode where a single item may be selected.
  static const SELECTION_MODE_SINGLE = 1;

  static final _id_obtain = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(IIZ)Landroid/view/accessibility/AccessibilityNodeInfo\$CollectionInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo.CollectionInfo obtain(int rowCount, int columnCount, boolean hierarchical)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a pooled instance.
  ///@param rowCount The number of rows.
  ///@param columnCount The number of columns.
  ///@param hierarchical Whether the collection is hierarchical.
  static AccessibilityNodeInfo_CollectionInfo obtain(
          int rowCount, int columnCount, bool hierarchical) =>
      AccessibilityNodeInfo_CollectionInfo.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_obtain,
              jni.JniType.objectType,
              [rowCount, columnCount, hierarchical]).object);

  static final _id_obtain1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(IIZI)Landroid/view/accessibility/AccessibilityNodeInfo\$CollectionInfo;");

  /// from: static public android.view.accessibility.AccessibilityNodeInfo.CollectionInfo obtain(int rowCount, int columnCount, boolean hierarchical, int selectionMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a pooled instance.
  ///@param rowCount The number of rows.
  ///@param columnCount The number of columns.
  ///@param hierarchical Whether the collection is hierarchical.
  ///@param selectionMode The collection's selection mode, one of:
  ///            <ul>
  ///            <li>\#SELECTION_MODE_NONE
  ///            <li>\#SELECTION_MODE_SINGLE
  ///            <li>\#SELECTION_MODE_MULTIPLE
  ///            </ul>
  static AccessibilityNodeInfo_CollectionInfo obtain1(int rowCount,
          int columnCount, bool hierarchical, int selectionMode) =>
      AccessibilityNodeInfo_CollectionInfo.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_obtain1,
              jni.JniType.objectType,
              [rowCount, columnCount, hierarchical, selectionMode]).object);

  static final _id_getRowCount =
      jniAccessors.getMethodIDOf(_classRef, "getRowCount", "()I");

  /// from: public int getRowCount()
  ///
  /// Gets the number of rows.
  ///@return The row count.
  int getRowCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRowCount, jni.JniType.intType, []).integer;

  static final _id_getColumnCount =
      jniAccessors.getMethodIDOf(_classRef, "getColumnCount", "()I");

  /// from: public int getColumnCount()
  ///
  /// Gets the number of columns.
  ///@return The column count.
  int getColumnCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getColumnCount, jni.JniType.intType, []).integer;

  static final _id_isHierarchical =
      jniAccessors.getMethodIDOf(_classRef, "isHierarchical", "()Z");

  /// from: public boolean isHierarchical()
  ///
  /// Gets if the collection is a hierarchically ordered.
  ///@return Whether the collection is hierarchical.
  bool isHierarchical() => jniAccessors.callMethodWithArgs(
      reference, _id_isHierarchical, jni.JniType.booleanType, []).boolean;

  static final _id_getSelectionMode =
      jniAccessors.getMethodIDOf(_classRef, "getSelectionMode", "()I");

  /// from: public int getSelectionMode()
  ///
  /// Gets the collection's selection mode.
  ///@return The collection's selection mode, one of:
  ///         <ul>
  ///         <li>\#SELECTION_MODE_NONE
  ///         <li>\#SELECTION_MODE_SINGLE
  ///         <li>\#SELECTION_MODE_MULTIPLE
  ///         </ul>
  int getSelectionMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectionMode, jni.JniType.intType, []).integer;
}

/// from: android.view.accessibility.AccessibilityNodeInfo$AccessibilityAction
///
/// A class defining an action that can be performed on an AccessibilityNodeInfo.
/// Each action has a unique id that is mandatory and optional data.
///
/// There are three categories of actions:
/// <ul>
/// <li><strong>Standard actions</strong> - These are actions that are reported and
/// handled by the standard UI widgets in the platform. For each standard action
/// there is a static constant defined in this class, e.g. \#ACTION_FOCUS.
/// These actions will have {@code null} labels.
/// </li>
/// <li><strong>Custom actions action</strong> - These are actions that are reported
/// and handled by custom widgets. i.e. ones that are not part of the UI toolkit. For
/// example, an application may define a custom action for clearing the user history.
/// </li>
/// <li><strong>Overriden standard actions</strong> - These are actions that override
/// standard actions to customize them. For example, an app may add a label to the
/// standard \#ACTION_CLICK action to announce that this action clears browsing history.
/// </ul>
///
///
///
/// Actions are typically added to an AccessibilityNodeInfo by using
/// AccessibilityNodeInfo\#addAction(AccessibilityAction) within
/// View\#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo) and are performed
/// within View\#performAccessibilityAction(int, Bundle).
///
///
/// <p class="note">
/// <strong>Note:</strong> Views which support these actions should invoke
/// View\#setImportantForAccessibility(int) with
/// View\#IMPORTANT_FOR_ACCESSIBILITY_YES to ensure an AccessibilityService
/// can discover the set of supported actions.
///
///
class AccessibilityNodeInfo_AccessibilityAction extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction");
  AccessibilityNodeInfo_AccessibilityAction.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ACTION_ACCESSIBILITY_FOCUS = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_ACCESSIBILITY_FOCUS",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_ACCESSIBILITY_FOCUS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that gives accessibility focus to the node.
  static AccessibilityNodeInfo_AccessibilityAction
      get ACTION_ACCESSIBILITY_FOCUS =>
          AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
              .getStaticField(_classRef, _id_ACTION_ACCESSIBILITY_FOCUS,
                  jni.JniType.objectType)
              .object);

  static final _id_ACTION_CLEAR_ACCESSIBILITY_FOCUS =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "ACTION_CLEAR_ACCESSIBILITY_FOCUS",
          "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_CLEAR_ACCESSIBILITY_FOCUS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that clears accessibility focus of the node.
  static AccessibilityNodeInfo_AccessibilityAction
      get ACTION_CLEAR_ACCESSIBILITY_FOCUS =>
          AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
              .getStaticField(_classRef, _id_ACTION_CLEAR_ACCESSIBILITY_FOCUS,
                  jni.JniType.objectType)
              .object);

  static final _id_ACTION_CLEAR_FOCUS = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_CLEAR_FOCUS",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_CLEAR_FOCUS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that clears input focus of the node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_CLEAR_FOCUS =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_CLEAR_FOCUS, jni.JniType.objectType)
          .object);

  static final _id_ACTION_CLEAR_SELECTION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_CLEAR_SELECTION",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_CLEAR_SELECTION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that deselects the node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_CLEAR_SELECTION =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_CLEAR_SELECTION, jni.JniType.objectType)
          .object);

  static final _id_ACTION_CLICK = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_CLICK",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_CLICK
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that clicks on the node info.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_CLICK =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ACTION_CLICK, jni.JniType.objectType)
          .object);

  static final _id_ACTION_COLLAPSE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_COLLAPSE",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_COLLAPSE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to collapse an expandable node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_COLLAPSE =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_COLLAPSE, jni.JniType.objectType)
          .object);

  static final _id_ACTION_CONTEXT_CLICK = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_CONTEXT_CLICK",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_CONTEXT_CLICK
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that context clicks the node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_CONTEXT_CLICK =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_CONTEXT_CLICK, jni.JniType.objectType)
          .object);

  static final _id_ACTION_COPY = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_COPY",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_COPY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to copy the current selection to the clipboard.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_COPY =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ACTION_COPY, jni.JniType.objectType)
          .object);

  static final _id_ACTION_CUT = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_CUT",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_CUT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to cut the current selection and place it to the clipboard.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_CUT =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ACTION_CUT, jni.JniType.objectType)
          .object);

  static final _id_ACTION_DISMISS = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_DISMISS",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_DISMISS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to dismiss a dismissable node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_DISMISS =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ACTION_DISMISS, jni.JniType.objectType)
          .object);

  static final _id_ACTION_EXPAND = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_EXPAND",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_EXPAND
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to expand an expandable node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_EXPAND =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ACTION_EXPAND, jni.JniType.objectType)
          .object);

  static final _id_ACTION_FOCUS = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_FOCUS",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_FOCUS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that gives input focus to the node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_FOCUS =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ACTION_FOCUS, jni.JniType.objectType)
          .object);

  static final _id_ACTION_HIDE_TOOLTIP = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_HIDE_TOOLTIP",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_HIDE_TOOLTIP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to hide a tooltip. A node should expose this action only for views that are
  /// currently showing a tooltip.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_HIDE_TOOLTIP =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_HIDE_TOOLTIP, jni.JniType.objectType)
          .object);

  static final _id_ACTION_LONG_CLICK = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_LONG_CLICK",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_LONG_CLICK
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that long clicks on the node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_LONG_CLICK =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_LONG_CLICK, jni.JniType.objectType)
          .object);

  static final _id_ACTION_MOVE_WINDOW = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_MOVE_WINDOW",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_MOVE_WINDOW
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to move a window to a new location.
  ///
  /// <strong>Arguments:</strong>
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_MOVE_WINDOW_X
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_MOVE_WINDOW_Y
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_MOVE_WINDOW =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_MOVE_WINDOW, jni.JniType.objectType)
          .object);

  static final _id_ACTION_NEXT_AT_MOVEMENT_GRANULARITY =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "ACTION_NEXT_AT_MOVEMENT_GRANULARITY",
          "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_NEXT_AT_MOVEMENT_GRANULARITY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that requests to go to the next entity in this node's text
  /// at a given movement granularity. For example, move to the next character,
  /// word, etc.
  ///
  /// <strong>Arguments:</strong>
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT,
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN<br>
  /// <strong>Example:</strong> Move to the previous character and do not extend selection.
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT,
  ///           AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER);
  ///   arguments.putBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN,
  ///           false);
  ///   info.performAction(AccessibilityAction.ACTION_NEXT_AT_MOVEMENT_GRANULARITY.getId(),
  ///           arguments);
  /// </code></pre>
  ///
  ///
  ///
  ///@see AccessibilityNodeInfo\#ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT
  ///@see AccessibilityNodeInfo\#ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN
  ///@see AccessibilityNodeInfo\#setMovementGranularities(int) AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN
  ///@see AccessibilityNodeInfo\#getMovementGranularities() AccessibilityNodeInfo.getMovementGranularities()
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_CHARACTER AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_WORD AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_LINE AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_PARAGRAPH AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_PAGE AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE
  static AccessibilityNodeInfo_AccessibilityAction
      get ACTION_NEXT_AT_MOVEMENT_GRANULARITY =>
          AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_ACTION_NEXT_AT_MOVEMENT_GRANULARITY,
                  jni.JniType.objectType)
              .object);

  static final _id_ACTION_NEXT_HTML_ELEMENT = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_NEXT_HTML_ELEMENT",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_NEXT_HTML_ELEMENT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to move to the next HTML element of a given type. For example, move
  /// to the BUTTON, INPUT, TABLE, etc.
  ///
  /// <strong>Arguments:</strong>
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_HTML_ELEMENT_STRING AccessibilityNodeInfo.ACTION_ARGUMENT_HTML_ELEMENT_STRING<br>
  /// <strong>Example:</strong>
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putString(AccessibilityNodeInfo.ACTION_ARGUMENT_HTML_ELEMENT_STRING, "BUTTON");
  ///   info.performAction(AccessibilityAction.ACTION_NEXT_HTML_ELEMENT.getId(), arguments);
  /// </code></pre>
  ///
  ///
  ///
  static AccessibilityNodeInfo_AccessibilityAction
      get ACTION_NEXT_HTML_ELEMENT =>
          AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
              .getStaticField(_classRef, _id_ACTION_NEXT_HTML_ELEMENT,
                  jni.JniType.objectType)
              .object);

  static final _id_ACTION_PASTE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_PASTE",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_PASTE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to paste the current clipboard content.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_PASTE =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ACTION_PASTE, jni.JniType.objectType)
          .object);

  static final _id_ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY",
          "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that requests to go to the previous entity in this node's text
  /// at a given movement granularity. For example, move to the next character,
  /// word, etc.
  ///
  /// <strong>Arguments:</strong>
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT,
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN<br>
  /// <strong>Example:</strong> Move to the next character and do not extend selection.
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT,
  ///           AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER);
  ///   arguments.putBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN,
  ///           false);
  ///   info.performAction(AccessibilityAction.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY.getId(),
  ///           arguments);
  /// </code></pre>
  ///
  ///
  ///
  ///@see AccessibilityNodeInfo\#ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT
  ///@see AccessibilityNodeInfo\#ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN
  ///@see AccessibilityNodeInfo\#setMovementGranularities(int) AccessibilityNodeInfo.setMovementGranularities(int)
  ///@see AccessibilityNodeInfo\#getMovementGranularities() AccessibilityNodeInfo.getMovementGranularities()
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_CHARACTER AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_WORD AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_LINE AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_PARAGRAPH AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH
  ///@see AccessibilityNodeInfo\#MOVEMENT_GRANULARITY_PAGE AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE
  static AccessibilityNodeInfo_AccessibilityAction
      get ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY =>
          AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY,
                  jni.JniType.objectType)
              .object);

  static final _id_ACTION_PREVIOUS_HTML_ELEMENT = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_PREVIOUS_HTML_ELEMENT",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_PREVIOUS_HTML_ELEMENT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to move to the previous HTML element of a given type. For example, move
  /// to the BUTTON, INPUT, TABLE, etc.
  ///
  /// <strong>Arguments:</strong>
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_HTML_ELEMENT_STRING AccessibilityNodeInfo.ACTION_ARGUMENT_HTML_ELEMENT_STRING<br>
  /// <strong>Example:</strong>
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putString(AccessibilityNodeInfo.ACTION_ARGUMENT_HTML_ELEMENT_STRING, "BUTTON");
  ///   info.performAction(AccessibilityAction.ACTION_PREVIOUS_HTML_ELEMENT.getId(), arguments);
  /// </code></pre>
  ///
  ///
  ///
  static AccessibilityNodeInfo_AccessibilityAction
      get ACTION_PREVIOUS_HTML_ELEMENT =>
          AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
              .getStaticField(_classRef, _id_ACTION_PREVIOUS_HTML_ELEMENT,
                  jni.JniType.objectType)
              .object);

  static final _id_ACTION_SCROLL_BACKWARD = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SCROLL_BACKWARD",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SCROLL_BACKWARD
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to scroll the node content backward.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SCROLL_BACKWARD =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SCROLL_BACKWARD, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SCROLL_DOWN = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SCROLL_DOWN",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SCROLL_DOWN
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to scroll the node content down.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SCROLL_DOWN =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SCROLL_DOWN, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SCROLL_FORWARD = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SCROLL_FORWARD",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SCROLL_FORWARD
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to scroll the node content forward.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SCROLL_FORWARD =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SCROLL_FORWARD, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SCROLL_LEFT = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SCROLL_LEFT",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SCROLL_LEFT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to scroll the node content left.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SCROLL_LEFT =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SCROLL_LEFT, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SCROLL_RIGHT = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SCROLL_RIGHT",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SCROLL_RIGHT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to scroll the node content right.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SCROLL_RIGHT =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SCROLL_RIGHT, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SCROLL_TO_POSITION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SCROLL_TO_POSITION",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SCROLL_TO_POSITION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that scrolls the node to make the specified collection
  /// position visible on screen.
  ///
  /// <strong>Arguments:</strong>
  /// <ul>
  ///     <li>AccessibilityNodeInfo\#ACTION_ARGUMENT_ROW_INT</li>
  ///     <li>AccessibilityNodeInfo\#ACTION_ARGUMENT_COLUMN_INT</li>
  /// <ul>
  ///@see AccessibilityNodeInfo\#getCollectionInfo()
  static AccessibilityNodeInfo_AccessibilityAction
      get ACTION_SCROLL_TO_POSITION =>
          AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
              .getStaticField(_classRef, _id_ACTION_SCROLL_TO_POSITION,
                  jni.JniType.objectType)
              .object);

  static final _id_ACTION_SCROLL_UP = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SCROLL_UP",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SCROLL_UP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to scroll the node content up.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SCROLL_UP =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SCROLL_UP, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SELECT = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SELECT",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SELECT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that selects the node.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SELECT =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ACTION_SELECT, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SET_PROGRESS = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SET_PROGRESS",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SET_PROGRESS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that sets progress between RangeInfo\#getMin() RangeInfo.getMin() and
  /// RangeInfo\#getMax() RangeInfo.getMax(). It should use the same value type as
  /// RangeInfo\#getType() RangeInfo.getType()
  ///
  /// <strong>Arguments:</strong>
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_PROGRESS_VALUE
  ///@see RangeInfo
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SET_PROGRESS =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SET_PROGRESS, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SET_SELECTION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SET_SELECTION",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SET_SELECTION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to set the selection. Performing this action with no arguments
  /// clears the selection.
  ///
  /// <strong>Arguments:</strong>
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_SELECTION_START_INT AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT,
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_SELECTION_END_INT AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT<br>
  /// <strong>Example:</strong>
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, 1);
  ///   arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, 2);
  ///   info.performAction(AccessibilityAction.ACTION_SET_SELECTION.getId(), arguments);
  /// </code></pre>
  ///
  ///
  ///
  ///@see AccessibilityNodeInfo\#ACTION_ARGUMENT_SELECTION_START_INT AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT
  ///@see AccessibilityNodeInfo\#ACTION_ARGUMENT_SELECTION_END_INT AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SET_SELECTION =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SET_SELECTION, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SET_TEXT = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SET_TEXT",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SET_TEXT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that sets the text of the node. Performing the action without argument,
  /// using <code> null</code> or empty CharSequence will clear the text. This
  /// action will also put the cursor at the end of text.
  ///
  /// <strong>Arguments:</strong>
  /// AccessibilityNodeInfo\#ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE<br>
  /// <strong>Example:</strong>
  /// <code><pre>
  ///   Bundle arguments = new Bundle();
  ///   arguments.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE,
  ///       "android");
  ///   info.performAction(AccessibilityAction.ACTION_SET_TEXT.getId(), arguments);
  /// </code></pre>
  ///
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SET_TEXT =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SET_TEXT, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SHOW_ON_SCREEN = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SHOW_ON_SCREEN",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SHOW_ON_SCREEN
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action that requests the node make its bounding rectangle visible
  /// on the screen, scrolling if necessary just enough.
  ///@see View\#requestRectangleOnScreen(Rect)
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SHOW_ON_SCREEN =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SHOW_ON_SCREEN, jni.JniType.objectType)
          .object);

  static final _id_ACTION_SHOW_TOOLTIP = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "ACTION_SHOW_TOOLTIP",
      "Landroid/view/accessibility/AccessibilityNodeInfo\$AccessibilityAction;");

  /// from: static public final android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction ACTION_SHOW_TOOLTIP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Action to show a tooltip. A node should expose this action only for views with tooltip
  /// text that but are not currently showing a tooltip.
  static AccessibilityNodeInfo_AccessibilityAction get ACTION_SHOW_TOOLTIP =>
      AccessibilityNodeInfo_AccessibilityAction.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_SHOW_TOOLTIP, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILjava/lang/CharSequence;)V");

  /// from: public void <init>(int actionId, java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new AccessibilityAction. For adding a standard action without a specific label,
  /// use the static constants.
  ///
  /// You can also override the description for one the standard actions. Below is an example
  /// how to override the standard click action by adding a custom label:
  /// <pre>
  ///   AccessibilityAction action = new AccessibilityAction(
  ///           AccessibilityAction.ACTION_CLICK.getId(), getLocalizedLabel());
  ///   node.addAction(action);
  /// </pre>
  ///@param actionId The id for this action. This should either be one of the
  ///                 standard actions or a specific action for your app. In that case it is
  ///                 required to use a resource identifier.
  ///@param label The label for the new AccessibilityAction.
  ///
  /// This value may be {@code null}.
  AccessibilityNodeInfo_AccessibilityAction(int actionId, jni.JniObject label)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [actionId, label.reference]).object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// Gets the id for this action.
  ///@return The action id.
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getLabel = jniAccessors.getMethodIDOf(
      _classRef, "getLabel", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the label for this action. Its purpose is to describe the
  /// action to user.
  ///@return The label.
  jni.JniObject getLabel() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLabel, jni.JniType.objectType, []).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  bool equals1(jni.JniObject other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
