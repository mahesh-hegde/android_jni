// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "View.dart" as view_;

import "Menu.dart" as menu_;

import "MenuInflater.dart" as menuinflater_;

import "../graphics/Rect.dart" as rect_;

import "MenuItem.dart" as menuitem_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.ActionMode
///
/// Represents a contextual mode of the user interface. Action modes can be used to provide
/// alternative interaction modes and replace parts of the normal UI until finished.
/// Examples of good action modes include text selection and contextual actions.
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about how to provide contextual actions with {@code ActionMode},
/// read the <a href="{@docRoot}guide/topics/ui/menus.html\#context-menu">Menus</a>
/// developer guide.
///
/// </div>
class ActionMode extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/ActionMode");
  ActionMode.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DEFAULT_HIDE_DURATION
  ///
  /// Default value to hide the action mode for
  /// ViewConfiguration\#getDefaultActionModeHideDuration().
  static const DEFAULT_HIDE_DURATION = -1;

  /// from: static public final int TYPE_FLOATING
  ///
  /// The action mode is treated as a Floating Toolbar.
  /// Use with \#setType.
  static const TYPE_FLOATING = 1;

  /// from: static public final int TYPE_PRIMARY
  ///
  /// The action mode is treated as a Primary mode. This is the default.
  /// Use with \#setType.
  static const TYPE_PRIMARY = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionMode()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setTag =
      jniAccessors.getMethodIDOf(_classRef, "setTag", "(Ljava/lang/Object;)V");

  /// from: public void setTag(java.lang.Object tag)
  ///
  /// Set a tag object associated with this ActionMode.
  ///
  /// Like the tag available to views, this allows applications to associate arbitrary
  /// data with an ActionMode for later reference.
  ///@param tag Tag to associate with this ActionMode
  ///@see \#getTag()
  void setTag(jni.JniObject tag) => jniAccessors.callMethodWithArgs(
      reference, _id_setTag, jni.JniType.voidType, [tag.reference]).check();

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Ljava/lang/Object;");

  /// from: public java.lang.Object getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the tag object associated with this ActionMode.
  ///
  /// Like the tag available to views, this allows applications to associate arbitrary
  /// data with an ActionMode for later reference.
  ///@return Tag associated with this ActionMode
  ///@see \#setTag(Object)
  jni.JniObject getTag() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_setTitle = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public abstract void setTitle(java.lang.CharSequence title)
  ///
  /// Set the title of the action mode. This method will have no visible effect if
  /// a custom view has been set.
  ///@param title Title string to set
  ///@see \#setTitle(int)
  ///@see \#setCustomView(View)
  void setTitle(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle, jni.JniType.voidType, [title.reference]).check();

  static final _id_setTitle1 =
      jniAccessors.getMethodIDOf(_classRef, "setTitle", "(I)V");

  /// from: public abstract void setTitle(int resId)
  ///
  /// Set the title of the action mode. This method will have no visible effect if
  /// a custom view has been set.
  ///@param resId Resource ID of a string to set as the title
  ///@see \#setTitle(CharSequence)
  ///@see \#setCustomView(View)
  void setTitle1(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle1, jni.JniType.voidType, [resId]).check();

  static final _id_setSubtitle = jniAccessors.getMethodIDOf(
      _classRef, "setSubtitle", "(Ljava/lang/CharSequence;)V");

  /// from: public abstract void setSubtitle(java.lang.CharSequence subtitle)
  ///
  /// Set the subtitle of the action mode. This method will have no visible effect if
  /// a custom view has been set.
  ///@param subtitle Subtitle string to set
  ///@see \#setSubtitle(int)
  ///@see \#setCustomView(View)
  void setSubtitle(jni.JniObject subtitle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSubtitle,
      jni.JniType.voidType,
      [subtitle.reference]).check();

  static final _id_setSubtitle1 =
      jniAccessors.getMethodIDOf(_classRef, "setSubtitle", "(I)V");

  /// from: public abstract void setSubtitle(int resId)
  ///
  /// Set the subtitle of the action mode. This method will have no visible effect if
  /// a custom view has been set.
  ///@param resId Resource ID of a string to set as the subtitle
  ///@see \#setSubtitle(CharSequence)
  ///@see \#setCustomView(View)
  void setSubtitle1(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setSubtitle1, jni.JniType.voidType, [resId]).check();

  static final _id_setTitleOptionalHint =
      jniAccessors.getMethodIDOf(_classRef, "setTitleOptionalHint", "(Z)V");

  /// from: public void setTitleOptionalHint(boolean titleOptional)
  ///
  /// Set whether or not the title/subtitle display for this action mode
  /// is optional.
  ///
  /// In many cases the supplied title for an action mode is merely
  /// meant to add context and is not strictly required for the action
  /// mode to be useful. If the title is optional, the system may choose
  /// to hide the title entirely rather than truncate it due to a lack
  /// of available space.
  ///
  ///
  /// Note that this is merely a hint; the underlying implementation
  /// may choose to ignore this setting under some circumstances.
  ///
  ///@param titleOptional true if the title only presents optional information.
  void setTitleOptionalHint(bool titleOptional) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTitleOptionalHint,
          jni.JniType.voidType, [titleOptional]).check();

  static final _id_getTitleOptionalHint =
      jniAccessors.getMethodIDOf(_classRef, "getTitleOptionalHint", "()Z");

  /// from: public boolean getTitleOptionalHint()
  ///
  /// @return true if this action mode has been given a hint to consider the
  ///         title/subtitle display to be optional.
  ///@see \#setTitleOptionalHint(boolean)
  ///@see \#isTitleOptional()
  bool getTitleOptionalHint() => jniAccessors.callMethodWithArgs(
      reference, _id_getTitleOptionalHint, jni.JniType.booleanType, []).boolean;

  static final _id_isTitleOptional =
      jniAccessors.getMethodIDOf(_classRef, "isTitleOptional", "()Z");

  /// from: public boolean isTitleOptional()
  ///
  /// @return true if this action mode considers the title and subtitle fields
  ///         as optional. Optional titles may not be displayed to the user.
  bool isTitleOptional() => jniAccessors.callMethodWithArgs(
      reference, _id_isTitleOptional, jni.JniType.booleanType, []).boolean;

  static final _id_setCustomView = jniAccessors.getMethodIDOf(
      _classRef, "setCustomView", "(Landroid/view/View;)V");

  /// from: public abstract void setCustomView(android.view.View view)
  ///
  /// Set a custom view for this action mode. The custom view will take the place of
  /// the title and subtitle. Useful for things like search boxes.
  ///@param view Custom view to use in place of the title/subtitle.
  ///@see \#setTitle(CharSequence)
  ///@see \#setSubtitle(CharSequence)
  void setCustomView(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCustomView,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setType =
      jniAccessors.getMethodIDOf(_classRef, "setType", "(I)V");

  /// from: public void setType(int type)
  ///
  /// Set a type for this action mode. This will affect how the system renders the action mode if
  /// it has to.
  ///@param type One of \#TYPE_PRIMARY or \#TYPE_FLOATING.
  void setType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setType, jni.JniType.voidType, [type]).check();

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()I");

  /// from: public int getType()
  ///
  /// Returns the type for this action mode.
  ///@return One of \#TYPE_PRIMARY or \#TYPE_FLOATING.
  int getType() => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, []).integer;

  static final _id_invalidate =
      jniAccessors.getMethodIDOf(_classRef, "invalidate", "()V");

  /// from: public abstract void invalidate()
  ///
  /// Invalidate the action mode and refresh menu content. The mode's
  /// ActionMode.Callback will have its
  /// Callback\#onPrepareActionMode(ActionMode, Menu) method called.
  /// If it returns true the menu will be scanned for updated content and any relevant changes
  /// will be reflected to the user.
  void invalidate() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidate, jni.JniType.voidType, []).check();

  static final _id_invalidateContentRect =
      jniAccessors.getMethodIDOf(_classRef, "invalidateContentRect", "()V");

  /// from: public void invalidateContentRect()
  ///
  /// Invalidate the content rect associated to this ActionMode. This only makes sense for
  /// action modes that support dynamic positioning on the screen, and provides a more efficient
  /// way to reposition it without invalidating the whole action mode.
  ///@see Callback2\#onGetContentRect(ActionMode, View, Rect) .
  void invalidateContentRect() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidateContentRect, jni.JniType.voidType, []).check();

  static final _id_hide0 =
      jniAccessors.getMethodIDOf(_classRef, "hide", "(J)V");

  /// from: public void hide(long duration)
  ///
  /// Hide the action mode view from obstructing the content below for a short duration.
  /// This only makes sense for action modes that support dynamic positioning on the screen.
  /// If this method is called again before the hide duration expires, the later hide call will
  /// cancel the former and then take effect.
  /// NOTE that there is an internal limit to how long the mode can be hidden for. It's typically
  /// about a few seconds.
  ///@param duration The number of milliseconds to hide for.
  ///@see \#DEFAULT_HIDE_DURATION
  void hide0(int duration) => jniAccessors.callMethodWithArgs(
      reference, _id_hide0, jni.JniType.voidType, [duration]).check();

  static final _id_finish =
      jniAccessors.getMethodIDOf(_classRef, "finish", "()V");

  /// from: public abstract void finish()
  ///
  /// Finish and close this action mode. The action mode's ActionMode.Callback will
  /// have its Callback\#onDestroyActionMode(ActionMode) method called.
  void finish() => jniAccessors.callMethodWithArgs(
      reference, _id_finish, jni.JniType.voidType, []).check();

  static final _id_getMenu =
      jniAccessors.getMethodIDOf(_classRef, "getMenu", "()Landroid/view/Menu;");

  /// from: public abstract android.view.Menu getMenu()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the menu of actions that this action mode presents.
  ///@return The action mode's menu.
  menu_.Menu getMenu() => menu_.Menu.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getMenu, jni.JniType.objectType, []).object);

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current title of this action mode.
  ///@return Title text
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_getSubtitle = jniAccessors.getMethodIDOf(
      _classRef, "getSubtitle", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getSubtitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current subtitle of this action mode.
  ///@return Subtitle text
  jni.JniObject getSubtitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSubtitle, jni.JniType.objectType, []).object);

  static final _id_getCustomView = jniAccessors.getMethodIDOf(
      _classRef, "getCustomView", "()Landroid/view/View;");

  /// from: public abstract android.view.View getCustomView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current custom view for this action mode.
  ///@return The current custom view
  view_.View getCustomView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCustomView, jni.JniType.objectType, []).object);

  static final _id_getMenuInflater = jniAccessors.getMethodIDOf(
      _classRef, "getMenuInflater", "()Landroid/view/MenuInflater;");

  /// from: public abstract android.view.MenuInflater getMenuInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a MenuInflater with the ActionMode's context.
  menuinflater_.MenuInflater getMenuInflater() =>
      menuinflater_.MenuInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMenuInflater, jni.JniType.objectType, []).object);

  static final _id_onWindowFocusChanged =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasWindowFocus)
  ///
  /// Called when the window containing the view that started this action mode gains or loses
  /// focus.
  ///@param hasWindowFocus True if the window containing the view that started this action mode
  ///        now has focus, false otherwise.
  void onWindowFocusChanged(bool hasWindowFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowFocusChanged,
          jni.JniType.voidType, [hasWindowFocus]).check();
}

/// from: android.view.ActionMode$Callback2
///
/// Extension of ActionMode.Callback to provide content rect information. This is
/// required for ActionModes with dynamic positioning such as the ones with type
/// ActionMode\#TYPE_FLOATING to ensure the positioning doesn't obscure app content. If
/// an app fails to provide a subclass of this class, a default implementation will be used.
class ActionMode_Callback2 extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ActionMode\$Callback2");
  ActionMode_Callback2.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionMode_Callback2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onGetContentRect = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetContentRect",
      "(Landroid/view/ActionMode;Landroid/view/View;Landroid/graphics/Rect;)V");

  /// from: public void onGetContentRect(android.view.ActionMode mode, android.view.View view, android.graphics.Rect outRect)
  ///
  /// Called when an ActionMode needs to be positioned on screen, potentially occluding view
  /// content. Note this may be called on a per-frame basis.
  ///@param mode The ActionMode that requires positioning.
  ///@param view The View that originated the ActionMode, in whose coordinates the Rect should
  ///          be provided.
  ///@param outRect The Rect to be populated with the content position. Use this to specify
  ///          where the content in your app lives within the given view. This will be used
  ///          to avoid occluding the given content Rect with the created ActionMode.
  void onGetContentRect(ActionMode mode, view_.View view, rect_.Rect outRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetContentRect,
          jni.JniType.voidType,
          [mode.reference, view.reference, outRect.reference]).check();
}

/// from: android.view.ActionMode$Callback
///
/// Callback interface for action modes. Supplied to
/// View\#startActionMode(Callback), a Callback
/// configures and handles events raised by a user's interaction with an action mode.
///
/// An action mode's lifecycle is as follows:
/// <ul>
/// <li>Callback\#onCreateActionMode(ActionMode, Menu) once on initial
/// creation</li>
/// <li>Callback\#onPrepareActionMode(ActionMode, Menu) after creation
/// and any time the ActionMode is invalidated</li>
/// <li>Callback\#onActionItemClicked(ActionMode, MenuItem) any time a
/// contextual action button is clicked</li>
/// <li>Callback\#onDestroyActionMode(ActionMode) when the action mode
/// is closed</li>
/// </ul>
class ActionMode_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ActionMode\$Callback");
  ActionMode_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onCreateActionMode = jniAccessors.getMethodIDOf(_classRef,
      "onCreateActionMode", "(Landroid/view/ActionMode;Landroid/view/Menu;)Z");

  /// from: public abstract boolean onCreateActionMode(android.view.ActionMode mode, android.view.Menu menu)
  ///
  /// Called when action mode is first created. The menu supplied will be used to
  /// generate action buttons for the action mode.
  ///@param mode ActionMode being created
  ///@param menu Menu used to populate action buttons
  ///@return true if the action mode should be created, false if entering this
  ///              mode should be aborted.
  bool onCreateActionMode(ActionMode mode, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreateActionMode,
          jni.JniType.booleanType, [mode.reference, menu.reference]).boolean;

  static final _id_onPrepareActionMode = jniAccessors.getMethodIDOf(_classRef,
      "onPrepareActionMode", "(Landroid/view/ActionMode;Landroid/view/Menu;)Z");

  /// from: public abstract boolean onPrepareActionMode(android.view.ActionMode mode, android.view.Menu menu)
  ///
  /// Called to refresh an action mode's action menu whenever it is invalidated.
  ///@param mode ActionMode being prepared
  ///@param menu Menu used to populate action buttons
  ///@return true if the menu or action mode was updated, false otherwise.
  bool onPrepareActionMode(ActionMode mode, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrepareActionMode,
          jni.JniType.booleanType, [mode.reference, menu.reference]).boolean;

  static final _id_onActionItemClicked = jniAccessors.getMethodIDOf(
      _classRef,
      "onActionItemClicked",
      "(Landroid/view/ActionMode;Landroid/view/MenuItem;)Z");

  /// from: public abstract boolean onActionItemClicked(android.view.ActionMode mode, android.view.MenuItem item)
  ///
  /// Called to report a user click on an action button.
  ///@param mode The current ActionMode
  ///@param item The item that was clicked
  ///@return true if this callback handled the event, false if the standard MenuItem
  ///          invocation should continue.
  bool onActionItemClicked(ActionMode mode, menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionItemClicked,
          jni.JniType.booleanType, [mode.reference, item.reference]).boolean;

  static final _id_onDestroyActionMode = jniAccessors.getMethodIDOf(
      _classRef, "onDestroyActionMode", "(Landroid/view/ActionMode;)V");

  /// from: public abstract void onDestroyActionMode(android.view.ActionMode mode)
  ///
  /// Called when an action mode is about to be exited and destroyed.
  ///@param mode The current ActionMode being destroyed
  void onDestroyActionMode(ActionMode mode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onDestroyActionMode,
      jni.JniType.voidType,
      [mode.reference]).check();
}
