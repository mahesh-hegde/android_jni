// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "View.dart" as view_;

import "MenuItem.dart" as menuitem_;

import "SubMenu.dart" as submenu_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.ActionProvider
///
/// An ActionProvider defines rich menu interaction in a single component.
/// ActionProvider can generate action views for use in the action bar,
/// dynamically populate submenus of a MenuItem, and handle default menu
/// item invocations.
///
/// An ActionProvider can be optionally specified for a MenuItem and will be
/// responsible for creating the action view that appears in the android.app.ActionBar
/// in place of a simple button in the bar. When the menu item is presented in a way that
/// does not allow custom action views, (e.g. in an overflow menu,) the ActionProvider
/// can perform a default action.
///
///
/// There are two ways to use an action provider:
/// <ul>
/// <li>
/// Set the action provider on a MenuItem directly by calling
/// MenuItem\#setActionProvider(ActionProvider).
/// </li>
/// <li>
/// Declare the action provider in an XML menu resource. For example:
/// <pre>
/// <code>
///   &lt;item android:id="@+id/my_menu_item"
///     android:title="Title"
///     android:icon="@drawable/my_menu_item_icon"
///     android:showAsAction="ifRoom"
///     android:actionProviderClass="foo.bar.SomeActionProvider" /&gt;
/// </code>
/// </pre>
/// </li>
/// </ul>
///
///
///@see MenuItem\#setActionProvider(ActionProvider)
///@see MenuItem\#getActionProvider()
class ActionProvider extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ActionProvider");
  ActionProvider.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new instance. ActionProvider classes should always implement a
  /// constructor that takes a single Context parameter for inflating from menu XML.
  ///@param context Context for accessing resources.
  ActionProvider(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_onCreateActionView = jniAccessors.getMethodIDOf(
      _classRef, "onCreateActionView", "()Landroid/view/View;");

  /// from: public abstract android.view.View onCreateActionView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Factory method called by the Android framework to create new action views.
  ///
  /// This method has been deprecated in favor of \#onCreateActionView(MenuItem).
  /// Newer apps that wish to support platform versions prior to API 16 should also
  /// implement this method to return a valid action view.
  ///
  ///@return A new action view.
  ///@deprecated use \#onCreateActionView(MenuItem)
  view_.View onCreateActionView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreateActionView, jni.JniType.objectType, []).object);

  static final _id_onCreateActionView1 = jniAccessors.getMethodIDOf(_classRef,
      "onCreateActionView", "(Landroid/view/MenuItem;)Landroid/view/View;");

  /// from: public android.view.View onCreateActionView(android.view.MenuItem forItem)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Factory method called by the Android framework to create new action views.
  /// This method returns a new action view for the given MenuItem.
  ///
  /// If your ActionProvider implementation overrides the deprecated no-argument overload
  /// \#onCreateActionView(), overriding this method for devices running API 16 or later
  /// is recommended but optional. The default implementation calls \#onCreateActionView()
  /// for compatibility with applications written for older platform versions.
  ///
  ///@param forItem MenuItem to create the action view for
  ///@return the new action view
  view_.View onCreateActionView1(menuitem_.MenuItem forItem) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateActionView1,
          jni.JniType.objectType,
          [forItem.reference]).object);

  static final _id_overridesItemVisibility =
      jniAccessors.getMethodIDOf(_classRef, "overridesItemVisibility", "()Z");

  /// from: public boolean overridesItemVisibility()
  ///
  /// The result of this method determines whether or not \#isVisible() will be used
  /// by the MenuItem this ActionProvider is bound to help determine its visibility.
  ///@return true if this ActionProvider overrides the visibility of the MenuItem
  ///         it is bound to, false otherwise. The default implementation returns false.
  ///@see \#isVisible()
  bool overridesItemVisibility() => jniAccessors.callMethodWithArgs(reference,
      _id_overridesItemVisibility, jni.JniType.booleanType, []).boolean;

  static final _id_isVisible =
      jniAccessors.getMethodIDOf(_classRef, "isVisible", "()Z");

  /// from: public boolean isVisible()
  ///
  /// If \#overridesItemVisibility() returns true, the return value of this method
  /// will help determine the visibility of the MenuItem this ActionProvider is bound to.
  ///
  /// If the MenuItem's visibility is explicitly set to false by the application,
  /// the MenuItem will not be shown, even if this method returns true.
  ///
  ///@return true if the MenuItem this ActionProvider is bound to is visible, false if
  ///         it is invisible. The default implementation returns true.
  bool isVisible() => jniAccessors.callMethodWithArgs(
      reference, _id_isVisible, jni.JniType.booleanType, []).boolean;

  static final _id_refreshVisibility =
      jniAccessors.getMethodIDOf(_classRef, "refreshVisibility", "()V");

  /// from: public void refreshVisibility()
  ///
  /// If this ActionProvider is associated with an item in a menu,
  /// refresh the visibility of the item based on \#overridesItemVisibility() and
  /// \#isVisible(). If \#overridesItemVisibility() returns false, this call
  /// will have no effect.
  void refreshVisibility() => jniAccessors.callMethodWithArgs(
      reference, _id_refreshVisibility, jni.JniType.voidType, []).check();

  static final _id_onPerformDefaultAction =
      jniAccessors.getMethodIDOf(_classRef, "onPerformDefaultAction", "()Z");

  /// from: public boolean onPerformDefaultAction()
  ///
  /// Performs an optional default action.
  ///
  /// For the case of an action provider placed in a menu item not shown as an action this
  /// method is invoked if previous callbacks for processing menu selection has handled
  /// the event.
  ///
  ///
  ///
  /// A menu item selection is processed in the following order:
  /// <ul>
  /// <li>
  /// Receiving a call to MenuItem.OnMenuItemClickListener\#onMenuItemClick MenuItem.OnMenuItemClickListener.onMenuItemClick.
  /// </li>
  /// <li>
  /// Receiving a call to android.app.Activity\#onOptionsItemSelected(MenuItem) Activity.onOptionsItemSelected(MenuItem)
  /// </li>
  /// <li>
  /// Receiving a call to android.app.Fragment\#onOptionsItemSelected(MenuItem) Fragment.onOptionsItemSelected(MenuItem)
  /// </li>
  /// <li>
  /// Launching the android.content.Intent set via
  /// MenuItem\#setIntent(android.content.Intent) MenuItem.setIntent(android.content.Intent)
  /// </li>
  /// <li>
  /// Invoking this method.
  /// </li>
  /// </ul>
  ///
  ///
  ///
  /// The default implementation does not perform any action and returns false.
  ///
  ///
  bool onPerformDefaultAction() => jniAccessors.callMethodWithArgs(reference,
      _id_onPerformDefaultAction, jni.JniType.booleanType, []).boolean;

  static final _id_hasSubMenu =
      jniAccessors.getMethodIDOf(_classRef, "hasSubMenu", "()Z");

  /// from: public boolean hasSubMenu()
  ///
  /// Determines if this ActionProvider has a submenu associated with it.
  ///
  /// Associated submenus will be shown when an action view is not. This
  /// provider instance will receive a call to \#onPrepareSubMenu(SubMenu)
  /// after the call to \#onPerformDefaultAction() and before a submenu is
  /// displayed to the user.
  ///@return true if the item backed by this provider should have an associated submenu
  bool hasSubMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSubMenu, jni.JniType.booleanType, []).boolean;

  static final _id_onPrepareSubMenu = jniAccessors.getMethodIDOf(
      _classRef, "onPrepareSubMenu", "(Landroid/view/SubMenu;)V");

  /// from: public void onPrepareSubMenu(android.view.SubMenu subMenu)
  ///
  /// Called to prepare an associated submenu for the menu item backed by this ActionProvider.
  ///
  /// if \#hasSubMenu() returns true, this method will be called when the
  /// menu item is selected to prepare the submenu for presentation to the user. Apps
  /// may use this to create or alter submenu content right before display.
  ///@param subMenu Submenu that will be displayed
  void onPrepareSubMenu(submenu_.SubMenu subMenu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrepareSubMenu,
          jni.JniType.voidType, [subMenu.reference]).check();

  static final _id_setVisibilityListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setVisibilityListener",
      "(Landroid/view/ActionProvider\$VisibilityListener;)V");

  /// from: public void setVisibilityListener(android.view.ActionProvider.VisibilityListener listener)
  ///
  /// Set a listener to be notified when this ActionProvider's overridden visibility changes.
  /// This should only be used by MenuItem implementations.
  ///@param listener listener to set
  void setVisibilityListener(ActionProvider_VisibilityListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVisibilityListener,
          jni.JniType.voidType, [listener.reference]).check();
}

/// from: android.view.ActionProvider$VisibilityListener
///
/// Listens to changes in visibility as reported by ActionProvider\#refreshVisibility().
///@see ActionProvider\#overridesItemVisibility()
///@see ActionProvider\#isVisible()
class ActionProvider_VisibilityListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/ActionProvider\$VisibilityListener");
  ActionProvider_VisibilityListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onActionProviderVisibilityChanged = jniAccessors
      .getMethodIDOf(_classRef, "onActionProviderVisibilityChanged", "(Z)V");

  /// from: public abstract void onActionProviderVisibilityChanged(boolean isVisible)
  void onActionProviderVisibilityChanged(bool isVisible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onActionProviderVisibilityChanged,
          jni.JniType.voidType,
          [isVisible]).check();
}
