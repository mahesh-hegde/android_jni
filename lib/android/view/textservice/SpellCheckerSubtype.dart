// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../content/Context.dart" as context_;

import "../../content/pm/ApplicationInfo.dart" as applicationinfo_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.textservice.SpellCheckerSubtype
///
/// This class is used to specify meta information of a subtype contained in a spell checker.
/// Subtype can describe locale (e.g. en_US, fr_FR...) used for settings.
///@see SpellCheckerInfo
///@attr ref android.R.styleable\#SpellChecker_Subtype_label
///@attr ref android.R.styleable\#SpellChecker_Subtype_languageTag
///@attr ref android.R.styleable\#SpellChecker_Subtype_subtypeLocale
///@attr ref android.R.styleable\#SpellChecker_Subtype_subtypeExtraValue
///@attr ref android.R.styleable\#SpellChecker_Subtype_subtypeId
class SpellCheckerSubtype extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/textservice/SpellCheckerSubtype");
  SpellCheckerSubtype.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.textservice.SpellCheckerSubtype> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILjava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(int nameId, java.lang.String locale, java.lang.String extraValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor.
  ///@param nameId The name of the subtype
  ///@param locale The locale supported by the subtype
  ///@param extraValue The extra value of the subtype
  ///@deprecated There is no public API that requires developers to directly instantiate custom
  /// SpellCheckerSubtype objects right now.  Hence only the system is expected to be able
  /// to instantiate SpellCheckerSubtype object.
  SpellCheckerSubtype(
      int nameId, jni.JniString locale, jni.JniString extraValue)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [nameId, locale.reference, extraValue.reference]).object);

  static final _id_getNameResId =
      jniAccessors.getMethodIDOf(_classRef, "getNameResId", "()I");

  /// from: public int getNameResId()
  ///
  /// @return the name of the subtype
  int getNameResId() => jniAccessors.callMethodWithArgs(
      reference, _id_getNameResId, jni.JniType.intType, []).integer;

  static final _id_getLocale = jniAccessors.getMethodIDOf(
      _classRef, "getLocale", "()Ljava/lang/String;");

  /// from: public java.lang.String getLocale()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the locale of the subtype
  ///
  /// This value will never be {@code null}.
  ///@deprecated Use \#getLanguageTag() instead.
  jni.JniString getLocale() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocale, jni.JniType.objectType, []).object);

  static final _id_getLanguageTag = jniAccessors.getMethodIDOf(
      _classRef, "getLanguageTag", "()Ljava/lang/String;");

  /// from: public java.lang.String getLanguageTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the BCP-47 Language Tag of the subtype.  Returns an empty string when no Language Tag
  /// is specified.
  ///
  /// This value will never be {@code null}.
  ///@see Locale\#forLanguageTag(String)
  jni.JniString getLanguageTag() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLanguageTag, jni.JniType.objectType, []).object);

  static final _id_getExtraValue = jniAccessors.getMethodIDOf(
      _classRef, "getExtraValue", "()Ljava/lang/String;");

  /// from: public java.lang.String getExtraValue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the extra value of the subtype
  jni.JniString getExtraValue() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtraValue, jni.JniType.objectType, []).object);

  static final _id_containsExtraValueKey = jniAccessors.getMethodIDOf(
      _classRef, "containsExtraValueKey", "(Ljava/lang/String;)Z");

  /// from: public boolean containsExtraValueKey(java.lang.String key)
  ///
  /// The string of ExtraValue in subtype should be defined as follows:
  /// example: key0,key1=value1,key2,key3,key4=value4
  ///@param key the key of extra value
  ///@return the subtype contains specified the extra value
  bool containsExtraValueKey(jni.JniString key) =>
      jniAccessors.callMethodWithArgs(reference, _id_containsExtraValueKey,
          jni.JniType.booleanType, [key.reference]).boolean;

  static final _id_getExtraValueOf = jniAccessors.getMethodIDOf(
      _classRef, "getExtraValueOf", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getExtraValueOf(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The string of ExtraValue in subtype should be defined as follows:
  /// example: key0,key1=value1,key2,key3,key4=value4
  ///@param key the key of extra value
  ///@return the value of the specified key
  jni.JniString getExtraValueOf(jni.JniString key) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getExtraValueOf, jni.JniType.objectType, [key.reference]).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_getDisplayName = jniAccessors.getMethodIDOf(
      _classRef,
      "getDisplayName",
      "(Landroid/content/Context;Ljava/lang/String;Landroid/content/pm/ApplicationInfo;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getDisplayName(android.content.Context context, java.lang.String packageName, android.content.pm.ApplicationInfo appInfo)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param context Context will be used for getting Locale and PackageManager.
  ///@param packageName The package name of the spell checker
  ///@param appInfo The application info of the spell checker
  ///@return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
  /// can have only one %s in it. If there is, the %s part will be replaced with the locale's
  /// display name by the formatter. If there is not, this method simply returns the string
  /// specified by mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the
  /// framework to generate an appropriate display name.
  jni.JniObject getDisplayName(
          context_.Context context,
          jni.JniString packageName,
          applicationinfo_.ApplicationInfo appInfo) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDisplayName, jni.JniType.objectType, [
        context.reference,
        packageName.reference,
        appInfo.reference
      ]).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(parcel_.Parcel dest, int parcelableFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, parcelableFlags]).check();
}
