// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "SpellCheckerInfo.dart" as spellcheckerinfo_;

import "TextInfo.dart" as textinfo_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.textservice.SpellCheckerSession
///
/// The SpellCheckerSession interface provides the per client functionality of SpellCheckerService.
///
///
/// <a name="Applications"></a>
/// <h3>Applications</h3>
///
/// In most cases, applications that are using the standard
/// android.widget.TextView or its subclasses will have little they need
/// to do to work well with spell checker services.  The main things you need to
/// be aware of are:
///
///
/// <ul>
/// <li> Properly set the android.R.attr\#inputType in your editable
/// text views, so that the spell checker will have enough context to help the
/// user in editing text in them.
/// </ul>
///
/// For the rare people amongst us writing client applications that use the spell checker service
/// directly, you will need to use \#getSuggestions(TextInfo, int) or
/// \#getSuggestions(TextInfo[], int, boolean) for obtaining results from the spell checker
/// service by yourself.
///
///
/// <h3>Security</h3>
///
/// There are a lot of security issues associated with spell checkers,
/// since they could monitor all the text being sent to them
/// through, for instance, android.widget.TextView.
/// The Android spell checker framework also allows
/// arbitrary third party spell checkers, so care must be taken to restrict their
/// selection and interactions.
///
///
/// Here are some key points about the security architecture behind the
/// spell checker framework:
///
///
/// <ul>
/// <li>Only the system is allowed to directly access a spell checker framework's
/// android.service.textservice.SpellCheckerService interface, via the
/// android.Manifest.permission\#BIND_TEXT_SERVICE permission.  This is
/// enforced in the system by not binding to a spell checker service that does
/// not require this permission.
///
/// <li>The user must explicitly enable a new spell checker in settings before
/// they can be enabled, to confirm with the system that they know about it
/// and want to make it available for use.
/// </ul>
class SpellCheckerSession extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/textservice/SpellCheckerSession");
  SpellCheckerSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String SERVICE_META_DATA
  ///
  /// Name under which a SpellChecker service component publishes information about itself.
  /// This meta-data must reference an XML resource.
  static const SERVICE_META_DATA = "android.view.textservice.scs";

  static final _id_isSessionDisconnected =
      jniAccessors.getMethodIDOf(_classRef, "isSessionDisconnected", "()Z");

  /// from: public boolean isSessionDisconnected()
  ///
  /// @return true if the connection to a text service of this session is disconnected and not
  /// alive.
  bool isSessionDisconnected() => jniAccessors.callMethodWithArgs(reference,
      _id_isSessionDisconnected, jni.JniType.booleanType, []).boolean;

  static final _id_getSpellChecker = jniAccessors.getMethodIDOf(_classRef,
      "getSpellChecker", "()Landroid/view/textservice/SpellCheckerInfo;");

  /// from: public android.view.textservice.SpellCheckerInfo getSpellChecker()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the spell checker service info this spell checker session has.
  ///@return SpellCheckerInfo for the specified locale.
  spellcheckerinfo_.SpellCheckerInfo getSpellChecker() =>
      spellcheckerinfo_.SpellCheckerInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getSpellChecker,
              jni.JniType.objectType, []).object);

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "()V");

  /// from: public void cancel()
  ///
  /// Cancel pending and running spell check tasks
  void cancel() => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Finish this session and allow TextServicesManagerService to disconnect the bound spell
  /// checker.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_getSentenceSuggestions = jniAccessors.getMethodIDOf(
      _classRef,
      "getSentenceSuggestions",
      "([Landroid/view/textservice/TextInfo;I)V");

  /// from: public void getSentenceSuggestions(android.view.textservice.TextInfo[] textInfos, int suggestionsLimit)
  ///
  /// Get suggestions from the specified sentences
  ///@param textInfos an array of text metadata for a spell checker
  ///@param suggestionsLimit the maximum number of suggestions that will be returned
  void getSentenceSuggestions(jni.JniObject textInfos, int suggestionsLimit) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getSentenceSuggestions,
          jni.JniType.voidType,
          [textInfos.reference, suggestionsLimit]).check();

  static final _id_getSuggestions = jniAccessors.getMethodIDOf(
      _classRef, "getSuggestions", "(Landroid/view/textservice/TextInfo;I)V");

  /// from: public void getSuggestions(android.view.textservice.TextInfo textInfo, int suggestionsLimit)
  ///
  /// Get candidate strings for a substring of the specified text.
  ///@param textInfo text metadata for a spell checker
  ///@param suggestionsLimit the maximum number of suggestions that will be returned
  ///@deprecated use SpellCheckerSession\#getSentenceSuggestions(TextInfo[], int) instead
  void getSuggestions(textinfo_.TextInfo textInfo, int suggestionsLimit) =>
      jniAccessors.callMethodWithArgs(reference, _id_getSuggestions,
          jni.JniType.voidType, [textInfo.reference, suggestionsLimit]).check();

  static final _id_getSuggestions1 = jniAccessors.getMethodIDOf(
      _classRef, "getSuggestions", "([Landroid/view/textservice/TextInfo;IZ)V");

  /// from: public void getSuggestions(android.view.textservice.TextInfo[] textInfos, int suggestionsLimit, boolean sequentialWords)
  ///
  /// A batch process of getSuggestions
  ///@param textInfos an array of text metadata for a spell checker
  ///@param suggestionsLimit the maximum number of suggestions that will be returned
  ///@param sequentialWords true if textInfos can be treated as sequential words.
  ///@deprecated use SpellCheckerSession\#getSentenceSuggestions(TextInfo[], int) instead
  void getSuggestions1(jni.JniObject textInfos, int suggestionsLimit,
          bool sequentialWords) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getSuggestions1,
          jni.JniType.voidType,
          [textInfos.reference, suggestionsLimit, sequentialWords]).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.view.textservice.SpellCheckerSession$SpellCheckerSessionListener
///
/// Callback for getting results from text services
class SpellCheckerSession_SpellCheckerSessionListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/textservice/SpellCheckerSession\$SpellCheckerSessionListener");
  SpellCheckerSession_SpellCheckerSessionListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onGetSuggestions = jniAccessors.getMethodIDOf(_classRef,
      "onGetSuggestions", "([Landroid/view/textservice/SuggestionsInfo;)V");

  /// from: public abstract void onGetSuggestions(android.view.textservice.SuggestionsInfo[] results)
  ///
  /// Callback for SpellCheckerSession\#getSuggestions(TextInfo, int)
  /// and SpellCheckerSession\#getSuggestions(TextInfo[], int, boolean)
  ///@param results an array of SuggestionsInfos.
  /// These results are suggestions for TextInfos queried by
  /// SpellCheckerSession\#getSuggestions(TextInfo, int) or
  /// SpellCheckerSession\#getSuggestions(TextInfo[], int, boolean)
  void onGetSuggestions(jni.JniObject results) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGetSuggestions,
          jni.JniType.voidType, [results.reference]).check();

  static final _id_onGetSentenceSuggestions = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetSentenceSuggestions",
      "([Landroid/view/textservice/SentenceSuggestionsInfo;)V");

  /// from: public abstract void onGetSentenceSuggestions(android.view.textservice.SentenceSuggestionsInfo[] results)
  ///
  /// Callback for SpellCheckerSession\#getSentenceSuggestions(TextInfo[], int)
  ///@param results an array of SentenceSuggestionsInfos.
  /// These results are suggestions for TextInfos
  /// queried by SpellCheckerSession\#getSentenceSuggestions(TextInfo[], int).
  void onGetSentenceSuggestions(jni.JniObject results) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGetSentenceSuggestions,
          jni.JniType.voidType, [results.reference]).check();
}
