// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "View.dart" as view_;

import "ViewGroup.dart" as viewgroup_;

import "../graphics/Rect.dart" as rect_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.FocusFinder
///
/// The algorithm used for finding the next focusable view in a given direction
/// from a view that currently has focus.
class FocusFinder extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/FocusFinder");
  FocusFinder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/view/FocusFinder;");

  /// from: static public android.view.FocusFinder getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the focus finder for this thread.
  static FocusFinder getInstance() =>
      FocusFinder.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_findNextFocus = jniAccessors.getMethodIDOf(
      _classRef,
      "findNextFocus",
      "(Landroid/view/ViewGroup;Landroid/view/View;I)Landroid/view/View;");

  /// from: public final android.view.View findNextFocus(android.view.ViewGroup root, android.view.View focused, int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the next view to take focus in root's descendants, starting from the view
  /// that currently is focused.
  ///@param root Contains focused. Cannot be null.
  ///@param focused Has focus now.
  ///@param direction Direction to look.
  ///@return The next focusable view, or null if none exists.
  view_.View findNextFocus(
          viewgroup_.ViewGroup root, view_.View focused, int direction) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findNextFocus,
          jni.JniType.objectType,
          [root.reference, focused.reference, direction]).object);

  static final _id_findNextFocusFromRect = jniAccessors.getMethodIDOf(
      _classRef,
      "findNextFocusFromRect",
      "(Landroid/view/ViewGroup;Landroid/graphics/Rect;I)Landroid/view/View;");

  /// from: public android.view.View findNextFocusFromRect(android.view.ViewGroup root, android.graphics.Rect focusedRect, int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the next view to take focus in root's descendants, searching from
  /// a particular rectangle in root's coordinates.
  ///@param root Contains focusedRect. Cannot be null.
  ///@param focusedRect The starting point of the search.
  ///@param direction Direction to look.
  ///@return The next focusable view, or null if none exists.
  view_.View findNextFocusFromRect(
          viewgroup_.ViewGroup root, rect_.Rect focusedRect, int direction) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findNextFocusFromRect,
          jni.JniType.objectType,
          [root.reference, focusedRect.reference, direction]).object);

  static final _id_findNextKeyboardNavigationCluster =
      jniAccessors.getMethodIDOf(_classRef, "findNextKeyboardNavigationCluster",
          "(Landroid/view/View;Landroid/view/View;I)Landroid/view/View;");

  /// from: public android.view.View findNextKeyboardNavigationCluster(android.view.View root, android.view.View currentCluster, int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the root of the next keyboard navigation cluster after the current one.
  ///@param root The view tree to look inside. Cannot be null
  /// This value must never be {@code null}.
  ///@param currentCluster The starting point of the search. Null means the default cluster
  /// This value may be {@code null}.
  ///@param direction Direction to look
  /// Value is android.view.View\#FOCUS_BACKWARD, android.view.View\#FOCUS_FORWARD, android.view.View\#FOCUS_LEFT, android.view.View\#FOCUS_UP, android.view.View\#FOCUS_RIGHT, or android.view.View\#FOCUS_DOWN
  ///@return The next cluster, or null if none exists
  view_.View findNextKeyboardNavigationCluster(
          view_.View root, view_.View currentCluster, int direction) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findNextKeyboardNavigationCluster,
          jni.JniType.objectType,
          [root.reference, currentCluster.reference, direction]).object);

  static final _id_findNearestTouchable = jniAccessors.getMethodIDOf(
      _classRef,
      "findNearestTouchable",
      "(Landroid/view/ViewGroup;III[I)Landroid/view/View;");

  /// from: public android.view.View findNearestTouchable(android.view.ViewGroup root, int x, int y, int direction, int[] deltas)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the nearest touchable view to the specified view.
  ///@param root The root of the tree in which to search
  ///@param x X coordinate from which to start the search
  ///@param y Y coordinate from which to start the search
  ///@param direction Direction to look
  ///@param deltas Offset from the <x, y> to the edge of the nearest view. Note that this array
  ///        may already be populated with values.
  ///@return The nearest touchable view, or null if none exists.
  view_.View findNearestTouchable(viewgroup_.ViewGroup root, int x, int y,
          int direction, jni.JniObject deltas) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findNearestTouchable,
          jni.JniType.objectType,
          [root.reference, x, y, direction, deltas.reference]).object);
}
