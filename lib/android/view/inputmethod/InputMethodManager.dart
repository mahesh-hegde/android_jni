// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "InputMethodInfo.dart" as inputmethodinfo_;

import "../../os/IBinder.dart" as ibinder_;

import "../View.dart" as view_;

import "ExtractedText.dart" as extractedtext_;

import "../../os/ResultReceiver.dart" as resultreceiver_;

import "CursorAnchorInfo.dart" as cursoranchorinfo_;

import "../../os/Bundle.dart" as bundle_;

import "InputMethodSubtype.dart" as inputmethodsubtype_;

import "../KeyEvent.dart" as keyevent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.inputmethod.InputMethodManager
///
/// Central system API to the overall input method framework (IMF) architecture,
/// which arbitrates interaction between applications and the current input method.
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#ArchitectureOverview">Architecture Overview</a>
/// <li><a href="\#Applications">Applications</a>
/// <li><a href="\#InputMethods">Input Methods</a>
/// <li><a href="\#Security">Security</a>
/// </ol>
///
/// <a name="ArchitectureOverview"></a>
/// <h3>Architecture Overview</h3>
///
/// There are three primary parties involved in the input method
/// framework (IMF) architecture:
///
///
/// <ul>
/// <li> The <strong>input method manager</strong> as expressed by this class
/// is the central point of the system that manages interaction between all
/// other parts.  It is expressed as the client-side API here which exists
/// in each application context and communicates with a global system service
/// that manages the interaction across all processes.
/// <li> An <strong>input method (IME)</strong> implements a particular
/// interaction model allowing the user to generate text.  The system binds
/// to the current input method that is in use, causing it to be created and run,
/// and tells it when to hide and show its UI.  Only one IME is running at a time.
/// <li> Multiple <strong>client applications</strong> arbitrate with the input
/// method manager for input focus and control over the state of the IME.  Only
/// one such client is ever active (working with the IME) at a time.
/// </ul>
///
///
/// <a name="Applications"></a>
/// <h3>Applications</h3>
///
/// In most cases, applications that are using the standard
/// android.widget.TextView or its subclasses will have little they need
/// to do to work well with soft input methods.  The main things you need to
/// be aware of are:
///
///
/// <ul>
/// <li> Properly set the android.R.attr\#inputType in your editable
/// text views, so that the input method will have enough context to help the
/// user in entering text into them.
/// <li> Deal well with losing screen space when the input method is
/// displayed.  Ideally an application should handle its window being resized
/// smaller, but it can rely on the system performing panning of the window
/// if needed.  You should set the android.R.attr\#windowSoftInputMode
/// attribute on your activity or the corresponding values on windows you
/// create to help the system determine whether to pan or resize (it will
/// try to determine this automatically but may get it wrong).
/// <li> You can also control the preferred soft input state (open, closed, etc)
/// for your window using the same android.R.attr\#windowSoftInputMode
/// attribute.
/// </ul>
///
/// More finer-grained control is available through the APIs here to directly
/// interact with the IMF and its IME -- either showing or hiding the input
/// area, letting the user pick an input method, etc.
///
///
/// For the rare people amongst us writing their own text editors, you
/// will need to implement android.view.View\#onCreateInputConnection
/// to return a new instance of your own InputConnection interface
/// allowing the IME to interact with your editor.
///
///
///
/// <a name="InputMethods"></a>
/// <h3>Input Methods</h3>
///
/// An input method (IME) is implemented
/// as a android.app.Service, typically deriving from
/// android.inputmethodservice.InputMethodService.  It must provide
/// the core InputMethod interface, though this is normally handled by
/// android.inputmethodservice.InputMethodService and implementors will
/// only need to deal with the higher-level API there.
///
///
/// See the android.inputmethodservice.InputMethodService class for
/// more information on implementing IMEs.
///
///
/// <a name="Security"></a>
/// <h3>Security</h3>
///
/// There are a lot of security issues associated with input methods,
/// since they essentially have freedom to completely drive the UI and monitor
/// everything the user enters.  The Android input method framework also allows
/// arbitrary third party IMEs, so care must be taken to restrict their
/// selection and interactions.
///
///
/// Here are some key points about the security architecture behind the
/// IMF:
///
///
/// <ul>
/// <li> Only the system is allowed to directly access an IME's
/// InputMethod interface, via the
/// android.Manifest.permission\#BIND_INPUT_METHOD permission.  This is
/// enforced in the system by not binding to an input method service that does
/// not require this permission, so the system can guarantee no other untrusted
/// clients are accessing the current input method outside of its control.
///
///
/// <li> There may be many client processes of the IMF, but only one may
/// be active at a time.  The inactive clients can not interact with key
/// parts of the IMF through the mechanisms described below.
///
///
/// <li> Clients of an input method are only given access to its
/// InputMethodSession interface.  One instance of this interface is
/// created for each client, and only calls from the session associated with
/// the active client will be processed by the current IME.  This is enforced
/// by android.inputmethodservice.AbstractInputMethodService for normal
/// IMEs, but must be explicitly handled by an IME that is customizing the
/// raw InputMethodSession implementation.
///
///
/// <li> Only the active client's InputConnection will accept
/// operations.  The IMF tells each client process whether it is active, and
/// the framework enforces that in inactive processes calls on to the current
/// InputConnection will be ignored.  This ensures that the current IME can
/// only deliver events and text edits to the UI that the user sees as
/// being in focus.
///
///
/// <li> An IME can never interact with an InputConnection while
/// the screen is off.  This is enforced by making all clients inactive while
/// the screen is off, and prevents bad IMEs from driving the UI when the user
/// can not be aware of its behavior.
///
///
/// <li> A client application can ask that the system let the user pick a
/// new IME, but can not programmatically switch to one itself.  This avoids
/// malicious applications from switching the user to their own IME, which
/// remains running when the user navigates away to another application.  An
/// IME, on the other hand, _is_ allowed to programmatically switch
/// the system to another IME, since it already has full control of user
/// input.
///
///
/// <li> The user must explicitly enable a new IME in settings before
/// they can switch to it, to confirm with the system that they know about it
/// and want to make it available for use.
///
/// </ul>
///
/// Requires the android.content.pm.PackageManager\#FEATURE_INPUT_METHODS PackageManager\#FEATURE_INPUT_METHODS feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
class InputMethodManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/inputmethod/InputMethodManager");
  InputMethodManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int HIDE_IMPLICIT_ONLY
  ///
  /// Flag for \#hideSoftInputFromWindow and InputMethodService\#requestHideSelf(int)
  /// to indicate that the soft input window should only be hidden if it was not explicitly shown
  /// by the user.
  static const HIDE_IMPLICIT_ONLY = 1;

  /// from: static public final int HIDE_NOT_ALWAYS
  ///
  /// Flag for \#hideSoftInputFromWindow and InputMethodService\#requestShowSelf(int)
  /// to indicate that the soft input window should normally be hidden, unless it was originally
  /// shown with \#SHOW_FORCED.
  static const HIDE_NOT_ALWAYS = 2;

  /// from: static public final int RESULT_HIDDEN
  ///
  /// Flag for the ResultReceiver result code from
  /// \#showSoftInput(View, int, ResultReceiver) and
  /// \#hideSoftInputFromWindow(IBinder, int, ResultReceiver): the
  /// state of the soft input window changed from shown to hidden.
  static const RESULT_HIDDEN = 3;

  /// from: static public final int RESULT_SHOWN
  ///
  /// Flag for the ResultReceiver result code from
  /// \#showSoftInput(View, int, ResultReceiver) and
  /// \#hideSoftInputFromWindow(IBinder, int, ResultReceiver): the
  /// state of the soft input window changed from hidden to shown.
  static const RESULT_SHOWN = 2;

  /// from: static public final int RESULT_UNCHANGED_HIDDEN
  ///
  /// Flag for the ResultReceiver result code from
  /// \#showSoftInput(View, int, ResultReceiver) and
  /// \#hideSoftInputFromWindow(IBinder, int, ResultReceiver): the
  /// state of the soft input window was unchanged and remains hidden.
  static const RESULT_UNCHANGED_HIDDEN = 1;

  /// from: static public final int RESULT_UNCHANGED_SHOWN
  ///
  /// Flag for the ResultReceiver result code from
  /// \#showSoftInput(View, int, ResultReceiver) and
  /// \#hideSoftInputFromWindow(IBinder, int, ResultReceiver): the
  /// state of the soft input window was unchanged and remains shown.
  static const RESULT_UNCHANGED_SHOWN = 0;

  /// from: static public final int SHOW_FORCED
  ///
  /// Flag for \#showSoftInput to indicate that the user has forced
  /// the input method open (such as by long-pressing menu) so it should
  /// not be closed until they explicitly do so.
  static const SHOW_FORCED = 2;

  /// from: static public final int SHOW_IMPLICIT
  ///
  /// Flag for \#showSoftInput to indicate that this is an implicit
  /// request to show the input window, not as the result of a direct request
  /// by the user.  The window may not be shown in this case.
  static const SHOW_IMPLICIT = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputMethodManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getInputMethodList = jniAccessors.getMethodIDOf(
      _classRef, "getInputMethodList", "()Ljava/util/List;");

  /// from: public java.util.List<android.view.inputmethod.InputMethodInfo> getInputMethodList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getInputMethodList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInputMethodList, jni.JniType.objectType, []).object);

  static final _id_getEnabledInputMethodList = jniAccessors.getMethodIDOf(
      _classRef, "getEnabledInputMethodList", "()Ljava/util/List;");

  /// from: public java.util.List<android.view.inputmethod.InputMethodInfo> getEnabledInputMethodList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getEnabledInputMethodList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getEnabledInputMethodList, jni.JniType.objectType, []).object);

  static final _id_getEnabledInputMethodSubtypeList =
      jniAccessors.getMethodIDOf(_classRef, "getEnabledInputMethodSubtypeList",
          "(Landroid/view/inputmethod/InputMethodInfo;Z)Ljava/util/List;");

  /// from: public java.util.List<android.view.inputmethod.InputMethodSubtype> getEnabledInputMethodSubtypeList(android.view.inputmethod.InputMethodInfo imi, boolean allowsImplicitlySelectedSubtypes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of enabled input method subtypes for the specified input method info.
  ///@param imi An input method info whose subtypes list will be returned.
  ///@param allowsImplicitlySelectedSubtypes A boolean flag to allow to return the implicitly
  /// selected subtypes. If an input method info doesn't have enabled subtypes, the framework
  /// will implicitly enable subtypes according to the current system language.
  jni.JniObject getEnabledInputMethodSubtypeList(
          inputmethodinfo_.InputMethodInfo imi,
          bool allowsImplicitlySelectedSubtypes) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getEnabledInputMethodSubtypeList,
          jni.JniType.objectType,
          [imi.reference, allowsImplicitlySelectedSubtypes]).object);

  static final _id_showStatusIcon = jniAccessors.getMethodIDOf(_classRef,
      "showStatusIcon", "(Landroid/os/IBinder;Ljava/lang/String;I)V");

  /// from: public void showStatusIcon(android.os.IBinder imeToken, java.lang.String packageName, int iconId)
  ///
  /// @deprecated Use InputMethodService\#showStatusIcon(int) instead. This method was
  /// intended for IME developers who should be accessing APIs through the service. APIs in this
  /// class are intended for app developers interacting with the IME.
  void showStatusIcon(
          ibinder_.IBinder imeToken, jni.JniString packageName, int iconId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_showStatusIcon,
          jni.JniType.voidType,
          [imeToken.reference, packageName.reference, iconId]).check();

  static final _id_hideStatusIcon = jniAccessors.getMethodIDOf(
      _classRef, "hideStatusIcon", "(Landroid/os/IBinder;)V");

  /// from: public void hideStatusIcon(android.os.IBinder imeToken)
  ///
  /// @deprecated Use InputMethodService\#hideStatusIcon() instead. This method was
  /// intended for IME developers who should be accessing APIs through the service. APIs in
  /// this class are intended for app developers interacting with the IME.
  void hideStatusIcon(ibinder_.IBinder imeToken) =>
      jniAccessors.callMethodWithArgs(reference, _id_hideStatusIcon,
          jni.JniType.voidType, [imeToken.reference]).check();

  static final _id_isFullscreenMode =
      jniAccessors.getMethodIDOf(_classRef, "isFullscreenMode", "()Z");

  /// from: public boolean isFullscreenMode()
  ///
  /// Allows you to discover whether the attached input method is running
  /// in fullscreen mode.  Return true if it is fullscreen, entirely covering
  /// your UI, else returns false.
  bool isFullscreenMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isFullscreenMode, jni.JniType.booleanType, []).boolean;

  static final _id_isActive = jniAccessors.getMethodIDOf(
      _classRef, "isActive", "(Landroid/view/View;)Z");

  /// from: public boolean isActive(android.view.View view)
  ///
  /// Return true if the given view is the currently active view for the
  /// input method.
  bool isActive(view_.View view) => jniAccessors.callMethodWithArgs(reference,
      _id_isActive, jni.JniType.booleanType, [view.reference]).boolean;

  static final _id_isActive1 =
      jniAccessors.getMethodIDOf(_classRef, "isActive", "()Z");

  /// from: public boolean isActive()
  ///
  /// Return true if any view is currently active in the input method.
  bool isActive1() => jniAccessors.callMethodWithArgs(
      reference, _id_isActive1, jni.JniType.booleanType, []).boolean;

  static final _id_isAcceptingText =
      jniAccessors.getMethodIDOf(_classRef, "isAcceptingText", "()Z");

  /// from: public boolean isAcceptingText()
  ///
  /// Return true if the currently served view is accepting full text edits.
  /// If false, it has no input connection, so can only handle raw key events.
  bool isAcceptingText() => jniAccessors.callMethodWithArgs(
      reference, _id_isAcceptingText, jni.JniType.booleanType, []).boolean;

  static final _id_displayCompletions = jniAccessors.getMethodIDOf(
      _classRef,
      "displayCompletions",
      "(Landroid/view/View;[Landroid/view/inputmethod/CompletionInfo;)V");

  /// from: public void displayCompletions(android.view.View view, android.view.inputmethod.CompletionInfo[] completions)
  void displayCompletions(view_.View view, jni.JniObject completions) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_displayCompletions,
          jni.JniType.voidType,
          [view.reference, completions.reference]).check();

  static final _id_updateExtractedText = jniAccessors.getMethodIDOf(
      _classRef,
      "updateExtractedText",
      "(Landroid/view/View;ILandroid/view/inputmethod/ExtractedText;)V");

  /// from: public void updateExtractedText(android.view.View view, int token, android.view.inputmethod.ExtractedText text)
  void updateExtractedText(
          view_.View view, int token, extractedtext_.ExtractedText text) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_updateExtractedText,
          jni.JniType.voidType,
          [view.reference, token, text.reference]).check();

  static final _id_showSoftInput = jniAccessors.getMethodIDOf(
      _classRef, "showSoftInput", "(Landroid/view/View;I)Z");

  /// from: public boolean showSoftInput(android.view.View view, int flags)
  ///
  /// Synonym for \#showSoftInput(View, int, ResultReceiver) without
  /// a result receiver: explicitly request that the current input method's
  /// soft input area be shown to the user, if needed.
  ///@param view The currently focused view, which would like to receive
  /// soft keyboard input.
  ///@param flags Provides additional operating flags.  Currently may be
  /// 0 or have the \#SHOW_IMPLICIT bit set.
  bool showSoftInput(view_.View view, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_showSoftInput,
          jni.JniType.booleanType, [view.reference, flags]).boolean;

  static final _id_showSoftInput1 = jniAccessors.getMethodIDOf(_classRef,
      "showSoftInput", "(Landroid/view/View;ILandroid/os/ResultReceiver;)Z");

  /// from: public boolean showSoftInput(android.view.View view, int flags, android.os.ResultReceiver resultReceiver)
  ///
  /// Explicitly request that the current input method's soft input area be
  /// shown to the user, if needed.  Call this if the user interacts with
  /// your view in such a way that they have expressed they would like to
  /// start performing input into it.
  ///
  /// <strong>Caveat:</strong> ResultReceiver instance passed to
  /// this method can be a long-lived object, because it may not be
  /// garbage-collected until all the corresponding ResultReceiver
  /// objects transferred to different processes get garbage-collected.
  /// Follow the general patterns to avoid memory leaks in Android.
  /// Consider to use java.lang.ref.WeakReference so that application
  /// logic objects such as android.app.Activity and Context
  /// can be garbage collected regardless of the lifetime of
  /// ResultReceiver.
  ///@param view The currently focused view, which would like to receive
  /// soft keyboard input.
  ///@param flags Provides additional operating flags.  Currently may be
  /// 0 or have the \#SHOW_IMPLICIT bit set.
  ///@param resultReceiver If non-null, this will be called by the IME when
  /// it has processed your request to tell you what it has done.  The result
  /// code you receive may be either \#RESULT_UNCHANGED_SHOWN,
  /// \#RESULT_UNCHANGED_HIDDEN, \#RESULT_SHOWN, or
  /// \#RESULT_HIDDEN.
  bool showSoftInput1(view_.View view, int flags,
          resultreceiver_.ResultReceiver resultReceiver) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_showSoftInput1,
          jni.JniType.booleanType,
          [view.reference, flags, resultReceiver.reference]).boolean;

  static final _id_hideSoftInputFromWindow = jniAccessors.getMethodIDOf(
      _classRef, "hideSoftInputFromWindow", "(Landroid/os/IBinder;I)Z");

  /// from: public boolean hideSoftInputFromWindow(android.os.IBinder windowToken, int flags)
  ///
  /// Synonym for \#hideSoftInputFromWindow(IBinder, int, ResultReceiver)
  /// without a result: request to hide the soft input window from the
  /// context of the window that is currently accepting input.
  ///@param windowToken The token of the window that is making the request,
  /// as returned by View\#getWindowToken() View.getWindowToken().
  ///@param flags Provides additional operating flags.  Currently may be
  /// 0 or have the \#HIDE_IMPLICIT_ONLY bit set.
  bool hideSoftInputFromWindow(ibinder_.IBinder windowToken, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_hideSoftInputFromWindow,
          jni.JniType.booleanType, [windowToken.reference, flags]).boolean;

  static final _id_hideSoftInputFromWindow1 = jniAccessors.getMethodIDOf(
      _classRef,
      "hideSoftInputFromWindow",
      "(Landroid/os/IBinder;ILandroid/os/ResultReceiver;)Z");

  /// from: public boolean hideSoftInputFromWindow(android.os.IBinder windowToken, int flags, android.os.ResultReceiver resultReceiver)
  ///
  /// Request to hide the soft input window from the context of the window
  /// that is currently accepting input.  This should be called as a result
  /// of the user doing some actually than fairly explicitly requests to
  /// have the input window hidden.
  ///
  /// <strong>Caveat:</strong> ResultReceiver instance passed to
  /// this method can be a long-lived object, because it may not be
  /// garbage-collected until all the corresponding ResultReceiver
  /// objects transferred to different processes get garbage-collected.
  /// Follow the general patterns to avoid memory leaks in Android.
  /// Consider to use java.lang.ref.WeakReference so that application
  /// logic objects such as android.app.Activity and Context
  /// can be garbage collected regardless of the lifetime of
  /// ResultReceiver.
  ///@param windowToken The token of the window that is making the request,
  /// as returned by View\#getWindowToken() View.getWindowToken().
  ///@param flags Provides additional operating flags.  Currently may be
  /// 0 or have the \#HIDE_IMPLICIT_ONLY bit set.
  ///@param resultReceiver If non-null, this will be called by the IME when
  /// it has processed your request to tell you what it has done.  The result
  /// code you receive may be either \#RESULT_UNCHANGED_SHOWN,
  /// \#RESULT_UNCHANGED_HIDDEN, \#RESULT_SHOWN, or
  /// \#RESULT_HIDDEN.
  bool hideSoftInputFromWindow1(ibinder_.IBinder windowToken, int flags,
          resultreceiver_.ResultReceiver resultReceiver) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_hideSoftInputFromWindow1,
          jni.JniType.booleanType,
          [windowToken.reference, flags, resultReceiver.reference]).boolean;

  static final _id_toggleSoftInputFromWindow = jniAccessors.getMethodIDOf(
      _classRef, "toggleSoftInputFromWindow", "(Landroid/os/IBinder;II)V");

  /// from: public void toggleSoftInputFromWindow(android.os.IBinder windowToken, int showFlags, int hideFlags)
  ///
  /// This method toggles the input method window display.
  /// If the input window is already displayed, it gets hidden.
  /// If not the input window will be displayed.
  ///@param windowToken The token of the window that is making the request,
  /// as returned by View\#getWindowToken() View.getWindowToken().
  ///@param showFlags Provides additional operating flags.  May be
  /// 0 or have the \#SHOW_IMPLICIT,
  /// \#SHOW_FORCED bit set.
  ///@param hideFlags Provides additional operating flags.  May be
  /// 0 or have the \#HIDE_IMPLICIT_ONLY,
  /// \#HIDE_NOT_ALWAYS bit set.
  void toggleSoftInputFromWindow(
          ibinder_.IBinder windowToken, int showFlags, int hideFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_toggleSoftInputFromWindow,
          jni.JniType.voidType,
          [windowToken.reference, showFlags, hideFlags]).check();

  static final _id_toggleSoftInput =
      jniAccessors.getMethodIDOf(_classRef, "toggleSoftInput", "(II)V");

  /// from: public void toggleSoftInput(int showFlags, int hideFlags)
  ///
  /// This method toggles the input method window display.
  ///
  /// If the input window is already displayed, it gets hidden.
  /// If not the input window will be displayed.
  ///@param showFlags Provides additional operating flags.  May be
  /// 0 or have the \#SHOW_IMPLICIT,
  /// \#SHOW_FORCED bit set.
  ///@param hideFlags Provides additional operating flags.  May be
  /// 0 or have the \#HIDE_IMPLICIT_ONLY,
  /// \#HIDE_NOT_ALWAYS bit set.
  void toggleSoftInput(int showFlags, int hideFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_toggleSoftInput,
          jni.JniType.voidType, [showFlags, hideFlags]).check();

  static final _id_restartInput = jniAccessors.getMethodIDOf(
      _classRef, "restartInput", "(Landroid/view/View;)V");

  /// from: public void restartInput(android.view.View view)
  ///
  /// If the input method is currently connected to the given view,
  /// restart it with its new contents.  You should call this when the text
  /// within your view changes outside of the normal input method or key
  /// input flow, such as when an application calls TextView.setText().
  ///@param view The view whose text has changed.
  void restartInput(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_restartInput,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_updateSelection = jniAccessors.getMethodIDOf(
      _classRef, "updateSelection", "(Landroid/view/View;IIII)V");

  /// from: public void updateSelection(android.view.View view, int selStart, int selEnd, int candidatesStart, int candidatesEnd)
  ///
  /// Report the current selection range.
  ///
  /// <strong>Editor authors</strong>, you need to call this method whenever
  /// the cursor moves in your editor. Remember that in addition to doing this, your
  /// editor needs to always supply current cursor values in
  /// EditorInfo\#initialSelStart and EditorInfo\#initialSelEnd every
  /// time android.view.View\#onCreateInputConnection(EditorInfo) is
  /// called, which happens whenever the keyboard shows up or the focus changes
  /// to a text field, among other cases.
  ///
  void updateSelection(view_.View view, int selStart, int selEnd,
          int candidatesStart, int candidatesEnd) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_updateSelection, jni.JniType.voidType, [
        view.reference,
        selStart,
        selEnd,
        candidatesStart,
        candidatesEnd
      ]).check();

  static final _id_viewClicked = jniAccessors.getMethodIDOf(
      _classRef, "viewClicked", "(Landroid/view/View;)V");

  /// from: public void viewClicked(android.view.View view)
  ///
  /// Notify the event when the user tapped or clicked the text view.
  void viewClicked(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_viewClicked,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_isWatchingCursor = jniAccessors.getMethodIDOf(
      _classRef, "isWatchingCursor", "(Landroid/view/View;)Z");

  /// from: public boolean isWatchingCursor(android.view.View view)
  ///
  /// Return true if the current input method wants to watch the location
  /// of the input editor's cursor in its window.
  ///@deprecated Use InputConnection\#requestCursorUpdates(int) instead.
  bool isWatchingCursor(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isWatchingCursor,
      jni.JniType.booleanType,
      [view.reference]).boolean;

  static final _id_updateCursor = jniAccessors.getMethodIDOf(
      _classRef, "updateCursor", "(Landroid/view/View;IIII)V");

  /// from: public void updateCursor(android.view.View view, int left, int top, int right, int bottom)
  ///
  /// Report the current cursor location in its window.
  ///@deprecated Use \#updateCursorAnchorInfo(View, CursorAnchorInfo) instead.
  void updateCursor(
          view_.View view, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_updateCursor,
          jni.JniType.voidType,
          [view.reference, left, top, right, bottom]).check();

  static final _id_updateCursorAnchorInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "updateCursorAnchorInfo",
      "(Landroid/view/View;Landroid/view/inputmethod/CursorAnchorInfo;)V");

  /// from: public void updateCursorAnchorInfo(android.view.View view, android.view.inputmethod.CursorAnchorInfo cursorAnchorInfo)
  ///
  /// Report positional change of the text insertion point and/or characters in the composition
  /// string.
  void updateCursorAnchorInfo(view_.View view,
          cursoranchorinfo_.CursorAnchorInfo cursorAnchorInfo) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_updateCursorAnchorInfo,
          jni.JniType.voidType,
          [view.reference, cursorAnchorInfo.reference]).check();

  static final _id_sendAppPrivateCommand = jniAccessors.getMethodIDOf(
      _classRef,
      "sendAppPrivateCommand",
      "(Landroid/view/View;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void sendAppPrivateCommand(android.view.View view, java.lang.String action, android.os.Bundle data)
  ///
  /// Call InputMethodSession\#appPrivateCommand(String, Bundle) InputMethodSession.appPrivateCommand() on the current Input Method.
  ///@param view Optional View that is sending the command, or null if
  /// you want to send the command regardless of the view that is attached
  /// to the input method.
  ///@param action Name of the command to be performed.  This _must_
  /// be a scoped name, i.e. prefixed with a package name you own, so that
  /// different developers will not create conflicting commands.
  ///@param data Any data to include with the command.
  void sendAppPrivateCommand(
          view_.View view, jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendAppPrivateCommand,
          jni.JniType.voidType,
          [view.reference, action.reference, data.reference]).check();

  static final _id_setInputMethod = jniAccessors.getMethodIDOf(
      _classRef, "setInputMethod", "(Landroid/os/IBinder;Ljava/lang/String;)V");

  /// from: public void setInputMethod(android.os.IBinder token, java.lang.String id)
  ///
  /// Force switch to a new input method component. This can only be called
  /// from an application or a service which has a token of the currently active input method.
  ///@param token Supplies the identifying token given to an input method
  /// when it was started, which allows it to perform this operation on
  /// itself.
  ///@param id The unique identifier for the new input method to be switched to.
  ///@deprecated Use InputMethodService\#switchInputMethod(String)
  /// instead. This method was intended for IME developers who should be accessing APIs through
  /// the service. APIs in this class are intended for app developers interacting with the IME.
  void setInputMethod(ibinder_.IBinder token, jni.JniString id) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInputMethod,
          jni.JniType.voidType, [token.reference, id.reference]).check();

  static final _id_setInputMethodAndSubtype = jniAccessors.getMethodIDOf(
      _classRef,
      "setInputMethodAndSubtype",
      "(Landroid/os/IBinder;Ljava/lang/String;Landroid/view/inputmethod/InputMethodSubtype;)V");

  /// from: public void setInputMethodAndSubtype(android.os.IBinder token, java.lang.String id, android.view.inputmethod.InputMethodSubtype subtype)
  ///
  /// Force switch to a new input method and subtype. This can only be called
  /// from an application or a service which has a token of the currently active input method.
  ///@param token Supplies the identifying token given to an input method
  /// when it was started, which allows it to perform this operation on
  /// itself.
  ///@param id The unique identifier for the new input method to be switched to.
  ///@param subtype The new subtype of the new input method to be switched to.
  ///@deprecated Use
  /// InputMethodService\#switchInputMethod(String, InputMethodSubtype)
  /// instead. This method was intended for IME developers who should be accessing APIs through
  /// the service. APIs in this class are intended for app developers interacting with the IME.
  void setInputMethodAndSubtype(ibinder_.IBinder token, jni.JniString id,
          inputmethodsubtype_.InputMethodSubtype subtype) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setInputMethodAndSubtype,
          jni.JniType.voidType,
          [token.reference, id.reference, subtype.reference]).check();

  static final _id_hideSoftInputFromInputMethod = jniAccessors.getMethodIDOf(
      _classRef, "hideSoftInputFromInputMethod", "(Landroid/os/IBinder;I)V");

  /// from: public void hideSoftInputFromInputMethod(android.os.IBinder token, int flags)
  ///
  /// Close/hide the input method's soft input area, so the user no longer
  /// sees it or can interact with it.  This can only be called
  /// from the currently active input method, as validated by the given token.
  ///@param token Supplies the identifying token given to an input method
  /// when it was started, which allows it to perform this operation on
  /// itself.
  ///@param flags Provides additional operating flags.  Currently may be
  /// 0 or have the \#HIDE_IMPLICIT_ONLY,
  /// \#HIDE_NOT_ALWAYS bit set.
  ///@deprecated Use InputMethodService\#requestHideSelf(int) instead. This method was
  /// intended for IME developers who should be accessing APIs through the service. APIs in this
  /// class are intended for app developers interacting with the IME.
  void hideSoftInputFromInputMethod(ibinder_.IBinder token, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_hideSoftInputFromInputMethod,
          jni.JniType.voidType,
          [token.reference, flags]).check();

  static final _id_showSoftInputFromInputMethod = jniAccessors.getMethodIDOf(
      _classRef, "showSoftInputFromInputMethod", "(Landroid/os/IBinder;I)V");

  /// from: public void showSoftInputFromInputMethod(android.os.IBinder token, int flags)
  ///
  /// Show the input method's soft input area, so the user
  /// sees the input method window and can interact with it.
  /// This can only be called from the currently active input method,
  /// as validated by the given token.
  ///@param token Supplies the identifying token given to an input method
  /// when it was started, which allows it to perform this operation on
  /// itself.
  ///@param flags Provides additional operating flags.  Currently may be
  /// 0 or have the \#SHOW_IMPLICIT or
  /// \#SHOW_FORCED bit set.
  ///@deprecated Use InputMethodService\#requestShowSelf(int) instead. This method was
  /// intended for IME developers who should be accessing APIs through the service. APIs in this
  /// class are intended for app developers interacting with the IME.
  void showSoftInputFromInputMethod(ibinder_.IBinder token, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_showSoftInputFromInputMethod,
          jni.JniType.voidType,
          [token.reference, flags]).check();

  static final _id_dispatchKeyEventFromInputMethod = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchKeyEventFromInputMethod",
      "(Landroid/view/View;Landroid/view/KeyEvent;)V");

  /// from: public void dispatchKeyEventFromInputMethod(android.view.View targetView, android.view.KeyEvent event)
  ///
  /// Provides the default implementation of InputConnection\#sendKeyEvent(KeyEvent), which
  /// is expected to dispatch an keyboard event sent from the IME to an appropriate event target
  /// depending on the given View and the current focus state.
  ///
  /// CAUTION: This method is provided only for the situation where
  /// InputConnection\#sendKeyEvent(KeyEvent) needs to be implemented without relying on
  /// BaseInputConnection. Do not use this API for anything else.
  ///
  ///@param targetView the default target view. If {@code null} is specified, then this method
  /// tries to find a good event target based on the current focus state.
  /// This value may be {@code null}.
  ///@param event the key event to be dispatched.
  ///
  /// This value must never be {@code null}.
  void dispatchKeyEventFromInputMethod(
          view_.View targetView, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchKeyEventFromInputMethod,
          jni.JniType.voidType,
          [targetView.reference, event.reference]).check();

  static final _id_showInputMethodPicker =
      jniAccessors.getMethodIDOf(_classRef, "showInputMethodPicker", "()V");

  /// from: public void showInputMethodPicker()
  void showInputMethodPicker() => jniAccessors.callMethodWithArgs(
      reference, _id_showInputMethodPicker, jni.JniType.voidType, []).check();

  static final _id_showInputMethodAndSubtypeEnabler =
      jniAccessors.getMethodIDOf(_classRef, "showInputMethodAndSubtypeEnabler",
          "(Ljava/lang/String;)V");

  /// from: public void showInputMethodAndSubtypeEnabler(java.lang.String imiId)
  ///
  /// Show the settings for enabling subtypes of the specified input method.
  ///@param imiId An input method, whose subtypes settings will be shown. If imiId is null,
  /// subtypes of all input methods will be shown.
  void showInputMethodAndSubtypeEnabler(jni.JniString imiId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_showInputMethodAndSubtypeEnabler,
          jni.JniType.voidType,
          [imiId.reference]).check();

  static final _id_getCurrentInputMethodSubtype = jniAccessors.getMethodIDOf(
      _classRef,
      "getCurrentInputMethodSubtype",
      "()Landroid/view/inputmethod/InputMethodSubtype;");

  /// from: public android.view.inputmethod.InputMethodSubtype getCurrentInputMethodSubtype()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current input method subtype. This subtype is one of the subtypes in
  /// the current input method. This method returns null when the current input method doesn't
  /// have any input method subtype.
  inputmethodsubtype_.InputMethodSubtype getCurrentInputMethodSubtype() =>
      inputmethodsubtype_.InputMethodSubtype.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getCurrentInputMethodSubtype,
              jni.JniType.objectType, []).object);

  static final _id_setCurrentInputMethodSubtype = jniAccessors.getMethodIDOf(
      _classRef,
      "setCurrentInputMethodSubtype",
      "(Landroid/view/inputmethod/InputMethodSubtype;)Z");

  /// from: public boolean setCurrentInputMethodSubtype(android.view.inputmethod.InputMethodSubtype subtype)
  ///
  /// Switch to a new input method subtype of the current input method.
  /// Requires android.Manifest.permission\#WRITE_SECURE_SETTINGS
  ///@param subtype A new input method subtype to switch.
  ///@return true if the current subtype was successfully switched. When the specified subtype is
  /// null, this method returns false.
  bool setCurrentInputMethodSubtype(
          inputmethodsubtype_.InputMethodSubtype subtype) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCurrentInputMethodSubtype,
          jni.JniType.booleanType,
          [subtype.reference]).boolean;

  static final _id_getShortcutInputMethodsAndSubtypes =
      jniAccessors.getMethodIDOf(
          _classRef, "getShortcutInputMethodsAndSubtypes", "()Ljava/util/Map;");

  /// from: public java.util.Map<android.view.inputmethod.InputMethodInfo,java.util.List<android.view.inputmethod.InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a map of all shortcut input method info and their subtypes.
  jni.JniObject getShortcutInputMethodsAndSubtypes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getShortcutInputMethodsAndSubtypes,
          jni.JniType.objectType, []).object);

  static final _id_switchToLastInputMethod = jniAccessors.getMethodIDOf(
      _classRef, "switchToLastInputMethod", "(Landroid/os/IBinder;)Z");

  /// from: public boolean switchToLastInputMethod(android.os.IBinder imeToken)
  ///
  /// Force switch to the last used input method and subtype. If the last input method didn't have
  /// any subtypes, the framework will simply switch to the last input method with no subtype
  /// specified.
  ///@param imeToken Supplies the identifying token given to an input method when it was started,
  /// which allows it to perform this operation on itself.
  ///@return true if the current input method and subtype was successfully switched to the last
  /// used input method and subtype.
  ///@deprecated Use InputMethodService\#switchToPreviousInputMethod() instead. This method
  /// was intended for IME developers who should be accessing APIs through the service. APIs in
  /// this class are intended for app developers interacting with the IME.
  bool switchToLastInputMethod(ibinder_.IBinder imeToken) =>
      jniAccessors.callMethodWithArgs(reference, _id_switchToLastInputMethod,
          jni.JniType.booleanType, [imeToken.reference]).boolean;

  static final _id_switchToNextInputMethod = jniAccessors.getMethodIDOf(
      _classRef, "switchToNextInputMethod", "(Landroid/os/IBinder;Z)Z");

  /// from: public boolean switchToNextInputMethod(android.os.IBinder imeToken, boolean onlyCurrentIme)
  ///
  /// Force switch to the next input method and subtype. If there is no IME enabled except
  /// current IME and subtype, do nothing.
  ///@param imeToken Supplies the identifying token given to an input method when it was started,
  /// which allows it to perform this operation on itself.
  ///@param onlyCurrentIme if true, the framework will find the next subtype which
  /// belongs to the current IME
  ///@return true if the current input method and subtype was successfully switched to the next
  /// input method and subtype.
  ///@deprecated Use InputMethodService\#switchToNextInputMethod(boolean) instead. This
  /// method was intended for IME developers who should be accessing APIs through the service.
  /// APIs in this class are intended for app developers interacting with the IME.
  bool switchToNextInputMethod(
          ibinder_.IBinder imeToken, bool onlyCurrentIme) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_switchToNextInputMethod,
          jni.JniType.booleanType,
          [imeToken.reference, onlyCurrentIme]).boolean;

  static final _id_shouldOfferSwitchingToNextInputMethod =
      jniAccessors.getMethodIDOf(_classRef,
          "shouldOfferSwitchingToNextInputMethod", "(Landroid/os/IBinder;)Z");

  /// from: public boolean shouldOfferSwitchingToNextInputMethod(android.os.IBinder imeToken)
  ///
  /// Returns true if the current IME needs to offer the users ways to switch to a next input
  /// method (e.g.&nbsp;a globe key.).
  /// When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
  /// the IME has to offer ways to to invoke \#switchToNextInputMethod accordingly.
  ///  Note that the system determines the most appropriate next input method
  /// and subtype in order to provide the consistent user experience in switching
  /// between IMEs and subtypes.
  ///@param imeToken Supplies the identifying token given to an input method when it was started,
  /// which allows it to perform this operation on itself.
  ///@deprecated Use InputMethodService\#shouldOfferSwitchingToNextInputMethod()
  /// instead. This method was intended for IME developers who should be accessing APIs through
  /// the service. APIs in this class are intended for app developers interacting with the IME.
  bool shouldOfferSwitchingToNextInputMethod(ibinder_.IBinder imeToken) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_shouldOfferSwitchingToNextInputMethod,
          jni.JniType.booleanType,
          [imeToken.reference]).boolean;

  static final _id_setAdditionalInputMethodSubtypes = jniAccessors.getMethodIDOf(
      _classRef,
      "setAdditionalInputMethodSubtypes",
      "(Ljava/lang/String;[Landroid/view/inputmethod/InputMethodSubtype;)V");

  /// from: public void setAdditionalInputMethodSubtypes(java.lang.String imiId, android.view.inputmethod.InputMethodSubtype[] subtypes)
  ///
  /// Set additional input method subtypes. Only a process which shares the same uid with the IME
  /// can add additional input method subtypes to the IME.
  /// Please note that a subtype's status is stored in the system.
  /// For example, enabled subtypes are remembered by the framework even after they are removed
  /// by using this method. If you re-add the same subtypes again,
  /// they will just get enabled. If you want to avoid such conflicts, for instance, you may
  /// want to create a "different" new subtype even with the same locale and mode,
  /// by changing its extra value. The different subtype won't get affected by the stored past
  /// status. (You may want to take a look at InputMethodSubtype\#hashCode() to refer
  /// to the current implementation.)
  ///
  /// NOTE: If the same subtype exists in both the manifest XML file and additional subtypes
  /// specified by {@code subtypes}, those multiple instances are automatically merged into one
  /// instance.
  ///
  ///
  /// CAVEAT: In API Level 23 and prior, the system may do nothing if an empty
  /// InputMethodSubtype is specified in {@code subtypes}, which prevents you from removing
  /// the last one entry of additional subtypes. If your IME statically defines one or more
  /// subtypes in the manifest XML file, you may be able to work around this limitation by
  /// specifying one of those statically defined subtypes in {@code subtypes}.
  ///
  ///@param imiId Id of InputMethodInfo which additional input method subtypes will be added to.
  ///@param subtypes subtypes will be added as additional subtypes of the current input method.
  void setAdditionalInputMethodSubtypes(
          jni.JniString imiId, jni.JniObject subtypes) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAdditionalInputMethodSubtypes,
          jni.JniType.voidType,
          [imiId.reference, subtypes.reference]).check();

  static final _id_getLastInputMethodSubtype = jniAccessors.getMethodIDOf(
      _classRef,
      "getLastInputMethodSubtype",
      "()Landroid/view/inputmethod/InputMethodSubtype;");

  /// from: public android.view.inputmethod.InputMethodSubtype getLastInputMethodSubtype()
  /// The returned object must be deleted after use, by calling the `delete` method.
  inputmethodsubtype_.InputMethodSubtype getLastInputMethodSubtype() =>
      inputmethodsubtype_.InputMethodSubtype.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getLastInputMethodSubtype,
              jni.JniType.objectType, []).object);
}
