// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;

import "../../graphics/RectF.dart" as rectf_;

import "../../graphics/Matrix.dart" as matrix_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.inputmethod.CursorAnchorInfo
///
/// Positional information about the text insertion point and characters in the composition string.
///
/// This class encapsulates locations of the text insertion point and the composition string in
/// the screen coordinates so that IMEs can render their UI components near where the text is
/// actually inserted.
///
class CursorAnchorInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/inputmethod/CursorAnchorInfo");
  CursorAnchorInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.inputmethod.CursorAnchorInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to make this class parcelable.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int FLAG_HAS_INVISIBLE_REGION
  ///
  /// Flag for \#getInsertionMarkerFlags() and \#getCharacterBoundsFlags(int): the
  /// insertion marker or character bounds have at least one invisible (clipped) region.
  static const FLAG_HAS_INVISIBLE_REGION = 2;

  /// from: static public final int FLAG_HAS_VISIBLE_REGION
  ///
  /// Flag for \#getInsertionMarkerFlags() and \#getCharacterBoundsFlags(int): the
  /// insertion marker or character bounds have at least one visible region.
  static const FLAG_HAS_VISIBLE_REGION = 1;

  /// from: static public final int FLAG_IS_RTL
  ///
  /// Flag for \#getInsertionMarkerFlags() and \#getCharacterBoundsFlags(int): the
  /// insertion marker or character bounds is placed at right-to-left (RTL) character.
  static const FLAG_IS_RTL = 4;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CursorAnchorInfo(parcel_.Parcel source)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [source.reference]).object);

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Used to package this object into a Parcel.
  ///@param dest The Parcel to be written.
  ///@param flags The flags used for parceling.
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_getSelectionStart =
      jniAccessors.getMethodIDOf(_classRef, "getSelectionStart", "()I");

  /// from: public int getSelectionStart()
  ///
  /// Returns the index where the selection starts.
  ///@return {@code -1} if there is no selection.
  int getSelectionStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectionStart, jni.JniType.intType, []).integer;

  static final _id_getSelectionEnd =
      jniAccessors.getMethodIDOf(_classRef, "getSelectionEnd", "()I");

  /// from: public int getSelectionEnd()
  ///
  /// Returns the index where the selection ends.
  ///@return {@code -1} if there is no selection.
  int getSelectionEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectionEnd, jni.JniType.intType, []).integer;

  static final _id_getComposingTextStart =
      jniAccessors.getMethodIDOf(_classRef, "getComposingTextStart", "()I");

  /// from: public int getComposingTextStart()
  ///
  /// Returns the index where the composing text starts.
  ///@return {@code -1} if there is no composing text.
  int getComposingTextStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getComposingTextStart, jni.JniType.intType, []).integer;

  static final _id_getComposingText = jniAccessors.getMethodIDOf(
      _classRef, "getComposingText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getComposingText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the entire composing text.
  ///@return {@code null} if there is no composition.
  jni.JniObject getComposingText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getComposingText, jni.JniType.objectType, []).object);

  static final _id_getInsertionMarkerFlags =
      jniAccessors.getMethodIDOf(_classRef, "getInsertionMarkerFlags", "()I");

  /// from: public int getInsertionMarkerFlags()
  ///
  /// Returns the flag of the insertion marker.
  ///@return the flag of the insertion marker. {@code 0} if no flag is specified.
  int getInsertionMarkerFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getInsertionMarkerFlags, jni.JniType.intType, []).integer;

  static final _id_getInsertionMarkerHorizontal = jniAccessors.getMethodIDOf(
      _classRef, "getInsertionMarkerHorizontal", "()F");

  /// from: public float getInsertionMarkerHorizontal()
  ///
  /// Returns the horizontal start of the insertion marker, in the local coordinates that will
  /// be transformed with \#getMatrix() when rendered on the screen.
  ///@return x coordinate that is compatible with Layout\#getPrimaryHorizontal(int).
  /// Pay special care to RTL/LTR handling.
  /// {@code java.lang.Float.NaN} if not specified.
  ///@see Layout\#getPrimaryHorizontal(int)
  double getInsertionMarkerHorizontal() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getInsertionMarkerHorizontal,
      jni.JniType.floatType, []).float;

  static final _id_getInsertionMarkerTop =
      jniAccessors.getMethodIDOf(_classRef, "getInsertionMarkerTop", "()F");

  /// from: public float getInsertionMarkerTop()
  ///
  /// Returns the vertical top position of the insertion marker, in the local coordinates that
  /// will be transformed with \#getMatrix() when rendered on the screen.
  ///@return y coordinate that is compatible with Layout\#getLineTop(int).
  /// {@code java.lang.Float.NaN} if not specified.
  double getInsertionMarkerTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getInsertionMarkerTop, jni.JniType.floatType, []).float;

  static final _id_getInsertionMarkerBaseline = jniAccessors.getMethodIDOf(
      _classRef, "getInsertionMarkerBaseline", "()F");

  /// from: public float getInsertionMarkerBaseline()
  ///
  /// Returns the vertical baseline position of the insertion marker, in the local coordinates
  /// that will be transformed with \#getMatrix() when rendered on the screen.
  ///@return y coordinate that is compatible with Layout\#getLineBaseline(int).
  /// {@code java.lang.Float.NaN} if not specified.
  double getInsertionMarkerBaseline() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getInsertionMarkerBaseline,
      jni.JniType.floatType, []).float;

  static final _id_getInsertionMarkerBottom =
      jniAccessors.getMethodIDOf(_classRef, "getInsertionMarkerBottom", "()F");

  /// from: public float getInsertionMarkerBottom()
  ///
  /// Returns the vertical bottom position of the insertion marker, in the local coordinates
  /// that will be transformed with \#getMatrix() when rendered on the screen.
  ///@return y coordinate that is compatible with Layout\#getLineBottom(int).
  /// {@code java.lang.Float.NaN} if not specified.
  double getInsertionMarkerBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getInsertionMarkerBottom, jni.JniType.floatType, []).float;

  static final _id_getCharacterBounds = jniAccessors.getMethodIDOf(
      _classRef, "getCharacterBounds", "(I)Landroid/graphics/RectF;");

  /// from: public android.graphics.RectF getCharacterBounds(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new instance of RectF that indicates the location of the character
  /// specified with the index.
  ///@param index index of the character in a Java chars.
  ///@return the character bounds in local coordinates as a new instance of RectF.
  rectf_.RectF getCharacterBounds(int index) =>
      rectf_.RectF.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCharacterBounds, jni.JniType.objectType, [index]).object);

  static final _id_getCharacterBoundsFlags =
      jniAccessors.getMethodIDOf(_classRef, "getCharacterBoundsFlags", "(I)I");

  /// from: public int getCharacterBoundsFlags(int index)
  ///
  /// Returns the flags associated with the character bounds specified with the index.
  ///@param index index of the character in a Java chars.
  ///@return {@code 0} if no flag is specified.
  int getCharacterBoundsFlags(int index) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCharacterBoundsFlags,
      jni.JniType.intType,
      [index]).integer;

  static final _id_getMatrix = jniAccessors.getMethodIDOf(
      _classRef, "getMatrix", "()Landroid/graphics/Matrix;");

  /// from: public android.graphics.Matrix getMatrix()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new instance of android.graphics.Matrix that indicates the transformation
  /// matrix that is to be applied other positional data in this class.
  ///@return a new instance (copy) of the transformation matrix.
  matrix_.Matrix getMatrix() =>
      matrix_.Matrix.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMatrix, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;
}

/// from: android.view.inputmethod.CursorAnchorInfo$Builder
///
/// Builder for CursorAnchorInfo. This class is not designed to be thread-safe.
class CursorAnchorInfo_Builder extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/inputmethod/CursorAnchorInfo\$Builder");
  CursorAnchorInfo_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CursorAnchorInfo_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setSelectionRange = jniAccessors.getMethodIDOf(
      _classRef,
      "setSelectionRange",
      "(II)Landroid/view/inputmethod/CursorAnchorInfo\$Builder;");

  /// from: public android.view.inputmethod.CursorAnchorInfo.Builder setSelectionRange(int newStart, int newEnd)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the text range of the selection. Calling this can be skipped if there is no
  /// selection.
  CursorAnchorInfo_Builder setSelectionRange(int newStart, int newEnd) =>
      CursorAnchorInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSelectionRange,
          jni.JniType.objectType,
          [newStart, newEnd]).object);

  static final _id_setComposingText = jniAccessors.getMethodIDOf(
      _classRef,
      "setComposingText",
      "(ILjava/lang/CharSequence;)Landroid/view/inputmethod/CursorAnchorInfo\$Builder;");

  /// from: public android.view.inputmethod.CursorAnchorInfo.Builder setComposingText(int composingTextStart, java.lang.CharSequence composingText)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the text range of the composing text. Calling this can be skipped if there is
  /// no composing text.
  ///@param composingTextStart index where the composing text starts.
  ///@param composingText the entire composing text.
  CursorAnchorInfo_Builder setComposingText(
          int composingTextStart, jni.JniObject composingText) =>
      CursorAnchorInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setComposingText,
          jni.JniType.objectType,
          [composingTextStart, composingText.reference]).object);

  static final _id_setInsertionMarkerLocation = jniAccessors.getMethodIDOf(
      _classRef,
      "setInsertionMarkerLocation",
      "(FFFFI)Landroid/view/inputmethod/CursorAnchorInfo\$Builder;");

  /// from: public android.view.inputmethod.CursorAnchorInfo.Builder setInsertionMarkerLocation(float horizontalPosition, float lineTop, float lineBaseline, float lineBottom, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the location of the text insertion point (zero width cursor) as a rectangle in
  /// local coordinates. Calling this can be skipped when there is no text insertion point;
  /// however if there is an insertion point, editors must call this method.
  ///@param horizontalPosition horizontal position of the insertion marker, in the local
  /// coordinates that will be transformed with the transformation matrix when rendered on the
  /// screen. This should be calculated or compatible with
  /// Layout\#getPrimaryHorizontal(int).
  ///@param lineTop vertical position of the insertion marker, in the local coordinates that
  /// will be transformed with the transformation matrix when rendered on the screen. This
  /// should be calculated or compatible with Layout\#getLineTop(int).
  ///@param lineBaseline vertical position of the insertion marker, in the local coordinates
  /// that will be transformed with the transformation matrix when rendered on the screen. This
  /// should be calculated or compatible with Layout\#getLineBaseline(int).
  ///@param lineBottom vertical position of the insertion marker, in the local coordinates
  /// that will be transformed with the transformation matrix when rendered on the screen. This
  /// should be calculated or compatible with Layout\#getLineBottom(int).
  ///@param flags flags of the insertion marker. See \#FLAG_HAS_VISIBLE_REGION for
  /// example.
  CursorAnchorInfo_Builder setInsertionMarkerLocation(double horizontalPosition,
          double lineTop, double lineBaseline, double lineBottom, int flags) =>
      CursorAnchorInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setInsertionMarkerLocation, jni.JniType.objectType, [
        horizontalPosition,
        lineTop,
        lineBaseline,
        lineBottom,
        flags
      ]).object);

  static final _id_addCharacterBounds = jniAccessors.getMethodIDOf(
      _classRef,
      "addCharacterBounds",
      "(IFFFFI)Landroid/view/inputmethod/CursorAnchorInfo\$Builder;");

  /// from: public android.view.inputmethod.CursorAnchorInfo.Builder addCharacterBounds(int index, float left, float top, float right, float bottom, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds the bounding box of the character specified with the index.
  ///@param index index of the character in Java chars units. Must be specified in
  /// ascending order across successive calls.
  ///@param left x coordinate of the left edge of the character in local coordinates.
  ///@param top y coordinate of the top edge of the character in local coordinates.
  ///@param right x coordinate of the right edge of the character in local coordinates.
  ///@param bottom y coordinate of the bottom edge of the character in local coordinates.
  ///@param flags flags for this character bounds. See \#FLAG_HAS_VISIBLE_REGION,
  /// \#FLAG_HAS_INVISIBLE_REGION and \#FLAG_IS_RTL. These flags must be
  /// specified when necessary.
  ///@throws IllegalArgumentException If the index is a negative value, or not greater than
  /// all of the previously called indices.
  CursorAnchorInfo_Builder addCharacterBounds(int index, double left,
          double top, double right, double bottom, int flags) =>
      CursorAnchorInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addCharacterBounds,
          jni.JniType.objectType,
          [index, left, top, right, bottom, flags]).object);

  static final _id_setMatrix = jniAccessors.getMethodIDOf(
      _classRef,
      "setMatrix",
      "(Landroid/graphics/Matrix;)Landroid/view/inputmethod/CursorAnchorInfo\$Builder;");

  /// from: public android.view.inputmethod.CursorAnchorInfo.Builder setMatrix(android.graphics.Matrix matrix)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the matrix that transforms local coordinates into screen coordinates.
  ///@param matrix transformation matrix from local coordinates into screen coordinates. null
  /// is interpreted as an identity matrix.
  CursorAnchorInfo_Builder setMatrix(matrix_.Matrix matrix) =>
      CursorAnchorInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setMatrix,
          jni.JniType.objectType,
          [matrix.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/view/inputmethod/CursorAnchorInfo;");

  /// from: public android.view.inputmethod.CursorAnchorInfo build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return CursorAnchorInfo using parameters in this Builder.
  ///@throws IllegalArgumentException if one or more positional parameters are specified but
  /// the coordinate transformation matrix is not provided via \#setMatrix(Matrix).
  CursorAnchorInfo build() =>
      CursorAnchorInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Resets the internal state so that this instance can be reused to build another
  /// instance of CursorAnchorInfo.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();
}
