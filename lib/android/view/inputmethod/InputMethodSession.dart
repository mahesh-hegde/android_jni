// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../graphics/Rect.dart" as rect_;

import "ExtractedText.dart" as extractedtext_;

import "../KeyEvent.dart" as keyevent_;

import "../MotionEvent.dart" as motionevent_;

import "../../os/Bundle.dart" as bundle_;

import "CursorAnchorInfo.dart" as cursoranchorinfo_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.inputmethod.InputMethodSession
///
/// The InputMethodSession interface provides the per-client functionality
/// of InputMethod that is safe to expose to applications.
///
/// Applications will not normally use this interface themselves, instead
/// relying on the standard interaction provided by
/// android.widget.TextView and android.widget.EditText.
class InputMethodSession extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/inputmethod/InputMethodSession");
  InputMethodSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_finishInput =
      jniAccessors.getMethodIDOf(_classRef, "finishInput", "()V");

  /// from: public abstract void finishInput()
  ///
  /// This method is called when the application would like to stop
  /// receiving text input.
  void finishInput() => jniAccessors.callMethodWithArgs(
      reference, _id_finishInput, jni.JniType.voidType, []).check();

  static final _id_updateSelection =
      jniAccessors.getMethodIDOf(_classRef, "updateSelection", "(IIIIII)V");

  /// from: public abstract void updateSelection(int oldSelStart, int oldSelEnd, int newSelStart, int newSelEnd, int candidatesStart, int candidatesEnd)
  ///
  /// This method is called when the selection or cursor in the current
  /// target input field has changed.
  ///@param oldSelStart The previous text offset of the cursor selection
  /// start position.
  ///@param oldSelEnd The previous text offset of the cursor selection
  /// end position.
  ///@param newSelStart The new text offset of the cursor selection
  /// start position.
  ///@param newSelEnd The new text offset of the cursor selection
  /// end position.
  ///@param candidatesStart The text offset of the current candidate
  /// text start position.
  ///@param candidatesEnd The text offset of the current candidate
  /// text end position.
  void updateSelection(int oldSelStart, int oldSelEnd, int newSelStart,
          int newSelEnd, int candidatesStart, int candidatesEnd) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_updateSelection, jni.JniType.voidType, [
        oldSelStart,
        oldSelEnd,
        newSelStart,
        newSelEnd,
        candidatesStart,
        candidatesEnd
      ]).check();

  static final _id_viewClicked =
      jniAccessors.getMethodIDOf(_classRef, "viewClicked", "(Z)V");

  /// from: public abstract void viewClicked(boolean focusChanged)
  ///
  /// This method is called when the user tapped a text view.
  /// IMEs can't rely on this method being called because this was not part of the original IME
  /// protocol, so applications with custom text editing written before this method appeared will
  /// not call to inform the IME of this interaction.
  ///@param focusChanged true if the user changed the focused view by this click.
  void viewClicked(bool focusChanged) => jniAccessors.callMethodWithArgs(
      reference, _id_viewClicked, jni.JniType.voidType, [focusChanged]).check();

  static final _id_updateCursor = jniAccessors.getMethodIDOf(
      _classRef, "updateCursor", "(Landroid/graphics/Rect;)V");

  /// from: public abstract void updateCursor(android.graphics.Rect newCursor)
  ///
  /// This method is called when cursor location of the target input field
  /// has changed within its window.  This is not normally called, but will
  /// only be reported if requested by the input method.
  ///@param newCursor The rectangle of the cursor currently being shown in
  /// the input field's window coordinates.
  void updateCursor(rect_.Rect newCursor) => jniAccessors.callMethodWithArgs(
      reference,
      _id_updateCursor,
      jni.JniType.voidType,
      [newCursor.reference]).check();

  static final _id_displayCompletions = jniAccessors.getMethodIDOf(_classRef,
      "displayCompletions", "([Landroid/view/inputmethod/CompletionInfo;)V");

  /// from: public abstract void displayCompletions(android.view.inputmethod.CompletionInfo[] completions)
  ///
  /// Called by a text editor that performs auto completion, to tell the
  /// input method about the completions it has available.  This can be used
  /// by the input method to display them to the user to select the text to
  /// be inserted.
  ///@param completions Array of text completions that are available, starting with
  /// the best.  If this array is null, any existing completions will be
  /// removed.
  void displayCompletions(jni.JniObject completions) =>
      jniAccessors.callMethodWithArgs(reference, _id_displayCompletions,
          jni.JniType.voidType, [completions.reference]).check();

  static final _id_updateExtractedText = jniAccessors.getMethodIDOf(_classRef,
      "updateExtractedText", "(ILandroid/view/inputmethod/ExtractedText;)V");

  /// from: public abstract void updateExtractedText(int token, android.view.inputmethod.ExtractedText text)
  ///
  /// Called by a text editor to report its new extracted text when its
  /// contents change.  This will only be called if the input method
  /// calls InputConnection\#getExtractedText(ExtractedTextRequest, int) InputConnection.getExtractedText() with the option to report updates.
  ///@param token The input method supplied token for identifying its request.
  ///@param text The new extracted text.
  void updateExtractedText(int token, extractedtext_.ExtractedText text) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateExtractedText,
          jni.JniType.voidType, [token, text.reference]).check();

  static final _id_dispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchKeyEvent",
      "(ILandroid/view/KeyEvent;Landroid/view/inputmethod/InputMethodSession\$EventCallback;)V");

  /// from: public abstract void dispatchKeyEvent(int seq, android.view.KeyEvent event, android.view.inputmethod.InputMethodSession.EventCallback callback)
  ///
  /// This method is called when a key is pressed.  When done with the event,
  /// the implementation must call back on <var>callback</var> with its
  /// result.
  ///
  ///
  /// If the input method wants to handle this event, return true, otherwise
  /// return false and the caller (i.e. the application) will handle the event.
  ///@param event The key event.
  ///@return Whether the input method wants to handle this event.
  ///@see \#dispatchKeyUp
  ///@see android.view.KeyEvent
  void dispatchKeyEvent(int seq, keyevent_.KeyEvent event,
          InputMethodSession_EventCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchKeyEvent,
          jni.JniType.voidType,
          [seq, event.reference, callback.reference]).check();

  static final _id_dispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchTrackballEvent",
      "(ILandroid/view/MotionEvent;Landroid/view/inputmethod/InputMethodSession\$EventCallback;)V");

  /// from: public abstract void dispatchTrackballEvent(int seq, android.view.MotionEvent event, android.view.inputmethod.InputMethodSession.EventCallback callback)
  ///
  /// This method is called when there is a track ball event.
  ///
  ///
  /// If the input method wants to handle this event, return true, otherwise
  /// return false and the caller (i.e. the application) will handle the event.
  ///@param event The motion event.
  ///@return Whether the input method wants to handle this event.
  ///@see android.view.MotionEvent
  void dispatchTrackballEvent(int seq, motionevent_.MotionEvent event,
          InputMethodSession_EventCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchTrackballEvent,
          jni.JniType.voidType,
          [seq, event.reference, callback.reference]).check();

  static final _id_dispatchGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchGenericMotionEvent",
      "(ILandroid/view/MotionEvent;Landroid/view/inputmethod/InputMethodSession\$EventCallback;)V");

  /// from: public abstract void dispatchGenericMotionEvent(int seq, android.view.MotionEvent event, android.view.inputmethod.InputMethodSession.EventCallback callback)
  ///
  /// This method is called when there is a generic motion event.
  ///
  ///
  /// If the input method wants to handle this event, return true, otherwise
  /// return false and the caller (i.e. the application) will handle the event.
  ///@param event The motion event.
  ///@return Whether the input method wants to handle this event.
  ///@see android.view.MotionEvent
  void dispatchGenericMotionEvent(int seq, motionevent_.MotionEvent event,
          InputMethodSession_EventCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchGenericMotionEvent,
          jni.JniType.voidType,
          [seq, event.reference, callback.reference]).check();

  static final _id_appPrivateCommand = jniAccessors.getMethodIDOf(_classRef,
      "appPrivateCommand", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public abstract void appPrivateCommand(java.lang.String action, android.os.Bundle data)
  ///
  /// Process a private command sent from the application to the input method.
  /// This can be used to provide domain-specific features that are
  /// only known between certain input methods and their clients.
  ///@param action Name of the command to be performed.  This _must_
  /// be a scoped name, i.e. prefixed with a package name you own, so that
  /// different developers will not create conflicting commands.
  ///@param data Any data to include with the command.
  void appPrivateCommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_appPrivateCommand,
          jni.JniType.voidType, [action.reference, data.reference]).check();

  static final _id_toggleSoftInput =
      jniAccessors.getMethodIDOf(_classRef, "toggleSoftInput", "(II)V");

  /// from: public abstract void toggleSoftInput(int showFlags, int hideFlags)
  ///
  /// Toggle the soft input window.
  /// Applications can toggle the state of the soft input window.
  ///@param showFlags Provides additional operating flags.  May be
  /// 0 or have the InputMethodManager\#SHOW_IMPLICIT,
  /// InputMethodManager\#SHOW_FORCED bit set.
  ///@param hideFlags Provides additional operating flags.  May be
  /// 0 or have the InputMethodManager\#HIDE_IMPLICIT_ONLY,
  /// InputMethodManager\#HIDE_NOT_ALWAYS bit set.
  void toggleSoftInput(int showFlags, int hideFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_toggleSoftInput,
          jni.JniType.voidType, [showFlags, hideFlags]).check();

  static final _id_updateCursorAnchorInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "updateCursorAnchorInfo",
      "(Landroid/view/inputmethod/CursorAnchorInfo;)V");

  /// from: public abstract void updateCursorAnchorInfo(android.view.inputmethod.CursorAnchorInfo cursorAnchorInfo)
  ///
  /// This method is called when the cursor and/or the character position relevant to text input
  /// is changed on the screen.  This is not called by default.  It will only be reported if
  /// requested by the input method.
  ///@param cursorAnchorInfo Positional information relevant to text input, such as text
  /// insertion point and composition string.
  void updateCursorAnchorInfo(
          cursoranchorinfo_.CursorAnchorInfo cursorAnchorInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateCursorAnchorInfo,
          jni.JniType.voidType, [cursorAnchorInfo.reference]).check();
}

/// from: android.view.inputmethod.InputMethodSession$EventCallback
class InputMethodSession_EventCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/inputmethod/InputMethodSession\$EventCallback");
  InputMethodSession_EventCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_finishedEvent =
      jniAccessors.getMethodIDOf(_classRef, "finishedEvent", "(IZ)V");

  /// from: public abstract void finishedEvent(int seq, boolean handled)
  void finishedEvent(int seq, bool handled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_finishedEvent,
      jni.JniType.voidType,
      [seq, handled]).check();
}
