// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../View.dart" as view_;

import "../../text/Spannable.dart" as spannable_;

import "../../text/Editable.dart" as editable_;

import "CompletionInfo.dart" as completioninfo_;

import "CorrectionInfo.dart" as correctioninfo_;

import "ExtractedText.dart" as extractedtext_;

import "ExtractedTextRequest.dart" as extractedtextrequest_;

import "../../os/Bundle.dart" as bundle_;

import "../../os/Handler.dart" as handler_;

import "../KeyEvent.dart" as keyevent_;

import "InputContentInfo.dart" as inputcontentinfo_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.inputmethod.BaseInputConnection
///
/// Base class for implementors of the InputConnection interface, taking care
/// of most of the common behavior for providing a connection to an Editable.
/// Implementors of this class will want to be sure to implement
/// \#getEditable to provide access to their own editable object, and
/// to refer to the documentation in InputConnection.
class BaseInputConnection extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/inputmethod/BaseInputConnection");
  BaseInputConnection.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/View;Z)V");

  /// from: public void <init>(android.view.View targetView, boolean fullEditor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  BaseInputConnection(view_.View targetView, bool fullEditor)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [targetView.reference, fullEditor]).object);

  static final _id_removeComposingSpans = jniAccessors.getStaticMethodIDOf(
      _classRef, "removeComposingSpans", "(Landroid/text/Spannable;)V");

  /// from: static public final void removeComposingSpans(android.text.Spannable text)
  static void removeComposingSpans(spannable_.Spannable text) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_removeComposingSpans,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_setComposingSpans = jniAccessors.getStaticMethodIDOf(
      _classRef, "setComposingSpans", "(Landroid/text/Spannable;)V");

  /// from: static public void setComposingSpans(android.text.Spannable text)
  static void setComposingSpans(spannable_.Spannable text) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_setComposingSpans,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_getComposingSpanStart = jniAccessors.getStaticMethodIDOf(
      _classRef, "getComposingSpanStart", "(Landroid/text/Spannable;)I");

  /// from: static public int getComposingSpanStart(android.text.Spannable text)
  static int getComposingSpanStart(spannable_.Spannable text) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getComposingSpanStart,
          jni.JniType.intType,
          [text.reference]).integer;

  static final _id_getComposingSpanEnd = jniAccessors.getStaticMethodIDOf(
      _classRef, "getComposingSpanEnd", "(Landroid/text/Spannable;)I");

  /// from: static public int getComposingSpanEnd(android.text.Spannable text)
  static int getComposingSpanEnd(spannable_.Spannable text) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getComposingSpanEnd,
          jni.JniType.intType, [text.reference]).integer;

  static final _id_getEditable = jniAccessors.getMethodIDOf(
      _classRef, "getEditable", "()Landroid/text/Editable;");

  /// from: public android.text.Editable getEditable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the target of edit operations.  The default implementation
  /// returns its own fake editable that is just used for composing text;
  /// subclasses that are real text editors should override this and
  /// supply their own.
  editable_.Editable getEditable() =>
      editable_.Editable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getEditable, jni.JniType.objectType, []).object);

  static final _id_beginBatchEdit =
      jniAccessors.getMethodIDOf(_classRef, "beginBatchEdit", "()Z");

  /// from: public boolean beginBatchEdit()
  ///
  /// Default implementation does nothing.
  bool beginBatchEdit() => jniAccessors.callMethodWithArgs(
      reference, _id_beginBatchEdit, jni.JniType.booleanType, []).boolean;

  static final _id_endBatchEdit =
      jniAccessors.getMethodIDOf(_classRef, "endBatchEdit", "()Z");

  /// from: public boolean endBatchEdit()
  ///
  /// Default implementation does nothing.
  bool endBatchEdit() => jniAccessors.callMethodWithArgs(
      reference, _id_endBatchEdit, jni.JniType.booleanType, []).boolean;

  static final _id_closeConnection =
      jniAccessors.getMethodIDOf(_classRef, "closeConnection", "()V");

  /// from: public void closeConnection()
  ///
  /// Default implementation calls \#finishComposingText().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void closeConnection() => jniAccessors.callMethodWithArgs(
      reference, _id_closeConnection, jni.JniType.voidType, []).check();

  static final _id_clearMetaKeyStates =
      jniAccessors.getMethodIDOf(_classRef, "clearMetaKeyStates", "(I)Z");

  /// from: public boolean clearMetaKeyStates(int states)
  ///
  /// Default implementation uses
  /// MetaKeyKeyListener\#clearMetaKeyState(long, int) MetaKeyKeyListener.clearMetaKeyState(long, int) to clear the state.
  bool clearMetaKeyStates(int states) => jniAccessors.callMethodWithArgs(
      reference,
      _id_clearMetaKeyStates,
      jni.JniType.booleanType,
      [states]).boolean;

  static final _id_commitCompletion = jniAccessors.getMethodIDOf(_classRef,
      "commitCompletion", "(Landroid/view/inputmethod/CompletionInfo;)Z");

  /// from: public boolean commitCompletion(android.view.inputmethod.CompletionInfo text)
  ///
  /// Default implementation does nothing and returns false.
  bool commitCompletion(completioninfo_.CompletionInfo text) =>
      jniAccessors.callMethodWithArgs(reference, _id_commitCompletion,
          jni.JniType.booleanType, [text.reference]).boolean;

  static final _id_commitCorrection = jniAccessors.getMethodIDOf(_classRef,
      "commitCorrection", "(Landroid/view/inputmethod/CorrectionInfo;)Z");

  /// from: public boolean commitCorrection(android.view.inputmethod.CorrectionInfo correctionInfo)
  ///
  /// Default implementation does nothing and returns false.
  bool commitCorrection(correctioninfo_.CorrectionInfo correctionInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_commitCorrection,
          jni.JniType.booleanType, [correctionInfo.reference]).boolean;

  static final _id_commitText = jniAccessors.getMethodIDOf(
      _classRef, "commitText", "(Ljava/lang/CharSequence;I)Z");

  /// from: public boolean commitText(java.lang.CharSequence text, int newCursorPosition)
  ///
  /// Default implementation replaces any existing composing text with
  /// the given text.  In addition, only if dummy mode, a key event is
  /// sent for the new text and the current editable buffer cleared.
  bool commitText(jni.JniObject text, int newCursorPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_commitText,
          jni.JniType.booleanType, [text.reference, newCursorPosition]).boolean;

  static final _id_deleteSurroundingText =
      jniAccessors.getMethodIDOf(_classRef, "deleteSurroundingText", "(II)Z");

  /// from: public boolean deleteSurroundingText(int beforeLength, int afterLength)
  ///
  /// The default implementation performs the deletion around the current selection position of the
  /// editable text.
  ///@param beforeLength The number of characters before the cursor to be deleted, in code unit.
  ///        If this is greater than the number of existing characters between the beginning of the
  ///        text and the cursor, then this method does not fail but deletes all the characters in
  ///        that range.
  ///@param afterLength The number of characters after the cursor to be deleted, in code unit.
  ///        If this is greater than the number of existing characters between the cursor and
  ///        the end of the text, then this method does not fail but deletes all the characters in
  ///        that range.
  bool deleteSurroundingText(int beforeLength, int afterLength) =>
      jniAccessors.callMethodWithArgs(reference, _id_deleteSurroundingText,
          jni.JniType.booleanType, [beforeLength, afterLength]).boolean;

  static final _id_deleteSurroundingTextInCodePoints = jniAccessors
      .getMethodIDOf(_classRef, "deleteSurroundingTextInCodePoints", "(II)Z");

  /// from: public boolean deleteSurroundingTextInCodePoints(int beforeLength, int afterLength)
  ///
  /// The default implementation performs the deletion around the current selection position of the
  /// editable text.
  ///@param beforeLength The number of characters before the cursor to be deleted, in code points.
  ///        If this is greater than the number of existing characters between the beginning of the
  ///        text and the cursor, then this method does not fail but deletes all the characters in
  ///        that range.
  ///@param afterLength The number of characters after the cursor to be deleted, in code points.
  ///        If this is greater than the number of existing characters between the cursor and
  ///        the end of the text, then this method does not fail but deletes all the characters in
  ///        that range.
  bool deleteSurroundingTextInCodePoints(int beforeLength, int afterLength) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_deleteSurroundingTextInCodePoints,
          jni.JniType.booleanType,
          [beforeLength, afterLength]).boolean;

  static final _id_finishComposingText =
      jniAccessors.getMethodIDOf(_classRef, "finishComposingText", "()Z");

  /// from: public boolean finishComposingText()
  ///
  /// The default implementation removes the composing state from the
  /// current editable text.  In addition, only if dummy mode, a key event is
  /// sent for the new text and the current editable buffer cleared.
  bool finishComposingText() => jniAccessors.callMethodWithArgs(
      reference, _id_finishComposingText, jni.JniType.booleanType, []).boolean;

  static final _id_getCursorCapsMode =
      jniAccessors.getMethodIDOf(_classRef, "getCursorCapsMode", "(I)I");

  /// from: public int getCursorCapsMode(int reqModes)
  ///
  /// The default implementation uses TextUtils.getCapsMode to get the
  /// cursor caps mode for the current selection position in the editable
  /// text, unless in dummy mode in which case 0 is always returned.
  int getCursorCapsMode(int reqModes) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCursorCapsMode,
      jni.JniType.intType,
      [reqModes]).integer;

  static final _id_getExtractedText = jniAccessors.getMethodIDOf(
      _classRef,
      "getExtractedText",
      "(Landroid/view/inputmethod/ExtractedTextRequest;I)Landroid/view/inputmethod/ExtractedText;");

  /// from: public android.view.inputmethod.ExtractedText getExtractedText(android.view.inputmethod.ExtractedTextRequest request, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default implementation always returns null.
  extractedtext_.ExtractedText getExtractedText(
          extractedtextrequest_.ExtractedTextRequest request, int flags) =>
      extractedtext_.ExtractedText.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getExtractedText,
          jni.JniType.objectType,
          [request.reference, flags]).object);

  static final _id_getTextBeforeCursor = jniAccessors.getMethodIDOf(
      _classRef, "getTextBeforeCursor", "(II)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTextBeforeCursor(int length, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default implementation returns the given amount of text from the
  /// current cursor position in the buffer.
  jni.JniObject getTextBeforeCursor(int length, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextBeforeCursor,
          jni.JniType.objectType,
          [length, flags]).object);

  static final _id_getSelectedText = jniAccessors.getMethodIDOf(
      _classRef, "getSelectedText", "(I)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getSelectedText(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default implementation returns the text currently selected, or null if none is
  /// selected.
  jni.JniObject getSelectedText(int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSelectedText, jni.JniType.objectType, [flags]).object);

  static final _id_getTextAfterCursor = jniAccessors.getMethodIDOf(
      _classRef, "getTextAfterCursor", "(II)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTextAfterCursor(int length, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default implementation returns the given amount of text from the
  /// current cursor position in the buffer.
  jni.JniObject getTextAfterCursor(int length, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextAfterCursor,
          jni.JniType.objectType,
          [length, flags]).object);

  static final _id_performEditorAction =
      jniAccessors.getMethodIDOf(_classRef, "performEditorAction", "(I)Z");

  /// from: public boolean performEditorAction(int actionCode)
  ///
  /// The default implementation turns this into the enter key.
  bool performEditorAction(int actionCode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_performEditorAction,
      jni.JniType.booleanType,
      [actionCode]).boolean;

  static final _id_performContextMenuAction =
      jniAccessors.getMethodIDOf(_classRef, "performContextMenuAction", "(I)Z");

  /// from: public boolean performContextMenuAction(int id)
  ///
  /// The default implementation does nothing.
  bool performContextMenuAction(int id) => jniAccessors.callMethodWithArgs(
      reference,
      _id_performContextMenuAction,
      jni.JniType.booleanType,
      [id]).boolean;

  static final _id_performPrivateCommand = jniAccessors.getMethodIDOf(_classRef,
      "performPrivateCommand", "(Ljava/lang/String;Landroid/os/Bundle;)Z");

  /// from: public boolean performPrivateCommand(java.lang.String action, android.os.Bundle data)
  ///
  /// The default implementation does nothing.
  bool performPrivateCommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_performPrivateCommand,
          jni.JniType.booleanType, [action.reference, data.reference]).boolean;

  static final _id_requestCursorUpdates =
      jniAccessors.getMethodIDOf(_classRef, "requestCursorUpdates", "(I)Z");

  /// from: public boolean requestCursorUpdates(int cursorUpdateMode)
  ///
  /// The default implementation does nothing.
  bool requestCursorUpdates(int cursorUpdateMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestCursorUpdates,
          jni.JniType.booleanType, [cursorUpdateMode]).boolean;

  static final _id_getHandler = jniAccessors.getMethodIDOf(
      _classRef, "getHandler", "()Landroid/os/Handler;");

  /// from: public android.os.Handler getHandler()
  /// The returned object must be deleted after use, by calling the `delete` method.
  handler_.Handler getHandler() =>
      handler_.Handler.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHandler, jni.JniType.objectType, []).object);

  static final _id_setComposingText = jniAccessors.getMethodIDOf(
      _classRef, "setComposingText", "(Ljava/lang/CharSequence;I)Z");

  /// from: public boolean setComposingText(java.lang.CharSequence text, int newCursorPosition)
  ///
  /// The default implementation places the given text into the editable,
  /// replacing any existing composing text.  The new text is marked as
  /// in a composing state with the composing style.
  bool setComposingText(jni.JniObject text, int newCursorPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setComposingText,
          jni.JniType.booleanType, [text.reference, newCursorPosition]).boolean;

  static final _id_setComposingRegion =
      jniAccessors.getMethodIDOf(_classRef, "setComposingRegion", "(II)Z");

  /// from: public boolean setComposingRegion(int start, int end)
  bool setComposingRegion(int start, int end) =>
      jniAccessors.callMethodWithArgs(reference, _id_setComposingRegion,
          jni.JniType.booleanType, [start, end]).boolean;

  static final _id_setSelection =
      jniAccessors.getMethodIDOf(_classRef, "setSelection", "(II)Z");

  /// from: public boolean setSelection(int start, int end)
  ///
  /// The default implementation changes the selection position in the
  /// current editable text.
  bool setSelection(int start, int end) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSelection,
      jni.JniType.booleanType,
      [start, end]).boolean;

  static final _id_sendKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "sendKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean sendKeyEvent(android.view.KeyEvent event)
  ///
  /// Provides standard implementation for sending a key event to the window
  /// attached to the input connection's view.
  bool sendKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_reportFullscreenMode =
      jniAccessors.getMethodIDOf(_classRef, "reportFullscreenMode", "(Z)Z");

  /// from: public boolean reportFullscreenMode(boolean enabled)
  ///
  /// Updates InputMethodManager with the current fullscreen mode.
  bool reportFullscreenMode(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_reportFullscreenMode,
      jni.JniType.booleanType,
      [enabled]).boolean;

  static final _id_commitContent = jniAccessors.getMethodIDOf(
      _classRef,
      "commitContent",
      "(Landroid/view/inputmethod/InputContentInfo;ILandroid/os/Bundle;)Z");

  /// from: public boolean commitContent(android.view.inputmethod.InputContentInfo inputContentInfo, int flags, android.os.Bundle opts)
  ///
  /// The default implementation does nothing.
  bool commitContent(inputcontentinfo_.InputContentInfo inputContentInfo,
          int flags, bundle_.Bundle opts) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_commitContent,
          jni.JniType.booleanType,
          [inputContentInfo.reference, flags, opts.reference]).boolean;
}
