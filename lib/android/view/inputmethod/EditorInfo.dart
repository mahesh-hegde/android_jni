// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Bundle.dart" as bundle_;

import "../../os/LocaleList.dart" as localelist_;

import "../../util/Printer.dart" as printer_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.inputmethod.EditorInfo
///
/// An EditorInfo describes several attributes of a text editing object
/// that an input method is communicating with (typically an EditText), most
/// importantly the type of text content it contains and the current cursor position.
class EditorInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/inputmethod/EditorInfo");
  EditorInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.inputmethod.EditorInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to make this class parcelable.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int IME_ACTION_DONE
  ///
  /// Bits of \#IME_MASK_ACTION: the action key performs a "done"
  /// operation, typically meaning there is nothing more to input and the
  /// IME will be closed.
  static const IME_ACTION_DONE = 6;

  /// from: static public final int IME_ACTION_GO
  ///
  /// Bits of \#IME_MASK_ACTION: the action key performs a "go"
  /// operation to take the user to the target of the text they typed.
  /// Typically used, for example, when entering a URL.
  static const IME_ACTION_GO = 2;

  /// from: static public final int IME_ACTION_NEXT
  ///
  /// Bits of \#IME_MASK_ACTION: the action key performs a "next"
  /// operation, taking the user to the next field that will accept text.
  static const IME_ACTION_NEXT = 5;

  /// from: static public final int IME_ACTION_NONE
  ///
  /// Bits of \#IME_MASK_ACTION: there is no available action.
  static const IME_ACTION_NONE = 1;

  /// from: static public final int IME_ACTION_PREVIOUS
  ///
  /// Bits of \#IME_MASK_ACTION: like \#IME_ACTION_NEXT, but
  /// for moving to the previous field.  This will normally not be used to
  /// specify an action (since it precludes \#IME_ACTION_NEXT), but
  /// can be returned to the app if it sets \#IME_FLAG_NAVIGATE_PREVIOUS.
  static const IME_ACTION_PREVIOUS = 7;

  /// from: static public final int IME_ACTION_SEARCH
  ///
  /// Bits of \#IME_MASK_ACTION: the action key performs a "search"
  /// operation, taking the user to the results of searching for the text
  /// they have typed (in whatever context is appropriate).
  static const IME_ACTION_SEARCH = 3;

  /// from: static public final int IME_ACTION_SEND
  ///
  /// Bits of \#IME_MASK_ACTION: the action key performs a "send"
  /// operation, delivering the text to its target.  This is typically used
  /// when composing a message in IM or SMS where sending is immediate.
  static const IME_ACTION_SEND = 4;

  /// from: static public final int IME_ACTION_UNSPECIFIED
  ///
  /// Bits of \#IME_MASK_ACTION: no specific action has been
  /// associated with this editor, let the editor come up with its own if
  /// it can.
  static const IME_ACTION_UNSPECIFIED = 0;

  /// from: static public final int IME_FLAG_FORCE_ASCII
  ///
  /// Flag of \#imeOptions: used to request an IME that is capable of
  /// inputting ASCII characters.  The intention of this flag is to ensure that
  /// the user can type Roman alphabet characters in a android.widget.TextView.
  /// It is typically used for an account ID or password input. A lot of the time,
  /// IMEs are already able to input ASCII even without being told so (such IMEs
  /// already respect this flag in a sense), but there are cases when this is not
  /// the default. For instance, users of languages using a different script like
  /// Arabic, Greek, Hebrew or Russian typically have a keyboard that can't
  /// input ASCII characters by default. Applications need to be
  /// aware that the flag is not a guarantee, and some IMEs may not respect it.
  /// However, it is strongly recommended for IME authors to respect this flag
  /// especially when their IME could end up with a state where only languages
  /// using non-ASCII are enabled.
  static const IME_FLAG_FORCE_ASCII = -2147483648;

  /// from: static public final int IME_FLAG_NAVIGATE_NEXT
  ///
  /// Flag of \#imeOptions: used to specify that there is something
  /// interesting that a forward navigation can focus on. This is like using
  /// \#IME_ACTION_NEXT, except allows the IME to be multiline (with
  /// an enter key) as well as provide forward navigation.  Note that some
  /// IMEs may not be able to do this, especially when running on a small
  /// screen where there is little space.  In that case it does not need to
  /// present a UI for this option.  Like \#IME_ACTION_NEXT, if the
  /// user selects the IME's facility to forward navigate, this will show up
  /// in the application at InputConnection\#performEditorAction(int) InputConnection.performEditorAction(int).
  static const IME_FLAG_NAVIGATE_NEXT = 134217728;

  /// from: static public final int IME_FLAG_NAVIGATE_PREVIOUS
  ///
  /// Flag of \#imeOptions: like \#IME_FLAG_NAVIGATE_NEXT, but
  /// specifies there is something interesting that a backward navigation
  /// can focus on.  If the user selects the IME's facility to backward
  /// navigate, this will show up in the application as an \#IME_ACTION_PREVIOUS
  /// at InputConnection\#performEditorAction(int) InputConnection.performEditorAction(int).
  static const IME_FLAG_NAVIGATE_PREVIOUS = 67108864;

  /// from: static public final int IME_FLAG_NO_ACCESSORY_ACTION
  ///
  /// Flag of \#imeOptions: used in conjunction with one of the actions
  /// masked by \#IME_MASK_ACTION, this indicates that the action
  /// should not be available as an accessory button on the right of the extracted
  /// text when the input method is full-screen. Note that by setting this flag,
  /// there can be cases where the action is simply never available to the
  /// user. Setting this generally means that you think that in fullscreen mode,
  /// where there is little space to show the text, it's not worth taking some
  /// screen real estate to display the action and it should be used instead
  /// to show more text.
  static const IME_FLAG_NO_ACCESSORY_ACTION = 536870912;

  /// from: static public final int IME_FLAG_NO_ENTER_ACTION
  ///
  /// Flag of \#imeOptions: used in conjunction with one of the actions
  /// masked by \#IME_MASK_ACTION. If this flag is not set, IMEs will
  /// normally replace the "enter" key with the action supplied. This flag
  /// indicates that the action should not be available in-line as a replacement
  /// for the "enter" key. Typically this is because the action has such a
  /// significant impact or is not recoverable enough that accidentally hitting
  /// it should be avoided, such as sending a message. Note that
  /// android.widget.TextView will automatically set this flag for you
  /// on multi-line text views.
  static const IME_FLAG_NO_ENTER_ACTION = 1073741824;

  /// from: static public final int IME_FLAG_NO_EXTRACT_UI
  ///
  /// Flag of \#imeOptions: used to specify that the IME does not need
  /// to show its extracted text UI.  For input methods that may be fullscreen,
  /// often when in landscape mode, this allows them to be smaller and let part
  /// of the application be shown behind, through transparent UI parts in the
  /// fullscreen IME. The part of the UI visible to the user may not be responsive
  /// to touch because the IME will receive touch events, which may confuse the
  /// user; use \#IME_FLAG_NO_FULLSCREEN instead for a better experience.
  /// Using this flag is discouraged and it may become deprecated in the future.
  /// Its meaning is unclear in some situations and it may not work appropriately
  /// on older versions of the platform.
  static const IME_FLAG_NO_EXTRACT_UI = 268435456;

  /// from: static public final int IME_FLAG_NO_FULLSCREEN
  ///
  /// Flag of \#imeOptions: used to request that the IME never go
  /// into fullscreen mode.
  /// By default, IMEs may go into full screen mode when they think
  /// it's appropriate, for example on small screens in landscape
  /// orientation where displaying a software keyboard may occlude
  /// such a large portion of the screen that the remaining part is
  /// too small to meaningfully display the application UI.
  /// If this flag is set, compliant IMEs will never go into full screen mode,
  /// and always leave some space to display the application UI.
  /// Applications need to be aware that the flag is not a guarantee, and
  /// some IMEs may ignore it.
  static const IME_FLAG_NO_FULLSCREEN = 33554432;

  /// from: static public final int IME_FLAG_NO_PERSONALIZED_LEARNING
  ///
  /// Flag of \#imeOptions: used to request that the IME should not update any personalized
  /// data such as typing history and personalized language model based on what the user typed on
  /// this text editing object.  Typical use cases are:
  /// <ul>
  ///     <li>When the application is in a special mode, where user's activities are expected to be
  ///     not recorded in the application's history.  Some web browsers and chat applications may
  ///     have this kind of modes.</li>
  ///     <li>When storing typing history does not make much sense.  Specifying this flag in typing
  ///     games may help to avoid typing history from being filled up with words that the user is
  ///     less likely to type in their daily life.  Another example is that when the application
  ///     already knows that the expected input is not a valid word (e.g. a promotion code that is
  ///     not a valid word in any natural language).</li>
  /// </ul>
  ///
  /// Applications need to be aware that the flag is not a guarantee, and some IMEs may not
  /// respect it.
  ///
  static const IME_FLAG_NO_PERSONALIZED_LEARNING = 16777216;

  /// from: static public final int IME_MASK_ACTION
  ///
  /// Set of bits in \#imeOptions that provide alternative actions
  /// associated with the "enter" key.  This both helps the IME provide
  /// better feedback about what the enter key will do, and also allows it
  /// to provide alternative mechanisms for providing that command.
  static const IME_MASK_ACTION = 255;

  /// from: static public final int IME_NULL
  ///
  /// Generic unspecified type for \#imeOptions.
  static const IME_NULL = 0;

  static final _id_actionId =
      jniAccessors.getFieldIDOf(_classRef, "actionId", "I");

  /// from: public int actionId
  ///
  /// If \#actionLabel has been given, this is the id for that command
  /// when the user presses its button that is delivered back with
  /// InputConnection\#performEditorAction(int) InputConnection.performEditorAction().
  int get actionId => jniAccessors
      .getField(reference, _id_actionId, jni.JniType.intType)
      .integer;

  /// from: public int actionId
  ///
  /// If \#actionLabel has been given, this is the id for that command
  /// when the user presses its button that is delivered back with
  /// InputConnection\#performEditorAction(int) InputConnection.performEditorAction().
  set actionId(int value) => jniEnv.SetIntField(reference, _id_actionId, value);

  static final _id_actionLabel = jniAccessors.getFieldIDOf(
      _classRef, "actionLabel", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence actionLabel
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// In some cases an IME may be able to display an arbitrary label for
  /// a command the user can perform, which you can specify here. This is
  /// typically used as the label for the action to use in-line as a replacement
  /// for the "enter" key (see \#actionId). Remember the key where
  /// this will be displayed is typically very small, and there are significant
  /// localization challenges to make this fit in all supported languages. Also
  /// you can not count absolutely on this being used, as some IMEs may
  /// ignore this.
  jni.JniObject get actionLabel => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_actionLabel, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence actionLabel
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// In some cases an IME may be able to display an arbitrary label for
  /// a command the user can perform, which you can specify here. This is
  /// typically used as the label for the action to use in-line as a replacement
  /// for the "enter" key (see \#actionId). Remember the key where
  /// this will be displayed is typically very small, and there are significant
  /// localization challenges to make this fit in all supported languages. Also
  /// you can not count absolutely on this being used, as some IMEs may
  /// ignore this.
  set actionLabel(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_actionLabel, value.reference);

  static final _id_contentMimeTypes = jniAccessors.getFieldIDOf(
      _classRef, "contentMimeTypes", "[Ljava/lang/String;");

  /// from: public java.lang.String[] contentMimeTypes
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of acceptable MIME types for
  /// InputConnection\#commitContent(InputContentInfo, int, Bundle).
  ///
  /// {@code null} or an empty array means that
  /// InputConnection\#commitContent(InputContentInfo, int, Bundle) is not supported in this
  /// editor.
  ///
  jni.JniObject get contentMimeTypes => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_contentMimeTypes, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String[] contentMimeTypes
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of acceptable MIME types for
  /// InputConnection\#commitContent(InputContentInfo, int, Bundle).
  ///
  /// {@code null} or an empty array means that
  /// InputConnection\#commitContent(InputContentInfo, int, Bundle) is not supported in this
  /// editor.
  ///
  set contentMimeTypes(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_contentMimeTypes, value.reference);

  static final _id_extras =
      jniAccessors.getFieldIDOf(_classRef, "extras", "Landroid/os/Bundle;");

  /// from: public android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Any extra data to supply to the input method.  This is for extended
  /// communication with specific input methods; the name fields in the
  /// bundle should be scoped (such as "com.mydomain.im.SOME_FIELD") so
  /// that they don't conflict with others.  This field can be
  /// filled in from the android.R.attr\#editorExtras
  /// attribute of a TextView.
  bundle_.Bundle get extras => bundle_.Bundle.fromRef(jniAccessors
      .getField(reference, _id_extras, jni.JniType.objectType)
      .object);

  /// from: public android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Any extra data to supply to the input method.  This is for extended
  /// communication with specific input methods; the name fields in the
  /// bundle should be scoped (such as "com.mydomain.im.SOME_FIELD") so
  /// that they don't conflict with others.  This field can be
  /// filled in from the android.R.attr\#editorExtras
  /// attribute of a TextView.
  set extras(bundle_.Bundle value) =>
      jniEnv.SetObjectField(reference, _id_extras, value.reference);

  static final _id_fieldId =
      jniAccessors.getFieldIDOf(_classRef, "fieldId", "I");

  /// from: public int fieldId
  ///
  /// Identifier for the editor's field.  This is optional, and may be
  /// 0.  By default it is filled in with the result of
  /// android.view.View\#getId() View.getId() on the View that
  /// is being edited.
  int get fieldId => jniAccessors
      .getField(reference, _id_fieldId, jni.JniType.intType)
      .integer;

  /// from: public int fieldId
  ///
  /// Identifier for the editor's field.  This is optional, and may be
  /// 0.  By default it is filled in with the result of
  /// android.view.View\#getId() View.getId() on the View that
  /// is being edited.
  set fieldId(int value) => jniEnv.SetIntField(reference, _id_fieldId, value);

  static final _id_fieldName =
      jniAccessors.getFieldIDOf(_classRef, "fieldName", "Ljava/lang/String;");

  /// from: public java.lang.String fieldName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Additional name for the editor's field.  This can supply additional
  /// name information for the field.  By default it is null.  The actual
  /// contents have no meaning.
  jni.JniString get fieldName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_fieldName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String fieldName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Additional name for the editor's field.  This can supply additional
  /// name information for the field.  By default it is null.  The actual
  /// contents have no meaning.
  set fieldName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_fieldName, value.reference);

  static final _id_hintLocales = jniAccessors.getFieldIDOf(
      _classRef, "hintLocales", "Landroid/os/LocaleList;");

  /// from: public android.os.LocaleList hintLocales
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of the languages that the user is supposed to switch to no matter what input method
  /// subtype is currently used.  This special "hint" can be used mainly for, but not limited to,
  /// multilingual users who want IMEs to switch language context automatically.
  ///
  /// {@code null} means that no special language "hint" is needed.
  ///
  ///
  /// <strong>Editor authors:</strong> Specify this only when you are confident that the user
  /// will switch to certain languages in this context no matter what input method subtype is
  /// currently selected.  Otherwise, keep this {@code null}.  Explicit user actions and/or
  /// preferences would be good signals to specify this special "hint",  For example, a chat
  /// application may be able to put the last used language at the top of \#hintLocales
  /// based on whom the user is going to talk, by remembering what language is used in the last
  /// conversation.  Do not specify android.widget.TextView\#getTextLocales() only because
  /// it is used for text rendering.
  ///
  ///@see android.widget.TextView\#setImeHintLocales(LocaleList)
  ///@see android.widget.TextView\#getImeHintLocales()
  localelist_.LocaleList get hintLocales =>
      localelist_.LocaleList.fromRef(jniAccessors
          .getField(reference, _id_hintLocales, jni.JniType.objectType)
          .object);

  /// from: public android.os.LocaleList hintLocales
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of the languages that the user is supposed to switch to no matter what input method
  /// subtype is currently used.  This special "hint" can be used mainly for, but not limited to,
  /// multilingual users who want IMEs to switch language context automatically.
  ///
  /// {@code null} means that no special language "hint" is needed.
  ///
  ///
  /// <strong>Editor authors:</strong> Specify this only when you are confident that the user
  /// will switch to certain languages in this context no matter what input method subtype is
  /// currently selected.  Otherwise, keep this {@code null}.  Explicit user actions and/or
  /// preferences would be good signals to specify this special "hint",  For example, a chat
  /// application may be able to put the last used language at the top of \#hintLocales
  /// based on whom the user is going to talk, by remembering what language is used in the last
  /// conversation.  Do not specify android.widget.TextView\#getTextLocales() only because
  /// it is used for text rendering.
  ///
  ///@see android.widget.TextView\#setImeHintLocales(LocaleList)
  ///@see android.widget.TextView\#getImeHintLocales()
  set hintLocales(localelist_.LocaleList value) =>
      jniEnv.SetObjectField(reference, _id_hintLocales, value.reference);

  static final _id_hintText = jniAccessors.getFieldIDOf(
      _classRef, "hintText", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence hintText
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The "hint" text of the text view, typically shown in-line when the
  /// text is empty to tell the user what to enter.
  jni.JniObject get hintText => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_hintText, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence hintText
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The "hint" text of the text view, typically shown in-line when the
  /// text is empty to tell the user what to enter.
  set hintText(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_hintText, value.reference);

  static final _id_imeOptions =
      jniAccessors.getFieldIDOf(_classRef, "imeOptions", "I");

  /// from: public int imeOptions
  ///
  /// Extended type information for the editor, to help the IME better
  /// integrate with it.
  int get imeOptions => jniAccessors
      .getField(reference, _id_imeOptions, jni.JniType.intType)
      .integer;

  /// from: public int imeOptions
  ///
  /// Extended type information for the editor, to help the IME better
  /// integrate with it.
  set imeOptions(int value) =>
      jniEnv.SetIntField(reference, _id_imeOptions, value);

  static final _id_initialCapsMode =
      jniAccessors.getFieldIDOf(_classRef, "initialCapsMode", "I");

  /// from: public int initialCapsMode
  ///
  /// The capitalization mode of the first character being edited in the
  /// text.  Values may be any combination of
  /// TextUtils\#CAP_MODE_CHARACTERS TextUtils.CAP_MODE_CHARACTERS,
  /// TextUtils\#CAP_MODE_WORDS TextUtils.CAP_MODE_WORDS, and
  /// TextUtils\#CAP_MODE_SENTENCES TextUtils.CAP_MODE_SENTENCES, though
  /// you should generally just take a non-zero value to mean "start out in
  /// caps mode".
  int get initialCapsMode => jniAccessors
      .getField(reference, _id_initialCapsMode, jni.JniType.intType)
      .integer;

  /// from: public int initialCapsMode
  ///
  /// The capitalization mode of the first character being edited in the
  /// text.  Values may be any combination of
  /// TextUtils\#CAP_MODE_CHARACTERS TextUtils.CAP_MODE_CHARACTERS,
  /// TextUtils\#CAP_MODE_WORDS TextUtils.CAP_MODE_WORDS, and
  /// TextUtils\#CAP_MODE_SENTENCES TextUtils.CAP_MODE_SENTENCES, though
  /// you should generally just take a non-zero value to mean "start out in
  /// caps mode".
  set initialCapsMode(int value) =>
      jniEnv.SetIntField(reference, _id_initialCapsMode, value);

  static final _id_initialSelEnd =
      jniAccessors.getFieldIDOf(_classRef, "initialSelEnd", "I");

  /// from: public int initialSelEnd
  ///
  /// The text offset of the end of the selection at the time editing
  /// begins; -1 if not known. Keep in mind that, without knowing the cursor
  /// position, many IMEs will not be able to offer their full feature set and
  /// may behave in unpredictable ways: pass the actual cursor position
  /// here if possible at all.
  ///
  ///
  /// Also, this needs to be the cursor position <strong>right now</strong>,
  /// not at some point in the past, even if input is starting in the same text field
  /// as before. When the app is filling this object, input is about to start by
  /// definition, and this value will override any value the app may have passed to
  /// InputMethodManager\#updateSelection(android.view.View, int, int, int, int)
  /// before.
  ///
  int get initialSelEnd => jniAccessors
      .getField(reference, _id_initialSelEnd, jni.JniType.intType)
      .integer;

  /// from: public int initialSelEnd
  ///
  /// The text offset of the end of the selection at the time editing
  /// begins; -1 if not known. Keep in mind that, without knowing the cursor
  /// position, many IMEs will not be able to offer their full feature set and
  /// may behave in unpredictable ways: pass the actual cursor position
  /// here if possible at all.
  ///
  ///
  /// Also, this needs to be the cursor position <strong>right now</strong>,
  /// not at some point in the past, even if input is starting in the same text field
  /// as before. When the app is filling this object, input is about to start by
  /// definition, and this value will override any value the app may have passed to
  /// InputMethodManager\#updateSelection(android.view.View, int, int, int, int)
  /// before.
  ///
  set initialSelEnd(int value) =>
      jniEnv.SetIntField(reference, _id_initialSelEnd, value);

  static final _id_initialSelStart =
      jniAccessors.getFieldIDOf(_classRef, "initialSelStart", "I");

  /// from: public int initialSelStart
  ///
  /// The text offset of the start of the selection at the time editing
  /// begins; -1 if not known. Keep in mind that, without knowing the cursor
  /// position, many IMEs will not be able to offer their full feature set and
  /// may even behave in unpredictable ways: pass the actual cursor position
  /// here if possible at all.
  ///
  /// Also, this needs to be the cursor position <strong>right now</strong>,
  /// not at some point in the past, even if input is starting in the same text field
  /// as before. When the app is filling this object, input is about to start by
  /// definition, and this value will override any value the app may have passed to
  /// InputMethodManager\#updateSelection(android.view.View, int, int, int, int)
  /// before.
  ///
  int get initialSelStart => jniAccessors
      .getField(reference, _id_initialSelStart, jni.JniType.intType)
      .integer;

  /// from: public int initialSelStart
  ///
  /// The text offset of the start of the selection at the time editing
  /// begins; -1 if not known. Keep in mind that, without knowing the cursor
  /// position, many IMEs will not be able to offer their full feature set and
  /// may even behave in unpredictable ways: pass the actual cursor position
  /// here if possible at all.
  ///
  /// Also, this needs to be the cursor position <strong>right now</strong>,
  /// not at some point in the past, even if input is starting in the same text field
  /// as before. When the app is filling this object, input is about to start by
  /// definition, and this value will override any value the app may have passed to
  /// InputMethodManager\#updateSelection(android.view.View, int, int, int, int)
  /// before.
  ///
  set initialSelStart(int value) =>
      jniEnv.SetIntField(reference, _id_initialSelStart, value);

  static final _id_inputType =
      jniAccessors.getFieldIDOf(_classRef, "inputType", "I");

  /// from: public int inputType
  ///
  /// The content type of the text box, whose bits are defined by
  /// InputType.
  ///@see InputType
  ///@see \#TYPE_MASK_CLASS
  ///@see \#TYPE_MASK_VARIATION
  ///@see \#TYPE_MASK_FLAGS
  int get inputType => jniAccessors
      .getField(reference, _id_inputType, jni.JniType.intType)
      .integer;

  /// from: public int inputType
  ///
  /// The content type of the text box, whose bits are defined by
  /// InputType.
  ///@see InputType
  ///@see \#TYPE_MASK_CLASS
  ///@see \#TYPE_MASK_VARIATION
  ///@see \#TYPE_MASK_FLAGS
  set inputType(int value) =>
      jniEnv.SetIntField(reference, _id_inputType, value);

  static final _id_label =
      jniAccessors.getFieldIDOf(_classRef, "label", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence label
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A label to show to the user describing the text they are writing.
  jni.JniObject get label => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_label, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence label
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A label to show to the user describing the text they are writing.
  set label(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_label, value.reference);

  static final _id_packageName =
      jniAccessors.getFieldIDOf(_classRef, "packageName", "Ljava/lang/String;");

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Name of the package that owns this editor.
  ///
  /// <strong>IME authors:</strong> In API level 22
  /// android.os.Build.VERSION_CODES\#LOLLIPOP_MR1 and prior, do not trust this package
  /// name. The system had not verified the consistency between the package name here and
  /// application's uid. Consider to use InputBinding\#getUid(), which is trustworthy.
  /// Starting from android.os.Build.VERSION_CODES\#M, the system verifies the consistency
  /// between this package name and application uid before EditorInfo is passed to the
  /// input method.
  ///
  ///
  /// <strong>Editor authors:</strong> Starting from android.os.Build.VERSION_CODES\#M,
  /// the application is no longer
  /// able to establish input connections if the package name provided here is inconsistent with
  /// application's uid.
  ///
  jni.JniString get packageName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_packageName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Name of the package that owns this editor.
  ///
  /// <strong>IME authors:</strong> In API level 22
  /// android.os.Build.VERSION_CODES\#LOLLIPOP_MR1 and prior, do not trust this package
  /// name. The system had not verified the consistency between the package name here and
  /// application's uid. Consider to use InputBinding\#getUid(), which is trustworthy.
  /// Starting from android.os.Build.VERSION_CODES\#M, the system verifies the consistency
  /// between this package name and application uid before EditorInfo is passed to the
  /// input method.
  ///
  ///
  /// <strong>Editor authors:</strong> Starting from android.os.Build.VERSION_CODES\#M,
  /// the application is no longer
  /// able to establish input connections if the package name provided here is inconsistent with
  /// application's uid.
  ///
  set packageName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_packageName, value.reference);

  static final _id_privateImeOptions = jniAccessors.getFieldIDOf(
      _classRef, "privateImeOptions", "Ljava/lang/String;");

  /// from: public java.lang.String privateImeOptions
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A string supplying additional information options that are
  /// private to a particular IME implementation.  The string must be
  /// scoped to a package owned by the implementation, to ensure there are
  /// no conflicts between implementations, but other than that you can put
  /// whatever you want in it to communicate with the IME.  For example,
  /// you could have a string that supplies an argument like
  /// <code>"com.example.myapp.SpecialMode=3"</code>.  This field is can be
  /// filled in from the android.R.attr\#privateImeOptions
  /// attribute of a TextView.
  jni.JniString get privateImeOptions => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_privateImeOptions, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String privateImeOptions
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A string supplying additional information options that are
  /// private to a particular IME implementation.  The string must be
  /// scoped to a package owned by the implementation, to ensure there are
  /// no conflicts between implementations, but other than that you can put
  /// whatever you want in it to communicate with the IME.  For example,
  /// you could have a string that supplies an argument like
  /// <code>"com.example.myapp.SpecialMode=3"</code>.  This field is can be
  /// filled in from the android.R.attr\#privateImeOptions
  /// attribute of a TextView.
  set privateImeOptions(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_privateImeOptions, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  EditorInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_makeCompatible =
      jniAccessors.getMethodIDOf(_classRef, "makeCompatible", "(I)V");

  /// from: public final void makeCompatible(int targetSdkVersion)
  ///
  /// Ensure that the data in this EditorInfo is compatible with an application
  /// that was developed against the given target API version.  This can
  /// impact the following input types:
  /// InputType\#TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS,
  /// InputType\#TYPE_TEXT_VARIATION_WEB_PASSWORD,
  /// InputType\#TYPE_NUMBER_VARIATION_NORMAL,
  /// InputType\#TYPE_NUMBER_VARIATION_PASSWORD.
  ///
  /// This is called by the framework for input method implementations;
  /// you should not generally need to call it yourself.
  ///@param targetSdkVersion The API version number that the compatible
  /// application was developed against.
  void makeCompatible(int targetSdkVersion) => jniAccessors.callMethodWithArgs(
      reference,
      _id_makeCompatible,
      jni.JniType.voidType,
      [targetSdkVersion]).check();

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Landroid/util/Printer;Ljava/lang/String;)V");

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  ///
  /// Write debug output of this object.
  void dump(printer_.Printer pw, jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [pw.reference, prefix.reference]).check();

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Used to package this object into a Parcel.
  ///@param dest The Parcel to be written.
  ///@param flags The flags used for parceling.
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;
}
