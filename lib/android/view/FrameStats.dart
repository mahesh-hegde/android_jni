// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.FrameStats
///
/// This is the base class for frame statistics.
class FrameStats extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/FrameStats");
  FrameStats.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final long UNDEFINED_TIME_NANO
  ///
  /// Undefined time.
  static const UNDEFINED_TIME_NANO = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  FrameStats()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getRefreshPeriodNano =
      jniAccessors.getMethodIDOf(_classRef, "getRefreshPeriodNano", "()J");

  /// from: public final long getRefreshPeriodNano()
  ///
  /// Gets the refresh period of the display hosting the window(s) for
  /// which these statistics apply.
  ///@return The refresh period in nanoseconds.
  int getRefreshPeriodNano() => jniAccessors.callMethodWithArgs(
      reference, _id_getRefreshPeriodNano, jni.JniType.longType, []).long;

  static final _id_getFrameCount =
      jniAccessors.getMethodIDOf(_classRef, "getFrameCount", "()I");

  /// from: public final int getFrameCount()
  ///
  /// Gets the number of frames for which there is data.
  ///@return The number of frames.
  int getFrameCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getFrameCount, jni.JniType.intType, []).integer;

  static final _id_getStartTimeNano =
      jniAccessors.getMethodIDOf(_classRef, "getStartTimeNano", "()J");

  /// from: public final long getStartTimeNano()
  ///
  /// Gets the start time of the interval for which these statistics
  /// apply. The start interval is the time when the first frame was
  /// presented.
  ///@return The start time in nanoseconds or \#UNDEFINED_TIME_NANO
  ///         if there is no frame data.
  int getStartTimeNano() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartTimeNano, jni.JniType.longType, []).long;

  static final _id_getEndTimeNano =
      jniAccessors.getMethodIDOf(_classRef, "getEndTimeNano", "()J");

  /// from: public final long getEndTimeNano()
  ///
  /// Gets the end time of the interval for which these statistics
  /// apply. The end interval is the time when the last frame was
  /// presented.
  ///@return The end time in nanoseconds or \#UNDEFINED_TIME_NANO
  ///         if there is no frame data.
  int getEndTimeNano() => jniAccessors.callMethodWithArgs(
      reference, _id_getEndTimeNano, jni.JniType.longType, []).long;

  static final _id_getFramePresentedTimeNano = jniAccessors.getMethodIDOf(
      _classRef, "getFramePresentedTimeNano", "(I)J");

  /// from: public final long getFramePresentedTimeNano(int index)
  ///
  /// Get the time a frame at a given index was presented.
  ///@param index The frame index.
  ///@return The presented time in nanoseconds or \#UNDEFINED_TIME_NANO
  ///         if the frame is not presented yet.
  int getFramePresentedTimeNano(int index) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getFramePresentedTimeNano,
      jni.JniType.longType,
      [index]).long;
}
