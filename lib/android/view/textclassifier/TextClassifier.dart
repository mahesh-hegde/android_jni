// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "TextSelection.dart" as textselection_;

import "../../os/LocaleList.dart" as localelist_;

import "TextClassification.dart" as textclassification_;

import "TextLinks.dart" as textlinks_;

import "SelectionEvent.dart" as selectionevent_;

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.textclassifier.TextClassifier
///
/// Interface for providing text classification related features.
///
/// <strong>NOTE: </strong>Unless otherwise stated, methods of this interface are blocking
/// operations. Call on a worker thread.
class TextClassifier extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/textclassifier/TextClassifier");
  TextClassifier.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String HINT_TEXT_IS_EDITABLE
  ///
  /// Designates that the text in question is editable.
  static const HINT_TEXT_IS_EDITABLE = "android.text_is_editable";

  /// from: static public final java.lang.String HINT_TEXT_IS_NOT_EDITABLE
  ///
  /// Designates that the text in question is not editable.
  static const HINT_TEXT_IS_NOT_EDITABLE = "android.text_is_not_editable";

  static final _id_NO_OP = jniAccessors.getStaticFieldIDOf(
      _classRef, "NO_OP", "Landroid/view/textclassifier/TextClassifier;");

  /// from: static public final android.view.textclassifier.TextClassifier NO_OP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// No-op TextClassifier.
  /// This may be used to turn off TextClassifier features.
  static TextClassifier get NO_OP => TextClassifier.fromRef(jniAccessors
      .getStaticField(_classRef, _id_NO_OP, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String TYPE_ADDRESS
  ///
  /// Physical address.
  static const TYPE_ADDRESS = "address";

  /// from: static public final java.lang.String TYPE_DATE
  ///
  /// Time reference that is no more specific than a date. May be absolute such as "01/01/2000" or
  /// relative like "tomorrow".
  static const TYPE_DATE = "date";

  /// from: static public final java.lang.String TYPE_DATE_TIME
  ///
  /// Time reference that includes a specific time. May be absolute such as "01/01/2000 5:30pm" or
  /// relative like "tomorrow at 5:30pm".
  static const TYPE_DATE_TIME = "datetime";

  /// from: static public final java.lang.String TYPE_EMAIL
  ///
  /// E-mail address (e.g.&nbsp;"noreply@android.com").
  static const TYPE_EMAIL = "email";

  /// from: static public final java.lang.String TYPE_FLIGHT_NUMBER
  ///
  /// Flight number in IATA format.
  static const TYPE_FLIGHT_NUMBER = "flight";

  /// from: static public final java.lang.String TYPE_OTHER
  ///
  /// The classifier ran, but didn't recognize a known entity.
  static const TYPE_OTHER = "other";

  /// from: static public final java.lang.String TYPE_PHONE
  ///
  /// Phone number (e.g.&nbsp;"555-123 456").
  static const TYPE_PHONE = "phone";

  static final _id_TYPE_UNKNOWN = jniAccessors.getStaticFieldIDOf(
      _classRef, "TYPE_UNKNOWN", "Ljava/lang/String;");

  /// from: static public final java.lang.String TYPE_UNKNOWN
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The TextClassifier failed to run.
  static jni.JniString get TYPE_UNKNOWN => jni.JniString.fromRef(jniAccessors
      .getStaticField(_classRef, _id_TYPE_UNKNOWN, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String TYPE_URL
  ///
  /// Web URL.
  static const TYPE_URL = "url";

  /// from: static public final java.lang.String WIDGET_TYPE_CUSTOM_EDITTEXT
  ///
  /// The widget involved in the text classification session is a custom editable text widget.
  static const WIDGET_TYPE_CUSTOM_EDITTEXT = "customedit";

  /// from: static public final java.lang.String WIDGET_TYPE_CUSTOM_TEXTVIEW
  ///
  /// The widget involved in the text classification session is a custom text widget.
  static const WIDGET_TYPE_CUSTOM_TEXTVIEW = "customview";

  /// from: static public final java.lang.String WIDGET_TYPE_CUSTOM_UNSELECTABLE_TEXTVIEW
  ///
  /// The widget involved in the text classification session is a custom non-selectable text
  /// widget.
  static const WIDGET_TYPE_CUSTOM_UNSELECTABLE_TEXTVIEW = "nosel-customview";

  /// from: static public final java.lang.String WIDGET_TYPE_EDITTEXT
  ///
  /// The widget involved in the text classification session is a standard
  /// android.widget.EditText.
  static const WIDGET_TYPE_EDITTEXT = "edittext";

  /// from: static public final java.lang.String WIDGET_TYPE_EDIT_WEBVIEW
  ///
  /// The widget involved in the text classification session is a standard editable
  /// android.webkit.WebView.
  static const WIDGET_TYPE_EDIT_WEBVIEW = "edit-webview";

  /// from: static public final java.lang.String WIDGET_TYPE_TEXTVIEW
  ///
  /// The widget involved in the text classification session is a standard
  /// android.widget.TextView.
  static const WIDGET_TYPE_TEXTVIEW = "textview";

  /// from: static public final java.lang.String WIDGET_TYPE_UNKNOWN
  ///
  /// The widget involved in the text classification session is of an unknown/unspecified type.
  static const WIDGET_TYPE_UNKNOWN = "unknown";

  /// from: static public final java.lang.String WIDGET_TYPE_UNSELECTABLE_TEXTVIEW
  ///
  /// The widget involved in the text classification session is a standard non-selectable
  /// android.widget.TextView.
  static const WIDGET_TYPE_UNSELECTABLE_TEXTVIEW = "nosel-textview";

  /// from: static public final java.lang.String WIDGET_TYPE_WEBVIEW
  ///
  /// The widget involved in the text classification session is a standard
  /// android.webkit.WebView.
  static const WIDGET_TYPE_WEBVIEW = "webview";

  static final _id_suggestSelection = jniAccessors.getMethodIDOf(
      _classRef,
      "suggestSelection",
      "(Landroid/view/textclassifier/TextSelection\$Request;)Landroid/view/textclassifier/TextSelection;");

  /// from: default public android.view.textclassifier.TextSelection suggestSelection(android.view.textclassifier.TextSelection.Request request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns suggested text selection start and end indices, recognized entity types, and their
  /// associated confidence scores. The entity types are ordered from highest to lowest scoring.
  ///
  /// <strong>NOTE: </strong>Call on a worker thread.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
  /// throw an IllegalStateException. See \#isDestroyed().
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param request the text selection request
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  textselection_.TextSelection suggestSelection(
          textselection_.TextSelection_Request request) =>
      textselection_.TextSelection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_suggestSelection,
          jni.JniType.objectType,
          [request.reference]).object);

  static final _id_suggestSelection1 = jniAccessors.getMethodIDOf(
      _classRef,
      "suggestSelection",
      "(Ljava/lang/CharSequence;IILandroid/os/LocaleList;)Landroid/view/textclassifier/TextSelection;");

  /// from: default public android.view.textclassifier.TextSelection suggestSelection(java.lang.CharSequence text, int selectionStartIndex, int selectionEndIndex, android.os.LocaleList defaultLocales)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns suggested text selection start and end indices, recognized entity types, and their
  /// associated confidence scores. The entity types are ordered from highest to lowest scoring.
  ///
  /// <strong>NOTE: </strong>Call on a worker thread.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
  /// throw an IllegalStateException. See \#isDestroyed().
  ///
  /// __NOTE:__ Do not implement. The default implementation of this method calls
  /// \#suggestSelection(TextSelection.Request). If that method calls this method,
  /// a stack overflow error will happen.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param text text providing context for the selected text (which is specified
  ///      by the sub sequence starting at selectionStartIndex and ending at selectionEndIndex)
  /// This value must never be {@code null}.
  ///@param selectionStartIndex start index of the selected part of text
  /// Value is 0 or greater
  ///@param selectionEndIndex end index of the selected part of text
  /// Value is 0 or greater
  ///@param defaultLocales ordered list of locale preferences that may be used to
  ///      disambiguate the provided text. If no locale preferences exist, set this to null
  ///      or an empty locale list.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if text is null; selectionStartIndex is negative;
  ///      selectionEndIndex is greater than text.length() or not greater than selectionStartIndex
  ///@see \#suggestSelection(TextSelection.Request)
  textselection_.TextSelection suggestSelection1(
          jni.JniObject text,
          int selectionStartIndex,
          int selectionEndIndex,
          localelist_.LocaleList defaultLocales) =>
      textselection_.TextSelection.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_suggestSelection1, jni.JniType.objectType, [
        text.reference,
        selectionStartIndex,
        selectionEndIndex,
        defaultLocales.reference
      ]).object);

  static final _id_classifyText = jniAccessors.getMethodIDOf(
      _classRef,
      "classifyText",
      "(Landroid/view/textclassifier/TextClassification\$Request;)Landroid/view/textclassifier/TextClassification;");

  /// from: default public android.view.textclassifier.TextClassification classifyText(android.view.textclassifier.TextClassification.Request request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Classifies the specified text and returns a TextClassification object that can be
  /// used to generate a widget for handling the classified text.
  ///
  /// <strong>NOTE: </strong>Call on a worker thread.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
  /// throw an IllegalStateException. See \#isDestroyed().
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param request the text classification request
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  textclassification_.TextClassification classifyText(
          textclassification_.TextClassification_Request request) =>
      textclassification_.TextClassification.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_classifyText,
              jni.JniType.objectType, [request.reference]).object);

  static final _id_classifyText1 = jniAccessors.getMethodIDOf(
      _classRef,
      "classifyText",
      "(Ljava/lang/CharSequence;IILandroid/os/LocaleList;)Landroid/view/textclassifier/TextClassification;");

  /// from: default public android.view.textclassifier.TextClassification classifyText(java.lang.CharSequence text, int startIndex, int endIndex, android.os.LocaleList defaultLocales)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Classifies the specified text and returns a TextClassification object that can be
  /// used to generate a widget for handling the classified text.
  ///
  /// <strong>NOTE: </strong>Call on a worker thread.
  ///
  /// __NOTE:__ Do not implement. The default implementation of this method calls
  /// \#classifyText(TextClassification.Request). If that method calls this method,
  /// a stack overflow error will happen.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
  /// throw an IllegalStateException. See \#isDestroyed().
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param text text providing context for the text to classify (which is specified
  ///      by the sub sequence starting at startIndex and ending at endIndex)
  /// This value must never be {@code null}.
  ///@param startIndex start index of the text to classify
  /// Value is 0 or greater
  ///@param endIndex end index of the text to classify
  /// Value is 0 or greater
  ///@param defaultLocales ordered list of locale preferences that may be used to
  ///      disambiguate the provided text. If no locale preferences exist, set this to null
  ///      or an empty locale list.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if text is null; startIndex is negative;
  ///      endIndex is greater than text.length() or not greater than startIndex
  ///@see \#classifyText(TextClassification.Request)
  textclassification_.TextClassification classifyText1(
          jni.JniObject text,
          int startIndex,
          int endIndex,
          localelist_.LocaleList defaultLocales) =>
      textclassification_.TextClassification.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_classifyText1, jni.JniType.objectType, [
        text.reference,
        startIndex,
        endIndex,
        defaultLocales.reference
      ]).object);

  static final _id_generateLinks = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLinks",
      "(Landroid/view/textclassifier/TextLinks\$Request;)Landroid/view/textclassifier/TextLinks;");

  /// from: default public android.view.textclassifier.TextLinks generateLinks(android.view.textclassifier.TextLinks.Request request)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generates and returns a TextLinks that may be applied to the text to annotate it with
  /// links information.
  ///
  /// <strong>NOTE: </strong>Call on a worker thread.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
  /// throw an IllegalStateException. See \#isDestroyed().
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param request the text links request
  ///
  /// This value must never be {@code null}.
  ///@see \#getMaxGenerateLinksTextLength()
  ///@return This value will never be {@code null}.
  textlinks_.TextLinks generateLinks(textlinks_.TextLinks_Request request) =>
      textlinks_.TextLinks.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLinks,
          jni.JniType.objectType,
          [request.reference]).object);

  static final _id_getMaxGenerateLinksTextLength = jniAccessors.getMethodIDOf(
      _classRef, "getMaxGenerateLinksTextLength", "()I");

  /// from: default public int getMaxGenerateLinksTextLength()
  ///
  /// Returns the maximal length of text that can be processed by generateLinks.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
  /// throw an IllegalStateException. See \#isDestroyed().
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@see \#generateLinks(TextLinks.Request)
  int getMaxGenerateLinksTextLength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getMaxGenerateLinksTextLength,
      jni.JniType.intType, []).integer;

  static final _id_onSelectionEvent = jniAccessors.getMethodIDOf(_classRef,
      "onSelectionEvent", "(Landroid/view/textclassifier/SelectionEvent;)V");

  /// from: default public void onSelectionEvent(android.view.textclassifier.SelectionEvent event)
  ///
  /// Reports a selection event.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
  /// throw an IllegalStateException. See \#isDestroyed().
  ///@param event This value must never be {@code null}.
  void onSelectionEvent(selectionevent_.SelectionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSelectionEvent,
          jni.JniType.voidType, [event.reference]).check();

  static final _id_destroy =
      jniAccessors.getMethodIDOf(_classRef, "destroy", "()V");

  /// from: default public void destroy()
  ///
  /// Destroys this TextClassifier.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to its methods should
  /// throw an IllegalStateException. See \#isDestroyed().
  ///
  /// Subsequent calls to this method are no-ops.
  void destroy() => jniAccessors.callMethodWithArgs(
      reference, _id_destroy, jni.JniType.voidType, []).check();

  static final _id_isDestroyed =
      jniAccessors.getMethodIDOf(_classRef, "isDestroyed", "()Z");

  /// from: default public boolean isDestroyed()
  ///
  /// Returns whether or not this TextClassifier has been destroyed.
  ///
  /// <strong>NOTE: </strong>If a TextClassifier has been destroyed, caller should not interact
  /// with the classifier and an attempt to do so would throw an IllegalStateException.
  /// However, this method should never throw an IllegalStateException.
  ///@see \#destroy()
  bool isDestroyed() => jniAccessors.callMethodWithArgs(
      reference, _id_isDestroyed, jni.JniType.booleanType, []).boolean;
}

/// from: android.view.textclassifier.TextClassifier$EntityConfig
///
/// Configuration object for specifying what entities to identify.
///
/// Configs are initially based on a predefined preset, and can be modified from there.
class TextClassifier_EntityConfig extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/textclassifier/TextClassifier\$EntityConfig");
  TextClassifier_EntityConfig.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.textclassifier.TextClassifier.EntityConfig> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_createWithHints = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createWithHints",
      "(Ljava/util/Collection;)Landroid/view/textclassifier/TextClassifier\$EntityConfig;");

  /// from: static public android.view.textclassifier.TextClassifier.EntityConfig createWithHints(java.util.Collection<java.lang.String> hints)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an EntityConfig.
  ///@param hints Hints for the TextClassifier to determine what types of entities to find.
  ///
  /// This value may be {@code null}.
  static TextClassifier_EntityConfig createWithHints(jni.JniObject hints) =>
      TextClassifier_EntityConfig.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createWithHints,
          jni.JniType.objectType,
          [hints.reference]).object);

  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Ljava/util/Collection;Ljava/util/Collection;Ljava/util/Collection;)Landroid/view/textclassifier/TextClassifier\$EntityConfig;");

  /// from: static public android.view.textclassifier.TextClassifier.EntityConfig create(java.util.Collection<java.lang.String> hints, java.util.Collection<java.lang.String> includedEntityTypes, java.util.Collection<java.lang.String> excludedEntityTypes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an EntityConfig.
  ///@param hints Hints for the TextClassifier to determine what types of entities to find
  /// This value may be {@code null}.
  ///@param includedEntityTypes Entity types, e.g. \#TYPE_EMAIL, to explicitly include
  /// This value may be {@code null}.
  ///@param excludedEntityTypes Entity types, e.g. \#TYPE_PHONE, to explicitly exclude
  ///
  ///
  /// Note that if an entity has been excluded, the exclusion will take precedence.
  ///
  /// This value may be {@code null}.
  static TextClassifier_EntityConfig create(
          jni.JniObject hints,
          jni.JniObject includedEntityTypes,
          jni.JniObject excludedEntityTypes) =>
      TextClassifier_EntityConfig.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_create, jni.JniType.objectType, [
        hints.reference,
        includedEntityTypes.reference,
        excludedEntityTypes.reference
      ]).object);

  static final _id_createWithExplicitEntityList = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createWithExplicitEntityList",
      "(Ljava/util/Collection;)Landroid/view/textclassifier/TextClassifier\$EntityConfig;");

  /// from: static public android.view.textclassifier.TextClassifier.EntityConfig createWithExplicitEntityList(java.util.Collection<java.lang.String> entityTypes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an EntityConfig with an explicit entity list.
  ///@param entityTypes Complete set of entities, e.g. \#TYPE_URL to find.
  ///
  ///
  /// This value may be {@code null}.
  static TextClassifier_EntityConfig createWithExplicitEntityList(
          jni.JniObject entityTypes) =>
      TextClassifier_EntityConfig.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createWithExplicitEntityList,
          jni.JniType.objectType,
          [entityTypes.reference]).object);

  static final _id_resolveEntityListModifications = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveEntityListModifications",
      "(Ljava/util/Collection;)Ljava/util/Collection;");

  /// from: public java.util.Collection<java.lang.String> resolveEntityListModifications(java.util.Collection<java.lang.String> entities)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of the final set of entities to find.
  ///@param entities Entities we think should be found before factoring in includes/excludes
  ///
  /// This method is intended for use by TextClassifier implementations.
  ///
  /// This value must never be {@code null}.
  jni.JniObject resolveEntityListModifications(jni.JniObject entities) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveEntityListModifications,
          jni.JniType.objectType,
          [entities.reference]).object);

  static final _id_getHints = jniAccessors.getMethodIDOf(
      _classRef, "getHints", "()Ljava/util/Collection;");

  /// from: public java.util.Collection<java.lang.String> getHints()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the list of hints.
  ///@return An unmodifiable collection of the hints.
  jni.JniObject getHints() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHints, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
