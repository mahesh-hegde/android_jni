// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;

import "TextClassifier.dart" as textclassifier_;

import "TextClassificationContext.dart" as textclassificationcontext_;

import "TextClassificationSessionFactory.dart"
    as textclassificationsessionfactory_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.textclassifier.TextClassificationManager
///
/// Interface to the text classification service.
class TextClassificationManager extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/textclassifier/TextClassificationManager");
  TextClassificationManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  TextClassificationManager(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_getTextClassifier = jniAccessors.getMethodIDOf(_classRef,
      "getTextClassifier", "()Landroid/view/textclassifier/TextClassifier;");

  /// from: public android.view.textclassifier.TextClassifier getTextClassifier()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the text classifier that was set via \#setTextClassifier(TextClassifier).
  /// If this is null, this method returns a default text classifier (i.e. either the system text
  /// classifier if one exists, or a local text classifier running in this app.)
  ///@see \#setTextClassifier(TextClassifier)
  textclassifier_.TextClassifier getTextClassifier() =>
      textclassifier_.TextClassifier.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextClassifier, jni.JniType.objectType, []).object);

  static final _id_setTextClassifier = jniAccessors.getMethodIDOf(_classRef,
      "setTextClassifier", "(Landroid/view/textclassifier/TextClassifier;)V");

  /// from: public void setTextClassifier(android.view.textclassifier.TextClassifier textClassifier)
  ///
  /// Sets the text classifier.
  /// Set to null to use the system default text classifier.
  /// Set to TextClassifier\#NO_OP to disable text classifier features.
  ///@param textClassifier This value may be {@code null}.
  void setTextClassifier(textclassifier_.TextClassifier textClassifier) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextClassifier,
          jni.JniType.voidType, [textClassifier.reference]).check();

  static final _id_createTextClassificationSession = jniAccessors.getMethodIDOf(
      _classRef,
      "createTextClassificationSession",
      "(Landroid/view/textclassifier/TextClassificationContext;)Landroid/view/textclassifier/TextClassifier;");

  /// from: public android.view.textclassifier.TextClassifier createTextClassificationSession(android.view.textclassifier.TextClassificationContext classificationContext)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call this method to start a text classification session with the given context.
  /// A session is created with a context helping the classifier better understand
  /// what the user needs and consists of queries and feedback events. The queries
  /// are directly related to providing useful functionality to the user and the events
  /// are a feedback loop back to the classifier helping it learn and better serve
  /// future queries.
  ///
  ///  All interactions with the returned classifier are considered part of a single
  /// session and are logically grouped. For example, when a text widget is focused
  /// all user interactions around text editing (selection, editing, etc) can be
  /// grouped together to allow the classifier get better.
  ///@param classificationContext The context in which classification would occur
  ///
  /// This value must never be {@code null}.
  ///@return An instance to perform classification in the given context
  ///
  /// This value will never be {@code null}.
  textclassifier_.TextClassifier createTextClassificationSession(
          textclassificationcontext_.TextClassificationContext
              classificationContext) =>
      textclassifier_.TextClassifier.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createTextClassificationSession,
          jni.JniType.objectType,
          [classificationContext.reference]).object);

  static final _id_setTextClassificationSessionFactory =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setTextClassificationSessionFactory",
          "(Landroid/view/textclassifier/TextClassificationSessionFactory;)V");

  /// from: public void setTextClassificationSessionFactory(android.view.textclassifier.TextClassificationSessionFactory factory)
  ///
  /// Sets a TextClassificationSessionFactory to be used to create session-aware TextClassifiers.
  ///@param factory the textClassification session factory. If this is null, the default factory
  ///      will be used.
  ///
  /// This value may be {@code null}.
  void setTextClassificationSessionFactory(
          textclassificationsessionfactory_.TextClassificationSessionFactory
              factory0) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTextClassificationSessionFactory,
          jni.JniType.voidType,
          [factory0.reference]).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
