// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../os/Handler.dart" as handler_;

import "MotionEvent.dart" as motionevent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.ScaleGestureDetector
///
/// Detects scaling transformation gestures using the supplied MotionEvents.
/// The OnScaleGestureListener callback will notify users when a particular
/// gesture event has occurred.
///
/// This class should only be used with MotionEvents reported via touch.
///
/// To use this class:
/// <ul>
///  <li>Create an instance of the {@code ScaleGestureDetector} for your
///      View
///  <li>In the View\#onTouchEvent(MotionEvent) method ensure you call
///          \#onTouchEvent(MotionEvent). The methods defined in your
///          callback will be executed when the events occur.
/// </ul>
class ScaleGestureDetector extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ScaleGestureDetector");
  ScaleGestureDetector.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/ScaleGestureDetector\$OnScaleGestureListener;)V");

  /// from: public void <init>(android.content.Context context, android.view.ScaleGestureDetector.OnScaleGestureListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ScaleGestureDetector with the supplied listener.
  /// You may only use this constructor from a android.os.Looper Looper thread.
  ///@param context the application's context
  ///@param listener the listener invoked for all the callbacks, this must
  /// not be null.
  ///@throws NullPointerException if {@code listener} is null.
  ScaleGestureDetector(context_.Context context,
      ScaleGestureDetector_OnScaleGestureListener listener)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [context.reference, listener.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/ScaleGestureDetector\$OnScaleGestureListener;Landroid/os/Handler;)V");

  /// from: public void <init>(android.content.Context context, android.view.ScaleGestureDetector.OnScaleGestureListener listener, android.os.Handler handler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ScaleGestureDetector with the supplied listener.
  ///@see android.os.Handler\#Handler()
  ///@param context the application's context
  ///@param listener the listener invoked for all the callbacks, this must
  /// not be null.
  ///@param handler the handler to use for running deferred listener events.
  ///@throws NullPointerException if {@code listener} is null.
  ScaleGestureDetector.ctor1(
      context_.Context context,
      ScaleGestureDetector_OnScaleGestureListener listener,
      handler_.Handler handler)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [context.reference, listener.reference, handler.reference]).object);

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  ///
  /// Accepts MotionEvents and dispatches events to a OnScaleGestureListener
  /// when appropriate.
  ///
  /// Applications should pass a complete and consistent event stream to this method.
  /// A complete and consistent event stream involves all MotionEvents from the initial
  /// ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.
  ///
  ///@param event The event to process
  ///@return true if the event was processed and the detector wants to receive the
  ///         rest of the MotionEvents in this event stream.
  bool onTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_setQuickScaleEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setQuickScaleEnabled", "(Z)V");

  /// from: public void setQuickScaleEnabled(boolean scales)
  ///
  /// Set whether the associated OnScaleGestureListener should receive onScale callbacks
  /// when the user performs a doubleTap followed by a swipe. Note that this is enabled by default
  /// if the app targets API 19 and newer.
  ///@param scales true to enable quick scaling, false to disable
  void setQuickScaleEnabled(bool scales) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setQuickScaleEnabled,
      jni.JniType.voidType,
      [scales]).check();

  static final _id_isQuickScaleEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isQuickScaleEnabled", "()Z");

  /// from: public boolean isQuickScaleEnabled()
  ///
  /// Return whether the quick scale gesture, in which the user performs a double tap followed by a
  /// swipe, should perform scaling. {@see \#setQuickScaleEnabled(boolean)}.
  bool isQuickScaleEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isQuickScaleEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setStylusScaleEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setStylusScaleEnabled", "(Z)V");

  /// from: public void setStylusScaleEnabled(boolean scales)
  ///
  /// Sets whether the associates OnScaleGestureListener should receive
  /// onScale callbacks when the user uses a stylus and presses the button.
  /// Note that this is enabled by default if the app targets API 23 and newer.
  ///@param scales true to enable stylus scaling, false to disable.
  void setStylusScaleEnabled(bool scales) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setStylusScaleEnabled,
      jni.JniType.voidType,
      [scales]).check();

  static final _id_isStylusScaleEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isStylusScaleEnabled", "()Z");

  /// from: public boolean isStylusScaleEnabled()
  ///
  /// Return whether the stylus scale gesture, in which the user uses a stylus and presses the
  /// button, should perform scaling. {@see \#setStylusScaleEnabled(boolean)}
  bool isStylusScaleEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isStylusScaleEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_isInProgress =
      jniAccessors.getMethodIDOf(_classRef, "isInProgress", "()Z");

  /// from: public boolean isInProgress()
  ///
  /// Returns {@code true} if a scale gesture is in progress.
  bool isInProgress() => jniAccessors.callMethodWithArgs(
      reference, _id_isInProgress, jni.JniType.booleanType, []).boolean;

  static final _id_getFocusX =
      jniAccessors.getMethodIDOf(_classRef, "getFocusX", "()F");

  /// from: public float getFocusX()
  ///
  /// Get the X coordinate of the current gesture's focal point.
  /// If a gesture is in progress, the focal point is between
  /// each of the pointers forming the gesture.
  ///
  /// If \#isInProgress() would return false, the result of this
  /// function is undefined.
  ///@return X coordinate of the focal point in pixels.
  double getFocusX() => jniAccessors.callMethodWithArgs(
      reference, _id_getFocusX, jni.JniType.floatType, []).float;

  static final _id_getFocusY =
      jniAccessors.getMethodIDOf(_classRef, "getFocusY", "()F");

  /// from: public float getFocusY()
  ///
  /// Get the Y coordinate of the current gesture's focal point.
  /// If a gesture is in progress, the focal point is between
  /// each of the pointers forming the gesture.
  ///
  /// If \#isInProgress() would return false, the result of this
  /// function is undefined.
  ///@return Y coordinate of the focal point in pixels.
  double getFocusY() => jniAccessors.callMethodWithArgs(
      reference, _id_getFocusY, jni.JniType.floatType, []).float;

  static final _id_getCurrentSpan =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentSpan", "()F");

  /// from: public float getCurrentSpan()
  ///
  /// Return the average distance between each of the pointers forming the
  /// gesture in progress through the focal point.
  ///@return Distance between pointers in pixels.
  double getCurrentSpan() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentSpan, jni.JniType.floatType, []).float;

  static final _id_getCurrentSpanX =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentSpanX", "()F");

  /// from: public float getCurrentSpanX()
  ///
  /// Return the average X distance between each of the pointers forming the
  /// gesture in progress through the focal point.
  ///@return Distance between pointers in pixels.
  double getCurrentSpanX() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentSpanX, jni.JniType.floatType, []).float;

  static final _id_getCurrentSpanY =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentSpanY", "()F");

  /// from: public float getCurrentSpanY()
  ///
  /// Return the average Y distance between each of the pointers forming the
  /// gesture in progress through the focal point.
  ///@return Distance between pointers in pixels.
  double getCurrentSpanY() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentSpanY, jni.JniType.floatType, []).float;

  static final _id_getPreviousSpan =
      jniAccessors.getMethodIDOf(_classRef, "getPreviousSpan", "()F");

  /// from: public float getPreviousSpan()
  ///
  /// Return the previous average distance between each of the pointers forming the
  /// gesture in progress through the focal point.
  ///@return Previous distance between pointers in pixels.
  double getPreviousSpan() => jniAccessors.callMethodWithArgs(
      reference, _id_getPreviousSpan, jni.JniType.floatType, []).float;

  static final _id_getPreviousSpanX =
      jniAccessors.getMethodIDOf(_classRef, "getPreviousSpanX", "()F");

  /// from: public float getPreviousSpanX()
  ///
  /// Return the previous average X distance between each of the pointers forming the
  /// gesture in progress through the focal point.
  ///@return Previous distance between pointers in pixels.
  double getPreviousSpanX() => jniAccessors.callMethodWithArgs(
      reference, _id_getPreviousSpanX, jni.JniType.floatType, []).float;

  static final _id_getPreviousSpanY =
      jniAccessors.getMethodIDOf(_classRef, "getPreviousSpanY", "()F");

  /// from: public float getPreviousSpanY()
  ///
  /// Return the previous average Y distance between each of the pointers forming the
  /// gesture in progress through the focal point.
  ///@return Previous distance between pointers in pixels.
  double getPreviousSpanY() => jniAccessors.callMethodWithArgs(
      reference, _id_getPreviousSpanY, jni.JniType.floatType, []).float;

  static final _id_getScaleFactor =
      jniAccessors.getMethodIDOf(_classRef, "getScaleFactor", "()F");

  /// from: public float getScaleFactor()
  ///
  /// Return the scaling factor from the previous scale event to the current
  /// event. This value is defined as
  /// (\#getCurrentSpan() / \#getPreviousSpan()).
  ///@return The current scaling factor.
  double getScaleFactor() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaleFactor, jni.JniType.floatType, []).float;

  static final _id_getTimeDelta =
      jniAccessors.getMethodIDOf(_classRef, "getTimeDelta", "()J");

  /// from: public long getTimeDelta()
  ///
  /// Return the time difference in milliseconds between the previous
  /// accepted scaling event and the current scaling event.
  ///@return Time difference since the last scaling event in milliseconds.
  int getTimeDelta() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimeDelta, jni.JniType.longType, []).long;

  static final _id_getEventTime =
      jniAccessors.getMethodIDOf(_classRef, "getEventTime", "()J");

  /// from: public long getEventTime()
  ///
  /// Return the event time of the current event being processed.
  ///@return Current event time in milliseconds.
  int getEventTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getEventTime, jni.JniType.longType, []).long;
}

/// from: android.view.ScaleGestureDetector$SimpleOnScaleGestureListener
///
/// A convenience class to extend when you only want to listen for a subset
/// of scaling-related events. This implements all methods in
/// OnScaleGestureListener but does nothing.
/// OnScaleGestureListener\#onScale(ScaleGestureDetector) returns
/// {@code false} so that a subclass can retrieve the accumulated scale
/// factor in an overridden onScaleEnd.
/// OnScaleGestureListener\#onScaleBegin(ScaleGestureDetector) returns
/// {@code true}.
class ScaleGestureDetector_SimpleOnScaleGestureListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/ScaleGestureDetector\$SimpleOnScaleGestureListener");
  ScaleGestureDetector_SimpleOnScaleGestureListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ScaleGestureDetector_SimpleOnScaleGestureListener()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onScale = jniAccessors.getMethodIDOf(
      _classRef, "onScale", "(Landroid/view/ScaleGestureDetector;)Z");

  /// from: public boolean onScale(android.view.ScaleGestureDetector detector)
  bool onScale(ScaleGestureDetector detector) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScale,
          jni.JniType.booleanType, [detector.reference]).boolean;

  static final _id_onScaleBegin = jniAccessors.getMethodIDOf(
      _classRef, "onScaleBegin", "(Landroid/view/ScaleGestureDetector;)Z");

  /// from: public boolean onScaleBegin(android.view.ScaleGestureDetector detector)
  bool onScaleBegin(ScaleGestureDetector detector) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScaleBegin,
          jni.JniType.booleanType, [detector.reference]).boolean;

  static final _id_onScaleEnd = jniAccessors.getMethodIDOf(
      _classRef, "onScaleEnd", "(Landroid/view/ScaleGestureDetector;)V");

  /// from: public void onScaleEnd(android.view.ScaleGestureDetector detector)
  void onScaleEnd(ScaleGestureDetector detector) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScaleEnd,
          jni.JniType.voidType, [detector.reference]).check();
}

/// from: android.view.ScaleGestureDetector$OnScaleGestureListener
///
/// The listener for receiving notifications when gestures occur.
/// If you want to listen for all the different gestures then implement
/// this interface. If you only want to listen for a subset it might
/// be easier to extend SimpleOnScaleGestureListener.
///
/// An application will receive events in the following order:
/// <ul>
///  <li>One OnScaleGestureListener\#onScaleBegin(ScaleGestureDetector)
///  <li>Zero or more OnScaleGestureListener\#onScale(ScaleGestureDetector)
///  <li>One OnScaleGestureListener\#onScaleEnd(ScaleGestureDetector)
/// </ul>
class ScaleGestureDetector_OnScaleGestureListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/ScaleGestureDetector\$OnScaleGestureListener");
  ScaleGestureDetector_OnScaleGestureListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onScale = jniAccessors.getMethodIDOf(
      _classRef, "onScale", "(Landroid/view/ScaleGestureDetector;)Z");

  /// from: public abstract boolean onScale(android.view.ScaleGestureDetector detector)
  ///
  /// Responds to scaling events for a gesture in progress.
  /// Reported by pointer motion.
  ///@param detector The detector reporting the event - use this to
  ///          retrieve extended info about event state.
  ///@return Whether or not the detector should consider this event
  ///          as handled. If an event was not handled, the detector
  ///          will continue to accumulate movement until an event is
  ///          handled. This can be useful if an application, for example,
  ///          only wants to update scaling factors if the change is
  ///          greater than 0.01.
  bool onScale(ScaleGestureDetector detector) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScale,
          jni.JniType.booleanType, [detector.reference]).boolean;

  static final _id_onScaleBegin = jniAccessors.getMethodIDOf(
      _classRef, "onScaleBegin", "(Landroid/view/ScaleGestureDetector;)Z");

  /// from: public abstract boolean onScaleBegin(android.view.ScaleGestureDetector detector)
  ///
  /// Responds to the beginning of a scaling gesture. Reported by
  /// new pointers going down.
  ///@param detector The detector reporting the event - use this to
  ///          retrieve extended info about event state.
  ///@return Whether or not the detector should continue recognizing
  ///          this gesture. For example, if a gesture is beginning
  ///          with a focal point outside of a region where it makes
  ///          sense, onScaleBegin() may return false to ignore the
  ///          rest of the gesture.
  bool onScaleBegin(ScaleGestureDetector detector) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScaleBegin,
          jni.JniType.booleanType, [detector.reference]).boolean;

  static final _id_onScaleEnd = jniAccessors.getMethodIDOf(
      _classRef, "onScaleEnd", "(Landroid/view/ScaleGestureDetector;)V");

  /// from: public abstract void onScaleEnd(android.view.ScaleGestureDetector detector)
  ///
  /// Responds to the end of a scale gesture. Reported by existing
  /// pointers going up.
  ///
  /// Once a scale has ended, ScaleGestureDetector\#getFocusX()
  /// and ScaleGestureDetector\#getFocusY() will return focal point
  /// of the pointers remaining on the screen.
  ///@param detector The detector reporting the event - use this to
  ///          retrieve extended info about event state.
  void onScaleEnd(ScaleGestureDetector detector) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScaleEnd,
          jni.JniType.voidType, [detector.reference]).check();
}
