// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "View.dart" as view_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "SurfaceHolder.dart" as surfaceholder_;

import "../graphics/Region.dart" as region_;

import "../graphics/Canvas.dart" as canvas_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.SurfaceView
///
/// Provides a dedicated drawing surface embedded inside of a view hierarchy.
/// You can control the format of this surface and, if you like, its size; the
/// SurfaceView takes care of placing the surface at the correct location on the
/// screen
///
/// The surface is Z ordered so that it is behind the window holding its
/// SurfaceView; the SurfaceView punches a hole in its window to allow its
/// surface to be displayed. The view hierarchy will take care of correctly
/// compositing with the Surface any siblings of the SurfaceView that would
/// normally appear on top of it. This can be used to place overlays such as
/// buttons on top of the Surface, though note however that it can have an
/// impact on performance since a full alpha-blended composite will be performed
/// each time the Surface changes.
///
///  The transparent region that makes the surface visible is based on the
/// layout positions in the view hierarchy. If the post-layout transform
/// properties are used to draw a sibling view on top of the SurfaceView, the
/// view may not be properly composited with the surface.
///
/// Access to the underlying surface is provided via the SurfaceHolder interface,
/// which can be retrieved by calling \#getHolder.
///
/// The Surface will be created for you while the SurfaceView's window is
/// visible; you should implement SurfaceHolder.Callback\#surfaceCreated
/// and SurfaceHolder.Callback\#surfaceDestroyed to discover when the
/// Surface is created and destroyed as the window is shown and hidden.
///
/// One of the purposes of this class is to provide a surface in which a
/// secondary thread can render into the screen. If you are going to use it
/// this way, you need to be aware of some threading semantics:
///
/// <ul>
/// <li> All SurfaceView and
/// SurfaceHolder.Callback SurfaceHolder.Callback methods will be called
/// from the thread running the SurfaceView's window (typically the main thread
/// of the application). They thus need to correctly synchronize with any
/// state that is also touched by the drawing thread.
/// <li> You must ensure that the drawing thread only touches the underlying
/// Surface while it is valid -- between
/// SurfaceHolder.Callback\#surfaceCreated SurfaceHolder.Callback.surfaceCreated()
/// and
/// SurfaceHolder.Callback\#surfaceDestroyed SurfaceHolder.Callback.surfaceDestroyed().
/// </ul>
///
/// <p class="note"><strong>Note:</strong> Starting in platform version
/// android.os.Build.VERSION_CODES\#N, SurfaceView's window position is
/// updated synchronously with other View rendering. This means that translating
/// and scaling a SurfaceView on screen will not cause rendering artifacts. Such
/// artifacts may occur on previous versions of the platform when its window is
/// positioned asynchronously.
///
class SurfaceView extends view_.View {
  static final _classRef = jniAccessors.getClassOf("android/view/SurfaceView");
  SurfaceView.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SurfaceView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SurfaceView.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SurfaceView.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SurfaceView.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_getHolder = jniAccessors.getMethodIDOf(
      _classRef, "getHolder", "()Landroid/view/SurfaceHolder;");

  /// from: public android.view.SurfaceHolder getHolder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the SurfaceHolder providing access and control over this
  /// SurfaceView's underlying surface.
  ///@return SurfaceHolder The holder of the surface.
  surfaceholder_.SurfaceHolder getHolder() =>
      surfaceholder_.SurfaceHolder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHolder, jni.JniType.objectType, []).object);

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onWindowVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "onWindowVisibilityChanged", "(I)V");

  /// from: protected void onWindowVisibilityChanged(int visibility)
  void onWindowVisibilityChanged(int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowVisibilityChanged,
          jni.JniType.voidType, [visibility]).check();

  static final _id_setVisibility =
      jniAccessors.getMethodIDOf(_classRef, "setVisibility", "(I)V");

  /// from: public void setVisibility(int visibility)
  void setVisibility(int visibility) => jniAccessors.callMethodWithArgs(
      reference, _id_setVisibility, jni.JniType.voidType, [visibility]).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_onMeasure =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_gatherTransparentRegion = jniAccessors.getMethodIDOf(
      _classRef, "gatherTransparentRegion", "(Landroid/graphics/Region;)Z");

  /// from: public boolean gatherTransparentRegion(android.graphics.Region region)
  bool gatherTransparentRegion(region_.Region region) =>
      jniAccessors.callMethodWithArgs(reference, _id_gatherTransparentRegion,
          jni.JniType.booleanType, [region.reference]).boolean;

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_dispatchDraw = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_setZOrderMediaOverlay =
      jniAccessors.getMethodIDOf(_classRef, "setZOrderMediaOverlay", "(Z)V");

  /// from: public void setZOrderMediaOverlay(boolean isMediaOverlay)
  ///
  /// Control whether the surface view's surface is placed on top of another
  /// regular surface view in the window (but still behind the window itself).
  /// This is typically used to place overlays on top of an underlying media
  /// surface view.
  ///
  /// Note that this must be set before the surface view's containing
  /// window is attached to the window manager.
  ///
  /// Calling this overrides any previous call to \#setZOrderOnTop.
  void setZOrderMediaOverlay(bool isMediaOverlay) =>
      jniAccessors.callMethodWithArgs(reference, _id_setZOrderMediaOverlay,
          jni.JniType.voidType, [isMediaOverlay]).check();

  static final _id_setZOrderOnTop =
      jniAccessors.getMethodIDOf(_classRef, "setZOrderOnTop", "(Z)V");

  /// from: public void setZOrderOnTop(boolean onTop)
  ///
  /// Control whether the surface view's surface is placed on top of its
  /// window.  Normally it is placed behind the window, to allow it to
  /// (for the most part) appear to composite with the views in the
  /// hierarchy.  By setting this, you cause it to be placed above the
  /// window.  This means that none of the contents of the window this
  /// SurfaceView is in will be visible on top of its surface.
  ///
  /// Note that this must be set before the surface view's containing
  /// window is attached to the window manager.
  ///
  /// Calling this overrides any previous call to \#setZOrderMediaOverlay.
  void setZOrderOnTop(bool onTop) => jniAccessors.callMethodWithArgs(
      reference, _id_setZOrderOnTop, jni.JniType.voidType, [onTop]).check();

  static final _id_setSecure =
      jniAccessors.getMethodIDOf(_classRef, "setSecure", "(Z)V");

  /// from: public void setSecure(boolean isSecure)
  ///
  /// Control whether the surface view's content should be treated as secure,
  /// preventing it from appearing in screenshots or from being viewed on
  /// non-secure displays.
  ///
  /// Note that this must be set before the surface view's containing
  /// window is attached to the window manager.
  ///
  /// See android.view.Display\#FLAG_SECURE for details.
  ///@param isSecure True if the surface view is secure.
  void setSecure(bool isSecure) => jniAccessors.callMethodWithArgs(
      reference, _id_setSecure, jni.JniType.voidType, [isSecure]).check();
}
