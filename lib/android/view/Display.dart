// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../graphics/Point.dart" as point_;

import "../graphics/Rect.dart" as rect_;

import "../util/DisplayMetrics.dart" as displaymetrics_;

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.Display
///
/// Provides information about the size and density of a logical display.
///
/// The display area is described in two different ways.
/// <ul>
/// <li>The application display area specifies the part of the display that may contain
/// an application window, excluding the system decorations.  The application display area may
/// be smaller than the real display area because the system subtracts the space needed
/// for decor elements such as the status bar.  Use the following methods to query the
/// application display area: \#getSize, \#getRectSize and \#getMetrics.</li>
/// <li>The real display area specifies the part of the display that contains content
/// including the system decorations.  Even so, the real display area may be smaller than the
/// physical size of the display if the window manager is emulating a smaller display
/// using (adb shell wm size).  Use the following methods to query the
/// real display area: \#getRealSize, \#getRealMetrics.</li>
/// </ul>
///
///
/// A logical display does not necessarily represent a particular physical display device
/// such as the built-in screen or an external monitor.  The contents of a logical
/// display may be presented on one or more physical displays according to the devices
/// that are currently attached and whether mirroring has been enabled.
///
///
class Display extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/Display");
  Display.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DEFAULT_DISPLAY
  ///
  /// The default Display id, which is the id of the built-in primary display
  /// assuming there is one.
  static const DEFAULT_DISPLAY = 0;

  /// from: static public final int FLAG_PRESENTATION
  ///
  /// Display flag: Indicates that the display is a presentation display.
  ///
  /// This flag identifies secondary displays that are suitable for
  /// use as presentation displays such as HDMI or Wireless displays.  Applications
  /// may automatically project their content to presentation displays to provide
  /// richer second screen experiences.
  ///
  ///
  ///@see \#getFlags
  static const FLAG_PRESENTATION = 8;

  /// from: static public final int FLAG_PRIVATE
  ///
  /// Display flag: Indicates that the display is private.  Only the application that
  /// owns the display and apps that are already on the display can create windows on it.
  ///@see \#getFlags
  static const FLAG_PRIVATE = 4;

  /// from: static public final int FLAG_ROUND
  ///
  /// Display flag: Indicates that the display has a round shape.
  ///
  /// This flag identifies displays that are circular, elliptical or otherwise
  /// do not permit the user to see all the way to the logical corners of the display.
  ///
  ///
  ///@see \#getFlags
  static const FLAG_ROUND = 16;

  /// from: static public final int FLAG_SECURE
  ///
  /// Display flag: Indicates that the display has a secure video output and
  /// supports compositing secure surfaces.
  ///
  /// If this flag is set then the display device has a secure video output
  /// and is capable of showing secure surfaces.  It may also be capable of
  /// showing \#FLAG_SUPPORTS_PROTECTED_BUFFERS protected buffers.
  ///
  ///
  /// If this flag is not set then the display device may not have a secure video
  /// output; the user may see a blank region on the screen instead of
  /// the contents of secure surfaces or protected buffers.
  ///
  ///
  /// Secure surfaces are used to prevent content rendered into those surfaces
  /// by applications from appearing in screenshots or from being viewed
  /// on non-secure displays.  Protected buffers are used by secure video decoders
  /// for a similar purpose.
  ///
  ///
  /// An application creates a window with a secure surface by specifying the
  /// WindowManager.LayoutParams\#FLAG_SECURE window flag.
  /// Likewise, an application creates a SurfaceView with a secure surface
  /// by calling SurfaceView\#setSecure before attaching the secure view to
  /// its containing window.
  ///
  ///
  /// An application can use the absence of this flag as a hint that it should not create
  /// secure surfaces or protected buffers on this display because the content may
  /// not be visible.  For example, if the flag is not set then the application may
  /// choose not to show content on this display, show an informative error message,
  /// select an alternate content stream or adopt a different strategy for decoding
  /// content that does not rely on secure surfaces or protected buffers.
  ///
  ///
  ///@see \#getFlags
  static const FLAG_SECURE = 2;

  /// from: static public final int FLAG_SUPPORTS_PROTECTED_BUFFERS
  ///
  /// Display flag: Indicates that the display supports compositing content
  /// that is stored in protected graphics buffers.
  ///
  /// If this flag is set then the display device supports compositing protected buffers.
  ///
  ///
  /// If this flag is not set then the display device may not support compositing
  /// protected buffers; the user may see a blank region on the screen instead of
  /// the protected content.
  ///
  ///
  /// Secure (DRM) video decoders may allocate protected graphics buffers to request that
  /// a hardware-protected path be provided between the video decoder and the external
  /// display sink.  If a hardware-protected path is not available, then content stored
  /// in protected graphics buffers may not be composited.
  ///
  ///
  /// An application can use the absence of this flag as a hint that it should not use protected
  /// buffers for this display because the content may not be visible.  For example,
  /// if the flag is not set then the application may choose not to show content on this
  /// display, show an informative error message, select an alternate content stream
  /// or adopt a different strategy for decoding content that does not rely on
  /// protected buffers.
  ///
  ///
  ///@see \#getFlags
  static const FLAG_SUPPORTS_PROTECTED_BUFFERS = 1;

  /// from: static public final int INVALID_DISPLAY
  ///
  /// Invalid display id.
  static const INVALID_DISPLAY = -1;

  /// from: static public final int STATE_DOZE
  ///
  /// Display state: The display is dozing in a low power state; it is still
  /// on but is optimized for showing system-provided content while the
  /// device is non-interactive.
  ///@see \#getState
  ///@see android.os.PowerManager\#isInteractive
  static const STATE_DOZE = 3;

  /// from: static public final int STATE_DOZE_SUSPEND
  ///
  /// Display state: The display is dozing in a suspended low power state; it is still
  /// on but the CPU is not updating it. This may be used in one of two ways: to show
  /// static system-provided content while the device is non-interactive, or to allow
  /// a "Sidekick" compute resource to update the display. For this reason, the
  /// CPU must not control the display in this mode.
  ///@see \#getState
  ///@see android.os.PowerManager\#isInteractive
  static const STATE_DOZE_SUSPEND = 4;

  /// from: static public final int STATE_OFF
  ///
  /// Display state: The display is off.
  ///@see \#getState
  static const STATE_OFF = 1;

  /// from: static public final int STATE_ON
  ///
  /// Display state: The display is on.
  ///@see \#getState
  static const STATE_ON = 2;

  /// from: static public final int STATE_ON_SUSPEND
  ///
  /// Display state: The display is in a suspended full power state; it is still
  /// on but the CPU is not updating it. This may be used in one of two ways: to show
  /// static system-provided content while the device is non-interactive, or to allow
  /// a "Sidekick" compute resource to update the display. For this reason, the
  /// CPU must not control the display in this mode.
  ///@see \#getState
  ///@see android.os.PowerManager\#isInteractive
  static const STATE_ON_SUSPEND = 6;

  /// from: static public final int STATE_UNKNOWN
  ///
  /// Display state: The display state is unknown.
  ///@see \#getState
  static const STATE_UNKNOWN = 0;

  /// from: static public final int STATE_VR
  ///
  /// Display state: The display is on and optimized for VR mode.
  ///@see \#getState
  ///@see android.os.PowerManager\#isInteractive
  static const STATE_VR = 5;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Display()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getDisplayId =
      jniAccessors.getMethodIDOf(_classRef, "getDisplayId", "()I");

  /// from: public int getDisplayId()
  ///
  /// Gets the display id.
  ///
  /// Each logical display has a unique id.
  /// The default display has id \#DEFAULT_DISPLAY.
  ///
  ///
  int getDisplayId() => jniAccessors.callMethodWithArgs(
      reference, _id_getDisplayId, jni.JniType.intType, []).integer;

  static final _id_isValid =
      jniAccessors.getMethodIDOf(_classRef, "isValid", "()Z");

  /// from: public boolean isValid()
  ///
  /// Returns true if this display is still valid, false if the display has been removed.
  ///
  /// If the display is invalid, then the methods of this class will
  /// continue to report the most recently observed display information.
  /// However, it is unwise (and rather fruitless) to continue using a
  /// Display object after the display's demise.
  ///
  /// It's possible for a display that was previously invalid to become
  /// valid again if a display with the same id is reconnected.
  ///@return True if the display is still valid.
  bool isValid() => jniAccessors.callMethodWithArgs(
      reference, _id_isValid, jni.JniType.booleanType, []).boolean;

  static final _id_getFlags =
      jniAccessors.getMethodIDOf(_classRef, "getFlags", "()I");

  /// from: public int getFlags()
  ///
  /// Returns a combination of flags that describe the capabilities of the display.
  ///@return The display flags.
  ///@see \#FLAG_SUPPORTS_PROTECTED_BUFFERS
  ///@see \#FLAG_SECURE
  ///@see \#FLAG_PRIVATE
  int getFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getFlags, jni.JniType.intType, []).integer;

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the name of the display.
  ///
  /// Note that some displays may be renamed by the user.
  ///
  ///
  ///@return The display's name.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_getSize = jniAccessors.getMethodIDOf(
      _classRef, "getSize", "(Landroid/graphics/Point;)V");

  /// from: public void getSize(android.graphics.Point outSize)
  ///
  /// Gets the size of the display, in pixels.
  /// Value returned by this method does not necessarily represent the actual raw size
  /// (native resolution) of the display.
  ///
  /// 1. The returned size may be adjusted to exclude certain system decor elements
  /// that are always visible.
  ///
  ///
  /// 2. It may be scaled to provide compatibility with older applications that
  /// were originally designed for smaller displays.
  ///
  ///
  /// 3. It can be different depending on the WindowManager to which the display belongs.
  ///
  ///
  /// - If requested from non-Activity context (e.g. Application context via
  /// {@code (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE)})
  /// it will report the size of the entire display based on current rotation and with subtracted
  /// system decoration areas.
  ///
  ///
  /// - If requested from activity (either using {@code getWindowManager()} or
  /// {@code (WindowManager) getSystemService(Context.WINDOW_SERVICE)}) resulting size will
  /// correspond to current app window size. In this case it can be smaller than physical size in
  /// multi-window mode.
  ///
  ///
  /// Typically for the purposes of layout apps should make a request from activity context
  /// to obtain size available for the app content.
  ///
  ///
  ///@param outSize A Point object to receive the size information.
  void getSize(point_.Point outSize) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getSize,
      jni.JniType.voidType,
      [outSize.reference]).check();

  static final _id_getRectSize = jniAccessors.getMethodIDOf(
      _classRef, "getRectSize", "(Landroid/graphics/Rect;)V");

  /// from: public void getRectSize(android.graphics.Rect outSize)
  ///
  /// Gets the size of the display as a rectangle, in pixels.
  ///@param outSize A Rect object to receive the size information.
  ///@see \#getSize(Point)
  void getRectSize(rect_.Rect outSize) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getRectSize,
      jni.JniType.voidType,
      [outSize.reference]).check();

  static final _id_getCurrentSizeRange = jniAccessors.getMethodIDOf(
      _classRef,
      "getCurrentSizeRange",
      "(Landroid/graphics/Point;Landroid/graphics/Point;)V");

  /// from: public void getCurrentSizeRange(android.graphics.Point outSmallestSize, android.graphics.Point outLargestSize)
  ///
  /// Return the range of display sizes an application can expect to encounter
  /// under normal operation, as long as there is no physical change in screen
  /// size.  This is basically the sizes you will see as the orientation
  /// changes, taking into account whatever screen decoration there is in
  /// each rotation.  For example, the status bar is always at the top of the
  /// screen, so it will reduce the height both in landscape and portrait, and
  /// the smallest height returned here will be the smaller of the two.
  ///
  /// This is intended for applications to get an idea of the range of sizes
  /// they will encounter while going through device rotations, to provide a
  /// stable UI through rotation.  The sizes here take into account all standard
  /// system decorations that reduce the size actually available to the
  /// application: the status bar, navigation bar, system bar, etc.  It does
  /// _not_ take into account more transient elements like an IME
  /// soft keyboard.
  ///@param outSmallestSize Filled in with the smallest width and height
  /// that the application will encounter, in pixels (not dp units).  The x
  /// (width) dimension here directly corresponds to
  /// android.content.res.Configuration\#smallestScreenWidthDp Configuration.smallestScreenWidthDp, except the value here is in raw
  /// screen pixels rather than dp units.  Your application may of course
  /// still get smaller space yet if, for example, a soft keyboard is
  /// being displayed.
  ///@param outLargestSize Filled in with the largest width and height
  /// that the application will encounter, in pixels (not dp units).  Your
  /// application may of course still get larger space than this if,
  /// for example, screen decorations like the status bar are being hidden.
  void getCurrentSizeRange(
          point_.Point outSmallestSize, point_.Point outLargestSize) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getCurrentSizeRange,
          jni.JniType.voidType,
          [outSmallestSize.reference, outLargestSize.reference]).check();

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// @deprecated Use \#getSize(Point) instead.
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// @deprecated Use \#getSize(Point) instead.
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getRotation =
      jniAccessors.getMethodIDOf(_classRef, "getRotation", "()I");

  /// from: public int getRotation()
  ///
  /// Returns the rotation of the screen from its "natural" orientation.
  /// The returned value may be Surface\#ROTATION_0 Surface.ROTATION_0
  /// (no rotation), Surface\#ROTATION_90 Surface.ROTATION_90,
  /// Surface\#ROTATION_180 Surface.ROTATION_180, or
  /// Surface\#ROTATION_270 Surface.ROTATION_270.  For
  /// example, if a device has a naturally tall screen, and the user has
  /// turned it on its side to go into a landscape orientation, the value
  /// returned here may be either Surface\#ROTATION_90 Surface.ROTATION_90
  /// or Surface\#ROTATION_270 Surface.ROTATION_270 depending on
  /// the direction it was turned.  The angle is the rotation of the drawn
  /// graphics on the screen, which is the opposite direction of the physical
  /// rotation of the device.  For example, if the device is rotated 90
  /// degrees counter-clockwise, to compensate rendering will be rotated by
  /// 90 degrees clockwise and thus the returned value here will be
  /// Surface\#ROTATION_90 Surface.ROTATION_90.
  ///@return Value is android.view.Surface\#ROTATION_0, android.view.Surface\#ROTATION_90, android.view.Surface\#ROTATION_180, or android.view.Surface\#ROTATION_270
  int getRotation() => jniAccessors.callMethodWithArgs(
      reference, _id_getRotation, jni.JniType.intType, []).integer;

  static final _id_getOrientation =
      jniAccessors.getMethodIDOf(_classRef, "getOrientation", "()I");

  /// from: public int getOrientation()
  ///
  /// @deprecated use \#getRotation
  ///@return orientation of this display.
  ///
  /// Value is android.view.Surface\#ROTATION_0, android.view.Surface\#ROTATION_90, android.view.Surface\#ROTATION_180, or android.view.Surface\#ROTATION_270
  int getOrientation() => jniAccessors.callMethodWithArgs(
      reference, _id_getOrientation, jni.JniType.intType, []).integer;

  static final _id_getPixelFormat =
      jniAccessors.getMethodIDOf(_classRef, "getPixelFormat", "()I");

  /// from: public int getPixelFormat()
  ///
  /// Gets the pixel format of the display.
  ///@return One of the constants defined in android.graphics.PixelFormat.
  ///@deprecated This method is no longer supported.
  /// The result is always PixelFormat\#RGBA_8888.
  int getPixelFormat() => jniAccessors.callMethodWithArgs(
      reference, _id_getPixelFormat, jni.JniType.intType, []).integer;

  static final _id_getRefreshRate =
      jniAccessors.getMethodIDOf(_classRef, "getRefreshRate", "()F");

  /// from: public float getRefreshRate()
  ///
  /// Gets the refresh rate of this display in frames per second.
  double getRefreshRate() => jniAccessors.callMethodWithArgs(
      reference, _id_getRefreshRate, jni.JniType.floatType, []).float;

  static final _id_getSupportedRefreshRates =
      jniAccessors.getMethodIDOf(_classRef, "getSupportedRefreshRates", "()[F");

  /// from: public float[] getSupportedRefreshRates()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the supported refresh rates of this display in frames per second.
  ///
  /// This method only returns refresh rates for the display's default modes. For more options, use
  /// \#getSupportedModes().
  ///@deprecated use \#getSupportedModes() instead
  jni.JniObject getSupportedRefreshRates() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedRefreshRates, jni.JniType.objectType, []).object);

  static final _id_getMode = jniAccessors.getMethodIDOf(
      _classRef, "getMode", "()Landroid/view/Display\$Mode;");

  /// from: public android.view.Display.Mode getMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the active mode of the display.
  Display_Mode getMode() =>
      Display_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMode, jni.JniType.objectType, []).object);

  static final _id_getSupportedModes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedModes", "()[Landroid/view/Display\$Mode;");

  /// from: public android.view.Display.Mode[] getSupportedModes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported modes of this display.
  jni.JniObject getSupportedModes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSupportedModes, jni.JniType.objectType, []).object);

  static final _id_getHdrCapabilities = jniAccessors.getMethodIDOf(_classRef,
      "getHdrCapabilities", "()Landroid/view/Display\$HdrCapabilities;");

  /// from: public android.view.Display.HdrCapabilities getHdrCapabilities()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the display's HDR capabilities.
  ///@see \#isHdr()
  Display_HdrCapabilities getHdrCapabilities() =>
      Display_HdrCapabilities.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getHdrCapabilities, jni.JniType.objectType, []).object);

  static final _id_isHdr =
      jniAccessors.getMethodIDOf(_classRef, "isHdr", "()Z");

  /// from: public boolean isHdr()
  ///
  /// Returns whether this display supports any HDR type.
  ///@see \#getHdrCapabilities()
  ///@see HdrCapabilities\#getSupportedHdrTypes()
  bool isHdr() => jniAccessors.callMethodWithArgs(
      reference, _id_isHdr, jni.JniType.booleanType, []).boolean;

  static final _id_isWideColorGamut =
      jniAccessors.getMethodIDOf(_classRef, "isWideColorGamut", "()Z");

  /// from: public boolean isWideColorGamut()
  ///
  /// Returns whether this display can be used to display wide color gamut content.
  /// This does not necessarily mean the device itself can render wide color gamut
  /// content. To ensure wide color gamut content can be produced, refer to
  /// Configuration\#isScreenWideColorGamut().
  bool isWideColorGamut() => jniAccessors.callMethodWithArgs(
      reference, _id_isWideColorGamut, jni.JniType.booleanType, []).boolean;

  static final _id_getAppVsyncOffsetNanos =
      jniAccessors.getMethodIDOf(_classRef, "getAppVsyncOffsetNanos", "()J");

  /// from: public long getAppVsyncOffsetNanos()
  ///
  /// Gets the app VSYNC offset, in nanoseconds.  This is a positive value indicating
  /// the phase offset of the VSYNC events provided by Choreographer relative to the
  /// display refresh.  For example, if Choreographer reports that the refresh occurred
  /// at time N, it actually occurred at (N - appVsyncOffset).
  ///
  /// Apps generally do not need to be aware of this.  It's only useful for fine-grained
  /// A/V synchronization.
  int getAppVsyncOffsetNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_getAppVsyncOffsetNanos, jni.JniType.longType, []).long;

  static final _id_getPresentationDeadlineNanos = jniAccessors.getMethodIDOf(
      _classRef, "getPresentationDeadlineNanos", "()J");

  /// from: public long getPresentationDeadlineNanos()
  ///
  /// This is how far in advance a buffer must be queued for presentation at
  /// a given time.  If you want a buffer to appear on the screen at
  /// time N, you must submit the buffer before (N - presentationDeadline).
  ///
  /// The desired presentation time for GLES rendering may be set with
  /// android.opengl.EGLExt\#eglPresentationTimeANDROID.  For video decoding, use
  /// android.media.MediaCodec\#releaseOutputBuffer(int, long).  Times are
  /// expressed in nanoseconds, using the system monotonic clock
  /// (System\#nanoTime).
  int getPresentationDeadlineNanos() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPresentationDeadlineNanos,
      jni.JniType.longType, []).long;

  static final _id_getMetrics = jniAccessors.getMethodIDOf(
      _classRef, "getMetrics", "(Landroid/util/DisplayMetrics;)V");

  /// from: public void getMetrics(android.util.DisplayMetrics outMetrics)
  ///
  /// Gets display metrics that describe the size and density of this display.
  /// The size returned by this method does not necessarily represent the
  /// actual raw size (native resolution) of the display.
  ///
  /// 1. The returned size may be adjusted to exclude certain system decor elements
  /// that are always visible.
  ///
  ///
  /// 2. It may be scaled to provide compatibility with older applications that
  /// were originally designed for smaller displays.
  ///
  ///
  /// 3. It can be different depending on the WindowManager to which the display belongs.
  ///
  ///
  /// - If requested from non-Activity context (e.g. Application context via
  /// {@code (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE)})
  /// metrics will report the size of the entire display based on current rotation and with
  /// subtracted system decoration areas.
  ///
  ///
  /// - If requested from activity (either using {@code getWindowManager()} or
  /// {@code (WindowManager) getSystemService(Context.WINDOW_SERVICE)}) resulting metrics will
  /// correspond to current app window metrics. In this case the size can be smaller than physical
  /// size in multi-window mode.
  ///
  ///
  ///@param outMetrics A DisplayMetrics object to receive the metrics.
  void getMetrics(displaymetrics_.DisplayMetrics outMetrics) =>
      jniAccessors.callMethodWithArgs(reference, _id_getMetrics,
          jni.JniType.voidType, [outMetrics.reference]).check();

  static final _id_getRealSize = jniAccessors.getMethodIDOf(
      _classRef, "getRealSize", "(Landroid/graphics/Point;)V");

  /// from: public void getRealSize(android.graphics.Point outSize)
  ///
  /// Gets the real size of the display without subtracting any window decor or
  /// applying any compatibility scale factors.
  ///
  /// The size is adjusted based on the current rotation of the display.
  ///
  ///
  /// The real size may be smaller than the physical size of the screen when the
  /// window manager is emulating a smaller display (using adb shell wm size).
  ///
  ///
  ///@param outSize Set to the real size of the display.
  void getRealSize(point_.Point outSize) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getRealSize,
      jni.JniType.voidType,
      [outSize.reference]).check();

  static final _id_getRealMetrics = jniAccessors.getMethodIDOf(
      _classRef, "getRealMetrics", "(Landroid/util/DisplayMetrics;)V");

  /// from: public void getRealMetrics(android.util.DisplayMetrics outMetrics)
  ///
  /// Gets display metrics based on the real size of this display.
  ///
  /// The size is adjusted based on the current rotation of the display.
  ///
  ///
  /// The real size may be smaller than the physical size of the screen when the
  /// window manager is emulating a smaller display (using adb shell wm size).
  ///
  ///
  ///@param outMetrics A DisplayMetrics object to receive the metrics.
  void getRealMetrics(displaymetrics_.DisplayMetrics outMetrics) =>
      jniAccessors.callMethodWithArgs(reference, _id_getRealMetrics,
          jni.JniType.voidType, [outMetrics.reference]).check();

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public int getState()
  ///
  /// Gets the state of the display, such as whether it is on or off.
  ///@return The state of the display: one of \#STATE_OFF, \#STATE_ON,
  /// \#STATE_DOZE, \#STATE_DOZE_SUSPEND, \#STATE_ON_SUSPEND, or
  /// \#STATE_UNKNOWN.
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.view.Display$Mode
///
/// A mode supported by a given display.
///@see Display\#getSupportedModes()
class Display_Mode extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/Display\$Mode");
  Display_Mode.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.Display.Mode> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Display_Mode(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [in0.reference]).object);

  static final _id_getModeId =
      jniAccessors.getMethodIDOf(_classRef, "getModeId", "()I");

  /// from: public int getModeId()
  ///
  /// Returns this mode's id.
  int getModeId() => jniAccessors.callMethodWithArgs(
      reference, _id_getModeId, jni.JniType.intType, []).integer;

  static final _id_getPhysicalWidth =
      jniAccessors.getMethodIDOf(_classRef, "getPhysicalWidth", "()I");

  /// from: public int getPhysicalWidth()
  ///
  /// Returns the physical width of the display in pixels when configured in this mode's
  /// resolution.
  ///
  /// Note that due to application UI scaling, the number of pixels made available to
  /// applications when the mode is active (as reported by Display\#getWidth() may
  /// differ from the mode's actual resolution (as reported by this function).
  ///
  /// For example, applications running on a 4K display may have their UI laid out and rendered
  /// in 1080p and then scaled up. Applications can take advantage of the extra resolution by
  /// rendering content through a android.view.SurfaceView using full size buffers.
  int getPhysicalWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getPhysicalWidth, jni.JniType.intType, []).integer;

  static final _id_getPhysicalHeight =
      jniAccessors.getMethodIDOf(_classRef, "getPhysicalHeight", "()I");

  /// from: public int getPhysicalHeight()
  ///
  /// Returns the physical height of the display in pixels when configured in this mode's
  /// resolution.
  ///
  /// Note that due to application UI scaling, the number of pixels made available to
  /// applications when the mode is active (as reported by Display\#getHeight() may
  /// differ from the mode's actual resolution (as reported by this function).
  ///
  /// For example, applications running on a 4K display may have their UI laid out and rendered
  /// in 1080p and then scaled up. Applications can take advantage of the extra resolution by
  /// rendering content through a android.view.SurfaceView using full size buffers.
  int getPhysicalHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getPhysicalHeight, jni.JniType.intType, []).integer;

  static final _id_getRefreshRate =
      jniAccessors.getMethodIDOf(_classRef, "getRefreshRate", "()F");

  /// from: public float getRefreshRate()
  ///
  /// Returns the refresh rate in frames per second.
  double getRefreshRate() => jniAccessors.callMethodWithArgs(
      reference, _id_getRefreshRate, jni.JniType.floatType, []).float;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  bool equals1(jni.JniObject other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int parcelableFlags)
  void writeToParcel(parcel_.Parcel out, int parcelableFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, parcelableFlags]).check();
}

/// from: android.view.Display$HdrCapabilities
///
/// Encapsulates the HDR capabilities of a given display.
/// For example, what HDR types it supports and details about the desired luminance data.
/// You can get an instance for a given Display object with
/// Display\#getHdrCapabilities getHdrCapabilities().
class Display_HdrCapabilities extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/Display\$HdrCapabilities");
  Display_HdrCapabilities.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.Display.HdrCapabilities> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int HDR_TYPE_DOLBY_VISION
  ///
  /// Dolby Vision high dynamic range (HDR) display.
  static const HDR_TYPE_DOLBY_VISION = 1;

  /// from: static public final int HDR_TYPE_HDR10
  ///
  /// HDR10 display.
  static const HDR_TYPE_HDR10 = 2;

  /// from: static public final int HDR_TYPE_HLG
  ///
  /// Hybrid Log-Gamma HDR display.
  static const HDR_TYPE_HLG = 3;

  /// from: static public final float INVALID_LUMINANCE
  ///
  /// Invalid luminance value.
  static const INVALID_LUMINANCE = -1.0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  Display_HdrCapabilities()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getSupportedHdrTypes =
      jniAccessors.getMethodIDOf(_classRef, "getSupportedHdrTypes", "()[I");

  /// from: public int[] getSupportedHdrTypes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported HDR types of this display.
  /// Returns empty array if HDR is not supported by the display.
  ///@return Value is android.view.Display.HdrCapabilities\#HDR_TYPE_DOLBY_VISION, android.view.Display.HdrCapabilities\#HDR_TYPE_HDR10, or android.view.Display.HdrCapabilities\#HDR_TYPE_HLG
  jni.JniObject getSupportedHdrTypes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedHdrTypes, jni.JniType.objectType, []).object);

  static final _id_getDesiredMaxLuminance =
      jniAccessors.getMethodIDOf(_classRef, "getDesiredMaxLuminance", "()F");

  /// from: public float getDesiredMaxLuminance()
  ///
  /// Returns the desired content max luminance data in cd/m2 for this display.
  double getDesiredMaxLuminance() => jniAccessors.callMethodWithArgs(
      reference, _id_getDesiredMaxLuminance, jni.JniType.floatType, []).float;

  static final _id_getDesiredMaxAverageLuminance = jniAccessors.getMethodIDOf(
      _classRef, "getDesiredMaxAverageLuminance", "()F");

  /// from: public float getDesiredMaxAverageLuminance()
  ///
  /// Returns the desired content max frame-average luminance data in cd/m2 for this display.
  double getDesiredMaxAverageLuminance() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDesiredMaxAverageLuminance,
      jni.JniType.floatType, []).float;

  static final _id_getDesiredMinLuminance =
      jniAccessors.getMethodIDOf(_classRef, "getDesiredMinLuminance", "()F");

  /// from: public float getDesiredMinLuminance()
  ///
  /// Returns the desired content min luminance data in cd/m2 for this display.
  double getDesiredMinLuminance() => jniAccessors.callMethodWithArgs(
      reference, _id_getDesiredMinLuminance, jni.JniType.floatType, []).float;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  bool equals1(jni.JniObject other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;
}
