// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Animation.dart" as animation_;

import "Interpolator.dart" as interpolator_;

import "../../content/Context.dart" as context_;

import "../../util/AttributeSet.dart" as attributeset_;

import "../View.dart" as view_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.animation.LayoutAnimationController
///
/// A layout animation controller is used to animated a layout's, or a view
/// group's, children. Each child uses the same animation but for every one of
/// them, the animation starts at a different time. A layout animation controller
/// is used by android.view.ViewGroup to compute the delay by which each
/// child's animation start must be offset. The delay is computed by using
/// characteristics of each child, like its index in the view group.
///
/// This standard implementation computes the delay by multiplying a fixed
/// amount of miliseconds by the index of the child in its parent view group.
/// Subclasses are supposed to override
/// \#getDelayForView(android.view.View) to implement a different way
/// of computing the delay. For instance, a
/// android.view.animation.GridLayoutAnimationController will compute the
/// delay based on the column and row indices of the child in its parent view
/// group.
///
/// Information used to compute the animation delay of each child are stored
/// in an instance of
/// android.view.animation.LayoutAnimationController.AnimationParameters,
/// itself stored in the android.view.ViewGroup.LayoutParams of the view.
///@attr ref android.R.styleable\#LayoutAnimation_delay
///@attr ref android.R.styleable\#LayoutAnimation_animationOrder
///@attr ref android.R.styleable\#LayoutAnimation_interpolator
///@attr ref android.R.styleable\#LayoutAnimation_animation
class LayoutAnimationController extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/animation/LayoutAnimationController");
  LayoutAnimationController.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ORDER_NORMAL
  ///
  /// Distributes the animation delays in the order in which view were added
  /// to their view group.
  static const ORDER_NORMAL = 0;

  /// from: static public final int ORDER_RANDOM
  ///
  /// Randomly distributes the animation delays.
  static const ORDER_RANDOM = 2;

  /// from: static public final int ORDER_REVERSE
  ///
  /// Distributes the animation delays in the reverse order in which view were
  /// added to their view group.
  static const ORDER_REVERSE = 1;

  static final _id_mAnimation = jniAccessors.getFieldIDOf(
      _classRef, "mAnimation", "Landroid/view/animation/Animation;");

  /// from: protected android.view.animation.Animation mAnimation
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The animation applied on each child of the view group on which this
  /// layout animation controller is set.
  animation_.Animation get mAnimation =>
      animation_.Animation.fromRef(jniAccessors
          .getField(reference, _id_mAnimation, jni.JniType.objectType)
          .object);

  /// from: protected android.view.animation.Animation mAnimation
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The animation applied on each child of the view group on which this
  /// layout animation controller is set.
  set mAnimation(animation_.Animation value) =>
      jniEnv.SetObjectField(reference, _id_mAnimation, value.reference);

  static final _id_mInterpolator = jniAccessors.getFieldIDOf(
      _classRef, "mInterpolator", "Landroid/view/animation/Interpolator;");

  /// from: protected android.view.animation.Interpolator mInterpolator
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The interpolator used to interpolate the delays.
  interpolator_.Interpolator get mInterpolator =>
      interpolator_.Interpolator.fromRef(jniAccessors
          .getField(reference, _id_mInterpolator, jni.JniType.objectType)
          .object);

  /// from: protected android.view.animation.Interpolator mInterpolator
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The interpolator used to interpolate the delays.
  set mInterpolator(interpolator_.Interpolator value) =>
      jniEnv.SetObjectField(reference, _id_mInterpolator, value.reference);

  static final _id_mRandomizer =
      jniAccessors.getFieldIDOf(_classRef, "mRandomizer", "Ljava/util/Random;");

  /// from: protected java.util.Random mRandomizer
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The randomizer used when the order is set to random. Subclasses should
  /// use this object to avoid creating their own.
  jni.JniObject get mRandomizer => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_mRandomizer, jni.JniType.objectType)
      .object);

  /// from: protected java.util.Random mRandomizer
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The randomizer used when the order is set to random. Subclasses should
  /// use this object to avoid creating their own.
  set mRandomizer(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_mRandomizer, value.reference);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new layout animation controller from external resources.
  ///@param context the Context the view  group is running in, through which
  ///        it can access the resources
  ///@param attrs the attributes of the XML tag that is inflating the
  ///        layout animation controller
  LayoutAnimationController(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference, attrs.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/animation/Animation;)V");

  /// from: public void <init>(android.view.animation.Animation animation)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new layout animation controller with a delay of 50%
  /// and the specified animation.
  ///@param animation the animation to use on each child of the view group
  LayoutAnimationController.ctor1(animation_.Animation animation)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [animation.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/animation/Animation;F)V");

  /// from: public void <init>(android.view.animation.Animation animation, float delay)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new layout animation controller with the specified delay
  /// and the specified animation.
  ///@param animation the animation to use on each child of the view group
  ///@param delay the delay by which each child's animation must be offset
  LayoutAnimationController.ctor2(animation_.Animation animation, double delay)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [animation.reference, delay]).object);

  static final _id_getOrder =
      jniAccessors.getMethodIDOf(_classRef, "getOrder", "()I");

  /// from: public int getOrder()
  ///
  /// Returns the order used to compute the delay of each child's animation.
  ///@return one of \#ORDER_NORMAL, \#ORDER_REVERSE or
  ///         \#ORDER_RANDOM
  ///@attr ref android.R.styleable\#LayoutAnimation_animationOrder
  int getOrder() => jniAccessors.callMethodWithArgs(
      reference, _id_getOrder, jni.JniType.intType, []).integer;

  static final _id_setOrder =
      jniAccessors.getMethodIDOf(_classRef, "setOrder", "(I)V");

  /// from: public void setOrder(int order)
  ///
  /// Sets the order used to compute the delay of each child's animation.
  ///@param order one of \#ORDER_NORMAL, \#ORDER_REVERSE or
  ///        \#ORDER_RANDOM
  ///@attr ref android.R.styleable\#LayoutAnimation_animationOrder
  void setOrder(int order) => jniAccessors.callMethodWithArgs(
      reference, _id_setOrder, jni.JniType.voidType, [order]).check();

  static final _id_setAnimation = jniAccessors.getMethodIDOf(
      _classRef, "setAnimation", "(Landroid/content/Context;I)V");

  /// from: public void setAnimation(android.content.Context context, int resourceID)
  ///
  /// Sets the animation to be run on each child of the view group on which
  /// this layout animation controller is .
  ///@param context the context from which the animation must be inflated
  ///@param resourceID the resource identifier of the animation
  ///@see \#setAnimation(Animation)
  ///@see \#getAnimation()
  ///@attr ref android.R.styleable\#LayoutAnimation_animation
  void setAnimation(context_.Context context, int resourceID) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAnimation,
          jni.JniType.voidType, [context.reference, resourceID]).check();

  static final _id_setAnimation1 = jniAccessors.getMethodIDOf(
      _classRef, "setAnimation", "(Landroid/view/animation/Animation;)V");

  /// from: public void setAnimation(android.view.animation.Animation animation)
  ///
  /// Sets the animation to be run on each child of the view group on which
  /// this layout animation controller is .
  ///@param animation the animation to run on each child of the view group
  ///@see \#setAnimation(android.content.Context, int)
  ///@see \#getAnimation()
  ///@attr ref android.R.styleable\#LayoutAnimation_animation
  void setAnimation1(animation_.Animation animation) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAnimation1,
          jni.JniType.voidType, [animation.reference]).check();

  static final _id_getAnimation = jniAccessors.getMethodIDOf(
      _classRef, "getAnimation", "()Landroid/view/animation/Animation;");

  /// from: public android.view.animation.Animation getAnimation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the animation applied to each child of the view group on which
  /// this controller is set.
  ///@return an android.view.animation.Animation instance
  ///@see \#setAnimation(android.content.Context, int)
  ///@see \#setAnimation(Animation)
  animation_.Animation getAnimation() =>
      animation_.Animation.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAnimation, jni.JniType.objectType, []).object);

  static final _id_setInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "setInterpolator", "(Landroid/content/Context;I)V");

  /// from: public void setInterpolator(android.content.Context context, int resourceID)
  ///
  /// Sets the interpolator used to interpolate the delays between the
  /// children.
  ///@param context the context from which the interpolator must be inflated
  ///@param resourceID the resource identifier of the interpolator
  ///@see \#getInterpolator()
  ///@see \#setInterpolator(Interpolator)
  ///@attr ref android.R.styleable\#LayoutAnimation_interpolator
  void setInterpolator(context_.Context context, int resourceID) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInterpolator,
          jni.JniType.voidType, [context.reference, resourceID]).check();

  static final _id_setInterpolator1 = jniAccessors.getMethodIDOf(
      _classRef, "setInterpolator", "(Landroid/view/animation/Interpolator;)V");

  /// from: public void setInterpolator(android.view.animation.Interpolator interpolator)
  ///
  /// Sets the interpolator used to interpolate the delays between the
  /// children.
  ///@param interpolator the interpolator
  ///@see \#getInterpolator()
  ///@see \#setInterpolator(Interpolator)
  ///@attr ref android.R.styleable\#LayoutAnimation_interpolator
  void setInterpolator1(interpolator_.Interpolator interpolator) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInterpolator1,
          jni.JniType.voidType, [interpolator.reference]).check();

  static final _id_getInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "getInterpolator", "()Landroid/view/animation/Interpolator;");

  /// from: public android.view.animation.Interpolator getInterpolator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the interpolator used to interpolate the delays between the
  /// children.
  ///@return an android.view.animation.Interpolator
  interpolator_.Interpolator getInterpolator() =>
      interpolator_.Interpolator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getInterpolator, jni.JniType.objectType, []).object);

  static final _id_getDelay =
      jniAccessors.getMethodIDOf(_classRef, "getDelay", "()F");

  /// from: public float getDelay()
  ///
  /// Returns the delay by which the children's animation are offset. The
  /// delay is expressed as a fraction of the animation duration.
  ///@return a fraction of the animation duration
  ///@see \#setDelay(float)
  double getDelay() => jniAccessors.callMethodWithArgs(
      reference, _id_getDelay, jni.JniType.floatType, []).float;

  static final _id_setDelay =
      jniAccessors.getMethodIDOf(_classRef, "setDelay", "(F)V");

  /// from: public void setDelay(float delay)
  ///
  /// Sets the delay, as a fraction of the animation duration, by which the
  /// children's animations are offset. The general formula is:
  ///
  /// <pre>
  /// child animation delay = child index * delay * animation duration
  /// </pre>
  ///@param delay a fraction of the animation duration
  ///@see \#getDelay()
  void setDelay(double delay) => jniAccessors.callMethodWithArgs(
      reference, _id_setDelay, jni.JniType.voidType, [delay]).check();

  static final _id_willOverlap =
      jniAccessors.getMethodIDOf(_classRef, "willOverlap", "()Z");

  /// from: public boolean willOverlap()
  ///
  /// Indicates whether two children's animations will overlap. Animations
  /// overlap when the delay is lower than 100% (or 1.0).
  ///@return true if animations will overlap, false otherwise
  bool willOverlap() => jniAccessors.callMethodWithArgs(
      reference, _id_willOverlap, jni.JniType.booleanType, []).boolean;

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "()V");

  /// from: public void start()
  ///
  /// Starts the animation.
  void start() => jniAccessors.callMethodWithArgs(
      reference, _id_start, jni.JniType.voidType, []).check();

  static final _id_getAnimationForView = jniAccessors.getMethodIDOf(
      _classRef,
      "getAnimationForView",
      "(Landroid/view/View;)Landroid/view/animation/Animation;");

  /// from: public final android.view.animation.Animation getAnimationForView(android.view.View view)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the animation to be applied to the specified view. The returned
  /// animation is delayed by an offset computed according to the information
  /// provided by
  /// android.view.animation.LayoutAnimationController.AnimationParameters.
  /// This method is called by view groups to obtain the animation to set on
  /// a specific child.
  ///@param view the view to animate
  ///@return an animation delayed by the number of milliseconds returned by
  ///         \#getDelayForView(android.view.View)
  ///@see \#getDelay()
  ///@see \#setDelay(float)
  ///@see \#getDelayForView(android.view.View)
  animation_.Animation getAnimationForView(view_.View view) =>
      animation_.Animation.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAnimationForView,
          jni.JniType.objectType,
          [view.reference]).object);

  static final _id_isDone =
      jniAccessors.getMethodIDOf(_classRef, "isDone", "()Z");

  /// from: public boolean isDone()
  ///
  /// Indicates whether the layout animation is over or not. A layout animation
  /// is considered done when the animation with the longest delay is done.
  ///@return true if all of the children's animations are over, false otherwise
  bool isDone() => jniAccessors.callMethodWithArgs(
      reference, _id_isDone, jni.JniType.booleanType, []).boolean;

  static final _id_getDelayForView = jniAccessors.getMethodIDOf(
      _classRef, "getDelayForView", "(Landroid/view/View;)J");

  /// from: protected long getDelayForView(android.view.View view)
  ///
  /// Returns the amount of milliseconds by which the specified view's
  /// animation must be delayed or offset. Subclasses should override this
  /// method to return a suitable value.
  ///
  /// This implementation returns <code>child animation delay</code>
  /// milliseconds where:
  ///
  /// <pre>
  /// child animation delay = child index * delay
  /// </pre>
  ///
  /// The index is retrieved from the
  /// android.view.animation.LayoutAnimationController.AnimationParameters
  /// found in the view's android.view.ViewGroup.LayoutParams.
  ///@param view the view for which to obtain the animation's delay
  ///@return a delay in milliseconds
  ///@see \#getAnimationForView(android.view.View)
  ///@see \#getDelay()
  ///@see \#getTransformedIndex(android.view.animation.LayoutAnimationController.AnimationParameters)
  ///@see android.view.ViewGroup.LayoutParams
  int getDelayForView(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDelayForView,
      jni.JniType.longType,
      [view.reference]).long;

  static final _id_getTransformedIndex = jniAccessors.getMethodIDOf(
      _classRef,
      "getTransformedIndex",
      "(Landroid/view/animation/LayoutAnimationController\$AnimationParameters;)I");

  /// from: protected int getTransformedIndex(android.view.animation.LayoutAnimationController.AnimationParameters params)
  ///
  /// Transforms the index stored in
  /// android.view.animation.LayoutAnimationController.AnimationParameters
  /// by the order returned by \#getOrder(). Subclasses should override
  /// this method to provide additional support for other types of ordering.
  /// This method should be invoked by
  /// \#getDelayForView(android.view.View) prior to any computation.
  ///@param params the animation parameters containing the index
  ///@return a transformed index
  int getTransformedIndex(
          LayoutAnimationController_AnimationParameters params) =>
      jniAccessors.callMethodWithArgs(reference, _id_getTransformedIndex,
          jni.JniType.intType, [params.reference]).integer;
}

/// from: android.view.animation.LayoutAnimationController$AnimationParameters
///
/// The set of parameters that has to be attached to each view contained in
/// the view group animated by the layout animation controller. These
/// parameters are used to compute the start time of each individual view's
/// animation.
class LayoutAnimationController_AnimationParameters extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/animation/LayoutAnimationController\$AnimationParameters");
  LayoutAnimationController_AnimationParameters.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_count = jniAccessors.getFieldIDOf(_classRef, "count", "I");

  /// from: public int count
  ///
  /// The number of children in the view group containing the view to which
  /// these parameters are attached.
  int get count =>
      jniAccessors.getField(reference, _id_count, jni.JniType.intType).integer;

  /// from: public int count
  ///
  /// The number of children in the view group containing the view to which
  /// these parameters are attached.
  set count(int value) => jniEnv.SetIntField(reference, _id_count, value);

  static final _id_index = jniAccessors.getFieldIDOf(_classRef, "index", "I");

  /// from: public int index
  ///
  /// The index of the view to which these parameters are attached in its
  /// containing view group.
  int get index =>
      jniAccessors.getField(reference, _id_index, jni.JniType.intType).integer;

  /// from: public int index
  ///
  /// The index of the view to which these parameters are attached in its
  /// containing view group.
  set index(int value) => jniEnv.SetIntField(reference, _id_index, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LayoutAnimationController_AnimationParameters()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
