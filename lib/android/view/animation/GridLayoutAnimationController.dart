// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "LayoutAnimationController.dart" as layoutanimationcontroller_;

import "../../content/Context.dart" as context_;

import "../../util/AttributeSet.dart" as attributeset_;

import "Animation.dart" as animation_;

import "../View.dart" as view_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.animation.GridLayoutAnimationController
///
/// A layout animation controller is used to animated a grid layout's children.
///
/// While LayoutAnimationController relies only on the index of the child
/// in the view group to compute the animation delay, this class uses both the
/// X and Y coordinates of the child within a grid.
///
/// In addition, the animation direction can be controlled. The default direction
/// is <code>DIRECTION_LEFT_TO_RIGHT | DIRECTION_TOP_TO_BOTTOM</code>. You can
/// also set the animation priority to columns or rows. The default priority is
/// none.
///
/// Information used to compute the animation delay of each child are stored
/// in an instance of
/// android.view.animation.GridLayoutAnimationController.AnimationParameters,
/// itself stored in the android.view.ViewGroup.LayoutParams of the view.
///@see LayoutAnimationController
///@see android.widget.GridView
///@attr ref android.R.styleable\#GridLayoutAnimation_columnDelay
///@attr ref android.R.styleable\#GridLayoutAnimation_rowDelay
///@attr ref android.R.styleable\#GridLayoutAnimation_direction
///@attr ref android.R.styleable\#GridLayoutAnimation_directionPriority
class GridLayoutAnimationController
    extends layoutanimationcontroller_.LayoutAnimationController {
  static final _classRef = jniAccessors
      .getClassOf("android/view/animation/GridLayoutAnimationController");
  GridLayoutAnimationController.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DIRECTION_BOTTOM_TO_TOP
  ///
  /// Animates the children starting from the bottom of the grid to the top.
  static const DIRECTION_BOTTOM_TO_TOP = 2;

  /// from: static public final int DIRECTION_HORIZONTAL_MASK
  ///
  /// Bitmask used to retrieve the horizontal component of the direction.
  static const DIRECTION_HORIZONTAL_MASK = 1;

  /// from: static public final int DIRECTION_LEFT_TO_RIGHT
  ///
  /// Animates the children starting from the left of the grid to the right.
  static const DIRECTION_LEFT_TO_RIGHT = 0;

  /// from: static public final int DIRECTION_RIGHT_TO_LEFT
  ///
  /// Animates the children starting from the right of the grid to the left.
  static const DIRECTION_RIGHT_TO_LEFT = 1;

  /// from: static public final int DIRECTION_TOP_TO_BOTTOM
  ///
  /// Animates the children starting from the top of the grid to the bottom.
  static const DIRECTION_TOP_TO_BOTTOM = 0;

  /// from: static public final int DIRECTION_VERTICAL_MASK
  ///
  /// Bitmask used to retrieve the vertical component of the direction.
  static const DIRECTION_VERTICAL_MASK = 2;

  /// from: static public final int PRIORITY_COLUMN
  ///
  /// Columns are animated first.
  static const PRIORITY_COLUMN = 1;

  /// from: static public final int PRIORITY_NONE
  ///
  /// Rows and columns are animated at the same time.
  static const PRIORITY_NONE = 0;

  /// from: static public final int PRIORITY_ROW
  ///
  /// Rows are animated first.
  static const PRIORITY_ROW = 2;

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new grid layout animation controller from external resources.
  ///@param context the Context the view  group is running in, through which
  ///        it can access the resources
  ///@param attrs the attributes of the XML tag that is inflating the
  ///        layout animation controller
  GridLayoutAnimationController(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference, attrs.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/animation/Animation;)V");

  /// from: public void <init>(android.view.animation.Animation animation)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new layout animation controller with a delay of 50%
  /// for both rows and columns and the specified animation.
  ///@param animation the animation to use on each child of the view group
  GridLayoutAnimationController.ctor1(animation_.Animation animation)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [animation.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/animation/Animation;FF)V");

  /// from: public void <init>(android.view.animation.Animation animation, float columnDelay, float rowDelay)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new layout animation controller with the specified delays
  /// and the specified animation.
  ///@param animation the animation to use on each child of the view group
  ///@param columnDelay the delay by which each column animation must be offset
  ///@param rowDelay the delay by which each row animation must be offset
  GridLayoutAnimationController.ctor3(
      animation_.Animation animation, double columnDelay, double rowDelay)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3,
            [animation.reference, columnDelay, rowDelay]).object);

  static final _id_getColumnDelay =
      jniAccessors.getMethodIDOf(_classRef, "getColumnDelay", "()F");

  /// from: public float getColumnDelay()
  ///
  /// Returns the delay by which the children's animation are offset from one
  /// column to the other. The delay is expressed as a fraction of the
  /// animation duration.
  ///@return a fraction of the animation duration
  ///@see \#setColumnDelay(float)
  ///@see \#getRowDelay()
  ///@see \#setRowDelay(float)
  double getColumnDelay() => jniAccessors.callMethodWithArgs(
      reference, _id_getColumnDelay, jni.JniType.floatType, []).float;

  static final _id_setColumnDelay =
      jniAccessors.getMethodIDOf(_classRef, "setColumnDelay", "(F)V");

  /// from: public void setColumnDelay(float columnDelay)
  ///
  /// Sets the delay, as a fraction of the animation duration, by which the
  /// children's animations are offset from one column to the other.
  ///@param columnDelay a fraction of the animation duration
  ///@see \#getColumnDelay()
  ///@see \#getRowDelay()
  ///@see \#setRowDelay(float)
  void setColumnDelay(double columnDelay) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setColumnDelay,
      jni.JniType.voidType,
      [columnDelay]).check();

  static final _id_getRowDelay =
      jniAccessors.getMethodIDOf(_classRef, "getRowDelay", "()F");

  /// from: public float getRowDelay()
  ///
  /// Returns the delay by which the children's animation are offset from one
  /// row to the other. The delay is expressed as a fraction of the
  /// animation duration.
  ///@return a fraction of the animation duration
  ///@see \#setRowDelay(float)
  ///@see \#getColumnDelay()
  ///@see \#setColumnDelay(float)
  double getRowDelay() => jniAccessors.callMethodWithArgs(
      reference, _id_getRowDelay, jni.JniType.floatType, []).float;

  static final _id_setRowDelay =
      jniAccessors.getMethodIDOf(_classRef, "setRowDelay", "(F)V");

  /// from: public void setRowDelay(float rowDelay)
  ///
  /// Sets the delay, as a fraction of the animation duration, by which the
  /// children's animations are offset from one row to the other.
  ///@param rowDelay a fraction of the animation duration
  ///@see \#getRowDelay()
  ///@see \#getColumnDelay()
  ///@see \#setColumnDelay(float)
  void setRowDelay(double rowDelay) => jniAccessors.callMethodWithArgs(
      reference, _id_setRowDelay, jni.JniType.voidType, [rowDelay]).check();

  static final _id_getDirection =
      jniAccessors.getMethodIDOf(_classRef, "getDirection", "()I");

  /// from: public int getDirection()
  ///
  /// Returns the direction of the animation. \#DIRECTION_HORIZONTAL_MASK
  /// and \#DIRECTION_VERTICAL_MASK can be used to retrieve the
  /// horizontal and vertical components of the direction.
  ///@return the direction of the animation
  ///@see \#setDirection(int)
  ///@see \#DIRECTION_BOTTOM_TO_TOP
  ///@see \#DIRECTION_TOP_TO_BOTTOM
  ///@see \#DIRECTION_LEFT_TO_RIGHT
  ///@see \#DIRECTION_RIGHT_TO_LEFT
  ///@see \#DIRECTION_HORIZONTAL_MASK
  ///@see \#DIRECTION_VERTICAL_MASK
  int getDirection() => jniAccessors.callMethodWithArgs(
      reference, _id_getDirection, jni.JniType.intType, []).integer;

  static final _id_setDirection =
      jniAccessors.getMethodIDOf(_classRef, "setDirection", "(I)V");

  /// from: public void setDirection(int direction)
  ///
  /// Sets the direction of the animation. The direction is expressed as an
  /// integer containing a horizontal and vertical component. For instance,
  /// <code>DIRECTION_BOTTOM_TO_TOP | DIRECTION_RIGHT_TO_LEFT</code>.
  ///@param direction the direction of the animation
  ///@see \#getDirection()
  ///@see \#DIRECTION_BOTTOM_TO_TOP
  ///@see \#DIRECTION_TOP_TO_BOTTOM
  ///@see \#DIRECTION_LEFT_TO_RIGHT
  ///@see \#DIRECTION_RIGHT_TO_LEFT
  ///@see \#DIRECTION_HORIZONTAL_MASK
  ///@see \#DIRECTION_VERTICAL_MASK
  void setDirection(int direction) => jniAccessors.callMethodWithArgs(
      reference, _id_setDirection, jni.JniType.voidType, [direction]).check();

  static final _id_getDirectionPriority =
      jniAccessors.getMethodIDOf(_classRef, "getDirectionPriority", "()I");

  /// from: public int getDirectionPriority()
  ///
  /// Returns the direction priority for the animation. The priority can
  /// be either \#PRIORITY_NONE, \#PRIORITY_COLUMN or
  /// \#PRIORITY_ROW.
  ///@return the priority of the animation direction
  ///@see \#setDirectionPriority(int)
  ///@see \#PRIORITY_COLUMN
  ///@see \#PRIORITY_NONE
  ///@see \#PRIORITY_ROW
  int getDirectionPriority() => jniAccessors.callMethodWithArgs(
      reference, _id_getDirectionPriority, jni.JniType.intType, []).integer;

  static final _id_setDirectionPriority =
      jniAccessors.getMethodIDOf(_classRef, "setDirectionPriority", "(I)V");

  /// from: public void setDirectionPriority(int directionPriority)
  ///
  /// Specifies the direction priority of the animation. For instance,
  /// \#PRIORITY_COLUMN will give priority to columns: the animation
  /// will first play on the column, then on the rows.Z
  ///@param directionPriority the direction priority of the animation
  ///@see \#getDirectionPriority()
  ///@see \#PRIORITY_COLUMN
  ///@see \#PRIORITY_NONE
  ///@see \#PRIORITY_ROW
  void setDirectionPriority(int directionPriority) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDirectionPriority,
          jni.JniType.voidType, [directionPriority]).check();

  static final _id_willOverlap =
      jniAccessors.getMethodIDOf(_classRef, "willOverlap", "()Z");

  /// from: public boolean willOverlap()
  ///
  /// {@inheritDoc}
  bool willOverlap() => jniAccessors.callMethodWithArgs(
      reference, _id_willOverlap, jni.JniType.booleanType, []).boolean;

  static final _id_getDelayForView = jniAccessors.getMethodIDOf(
      _classRef, "getDelayForView", "(Landroid/view/View;)J");

  /// from: protected long getDelayForView(android.view.View view)
  ///
  /// {@inheritDoc}
  int getDelayForView(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDelayForView,
      jni.JniType.longType,
      [view.reference]).long;
}

/// from: android.view.animation.GridLayoutAnimationController$AnimationParameters
///
/// The set of parameters that has to be attached to each view contained in
/// the view group animated by the grid layout animation controller. These
/// parameters are used to compute the start time of each individual view's
/// animation.
class GridLayoutAnimationController_AnimationParameters
    extends layoutanimationcontroller_
        .LayoutAnimationController_AnimationParameters {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/animation/GridLayoutAnimationController\$AnimationParameters");
  GridLayoutAnimationController_AnimationParameters.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_column = jniAccessors.getFieldIDOf(_classRef, "column", "I");

  /// from: public int column
  ///
  /// The view group's column to which the view belongs.
  int get column =>
      jniAccessors.getField(reference, _id_column, jni.JniType.intType).integer;

  /// from: public int column
  ///
  /// The view group's column to which the view belongs.
  set column(int value) => jniEnv.SetIntField(reference, _id_column, value);

  static final _id_columnsCount =
      jniAccessors.getFieldIDOf(_classRef, "columnsCount", "I");

  /// from: public int columnsCount
  ///
  /// The number of columns in the view's enclosing grid layout.
  int get columnsCount => jniAccessors
      .getField(reference, _id_columnsCount, jni.JniType.intType)
      .integer;

  /// from: public int columnsCount
  ///
  /// The number of columns in the view's enclosing grid layout.
  set columnsCount(int value) =>
      jniEnv.SetIntField(reference, _id_columnsCount, value);

  static final _id_row = jniAccessors.getFieldIDOf(_classRef, "row", "I");

  /// from: public int row
  ///
  /// The view group's row to which the view belongs.
  int get row =>
      jniAccessors.getField(reference, _id_row, jni.JniType.intType).integer;

  /// from: public int row
  ///
  /// The view group's row to which the view belongs.
  set row(int value) => jniEnv.SetIntField(reference, _id_row, value);

  static final _id_rowsCount =
      jniAccessors.getFieldIDOf(_classRef, "rowsCount", "I");

  /// from: public int rowsCount
  ///
  /// The number of rows in the view's enclosing grid layout.
  int get rowsCount => jniAccessors
      .getField(reference, _id_rowsCount, jni.JniType.intType)
      .integer;

  /// from: public int rowsCount
  ///
  /// The number of rows in the view's enclosing grid layout.
  set rowsCount(int value) =>
      jniEnv.SetIntField(reference, _id_rowsCount, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GridLayoutAnimationController_AnimationParameters()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
