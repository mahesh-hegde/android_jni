// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "View.dart" as view_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "ActionMode.dart" as actionmode_;

import "../graphics/Rect.dart" as rect_;

import "accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "../content/res/Configuration.dart" as configuration_;

import "DragEvent.dart" as dragevent_;

import "KeyEvent.dart" as keyevent_;

import "MotionEvent.dart" as motionevent_;

import "PointerIcon.dart" as pointericon_;

import "ViewStructure.dart" as viewstructure_;

import "../os/Bundle.dart" as bundle_;

import "../util/SparseArray.dart" as sparsearray_;

import "../graphics/Canvas.dart" as canvas_;

import "ViewGroupOverlay.dart" as viewgroupoverlay_;

import "animation/Transformation.dart" as transformation_;

import "../animation/LayoutTransition.dart" as layouttransition_;

import "ViewParent.dart" as viewparent_;

import "../graphics/Point.dart" as point_;

import "animation/LayoutAnimationController.dart" as layoutanimationcontroller_;

import "../graphics/Region.dart" as region_;

import "WindowInsets.dart" as windowinsets_;

import "animation/Animation.dart" as animation_;

import "../content/res/TypedArray.dart" as typedarray_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.ViewGroup
///
///
/// A <code>ViewGroup</code> is a special view that can contain other views
/// (called children.) The view group is the base class for layouts and views
/// containers. This class also defines the
/// android.view.ViewGroup.LayoutParams class which serves as the base
/// class for layouts parameters.
///
///
///
///
/// Also see LayoutParams for layout attributes.
///
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating user interface layouts, read the
/// <a href="{@docRoot}guide/topics/ui/declaring-layout.html">XML Layouts</a> developer
/// guide.
///</div>
///
/// Here is a complete implementation of a custom ViewGroup that implements
/// a simple android.widget.FrameLayout along with the ability to stack
/// children in left and right gutters.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/view/CustomLayout.java
///      Complete}
///
/// If you are implementing XML layout attributes as shown in the example, this is the
/// corresponding definition for them that would go in <code>res/values/attrs.xml</code>:
///
///
/// {@sample development/samples/ApiDemos/res/values/attrs.xml CustomLayout}
///
/// Finally the layout manager can be used in an XML layout like so:
///
///
/// {@sample development/samples/ApiDemos/res/layout/custom_layout.xml Complete}
///@attr ref android.R.styleable\#ViewGroup_clipChildren
///@attr ref android.R.styleable\#ViewGroup_clipToPadding
///@attr ref android.R.styleable\#ViewGroup_layoutAnimation
///@attr ref android.R.styleable\#ViewGroup_animationCache
///@attr ref android.R.styleable\#ViewGroup_persistentDrawingCache
///@attr ref android.R.styleable\#ViewGroup_alwaysDrawnWithCache
///@attr ref android.R.styleable\#ViewGroup_addStatesFromChildren
///@attr ref android.R.styleable\#ViewGroup_descendantFocusability
///@attr ref android.R.styleable\#ViewGroup_animateLayoutChanges
///@attr ref android.R.styleable\#ViewGroup_splitMotionEvents
///@attr ref android.R.styleable\#ViewGroup_layoutMode
class ViewGroup extends view_.View {
  static final _classRef = jniAccessors.getClassOf("android/view/ViewGroup");
  ViewGroup.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static protected final int CLIP_TO_PADDING_MASK
  ///
  /// We clip to padding when FLAG_CLIP_TO_PADDING and FLAG_PADDING_NOT_NULL
  /// are set at the same time.
  static const CLIP_TO_PADDING_MASK = 34;

  /// from: static public final int FOCUS_AFTER_DESCENDANTS
  ///
  /// This view will get focus only if none of its descendants want it.
  static const FOCUS_AFTER_DESCENDANTS = 262144;

  /// from: static public final int FOCUS_BEFORE_DESCENDANTS
  ///
  /// This view will get focus before any of its descendants.
  static const FOCUS_BEFORE_DESCENDANTS = 131072;

  /// from: static public final int FOCUS_BLOCK_DESCENDANTS
  ///
  /// This view will block any of its descendants from getting focus, even
  /// if they are focusable.
  static const FOCUS_BLOCK_DESCENDANTS = 393216;

  /// from: static public final int LAYOUT_MODE_CLIP_BOUNDS
  ///
  /// This constant is a \#setLayoutMode(int) layoutMode.
  /// Clip bounds are the raw values of \#getLeft() left, \#getTop() top,
  /// \#getRight() right and \#getBottom() bottom.
  static const LAYOUT_MODE_CLIP_BOUNDS = 0;

  /// from: static public final int LAYOUT_MODE_OPTICAL_BOUNDS
  ///
  /// This constant is a \#setLayoutMode(int) layoutMode.
  /// Optical bounds describe where a widget appears to be. They sit inside the clip
  /// bounds which need to cover a larger area to allow other effects,
  /// such as shadows and glows, to be drawn.
  static const LAYOUT_MODE_OPTICAL_BOUNDS = 1;

  /// from: static public final int PERSISTENT_ALL_CACHES
  ///
  /// Used to indicate that all drawing caches should be kept in memory.
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  static const PERSISTENT_ALL_CACHES = 3;

  /// from: static public final int PERSISTENT_ANIMATION_CACHE
  ///
  /// Used to indicate that the animation drawing cache should be kept in memory.
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  static const PERSISTENT_ANIMATION_CACHE = 1;

  /// from: static public final int PERSISTENT_NO_CACHE
  ///
  /// Used to indicate that no drawing cache should be kept in memory.
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  static const PERSISTENT_NO_CACHE = 0;

  /// from: static public final int PERSISTENT_SCROLLING_CACHE
  ///
  /// Used to indicate that the scrolling drawing cache should be kept in memory.
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  static const PERSISTENT_SCROLLING_CACHE = 2;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewGroup(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewGroup.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewGroup.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewGroup.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_getDescendantFocusability =
      jniAccessors.getMethodIDOf(_classRef, "getDescendantFocusability", "()I");

  /// from: public int getDescendantFocusability()
  ///
  /// Gets the descendant focusability of this view group.  The descendant
  /// focusability defines the relationship between this view group and its
  /// descendants when looking for a view to take focus in
  /// \#requestFocus(int, android.graphics.Rect).
  ///@return one of \#FOCUS_BEFORE_DESCENDANTS, \#FOCUS_AFTER_DESCENDANTS,
  ///   \#FOCUS_BLOCK_DESCENDANTS.
  int getDescendantFocusability() => jniAccessors.callMethodWithArgs(reference,
      _id_getDescendantFocusability, jni.JniType.intType, []).integer;

  static final _id_setDescendantFocusability = jniAccessors.getMethodIDOf(
      _classRef, "setDescendantFocusability", "(I)V");

  /// from: public void setDescendantFocusability(int focusability)
  ///
  /// Set the descendant focusability of this view group. This defines the relationship
  /// between this view group and its descendants when looking for a view to
  /// take focus in \#requestFocus(int, android.graphics.Rect).
  ///@param focusability one of \#FOCUS_BEFORE_DESCENDANTS, \#FOCUS_AFTER_DESCENDANTS,
  ///   \#FOCUS_BLOCK_DESCENDANTS.
  void setDescendantFocusability(int focusability) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDescendantFocusability,
          jni.JniType.voidType, [focusability]).check();

  static final _id_requestChildFocus = jniAccessors.getMethodIDOf(_classRef,
      "requestChildFocus", "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void requestChildFocus(android.view.View child, android.view.View focused)
  void requestChildFocus(view_.View child, view_.View focused) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestChildFocus,
          jni.JniType.voidType, [child.reference, focused.reference]).check();

  static final _id_focusableViewAvailable = jniAccessors.getMethodIDOf(
      _classRef, "focusableViewAvailable", "(Landroid/view/View;)V");

  /// from: public void focusableViewAvailable(android.view.View v)
  void focusableViewAvailable(view_.View v) => jniAccessors.callMethodWithArgs(
      reference,
      _id_focusableViewAvailable,
      jni.JniType.voidType,
      [v.reference]).check();

  static final _id_showContextMenuForChild = jniAccessors.getMethodIDOf(
      _classRef, "showContextMenuForChild", "(Landroid/view/View;)Z");

  /// from: public boolean showContextMenuForChild(android.view.View originalView)
  bool showContextMenuForChild(view_.View originalView) =>
      jniAccessors.callMethodWithArgs(reference, _id_showContextMenuForChild,
          jni.JniType.booleanType, [originalView.reference]).boolean;

  static final _id_showContextMenuForChild1 = jniAccessors.getMethodIDOf(
      _classRef, "showContextMenuForChild", "(Landroid/view/View;FF)Z");

  /// from: public boolean showContextMenuForChild(android.view.View originalView, float x, float y)
  bool showContextMenuForChild1(view_.View originalView, double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_showContextMenuForChild1,
          jni.JniType.booleanType, [originalView.reference, x, y]).boolean;

  static final _id_startActionModeForChild = jniAccessors.getMethodIDOf(
      _classRef,
      "startActionModeForChild",
      "(Landroid/view/View;Landroid/view/ActionMode\$Callback;)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode startActionModeForChild(android.view.View originalView, android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  actionmode_.ActionMode startActionModeForChild(
          view_.View originalView, actionmode_.ActionMode_Callback callback) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActionModeForChild,
          jni.JniType.objectType,
          [originalView.reference, callback.reference]).object);

  static final _id_startActionModeForChild1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActionModeForChild",
      "(Landroid/view/View;Landroid/view/ActionMode\$Callback;I)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode startActionModeForChild(android.view.View originalView, android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  actionmode_.ActionMode startActionModeForChild1(view_.View originalView,
          actionmode_.ActionMode_Callback callback, int type) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActionModeForChild1,
          jni.JniType.objectType,
          [originalView.reference, callback.reference, type]).object);

  static final _id_focusSearch1 = jniAccessors.getMethodIDOf(
      _classRef, "focusSearch", "(Landroid/view/View;I)Landroid/view/View;");

  /// from: public android.view.View focusSearch(android.view.View focused, int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the nearest view in the specified direction that wants to take
  /// focus.
  ///@param focused The view that currently has focus
  ///@param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and
  ///        FOCUS_RIGHT, or 0 for not applicable.
  view_.View focusSearch1(view_.View focused, int direction) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_focusSearch1,
          jni.JniType.objectType,
          [focused.reference, direction]).object);

  static final _id_requestChildRectangleOnScreen = jniAccessors.getMethodIDOf(
      _classRef,
      "requestChildRectangleOnScreen",
      "(Landroid/view/View;Landroid/graphics/Rect;Z)Z");

  /// from: public boolean requestChildRectangleOnScreen(android.view.View child, android.graphics.Rect rectangle, boolean immediate)
  bool requestChildRectangleOnScreen(
          view_.View child, rect_.Rect rectangle, bool immediate) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestChildRectangleOnScreen,
          jni.JniType.booleanType,
          [child.reference, rectangle.reference, immediate]).boolean;

  static final _id_requestSendAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "requestSendAccessibilityEvent",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean requestSendAccessibilityEvent(android.view.View child, android.view.accessibility.AccessibilityEvent event)
  bool requestSendAccessibilityEvent(
          view_.View child, accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestSendAccessibilityEvent,
          jni.JniType.booleanType,
          [child.reference, event.reference]).boolean;

  static final _id_onRequestSendAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestSendAccessibilityEvent",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean onRequestSendAccessibilityEvent(android.view.View child, android.view.accessibility.AccessibilityEvent event)
  ///
  /// Called when a child has requested sending an AccessibilityEvent and
  /// gives an opportunity to its parent to augment the event.
  ///
  /// If an android.view.View.AccessibilityDelegate has been specified via calling
  /// android.view.View\#setAccessibilityDelegate(android.view.View.AccessibilityDelegate) its
  /// android.view.View.AccessibilityDelegate\#onRequestSendAccessibilityEvent(ViewGroup, View, AccessibilityEvent)
  /// is responsible for handling this call.
  ///
  ///
  ///@param child The child which requests sending the event.
  ///@param event The event to be sent.
  ///@return True if the event should be sent.
  ///@see \#requestSendAccessibilityEvent(View, AccessibilityEvent)
  bool onRequestSendAccessibilityEvent(
          view_.View child, accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRequestSendAccessibilityEvent,
          jni.JniType.booleanType,
          [child.reference, event.reference]).boolean;

  static final _id_childHasTransientStateChanged = jniAccessors.getMethodIDOf(
      _classRef, "childHasTransientStateChanged", "(Landroid/view/View;Z)V");

  /// from: public void childHasTransientStateChanged(android.view.View child, boolean childHasTransientState)
  ///
  /// Called when a child view has changed whether or not it is tracking transient state.
  void childHasTransientStateChanged(
          view_.View child, bool childHasTransientState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_childHasTransientStateChanged,
          jni.JniType.voidType,
          [child.reference, childHasTransientState]).check();

  static final _id_hasTransientState =
      jniAccessors.getMethodIDOf(_classRef, "hasTransientState", "()Z");

  /// from: public boolean hasTransientState()
  bool hasTransientState() => jniAccessors.callMethodWithArgs(
      reference, _id_hasTransientState, jni.JniType.booleanType, []).boolean;

  static final _id_dispatchUnhandledMove = jniAccessors.getMethodIDOf(
      _classRef, "dispatchUnhandledMove", "(Landroid/view/View;I)Z");

  /// from: public boolean dispatchUnhandledMove(android.view.View focused, int direction)
  bool dispatchUnhandledMove(view_.View focused, int direction) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchUnhandledMove,
          jni.JniType.booleanType, [focused.reference, direction]).boolean;

  static final _id_clearChildFocus = jniAccessors.getMethodIDOf(
      _classRef, "clearChildFocus", "(Landroid/view/View;)V");

  /// from: public void clearChildFocus(android.view.View child)
  void clearChildFocus(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_clearChildFocus,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_clearFocus =
      jniAccessors.getMethodIDOf(_classRef, "clearFocus", "()V");

  /// from: public void clearFocus()
  void clearFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_clearFocus, jni.JniType.voidType, []).check();

  static final _id_getFocusedChild = jniAccessors.getMethodIDOf(
      _classRef, "getFocusedChild", "()Landroid/view/View;");

  /// from: public android.view.View getFocusedChild()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the focused child of this view, if any. The child may have focus
  /// or contain focus.
  ///@return the focused child or null.
  view_.View getFocusedChild() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFocusedChild, jni.JniType.objectType, []).object);

  static final _id_hasFocus =
      jniAccessors.getMethodIDOf(_classRef, "hasFocus", "()Z");

  /// from: public boolean hasFocus()
  ///
  /// Returns true if this view has or contains focus
  ///@return true if this view has or contains focus
  bool hasFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFocus, jni.JniType.booleanType, []).boolean;

  static final _id_findFocus = jniAccessors.getMethodIDOf(
      _classRef, "findFocus", "()Landroid/view/View;");

  /// from: public android.view.View findFocus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  view_.View findFocus() => view_.View.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_findFocus, jni.JniType.objectType, []).object);

  static final _id_addFocusables1 = jniAccessors.getMethodIDOf(
      _classRef, "addFocusables", "(Ljava/util/ArrayList;II)V");

  /// from: public void addFocusables(java.util.ArrayList<android.view.View> views, int direction, int focusableMode)
  void addFocusables1(jni.JniObject views, int direction, int focusableMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addFocusables1,
          jni.JniType.voidType,
          [views.reference, direction, focusableMode]).check();

  static final _id_addKeyboardNavigationClusters = jniAccessors.getMethodIDOf(
      _classRef, "addKeyboardNavigationClusters", "(Ljava/util/Collection;I)V");

  /// from: public void addKeyboardNavigationClusters(java.util.Collection<android.view.View> views, int direction)
  void addKeyboardNavigationClusters(jni.JniObject views, int direction) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addKeyboardNavigationClusters,
          jni.JniType.voidType,
          [views.reference, direction]).check();

  static final _id_setTouchscreenBlocksFocus = jniAccessors.getMethodIDOf(
      _classRef, "setTouchscreenBlocksFocus", "(Z)V");

  /// from: public void setTouchscreenBlocksFocus(boolean touchscreenBlocksFocus)
  ///
  /// Set whether this ViewGroup should ignore focus requests for itself and its children.
  /// If this option is enabled and the ViewGroup or a descendant currently has focus, focus
  /// will proceed forward.
  ///@param touchscreenBlocksFocus true to enable blocking focus in the presence of a touchscreen
  void setTouchscreenBlocksFocus(bool touchscreenBlocksFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTouchscreenBlocksFocus,
          jni.JniType.voidType, [touchscreenBlocksFocus]).check();

  static final _id_getTouchscreenBlocksFocus =
      jniAccessors.getMethodIDOf(_classRef, "getTouchscreenBlocksFocus", "()Z");

  /// from: public boolean getTouchscreenBlocksFocus()
  ///
  /// Check whether this ViewGroup should ignore focus requests for itself and its children.
  bool getTouchscreenBlocksFocus() => jniAccessors.callMethodWithArgs(reference,
      _id_getTouchscreenBlocksFocus, jni.JniType.booleanType, []).boolean;

  static final _id_findViewsWithText = jniAccessors.getMethodIDOf(_classRef,
      "findViewsWithText", "(Ljava/util/ArrayList;Ljava/lang/CharSequence;I)V");

  /// from: public void findViewsWithText(java.util.ArrayList<android.view.View> outViews, java.lang.CharSequence text, int flags)
  void findViewsWithText(
          jni.JniObject outViews, jni.JniObject text, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_findViewsWithText,
          jni.JniType.voidType,
          [outViews.reference, text.reference, flags]).check();

  static final _id_dispatchWindowFocusChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchWindowFocusChanged", "(Z)V");

  /// from: public void dispatchWindowFocusChanged(boolean hasFocus)
  void dispatchWindowFocusChanged(bool hasFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchWindowFocusChanged,
          jni.JniType.voidType, [hasFocus]).check();

  static final _id_addTouchables = jniAccessors.getMethodIDOf(
      _classRef, "addTouchables", "(Ljava/util/ArrayList;)V");

  /// from: public void addTouchables(java.util.ArrayList<android.view.View> views)
  void addTouchables(jni.JniObject views) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addTouchables,
      jni.JniType.voidType,
      [views.reference]).check();

  static final _id_dispatchDisplayHint =
      jniAccessors.getMethodIDOf(_classRef, "dispatchDisplayHint", "(I)V");

  /// from: public void dispatchDisplayHint(int hint)
  void dispatchDisplayHint(int hint) => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchDisplayHint, jni.JniType.voidType, [hint]).check();

  static final _id_dispatchVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchVisibilityChanged", "(Landroid/view/View;I)V");

  /// from: protected void dispatchVisibilityChanged(android.view.View changedView, int visibility)
  void dispatchVisibilityChanged(view_.View changedView, int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchVisibilityChanged,
          jni.JniType.voidType, [changedView.reference, visibility]).check();

  static final _id_dispatchWindowVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchWindowVisibilityChanged", "(I)V");

  /// from: public void dispatchWindowVisibilityChanged(int visibility)
  void dispatchWindowVisibilityChanged(int visibility) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchWindowVisibilityChanged,
          jni.JniType.voidType,
          [visibility]).check();

  static final _id_dispatchConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void dispatchConfigurationChanged(android.content.res.Configuration newConfig)
  void dispatchConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchConfigurationChanged,
          jni.JniType.voidType,
          [newConfig.reference]).check();

  static final _id_recomputeViewAttributes = jniAccessors.getMethodIDOf(
      _classRef, "recomputeViewAttributes", "(Landroid/view/View;)V");

  /// from: public void recomputeViewAttributes(android.view.View child)
  void recomputeViewAttributes(view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_recomputeViewAttributes,
          jni.JniType.voidType, [child.reference]).check();

  static final _id_bringChildToFront = jniAccessors.getMethodIDOf(
      _classRef, "bringChildToFront", "(Landroid/view/View;)V");

  /// from: public void bringChildToFront(android.view.View child)
  void bringChildToFront(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_bringChildToFront,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_dispatchDragEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDragEvent", "(Landroid/view/DragEvent;)Z");

  /// from: public boolean dispatchDragEvent(android.view.DragEvent event)
  bool dispatchDragEvent(dragevent_.DragEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchDragEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchWindowSystemUiVisiblityChanged =
      jniAccessors.getMethodIDOf(
          _classRef, "dispatchWindowSystemUiVisiblityChanged", "(I)V");

  /// from: public void dispatchWindowSystemUiVisiblityChanged(int visible)
  void dispatchWindowSystemUiVisiblityChanged(int visible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchWindowSystemUiVisiblityChanged,
          jni.JniType.voidType,
          [visible]).check();

  static final _id_dispatchSystemUiVisibilityChanged = jniAccessors
      .getMethodIDOf(_classRef, "dispatchSystemUiVisibilityChanged", "(I)V");

  /// from: public void dispatchSystemUiVisibilityChanged(int visible)
  void dispatchSystemUiVisibilityChanged(int visible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchSystemUiVisibilityChanged,
          jni.JniType.voidType,
          [visible]).check();

  static final _id_dispatchKeyEventPreIme = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEventPreIme", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEventPreIme(android.view.KeyEvent event)
  bool dispatchKeyEventPreIme(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEventPreIme,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  bool dispatchKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchKeyShortcutEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyShortcutEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  bool dispatchKeyShortcutEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyShortcutEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent event)
  bool dispatchTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchCapturedPointerEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchCapturedPointerEvent",
      "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchCapturedPointerEvent(android.view.MotionEvent event)
  bool dispatchCapturedPointerEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchCapturedPointerEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_dispatchPointerCaptureChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchPointerCaptureChanged", "(Z)V");

  /// from: public void dispatchPointerCaptureChanged(boolean hasCapture)
  void dispatchPointerCaptureChanged(bool hasCapture) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPointerCaptureChanged,
          jni.JniType.voidType,
          [hasCapture]).check();

  static final _id_onResolvePointerIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "onResolvePointerIcon",
      "(Landroid/view/MotionEvent;I)Landroid/view/PointerIcon;");

  /// from: public android.view.PointerIcon onResolvePointerIcon(android.view.MotionEvent event, int pointerIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  pointericon_.PointerIcon onResolvePointerIcon(
          motionevent_.MotionEvent event, int pointerIndex) =>
      pointericon_.PointerIcon.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onResolvePointerIcon,
          jni.JniType.objectType,
          [event.reference, pointerIndex]).object);

  static final _id_dispatchHoverEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchHoverEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchHoverEvent(android.view.MotionEvent event)
  bool dispatchHoverEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchHoverEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_addChildrenForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "addChildrenForAccessibility", "(Ljava/util/ArrayList;)V");

  /// from: public void addChildrenForAccessibility(java.util.ArrayList<android.view.View> outChildren)
  void addChildrenForAccessibility(jni.JniObject outChildren) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addChildrenForAccessibility,
          jni.JniType.voidType,
          [outChildren.reference]).check();

  static final _id_onInterceptHoverEvent = jniAccessors.getMethodIDOf(
      _classRef, "onInterceptHoverEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onInterceptHoverEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to intercept hover events before they are handled
  /// by child views.
  ///
  /// This method is called before dispatching a hover event to a child of
  /// the view group or to the view group's own \#onHoverEvent to allow
  /// the view group a chance to intercept the hover event.
  /// This method can also be used to watch all pointer motions that occur within
  /// the bounds of the view group even when the pointer is hovering over
  /// a child of the view group rather than over the view group itself.
  ///
  ///
  /// The view group can prevent its children from receiving hover events by
  /// implementing this method and returning <code>true</code> to indicate
  /// that it would like to intercept hover events.  The view group must
  /// continuously return <code>true</code> from \#onInterceptHoverEvent
  /// for as long as it wishes to continue intercepting hover events from
  /// its children.
  ///
  ///
  /// Interception preserves the invariant that at most one view can be
  /// hovered at a time by transferring hover focus from the currently hovered
  /// child to the view group or vice-versa as needed.
  ///
  ///
  /// If this method returns <code>true</code> and a child is already hovered, then the
  /// child view will first receive a hover exit event and then the view group
  /// itself will receive a hover enter event in \#onHoverEvent.
  /// Likewise, if this method had previously returned <code>true</code> to intercept hover
  /// events and instead returns <code>false</code> while the pointer is hovering
  /// within the bounds of one of a child, then the view group will first receive a
  /// hover exit event in \#onHoverEvent and then the hovered child will
  /// receive a hover enter event.
  ///
  ///
  /// The default implementation handles mouse hover on the scroll bars.
  ///
  ///
  ///@param event The motion event that describes the hover.
  ///@return True if the view group would like to intercept the hover event
  /// and prevent its children from receiving it.
  bool onInterceptHoverEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onInterceptHoverEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchGenericPointerEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchGenericPointerEvent",
      "(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchGenericPointerEvent(android.view.MotionEvent event)
  bool dispatchGenericPointerEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchGenericPointerEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_dispatchGenericFocusedEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchGenericFocusedEvent",
      "(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchGenericFocusedEvent(android.view.MotionEvent event)
  bool dispatchGenericFocusedEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchGenericFocusedEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_dispatchTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent ev)
  bool dispatchTouchEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTouchEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_setMotionEventSplittingEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setMotionEventSplittingEnabled", "(Z)V");

  /// from: public void setMotionEventSplittingEnabled(boolean split)
  ///
  /// Enable or disable the splitting of MotionEvents to multiple children during touch event
  /// dispatch. This behavior is enabled by default for applications that target an
  /// SDK version of Build.VERSION_CODES\#HONEYCOMB or newer.
  ///
  /// When this option is enabled MotionEvents may be split and dispatched to different child
  /// views depending on where each pointer initially went down. This allows for user interactions
  /// such as scrolling two panes of content independently, chording of buttons, and performing
  /// independent gestures on different pieces of content.
  ///@param split <code>true</code> to allow MotionEvents to be split and dispatched to multiple
  ///              child views. <code>false</code> to only allow one child view to be the target of
  ///              any MotionEvent received by this ViewGroup.
  ///@attr ref android.R.styleable\#ViewGroup_splitMotionEvents
  void setMotionEventSplittingEnabled(bool split) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setMotionEventSplittingEnabled,
          jni.JniType.voidType,
          [split]).check();

  static final _id_isMotionEventSplittingEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isMotionEventSplittingEnabled", "()Z");

  /// from: public boolean isMotionEventSplittingEnabled()
  ///
  /// Returns true if MotionEvents dispatched to this ViewGroup can be split to multiple children.
  ///@return true if MotionEvents dispatched to this ViewGroup can be split to multiple children.
  bool isMotionEventSplittingEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isMotionEventSplittingEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_isTransitionGroup =
      jniAccessors.getMethodIDOf(_classRef, "isTransitionGroup", "()Z");

  /// from: public boolean isTransitionGroup()
  ///
  /// Returns true if this ViewGroup should be considered as a single entity for removal
  /// when executing an Activity transition. If this is false, child elements will move
  /// individually during the transition.
  ///@return True if the ViewGroup should be acted on together during an Activity transition.
  /// The default value is true when there is a non-null background or if
  /// \#getTransitionName() is not null or if a
  /// non-null android.view.ViewOutlineProvider other than
  /// android.view.ViewOutlineProvider\#BACKGROUND was given to
  /// \#setOutlineProvider(ViewOutlineProvider) and false otherwise.
  bool isTransitionGroup() => jniAccessors.callMethodWithArgs(
      reference, _id_isTransitionGroup, jni.JniType.booleanType, []).boolean;

  static final _id_setTransitionGroup =
      jniAccessors.getMethodIDOf(_classRef, "setTransitionGroup", "(Z)V");

  /// from: public void setTransitionGroup(boolean isTransitionGroup)
  ///
  /// Changes whether or not this ViewGroup should be treated as a single entity during
  /// Activity Transitions.
  ///@param isTransitionGroup Whether or not the ViewGroup should be treated as a unit
  ///                          in Activity transitions. If false, the ViewGroup won't transition,
  ///                          only its children. If true, the entire ViewGroup will transition
  ///                          together.
  ///@see android.app.ActivityOptions\#makeSceneTransitionAnimation(android.app.Activity,
  /// android.util.Pair[])
  void setTransitionGroup(bool isTransitionGroup) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTransitionGroup,
          jni.JniType.voidType, [isTransitionGroup]).check();

  static final _id_requestDisallowInterceptTouchEvent = jniAccessors
      .getMethodIDOf(_classRef, "requestDisallowInterceptTouchEvent", "(Z)V");

  /// from: public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)
  void requestDisallowInterceptTouchEvent(bool disallowIntercept) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestDisallowInterceptTouchEvent,
          jni.JniType.voidType,
          [disallowIntercept]).check();

  static final _id_onInterceptTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onInterceptTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onInterceptTouchEvent(android.view.MotionEvent ev)
  ///
  /// Implement this method to intercept all touch screen motion events.  This
  /// allows you to watch events as they are dispatched to your children, and
  /// take ownership of the current gesture at any point.
  ///
  /// Using this function takes some care, as it has a fairly complicated
  /// interaction with View\#onTouchEvent(MotionEvent) View.onTouchEvent(MotionEvent), and using it requires implementing
  /// that method as well as this one in the correct way.  Events will be
  /// received in the following order:
  ///
  /// <ol>
  /// <li> You will receive the down event here.
  /// <li> The down event will be handled either by a child of this view
  /// group, or given to your own onTouchEvent() method to handle; this means
  /// you should implement onTouchEvent() to return true, so you will
  /// continue to see the rest of the gesture (instead of looking for
  /// a parent view to handle it).  Also, by returning true from
  /// onTouchEvent(), you will not receive any following
  /// events in onInterceptTouchEvent() and all touch processing must
  /// happen in onTouchEvent() like normal.
  /// <li> For as long as you return false from this function, each following
  /// event (up to and including the final up) will be delivered first here
  /// and then to the target's onTouchEvent().
  /// <li> If you return true from here, you will not receive any
  /// following events: the target view will receive the same event but
  /// with the action MotionEvent\#ACTION_CANCEL, and all further
  /// events will be delivered to your onTouchEvent() method and no longer
  /// appear here.
  /// </ol>
  ///@param ev The motion event being dispatched down the hierarchy.
  ///@return Return true to steal motion events from the children and have
  /// them dispatched to this ViewGroup through onTouchEvent().
  /// The current target will receive an ACTION_CANCEL event, and no further
  /// messages will be delivered here.
  bool onInterceptTouchEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_onInterceptTouchEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_requestFocus2 = jniAccessors.getMethodIDOf(
      _classRef, "requestFocus", "(ILandroid/graphics/Rect;)Z");

  /// from: public boolean requestFocus(int direction, android.graphics.Rect previouslyFocusedRect)
  ///
  /// {@inheritDoc}
  ///
  /// Looks for a view to give focus to respecting the setting specified by
  /// \#getDescendantFocusability().
  ///
  /// Uses \#onRequestFocusInDescendants(int, android.graphics.Rect) to
  /// find focus within the children of this group when appropriate.
  ///@see \#FOCUS_BEFORE_DESCENDANTS
  ///@see \#FOCUS_AFTER_DESCENDANTS
  ///@see \#FOCUS_BLOCK_DESCENDANTS
  ///@see \#onRequestFocusInDescendants(int, android.graphics.Rect)
  bool requestFocus2(int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestFocus2,
          jni.JniType.booleanType,
          [direction, previouslyFocusedRect.reference]).boolean;

  static final _id_onRequestFocusInDescendants = jniAccessors.getMethodIDOf(
      _classRef, "onRequestFocusInDescendants", "(ILandroid/graphics/Rect;)Z");

  /// from: protected boolean onRequestFocusInDescendants(int direction, android.graphics.Rect previouslyFocusedRect)
  ///
  /// Look for a descendant to call View\#requestFocus on.
  /// Called by ViewGroup\#requestFocus(int, android.graphics.Rect)
  /// when it wants to request focus within its children.  Override this to
  /// customize how your ViewGroup requests focus within its children.
  ///@param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
  ///@param previouslyFocusedRect The rectangle (in this View's coordinate system)
  ///        to give a finer grained hint about where focus is coming from.  May be null
  ///        if there is no hint.
  ///@return Whether focus was taken.
  bool onRequestFocusInDescendants(
          int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRequestFocusInDescendants,
          jni.JniType.booleanType,
          [direction, previouslyFocusedRect.reference]).boolean;

  static final _id_restoreDefaultFocus =
      jniAccessors.getMethodIDOf(_classRef, "restoreDefaultFocus", "()Z");

  /// from: public boolean restoreDefaultFocus()
  bool restoreDefaultFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_restoreDefaultFocus, jni.JniType.booleanType, []).boolean;

  static final _id_dispatchStartTemporaryDetach = jniAccessors.getMethodIDOf(
      _classRef, "dispatchStartTemporaryDetach", "()V");

  /// from: public void dispatchStartTemporaryDetach()
  ///
  /// {@inheritDoc}
  ///@hide
  void dispatchStartTemporaryDetach() => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchStartTemporaryDetach,
      jni.JniType.voidType, []).check();

  static final _id_dispatchFinishTemporaryDetach = jniAccessors.getMethodIDOf(
      _classRef, "dispatchFinishTemporaryDetach", "()V");

  /// from: public void dispatchFinishTemporaryDetach()
  ///
  /// {@inheritDoc}
  ///@hide
  void dispatchFinishTemporaryDetach() => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchFinishTemporaryDetach,
      jni.JniType.voidType, []).check();

  static final _id_dispatchProvideStructure = jniAccessors.getMethodIDOf(
      _classRef, "dispatchProvideStructure", "(Landroid/view/ViewStructure;)V");

  /// from: public void dispatchProvideStructure(android.view.ViewStructure structure)
  ///
  /// Dispatch creation of ViewStructure down the hierarchy.  This implementation
  /// adds in all child views of the view group, in addition to calling the default View
  /// implementation.
  void dispatchProvideStructure(viewstructure_.ViewStructure structure) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchProvideStructure,
          jni.JniType.voidType, [structure.reference]).check();

  static final _id_dispatchProvideAutofillStructure =
      jniAccessors.getMethodIDOf(_classRef, "dispatchProvideAutofillStructure",
          "(Landroid/view/ViewStructure;I)V");

  /// from: public void dispatchProvideAutofillStructure(android.view.ViewStructure structure, int flags)
  ///
  /// {@inheritDoc}
  ///
  /// This implementation adds in all child views of the view group, in addition to calling the
  /// default View implementation.
  ///@param flags Value is either <code>0</code> or android.view.View\#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  void dispatchProvideAutofillStructure(
          viewstructure_.ViewStructure structure, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchProvideAutofillStructure,
          jni.JniType.voidType,
          [structure.reference, flags]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_notifySubtreeAccessibilityStateChanged =
      jniAccessors.getMethodIDOf(
          _classRef,
          "notifySubtreeAccessibilityStateChanged",
          "(Landroid/view/View;Landroid/view/View;I)V");

  /// from: public void notifySubtreeAccessibilityStateChanged(android.view.View child, android.view.View source, int changeType)
  void notifySubtreeAccessibilityStateChanged(
          view_.View child, view_.View source, int changeType) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifySubtreeAccessibilityStateChanged,
          jni.JniType.voidType,
          [child.reference, source.reference, changeType]).check();

  static final _id_onNestedPrePerformAccessibilityAction =
      jniAccessors.getMethodIDOf(
          _classRef,
          "onNestedPrePerformAccessibilityAction",
          "(Landroid/view/View;ILandroid/os/Bundle;)Z");

  /// from: public boolean onNestedPrePerformAccessibilityAction(android.view.View target, int action, android.os.Bundle args)
  ///
  /// {@inheritDoc}
  ///
  /// Subclasses should always call <code>super.onNestedPrePerformAccessibilityAction</code>
  ///
  ///@param target The target view dispatching this action
  ///@param action Action being performed; see
  ///               android.view.accessibility.AccessibilityNodeInfo
  ///@param args Optional action arguments
  ///@return false by default. Subclasses should return true if they handle the event.
  bool onNestedPrePerformAccessibilityAction(
          view_.View target, int action, bundle_.Bundle args) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedPrePerformAccessibilityAction,
          jni.JniType.booleanType,
          [target.reference, action, args.reference]).boolean;

  static final _id_dispatchSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "dispatchSaveInstanceState", "(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchSaveInstanceState(android.util.SparseArray<android.os.Parcelable> container)
  void dispatchSaveInstanceState(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchSaveInstanceState,
          jni.JniType.voidType, [container.reference]).check();

  static final _id_dispatchFreezeSelfOnly = jniAccessors.getMethodIDOf(
      _classRef, "dispatchFreezeSelfOnly", "(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchFreezeSelfOnly(android.util.SparseArray<android.os.Parcelable> container)
  ///
  /// Perform dispatching of a \#saveHierarchyState(android.util.SparseArray)  freeze()}
  /// to only this view, not to its children.  For use when overriding
  /// \#dispatchSaveInstanceState(android.util.SparseArray)  dispatchFreeze()} to allow
  /// subclasses to freeze their own state but not the state of their children.
  ///@param container the container
  void dispatchFreezeSelfOnly(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchFreezeSelfOnly,
          jni.JniType.voidType, [container.reference]).check();

  static final _id_dispatchRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchRestoreInstanceState",
      "(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchRestoreInstanceState(android.util.SparseArray<android.os.Parcelable> container)
  void dispatchRestoreInstanceState(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchRestoreInstanceState,
          jni.JniType.voidType,
          [container.reference]).check();

  static final _id_dispatchThawSelfOnly = jniAccessors.getMethodIDOf(
      _classRef, "dispatchThawSelfOnly", "(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchThawSelfOnly(android.util.SparseArray<android.os.Parcelable> container)
  ///
  /// Perform dispatching of a \#restoreHierarchyState(android.util.SparseArray)
  /// to only this view, not to its children.  For use when overriding
  /// \#dispatchRestoreInstanceState(android.util.SparseArray) to allow
  /// subclasses to thaw their own state but not the state of their children.
  ///@param container the container
  void dispatchThawSelfOnly(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchThawSelfOnly,
          jni.JniType.voidType, [container.reference]).check();

  static final _id_setChildrenDrawingCacheEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setChildrenDrawingCacheEnabled", "(Z)V");

  /// from: protected void setChildrenDrawingCacheEnabled(boolean enabled)
  ///
  /// Enables or disables the drawing cache for each child of this view group.
  ///@param enabled true to enable the cache, false to dispose of it
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void setChildrenDrawingCacheEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setChildrenDrawingCacheEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_dispatchDraw = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_getOverlay1 = jniAccessors.getMethodIDOf(
      _classRef, "getOverlay", "()Landroid/view/ViewGroupOverlay;");

  /// from: public android.view.ViewGroupOverlay getOverlay()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ViewGroupOverlay for this view group, creating it if it does
  /// not yet exist. In addition to ViewOverlay's support for drawables,
  /// ViewGroupOverlay allows views to be added to the overlay. These
  /// views, like overlay drawables, are visual-only; they do not receive input
  /// events and should not be used as anything other than a temporary
  /// representation of a view in a parent container, such as might be used
  /// by an animation effect.
  ///
  /// Note: Overlays do not currently work correctly with SurfaceView or TextureView; contents in overlays for these
  /// types of views may not display correctly.
  ///
  ///@return The ViewGroupOverlay object for this view.
  ///@see ViewGroupOverlay
  viewgroupoverlay_.ViewGroupOverlay getOverlay1() =>
      viewgroupoverlay_.ViewGroupOverlay.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getOverlay1, jni.JniType.objectType, []).object);

  static final _id_getChildDrawingOrder =
      jniAccessors.getMethodIDOf(_classRef, "getChildDrawingOrder", "(II)I");

  /// from: protected int getChildDrawingOrder(int childCount, int i)
  ///
  /// Returns the index of the child to draw for this iteration. Override this
  /// if you want to change the drawing order of children. By default, it
  /// returns i.
  ///
  /// NOTE: In order for this method to be called, you must enable child ordering
  /// first by calling \#setChildrenDrawingOrderEnabled(boolean).
  ///@param i The current iteration.
  ///@return The index of the child to draw this iteration.
  ///@see \#setChildrenDrawingOrderEnabled(boolean)
  ///@see \#isChildrenDrawingOrderEnabled()
  int getChildDrawingOrder(int childCount, int i) =>
      jniAccessors.callMethodWithArgs(reference, _id_getChildDrawingOrder,
          jni.JniType.intType, [childCount, i]).integer;

  static final _id_drawChild = jniAccessors.getMethodIDOf(_classRef,
      "drawChild", "(Landroid/graphics/Canvas;Landroid/view/View;J)Z");

  /// from: protected boolean drawChild(android.graphics.Canvas canvas, android.view.View child, long drawingTime)
  ///
  /// Draw one child of this View Group. This method is responsible for getting
  /// the canvas in the right state. This includes clipping, translating so
  /// that the child's scrolled origin is at 0, 0, and applying any animation
  /// transformations.
  ///@param canvas The canvas on which to draw the child
  ///@param child Who to draw
  ///@param drawingTime The time at which draw is occurring
  ///@return True if an invalidate() was issued
  bool drawChild(canvas_.Canvas canvas, view_.View child, int drawingTime) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawChild,
          jni.JniType.booleanType,
          [canvas.reference, child.reference, drawingTime]).boolean;

  static final _id_getClipChildren =
      jniAccessors.getMethodIDOf(_classRef, "getClipChildren", "()Z");

  /// from: public boolean getClipChildren()
  ///
  /// Returns whether this group's children are clipped to their bounds before drawing.
  /// The default value is true.
  ///@see \#setClipChildren(boolean)
  ///@return True if the group's children will be clipped to their bounds,
  /// false otherwise.
  bool getClipChildren() => jniAccessors.callMethodWithArgs(
      reference, _id_getClipChildren, jni.JniType.booleanType, []).boolean;

  static final _id_setClipChildren =
      jniAccessors.getMethodIDOf(_classRef, "setClipChildren", "(Z)V");

  /// from: public void setClipChildren(boolean clipChildren)
  ///
  /// By default, children are clipped to their bounds before drawing. This
  /// allows view groups to override this behavior for animations, etc.
  ///@param clipChildren true to clip children to their bounds,
  ///        false otherwise
  ///@attr ref android.R.styleable\#ViewGroup_clipChildren
  void setClipChildren(bool clipChildren) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClipChildren,
      jni.JniType.voidType,
      [clipChildren]).check();

  static final _id_setClipToPadding =
      jniAccessors.getMethodIDOf(_classRef, "setClipToPadding", "(Z)V");

  /// from: public void setClipToPadding(boolean clipToPadding)
  ///
  /// Sets whether this ViewGroup will clip its children to its padding and resize (but not
  /// clip) any EdgeEffect to the padded region, if padding is present.
  ///
  /// By default, children are clipped to the padding of their parent
  /// ViewGroup. This clipping behavior is only enabled if padding is non-zero.
  ///@param clipToPadding true to clip children to the padding of the group, and resize (but
  ///        not clip) any EdgeEffect to the padded region. False otherwise.
  ///@attr ref android.R.styleable\#ViewGroup_clipToPadding
  void setClipToPadding(bool clipToPadding) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClipToPadding,
      jni.JniType.voidType,
      [clipToPadding]).check();

  static final _id_getClipToPadding =
      jniAccessors.getMethodIDOf(_classRef, "getClipToPadding", "()Z");

  /// from: public boolean getClipToPadding()
  ///
  /// Returns whether this ViewGroup will clip its children to its padding, and resize (but
  /// not clip) any EdgeEffect to the padded region, if padding is present.
  ///
  /// By default, children are clipped to the padding of their parent
  /// Viewgroup. This clipping behavior is only enabled if padding is non-zero.
  ///@return true if this ViewGroup clips children to its padding and resizes (but doesn't
  ///         clip) any EdgeEffect to the padded region, false otherwise.
  ///@attr ref android.R.styleable\#ViewGroup_clipToPadding
  bool getClipToPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getClipToPadding, jni.JniType.booleanType, []).boolean;

  static final _id_dispatchSetSelected =
      jniAccessors.getMethodIDOf(_classRef, "dispatchSetSelected", "(Z)V");

  /// from: public void dispatchSetSelected(boolean selected)
  void dispatchSetSelected(bool selected) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchSetSelected,
      jni.JniType.voidType,
      [selected]).check();

  static final _id_dispatchSetActivated =
      jniAccessors.getMethodIDOf(_classRef, "dispatchSetActivated", "(Z)V");

  /// from: public void dispatchSetActivated(boolean activated)
  void dispatchSetActivated(bool activated) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchSetActivated,
      jni.JniType.voidType,
      [activated]).check();

  static final _id_dispatchSetPressed =
      jniAccessors.getMethodIDOf(_classRef, "dispatchSetPressed", "(Z)V");

  /// from: protected void dispatchSetPressed(boolean pressed)
  void dispatchSetPressed(bool pressed) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchSetPressed,
      jni.JniType.voidType,
      [pressed]).check();

  static final _id_dispatchDrawableHotspotChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDrawableHotspotChanged", "(FF)V");

  /// from: public void dispatchDrawableHotspotChanged(float x, float y)
  ///
  /// Dispatches drawable hotspot changes to child views that meet at least
  /// one of the following criteria:
  /// <ul>
  ///     <li>Returns {@code false} from both View\#isClickable() and
  ///     View\#isLongClickable()</li>
  ///     <li>Requests duplication of parent state via
  ///     View\#setDuplicateParentStateEnabled(boolean)</li>
  /// </ul>
  ///@param x hotspot x coordinate
  ///@param y hotspot y coordinate
  ///@see \#drawableHotspotChanged(float, float)
  void dispatchDrawableHotspotChanged(double x, double y) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchDrawableHotspotChanged,
          jni.JniType.voidType,
          [x, y]).check();

  static final _id_setStaticTransformationsEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setStaticTransformationsEnabled", "(Z)V");

  /// from: protected void setStaticTransformationsEnabled(boolean enabled)
  ///
  /// When this property is set to true, this ViewGroup supports static transformations on
  /// children; this causes
  /// \#getChildStaticTransformation(View, android.view.animation.Transformation) to be
  /// invoked when a child is drawn.
  ///
  /// Any subclass overriding
  /// \#getChildStaticTransformation(View, android.view.animation.Transformation) should
  /// set this property to true.
  ///@param enabled True to enable static transformations on children, false otherwise.
  ///@see \#getChildStaticTransformation(View, android.view.animation.Transformation)
  void setStaticTransformationsEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setStaticTransformationsEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_getChildStaticTransformation = jniAccessors.getMethodIDOf(
      _classRef,
      "getChildStaticTransformation",
      "(Landroid/view/View;Landroid/view/animation/Transformation;)Z");

  /// from: protected boolean getChildStaticTransformation(android.view.View child, android.view.animation.Transformation t)
  ///
  /// Sets  <code>t</code> to be the static transformation of the child, if set, returning a
  /// boolean to indicate whether a static transform was set. The default implementation
  /// simply returns <code>false</code>; subclasses may override this method for different
  /// behavior. \#setStaticTransformationsEnabled(boolean) must be set to true
  /// for this method to be called.
  ///@param child The child view whose static transform is being requested
  ///@param t The Transformation which will hold the result
  ///@return true if the transformation was set, false otherwise
  ///@see \#setStaticTransformationsEnabled(boolean)
  bool getChildStaticTransformation(
          view_.View child, transformation_.Transformation t) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getChildStaticTransformation,
          jni.JniType.booleanType,
          [child.reference, t.reference]).boolean;

  static final _id_addView = jniAccessors.getMethodIDOf(
      _classRef, "addView", "(Landroid/view/View;)V");

  /// from: public void addView(android.view.View child)
  ///
  /// Adds a child view. If no layout parameters are already set on the child, the
  /// default parameters for this ViewGroup are set on the child.
  ///
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param child the child view to add
  ///@see \#generateDefaultLayoutParams()
  void addView(view_.View child) => jniAccessors.callMethodWithArgs(
      reference, _id_addView, jni.JniType.voidType, [child.reference]).check();

  static final _id_addView1 = jniAccessors.getMethodIDOf(
      _classRef, "addView", "(Landroid/view/View;I)V");

  /// from: public void addView(android.view.View child, int index)
  ///
  /// Adds a child view. If no layout parameters are already set on the child, the
  /// default parameters for this ViewGroup are set on the child.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param child the child view to add
  ///@param index the position at which to add the child
  ///@see \#generateDefaultLayoutParams()
  void addView1(view_.View child, int index) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addView1,
      jni.JniType.voidType,
      [child.reference, index]).check();

  static final _id_addView2 = jniAccessors.getMethodIDOf(
      _classRef, "addView", "(Landroid/view/View;II)V");

  /// from: public void addView(android.view.View child, int width, int height)
  ///
  /// Adds a child view with this ViewGroup's default layout parameters and the
  /// specified width and height.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param child the child view to add
  void addView2(view_.View child, int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_addView2,
          jni.JniType.voidType, [child.reference, width, height]).check();

  static final _id_addView3 = jniAccessors.getMethodIDOf(_classRef, "addView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void addView(android.view.View child, android.view.ViewGroup.LayoutParams params)
  ///
  /// Adds a child view with the specified layout parameters.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param child the child view to add
  ///@param params the layout parameters to set on the child
  void addView3(view_.View child, ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_addView3,
          jni.JniType.voidType, [child.reference, params.reference]).check();

  static final _id_addView4 = jniAccessors.getMethodIDOf(_classRef, "addView",
      "(Landroid/view/View;ILandroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void addView(android.view.View child, int index, android.view.ViewGroup.LayoutParams params)
  ///
  /// Adds a child view with the specified layout parameters.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param child the child view to add
  ///@param index the position at which to add the child or -1 to add last
  ///@param params the layout parameters to set on the child
  void addView4(view_.View child, int index, ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addView4,
          jni.JniType.voidType,
          [child.reference, index, params.reference]).check();

  static final _id_updateViewLayout = jniAccessors.getMethodIDOf(
      _classRef,
      "updateViewLayout",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void updateViewLayout(android.view.View view, android.view.ViewGroup.LayoutParams params)
  void updateViewLayout(view_.View view, ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateViewLayout,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_checkLayoutParams = jniAccessors.getMethodIDOf(_classRef,
      "checkLayoutParams", "(Landroid/view/ViewGroup\$LayoutParams;)Z");

  /// from: protected boolean checkLayoutParams(android.view.ViewGroup.LayoutParams p)
  bool checkLayoutParams(ViewGroup_LayoutParams p) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkLayoutParams,
          jni.JniType.booleanType, [p.reference]).boolean;

  static final _id_setOnHierarchyChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnHierarchyChangeListener",
      "(Landroid/view/ViewGroup\$OnHierarchyChangeListener;)V");

  /// from: public void setOnHierarchyChangeListener(android.view.ViewGroup.OnHierarchyChangeListener listener)
  ///
  /// Register a callback to be invoked when a child is added to or removed
  /// from this view.
  ///@param listener the callback to invoke on hierarchy change
  void setOnHierarchyChangeListener(
          ViewGroup_OnHierarchyChangeListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnHierarchyChangeListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_onViewAdded = jniAccessors.getMethodIDOf(
      _classRef, "onViewAdded", "(Landroid/view/View;)V");

  /// from: public void onViewAdded(android.view.View child)
  ///
  /// Called when a new child is added to this ViewGroup. Overrides should always
  /// call super.onViewAdded.
  ///@param child the added child view
  void onViewAdded(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onViewAdded,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_onViewRemoved = jniAccessors.getMethodIDOf(
      _classRef, "onViewRemoved", "(Landroid/view/View;)V");

  /// from: public void onViewRemoved(android.view.View child)
  ///
  /// Called when a child view is removed from this ViewGroup. Overrides should always
  /// call super.onViewRemoved.
  ///@param child the removed child view
  void onViewRemoved(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onViewRemoved,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_addViewInLayout = jniAccessors.getMethodIDOf(
      _classRef,
      "addViewInLayout",
      "(Landroid/view/View;ILandroid/view/ViewGroup\$LayoutParams;)Z");

  /// from: protected boolean addViewInLayout(android.view.View child, int index, android.view.ViewGroup.LayoutParams params)
  ///
  /// Adds a view during layout. This is useful if in your onLayout() method,
  /// you need to add more views (as does the list view for example).
  ///
  /// If index is negative, it means put it at the end of the list.
  ///@param child the view to add to the group
  ///@param index the index at which the child must be added or -1 to add last
  ///@param params the layout parameters to associate with the child
  ///@return true if the child was added, false otherwise
  bool addViewInLayout(
          view_.View child, int index, ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addViewInLayout,
          jni.JniType.booleanType,
          [child.reference, index, params.reference]).boolean;

  static final _id_addViewInLayout1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addViewInLayout",
      "(Landroid/view/View;ILandroid/view/ViewGroup\$LayoutParams;Z)Z");

  /// from: protected boolean addViewInLayout(android.view.View child, int index, android.view.ViewGroup.LayoutParams params, boolean preventRequestLayout)
  ///
  /// Adds a view during layout. This is useful if in your onLayout() method,
  /// you need to add more views (as does the list view for example).
  ///
  /// If index is negative, it means put it at the end of the list.
  ///@param child the view to add to the group
  ///@param index the index at which the child must be added or -1 to add last
  ///@param params the layout parameters to associate with the child
  ///@param preventRequestLayout if true, calling this method will not trigger a
  ///        layout request on child
  ///@return true if the child was added, false otherwise
  bool addViewInLayout1(view_.View child, int index,
          ViewGroup_LayoutParams params, bool preventRequestLayout) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_addViewInLayout1, jni.JniType.booleanType, [
        child.reference,
        index,
        params.reference,
        preventRequestLayout
      ]).boolean;

  static final _id_cleanupLayoutState = jniAccessors.getMethodIDOf(
      _classRef, "cleanupLayoutState", "(Landroid/view/View;)V");

  /// from: protected void cleanupLayoutState(android.view.View child)
  ///
  /// Prevents the specified child to be laid out during the next layout pass.
  ///@param child the child on which to perform the cleanup
  void cleanupLayoutState(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_cleanupLayoutState,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_attachLayoutAnimationParameters = jniAccessors.getMethodIDOf(
      _classRef,
      "attachLayoutAnimationParameters",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;II)V");

  /// from: protected void attachLayoutAnimationParameters(android.view.View child, android.view.ViewGroup.LayoutParams params, int index, int count)
  ///
  /// Subclasses should override this method to set layout animation
  /// parameters on the supplied child.
  ///@param child the child to associate with animation parameters
  ///@param params the child's layout parameters which hold the animation
  ///        parameters
  ///@param index the index of the child in the view group
  ///@param count the number of children in the view group
  void attachLayoutAnimationParameters(view_.View child,
          ViewGroup_LayoutParams params, int index, int count) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_attachLayoutAnimationParameters,
          jni.JniType.voidType,
          [child.reference, params.reference, index, count]).check();

  static final _id_removeView = jniAccessors.getMethodIDOf(
      _classRef, "removeView", "(Landroid/view/View;)V");

  /// from: public void removeView(android.view.View view)
  ///
  /// {@inheritDoc}
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  void removeView(view_.View view) => jniAccessors.callMethodWithArgs(reference,
      _id_removeView, jni.JniType.voidType, [view.reference]).check();

  static final _id_removeViewInLayout = jniAccessors.getMethodIDOf(
      _classRef, "removeViewInLayout", "(Landroid/view/View;)V");

  /// from: public void removeViewInLayout(android.view.View view)
  ///
  /// Removes a view during layout. This is useful if in your onLayout() method,
  /// you need to remove more views.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param view the view to remove from the group
  void removeViewInLayout(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeViewInLayout,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_removeViewsInLayout =
      jniAccessors.getMethodIDOf(_classRef, "removeViewsInLayout", "(II)V");

  /// from: public void removeViewsInLayout(int start, int count)
  ///
  /// Removes a range of views during layout. This is useful if in your onLayout() method,
  /// you need to remove more views.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param start the index of the first view to remove from the group
  ///@param count the number of views to remove from the group
  void removeViewsInLayout(int start, int count) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeViewsInLayout,
          jni.JniType.voidType, [start, count]).check();

  static final _id_removeViewAt =
      jniAccessors.getMethodIDOf(_classRef, "removeViewAt", "(I)V");

  /// from: public void removeViewAt(int index)
  ///
  /// Removes the view at the specified position in the group.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param index the position in the group of the view to remove
  void removeViewAt(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_removeViewAt, jni.JniType.voidType, [index]).check();

  static final _id_removeViews =
      jniAccessors.getMethodIDOf(_classRef, "removeViews", "(II)V");

  /// from: public void removeViews(int start, int count)
  ///
  /// Removes the specified range of views from the group.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  ///@param start the first position in the group of the range of views to remove
  ///@param count the number of views to remove
  void removeViews(int start, int count) => jniAccessors.callMethodWithArgs(
      reference, _id_removeViews, jni.JniType.voidType, [start, count]).check();

  static final _id_setLayoutTransition = jniAccessors.getMethodIDOf(_classRef,
      "setLayoutTransition", "(Landroid/animation/LayoutTransition;)V");

  /// from: public void setLayoutTransition(android.animation.LayoutTransition transition)
  ///
  /// Sets the LayoutTransition object for this ViewGroup. If the LayoutTransition object is
  /// not null, changes in layout which occur because of children being added to or removed from
  /// the ViewGroup will be animated according to the animations defined in that LayoutTransition
  /// object. By default, the transition object is null (so layout changes are not animated).
  ///
  /// Replacing a non-null transition will cause that previous transition to be
  /// canceled, if it is currently running, to restore this container to
  /// its correct post-transition state.
  ///
  ///@param transition The LayoutTransition object that will animated changes in layout. A value
  /// of <code>null</code> means no transition will run on layout changes.
  ///@attr ref android.R.styleable\#ViewGroup_animateLayoutChanges
  void setLayoutTransition(layouttransition_.LayoutTransition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_getLayoutTransition = jniAccessors.getMethodIDOf(_classRef,
      "getLayoutTransition", "()Landroid/animation/LayoutTransition;");

  /// from: public android.animation.LayoutTransition getLayoutTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the LayoutTransition object for this ViewGroup. If the LayoutTransition object is
  /// not null, changes in layout which occur because of children being added to or removed from
  /// the ViewGroup will be animated according to the animations defined in that LayoutTransition
  /// object. By default, the transition object is null (so layout changes are not animated).
  ///@return LayoutTranstion The LayoutTransition object that will animated changes in layout.
  /// A value of <code>null</code> means no transition will run on layout changes.
  layouttransition_.LayoutTransition getLayoutTransition() =>
      layouttransition_.LayoutTransition.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getLayoutTransition,
              jni.JniType.objectType, []).object);

  static final _id_removeAllViews =
      jniAccessors.getMethodIDOf(_classRef, "removeAllViews", "()V");

  /// from: public void removeAllViews()
  ///
  /// Call this method to remove all child views from the
  /// ViewGroup.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  void removeAllViews() => jniAccessors.callMethodWithArgs(
      reference, _id_removeAllViews, jni.JniType.voidType, []).check();

  static final _id_removeAllViewsInLayout =
      jniAccessors.getMethodIDOf(_classRef, "removeAllViewsInLayout", "()V");

  /// from: public void removeAllViewsInLayout()
  ///
  /// Called by a ViewGroup subclass to remove child views from itself,
  /// when it must first know its size on screen before it can calculate how many
  /// child views it will render. An example is a Gallery or a ListView, which
  /// may "have" 50 children, but actually only render the number of children
  /// that can currently fit inside the object on screen. Do not call
  /// this method unless you are extending ViewGroup and understand the
  /// view measuring and layout pipeline.
  ///
  /// <strong>Note:</strong> do not invoke this method from
  /// \#draw(android.graphics.Canvas), \#onDraw(android.graphics.Canvas),
  /// \#dispatchDraw(android.graphics.Canvas) or any related method.
  ///
  void removeAllViewsInLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_removeAllViewsInLayout, jni.JniType.voidType, []).check();

  static final _id_removeDetachedView = jniAccessors.getMethodIDOf(
      _classRef, "removeDetachedView", "(Landroid/view/View;Z)V");

  /// from: protected void removeDetachedView(android.view.View child, boolean animate)
  ///
  /// Finishes the removal of a detached view. This method will dispatch the detached from
  /// window event and notify the hierarchy change listener.
  ///
  /// This method is intended to be lightweight and makes no assumptions about whether the
  /// parent or child should be redrawn. Proper use of this method will include also making
  /// any appropriate \#requestLayout() or \#invalidate() calls.
  /// For example, callers can \#post(Runnable) post a Runnable
  /// which performs a \#requestLayout() on the next frame, after all detach/remove
  /// calls are finished, causing layout to be run prior to redrawing the view hierarchy.
  ///@param child the child to be definitely removed from the view hierarchy
  ///@param animate if true and the view has an animation, the view is placed in the
  ///                disappearing views list, otherwise, it is detached from the window
  ///@see \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  ///@see \#detachAllViewsFromParent()
  ///@see \#detachViewFromParent(View)
  ///@see \#detachViewFromParent(int)
  void removeDetachedView(view_.View child, bool animate) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeDetachedView,
          jni.JniType.voidType, [child.reference, animate]).check();

  static final _id_attachViewToParent = jniAccessors.getMethodIDOf(
      _classRef,
      "attachViewToParent",
      "(Landroid/view/View;ILandroid/view/ViewGroup\$LayoutParams;)V");

  /// from: protected void attachViewToParent(android.view.View child, int index, android.view.ViewGroup.LayoutParams params)
  ///
  /// Attaches a view to this view group. Attaching a view assigns this group as the parent,
  /// sets the layout parameters and puts the view in the list of children so that
  /// it can be retrieved by calling \#getChildAt(int).
  ///
  /// This method is intended to be lightweight and makes no assumptions about whether the
  /// parent or child should be redrawn. Proper use of this method will include also making
  /// any appropriate \#requestLayout() or \#invalidate() calls.
  /// For example, callers can \#post(Runnable) post a Runnable
  /// which performs a \#requestLayout() on the next frame, after all detach/attach
  /// calls are finished, causing layout to be run prior to redrawing the view hierarchy.
  ///
  /// This method should be called only for views which were detached from their parent.
  ///@param child the child to attach
  ///@param index the index at which the child should be attached
  ///@param params the layout parameters of the child
  ///@see \#removeDetachedView(View, boolean)
  ///@see \#detachAllViewsFromParent()
  ///@see \#detachViewFromParent(View)
  ///@see \#detachViewFromParent(int)
  void attachViewToParent(
          view_.View child, int index, ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_attachViewToParent,
          jni.JniType.voidType,
          [child.reference, index, params.reference]).check();

  static final _id_detachViewFromParent = jniAccessors.getMethodIDOf(
      _classRef, "detachViewFromParent", "(Landroid/view/View;)V");

  /// from: protected void detachViewFromParent(android.view.View child)
  ///
  /// Detaches a view from its parent. Detaching a view should be followed
  /// either by a call to
  /// \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  /// or a call to \#removeDetachedView(View, boolean). Detachment should only be
  /// temporary; reattachment or removal should happen within the same drawing cycle as
  /// detachment. When a view is detached, its parent is null and cannot be retrieved by a
  /// call to \#getChildAt(int).
  ///@param child the child to detach
  ///@see \#detachViewFromParent(int)
  ///@see \#detachViewsFromParent(int, int)
  ///@see \#detachAllViewsFromParent()
  ///@see \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  ///@see \#removeDetachedView(View, boolean)
  void detachViewFromParent(view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_detachViewFromParent,
          jni.JniType.voidType, [child.reference]).check();

  static final _id_detachViewFromParent1 =
      jniAccessors.getMethodIDOf(_classRef, "detachViewFromParent", "(I)V");

  /// from: protected void detachViewFromParent(int index)
  ///
  /// Detaches a view from its parent. Detaching a view should be followed
  /// either by a call to
  /// \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  /// or a call to \#removeDetachedView(View, boolean). Detachment should only be
  /// temporary; reattachment or removal should happen within the same drawing cycle as
  /// detachment. When a view is detached, its parent is null and cannot be retrieved by a
  /// call to \#getChildAt(int).
  ///@param index the index of the child to detach
  ///@see \#detachViewFromParent(View)
  ///@see \#detachAllViewsFromParent()
  ///@see \#detachViewsFromParent(int, int)
  ///@see \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  ///@see \#removeDetachedView(View, boolean)
  void detachViewFromParent1(int index) => jniAccessors.callMethodWithArgs(
      reference,
      _id_detachViewFromParent1,
      jni.JniType.voidType,
      [index]).check();

  static final _id_detachViewsFromParent =
      jniAccessors.getMethodIDOf(_classRef, "detachViewsFromParent", "(II)V");

  /// from: protected void detachViewsFromParent(int start, int count)
  ///
  /// Detaches a range of views from their parents. Detaching a view should be followed
  /// either by a call to
  /// \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  /// or a call to \#removeDetachedView(View, boolean). Detachment should only be
  /// temporary; reattachment or removal should happen within the same drawing cycle as
  /// detachment. When a view is detached, its parent is null and cannot be retrieved by a
  /// call to \#getChildAt(int).
  ///@param start the first index of the childrend range to detach
  ///@param count the number of children to detach
  ///@see \#detachViewFromParent(View)
  ///@see \#detachViewFromParent(int)
  ///@see \#detachAllViewsFromParent()
  ///@see \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  ///@see \#removeDetachedView(View, boolean)
  void detachViewsFromParent(int start, int count) =>
      jniAccessors.callMethodWithArgs(reference, _id_detachViewsFromParent,
          jni.JniType.voidType, [start, count]).check();

  static final _id_detachAllViewsFromParent =
      jniAccessors.getMethodIDOf(_classRef, "detachAllViewsFromParent", "()V");

  /// from: protected void detachAllViewsFromParent()
  ///
  /// Detaches all views from the parent. Detaching a view should be followed
  /// either by a call to
  /// \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  /// or a call to \#removeDetachedView(View, boolean). Detachment should only be
  /// temporary; reattachment or removal should happen within the same drawing cycle as
  /// detachment. When a view is detached, its parent is null and cannot be retrieved by a
  /// call to \#getChildAt(int).
  ///@see \#detachViewFromParent(View)
  ///@see \#detachViewFromParent(int)
  ///@see \#detachViewsFromParent(int, int)
  ///@see \#attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
  ///@see \#removeDetachedView(View, boolean)
  void detachAllViewsFromParent() => jniAccessors.callMethodWithArgs(reference,
      _id_detachAllViewsFromParent, jni.JniType.voidType, []).check();

  static final _id_onDescendantInvalidated = jniAccessors.getMethodIDOf(
      _classRef,
      "onDescendantInvalidated",
      "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void onDescendantInvalidated(android.view.View child, android.view.View target)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  ///@param child This value must never be {@code null}.
  ///@param target This value must never be {@code null}.
  void onDescendantInvalidated(view_.View child, view_.View target) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDescendantInvalidated,
          jni.JniType.voidType, [child.reference, target.reference]).check();

  static final _id_invalidateChild = jniAccessors.getMethodIDOf(_classRef,
      "invalidateChild", "(Landroid/view/View;Landroid/graphics/Rect;)V");

  /// from: public final void invalidateChild(android.view.View child, android.graphics.Rect dirty)
  ///
  /// Don't call or override this method. It is used for the implementation of
  /// the view hierarchy.
  ///@deprecated Use \#onDescendantInvalidated(View, View) instead to observe updates to
  /// draw state in descendants.
  void invalidateChild(view_.View child, rect_.Rect dirty) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateChild,
          jni.JniType.voidType, [child.reference, dirty.reference]).check();

  static final _id_invalidateChildInParent = jniAccessors.getMethodIDOf(
      _classRef,
      "invalidateChildInParent",
      "([ILandroid/graphics/Rect;)Landroid/view/ViewParent;");

  /// from: public android.view.ViewParent invalidateChildInParent(int[] location, android.graphics.Rect dirty)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Don't call or override this method. It is used for the implementation of
  /// the view hierarchy.
  ///
  /// This implementation returns null if this ViewGroup does not have a parent,
  /// if this ViewGroup is already fully invalidated or if the dirty rectangle
  /// does not intersect with this ViewGroup's bounds.
  ///@deprecated Use \#onDescendantInvalidated(View, View) instead to observe updates to
  /// draw state in descendants.
  viewparent_.ViewParent invalidateChildInParent(
          jni.JniObject location, rect_.Rect dirty) =>
      viewparent_.ViewParent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_invalidateChildInParent,
          jni.JniType.objectType,
          [location.reference, dirty.reference]).object);

  static final _id_offsetDescendantRectToMyCoords = jniAccessors.getMethodIDOf(
      _classRef,
      "offsetDescendantRectToMyCoords",
      "(Landroid/view/View;Landroid/graphics/Rect;)V");

  /// from: public final void offsetDescendantRectToMyCoords(android.view.View descendant, android.graphics.Rect rect)
  ///
  /// Offset a rectangle that is in a descendant's coordinate
  /// space into our coordinate space.
  ///@param descendant A descendant of this view
  ///@param rect A rectangle defined in descendant's coordinate space.
  void offsetDescendantRectToMyCoords(view_.View descendant, rect_.Rect rect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_offsetDescendantRectToMyCoords,
          jni.JniType.voidType,
          [descendant.reference, rect.reference]).check();

  static final _id_offsetRectIntoDescendantCoords = jniAccessors.getMethodIDOf(
      _classRef,
      "offsetRectIntoDescendantCoords",
      "(Landroid/view/View;Landroid/graphics/Rect;)V");

  /// from: public final void offsetRectIntoDescendantCoords(android.view.View descendant, android.graphics.Rect rect)
  ///
  /// Offset a rectangle that is in our coordinate space into an ancestor's
  /// coordinate space.
  ///@param descendant A descendant of this view
  ///@param rect A rectangle defined in descendant's coordinate space.
  void offsetRectIntoDescendantCoords(view_.View descendant, rect_.Rect rect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_offsetRectIntoDescendantCoords,
          jni.JniType.voidType,
          [descendant.reference, rect.reference]).check();

  static final _id_getChildVisibleRect = jniAccessors.getMethodIDOf(
      _classRef,
      "getChildVisibleRect",
      "(Landroid/view/View;Landroid/graphics/Rect;Landroid/graphics/Point;)Z");

  /// from: public boolean getChildVisibleRect(android.view.View child, android.graphics.Rect r, android.graphics.Point offset)
  bool getChildVisibleRect(
          view_.View child, rect_.Rect r, point_.Point offset) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getChildVisibleRect,
          jni.JniType.booleanType,
          [child.reference, r.reference, offset.reference]).boolean;

  static final _id_layout =
      jniAccessors.getMethodIDOf(_classRef, "layout", "(IIII)V");

  /// from: public final void layout(int l, int t, int r, int b)
  void layout(int l, int t, int r, int b) => jniAccessors.callMethodWithArgs(
      reference, _id_layout, jni.JniType.voidType, [l, t, r, b]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected abstract void onLayout(boolean changed, int l, int t, int r, int b)
  void onLayout(bool changed, int l, int t, int r, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, l, t, r, b]).check();

  static final _id_canAnimate =
      jniAccessors.getMethodIDOf(_classRef, "canAnimate", "()Z");

  /// from: protected boolean canAnimate()
  ///
  /// Indicates whether the view group has the ability to animate its children
  /// after the first layout.
  ///@return true if the children can be animated, false otherwise
  bool canAnimate() => jniAccessors.callMethodWithArgs(
      reference, _id_canAnimate, jni.JniType.booleanType, []).boolean;

  static final _id_startLayoutAnimation =
      jniAccessors.getMethodIDOf(_classRef, "startLayoutAnimation", "()V");

  /// from: public void startLayoutAnimation()
  ///
  /// Runs the layout animation. Calling this method triggers a relayout of
  /// this view group.
  void startLayoutAnimation() => jniAccessors.callMethodWithArgs(
      reference, _id_startLayoutAnimation, jni.JniType.voidType, []).check();

  static final _id_scheduleLayoutAnimation =
      jniAccessors.getMethodIDOf(_classRef, "scheduleLayoutAnimation", "()V");

  /// from: public void scheduleLayoutAnimation()
  ///
  /// Schedules the layout animation to be played after the next layout pass
  /// of this view group. This can be used to restart the layout animation
  /// when the content of the view group changes or when the activity is
  /// paused and resumed.
  void scheduleLayoutAnimation() => jniAccessors.callMethodWithArgs(
      reference, _id_scheduleLayoutAnimation, jni.JniType.voidType, []).check();

  static final _id_setLayoutAnimation = jniAccessors.getMethodIDOf(
      _classRef,
      "setLayoutAnimation",
      "(Landroid/view/animation/LayoutAnimationController;)V");

  /// from: public void setLayoutAnimation(android.view.animation.LayoutAnimationController controller)
  ///
  /// Sets the layout animation controller used to animate the group's
  /// children after the first layout.
  ///@param controller the animation controller
  void setLayoutAnimation(
          layoutanimationcontroller_.LayoutAnimationController controller) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutAnimation,
          jni.JniType.voidType, [controller.reference]).check();

  static final _id_getLayoutAnimation = jniAccessors.getMethodIDOf(
      _classRef,
      "getLayoutAnimation",
      "()Landroid/view/animation/LayoutAnimationController;");

  /// from: public android.view.animation.LayoutAnimationController getLayoutAnimation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the layout animation controller used to animate the group's
  /// children.
  ///@return the current animation controller
  layoutanimationcontroller_.LayoutAnimationController getLayoutAnimation() =>
      layoutanimationcontroller_.LayoutAnimationController.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getLayoutAnimation,
              jni.JniType.objectType, []).object);

  static final _id_isAnimationCacheEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isAnimationCacheEnabled", "()Z");

  /// from: public boolean isAnimationCacheEnabled()
  ///
  /// Indicates whether the children's drawing cache is used during a layout
  /// animation. By default, the drawing cache is enabled but this will prevent
  /// nested layout animations from working. To nest animations, you must disable
  /// the cache.
  ///@return true if the animation cache is enabled, false otherwise
  ///@see \#setAnimationCacheEnabled(boolean)
  ///@see View\#setDrawingCacheEnabled(boolean)
  ///@deprecated As of android.os.Build.VERSION_CODES\#M, this property is ignored.
  /// Caching behavior of children may be controlled through View\#setLayerType(int, Paint).
  bool isAnimationCacheEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isAnimationCacheEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setAnimationCacheEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setAnimationCacheEnabled", "(Z)V");

  /// from: public void setAnimationCacheEnabled(boolean enabled)
  ///
  /// Enables or disables the children's drawing cache during a layout animation.
  /// By default, the drawing cache is enabled but this will prevent nested
  /// layout animations from working. To nest animations, you must disable the
  /// cache.
  ///@param enabled true to enable the animation cache, false otherwise
  ///@see \#isAnimationCacheEnabled()
  ///@see View\#setDrawingCacheEnabled(boolean)
  ///@deprecated As of android.os.Build.VERSION_CODES\#M, this property is ignored.
  /// Caching behavior of children may be controlled through View\#setLayerType(int, Paint).
  void setAnimationCacheEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAnimationCacheEnabled,
          jni.JniType.voidType, [enabled]).check();

  static final _id_isAlwaysDrawnWithCacheEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isAlwaysDrawnWithCacheEnabled", "()Z");

  /// from: public boolean isAlwaysDrawnWithCacheEnabled()
  ///
  /// Indicates whether this ViewGroup will always try to draw its children using their
  /// drawing cache. By default this property is enabled.
  ///@return true if the animation cache is enabled, false otherwise
  ///@see \#setAlwaysDrawnWithCacheEnabled(boolean)
  ///@see \#setChildrenDrawnWithCacheEnabled(boolean)
  ///@see View\#setDrawingCacheEnabled(boolean)
  ///@deprecated As of android.os.Build.VERSION_CODES\#M, this property is ignored.
  /// Child views may no longer have their caching behavior disabled by parents.
  bool isAlwaysDrawnWithCacheEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isAlwaysDrawnWithCacheEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setAlwaysDrawnWithCacheEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setAlwaysDrawnWithCacheEnabled", "(Z)V");

  /// from: public void setAlwaysDrawnWithCacheEnabled(boolean always)
  ///
  /// Indicates whether this ViewGroup will always try to draw its children using their
  /// drawing cache. This property can be set to true when the cache rendering is
  /// slightly different from the children's normal rendering. Renderings can be different,
  /// for instance, when the cache's quality is set to low.
  ///
  /// When this property is disabled, the ViewGroup will use the drawing cache of its
  /// children only when asked to. It's usually the task of subclasses to tell ViewGroup
  /// when to start using the drawing cache and when to stop using it.
  ///@param always true to always draw with the drawing cache, false otherwise
  ///@see \#isAlwaysDrawnWithCacheEnabled()
  ///@see \#setChildrenDrawnWithCacheEnabled(boolean)
  ///@see View\#setDrawingCacheEnabled(boolean)
  ///@see View\#setDrawingCacheQuality(int)
  ///@deprecated As of android.os.Build.VERSION_CODES\#M, this property is ignored.
  /// Child views may no longer have their caching behavior disabled by parents.
  void setAlwaysDrawnWithCacheEnabled(bool always) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAlwaysDrawnWithCacheEnabled,
          jni.JniType.voidType,
          [always]).check();

  static final _id_isChildrenDrawnWithCacheEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isChildrenDrawnWithCacheEnabled", "()Z");

  /// from: protected boolean isChildrenDrawnWithCacheEnabled()
  ///
  /// Indicates whether the ViewGroup is currently drawing its children using
  /// their drawing cache.
  ///@return true if children should be drawn with their cache, false otherwise
  ///@see \#setAlwaysDrawnWithCacheEnabled(boolean)
  ///@see \#setChildrenDrawnWithCacheEnabled(boolean)
  ///@deprecated As of android.os.Build.VERSION_CODES\#M, this property is ignored.
  /// Child views may no longer be forced to cache their rendering state by their parents.
  /// Use View\#setLayerType(int, Paint) on individual Views instead.
  bool isChildrenDrawnWithCacheEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isChildrenDrawnWithCacheEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setChildrenDrawnWithCacheEnabled = jniAccessors
      .getMethodIDOf(_classRef, "setChildrenDrawnWithCacheEnabled", "(Z)V");

  /// from: protected void setChildrenDrawnWithCacheEnabled(boolean enabled)
  ///
  /// Tells the ViewGroup to draw its children using their drawing cache. This property
  /// is ignored when \#isAlwaysDrawnWithCacheEnabled() is true. A child's drawing cache
  /// will be used only if it has been enabled.
  ///
  /// Subclasses should call this method to start and stop using the drawing cache when
  /// they perform performance sensitive operations, like scrolling or animating.
  ///@param enabled true if children should be drawn with their cache, false otherwise
  ///@see \#setAlwaysDrawnWithCacheEnabled(boolean)
  ///@see \#isChildrenDrawnWithCacheEnabled()
  ///@deprecated As of android.os.Build.VERSION_CODES\#M, this property is ignored.
  /// Child views may no longer be forced to cache their rendering state by their parents.
  /// Use View\#setLayerType(int, Paint) on individual Views instead.
  void setChildrenDrawnWithCacheEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setChildrenDrawnWithCacheEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_isChildrenDrawingOrderEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isChildrenDrawingOrderEnabled", "()Z");

  /// from: protected boolean isChildrenDrawingOrderEnabled()
  ///
  /// Indicates whether the ViewGroup is drawing its children in the order defined by
  /// \#getChildDrawingOrder(int, int).
  ///@return true if children drawing order is defined by \#getChildDrawingOrder(int, int),
  ///         false otherwise
  ///@see \#setChildrenDrawingOrderEnabled(boolean)
  ///@see \#getChildDrawingOrder(int, int)
  bool isChildrenDrawingOrderEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isChildrenDrawingOrderEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setChildrenDrawingOrderEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setChildrenDrawingOrderEnabled", "(Z)V");

  /// from: protected void setChildrenDrawingOrderEnabled(boolean enabled)
  ///
  /// Tells the ViewGroup whether to draw its children in the order defined by the method
  /// \#getChildDrawingOrder(int, int).
  ///
  /// Note that View\#getZ() Z reordering, done by \#dispatchDraw(Canvas),
  /// will override custom child ordering done via this method.
  ///@param enabled true if the order of the children when drawing is determined by
  ///        \#getChildDrawingOrder(int, int), false otherwise
  ///@see \#isChildrenDrawingOrderEnabled()
  ///@see \#getChildDrawingOrder(int, int)
  void setChildrenDrawingOrderEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setChildrenDrawingOrderEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_getPersistentDrawingCache =
      jniAccessors.getMethodIDOf(_classRef, "getPersistentDrawingCache", "()I");

  /// from: public int getPersistentDrawingCache()
  ///
  /// Returns an integer indicating what types of drawing caches are kept in memory.
  ///@see \#setPersistentDrawingCache(int)
  ///@see \#setAnimationCacheEnabled(boolean)
  ///@return one or a combination of \#PERSISTENT_NO_CACHE,
  ///         \#PERSISTENT_ANIMATION_CACHE, \#PERSISTENT_SCROLLING_CACHE
  ///         and \#PERSISTENT_ALL_CACHES
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  int getPersistentDrawingCache() => jniAccessors.callMethodWithArgs(reference,
      _id_getPersistentDrawingCache, jni.JniType.intType, []).integer;

  static final _id_setPersistentDrawingCache = jniAccessors.getMethodIDOf(
      _classRef, "setPersistentDrawingCache", "(I)V");

  /// from: public void setPersistentDrawingCache(int drawingCacheToKeep)
  ///
  /// Indicates what types of drawing caches should be kept in memory after
  /// they have been created.
  ///@see \#getPersistentDrawingCache()
  ///@see \#setAnimationCacheEnabled(boolean)
  ///@param drawingCacheToKeep one or a combination of \#PERSISTENT_NO_CACHE,
  ///        \#PERSISTENT_ANIMATION_CACHE, \#PERSISTENT_SCROLLING_CACHE
  ///        and \#PERSISTENT_ALL_CACHES
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void setPersistentDrawingCache(int drawingCacheToKeep) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPersistentDrawingCache,
          jni.JniType.voidType, [drawingCacheToKeep]).check();

  static final _id_getLayoutMode =
      jniAccessors.getMethodIDOf(_classRef, "getLayoutMode", "()I");

  /// from: public int getLayoutMode()
  ///
  /// Returns the basis of alignment during layout operations on this ViewGroup:
  /// either \#LAYOUT_MODE_CLIP_BOUNDS or \#LAYOUT_MODE_OPTICAL_BOUNDS.
  ///
  /// If no layoutMode was explicitly set, either programmatically or in an XML resource,
  /// the method returns the layoutMode of the view's parent ViewGroup if such a parent exists,
  /// otherwise the method returns a default value of \#LAYOUT_MODE_CLIP_BOUNDS.
  ///@return the layout mode to use during layout operations
  ///@see \#setLayoutMode(int)
  int getLayoutMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayoutMode, jni.JniType.intType, []).integer;

  static final _id_setLayoutMode =
      jniAccessors.getMethodIDOf(_classRef, "setLayoutMode", "(I)V");

  /// from: public void setLayoutMode(int layoutMode)
  ///
  /// Sets the basis of alignment during the layout of this ViewGroup.
  /// Valid values are either \#LAYOUT_MODE_CLIP_BOUNDS or
  /// \#LAYOUT_MODE_OPTICAL_BOUNDS.
  ///@param layoutMode the layout mode to use during layout operations
  ///@see \#getLayoutMode()
  ///@attr ref android.R.styleable\#ViewGroup_layoutMode
  void setLayoutMode(int layoutMode) => jniAccessors.callMethodWithArgs(
      reference, _id_setLayoutMode, jni.JniType.voidType, [layoutMode]).check();

  static final _id_generateLayoutParams = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/util/AttributeSet;)Landroid/view/ViewGroup\$LayoutParams;");

  /// from: public android.view.ViewGroup.LayoutParams generateLayoutParams(android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new set of layout parameters based on the supplied attributes set.
  ///@param attrs the attributes to build the layout parameters from
  ///@return an instance of android.view.ViewGroup.LayoutParams or one
  ///         of its descendants
  ViewGroup_LayoutParams generateLayoutParams(
          attributeset_.AttributeSet attrs) =>
      ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams,
          jni.JniType.objectType,
          [attrs.reference]).object);

  static final _id_generateLayoutParams1 = jniAccessors.getMethodIDOf(
      _classRef,
      "generateLayoutParams",
      "(Landroid/view/ViewGroup\$LayoutParams;)Landroid/view/ViewGroup\$LayoutParams;");

  /// from: protected android.view.ViewGroup.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams p)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a safe set of layout parameters based on the supplied layout params.
  /// When a ViewGroup is passed a View whose layout params do not pass the test of
  /// \#checkLayoutParams(android.view.ViewGroup.LayoutParams), this method
  /// is invoked. This method should return a new set of layout params suitable for
  /// this ViewGroup, possibly by copying the appropriate attributes from the
  /// specified set of layout params.
  ///@param p The layout parameters to convert into a suitable set of layout parameters
  ///          for this ViewGroup.
  ///@return an instance of android.view.ViewGroup.LayoutParams or one
  ///         of its descendants
  ViewGroup_LayoutParams generateLayoutParams1(ViewGroup_LayoutParams p) =>
      ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_generateLayoutParams1,
          jni.JniType.objectType,
          [p.reference]).object);

  static final _id_generateDefaultLayoutParams = jniAccessors.getMethodIDOf(
      _classRef,
      "generateDefaultLayoutParams",
      "()Landroid/view/ViewGroup\$LayoutParams;");

  /// from: protected android.view.ViewGroup.LayoutParams generateDefaultLayoutParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a set of default layout parameters. These parameters are requested
  /// when the View passed to \#addView(View) has no layout parameters
  /// already set. If null is returned, an exception is thrown from addView.
  ///@return a set of default layout parameters or null
  ViewGroup_LayoutParams generateDefaultLayoutParams() =>
      ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_generateDefaultLayoutParams, jni.JniType.objectType, []).object);

  static final _id_debug =
      jniAccessors.getMethodIDOf(_classRef, "debug", "(I)V");

  /// from: protected void debug(int depth)
  void debug(int depth) => jniAccessors.callMethodWithArgs(
      reference, _id_debug, jni.JniType.voidType, [depth]).check();

  static final _id_indexOfChild = jniAccessors.getMethodIDOf(
      _classRef, "indexOfChild", "(Landroid/view/View;)I");

  /// from: public int indexOfChild(android.view.View child)
  ///
  /// Returns the position in the group of the specified child view.
  ///@param child the view for which to get the position
  ///@return a positive integer representing the position of the view in the
  ///         group, or -1 if the view does not exist in the group
  int indexOfChild(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_indexOfChild,
      jni.JniType.intType,
      [child.reference]).integer;

  static final _id_getChildCount =
      jniAccessors.getMethodIDOf(_classRef, "getChildCount", "()I");

  /// from: public int getChildCount()
  ///
  /// Returns the number of children in the group.
  ///@return a positive integer representing the number of children in
  ///         the group
  int getChildCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getChildCount, jni.JniType.intType, []).integer;

  static final _id_getChildAt = jniAccessors.getMethodIDOf(
      _classRef, "getChildAt", "(I)Landroid/view/View;");

  /// from: public android.view.View getChildAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the view at the specified position in the group.
  ///@param index the position at which to get the view from
  ///@return the view at the specified position or null if the position
  ///         does not exist within the group
  view_.View getChildAt(int index) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChildAt, jni.JniType.objectType, [index]).object);

  static final _id_measureChildren =
      jniAccessors.getMethodIDOf(_classRef, "measureChildren", "(II)V");

  /// from: protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec)
  ///
  /// Ask all of the children of this view to measure themselves, taking into
  /// account both the MeasureSpec requirements for this view and its padding.
  /// We skip children that are in the GONE state The heavy lifting is done in
  /// getChildMeasureSpec.
  ///@param widthMeasureSpec The width requirements for this view
  ///@param heightMeasureSpec The height requirements for this view
  void measureChildren(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_measureChildren,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_measureChild = jniAccessors.getMethodIDOf(
      _classRef, "measureChild", "(Landroid/view/View;II)V");

  /// from: protected void measureChild(android.view.View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)
  ///
  /// Ask one of the children of this view to measure itself, taking into
  /// account both the MeasureSpec requirements for this view and its padding.
  /// The heavy lifting is done in getChildMeasureSpec.
  ///@param child The child to measure
  ///@param parentWidthMeasureSpec The width requirements for this view
  ///@param parentHeightMeasureSpec The height requirements for this view
  void measureChild(view_.View child, int parentWidthMeasureSpec,
          int parentHeightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_measureChild, jni.JniType.voidType, [
        child.reference,
        parentWidthMeasureSpec,
        parentHeightMeasureSpec
      ]).check();

  static final _id_measureChildWithMargins = jniAccessors.getMethodIDOf(
      _classRef, "measureChildWithMargins", "(Landroid/view/View;IIII)V");

  /// from: protected void measureChildWithMargins(android.view.View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)
  ///
  /// Ask one of the children of this view to measure itself, taking into
  /// account both the MeasureSpec requirements for this view and its padding
  /// and margins. The child must have MarginLayoutParams The heavy lifting is
  /// done in getChildMeasureSpec.
  ///@param child The child to measure
  ///@param parentWidthMeasureSpec The width requirements for this view
  ///@param widthUsed Extra space that has been used up by the parent
  ///        horizontally (possibly by other children of the parent)
  ///@param parentHeightMeasureSpec The height requirements for this view
  ///@param heightUsed Extra space that has been used up by the parent
  ///        vertically (possibly by other children of the parent)
  void measureChildWithMargins(view_.View child, int parentWidthMeasureSpec,
          int widthUsed, int parentHeightMeasureSpec, int heightUsed) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_measureChildWithMargins, jni.JniType.voidType, [
        child.reference,
        parentWidthMeasureSpec,
        widthUsed,
        parentHeightMeasureSpec,
        heightUsed
      ]).check();

  static final _id_getChildMeasureSpec = jniAccessors.getStaticMethodIDOf(
      _classRef, "getChildMeasureSpec", "(III)I");

  /// from: static public int getChildMeasureSpec(int spec, int padding, int childDimension)
  ///
  /// Does the hard part of measureChildren: figuring out the MeasureSpec to
  /// pass to a particular child. This method figures out the right MeasureSpec
  /// for one dimension (height or width) of one child view.
  ///
  /// The goal is to combine information from our MeasureSpec with the
  /// LayoutParams of the child to get the best possible results. For example,
  /// if the this view knows its size (because its MeasureSpec has a mode of
  /// EXACTLY), and the child has indicated in its LayoutParams that it wants
  /// to be the same size as the parent, the parent should ask the child to
  /// layout given an exact size.
  ///@param spec The requirements for this view
  ///@param padding The padding of this view for the current dimension and
  ///        margins, if applicable
  ///@param childDimension How big the child wants to be in the current
  ///        dimension
  ///@return a MeasureSpec integer for the child
  static int getChildMeasureSpec(int spec, int padding, int childDimension) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getChildMeasureSpec,
          jni.JniType.intType, [spec, padding, childDimension]).integer;

  static final _id_clearDisappearingChildren =
      jniAccessors.getMethodIDOf(_classRef, "clearDisappearingChildren", "()V");

  /// from: public void clearDisappearingChildren()
  ///
  /// Removes any pending animations for views that have been removed. Call
  /// this if you don't want animations for exiting views to stack up.
  void clearDisappearingChildren() => jniAccessors.callMethodWithArgs(reference,
      _id_clearDisappearingChildren, jni.JniType.voidType, []).check();

  static final _id_startViewTransition = jniAccessors.getMethodIDOf(
      _classRef, "startViewTransition", "(Landroid/view/View;)V");

  /// from: public void startViewTransition(android.view.View view)
  ///
  /// This method tells the ViewGroup that the given View object, which should have this
  /// ViewGroup as its parent,
  /// should be kept around  (re-displayed when the ViewGroup draws its children) even if it
  /// is removed from its parent. This allows animations, such as those used by
  /// android.app.Fragment and android.animation.LayoutTransition to animate
  /// the removal of views. A call to this method should always be accompanied by a later call
  /// to \#endViewTransition(View), such as after an animation on the View has finished,
  /// so that the View finally gets removed.
  ///@param view The View object to be kept visible even if it gets removed from its parent.
  void startViewTransition(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_startViewTransition,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_endViewTransition = jniAccessors.getMethodIDOf(
      _classRef, "endViewTransition", "(Landroid/view/View;)V");

  /// from: public void endViewTransition(android.view.View view)
  ///
  /// This method should always be called following an earlier call to
  /// \#startViewTransition(View). The given View is finally removed from its parent
  /// and will no longer be displayed. Note that this method does not perform the functionality
  /// of removing a view from its parent; it just discontinues the display of a View that
  /// has previously been removed.
  ///@return view The View object that has been removed but is being kept around in the visible
  /// hierarchy by an earlier call to \#startViewTransition(View).
  void endViewTransition(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_endViewTransition,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_gatherTransparentRegion = jniAccessors.getMethodIDOf(
      _classRef, "gatherTransparentRegion", "(Landroid/graphics/Region;)Z");

  /// from: public boolean gatherTransparentRegion(android.graphics.Region region)
  bool gatherTransparentRegion(region_.Region region) =>
      jniAccessors.callMethodWithArgs(reference, _id_gatherTransparentRegion,
          jni.JniType.booleanType, [region.reference]).boolean;

  static final _id_requestTransparentRegion = jniAccessors.getMethodIDOf(
      _classRef, "requestTransparentRegion", "(Landroid/view/View;)V");

  /// from: public void requestTransparentRegion(android.view.View child)
  void requestTransparentRegion(view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestTransparentRegion,
          jni.JniType.voidType, [child.reference]).check();

  static final _id_dispatchApplyWindowInsets = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchApplyWindowInsets",
      "(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets dispatchApplyWindowInsets(android.view.WindowInsets insets)
  /// The returned object must be deleted after use, by calling the `delete` method.
  windowinsets_.WindowInsets dispatchApplyWindowInsets(
          windowinsets_.WindowInsets insets) =>
      windowinsets_.WindowInsets.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchApplyWindowInsets,
          jni.JniType.objectType,
          [insets.reference]).object);

  static final _id_getLayoutAnimationListener = jniAccessors.getMethodIDOf(
      _classRef,
      "getLayoutAnimationListener",
      "()Landroid/view/animation/Animation\$AnimationListener;");

  /// from: public android.view.animation.Animation.AnimationListener getLayoutAnimationListener()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the animation listener to which layout animation events are
  /// sent.
  ///@return an android.view.animation.Animation.AnimationListener
  animation_.Animation_AnimationListener getLayoutAnimationListener() =>
      animation_.Animation_AnimationListener.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getLayoutAnimationListener,
              jni.JniType.objectType, []).object);

  static final _id_drawableStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableStateChanged", "()V");

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_drawableStateChanged, jni.JniType.voidType, []).check();

  static final _id_jumpDrawablesToCurrentState = jniAccessors.getMethodIDOf(
      _classRef, "jumpDrawablesToCurrentState", "()V");

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_jumpDrawablesToCurrentState,
      jni.JniType.voidType, []).check();

  static final _id_onCreateDrawableState =
      jniAccessors.getMethodIDOf(_classRef, "onCreateDrawableState", "(I)[I");

  /// from: protected int[] onCreateDrawableState(int extraSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onCreateDrawableState(int extraSpace) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateDrawableState,
          jni.JniType.objectType,
          [extraSpace]).object);

  static final _id_setAddStatesFromChildren =
      jniAccessors.getMethodIDOf(_classRef, "setAddStatesFromChildren", "(Z)V");

  /// from: public void setAddStatesFromChildren(boolean addsStates)
  ///
  /// Sets whether this ViewGroup's drawable states also include
  /// its children's drawable states.  This is used, for example, to
  /// make a group appear to be focused when its child EditText or button
  /// is focused.
  void setAddStatesFromChildren(bool addsStates) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAddStatesFromChildren,
          jni.JniType.voidType, [addsStates]).check();

  static final _id_addStatesFromChildren =
      jniAccessors.getMethodIDOf(_classRef, "addStatesFromChildren", "()Z");

  /// from: public boolean addStatesFromChildren()
  ///
  /// Returns whether this ViewGroup's drawable states also include
  /// its children's drawable states.  This is used, for example, to
  /// make a group appear to be focused when its child EditText or button
  /// is focused.
  bool addStatesFromChildren() => jniAccessors.callMethodWithArgs(reference,
      _id_addStatesFromChildren, jni.JniType.booleanType, []).boolean;

  static final _id_childDrawableStateChanged = jniAccessors.getMethodIDOf(
      _classRef, "childDrawableStateChanged", "(Landroid/view/View;)V");

  /// from: public void childDrawableStateChanged(android.view.View child)
  ///
  /// If \#addStatesFromChildren is true, refreshes this group's
  /// drawable state (to include the states from its children).
  void childDrawableStateChanged(view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_childDrawableStateChanged,
          jni.JniType.voidType, [child.reference]).check();

  static final _id_setLayoutAnimationListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setLayoutAnimationListener",
      "(Landroid/view/animation/Animation\$AnimationListener;)V");

  /// from: public void setLayoutAnimationListener(android.view.animation.Animation.AnimationListener animationListener)
  ///
  /// Specifies the animation listener to which layout animation events must
  /// be sent. Only
  /// android.view.animation.Animation.AnimationListener\#onAnimationStart(Animation)
  /// and
  /// android.view.animation.Animation.AnimationListener\#onAnimationEnd(Animation)
  /// are invoked.
  ///@param animationListener the layout animation listener
  void setLayoutAnimationListener(
          animation_.Animation_AnimationListener animationListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutAnimationListener,
          jni.JniType.voidType, [animationListener.reference]).check();

  static final _id_shouldDelayChildPressedState = jniAccessors.getMethodIDOf(
      _classRef, "shouldDelayChildPressedState", "()Z");

  /// from: public boolean shouldDelayChildPressedState()
  ///
  /// Return true if the pressed state should be delayed for children or descendants of this
  /// ViewGroup. Generally, this should be done for containers that can scroll, such as a List.
  /// This prevents the pressed state from appearing when the user is actually trying to scroll
  /// the content.
  ///
  /// The default implementation returns true for compatibility reasons. Subclasses that do
  /// not scroll should generally override this method and return false.
  bool shouldDelayChildPressedState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_shouldDelayChildPressedState,
      jni.JniType.booleanType, []).boolean;

  static final _id_onStartNestedScroll = jniAccessors.getMethodIDOf(_classRef,
      "onStartNestedScroll", "(Landroid/view/View;Landroid/view/View;I)Z");

  /// from: public boolean onStartNestedScroll(android.view.View child, android.view.View target, int nestedScrollAxes)
  ///
  /// @inheritDoc
  bool onStartNestedScroll(
          view_.View child, view_.View target, int nestedScrollAxes) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onStartNestedScroll,
          jni.JniType.booleanType,
          [child.reference, target.reference, nestedScrollAxes]).boolean;

  static final _id_onNestedScrollAccepted = jniAccessors.getMethodIDOf(
      _classRef,
      "onNestedScrollAccepted",
      "(Landroid/view/View;Landroid/view/View;I)V");

  /// from: public void onNestedScrollAccepted(android.view.View child, android.view.View target, int axes)
  ///
  /// @inheritDoc
  void onNestedScrollAccepted(view_.View child, view_.View target, int axes) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedScrollAccepted,
          jni.JniType.voidType,
          [child.reference, target.reference, axes]).check();

  static final _id_onStopNestedScroll = jniAccessors.getMethodIDOf(
      _classRef, "onStopNestedScroll", "(Landroid/view/View;)V");

  /// from: public void onStopNestedScroll(android.view.View child)
  ///
  /// @inheritDoc
  void onStopNestedScroll(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStopNestedScroll,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_onNestedScroll = jniAccessors.getMethodIDOf(
      _classRef, "onNestedScroll", "(Landroid/view/View;IIII)V");

  /// from: public void onNestedScroll(android.view.View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)
  ///
  /// @inheritDoc
  void onNestedScroll(view_.View target, int dxConsumed, int dyConsumed,
          int dxUnconsumed, int dyUnconsumed) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onNestedScroll, jni.JniType.voidType, [
        target.reference,
        dxConsumed,
        dyConsumed,
        dxUnconsumed,
        dyUnconsumed
      ]).check();

  static final _id_onNestedPreScroll = jniAccessors.getMethodIDOf(
      _classRef, "onNestedPreScroll", "(Landroid/view/View;II[I)V");

  /// from: public void onNestedPreScroll(android.view.View target, int dx, int dy, int[] consumed)
  ///
  /// @inheritDoc
  void onNestedPreScroll(
          view_.View target, int dx, int dy, jni.JniObject consumed) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedPreScroll,
          jni.JniType.voidType,
          [target.reference, dx, dy, consumed.reference]).check();

  static final _id_onNestedFling = jniAccessors.getMethodIDOf(
      _classRef, "onNestedFling", "(Landroid/view/View;FFZ)Z");

  /// from: public boolean onNestedFling(android.view.View target, float velocityX, float velocityY, boolean consumed)
  ///
  /// @inheritDoc
  bool onNestedFling(view_.View target, double velocityX, double velocityY,
          bool consumed) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedFling,
          jni.JniType.booleanType,
          [target.reference, velocityX, velocityY, consumed]).boolean;

  static final _id_onNestedPreFling = jniAccessors.getMethodIDOf(
      _classRef, "onNestedPreFling", "(Landroid/view/View;FF)Z");

  /// from: public boolean onNestedPreFling(android.view.View target, float velocityX, float velocityY)
  ///
  /// @inheritDoc
  bool onNestedPreFling(
          view_.View target, double velocityX, double velocityY) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedPreFling,
          jni.JniType.booleanType,
          [target.reference, velocityX, velocityY]).boolean;

  static final _id_getNestedScrollAxes =
      jniAccessors.getMethodIDOf(_classRef, "getNestedScrollAxes", "()I");

  /// from: public int getNestedScrollAxes()
  ///
  /// Return the current axes of nested scrolling for this ViewGroup.
  ///
  /// A ViewGroup returning something other than \#SCROLL_AXIS_NONE is currently
  /// acting as a nested scrolling parent for one or more descendant views in the hierarchy.
  ///
  ///@return Flags indicating the current axes of nested scrolling
  ///@see \#SCROLL_AXIS_HORIZONTAL
  ///@see \#SCROLL_AXIS_VERTICAL
  ///@see \#SCROLL_AXIS_NONE
  int getNestedScrollAxes() => jniAccessors.callMethodWithArgs(
      reference, _id_getNestedScrollAxes, jni.JniType.intType, []).integer;
}

/// from: android.view.ViewGroup$OnHierarchyChangeListener
///
/// Interface definition for a callback to be invoked when the hierarchy
/// within this view changed. The hierarchy changes whenever a child is added
/// to or removed from this view.
class ViewGroup_OnHierarchyChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/ViewGroup\$OnHierarchyChangeListener");
  ViewGroup_OnHierarchyChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onChildViewAdded = jniAccessors.getMethodIDOf(_classRef,
      "onChildViewAdded", "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public abstract void onChildViewAdded(android.view.View parent, android.view.View child)
  ///
  /// Called when a new child is added to a parent view.
  ///@param parent the view in which a child was added
  ///@param child the new child view added in the hierarchy
  void onChildViewAdded(view_.View parent, view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_onChildViewAdded,
          jni.JniType.voidType, [parent.reference, child.reference]).check();

  static final _id_onChildViewRemoved = jniAccessors.getMethodIDOf(_classRef,
      "onChildViewRemoved", "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public abstract void onChildViewRemoved(android.view.View parent, android.view.View child)
  ///
  /// Called when a child is removed from a parent view.
  ///@param parent the view from which the child was removed
  ///@param child the child removed from the hierarchy
  void onChildViewRemoved(view_.View parent, view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_onChildViewRemoved,
          jni.JniType.voidType, [parent.reference, child.reference]).check();
}

/// from: android.view.ViewGroup$MarginLayoutParams
///
/// Per-child layout information for layouts that support margins.
/// See
/// android.R.styleable\#ViewGroup_MarginLayout ViewGroup Margin Layout Attributes
/// for a list of all child view attributes that this class supports.
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_margin
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginHorizontal
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginVertical
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginLeft
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginTop
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginRight
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginBottom
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginStart
///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginEnd
class ViewGroup_MarginLayoutParams extends ViewGroup_LayoutParams {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ViewGroup\$MarginLayoutParams");
  ViewGroup_MarginLayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_bottomMargin =
      jniAccessors.getFieldIDOf(_classRef, "bottomMargin", "I");

  /// from: public int bottomMargin
  ///
  /// The bottom margin in pixels of the child. Margin values should be positive.
  /// Call ViewGroup\#setLayoutParams(LayoutParams) after reassigning a new value
  /// to this field.
  int get bottomMargin => jniAccessors
      .getField(reference, _id_bottomMargin, jni.JniType.intType)
      .integer;

  /// from: public int bottomMargin
  ///
  /// The bottom margin in pixels of the child. Margin values should be positive.
  /// Call ViewGroup\#setLayoutParams(LayoutParams) after reassigning a new value
  /// to this field.
  set bottomMargin(int value) =>
      jniEnv.SetIntField(reference, _id_bottomMargin, value);

  static final _id_leftMargin =
      jniAccessors.getFieldIDOf(_classRef, "leftMargin", "I");

  /// from: public int leftMargin
  ///
  /// The left margin in pixels of the child. Margin values should be positive.
  /// Call ViewGroup\#setLayoutParams(LayoutParams) after reassigning a new value
  /// to this field.
  int get leftMargin => jniAccessors
      .getField(reference, _id_leftMargin, jni.JniType.intType)
      .integer;

  /// from: public int leftMargin
  ///
  /// The left margin in pixels of the child. Margin values should be positive.
  /// Call ViewGroup\#setLayoutParams(LayoutParams) after reassigning a new value
  /// to this field.
  set leftMargin(int value) =>
      jniEnv.SetIntField(reference, _id_leftMargin, value);

  static final _id_rightMargin =
      jniAccessors.getFieldIDOf(_classRef, "rightMargin", "I");

  /// from: public int rightMargin
  ///
  /// The right margin in pixels of the child. Margin values should be positive.
  /// Call ViewGroup\#setLayoutParams(LayoutParams) after reassigning a new value
  /// to this field.
  int get rightMargin => jniAccessors
      .getField(reference, _id_rightMargin, jni.JniType.intType)
      .integer;

  /// from: public int rightMargin
  ///
  /// The right margin in pixels of the child. Margin values should be positive.
  /// Call ViewGroup\#setLayoutParams(LayoutParams) after reassigning a new value
  /// to this field.
  set rightMargin(int value) =>
      jniEnv.SetIntField(reference, _id_rightMargin, value);

  static final _id_topMargin =
      jniAccessors.getFieldIDOf(_classRef, "topMargin", "I");

  /// from: public int topMargin
  ///
  /// The top margin in pixels of the child. Margin values should be positive.
  /// Call ViewGroup\#setLayoutParams(LayoutParams) after reassigning a new value
  /// to this field.
  int get topMargin => jniAccessors
      .getField(reference, _id_topMargin, jni.JniType.intType)
      .integer;

  /// from: public int topMargin
  ///
  /// The top margin in pixels of the child. Margin values should be positive.
  /// Call ViewGroup\#setLayoutParams(LayoutParams) after reassigning a new value
  /// to this field.
  set topMargin(int value) =>
      jniEnv.SetIntField(reference, _id_topMargin, value);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new set of layout parameters. The values are extracted from
  /// the supplied attributes set and context.
  ///@param c the application environment
  ///@param attrs the set of attributes from which to extract the layout
  ///              parameters' values
  ViewGroup_MarginLayoutParams(
      context_.Context c, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [c.reference, attrs.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewGroup_MarginLayoutParams.ctor1(int width, int height)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [width, height]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$MarginLayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.MarginLayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy constructor. Clones the width, height and margin values of the source.
  ///@param source The layout params to copy from.
  ViewGroup_MarginLayoutParams.ctor3(ViewGroup_MarginLayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [source.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewGroup_MarginLayoutParams.ctor2(ViewGroup_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [source.reference]).object);

  static final _id_setMargins =
      jniAccessors.getMethodIDOf(_classRef, "setMargins", "(IIII)V");

  /// from: public void setMargins(int left, int top, int right, int bottom)
  ///
  /// Sets the margins, in pixels. A call to android.view.View\#requestLayout() needs
  /// to be done so that the new margins are taken into account. Left and right margins may be
  /// overriden by android.view.View\#requestLayout() depending on layout direction.
  /// Margin values should be positive.
  ///@param left the left margin size
  ///@param top the top margin size
  ///@param right the right margin size
  ///@param bottom the bottom margin size
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginLeft
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginTop
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginRight
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginBottom
  void setMargins(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMargins,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_setMarginStart =
      jniAccessors.getMethodIDOf(_classRef, "setMarginStart", "(I)V");

  /// from: public void setMarginStart(int start)
  ///
  /// Sets the relative start margin. Margin values should be positive.
  ///@param start the start margin size
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginStart
  void setMarginStart(int start) => jniAccessors.callMethodWithArgs(
      reference, _id_setMarginStart, jni.JniType.voidType, [start]).check();

  static final _id_getMarginStart =
      jniAccessors.getMethodIDOf(_classRef, "getMarginStart", "()I");

  /// from: public int getMarginStart()
  ///
  /// Returns the start margin in pixels.
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginStart
  ///@return the start margin in pixels.
  int getMarginStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getMarginStart, jni.JniType.intType, []).integer;

  static final _id_setMarginEnd =
      jniAccessors.getMethodIDOf(_classRef, "setMarginEnd", "(I)V");

  /// from: public void setMarginEnd(int end)
  ///
  /// Sets the relative end margin. Margin values should be positive.
  ///@param end the end margin size
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginEnd
  void setMarginEnd(int end) => jniAccessors.callMethodWithArgs(
      reference, _id_setMarginEnd, jni.JniType.voidType, [end]).check();

  static final _id_getMarginEnd =
      jniAccessors.getMethodIDOf(_classRef, "getMarginEnd", "()I");

  /// from: public int getMarginEnd()
  ///
  /// Returns the end margin in pixels.
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginEnd
  ///@return the end margin in pixels.
  int getMarginEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getMarginEnd, jni.JniType.intType, []).integer;

  static final _id_isMarginRelative =
      jniAccessors.getMethodIDOf(_classRef, "isMarginRelative", "()Z");

  /// from: public boolean isMarginRelative()
  ///
  /// Check if margins are relative.
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginStart
  ///@attr ref android.R.styleable\#ViewGroup_MarginLayout_layout_marginEnd
  ///@return true if either marginStart or marginEnd has been set.
  bool isMarginRelative() => jniAccessors.callMethodWithArgs(
      reference, _id_isMarginRelative, jni.JniType.booleanType, []).boolean;

  static final _id_setLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "setLayoutDirection", "(I)V");

  /// from: public void setLayoutDirection(int layoutDirection)
  ///
  /// Set the layout direction
  ///@param layoutDirection the layout direction.
  ///        Should be either View\#LAYOUT_DIRECTION_LTR
  ///                     or View\#LAYOUT_DIRECTION_RTL.
  void setLayoutDirection(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutDirection,
          jni.JniType.voidType, [layoutDirection]).check();

  static final _id_getLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "getLayoutDirection", "()I");

  /// from: public int getLayoutDirection()
  ///
  /// Retuns the layout direction. Can be either View\#LAYOUT_DIRECTION_LTR or
  /// View\#LAYOUT_DIRECTION_RTL.
  ///@return the layout direction.
  int getLayoutDirection() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayoutDirection, jni.JniType.intType, []).integer;

  static final _id_resolveLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "resolveLayoutDirection", "(I)V");

  /// from: public void resolveLayoutDirection(int layoutDirection)
  ///
  /// This will be called by android.view.View\#requestLayout(). Left and Right margins
  /// may be overridden depending on layout direction.
  void resolveLayoutDirection(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_resolveLayoutDirection,
          jni.JniType.voidType, [layoutDirection]).check();
}

/// from: android.view.ViewGroup$LayoutParams
///
/// LayoutParams are used by views to tell their parents how they want to be
/// laid out. See
/// android.R.styleable\#ViewGroup_Layout ViewGroup Layout Attributes
/// for a list of all child view attributes that this class supports.
///
///
/// The base LayoutParams class just describes how big the view wants to be
/// for both width and height. For each dimension, it can specify one of:
/// <ul>
/// <li>FILL_PARENT (renamed MATCH_PARENT in API Level 8 and higher), which
/// means that the view wants to be as big as its parent (minus padding)
/// <li> WRAP_CONTENT, which means that the view wants to be just big enough
/// to enclose its content (plus padding)
/// <li> an exact number
/// </ul>
/// There are subclasses of LayoutParams for different subclasses of
/// ViewGroup. For example, AbsoluteLayout has its own subclass of
/// LayoutParams which adds an X and Y value.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating user interface layouts, read the
/// <a href="{@docRoot}guide/topics/ui/declaring-layout.html">XML Layouts</a> developer
/// guide.
///</div>
///@attr ref android.R.styleable\#ViewGroup_Layout_layout_height
///@attr ref android.R.styleable\#ViewGroup_Layout_layout_width
class ViewGroup_LayoutParams extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ViewGroup\$LayoutParams");
  ViewGroup_LayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int FILL_PARENT
  ///
  /// Special value for the height or width requested by a View.
  /// FILL_PARENT means that the view wants to be as big as its parent,
  /// minus the parent's padding, if any. This value is deprecated
  /// starting in API Level 8 and replaced by \#MATCH_PARENT.
  static const FILL_PARENT = -1;

  /// from: static public final int MATCH_PARENT
  ///
  /// Special value for the height or width requested by a View.
  /// MATCH_PARENT means that the view wants to be as big as its parent,
  /// minus the parent's padding, if any. Introduced in API Level 8.
  static const MATCH_PARENT = -1;

  /// from: static public final int WRAP_CONTENT
  ///
  /// Special value for the height or width requested by a View.
  /// WRAP_CONTENT means that the view wants to be just large enough to fit
  /// its own internal content, taking its own padding into account.
  static const WRAP_CONTENT = -2;

  static final _id_height = jniAccessors.getFieldIDOf(_classRef, "height", "I");

  /// from: public int height
  ///
  /// Information about how tall the view wants to be. Can be one of the
  /// constants FILL_PARENT (replaced by MATCH_PARENT
  /// in API Level 8) or WRAP_CONTENT, or an exact size.
  int get height =>
      jniAccessors.getField(reference, _id_height, jni.JniType.intType).integer;

  /// from: public int height
  ///
  /// Information about how tall the view wants to be. Can be one of the
  /// constants FILL_PARENT (replaced by MATCH_PARENT
  /// in API Level 8) or WRAP_CONTENT, or an exact size.
  set height(int value) => jniEnv.SetIntField(reference, _id_height, value);

  static final _id_layoutAnimationParameters = jniAccessors.getFieldIDOf(
      _classRef,
      "layoutAnimationParameters",
      "Landroid/view/animation/LayoutAnimationController\$AnimationParameters;");

  /// from: public android.view.animation.LayoutAnimationController.AnimationParameters layoutAnimationParameters
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to animate layouts.
  layoutanimationcontroller_.LayoutAnimationController_AnimationParameters
      get layoutAnimationParameters => layoutanimationcontroller_
              .LayoutAnimationController_AnimationParameters
          .fromRef(jniAccessors
              .getField(reference, _id_layoutAnimationParameters,
                  jni.JniType.objectType)
              .object);

  /// from: public android.view.animation.LayoutAnimationController.AnimationParameters layoutAnimationParameters
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to animate layouts.
  set layoutAnimationParameters(
          layoutanimationcontroller_
                  .LayoutAnimationController_AnimationParameters
              value) =>
      jniEnv.SetObjectField(
          reference, _id_layoutAnimationParameters, value.reference);

  static final _id_width = jniAccessors.getFieldIDOf(_classRef, "width", "I");

  /// from: public int width
  ///
  /// Information about how wide the view wants to be. Can be one of the
  /// constants FILL_PARENT (replaced by MATCH_PARENT
  /// in API Level 8) or WRAP_CONTENT, or an exact size.
  int get width =>
      jniAccessors.getField(reference, _id_width, jni.JniType.intType).integer;

  /// from: public int width
  ///
  /// Information about how wide the view wants to be. Can be one of the
  /// constants FILL_PARENT (replaced by MATCH_PARENT
  /// in API Level 8) or WRAP_CONTENT, or an exact size.
  set width(int value) => jniEnv.SetIntField(reference, _id_width, value);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new set of layout parameters. The values are extracted from
  /// the supplied attributes set and context. The XML attributes mapped
  /// to this set of layout parameters are:
  ///
  /// <ul>
  ///   <li><code>layout_width</code>: the width, either an exact value,
  ///   \#WRAP_CONTENT, or \#FILL_PARENT (replaced by
  ///   \#MATCH_PARENT in API Level 8)</li>
  ///   <li><code>layout_height</code>: the height, either an exact value,
  ///   \#WRAP_CONTENT, or \#FILL_PARENT (replaced by
  ///   \#MATCH_PARENT in API Level 8)</li>
  /// </ul>
  ///@param c the application environment
  ///@param attrs the set of attributes from which to extract the layout
  ///              parameters' values
  ViewGroup_LayoutParams(context_.Context c, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [c.reference, attrs.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new set of layout parameters with the specified width
  /// and height.
  ///@param width the width, either \#WRAP_CONTENT,
  ///        \#FILL_PARENT (replaced by \#MATCH_PARENT in
  ///        API Level 8), or a fixed size in pixels
  ///@param height the height, either \#WRAP_CONTENT,
  ///        \#FILL_PARENT (replaced by \#MATCH_PARENT in
  ///        API Level 8), or a fixed size in pixels
  ViewGroup_LayoutParams.ctor1(int width, int height)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [width, height]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy constructor. Clones the width and height values of the source.
  ///@param source The layout params to copy from.
  ViewGroup_LayoutParams.ctor2(ViewGroup_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [source.reference]).object);

  static final _id_setBaseAttributes = jniAccessors.getMethodIDOf(
      _classRef, "setBaseAttributes", "(Landroid/content/res/TypedArray;II)V");

  /// from: protected void setBaseAttributes(android.content.res.TypedArray a, int widthAttr, int heightAttr)
  ///
  /// Extracts the layout parameters from the supplied attributes.
  ///@param a the style attributes to extract the parameters from
  ///@param widthAttr the identifier of the width attribute
  ///@param heightAttr the identifier of the height attribute
  void setBaseAttributes(
          typedarray_.TypedArray a, int widthAttr, int heightAttr) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBaseAttributes,
          jni.JniType.voidType, [a.reference, widthAttr, heightAttr]).check();

  static final _id_resolveLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "resolveLayoutDirection", "(I)V");

  /// from: public void resolveLayoutDirection(int layoutDirection)
  ///
  /// Resolve layout parameters depending on the layout direction. Subclasses that care about
  /// layoutDirection changes should override this method. The default implementation does
  /// nothing.
  ///@param layoutDirection the direction of the layout
  ///
  /// View\#LAYOUT_DIRECTION_LTR
  /// View\#LAYOUT_DIRECTION_RTL
  void resolveLayoutDirection(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_resolveLayoutDirection,
          jni.JniType.voidType, [layoutDirection]).check();
}
