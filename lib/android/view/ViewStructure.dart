// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../graphics/Matrix.dart" as matrix_;

import "../os/Bundle.dart" as bundle_;

import "autofill/AutofillId.dart" as autofillid_;

import "autofill/AutofillValue.dart" as autofillvalue_;

import "../os/LocaleList.dart" as localelist_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.ViewStructure
///
/// Container for storing additional per-view data generated by View\#onProvideStructure View.onProvideStructure and View\#onProvideAutofillStructure View.onProvideAutofillStructure.
class ViewStructure extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ViewStructure");
  ViewStructure.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewStructure()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setId = jniAccessors.getMethodIDOf(_classRef, "setId",
      "(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public abstract void setId(int id, java.lang.String packageName, java.lang.String typeName, java.lang.String entryName)
  ///
  /// Set the identifier for this view.
  ///@param id The view's identifier, as per View\#getId View.getId().
  ///@param packageName The package name of the view's identifier, or null if there is none.
  ///@param typeName The type name of the view's identifier, or null if there is none.
  ///@param entryName The entry name of the view's identifier, or null if there is none.
  void setId(int id, jni.JniString packageName, jni.JniString typeName,
          jni.JniString entryName) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setId, jni.JniType.voidType, [
        id,
        packageName.reference,
        typeName.reference,
        entryName.reference
      ]).check();

  static final _id_setDimens =
      jniAccessors.getMethodIDOf(_classRef, "setDimens", "(IIIIII)V");

  /// from: public abstract void setDimens(int left, int top, int scrollX, int scrollY, int width, int height)
  ///
  /// Set the basic dimensions of this view.
  ///@param left The view's left position, in pixels relative to its parent's left edge.
  ///@param top The view's top position, in pixels relative to its parent's top edge.
  ///@param scrollX How much the view's x coordinate space has been scrolled, in pixels.
  ///@param scrollY How much the view's y coordinate space has been scrolled, in pixels.
  ///@param width The view's visible width, in pixels.  This is the width visible on screen,
  /// not the total data width of a scrollable view.
  ///@param height The view's visible height, in pixels.  This is the height visible on
  /// screen, not the total data height of a scrollable view.
  void setDimens(
          int left, int top, int scrollX, int scrollY, int width, int height) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDimens,
          jni.JniType.voidType,
          [left, top, scrollX, scrollY, width, height]).check();

  static final _id_setTransformation = jniAccessors.getMethodIDOf(
      _classRef, "setTransformation", "(Landroid/graphics/Matrix;)V");

  /// from: public abstract void setTransformation(android.graphics.Matrix matrix)
  ///
  /// Set the transformation matrix associated with this view, as per
  /// View\#getMatrix View.getMatrix(), or null if there is none.
  void setTransformation(matrix_.Matrix matrix) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTransformation,
          jni.JniType.voidType, [matrix.reference]).check();

  static final _id_setElevation =
      jniAccessors.getMethodIDOf(_classRef, "setElevation", "(F)V");

  /// from: public abstract void setElevation(float elevation)
  ///
  /// Set the visual elevation (shadow) of the view, as per
  /// View\#getZ View.getZ().  Note this is _not_ related
  /// to the physical Z-ordering of this view relative to its other siblings (that is how
  /// they overlap when drawing), it is only the visual representation for shadowing.
  void setElevation(double elevation) => jniAccessors.callMethodWithArgs(
      reference, _id_setElevation, jni.JniType.voidType, [elevation]).check();

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(F)V");

  /// from: public abstract void setAlpha(float alpha)
  ///
  /// Set an alpha transformation that is applied to this view, as per
  /// View\#getAlpha View.getAlpha().  Value ranges from 0
  /// (completely transparent) to 1 (completely opaque); the default is 1, which means
  /// no transformation.
  void setAlpha(double alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_setVisibility =
      jniAccessors.getMethodIDOf(_classRef, "setVisibility", "(I)V");

  /// from: public abstract void setVisibility(int visibility)
  ///
  /// Set the visibility state of this view, as per
  /// View\#getVisibility View.getVisibility().
  void setVisibility(int visibility) => jniAccessors.callMethodWithArgs(
      reference, _id_setVisibility, jni.JniType.voidType, [visibility]).check();

  static final _id_setEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)V");

  /// from: public abstract void setEnabled(boolean state)
  ///
  /// Set the enabled state of this view, as per View\#isEnabled View.isEnabled().
  void setEnabled(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled, jni.JniType.voidType, [state]).check();

  static final _id_setClickable =
      jniAccessors.getMethodIDOf(_classRef, "setClickable", "(Z)V");

  /// from: public abstract void setClickable(boolean state)
  ///
  /// Set the clickable state of this view, as per View\#isClickable View.isClickable().
  void setClickable(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setClickable, jni.JniType.voidType, [state]).check();

  static final _id_setLongClickable =
      jniAccessors.getMethodIDOf(_classRef, "setLongClickable", "(Z)V");

  /// from: public abstract void setLongClickable(boolean state)
  ///
  /// Set the long clickable state of this view, as per
  /// View\#isLongClickable View.isLongClickable().
  void setLongClickable(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setLongClickable, jni.JniType.voidType, [state]).check();

  static final _id_setContextClickable =
      jniAccessors.getMethodIDOf(_classRef, "setContextClickable", "(Z)V");

  /// from: public abstract void setContextClickable(boolean state)
  ///
  /// Set the context clickable state of this view, as per
  /// View\#isContextClickable View.isContextClickable().
  void setContextClickable(bool state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContextClickable,
      jni.JniType.voidType,
      [state]).check();

  static final _id_setFocusable =
      jniAccessors.getMethodIDOf(_classRef, "setFocusable", "(Z)V");

  /// from: public abstract void setFocusable(boolean state)
  ///
  /// Set the focusable state of this view, as per View\#isFocusable View.isFocusable().
  void setFocusable(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setFocusable, jni.JniType.voidType, [state]).check();

  static final _id_setFocused =
      jniAccessors.getMethodIDOf(_classRef, "setFocused", "(Z)V");

  /// from: public abstract void setFocused(boolean state)
  ///
  /// Set the focused state of this view, as per View\#isFocused View.isFocused().
  void setFocused(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setFocused, jni.JniType.voidType, [state]).check();

  static final _id_setAccessibilityFocused =
      jniAccessors.getMethodIDOf(_classRef, "setAccessibilityFocused", "(Z)V");

  /// from: public abstract void setAccessibilityFocused(boolean state)
  ///
  /// Set the accessibility focused state of this view, as per
  /// View\#isAccessibilityFocused View.isAccessibilityFocused().
  void setAccessibilityFocused(bool state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAccessibilityFocused,
      jni.JniType.voidType,
      [state]).check();

  static final _id_setCheckable =
      jniAccessors.getMethodIDOf(_classRef, "setCheckable", "(Z)V");

  /// from: public abstract void setCheckable(boolean state)
  ///
  /// Set the checkable state of this view, such as whether it implements the
  /// android.widget.Checkable interface.
  void setCheckable(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setCheckable, jni.JniType.voidType, [state]).check();

  static final _id_setChecked =
      jniAccessors.getMethodIDOf(_classRef, "setChecked", "(Z)V");

  /// from: public abstract void setChecked(boolean state)
  ///
  /// Set the checked state of this view, such as
  /// android.widget.Checkable\#isChecked Checkable.isChecked().
  void setChecked(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setChecked, jni.JniType.voidType, [state]).check();

  static final _id_setSelected =
      jniAccessors.getMethodIDOf(_classRef, "setSelected", "(Z)V");

  /// from: public abstract void setSelected(boolean state)
  ///
  /// Set the selected state of this view, as per View\#isSelected View.isSelected().
  void setSelected(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelected, jni.JniType.voidType, [state]).check();

  static final _id_setActivated =
      jniAccessors.getMethodIDOf(_classRef, "setActivated", "(Z)V");

  /// from: public abstract void setActivated(boolean state)
  ///
  /// Set the activated state of this view, as per View\#isActivated View.isActivated().
  void setActivated(bool state) => jniAccessors.callMethodWithArgs(
      reference, _id_setActivated, jni.JniType.voidType, [state]).check();

  static final _id_setOpaque =
      jniAccessors.getMethodIDOf(_classRef, "setOpaque", "(Z)V");

  /// from: public abstract void setOpaque(boolean opaque)
  ///
  /// Set the opaque state of this view, as per View\#isOpaque View.isOpaque().
  void setOpaque(bool opaque) => jniAccessors.callMethodWithArgs(
      reference, _id_setOpaque, jni.JniType.voidType, [opaque]).check();

  static final _id_setClassName = jniAccessors.getMethodIDOf(
      _classRef, "setClassName", "(Ljava/lang/String;)V");

  /// from: public abstract void setClassName(java.lang.String className)
  ///
  /// Set the class name of the view, as per
  /// View\#getAccessibilityClassName View.getAccessibilityClassName().
  void setClassName(jni.JniString className) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClassName,
      jni.JniType.voidType,
      [className.reference]).check();

  static final _id_setContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "setContentDescription", "(Ljava/lang/CharSequence;)V");

  /// from: public abstract void setContentDescription(java.lang.CharSequence contentDescription)
  ///
  /// Set the content description of the view, as per
  /// View\#getContentDescription View.getContentDescription().
  void setContentDescription(jni.JniObject contentDescription) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentDescription,
          jni.JniType.voidType, [contentDescription.reference]).check();

  static final _id_setText = jniAccessors.getMethodIDOf(
      _classRef, "setText", "(Ljava/lang/CharSequence;)V");

  /// from: public abstract void setText(java.lang.CharSequence text)
  ///
  /// Set the text that is associated with this view.  There is no selection
  /// associated with the text.  The text may have style spans to supply additional
  /// display and semantic information.
  void setText(jni.JniObject text) => jniAccessors.callMethodWithArgs(
      reference, _id_setText, jni.JniType.voidType, [text.reference]).check();

  static final _id_setText1 = jniAccessors.getMethodIDOf(
      _classRef, "setText", "(Ljava/lang/CharSequence;II)V");

  /// from: public abstract void setText(java.lang.CharSequence text, int selectionStart, int selectionEnd)
  ///
  /// Like \#setText(CharSequence) but with an active selection
  /// extending from <var>selectionStart</var> through <var>selectionEnd</var>.
  void setText1(jni.JniObject text, int selectionStart, int selectionEnd) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setText1,
          jni.JniType.voidType,
          [text.reference, selectionStart, selectionEnd]).check();

  static final _id_setTextStyle =
      jniAccessors.getMethodIDOf(_classRef, "setTextStyle", "(FIII)V");

  /// from: public abstract void setTextStyle(float size, int fgColor, int bgColor, int style)
  ///
  /// Explicitly set default global style information for text that was previously set with
  /// \#setText.
  ///@param size The size, in pixels, of the text.
  ///@param fgColor The foreground color, packed as 0xAARRGGBB.
  ///@param bgColor The background color, packed as 0xAARRGGBB.
  ///@param style Style flags, as defined by android.app.assist.AssistStructure.ViewNode.
  void setTextStyle(double size, int fgColor, int bgColor, int style) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextStyle,
          jni.JniType.voidType, [size, fgColor, bgColor, style]).check();

  static final _id_setTextLines =
      jniAccessors.getMethodIDOf(_classRef, "setTextLines", "([I[I)V");

  /// from: public abstract void setTextLines(int[] charOffsets, int[] baselines)
  ///
  /// Set line information for test that was previously supplied through
  /// \#setText(CharSequence).  This provides the line breaking of the text as it
  /// is shown on screen.  This function takes ownership of the provided arrays; you should
  /// not make further modification to them.
  ///@param charOffsets The offset in to \#setText where a line starts.
  ///@param baselines The baseline where the line is drawn on screen.
  void setTextLines(jni.JniObject charOffsets, jni.JniObject baselines) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTextLines,
          jni.JniType.voidType,
          [charOffsets.reference, baselines.reference]).check();

  static final _id_setTextIdEntry = jniAccessors.getMethodIDOf(
      _classRef, "setTextIdEntry", "(Ljava/lang/String;)V");

  /// from: public void setTextIdEntry(java.lang.String entryName)
  ///
  /// Sets the identifier used to set the text associated with this view.
  ///
  /// Should only be set when the node is used for autofill purposes - it will be ignored
  /// when used for Assist.
  ///@param entryName This value must never be {@code null}.
  void setTextIdEntry(jni.JniString entryName) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextIdEntry,
          jni.JniType.voidType, [entryName.reference]).check();

  static final _id_setHint = jniAccessors.getMethodIDOf(
      _classRef, "setHint", "(Ljava/lang/CharSequence;)V");

  /// from: public abstract void setHint(java.lang.CharSequence hint)
  ///
  /// Set optional hint text associated with this view; this is for example the text that is
  /// shown by an EditText when it is empty to indicate to the user the kind of text to input.
  void setHint(jni.JniObject hint) => jniAccessors.callMethodWithArgs(
      reference, _id_setHint, jni.JniType.voidType, [hint.reference]).check();

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the last \#setText(CharSequence).
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_getTextSelectionStart =
      jniAccessors.getMethodIDOf(_classRef, "getTextSelectionStart", "()I");

  /// from: public abstract int getTextSelectionStart()
  ///
  /// Retrieve the last selection start set by \#setText(CharSequence, int, int).
  int getTextSelectionStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSelectionStart, jni.JniType.intType, []).integer;

  static final _id_getTextSelectionEnd =
      jniAccessors.getMethodIDOf(_classRef, "getTextSelectionEnd", "()I");

  /// from: public abstract int getTextSelectionEnd()
  ///
  /// Retrieve the last selection end set by \#setText(CharSequence, int, int).
  int getTextSelectionEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSelectionEnd, jni.JniType.intType, []).integer;

  static final _id_getHint = jniAccessors.getMethodIDOf(
      _classRef, "getHint", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getHint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the last hint set by \#setHint.
  jni.JniObject getHint() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHint, jni.JniType.objectType, []).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public abstract android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get extra data associated with this view structure; the returned Bundle is mutable,
  /// allowing you to view and modify its contents.  Keys placed in the Bundle should use
  /// an appropriate namespace prefix (such as com.google.MY_KEY) to avoid conflicts.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_hasExtras =
      jniAccessors.getMethodIDOf(_classRef, "hasExtras", "()Z");

  /// from: public abstract boolean hasExtras()
  ///
  /// Returns true if \#getExtras has been used to create extra content.
  bool hasExtras() => jniAccessors.callMethodWithArgs(
      reference, _id_hasExtras, jni.JniType.booleanType, []).boolean;

  static final _id_setChildCount =
      jniAccessors.getMethodIDOf(_classRef, "setChildCount", "(I)V");

  /// from: public abstract void setChildCount(int num)
  ///
  /// Set the number of children of this view, which defines the range of indices you can
  /// use with \#newChild and \#asyncNewChild.  Calling this method again
  /// resets all of the child state of the view, removing any children that had previously
  /// been added.
  void setChildCount(int num) => jniAccessors.callMethodWithArgs(
      reference, _id_setChildCount, jni.JniType.voidType, [num]).check();

  static final _id_addChildCount =
      jniAccessors.getMethodIDOf(_classRef, "addChildCount", "(I)I");

  /// from: public abstract int addChildCount(int num)
  ///
  /// Add to this view's child count.  This increases the current child count by
  /// <var>num</var> children beyond what was last set by \#setChildCount
  /// or \#addChildCount.  The index at which the new child starts in the child
  /// array is returned.
  ///@param num The number of new children to add.
  ///@return Returns the index in the child array at which the new children start.
  int addChildCount(int num) => jniAccessors.callMethodWithArgs(
      reference, _id_addChildCount, jni.JniType.intType, [num]).integer;

  static final _id_getChildCount =
      jniAccessors.getMethodIDOf(_classRef, "getChildCount", "()I");

  /// from: public abstract int getChildCount()
  ///
  /// Return the child count as set by \#setChildCount.
  int getChildCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getChildCount, jni.JniType.intType, []).integer;

  static final _id_newChild = jniAccessors.getMethodIDOf(
      _classRef, "newChild", "(I)Landroid/view/ViewStructure;");

  /// from: public abstract android.view.ViewStructure newChild(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new child ViewStructure in this view, putting into the list of
  /// children at <var>index</var>.
  ///
  /// __NOTE: __you must pre-allocate space for the child first, by calling either
  /// \#addChildCount(int) or \#setChildCount(int).
  ///@return Returns an fresh ViewStructure ready to be filled in.
  ViewStructure newChild(int index) =>
      ViewStructure.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_newChild, jni.JniType.objectType, [index]).object);

  static final _id_asyncNewChild = jniAccessors.getMethodIDOf(
      _classRef, "asyncNewChild", "(I)Landroid/view/ViewStructure;");

  /// from: public abstract android.view.ViewStructure asyncNewChild(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#newChild, but allows the caller to asynchronously populate the returned
  /// child.  It can transfer the returned ViewStructure to another thread for it
  /// to build its content (and children etc).  Once done, some thread must call
  /// \#asyncCommit to tell the containing ViewStructure that the async
  /// population is done.
  ///
  /// __NOTE: __you must pre-allocate space for the child first, by calling either
  /// \#addChildCount(int) or \#setChildCount(int).
  ///@return Returns an fresh ViewStructure ready to be filled in.
  ViewStructure asyncNewChild(int index) =>
      ViewStructure.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_asyncNewChild, jni.JniType.objectType, [index]).object);

  static final _id_getAutofillId = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillId", "()Landroid/view/autofill/AutofillId;");

  /// from: public abstract android.view.autofill.AutofillId getAutofillId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the AutofillId associated with this node.
  ///@return This value may be {@code null}.
  autofillid_.AutofillId getAutofillId() =>
      autofillid_.AutofillId.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillId, jni.JniType.objectType, []).object);

  static final _id_setAutofillId = jniAccessors.getMethodIDOf(
      _classRef, "setAutofillId", "(Landroid/view/autofill/AutofillId;)V");

  /// from: public abstract void setAutofillId(android.view.autofill.AutofillId id)
  ///
  /// Sets the AutofillId associated with this node.
  ///@param id This value must never be {@code null}.
  void setAutofillId(autofillid_.AutofillId id) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAutofillId,
          jni.JniType.voidType, [id.reference]).check();

  static final _id_setAutofillId1 = jniAccessors.getMethodIDOf(
      _classRef, "setAutofillId", "(Landroid/view/autofill/AutofillId;I)V");

  /// from: public abstract void setAutofillId(android.view.autofill.AutofillId parentId, int virtualId)
  ///
  /// Sets the AutofillId for this virtual node.
  ///@param parentId id of the parent node.
  /// This value must never be {@code null}.
  ///@param virtualId an opaque ID to the Android System; it's the same id used on
  ///            View\#autofill(android.util.SparseArray).
  void setAutofillId1(autofillid_.AutofillId parentId, int virtualId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAutofillId1,
          jni.JniType.voidType, [parentId.reference, virtualId]).check();

  static final _id_setAutofillType =
      jniAccessors.getMethodIDOf(_classRef, "setAutofillType", "(I)V");

  /// from: public abstract void setAutofillType(int type)
  ///
  /// Sets the View\#getAutofillType() that can be used to autofill this node.
  ///@param type Value is android.view.View\#AUTOFILL_TYPE_NONE, android.view.View\#AUTOFILL_TYPE_TEXT, android.view.View\#AUTOFILL_TYPE_TOGGLE, android.view.View\#AUTOFILL_TYPE_LIST, or android.view.View\#AUTOFILL_TYPE_DATE
  void setAutofillType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutofillType, jni.JniType.voidType, [type]).check();

  static final _id_setAutofillHints = jniAccessors.getMethodIDOf(
      _classRef, "setAutofillHints", "([Ljava/lang/String;)V");

  /// from: public abstract void setAutofillHints(java.lang.String[] hint)
  ///
  /// Sets the a hints that helps the autofill service to select the appropriate data to fill the
  /// view.
  ///@param hint This value may be {@code null}.
  void setAutofillHints(jni.JniObject hint) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAutofillHints,
      jni.JniType.voidType,
      [hint.reference]).check();

  static final _id_setAutofillValue = jniAccessors.getMethodIDOf(_classRef,
      "setAutofillValue", "(Landroid/view/autofill/AutofillValue;)V");

  /// from: public abstract void setAutofillValue(android.view.autofill.AutofillValue value)
  ///
  /// Sets the AutofillValue representing the current value of this node.
  void setAutofillValue(autofillvalue_.AutofillValue value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAutofillValue,
          jni.JniType.voidType, [value.reference]).check();

  static final _id_setAutofillOptions = jniAccessors.getMethodIDOf(
      _classRef, "setAutofillOptions", "([Ljava/lang/CharSequence;)V");

  /// from: public abstract void setAutofillOptions(java.lang.CharSequence[] options)
  ///
  /// Sets the options that can be used to autofill this node.
  ///
  /// Typically used by nodes whose View\#getAutofillType() is a list to indicate the
  /// meaning of each possible value in the list.
  void setAutofillOptions(jni.JniObject options) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAutofillOptions,
          jni.JniType.voidType, [options.reference]).check();

  static final _id_setImportantForAutofill =
      jniAccessors.getMethodIDOf(_classRef, "setImportantForAutofill", "(I)V");

  /// from: public void setImportantForAutofill(int mode)
  ///
  /// Sets the View\#setImportantForAutofill(int) importantForAutofill mode of the
  /// view associated with this node.
  ///@param mode Value is android.view.View\#IMPORTANT_FOR_AUTOFILL_AUTO, android.view.View\#IMPORTANT_FOR_AUTOFILL_YES, android.view.View\#IMPORTANT_FOR_AUTOFILL_NO, android.view.View\#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS, or android.view.View\#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
  void setImportantForAutofill(int mode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setImportantForAutofill,
      jni.JniType.voidType,
      [mode]).check();

  static final _id_setInputType =
      jniAccessors.getMethodIDOf(_classRef, "setInputType", "(I)V");

  /// from: public abstract void setInputType(int inputType)
  ///
  /// Sets the android.text.InputType bits of this node.
  ///@param inputType inputType bits as defined by android.text.InputType.
  void setInputType(int inputType) => jniAccessors.callMethodWithArgs(
      reference, _id_setInputType, jni.JniType.voidType, [inputType]).check();

  static final _id_setDataIsSensitive =
      jniAccessors.getMethodIDOf(_classRef, "setDataIsSensitive", "(Z)V");

  /// from: public abstract void setDataIsSensitive(boolean sensitive)
  ///
  /// Sets whether the data on this node is sensitive; if it is, then its content (text, autofill
  /// value, etc..) is striped before calls to android.service.autofill.AutofillService\#onFillRequest(android.service.autofill.FillRequest,
  /// android.os.CancellationSignal, android.service.autofill.FillCallback).
  ///
  /// By default, all nodes are assumed to be sensitive, and only nodes that does not have PII
  /// (Personally Identifiable Information - sensitive data such as email addresses, credit card
  /// numbers, passwords, etc...) should be marked as non-sensitive; a good rule of thumb is to
  /// mark as non-sensitive nodes whose value were statically set from resources.
  ///
  /// Notice that the content of even sensitive nodes are sent to the service (through the
  /// android.service.autofill.AutofillService\#onSaveRequest(android.service.autofill.SaveRequest,
  /// android.service.autofill.SaveCallback) call) when the user consented to save
  /// thedata, so it is important to set the content of sensitive nodes as well, but mark them as
  /// sensitive.
  ///
  /// Should only be set when the node is used for autofill purposes - it will be ignored
  /// when used for Assist.
  void setDataIsSensitive(bool sensitive) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDataIsSensitive,
      jni.JniType.voidType,
      [sensitive]).check();

  static final _id_setMinTextEms =
      jniAccessors.getMethodIDOf(_classRef, "setMinTextEms", "(I)V");

  /// from: public void setMinTextEms(int minEms)
  ///
  /// Sets the minimum width in ems of the text associated with this view, when supported.
  ///
  /// Should only be set when the node is used for autofill purposes - it will be ignored
  /// when used for Assist.
  void setMinTextEms(int minEms) => jniAccessors.callMethodWithArgs(
      reference, _id_setMinTextEms, jni.JniType.voidType, [minEms]).check();

  static final _id_setMaxTextEms =
      jniAccessors.getMethodIDOf(_classRef, "setMaxTextEms", "(I)V");

  /// from: public void setMaxTextEms(int maxEms)
  ///
  /// Sets the maximum width in ems of the text associated with this view, when supported.
  ///
  /// Should only be set when the node is used for autofill purposes - it will be ignored
  /// when used for Assist.
  void setMaxTextEms(int maxEms) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaxTextEms, jni.JniType.voidType, [maxEms]).check();

  static final _id_setMaxTextLength =
      jniAccessors.getMethodIDOf(_classRef, "setMaxTextLength", "(I)V");

  /// from: public void setMaxTextLength(int maxLength)
  ///
  /// Sets the maximum length of the text associated with this view, when supported.
  ///
  /// Should only be set when the node is used for autofill purposes - it will be ignored
  /// when used for Assist.
  void setMaxTextLength(int maxLength) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMaxTextLength,
      jni.JniType.voidType,
      [maxLength]).check();

  static final _id_asyncCommit =
      jniAccessors.getMethodIDOf(_classRef, "asyncCommit", "()V");

  /// from: public abstract void asyncCommit()
  ///
  /// Call when done populating a ViewStructure returned by
  /// \#asyncNewChild.
  void asyncCommit() => jniAccessors.callMethodWithArgs(
      reference, _id_asyncCommit, jni.JniType.voidType, []).check();

  static final _id_setWebDomain = jniAccessors.getMethodIDOf(
      _classRef, "setWebDomain", "(Ljava/lang/String;)V");

  /// from: public abstract void setWebDomain(java.lang.String domain)
  ///
  /// Sets the Web domain represented by this node.
  ///
  /// Typically used when the view is a container for an HTML document.
  ///@param domain RFC 2396-compliant URI representing the domain.
  ///
  /// This value may be {@code null}.
  void setWebDomain(jni.JniString domain) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWebDomain,
      jni.JniType.voidType,
      [domain.reference]).check();

  static final _id_setLocaleList = jniAccessors.getMethodIDOf(
      _classRef, "setLocaleList", "(Landroid/os/LocaleList;)V");

  /// from: public abstract void setLocaleList(android.os.LocaleList localeList)
  ///
  /// Sets the the list of locales associated with this node.
  void setLocaleList(localelist_.LocaleList localeList) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLocaleList,
          jni.JniType.voidType, [localeList.reference]).check();

  static final _id_newHtmlInfoBuilder = jniAccessors.getMethodIDOf(
      _classRef,
      "newHtmlInfoBuilder",
      "(Ljava/lang/String;)Landroid/view/ViewStructure\$HtmlInfo\$Builder;");

  /// from: public abstract android.view.ViewStructure.HtmlInfo.Builder newHtmlInfoBuilder(java.lang.String tagName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new HtmlInfo.Builder for the given HTML tag.
  ///@param tagName name of the HTML tag.
  /// This value must never be {@code null}.
  ///@return a new builder.
  ViewStructure_HtmlInfo_Builder newHtmlInfoBuilder(jni.JniString tagName) =>
      ViewStructure_HtmlInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_newHtmlInfoBuilder,
          jni.JniType.objectType,
          [tagName.reference]).object);

  static final _id_setHtmlInfo = jniAccessors.getMethodIDOf(
      _classRef, "setHtmlInfo", "(Landroid/view/ViewStructure\$HtmlInfo;)V");

  /// from: public abstract void setHtmlInfo(android.view.ViewStructure.HtmlInfo htmlInfo)
  ///
  /// Sets the HTML properties of this node when it represents an HTML element.
  ///
  /// Should only be set when the node is used for autofill purposes - it will be ignored
  /// when used for assist.
  ///@param htmlInfo HTML properties.
  ///
  /// This value must never be {@code null}.
  void setHtmlInfo(ViewStructure_HtmlInfo htmlInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHtmlInfo,
          jni.JniType.voidType, [htmlInfo.reference]).check();
}

/// from: android.view.ViewStructure$HtmlInfo
///
/// Simplified representation of the HTML properties of a node that represents an HTML element.
class ViewStructure_HtmlInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ViewStructure\$HtmlInfo");
  ViewStructure_HtmlInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewStructure_HtmlInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the HTML tag.
  ///@return This value will never be {@code null}.
  jni.JniString getTag() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_getAttributes = jniAccessors.getMethodIDOf(
      _classRef, "getAttributes", "()Ljava/util/List;");

  /// from: public abstract java.util.List<android.util.Pair<java.lang.String,java.lang.String>> getAttributes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of HTML attributes.
  ///@return list of key/value pairs; could contain pairs with the same keys.
  ///
  /// This value may be {@code null}.
  jni.JniObject getAttributes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAttributes, jni.JniType.objectType, []).object);
}

/// from: android.view.ViewStructure$HtmlInfo$Builder
///
/// Builder for HtmlInfo objects.
class ViewStructure_HtmlInfo_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/ViewStructure\$HtmlInfo\$Builder");
  ViewStructure_HtmlInfo_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ViewStructure_HtmlInfo_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_addAttribute = jniAccessors.getMethodIDOf(
      _classRef,
      "addAttribute",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/view/ViewStructure\$HtmlInfo\$Builder;");

  /// from: public abstract android.view.ViewStructure.HtmlInfo.Builder addAttribute(java.lang.String name, java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds an HTML attribute.
  ///@param name name of the attribute.
  /// This value must never be {@code null}.
  ///@param value value of the attribute.
  /// This value must never be {@code null}.
  ///@return same builder, for chaining.
  ViewStructure_HtmlInfo_Builder addAttribute(
          jni.JniString name, jni.JniString value) =>
      ViewStructure_HtmlInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addAttribute,
          jni.JniType.objectType,
          [name.reference, value.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/view/ViewStructure\$HtmlInfo;");

  /// from: public abstract android.view.ViewStructure.HtmlInfo build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds the HtmlInfo object.
  ///@return a new HtmlInfo instance.
  ViewStructure_HtmlInfo build() =>
      ViewStructure_HtmlInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}
