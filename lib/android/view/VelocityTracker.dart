// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "MotionEvent.dart" as motionevent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.VelocityTracker
///
/// Helper for tracking the velocity of touch events, for implementing
/// flinging and other such gestures.
///
/// Use \#obtain to retrieve a new instance of the class when you are going
/// to begin tracking.  Put the motion events you receive into it with
/// \#addMovement(MotionEvent).  When you want to determine the velocity call
/// \#computeCurrentVelocity(int) and then call \#getXVelocity(int)
/// and \#getYVelocity(int) to retrieve the velocity for each pointer id.
class VelocityTracker extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/VelocityTracker");
  VelocityTracker.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_obtain = jniAccessors.getStaticMethodIDOf(
      _classRef, "obtain", "()Landroid/view/VelocityTracker;");

  /// from: static public android.view.VelocityTracker obtain()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a new VelocityTracker object to watch the velocity of a
  /// motion.  Be sure to call \#recycle when done.  You should
  /// generally only maintain an active object while tracking a movement,
  /// so that the VelocityTracker can be re-used elsewhere.
  ///@return Returns a new VelocityTracker.
  static VelocityTracker obtain() =>
      VelocityTracker.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_obtain, jni.JniType.objectType, []).object);

  static final _id_recycle =
      jniAccessors.getMethodIDOf(_classRef, "recycle", "()V");

  /// from: public void recycle()
  ///
  /// Return a VelocityTracker object back to be re-used by others.  You must
  /// not touch the object after calling this function.
  void recycle() => jniAccessors.callMethodWithArgs(
      reference, _id_recycle, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Reset the velocity tracker back to its initial state.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_addMovement = jniAccessors.getMethodIDOf(
      _classRef, "addMovement", "(Landroid/view/MotionEvent;)V");

  /// from: public void addMovement(android.view.MotionEvent event)
  ///
  /// Add a user's movement to the tracker.  You should call this for the
  /// initial MotionEvent\#ACTION_DOWN, the following
  /// MotionEvent\#ACTION_MOVE events that you receive, and the
  /// final MotionEvent\#ACTION_UP.  You can, however, call this
  /// for whichever events you desire.
  ///@param event The MotionEvent you received and would like to track.
  void addMovement(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_addMovement,
          jni.JniType.voidType, [event.reference]).check();

  static final _id_computeCurrentVelocity =
      jniAccessors.getMethodIDOf(_classRef, "computeCurrentVelocity", "(I)V");

  /// from: public void computeCurrentVelocity(int units)
  ///
  /// Equivalent to invoking \#computeCurrentVelocity(int, float) with a maximum
  /// velocity of Float.MAX_VALUE.
  ///@see \#computeCurrentVelocity(int, float)
  void computeCurrentVelocity(int units) => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeCurrentVelocity,
      jni.JniType.voidType,
      [units]).check();

  static final _id_computeCurrentVelocity1 =
      jniAccessors.getMethodIDOf(_classRef, "computeCurrentVelocity", "(IF)V");

  /// from: public void computeCurrentVelocity(int units, float maxVelocity)
  ///
  /// Compute the current velocity based on the points that have been
  /// collected.  Only call this when you actually want to retrieve velocity
  /// information, as it is relatively expensive.  You can then retrieve
  /// the velocity with \#getXVelocity() and
  /// \#getYVelocity().
  ///@param units The units you would like the velocity in.  A value of 1
  /// provides pixels per millisecond, 1000 provides pixels per second, etc.
  ///@param maxVelocity The maximum velocity that can be computed by this method.
  /// This value must be declared in the same unit as the units parameter. This value
  /// must be positive.
  void computeCurrentVelocity1(int units, double maxVelocity) =>
      jniAccessors.callMethodWithArgs(reference, _id_computeCurrentVelocity1,
          jni.JniType.voidType, [units, maxVelocity]).check();

  static final _id_getXVelocity =
      jniAccessors.getMethodIDOf(_classRef, "getXVelocity", "()F");

  /// from: public float getXVelocity()
  ///
  /// Retrieve the last computed X velocity.  You must first call
  /// \#computeCurrentVelocity(int) before calling this function.
  ///@return The previously computed X velocity.
  double getXVelocity() => jniAccessors.callMethodWithArgs(
      reference, _id_getXVelocity, jni.JniType.floatType, []).float;

  static final _id_getYVelocity =
      jniAccessors.getMethodIDOf(_classRef, "getYVelocity", "()F");

  /// from: public float getYVelocity()
  ///
  /// Retrieve the last computed Y velocity.  You must first call
  /// \#computeCurrentVelocity(int) before calling this function.
  ///@return The previously computed Y velocity.
  double getYVelocity() => jniAccessors.callMethodWithArgs(
      reference, _id_getYVelocity, jni.JniType.floatType, []).float;

  static final _id_getXVelocity1 =
      jniAccessors.getMethodIDOf(_classRef, "getXVelocity", "(I)F");

  /// from: public float getXVelocity(int id)
  ///
  /// Retrieve the last computed X velocity.  You must first call
  /// \#computeCurrentVelocity(int) before calling this function.
  ///@param id Which pointer's velocity to return.
  ///@return The previously computed X velocity.
  double getXVelocity1(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_getXVelocity1, jni.JniType.floatType, [id]).float;

  static final _id_getYVelocity1 =
      jniAccessors.getMethodIDOf(_classRef, "getYVelocity", "(I)F");

  /// from: public float getYVelocity(int id)
  ///
  /// Retrieve the last computed Y velocity.  You must first call
  /// \#computeCurrentVelocity(int) before calling this function.
  ///@param id Which pointer's velocity to return.
  ///@return The previously computed Y velocity.
  double getYVelocity1(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_getYVelocity1, jni.JniType.floatType, [id]).float;
}
