// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.Choreographer
///
/// Coordinates the timing of animations, input and drawing.
///
/// The choreographer receives timing pulses (such as vertical synchronization)
/// from the display subsystem then schedules work to occur as part of rendering
/// the next display frame.
///
///
/// Applications typically interact with the choreographer indirectly using
/// higher level abstractions in the animation framework or the view hierarchy.
/// Here are some examples of things you can do using the higher-level APIs.
///
///
/// <ul>
/// <li>To post an animation to be processed on a regular time basis synchronized with
/// display frame rendering, use android.animation.ValueAnimator\#start.</li>
/// <li>To post a Runnable to be invoked once at the beginning of the next display
/// frame, use View\#postOnAnimation.</li>
/// <li>To post a Runnable to be invoked once at the beginning of the next display
/// frame after a delay, use View\#postOnAnimationDelayed.</li>
/// <li>To post a call to View\#invalidate() to occur once at the beginning of the
/// next display frame, use View\#postInvalidateOnAnimation() or
/// View\#postInvalidateOnAnimation(int, int, int, int).</li>
/// <li>To ensure that the contents of a View scroll smoothly and are drawn in
/// sync with display frame rendering, do nothing.  This already happens automatically.
/// View\#onDraw will be called at the appropriate time.</li>
/// </ul>
///
/// However, there are a few cases where you might want to use the functions of the
/// choreographer directly in your application.  Here are some examples.
///
///
/// <ul>
/// <li>If your application does its rendering in a different thread, possibly using GL,
/// or does not use the animation framework or view hierarchy at all
/// and you want to ensure that it is appropriately synchronized with the display, then use
/// Choreographer\#postFrameCallback.</li>
/// <li>... and that's about it.</li>
/// </ul>
///
/// Each Looper thread has its own choreographer.  Other threads can
/// post callbacks to run on the choreographer but they will run on the Looper
/// to which the choreographer belongs.
///
///
class Choreographer extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/Choreographer");
  Choreographer.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/view/Choreographer;");

  /// from: static public android.view.Choreographer getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the choreographer for the calling thread.  Must be called from
  /// a thread that already has a android.os.Looper associated with it.
  ///@return The choreographer for this thread.
  ///@throws IllegalStateException if the thread does not have a looper.
  static Choreographer getInstance() =>
      Choreographer.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_postFrameCallback = jniAccessors.getMethodIDOf(_classRef,
      "postFrameCallback", "(Landroid/view/Choreographer\$FrameCallback;)V");

  /// from: public void postFrameCallback(android.view.Choreographer.FrameCallback callback)
  ///
  /// Posts a frame callback to run on the next frame.
  ///
  /// The callback runs once then is automatically removed.
  ///
  ///
  ///@param callback The frame callback to run during the next frame.
  ///@see \#postFrameCallbackDelayed
  ///@see \#removeFrameCallback
  void postFrameCallback(Choreographer_FrameCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_postFrameCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_postFrameCallbackDelayed = jniAccessors.getMethodIDOf(
      _classRef,
      "postFrameCallbackDelayed",
      "(Landroid/view/Choreographer\$FrameCallback;J)V");

  /// from: public void postFrameCallbackDelayed(android.view.Choreographer.FrameCallback callback, long delayMillis)
  ///
  /// Posts a frame callback to run on the next frame after the specified delay.
  ///
  /// The callback runs once then is automatically removed.
  ///
  ///
  ///@param callback The frame callback to run during the next frame.
  ///@param delayMillis The delay time in milliseconds.
  ///@see \#postFrameCallback
  ///@see \#removeFrameCallback
  void postFrameCallbackDelayed(
          Choreographer_FrameCallback callback, int delayMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_postFrameCallbackDelayed,
          jni.JniType.voidType, [callback.reference, delayMillis]).check();

  static final _id_removeFrameCallback = jniAccessors.getMethodIDOf(_classRef,
      "removeFrameCallback", "(Landroid/view/Choreographer\$FrameCallback;)V");

  /// from: public void removeFrameCallback(android.view.Choreographer.FrameCallback callback)
  ///
  /// Removes a previously posted frame callback.
  ///@param callback The frame callback to remove.
  ///@see \#postFrameCallback
  ///@see \#postFrameCallbackDelayed
  void removeFrameCallback(Choreographer_FrameCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeFrameCallback,
          jni.JniType.voidType, [callback.reference]).check();
}

/// from: android.view.Choreographer$FrameCallback
///
/// Implement this interface to receive a callback when a new display frame is
/// being rendered.  The callback is invoked on the Looper thread to
/// which the Choreographer is attached.
class Choreographer_FrameCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/Choreographer\$FrameCallback");
  Choreographer_FrameCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_doFrame =
      jniAccessors.getMethodIDOf(_classRef, "doFrame", "(J)V");

  /// from: public abstract void doFrame(long frameTimeNanos)
  ///
  /// Called when a new display frame is being rendered.
  ///
  /// This method provides the time in nanoseconds when the frame started being rendered.
  /// The frame time provides a stable time base for synchronizing animations
  /// and drawing.  It should be used instead of SystemClock\#uptimeMillis()
  /// or System\#nanoTime() for animations and drawing in the UI.  Using the frame
  /// time helps to reduce inter-frame jitter because the frame time is fixed at the time
  /// the frame was scheduled to start, regardless of when the animations or drawing
  /// callback actually runs.  All callbacks that run as part of rendering a frame will
  /// observe the same frame time so using the frame time also helps to synchronize effects
  /// that are performed by different callbacks.
  ///
  ///
  /// Please note that the framework already takes care to process animations and
  /// drawing using the frame time as a stable time base.  Most applications should
  /// not need to use the frame time information directly.
  ///
  ///
  ///@param frameTimeNanos The time in nanoseconds when the frame started being rendered,
  /// in the System\#nanoTime() timebase.  Divide this value by {@code 1000000}
  /// to convert it to the SystemClock\#uptimeMillis() time base.
  void doFrame(int frameTimeNanos) => jniAccessors.callMethodWithArgs(
      reference, _id_doFrame, jni.JniType.voidType, [frameTimeNanos]).check();
}
