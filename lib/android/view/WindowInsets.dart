// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "DisplayCutout.dart" as displaycutout_;

import "../graphics/Rect.dart" as rect_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.WindowInsets
///
/// Describes a set of insets for window content.
///
/// WindowInsets are immutable and may be expanded to include more inset types in the future.
/// To adjust insets, use one of the supplied clone methods to obtain a new WindowInsets instance
/// with the adjusted properties.
///
///
/// Note: Before android.os.Build.VERSION_CODES\#P P, WindowInsets instances were only
/// immutable during a single layout pass (i.e. would return the same values between
/// View\#onApplyWindowInsets and View\#onLayout, but could return other values
/// otherwise). Starting with android.os.Build.VERSION_CODES\#P P, WindowInsets are
/// always immutable and implement equality.
///@see View.OnApplyWindowInsetsListener
///@see View\#onApplyWindowInsets(WindowInsets)
class WindowInsets extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/WindowInsets");
  WindowInsets.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/WindowInsets;)V");

  /// from: public void <init>(android.view.WindowInsets src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new WindowInsets, copying all values from a source WindowInsets.
  ///@param src Source to copy insets from
  WindowInsets(WindowInsets src)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [src.reference]).object);

  static final _id_getSystemWindowInsetLeft =
      jniAccessors.getMethodIDOf(_classRef, "getSystemWindowInsetLeft", "()I");

  /// from: public int getSystemWindowInsetLeft()
  ///
  /// Returns the left system window inset in pixels.
  ///
  /// The system window inset represents the area of a full-screen window that is
  /// partially or fully obscured by the status bar, navigation bar, IME or other system windows.
  ///
  ///
  ///@return The left system window inset
  int getSystemWindowInsetLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getSystemWindowInsetLeft, jni.JniType.intType, []).integer;

  static final _id_getSystemWindowInsetTop =
      jniAccessors.getMethodIDOf(_classRef, "getSystemWindowInsetTop", "()I");

  /// from: public int getSystemWindowInsetTop()
  ///
  /// Returns the top system window inset in pixels.
  ///
  /// The system window inset represents the area of a full-screen window that is
  /// partially or fully obscured by the status bar, navigation bar, IME or other system windows.
  ///
  ///
  ///@return The top system window inset
  int getSystemWindowInsetTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getSystemWindowInsetTop, jni.JniType.intType, []).integer;

  static final _id_getSystemWindowInsetRight =
      jniAccessors.getMethodIDOf(_classRef, "getSystemWindowInsetRight", "()I");

  /// from: public int getSystemWindowInsetRight()
  ///
  /// Returns the right system window inset in pixels.
  ///
  /// The system window inset represents the area of a full-screen window that is
  /// partially or fully obscured by the status bar, navigation bar, IME or other system windows.
  ///
  ///
  ///@return The right system window inset
  int getSystemWindowInsetRight() => jniAccessors.callMethodWithArgs(reference,
      _id_getSystemWindowInsetRight, jni.JniType.intType, []).integer;

  static final _id_getSystemWindowInsetBottom = jniAccessors.getMethodIDOf(
      _classRef, "getSystemWindowInsetBottom", "()I");

  /// from: public int getSystemWindowInsetBottom()
  ///
  /// Returns the bottom system window inset in pixels.
  ///
  /// The system window inset represents the area of a full-screen window that is
  /// partially or fully obscured by the status bar, navigation bar, IME or other system windows.
  ///
  ///
  ///@return The bottom system window inset
  int getSystemWindowInsetBottom() => jniAccessors.callMethodWithArgs(reference,
      _id_getSystemWindowInsetBottom, jni.JniType.intType, []).integer;

  static final _id_hasSystemWindowInsets =
      jniAccessors.getMethodIDOf(_classRef, "hasSystemWindowInsets", "()Z");

  /// from: public boolean hasSystemWindowInsets()
  ///
  /// Returns true if this WindowInsets has nonzero system window insets.
  ///
  /// The system window inset represents the area of a full-screen window that is
  /// partially or fully obscured by the status bar, navigation bar, IME or other system windows.
  ///
  ///
  ///@return true if any of the system window inset values are nonzero
  bool hasSystemWindowInsets() => jniAccessors.callMethodWithArgs(reference,
      _id_hasSystemWindowInsets, jni.JniType.booleanType, []).boolean;

  static final _id_hasInsets =
      jniAccessors.getMethodIDOf(_classRef, "hasInsets", "()Z");

  /// from: public boolean hasInsets()
  ///
  /// Returns true if this WindowInsets has any nonzero insets.
  ///@return true if any inset values are nonzero
  bool hasInsets() => jniAccessors.callMethodWithArgs(
      reference, _id_hasInsets, jni.JniType.booleanType, []).boolean;

  static final _id_getDisplayCutout = jniAccessors.getMethodIDOf(
      _classRef, "getDisplayCutout", "()Landroid/view/DisplayCutout;");

  /// from: public android.view.DisplayCutout getDisplayCutout()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the display cutout if there is one.
  ///@return the display cutout or null if there is none
  ///@see DisplayCutout
  displaycutout_.DisplayCutout getDisplayCutout() =>
      displaycutout_.DisplayCutout.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDisplayCutout, jni.JniType.objectType, []).object);

  static final _id_consumeDisplayCutout = jniAccessors.getMethodIDOf(
      _classRef, "consumeDisplayCutout", "()Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets consumeDisplayCutout()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of this WindowInsets with the cutout fully consumed.
  ///@return A modified copy of this WindowInsets
  WindowInsets consumeDisplayCutout() =>
      WindowInsets.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_consumeDisplayCutout, jni.JniType.objectType, []).object);

  static final _id_isConsumed =
      jniAccessors.getMethodIDOf(_classRef, "isConsumed", "()Z");

  /// from: public boolean isConsumed()
  ///
  /// Check if these insets have been fully consumed.
  ///
  /// Insets are considered "consumed" if the applicable <code>consume*</code> methods
  /// have been called such that all insets have been set to zero. This affects propagation of
  /// insets through the view hierarchy; insets that have not been fully consumed will continue
  /// to propagate down to child views.
  ///
  ///
  /// The result of this method is equivalent to the return value of
  /// View\#fitSystemWindows(android.graphics.Rect).
  ///
  ///@return true if the insets have been fully consumed.
  bool isConsumed() => jniAccessors.callMethodWithArgs(
      reference, _id_isConsumed, jni.JniType.booleanType, []).boolean;

  static final _id_isRound =
      jniAccessors.getMethodIDOf(_classRef, "isRound", "()Z");

  /// from: public boolean isRound()
  ///
  /// Returns true if the associated window has a round shape.
  ///
  /// A round window's left, top, right and bottom edges reach all the way to the
  /// associated edges of the window but the corners may not be visible. Views responding
  /// to round insets should take care to not lay out critical elements within the corners
  /// where they may not be accessible.
  ///
  ///@return True if the window is round
  bool isRound() => jniAccessors.callMethodWithArgs(
      reference, _id_isRound, jni.JniType.booleanType, []).boolean;

  static final _id_consumeSystemWindowInsets = jniAccessors.getMethodIDOf(
      _classRef, "consumeSystemWindowInsets", "()Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets consumeSystemWindowInsets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of this WindowInsets with the system window insets fully consumed.
  ///@return A modified copy of this WindowInsets
  WindowInsets consumeSystemWindowInsets() =>
      WindowInsets.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_consumeSystemWindowInsets, jni.JniType.objectType, []).object);

  static final _id_replaceSystemWindowInsets = jniAccessors.getMethodIDOf(
      _classRef,
      "replaceSystemWindowInsets",
      "(IIII)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets replaceSystemWindowInsets(int left, int top, int right, int bottom)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of this WindowInsets with selected system window insets replaced
  /// with new values.
  ///@param left New left inset in pixels
  ///@param top New top inset in pixels
  ///@param right New right inset in pixels
  ///@param bottom New bottom inset in pixels
  ///@return A modified copy of this WindowInsets
  WindowInsets replaceSystemWindowInsets(
          int left, int top, int right, int bottom) =>
      WindowInsets.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_replaceSystemWindowInsets,
          jni.JniType.objectType,
          [left, top, right, bottom]).object);

  static final _id_replaceSystemWindowInsets1 = jniAccessors.getMethodIDOf(
      _classRef,
      "replaceSystemWindowInsets",
      "(Landroid/graphics/Rect;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets replaceSystemWindowInsets(android.graphics.Rect systemWindowInsets)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of this WindowInsets with selected system window insets replaced
  /// with new values.
  ///@param systemWindowInsets New system window insets. Each field is the inset in pixels
  ///                           for that edge
  ///@return A modified copy of this WindowInsets
  WindowInsets replaceSystemWindowInsets1(rect_.Rect systemWindowInsets) =>
      WindowInsets.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_replaceSystemWindowInsets1,
          jni.JniType.objectType,
          [systemWindowInsets.reference]).object);

  static final _id_getStableInsetTop =
      jniAccessors.getMethodIDOf(_classRef, "getStableInsetTop", "()I");

  /// from: public int getStableInsetTop()
  ///
  /// Returns the top stable inset in pixels.
  ///
  /// The stable inset represents the area of a full-screen window that __may__ be
  /// partially or fully obscured by the system UI elements.  This value does not change
  /// based on the visibility state of those elements; for example, if the status bar is
  /// normally shown, but temporarily hidden, the stable inset will still provide the inset
  /// associated with the status bar being shown.
  ///
  ///@return The top stable inset
  int getStableInsetTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getStableInsetTop, jni.JniType.intType, []).integer;

  static final _id_getStableInsetLeft =
      jniAccessors.getMethodIDOf(_classRef, "getStableInsetLeft", "()I");

  /// from: public int getStableInsetLeft()
  ///
  /// Returns the left stable inset in pixels.
  ///
  /// The stable inset represents the area of a full-screen window that __may__ be
  /// partially or fully obscured by the system UI elements.  This value does not change
  /// based on the visibility state of those elements; for example, if the status bar is
  /// normally shown, but temporarily hidden, the stable inset will still provide the inset
  /// associated with the status bar being shown.
  ///
  ///@return The left stable inset
  int getStableInsetLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getStableInsetLeft, jni.JniType.intType, []).integer;

  static final _id_getStableInsetRight =
      jniAccessors.getMethodIDOf(_classRef, "getStableInsetRight", "()I");

  /// from: public int getStableInsetRight()
  ///
  /// Returns the right stable inset in pixels.
  ///
  /// The stable inset represents the area of a full-screen window that __may__ be
  /// partially or fully obscured by the system UI elements.  This value does not change
  /// based on the visibility state of those elements; for example, if the status bar is
  /// normally shown, but temporarily hidden, the stable inset will still provide the inset
  /// associated with the status bar being shown.
  ///
  ///@return The right stable inset
  int getStableInsetRight() => jniAccessors.callMethodWithArgs(
      reference, _id_getStableInsetRight, jni.JniType.intType, []).integer;

  static final _id_getStableInsetBottom =
      jniAccessors.getMethodIDOf(_classRef, "getStableInsetBottom", "()I");

  /// from: public int getStableInsetBottom()
  ///
  /// Returns the bottom stable inset in pixels.
  ///
  /// The stable inset represents the area of a full-screen window that __may__ be
  /// partially or fully obscured by the system UI elements.  This value does not change
  /// based on the visibility state of those elements; for example, if the status bar is
  /// normally shown, but temporarily hidden, the stable inset will still provide the inset
  /// associated with the status bar being shown.
  ///
  ///@return The bottom stable inset
  int getStableInsetBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getStableInsetBottom, jni.JniType.intType, []).integer;

  static final _id_hasStableInsets =
      jniAccessors.getMethodIDOf(_classRef, "hasStableInsets", "()Z");

  /// from: public boolean hasStableInsets()
  ///
  /// Returns true if this WindowInsets has nonzero stable insets.
  ///
  /// The stable inset represents the area of a full-screen window that __may__ be
  /// partially or fully obscured by the system UI elements.  This value does not change
  /// based on the visibility state of those elements; for example, if the status bar is
  /// normally shown, but temporarily hidden, the stable inset will still provide the inset
  /// associated with the status bar being shown.
  ///
  ///@return true if any of the stable inset values are nonzero
  bool hasStableInsets() => jniAccessors.callMethodWithArgs(
      reference, _id_hasStableInsets, jni.JniType.booleanType, []).boolean;

  static final _id_consumeStableInsets = jniAccessors.getMethodIDOf(
      _classRef, "consumeStableInsets", "()Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets consumeStableInsets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of this WindowInsets with the stable insets fully consumed.
  ///@return A modified copy of this WindowInsets
  WindowInsets consumeStableInsets() =>
      WindowInsets.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_consumeStableInsets, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
