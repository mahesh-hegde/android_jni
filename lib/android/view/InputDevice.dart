// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;

import "KeyCharacterMap.dart" as keycharactermap_;

import "../os/Vibrator.dart" as vibrator_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.InputDevice
///
/// Describes the capabilities of a particular input device.
///
/// Each input device may support multiple classes of input.  For example, a multi-function
/// keyboard may compose the capabilities of a standard keyboard together with a track pad mouse
/// or other pointing device.
///
///
/// Some input devices present multiple distinguishable sources of input.
/// Applications can query the framework about the characteristics of each distinct source.
///
///
/// As a further wrinkle, different kinds of input sources uses different coordinate systems
/// to describe motion events.  Refer to the comments on the input source constants for
/// the appropriate interpretation.
///
///
class InputDevice extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/InputDevice");
  InputDevice.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.InputDevice> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int KEYBOARD_TYPE_ALPHABETIC
  ///
  /// The keyboard supports a complement of alphabetic keys.
  static const KEYBOARD_TYPE_ALPHABETIC = 2;

  /// from: static public final int KEYBOARD_TYPE_NONE
  ///
  /// There is no keyboard.
  static const KEYBOARD_TYPE_NONE = 0;

  /// from: static public final int KEYBOARD_TYPE_NON_ALPHABETIC
  ///
  /// The keyboard is not fully alphabetic.  It may be a numeric keypad or an assortment
  /// of buttons that are not mapped as alphabetic keys suitable for text input.
  static const KEYBOARD_TYPE_NON_ALPHABETIC = 1;

  /// from: static public final int MOTION_RANGE_ORIENTATION
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_ORIENTATION.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_ORIENTATION instead.
  static const MOTION_RANGE_ORIENTATION = 8;

  /// from: static public final int MOTION_RANGE_PRESSURE
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_PRESSURE.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_PRESSURE instead.
  static const MOTION_RANGE_PRESSURE = 2;

  /// from: static public final int MOTION_RANGE_SIZE
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_SIZE.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_SIZE instead.
  static const MOTION_RANGE_SIZE = 3;

  /// from: static public final int MOTION_RANGE_TOOL_MAJOR
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_TOOL_MAJOR.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_TOOL_MAJOR instead.
  static const MOTION_RANGE_TOOL_MAJOR = 6;

  /// from: static public final int MOTION_RANGE_TOOL_MINOR
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_TOOL_MINOR.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_TOOL_MINOR instead.
  static const MOTION_RANGE_TOOL_MINOR = 7;

  /// from: static public final int MOTION_RANGE_TOUCH_MAJOR
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_TOUCH_MAJOR.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_TOUCH_MAJOR instead.
  static const MOTION_RANGE_TOUCH_MAJOR = 4;

  /// from: static public final int MOTION_RANGE_TOUCH_MINOR
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_TOUCH_MINOR.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_TOUCH_MINOR instead.
  static const MOTION_RANGE_TOUCH_MINOR = 5;

  /// from: static public final int MOTION_RANGE_X
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_X.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_X instead.
  static const MOTION_RANGE_X = 0;

  /// from: static public final int MOTION_RANGE_Y
  ///
  /// Constant for retrieving the range of values for MotionEvent\#AXIS_Y.
  ///@see \#getMotionRange
  ///@deprecated Use MotionEvent\#AXIS_Y instead.
  static const MOTION_RANGE_Y = 1;

  /// from: static public final int SOURCE_ANY
  ///
  /// A special input source constant that is used when filtering input devices
  /// to match devices that provide any type of input source.
  static const SOURCE_ANY = -256;

  /// from: static public final int SOURCE_BLUETOOTH_STYLUS
  ///
  /// The input device is a Bluetooth stylus.
  ///
  /// Note that this bit merely indicates that an input device is capable of
  /// obtaining input from a Bluetooth stylus.  To determine whether a given
  /// touch event was produced by a stylus, examine the tool type returned by
  /// MotionEvent\#getToolType(int) for each individual pointer.
  ///
  ///
  /// A single touch event may multiple pointers with different tool types,
  /// such as an event that has one pointer with tool type
  /// MotionEvent\#TOOL_TYPE_FINGER and another pointer with tool type
  /// MotionEvent\#TOOL_TYPE_STYLUS.  So it is important to examine
  /// the tool type of each pointer, regardless of the source reported
  /// by MotionEvent\#getSource().
  ///
  ///
  /// A bluetooth stylus generally receives its pressure and button state
  /// information from the stylus itself, and derives the rest from another
  /// source. For example, a Bluetooth stylus used in conjunction with a
  /// touchscreen would derive its contact position and pointer size from the
  /// touchscreen and may not be any more accurate than other tools such as
  /// fingers.
  ///
  ///
  ///@see \#SOURCE_STYLUS
  ///@see \#SOURCE_CLASS_POINTER
  static const SOURCE_BLUETOOTH_STYLUS = 49154;

  /// from: static public final int SOURCE_CLASS_BUTTON
  ///
  /// The input source has buttons or keys.
  /// Examples: \#SOURCE_KEYBOARD, \#SOURCE_DPAD.
  ///
  /// A KeyEvent should be interpreted as a button or key press.
  ///
  /// Use \#getKeyCharacterMap to query the device's button and key mappings.
  static const SOURCE_CLASS_BUTTON = 1;

  /// from: static public final int SOURCE_CLASS_JOYSTICK
  ///
  /// The input source is a joystick.
  ///
  /// A MotionEvent should be interpreted as absolute joystick movements.
  ///
  /// Use \#getMotionRange to query the range of positions.
  static const SOURCE_CLASS_JOYSTICK = 16;

  /// from: static public final int SOURCE_CLASS_MASK
  ///
  /// A mask for input source classes.
  ///
  /// Each distinct input source constant has one or more input source class bits set to
  /// specify the desired interpretation for its input events.
  static const SOURCE_CLASS_MASK = 255;

  /// from: static public final int SOURCE_CLASS_NONE
  ///
  /// The input source has no class.
  ///
  /// It is up to the application to determine how to handle the device based on the device type.
  static const SOURCE_CLASS_NONE = 0;

  /// from: static public final int SOURCE_CLASS_POINTER
  ///
  /// The input source is a pointing device associated with a display.
  /// Examples: \#SOURCE_TOUCHSCREEN, \#SOURCE_MOUSE.
  ///
  /// A MotionEvent should be interpreted as absolute coordinates in
  /// display units according to the View hierarchy.  Pointer down/up indicated when
  /// the finger touches the display or when the selection button is pressed/released.
  ///
  /// Use \#getMotionRange to query the range of the pointing device.  Some devices permit
  /// touches outside the display area so the effective range may be somewhat smaller or larger
  /// than the actual display size.
  static const SOURCE_CLASS_POINTER = 2;

  /// from: static public final int SOURCE_CLASS_POSITION
  ///
  /// The input source is an absolute positioning device not associated with a display
  /// (unlike \#SOURCE_CLASS_POINTER).
  ///
  /// A MotionEvent should be interpreted as absolute coordinates in
  /// device-specific surface units.
  ///
  /// Use \#getMotionRange to query the range of positions.
  static const SOURCE_CLASS_POSITION = 8;

  /// from: static public final int SOURCE_CLASS_TRACKBALL
  ///
  /// The input source is a trackball navigation device.
  /// Examples: \#SOURCE_TRACKBALL.
  ///
  /// A MotionEvent should be interpreted as relative movements in device-specific
  /// units used for navigation purposes.  Pointer down/up indicates when the selection button
  /// is pressed/released.
  ///
  /// Use \#getMotionRange to query the range of motion.
  static const SOURCE_CLASS_TRACKBALL = 4;

  /// from: static public final int SOURCE_DPAD
  ///
  /// The input source is a DPad.
  ///@see \#SOURCE_CLASS_BUTTON
  static const SOURCE_DPAD = 513;

  /// from: static public final int SOURCE_GAMEPAD
  ///
  /// The input source is a game pad.
  /// (It may also be a \#SOURCE_JOYSTICK).
  ///@see \#SOURCE_CLASS_BUTTON
  static const SOURCE_GAMEPAD = 1025;

  /// from: static public final int SOURCE_HDMI
  ///
  /// The input source is a device connected through HDMI-based bus.
  ///
  /// The key comes in through HDMI-CEC or MHL signal line, and is treated as if it were
  /// generated by a locally connected DPAD or keyboard.
  static const SOURCE_HDMI = 33554433;

  /// from: static public final int SOURCE_JOYSTICK
  ///
  /// The input source is a joystick.
  /// (It may also be a \#SOURCE_GAMEPAD).
  ///@see \#SOURCE_CLASS_JOYSTICK
  static const SOURCE_JOYSTICK = 16777232;

  /// from: static public final int SOURCE_KEYBOARD
  ///
  /// The input source is a keyboard.
  ///
  /// This source indicates pretty much anything that has buttons.  Use
  /// \#getKeyboardType() to determine whether the keyboard has alphabetic keys
  /// and can be used to enter text.
  ///@see \#SOURCE_CLASS_BUTTON
  static const SOURCE_KEYBOARD = 257;

  /// from: static public final int SOURCE_MOUSE
  ///
  /// The input source is a mouse pointing device.
  /// This code is also used for other mouse-like pointing devices such as trackpads
  /// and trackpoints.
  ///@see \#SOURCE_CLASS_POINTER
  static const SOURCE_MOUSE = 8194;

  /// from: static public final int SOURCE_MOUSE_RELATIVE
  ///
  /// The input source is a mouse device whose relative motions should be interpreted as
  /// navigation events.
  ///@see \#SOURCE_CLASS_TRACKBALL
  static const SOURCE_MOUSE_RELATIVE = 131076;

  /// from: static public final int SOURCE_ROTARY_ENCODER
  ///
  /// The input source is a rotating encoder device whose motions should be interpreted as akin to
  /// those of a scroll wheel.
  ///@see \#SOURCE_CLASS_NONE
  static const SOURCE_ROTARY_ENCODER = 4194304;

  /// from: static public final int SOURCE_STYLUS
  ///
  /// The input source is a stylus pointing device.
  ///
  /// Note that this bit merely indicates that an input device is capable of obtaining
  /// input from a stylus.  To determine whether a given touch event was produced
  /// by a stylus, examine the tool type returned by MotionEvent\#getToolType(int)
  /// for each individual pointer.
  ///
  ///
  /// A single touch event may multiple pointers with different tool types,
  /// such as an event that has one pointer with tool type
  /// MotionEvent\#TOOL_TYPE_FINGER and another pointer with tool type
  /// MotionEvent\#TOOL_TYPE_STYLUS.  So it is important to examine
  /// the tool type of each pointer, regardless of the source reported
  /// by MotionEvent\#getSource().
  ///
  ///
  ///@see \#SOURCE_CLASS_POINTER
  static const SOURCE_STYLUS = 16386;

  /// from: static public final int SOURCE_TOUCHPAD
  ///
  /// The input source is a touch pad or digitizer tablet that is not
  /// associated with a display (unlike \#SOURCE_TOUCHSCREEN).
  ///@see \#SOURCE_CLASS_POSITION
  static const SOURCE_TOUCHPAD = 1048584;

  /// from: static public final int SOURCE_TOUCHSCREEN
  ///
  /// The input source is a touch screen pointing device.
  ///@see \#SOURCE_CLASS_POINTER
  static const SOURCE_TOUCHSCREEN = 4098;

  /// from: static public final int SOURCE_TOUCH_NAVIGATION
  ///
  /// The input source is a touch device whose motions should be interpreted as navigation events.
  ///
  /// For example, an upward swipe should be as an upward focus traversal in the same manner as
  /// pressing up on a D-Pad would be. Swipes to the left, right and down should be treated in a
  /// similar manner.
  ///@see \#SOURCE_CLASS_NONE
  static const SOURCE_TOUCH_NAVIGATION = 2097152;

  /// from: static public final int SOURCE_TRACKBALL
  ///
  /// The input source is a trackball.
  ///@see \#SOURCE_CLASS_TRACKBALL
  static const SOURCE_TRACKBALL = 65540;

  /// from: static public final int SOURCE_UNKNOWN
  ///
  /// The input source is unknown.
  static const SOURCE_UNKNOWN = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputDevice(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [in0.reference]).object);

  static final _id_getDevice = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDevice", "(I)Landroid/view/InputDevice;");

  /// from: static public android.view.InputDevice getDevice(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets information about the input device with the specified id.
  ///@param id The device id.
  ///@return The input device or null if not found.
  static InputDevice getDevice(int id) =>
      InputDevice.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getDevice, jni.JniType.objectType, [id]).object);

  static final _id_getDeviceIds =
      jniAccessors.getStaticMethodIDOf(_classRef, "getDeviceIds", "()[I");

  /// from: static public int[] getDeviceIds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the ids of all input devices in the system.
  ///@return The input device ids.
  static jni.JniObject getDeviceIds() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getDeviceIds, jni.JniType.objectType, []).object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// Gets the input device id.
  ///
  /// Each input device receives a unique id when it is first configured
  /// by the system.  The input device id may change when the system is restarted or if the
  /// input device is disconnected, reconnected or reconfigured at any time.
  /// If you require a stable identifier for a device that persists across
  /// boots and reconfigurations, use \#getDescriptor().
  ///
  ///
  ///@return The input device id.
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getControllerNumber =
      jniAccessors.getMethodIDOf(_classRef, "getControllerNumber", "()I");

  /// from: public int getControllerNumber()
  ///
  /// The controller number for a given input device.
  ///
  /// Each gamepad or joystick is given a unique, positive controller number when initially
  /// configured by the system. This number may change due to events such as device disconnects /
  /// reconnects or user initiated reassignment. Any change in number will trigger an event that
  /// can be observed by registering an InputManager.InputDeviceListener.
  ///
  ///
  ///
  /// All input devices which are not gamepads or joysticks will be assigned a controller number
  /// of 0.
  ///
  ///
  ///@return The controller number of the device.
  int getControllerNumber() => jniAccessors.callMethodWithArgs(
      reference, _id_getControllerNumber, jni.JniType.intType, []).integer;

  static final _id_getVendorId =
      jniAccessors.getMethodIDOf(_classRef, "getVendorId", "()I");

  /// from: public int getVendorId()
  ///
  /// Gets the vendor id for the given device, if available.
  ///
  /// A vendor id uniquely identifies the company who manufactured the device. A value of 0 will
  /// be assigned where a vendor id is not available.
  ///
  ///
  ///@return The vendor id of a given device
  int getVendorId() => jniAccessors.callMethodWithArgs(
      reference, _id_getVendorId, jni.JniType.intType, []).integer;

  static final _id_getProductId =
      jniAccessors.getMethodIDOf(_classRef, "getProductId", "()I");

  /// from: public int getProductId()
  ///
  /// Gets the product id for the given device, if available.
  ///
  /// A product id uniquely identifies which product within the address space of a given vendor,
  /// identified by the device's vendor id. A value of 0 will be assigned where a product id is
  /// not available.
  ///
  ///
  ///@return The product id of a given device
  int getProductId() => jniAccessors.callMethodWithArgs(
      reference, _id_getProductId, jni.JniType.intType, []).integer;

  static final _id_getDescriptor = jniAccessors.getMethodIDOf(
      _classRef, "getDescriptor", "()Ljava/lang/String;");

  /// from: public java.lang.String getDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the input device descriptor, which is a stable identifier for an input device.
  ///
  /// An input device descriptor uniquely identifies an input device.  Its value
  /// is intended to be persistent across system restarts, and should not change even
  /// if the input device is disconnected, reconnected or reconfigured at any time.
  ///
  ///
  /// It is possible for there to be multiple InputDevice instances that have the
  /// same input device descriptor.  This might happen in situations where a single
  /// human input device registers multiple InputDevice instances (HID collections)
  /// that describe separate features of the device, such as a keyboard that also
  /// has a trackpad.  Alternately, it may be that the input devices are simply
  /// indistinguishable, such as two keyboards made by the same manufacturer.
  ///
  ///
  /// The input device descriptor returned by \#getDescriptor should only be
  /// used when an application needs to remember settings associated with a particular
  /// input device.  For all other purposes when referring to a logical
  /// InputDevice instance at runtime use the id returned by \#getId().
  ///
  ///
  ///@return The input device descriptor.
  jni.JniString getDescriptor() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDescriptor, jni.JniType.objectType, []).object);

  static final _id_isVirtual =
      jniAccessors.getMethodIDOf(_classRef, "isVirtual", "()Z");

  /// from: public boolean isVirtual()
  ///
  /// Returns true if the device is a virtual input device rather than a real one,
  /// such as the virtual keyboard (see KeyCharacterMap\#VIRTUAL_KEYBOARD).
  ///
  /// Virtual input devices are provided to implement system-level functionality
  /// and should not be seen or configured by users.
  ///
  ///
  ///@return True if the device is virtual.
  ///@see KeyCharacterMap\#VIRTUAL_KEYBOARD
  bool isVirtual() => jniAccessors.callMethodWithArgs(
      reference, _id_isVirtual, jni.JniType.booleanType, []).boolean;

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the name of this input device.
  ///@return The input device name.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_getSources =
      jniAccessors.getMethodIDOf(_classRef, "getSources", "()I");

  /// from: public int getSources()
  ///
  /// Gets the input sources supported by this input device as a combined bitfield.
  ///@return The supported input sources.
  int getSources() => jniAccessors.callMethodWithArgs(
      reference, _id_getSources, jni.JniType.intType, []).integer;

  static final _id_supportsSource =
      jniAccessors.getMethodIDOf(_classRef, "supportsSource", "(I)Z");

  /// from: public boolean supportsSource(int source)
  ///
  /// Determines whether the input device supports the given source or sources.
  ///@param source The input source or sources to check against. This can be a generic device
  /// type such as InputDevice\#SOURCE_MOUSE, a more generic device class, such as
  /// InputDevice\#SOURCE_CLASS_POINTER, or a combination of sources bitwise ORed together.
  ///@return Whether the device can produce all of the given sources.
  bool supportsSource(int source) => jniAccessors.callMethodWithArgs(
      reference, _id_supportsSource, jni.JniType.booleanType, [source]).boolean;

  static final _id_getKeyboardType =
      jniAccessors.getMethodIDOf(_classRef, "getKeyboardType", "()I");

  /// from: public int getKeyboardType()
  ///
  /// Gets the keyboard type.
  ///@return The keyboard type.
  int getKeyboardType() => jniAccessors.callMethodWithArgs(
      reference, _id_getKeyboardType, jni.JniType.intType, []).integer;

  static final _id_getKeyCharacterMap = jniAccessors.getMethodIDOf(
      _classRef, "getKeyCharacterMap", "()Landroid/view/KeyCharacterMap;");

  /// from: public android.view.KeyCharacterMap getKeyCharacterMap()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the key character map associated with this input device.
  ///@return The key character map.
  keycharactermap_.KeyCharacterMap getKeyCharacterMap() =>
      keycharactermap_.KeyCharacterMap.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getKeyCharacterMap,
          jni.JniType.objectType, []).object);

  static final _id_hasKeys =
      jniAccessors.getMethodIDOf(_classRef, "hasKeys", "([I)[Z");

  /// from: public boolean[] hasKeys(int[] keys)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets whether the device is capable of producing the list of keycodes.
  ///@param keys The list of android keycodes to check for.
  ///@return An array of booleans where each member specifies whether the device is capable of
  /// generating the keycode given by the corresponding value at the same index in the keys array.
  jni.JniObject hasKeys(jni.JniObject keys) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_hasKeys, jni.JniType.objectType, [keys.reference]).object);

  static final _id_getMotionRange = jniAccessors.getMethodIDOf(_classRef,
      "getMotionRange", "(I)Landroid/view/InputDevice\$MotionRange;");

  /// from: public android.view.InputDevice.MotionRange getMotionRange(int axis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets information about the range of values for a particular MotionEvent axis.
  /// If the device supports multiple sources, the same axis may have different meanings
  /// for each source.  Returns information about the first axis found for any source.
  /// To obtain information about the axis for a specific source, use
  /// \#getMotionRange(int, int).
  ///@param axis The axis constant.
  ///@return The range of values, or null if the requested axis is not
  /// supported by the device.
  ///@see MotionEvent\#AXIS_X
  ///@see MotionEvent\#AXIS_Y
  InputDevice_MotionRange getMotionRange(int axis) =>
      InputDevice_MotionRange.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getMotionRange, jni.JniType.objectType, [axis]).object);

  static final _id_getMotionRange1 = jniAccessors.getMethodIDOf(_classRef,
      "getMotionRange", "(II)Landroid/view/InputDevice\$MotionRange;");

  /// from: public android.view.InputDevice.MotionRange getMotionRange(int axis, int source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets information about the range of values for a particular MotionEvent axis
  /// used by a particular source on the device.
  /// If the device supports multiple sources, the same axis may have different meanings
  /// for each source.
  ///@param axis The axis constant.
  ///@param source The source for which to return information.
  ///@return The range of values, or null if the requested axis is not
  /// supported by the device.
  ///@see MotionEvent\#AXIS_X
  ///@see MotionEvent\#AXIS_Y
  InputDevice_MotionRange getMotionRange1(int axis, int source) =>
      InputDevice_MotionRange.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getMotionRange1, jni.JniType.objectType, [axis, source]).object);

  static final _id_getMotionRanges = jniAccessors.getMethodIDOf(
      _classRef, "getMotionRanges", "()Ljava/util/List;");

  /// from: public java.util.List<android.view.InputDevice.MotionRange> getMotionRanges()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the ranges for all axes supported by the device.
  ///@return The motion ranges for the device.
  ///@see \#getMotionRange(int, int)
  jni.JniObject getMotionRanges() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMotionRanges, jni.JniType.objectType, []).object);

  static final _id_getVibrator = jniAccessors.getMethodIDOf(
      _classRef, "getVibrator", "()Landroid/os/Vibrator;");

  /// from: public android.os.Vibrator getVibrator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the vibrator service associated with the device, if there is one.
  /// Even if the device does not have a vibrator, the result is never null.
  /// Use Vibrator\#hasVibrator to determine whether a vibrator is
  /// present.
  ///
  /// Note that the vibrator associated with the device may be different from
  /// the system vibrator.  To obtain an instance of the system vibrator instead, call
  /// Context\#getSystemService with Context\#VIBRATOR_SERVICE as argument.
  ///@return The vibrator service associated with the device, never null.
  vibrator_.Vibrator getVibrator() =>
      vibrator_.Vibrator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getVibrator, jni.JniType.objectType, []).object);

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Returns true if input device is enabled.
  ///@return Whether the input device is enabled.
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_hasMicrophone =
      jniAccessors.getMethodIDOf(_classRef, "hasMicrophone", "()Z");

  /// from: public boolean hasMicrophone()
  ///
  /// Reports whether the device has a built-in microphone.
  ///@return Whether the device has a built-in microphone.
  bool hasMicrophone() => jniAccessors.callMethodWithArgs(
      reference, _id_hasMicrophone, jni.JniType.booleanType, []).boolean;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.view.InputDevice$MotionRange
///
/// Provides information about the range of values for a particular MotionEvent axis.
///@see InputDevice\#getMotionRange(int)
class InputDevice_MotionRange extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/InputDevice\$MotionRange");
  InputDevice_MotionRange.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIFFFFF)V");

  /// from: void <init>(int axis, int source, float min, float max, float flat, float fuzz, float resolution)
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputDevice_MotionRange(int axis, int source, double min, double max,
      double flat, double fuzz, double resolution)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [axis, source, min, max, flat, fuzz, resolution]).object);

  static final _id_getAxis =
      jniAccessors.getMethodIDOf(_classRef, "getAxis", "()I");

  /// from: public int getAxis()
  ///
  /// Gets the axis id.
  ///@return The axis id.
  int getAxis() => jniAccessors.callMethodWithArgs(
      reference, _id_getAxis, jni.JniType.intType, []).integer;

  static final _id_getSource =
      jniAccessors.getMethodIDOf(_classRef, "getSource", "()I");

  /// from: public int getSource()
  ///
  /// Gets the source for which the axis is defined.
  ///@return The source.
  int getSource() => jniAccessors.callMethodWithArgs(
      reference, _id_getSource, jni.JniType.intType, []).integer;

  static final _id_isFromSource =
      jniAccessors.getMethodIDOf(_classRef, "isFromSource", "(I)Z");

  /// from: public boolean isFromSource(int source)
  ///
  /// Determines whether the event is from the given source.
  ///@param source The input source to check against. This can be a specific device type,
  /// such as InputDevice\#SOURCE_TOUCH_NAVIGATION, or a more generic device class,
  /// such as InputDevice\#SOURCE_CLASS_POINTER.
  ///@return Whether the event is from the given source.
  bool isFromSource(int source) => jniAccessors.callMethodWithArgs(
      reference, _id_isFromSource, jni.JniType.booleanType, [source]).boolean;

  static final _id_getMin =
      jniAccessors.getMethodIDOf(_classRef, "getMin", "()F");

  /// from: public float getMin()
  ///
  /// Gets the inclusive minimum value for the axis.
  ///@return The inclusive minimum value.
  double getMin() => jniAccessors.callMethodWithArgs(
      reference, _id_getMin, jni.JniType.floatType, []).float;

  static final _id_getMax =
      jniAccessors.getMethodIDOf(_classRef, "getMax", "()F");

  /// from: public float getMax()
  ///
  /// Gets the inclusive maximum value for the axis.
  ///@return The inclusive maximum value.
  double getMax() => jniAccessors.callMethodWithArgs(
      reference, _id_getMax, jni.JniType.floatType, []).float;

  static final _id_getRange =
      jniAccessors.getMethodIDOf(_classRef, "getRange", "()F");

  /// from: public float getRange()
  ///
  /// Gets the range of the axis (difference between maximum and minimum).
  ///@return The range of values.
  double getRange() => jniAccessors.callMethodWithArgs(
      reference, _id_getRange, jni.JniType.floatType, []).float;

  static final _id_getFlat =
      jniAccessors.getMethodIDOf(_classRef, "getFlat", "()F");

  /// from: public float getFlat()
  ///
  /// Gets the extent of the center flat position with respect to this axis.
  ///
  /// For example, a flat value of 8 means that the center position is between -8 and +8.
  /// This value is mainly useful for calibrating self-centering devices.
  ///
  ///
  ///@return The extent of the center flat position.
  double getFlat() => jniAccessors.callMethodWithArgs(
      reference, _id_getFlat, jni.JniType.floatType, []).float;

  static final _id_getFuzz =
      jniAccessors.getMethodIDOf(_classRef, "getFuzz", "()F");

  /// from: public float getFuzz()
  ///
  /// Gets the error tolerance for input device measurements with respect to this axis.
  ///
  /// For example, a value of 2 indicates that the measured value may be up to +/- 2 units
  /// away from the actual value due to noise and device sensitivity limitations.
  ///
  ///
  ///@return The error tolerance.
  double getFuzz() => jniAccessors.callMethodWithArgs(
      reference, _id_getFuzz, jni.JniType.floatType, []).float;

  static final _id_getResolution =
      jniAccessors.getMethodIDOf(_classRef, "getResolution", "()F");

  /// from: public float getResolution()
  ///
  /// Gets the resolution for input device measurements with respect to this axis.
  ///@return The resolution in units per millimeter, or units per radian for rotational axes.
  double getResolution() => jniAccessors.callMethodWithArgs(
      reference, _id_getResolution, jni.JniType.floatType, []).float;
}
