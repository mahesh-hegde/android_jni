// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../graphics/SurfaceTexture.dart" as surfacetexture_;

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/Rect.dart" as rect_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.Surface
///
/// Handle onto a raw buffer that is being managed by the screen compositor.
///
/// A Surface is generally created by or from a consumer of image buffers (such as a
/// android.graphics.SurfaceTexture, android.media.MediaRecorder, or
/// android.renderscript.Allocation), and is handed to some kind of producer (such as
/// android.opengl.EGL14\#eglCreateWindowSurface(android.opengl.EGLDisplay,android.opengl.EGLConfig,java.lang.Object,int[],int) OpenGL,
/// android.media.MediaPlayer\#setSurface MediaPlayer, or
/// android.hardware.camera2.CameraDevice\#createCaptureSession CameraDevice) to draw
/// into.
///
///
/// <strong>Note:</strong> A Surface acts like a
/// java.lang.ref.WeakReference weak reference to the consumer it is associated with. By
/// itself it will not keep its parent consumer from being reclaimed.
///
class Surface extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/Surface");
  Surface.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.Surface> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int ROTATION_0
  ///
  /// Rotation constant: 0 degree rotation (natural orientation)
  static const ROTATION_0 = 0;

  /// from: static public final int ROTATION_180
  ///
  /// Rotation constant: 180 degree rotation.
  static const ROTATION_180 = 2;

  /// from: static public final int ROTATION_270
  ///
  /// Rotation constant: 270 degree rotation.
  static const ROTATION_270 = 3;

  /// from: static public final int ROTATION_90
  ///
  /// Rotation constant: 90 degree rotation.
  static const ROTATION_90 = 1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/SurfaceTexture;)V");

  /// from: public void <init>(android.graphics.SurfaceTexture surfaceTexture)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create Surface from a SurfaceTexture.
  ///
  /// Images drawn to the Surface will be made available to the SurfaceTexture, which can attach them to an OpenGL ES texture via SurfaceTexture\#updateTexImage.
  ///
  /// Please note that holding onto the Surface created here is not enough to
  /// keep the provided SurfaceTexture from being reclaimed.  In that sense,
  /// the Surface will act like a
  /// java.lang.ref.WeakReference weak reference to the SurfaceTexture.
  ///@param surfaceTexture The SurfaceTexture that is updated by this
  /// Surface.
  ///@throws OutOfResourcesException if the surface could not be created.
  Surface(surfacetexture_.SurfaceTexture surfaceTexture)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [surfaceTexture.reference]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Release the local reference to the server-side surface.
  /// Always call release() when you're done with a Surface.
  /// This will make the surface invalid.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_isValid =
      jniAccessors.getMethodIDOf(_classRef, "isValid", "()Z");

  /// from: public boolean isValid()
  ///
  /// Returns true if this object holds a valid surface.
  ///@return True if it holds a physical surface, so lockCanvas() will succeed.
  /// Otherwise returns false.
  bool isValid() => jniAccessors.callMethodWithArgs(
      reference, _id_isValid, jni.JniType.booleanType, []).boolean;

  static final _id_lockCanvas = jniAccessors.getMethodIDOf(_classRef,
      "lockCanvas", "(Landroid/graphics/Rect;)Landroid/graphics/Canvas;");

  /// from: public android.graphics.Canvas lockCanvas(android.graphics.Rect inOutDirty)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a Canvas for drawing into this surface.
  ///
  /// After drawing into the provided Canvas, the caller must
  /// invoke \#unlockCanvasAndPost to post the new contents to the surface.
  ///@param inOutDirty A rectangle that represents the dirty region that the caller wants
  /// to redraw.  This function may choose to expand the dirty rectangle if for example
  /// the surface has been resized or if the previous contents of the surface were
  /// not available.  The caller must redraw the entire dirty region as represented
  /// by the contents of the inOutDirty rectangle upon return from this function.
  /// The caller may also pass <code>null</code> instead, in the case where the
  /// entire surface should be redrawn.
  ///@return A canvas for drawing into the surface.
  ///@throws IllegalArgumentException If the inOutDirty rectangle is not valid.
  ///@throws OutOfResourcesException If the canvas cannot be locked.
  canvas_.Canvas lockCanvas(rect_.Rect inOutDirty) =>
      canvas_.Canvas.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_lockCanvas,
          jni.JniType.objectType,
          [inOutDirty.reference]).object);

  static final _id_unlockCanvasAndPost = jniAccessors.getMethodIDOf(
      _classRef, "unlockCanvasAndPost", "(Landroid/graphics/Canvas;)V");

  /// from: public void unlockCanvasAndPost(android.graphics.Canvas canvas)
  ///
  /// Posts the new contents of the Canvas to the surface and
  /// releases the Canvas.
  ///@param canvas The canvas previously obtained from \#lockCanvas.
  void unlockCanvasAndPost(canvas_.Canvas canvas) =>
      jniAccessors.callMethodWithArgs(reference, _id_unlockCanvasAndPost,
          jni.JniType.voidType, [canvas.reference]).check();

  static final _id_lockHardwareCanvas = jniAccessors.getMethodIDOf(
      _classRef, "lockHardwareCanvas", "()Landroid/graphics/Canvas;");

  /// from: public android.graphics.Canvas lockHardwareCanvas()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a Canvas for drawing into this surface.
  ///
  /// After drawing into the provided Canvas, the caller must
  /// invoke \#unlockCanvasAndPost to post the new contents to the surface.
  ///
  /// Unlike \#lockCanvas(Rect) this will return a hardware-accelerated
  /// canvas. See the <a href="{@docRoot}guide/topics/graphics/hardware-accel.html\#unsupported">
  /// unsupported drawing operations</a> for a list of what is and isn't
  /// supported in a hardware-accelerated canvas. It is also required to
  /// fully cover the surface every time \#lockHardwareCanvas() is
  /// called as the buffer is not preserved between frames. Partial updates
  /// are not supported.
  ///@return A canvas for drawing into the surface.
  ///@throws IllegalStateException If the canvas cannot be locked.
  canvas_.Canvas lockHardwareCanvas() =>
      canvas_.Canvas.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_lockHardwareCanvas, jni.JniType.objectType, []).object);

  static final _id_unlockCanvas = jniAccessors.getMethodIDOf(
      _classRef, "unlockCanvas", "(Landroid/graphics/Canvas;)V");

  /// from: public void unlockCanvas(android.graphics.Canvas canvas)
  ///
  /// @deprecated This API has been removed and is not supported.  Do not use.
  void unlockCanvas(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_unlockCanvas,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.view.Surface$OutOfResourcesException
///
/// Exception thrown when a Canvas couldn't be locked with Surface\#lockCanvas, or
/// when a SurfaceTexture could not successfully be allocated.
class Surface_OutOfResourcesException extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/Surface\$OutOfResourcesException");
  Surface_OutOfResourcesException.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Surface_OutOfResourcesException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Surface_OutOfResourcesException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);
}
