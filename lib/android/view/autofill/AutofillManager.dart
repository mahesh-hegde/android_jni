// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../View.dart" as view_;

import "../../graphics/Rect.dart" as rect_;

import "AutofillValue.dart" as autofillvalue_;

import "../../content/ComponentName.dart" as componentname_;

import "../../service/autofill/UserData.dart" as userdata_;

import "AutofillId.dart" as autofillid_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.autofill.AutofillManager
///
/// The AutofillManager provides ways for apps and custom views to integrate with the
/// Autofill Framework lifecycle.
///
/// The autofill lifecycle starts with the creation of an autofill context associated with an
/// activity context; the autofill context is created when one of the following methods is called for
/// the first time in an activity context, and the current user has an enabled autofill service:
///
/// <ul>
///   <li>\#notifyViewEntered(View)
///   <li>\#notifyViewEntered(View, int, Rect)
///   <li>\#requestAutofill(View)
/// </ul>
///
/// Tipically, the context is automatically created when the first view of the activity is
/// focused because {@code View.onFocusChanged()} indirectly calls
/// \#notifyViewEntered(View). App developers can call \#requestAutofill(View) to
/// explicitly create it (for example, a custom view developer could offer a contextual menu action
/// in a text-field view to let users manually request autofill).
///
/// After the context is created, the Android System creates a android.view.ViewStructure
/// that represents the view hierarchy by calling
/// View\#dispatchProvideAutofillStructure(android.view.ViewStructure, int) in the root views
/// of all application windows. By default, {@code dispatchProvideAutofillStructure()} results in
/// subsequent calls to View\#onProvideAutofillStructure(android.view.ViewStructure, int) and
/// View\#onProvideAutofillVirtualStructure(android.view.ViewStructure, int) for each view in
/// the hierarchy.
///
/// The resulting android.view.ViewStructure is then passed to the autofill service, which
/// parses it looking for views that can be autofilled. If the service finds such views, it returns
/// a data structure to the Android System containing the following optional info:
///
/// <ul>
///   <li>Datasets used to autofill subsets of views in the activity.
///   <li>Id of views that the service can save their values for future autofilling.
/// </ul>
///
/// When the service returns datasets, the Android System displays an autofill dataset picker
/// UI associated with the view, when the view is focused on and is part of a dataset.
/// The application can be notified when the UI is shown by registering an
/// AutofillCallback through \#registerCallback(AutofillCallback). When the user
/// selects a dataset from the UI, all views present in the dataset are autofilled, through
/// calls to View\#autofill(AutofillValue) or View\#autofill(SparseArray).
///
/// When the service returns ids of savable views, the Android System keeps track of changes
/// made to these views, so they can be used to determine if the autofill save UI is shown later.
///
/// The context is then finished when one of the following occurs:
///
/// <ul>
///   <li>\#commit() is called or all savable views are gone.
///   <li>\#cancel() is called.
/// </ul>
///
/// Finally, after the autofill context is commited (i.e., not cancelled), the Android System
/// shows an autofill save UI if the value of savable views have changed. If the user selects the
/// option to Save, the current value of the views is then sent to the autofill service.
///
/// It is safe to call into its methods from any thread.
///
/// Requires the android.content.pm.PackageManager\#FEATURE_AUTOFILL PackageManager\#FEATURE_AUTOFILL feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
class AutofillManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/autofill/AutofillManager");
  AutofillManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String EXTRA_ASSIST_STRUCTURE
  ///
  /// Intent extra: The assist structure which captures the filled screen.
  ///
  ///
  /// Type: android.app.assist.AssistStructure
  static const EXTRA_ASSIST_STRUCTURE =
      "android.view.autofill.extra.ASSIST_STRUCTURE";

  /// from: static public final java.lang.String EXTRA_AUTHENTICATION_RESULT
  ///
  /// Intent extra: The result of an authentication operation. It is
  /// either a fully populated android.service.autofill.FillResponse
  /// or a fully populated android.service.autofill.Dataset if
  /// a response or a dataset is being authenticated respectively.
  ///
  ///
  /// Type: android.service.autofill.FillResponse or a
  /// android.service.autofill.Dataset
  static const EXTRA_AUTHENTICATION_RESULT =
      "android.view.autofill.extra.AUTHENTICATION_RESULT";

  /// from: static public final java.lang.String EXTRA_CLIENT_STATE
  ///
  /// Intent extra: The optional extras provided by the
  /// android.service.autofill.AutofillService.
  ///
  /// For example, when the service responds to a android.service.autofill.FillCallback\#onSuccess(android.service.autofill.FillResponse) with
  /// a {@code FillResponse} that requires authentication, the Intent that launches the
  /// service authentication will contain the Bundle set by
  /// android.service.autofill.FillResponse.Builder\#setClientState(Bundle) on this extra.
  ///
  /// On Android android.os.Build.VERSION_CODES\#P and higher, the autofill service
  /// can also add this bundle to the Intent set as the
  /// android.app.Activity\#setResult(int, Intent) result for an authentication request,
  /// so the bundle can be recovered later on
  /// android.service.autofill.SaveRequest\#getClientState().
  ///
  ///
  /// Type: android.os.Bundle
  static const EXTRA_CLIENT_STATE = "android.view.autofill.extra.CLIENT_STATE";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AutofillManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Checks whether autofill is enabled for the current user.
  ///
  /// Typically used to determine whether the option to explicitly request autofill should
  /// be offered - see \#requestAutofill(View).
  ///@return whether autofill is enabled for the current user.
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_requestAutofill = jniAccessors.getMethodIDOf(
      _classRef, "requestAutofill", "(Landroid/view/View;)V");

  /// from: public void requestAutofill(android.view.View view)
  ///
  /// Explicitly requests a new autofill context.
  ///
  /// Normally, the autofill context is automatically started if necessary when
  /// \#notifyViewEntered(View) is called, but this method should be used in the
  /// cases where it must be explicitly started. For example, when the view offers an AUTOFILL
  /// option on its contextual overflow menu, and the user selects it.
  ///@param view view requesting the new autofill context.
  ///
  /// This value must never be {@code null}.
  void requestAutofill(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestAutofill,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_requestAutofill1 = jniAccessors.getMethodIDOf(_classRef,
      "requestAutofill", "(Landroid/view/View;ILandroid/graphics/Rect;)V");

  /// from: public void requestAutofill(android.view.View view, int virtualId, android.graphics.Rect absBounds)
  ///
  /// Explicitly requests a new autofill context for virtual views.
  ///
  /// Normally, the autofill context is automatically started if necessary when
  /// \#notifyViewEntered(View, int, Rect) is called, but this method should be used in the
  /// cases where it must be explicitly started. For example, when the virtual view offers an
  /// AUTOFILL option on its contextual overflow menu, and the user selects it.
  ///
  /// The virtual view boundaries must be absolute screen coordinates. For example, if the
  /// parent view uses {@code bounds} to draw the virtual view inside its Canvas,
  /// the absolute bounds could be calculated by:
  ///
  /// <pre class="prettyprint">
  ///   int offset[] = new int[2];
  ///   getLocationOnScreen(offset);
  ///   Rect absBounds = new Rect(bounds.left + offset[0],
  ///       bounds.top + offset[1],
  ///       bounds.right + offset[0], bounds.bottom + offset[1]);
  /// </pre>
  ///@param view the virtual view parent.
  /// This value must never be {@code null}.
  ///@param virtualId id identifying the virtual child inside the parent view.
  ///@param absBounds absolute boundaries of the virtual view in the screen.
  ///
  /// This value must never be {@code null}.
  void requestAutofill1(view_.View view, int virtualId, rect_.Rect absBounds) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestAutofill1,
          jni.JniType.voidType,
          [view.reference, virtualId, absBounds.reference]).check();

  static final _id_notifyViewEntered = jniAccessors.getMethodIDOf(
      _classRef, "notifyViewEntered", "(Landroid/view/View;)V");

  /// from: public void notifyViewEntered(android.view.View view)
  ///
  /// Called when a View that supports autofill is entered.
  ///@param view View that was entered.
  ///
  /// This value must never be {@code null}.
  void notifyViewEntered(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_notifyViewEntered,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_notifyViewExited = jniAccessors.getMethodIDOf(
      _classRef, "notifyViewExited", "(Landroid/view/View;)V");

  /// from: public void notifyViewExited(android.view.View view)
  ///
  /// Called when a View that supports autofill is exited.
  ///@param view View that was exited.
  ///
  /// This value must never be {@code null}.
  void notifyViewExited(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_notifyViewExited,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_notifyViewVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "notifyViewVisibilityChanged", "(Landroid/view/View;Z)V");

  /// from: public void notifyViewVisibilityChanged(android.view.View view, boolean isVisible)
  ///
  /// Called when a View view's visibility changed.
  ///@param view View that was exited.
  /// This value must never be {@code null}.
  ///@param isVisible visible if the view is visible in the view hierarchy.
  void notifyViewVisibilityChanged(view_.View view, bool isVisible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyViewVisibilityChanged,
          jni.JniType.voidType,
          [view.reference, isVisible]).check();

  static final _id_notifyViewVisibilityChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "notifyViewVisibilityChanged", "(Landroid/view/View;IZ)V");

  /// from: public void notifyViewVisibilityChanged(android.view.View view, int virtualId, boolean isVisible)
  ///
  /// Called when a virtual view's visibility changed.
  ///@param view View that was exited.
  /// This value must never be {@code null}.
  ///@param virtualId id identifying the virtual child inside the parent view.
  ///@param isVisible visible if the view is visible in the view hierarchy.
  void notifyViewVisibilityChanged1(
          view_.View view, int virtualId, bool isVisible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyViewVisibilityChanged1,
          jni.JniType.voidType,
          [view.reference, virtualId, isVisible]).check();

  static final _id_notifyViewEntered1 = jniAccessors.getMethodIDOf(_classRef,
      "notifyViewEntered", "(Landroid/view/View;ILandroid/graphics/Rect;)V");

  /// from: public void notifyViewEntered(android.view.View view, int virtualId, android.graphics.Rect absBounds)
  ///
  /// Called when a virtual view that supports autofill is entered.
  ///
  /// The virtual view boundaries must be absolute screen coordinates. For example, if the
  /// parent, non-virtual view uses {@code bounds} to draw the virtual view inside its Canvas,
  /// the absolute bounds could be calculated by:
  ///
  /// <pre class="prettyprint">
  ///   int offset[] = new int[2];
  ///   getLocationOnScreen(offset);
  ///   Rect absBounds = new Rect(bounds.left + offset[0],
  ///       bounds.top + offset[1],
  ///       bounds.right + offset[0], bounds.bottom + offset[1]);
  /// </pre>
  ///@param view the virtual view parent.
  /// This value must never be {@code null}.
  ///@param virtualId id identifying the virtual child inside the parent view.
  ///@param absBounds absolute boundaries of the virtual view in the screen.
  ///
  /// This value must never be {@code null}.
  void notifyViewEntered1(
          view_.View view, int virtualId, rect_.Rect absBounds) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyViewEntered1,
          jni.JniType.voidType,
          [view.reference, virtualId, absBounds.reference]).check();

  static final _id_notifyViewExited1 = jniAccessors.getMethodIDOf(
      _classRef, "notifyViewExited", "(Landroid/view/View;I)V");

  /// from: public void notifyViewExited(android.view.View view, int virtualId)
  ///
  /// Called when a virtual view that supports autofill is exited.
  ///@param view the virtual view parent.
  /// This value must never be {@code null}.
  ///@param virtualId id identifying the virtual child inside the parent view.
  void notifyViewExited1(view_.View view, int virtualId) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyViewExited1,
          jni.JniType.voidType, [view.reference, virtualId]).check();

  static final _id_notifyValueChanged = jniAccessors.getMethodIDOf(
      _classRef, "notifyValueChanged", "(Landroid/view/View;)V");

  /// from: public void notifyValueChanged(android.view.View view)
  ///
  /// Called to indicate the value of an autofillable View changed.
  ///@param view view whose value changed.
  void notifyValueChanged(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_notifyValueChanged,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_notifyValueChanged1 = jniAccessors.getMethodIDOf(
      _classRef,
      "notifyValueChanged",
      "(Landroid/view/View;ILandroid/view/autofill/AutofillValue;)V");

  /// from: public void notifyValueChanged(android.view.View view, int virtualId, android.view.autofill.AutofillValue value)
  ///
  /// Called to indicate the value of an autofillable virtual view has changed.
  ///@param view the virtual view parent.
  ///@param virtualId id identifying the virtual child inside the parent view.
  ///@param value new value of the child.
  void notifyValueChanged1(
          view_.View view, int virtualId, autofillvalue_.AutofillValue value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyValueChanged1,
          jni.JniType.voidType,
          [view.reference, virtualId, value.reference]).check();

  static final _id_notifyViewClicked = jniAccessors.getMethodIDOf(
      _classRef, "notifyViewClicked", "(Landroid/view/View;)V");

  /// from: public void notifyViewClicked(android.view.View view)
  ///
  /// Called to indicate a View is clicked.
  ///@param view view that has been clicked.
  ///
  /// This value must never be {@code null}.
  void notifyViewClicked(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_notifyViewClicked,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_notifyViewClicked1 = jniAccessors.getMethodIDOf(
      _classRef, "notifyViewClicked", "(Landroid/view/View;I)V");

  /// from: public void notifyViewClicked(android.view.View view, int virtualId)
  ///
  /// Called to indicate a virtual view has been clicked.
  ///@param view the virtual view parent.
  /// This value must never be {@code null}.
  ///@param virtualId id identifying the virtual child inside the parent view.
  void notifyViewClicked1(view_.View view, int virtualId) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyViewClicked1,
          jni.JniType.voidType, [view.reference, virtualId]).check();

  static final _id_commit =
      jniAccessors.getMethodIDOf(_classRef, "commit", "()V");

  /// from: public void commit()
  ///
  /// Called to indicate the current autofill context should be commited.
  ///
  /// This method is typically called by View Views that manage virtual views; for
  /// example, when the view is rendering an {@code HTML} page with a form and virtual views
  /// that represent the HTML elements, it should call this method after the form is submitted and
  /// another page is rendered.
  ///
  /// __Note:__ This method does not need to be called on regular application lifecycle
  /// methods such as android.app.Activity\#finish().
  void commit() => jniAccessors.callMethodWithArgs(
      reference, _id_commit, jni.JniType.voidType, []).check();

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "()V");

  /// from: public void cancel()
  ///
  /// Called to indicate the current autofill context should be cancelled.
  ///
  /// This method is typically called by View Views that manage virtual views; for
  /// example, when the view is rendering an {@code HTML} page with a form and virtual views
  /// that represent the HTML elements, it should call this method if the user does not post the
  /// form but moves to another form in this page.
  ///
  /// __Note:__ This method does not need to be called on regular application lifecycle
  /// methods such as android.app.Activity\#finish().
  void cancel() => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, []).check();

  static final _id_disableAutofillServices =
      jniAccessors.getMethodIDOf(_classRef, "disableAutofillServices", "()V");

  /// from: public void disableAutofillServices()
  ///
  /// If the app calling this API has enabled autofill services they
  /// will be disabled.
  void disableAutofillServices() => jniAccessors.callMethodWithArgs(
      reference, _id_disableAutofillServices, jni.JniType.voidType, []).check();

  static final _id_hasEnabledAutofillServices = jniAccessors.getMethodIDOf(
      _classRef, "hasEnabledAutofillServices", "()Z");

  /// from: public boolean hasEnabledAutofillServices()
  ///
  /// Returns {@code true} if the calling application provides a AutofillService that is
  /// enabled for the current user, or {@code false} otherwise.
  bool hasEnabledAutofillServices() => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasEnabledAutofillServices,
      jni.JniType.booleanType, []).boolean;

  static final _id_getAutofillServiceComponentName = jniAccessors.getMethodIDOf(
      _classRef,
      "getAutofillServiceComponentName",
      "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getAutofillServiceComponentName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the component name of the AutofillService that is enabled for the current
  /// user.
  ///@return This value may be {@code null}.
  componentname_.ComponentName getAutofillServiceComponentName() =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAutofillServiceComponentName,
          jni.JniType.objectType, []).object);

  static final _id_getUserDataId = jniAccessors.getMethodIDOf(
      _classRef, "getUserDataId", "()Ljava/lang/String;");

  /// from: public java.lang.String getUserDataId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the id of the UserData used for
  /// <a href="AutofillService.html\#FieldClassification">field classification</a>.
  ///
  /// This method is useful when the service must check the status of the UserData in
  /// the device without fetching the whole object.
  ///
  /// __Note:__ This method should only be called by an app providing an autofill service,
  /// and it's ignored if the caller currently doesn't have an enabled autofill service for
  /// the user.
  ///@return id of the UserData previously set by \#setUserData(UserData)
  /// or {@code null} if it was reset or if the caller currently does not have an enabled autofill
  /// service for the user.
  jni.JniString getUserDataId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUserDataId, jni.JniType.objectType, []).object);

  static final _id_getUserData = jniAccessors.getMethodIDOf(
      _classRef, "getUserData", "()Landroid/service/autofill/UserData;");

  /// from: public android.service.autofill.UserData getUserData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the user data used for
  /// <a href="AutofillService.html\#FieldClassification">field classification</a>.
  ///
  /// __Note:__ This method should only be called by an app providing an autofill service,
  /// and it's ignored if the caller currently doesn't have an enabled autofill service for
  /// the user.
  ///@return value previously set by \#setUserData(UserData) or {@code null} if it was
  /// reset or if the caller currently does not have an enabled autofill service for the user.
  userdata_.UserData getUserData() =>
      userdata_.UserData.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUserData, jni.JniType.objectType, []).object);

  static final _id_setUserData = jniAccessors.getMethodIDOf(
      _classRef, "setUserData", "(Landroid/service/autofill/UserData;)V");

  /// from: public void setUserData(android.service.autofill.UserData userData)
  ///
  /// Sets the UserData used for
  /// <a href="AutofillService.html\#FieldClassification">field classification</a>
  ///
  /// __Note:__ This method should only be called by an app providing an autofill service,
  /// and it's ignored if the caller currently doesn't have an enabled autofill service for
  /// the user.
  ///@param userData This value may be {@code null}.
  void setUserData(userdata_.UserData userData) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUserData,
          jni.JniType.voidType, [userData.reference]).check();

  static final _id_isFieldClassificationEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isFieldClassificationEnabled", "()Z");

  /// from: public boolean isFieldClassificationEnabled()
  ///
  /// Checks if <a href="AutofillService.html\#FieldClassification">field classification</a> is
  /// enabled.
  ///
  /// As field classification is an expensive operation, it could be disabled, either
  /// temporarily (for example, because the service exceeded a rate-limit threshold) or
  /// permanently (for example, because the device is a low-level device).
  ///
  /// __Note:__ This method should only be called by an app providing an autofill service,
  /// and it's ignored if the caller currently doesn't have an enabled autofill service for
  /// the user.
  bool isFieldClassificationEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isFieldClassificationEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_getDefaultFieldClassificationAlgorithm =
      jniAccessors.getMethodIDOf(_classRef,
          "getDefaultFieldClassificationAlgorithm", "()Ljava/lang/String;");

  /// from: public java.lang.String getDefaultFieldClassificationAlgorithm()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the name of the default algorithm used for
  /// <a href="AutofillService.html\#FieldClassification">field classification</a>.
  ///
  /// The default algorithm is used when the algorithm on UserData is invalid or not
  /// set.
  ///
  /// __Note:__ This method should only be called by an app providing an autofill service,
  /// and it's ignored if the caller currently doesn't have an enabled autofill service for
  /// the user.
  ///@return This value may be {@code null}.
  jni.JniString getDefaultFieldClassificationAlgorithm() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDefaultFieldClassificationAlgorithm,
          jni.JniType.objectType, []).object);

  static final _id_getAvailableFieldClassificationAlgorithms =
      jniAccessors.getMethodIDOf(_classRef,
          "getAvailableFieldClassificationAlgorithms", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getAvailableFieldClassificationAlgorithms()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the name of all algorithms currently available for
  /// <a href="AutofillService.html\#FieldClassification">field classification</a>.
  ///
  /// __Note:__ This method should only be called by an app providing an autofill service,
  /// and it returns an empty list if the caller currently doesn't have an enabled autofill service
  /// for the user.
  ///@return This value will never be {@code null}.
  jni.JniObject getAvailableFieldClassificationAlgorithms() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAvailableFieldClassificationAlgorithms,
          jni.JniType.objectType, []).object);

  static final _id_isAutofillSupported =
      jniAccessors.getMethodIDOf(_classRef, "isAutofillSupported", "()Z");

  /// from: public boolean isAutofillSupported()
  ///
  /// Returns {@code true} if autofill is supported by the current device and
  /// is supported for this user.
  ///
  /// Autofill is typically supported, but it could be unsupported in cases like:
  /// <ol>
  ///     <li>Low-end devices.
  ///     <li>Device policy rules that forbid its usage.
  /// </ol>
  bool isAutofillSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_isAutofillSupported, jni.JniType.booleanType, []).boolean;

  static final _id_getNextAutofillId = jniAccessors.getMethodIDOf(
      _classRef, "getNextAutofillId", "()Landroid/view/autofill/AutofillId;");

  /// from: public android.view.autofill.AutofillId getNextAutofillId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the next unique autofill ID for the activity context.
  ///
  /// Typically used to manage views whose content is recycled - see
  /// View\#setAutofillId(AutofillId) for more info.
  ///@return An ID that is unique in the activity, or {@code null} if autofill is not supported in
  /// the Context associated with this AutofillManager.
  autofillid_.AutofillId getNextAutofillId() =>
      autofillid_.AutofillId.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNextAutofillId, jni.JniType.objectType, []).object);

  static final _id_registerCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerCallback",
      "(Landroid/view/autofill/AutofillManager\$AutofillCallback;)V");

  /// from: public void registerCallback(android.view.autofill.AutofillManager.AutofillCallback callback)
  ///
  /// Registers a AutofillCallback to receive autofill events.
  ///@param callback callback to receive events.
  ///
  /// This value may be {@code null}.
  void registerCallback(AutofillManager_AutofillCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_unregisterCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterCallback",
      "(Landroid/view/autofill/AutofillManager\$AutofillCallback;)V");

  /// from: public void unregisterCallback(android.view.autofill.AutofillManager.AutofillCallback callback)
  ///
  /// Unregisters a AutofillCallback to receive autofill events.
  ///@param callback callback to stop receiving events.
  ///
  /// This value may be {@code null}.
  void unregisterCallback(AutofillManager_AutofillCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterCallback,
          jni.JniType.voidType, [callback.reference]).check();
}

/// from: android.view.autofill.AutofillManager$AutofillCallback
///
/// Callback for autofill related events.
///
/// Typically used for applications that display their own "auto-complete" views, so they can
/// enable / disable such views when the autofill UI is shown / hidden.
class AutofillManager_AutofillCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/autofill/AutofillManager\$AutofillCallback");
  AutofillManager_AutofillCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int EVENT_INPUT_HIDDEN
  ///
  /// The autofill input UI associated with the view was hidden.
  ///
  /// If the view provides its own auto-complete UI that was hidden upon a
  /// \#EVENT_INPUT_SHOWN event, it could be shown again now.
  static const EVENT_INPUT_HIDDEN = 2;

  /// from: static public final int EVENT_INPUT_SHOWN
  ///
  /// The autofill input UI associated with the view was shown.
  ///
  /// If the view provides its own auto-complete UI and its currently shown, it
  /// should be hidden upon receiving this event.
  static const EVENT_INPUT_SHOWN = 1;

  /// from: static public final int EVENT_INPUT_UNAVAILABLE
  ///
  /// The autofill input UI associated with the view isn't shown because
  /// autofill is not available.
  ///
  /// If the view provides its own auto-complete UI but was not displaying it
  /// to avoid flickering, it could shown it upon receiving this event.
  static const EVENT_INPUT_UNAVAILABLE = 3;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AutofillManager_AutofillCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onAutofillEvent = jniAccessors.getMethodIDOf(
      _classRef, "onAutofillEvent", "(Landroid/view/View;I)V");

  /// from: public void onAutofillEvent(android.view.View view, int event)
  ///
  /// Called after a change in the autofill state associated with a view.
  ///@param view view associated with the change.
  ///
  /// This value must never be {@code null}.
  ///@param event currently either \#EVENT_INPUT_SHOWN or \#EVENT_INPUT_HIDDEN.
  ///
  /// Value is android.view.autofill.AutofillManager.AutofillCallback\#EVENT_INPUT_SHOWN, android.view.autofill.AutofillManager.AutofillCallback\#EVENT_INPUT_HIDDEN, or android.view.autofill.AutofillManager.AutofillCallback\#EVENT_INPUT_UNAVAILABLE
  void onAutofillEvent(view_.View view, int event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAutofillEvent,
          jni.JniType.voidType, [view.reference, event]).check();

  static final _id_onAutofillEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onAutofillEvent", "(Landroid/view/View;II)V");

  /// from: public void onAutofillEvent(android.view.View view, int virtualId, int event)
  ///
  /// Called after a change in the autofill state associated with a virtual view.
  ///@param view parent view associated with the change.
  /// This value must never be {@code null}.
  ///@param virtualId id identifying the virtual child inside the parent view.
  ///@param event currently either \#EVENT_INPUT_SHOWN or \#EVENT_INPUT_HIDDEN.
  ///
  /// Value is android.view.autofill.AutofillManager.AutofillCallback\#EVENT_INPUT_SHOWN, android.view.autofill.AutofillManager.AutofillCallback\#EVENT_INPUT_HIDDEN, or android.view.autofill.AutofillManager.AutofillCallback\#EVENT_INPUT_UNAVAILABLE
  void onAutofillEvent1(view_.View view, int virtualId, int event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAutofillEvent1,
          jni.JniType.voidType, [view.reference, virtualId, event]).check();
}
