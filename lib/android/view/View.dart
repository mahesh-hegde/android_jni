// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../util/Property.dart" as property_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "ActionMode.dart" as actionmode_;

import "../graphics/Rect.dart" as rect_;

import "accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "accessibility/AccessibilityNodeInfo.dart" as accessibilitynodeinfo_;

import "ViewStructure.dart" as viewstructure_;

import "autofill/AutofillValue.dart" as autofillvalue_;

import "../util/SparseArray.dart" as sparsearray_;

import "autofill/AutofillId.dart" as autofillid_;

import "../os/Bundle.dart" as bundle_;

import "accessibility/AccessibilityNodeProvider.dart"
    as accessibilitynodeprovider_;

import "WindowInsets.dart" as windowinsets_;

import "ViewParent.dart" as viewparent_;

import "KeyEvent.dart" as keyevent_;

import "MotionEvent.dart" as motionevent_;

import "../content/res/Configuration.dart" as configuration_;

import "inputmethod/InputConnection.dart" as inputconnection_;

import "inputmethod/EditorInfo.dart" as editorinfo_;

import "ContextMenu.dart" as contextmenu_;

import "TouchDelegate.dart" as touchdelegate_;

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/Matrix.dart" as matrix_;

import "../animation/StateListAnimator.dart" as statelistanimator_;

import "ViewOutlineProvider.dart" as viewoutlineprovider_;

import "../graphics/Point.dart" as point_;

import "ViewGroup.dart" as viewgroup_;

import "../os/Handler.dart" as handler_;

import "../os/IBinder.dart" as ibinder_;

import "WindowId.dart" as windowid_;

import "Display.dart" as display_;

import "../os/Parcelable.dart" as parcelable_;

import "../graphics/Paint.dart" as paint_;

import "../graphics/Bitmap.dart" as bitmap_;

import "ViewOverlay.dart" as viewoverlay_;

import "../content/res/Resources.dart" as resources_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../content/res/ColorStateList.dart" as colorstatelist_;

import "../graphics/PorterDuff.dart" as porterduff_;

import "ViewTreeObserver.dart" as viewtreeobserver_;

import "animation/Animation.dart" as animation_;

import "../content/ClipData.dart" as clipdata_;

import "DragEvent.dart" as dragevent_;

import "PointerIcon.dart" as pointericon_;

import "ViewPropertyAnimator.dart" as viewpropertyanimator_;

import "AbsSavedState.dart" as abssavedstate_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.View
///
///
/// This class represents the basic building block for user interface components. A View
/// occupies a rectangular area on the screen and is responsible for drawing and
/// event handling. View is the base class for _widgets_, which are
/// used to create interactive UI components (buttons, text fields, etc.). The
/// android.view.ViewGroup subclass is the base class for _layouts_, which
/// are invisible containers that hold other Views (or other ViewGroups) and define
/// their layout properties.
///
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about using this class to develop your application's user interface,
/// read the <a href="{@docRoot}guide/topics/ui/index.html">User Interface</a> developer guide.
/// </div>
///
/// <a name="Using"></a>
/// <h3>Using Views</h3>
///
/// All of the views in a window are arranged in a single tree. You can add views
/// either from code or by specifying a tree of views in one or more XML layout
/// files. There are many specialized subclasses of views that act as controls or
/// are capable of displaying text, images, or other content.
///
///
///
/// Once you have created a tree of views, there are typically a few types of
/// common operations you may wish to perform:
/// <ul>
/// <li><strong>Set properties:</strong> for example setting the text of a
/// android.widget.TextView. The available properties and the methods
/// that set them will vary among the different subclasses of views. Note that
/// properties that are known at build time can be set in the XML layout
/// files.</li>
/// <li><strong>Set focus:</strong> The framework will handle moving focus in
/// response to user input. To force focus to a specific view, call
/// \#requestFocus.</li>
/// <li><strong>Set up listeners:</strong> Views allow clients to set listeners
/// that will be notified when something interesting happens to the view. For
/// example, all views will let you set a listener to be notified when the view
/// gains or loses focus. You can register such a listener using
/// \#setOnFocusChangeListener(android.view.View.OnFocusChangeListener).
/// Other view subclasses offer more specialized listeners. For example, a Button
/// exposes a listener to notify clients when the button is clicked.</li>
/// <li><strong>Set visibility:</strong> You can hide or show views using
/// \#setVisibility(int).</li>
/// </ul>
///
///
/// _
/// Note: The Android framework is responsible for measuring, laying out and
/// drawing views. You should not call methods that perform these actions on
/// views yourself unless you are actually implementing a
/// android.view.ViewGroup.
/// _
///
///
/// <a name="Lifecycle"></a>
/// <h3>Implementing a Custom View</h3>
///
///
/// To implement a custom view, you will usually begin by providing overrides for
/// some of the standard methods that the framework calls on all views. You do
/// not need to override all of these methods. In fact, you can start by just
/// overriding \#onDraw(android.graphics.Canvas).
/// <table border="2"width="85%"align="center"cellpadding="5">
///     <thead>
///         <tr><th>Category</th> <th>Methods</th> <th>Description</th></tr>
///     </thead>
///
///     <tbody>
///     <tr>
///         <td rowspan="2">Creation</td>
///         <td>Constructors</td>
///         <td>There is a form of the constructor that are called when the view
///         is created from code and a form that is called when the view is
///         inflated from a layout file. The second form should parse and apply
///         any attributes defined in the layout file.
///         </td>
///     </tr>
///     <tr>
///         <td><code>\#onFinishInflate()</code></td>
///         <td>Called after a view and all of its children has been inflated
///         from XML.</td>
///     </tr>
///
///     <tr>
///         <td rowspan="3">Layout</td>
///         <td><code>\#onMeasure(int, int)</code></td>
///         <td>Called to determine the size requirements for this view and all
///         of its children.
///         </td>
///     </tr>
///     <tr>
///         <td><code>\#onLayout(boolean, int, int, int, int)</code></td>
///         <td>Called when this view should assign a size and position to all
///         of its children.
///         </td>
///     </tr>
///     <tr>
///         <td><code>\#onSizeChanged(int, int, int, int)</code></td>
///         <td>Called when the size of this view has changed.
///         </td>
///     </tr>
///
///     <tr>
///         <td>Drawing</td>
///         <td><code>\#onDraw(android.graphics.Canvas)</code></td>
///         <td>Called when the view should render its content.
///         </td>
///     </tr>
///
///     <tr>
///         <td rowspan="4">Event processing</td>
///         <td><code>\#onKeyDown(int, KeyEvent)</code></td>
///         <td>Called when a new hardware key event occurs.
///         </td>
///     </tr>
///     <tr>
///         <td><code>\#onKeyUp(int, KeyEvent)</code></td>
///         <td>Called when a hardware key up event occurs.
///         </td>
///     </tr>
///     <tr>
///         <td><code>\#onTrackballEvent(MotionEvent)</code></td>
///         <td>Called when a trackball motion event occurs.
///         </td>
///     </tr>
///     <tr>
///         <td><code>\#onTouchEvent(MotionEvent)</code></td>
///         <td>Called when a touch screen motion event occurs.
///         </td>
///     </tr>
///
///     <tr>
///         <td rowspan="2">Focus</td>
///         <td><code>\#onFocusChanged(boolean, int, android.graphics.Rect)</code></td>
///         <td>Called when the view gains or loses focus.
///         </td>
///     </tr>
///
///     <tr>
///         <td><code>\#onWindowFocusChanged(boolean)</code></td>
///         <td>Called when the window containing the view gains or loses focus.
///         </td>
///     </tr>
///
///     <tr>
///         <td rowspan="3">Attaching</td>
///         <td><code>\#onAttachedToWindow()</code></td>
///         <td>Called when the view is attached to a window.
///         </td>
///     </tr>
///
///     <tr>
///         <td><code>\#onDetachedFromWindow</code></td>
///         <td>Called when the view is detached from its window.
///         </td>
///     </tr>
///
///     <tr>
///         <td><code>\#onWindowVisibilityChanged(int)</code></td>
///         <td>Called when the visibility of the window containing the view
///         has changed.
///         </td>
///     </tr>
///     </tbody>
///
/// </table>
///
///
///
/// <a name="IDs"></a>
/// <h3>IDs</h3>
/// Views may have an integer id associated with them. These ids are typically
/// assigned in the layout XML files, and are used to find specific views within
/// the view tree. A common pattern is to:
/// <ul>
/// <li>Define a Button in the layout file and assign it a unique ID.
/// <pre>
/// &lt;Button
///     android:id="@+id/my_button"
///     android:layout_width="wrap_content"
///     android:layout_height="wrap_content"
///     android:text="@string/my_button_text"/&gt;
/// </pre></li>
/// <li>From the onCreate method of an Activity, find the Button
/// <pre class="prettyprint">
///      Button myButton = findViewById(R.id.my_button);
/// </pre></li>
/// </ul>
///
/// View IDs need not be unique throughout the tree, but it is good practice to
/// ensure that they are at least unique within the part of the tree you are
/// searching.
///
///
///
/// <a name="Position"></a>
/// <h3>Position</h3>
///
/// The geometry of a view is that of a rectangle. A view has a location,
/// expressed as a pair of _left_ and _top_ coordinates, and
/// two dimensions, expressed as a width and a height. The unit for location
/// and dimensions is the pixel.
///
///
///
///
/// It is possible to retrieve the location of a view by invoking the methods
/// \#getLeft() and \#getTop(). The former returns the left, or X,
/// coordinate of the rectangle representing the view. The latter returns the
/// top, or Y, coordinate of the rectangle representing the view. These methods
/// both return the location of the view relative to its parent. For instance,
/// when getLeft() returns 20, that means the view is located 20 pixels to the
/// right of the left edge of its direct parent.
///
///
///
///
/// In addition, several convenience methods are offered to avoid unnecessary
/// computations, namely \#getRight() and \#getBottom().
/// These methods return the coordinates of the right and bottom edges of the
/// rectangle representing the view. For instance, calling \#getRight()
/// is similar to the following computation: <code>getLeft() + getWidth()</code>
/// (see <a href="\#SizePaddingMargins">Size</a> for more information about the width.)
///
///
///
/// <a name="SizePaddingMargins"></a>
/// <h3>Size, padding and margins</h3>
///
/// The size of a view is expressed with a width and a height. A view actually
/// possess two pairs of width and height values.
///
///
///
///
/// The first pair is known as _measured width_ and
/// _measured height_. These dimensions define how big a view wants to be
/// within its parent (see <a href="\#Layout">Layout</a> for more details.) The
/// measured dimensions can be obtained by calling \#getMeasuredWidth()
/// and \#getMeasuredHeight().
///
///
///
///
/// The second pair is simply known as _width_ and _height_, or
/// sometimes _drawing width_ and _drawing height_. These
/// dimensions define the actual size of the view on screen, at drawing time and
/// after layout. These values may, but do not have to, be different from the
/// measured width and height. The width and height can be obtained by calling
/// \#getWidth() and \#getHeight().
///
///
///
///
/// To measure its dimensions, a view takes into account its padding. The padding
/// is expressed in pixels for the left, top, right and bottom parts of the view.
/// Padding can be used to offset the content of the view by a specific amount of
/// pixels. For instance, a left padding of 2 will push the view's content by
/// 2 pixels to the right of the left edge. Padding can be set using the
/// \#setPadding(int, int, int, int) or \#setPaddingRelative(int, int, int, int)
/// method and queried by calling \#getPaddingLeft(), \#getPaddingTop(),
/// \#getPaddingRight(), \#getPaddingBottom(), \#getPaddingStart(),
/// \#getPaddingEnd().
///
///
///
///
/// Even though a view can define a padding, it does not provide any support for
/// margins. However, view groups provide such a support. Refer to
/// android.view.ViewGroup and
/// android.view.ViewGroup.MarginLayoutParams for further information.
///
///
///
/// <a name="Layout"></a>
/// <h3>Layout</h3>
///
/// Layout is a two pass process: a measure pass and a layout pass. The measuring
/// pass is implemented in \#measure(int, int) and is a top-down traversal
/// of the view tree. Each view pushes dimension specifications down the tree
/// during the recursion. At the end of the measure pass, every view has stored
/// its measurements. The second pass happens in
/// \#layout(int,int,int,int) and is also top-down. During
/// this pass each parent is responsible for positioning all of its children
/// using the sizes computed in the measure pass.
///
///
///
///
/// When a view's measure() method returns, its \#getMeasuredWidth() and
/// \#getMeasuredHeight() values must be set, along with those for all of
/// that view's descendants. A view's measured width and measured height values
/// must respect the constraints imposed by the view's parents. This guarantees
/// that at the end of the measure pass, all parents accept all of their
/// children's measurements. A parent view may call measure() more than once on
/// its children. For example, the parent may measure each child once with
/// unspecified dimensions to find out how big they want to be, then call
/// measure() on them again with actual numbers if the sum of all the children's
/// unconstrained sizes is too big or too small.
///
///
///
///
/// The measure pass uses two classes to communicate dimensions. The
/// MeasureSpec class is used by views to tell their parents how they
/// want to be measured and positioned. The base LayoutParams class just
/// describes how big the view wants to be for both width and height. For each
/// dimension, it can specify one of:
/// <ul>
/// <li> an exact number
/// <li>MATCH_PARENT, which means the view wants to be as big as its parent
/// (minus padding)
/// <li> WRAP_CONTENT, which means that the view wants to be just big enough to
/// enclose its content (plus padding).
/// </ul>
/// There are subclasses of LayoutParams for different subclasses of ViewGroup.
/// For example, AbsoluteLayout has its own subclass of LayoutParams which adds
/// an X and Y value.
///
///
///
///
/// MeasureSpecs are used to push requirements down the tree from parent to
/// child. A MeasureSpec can be in one of three modes:
/// <ul>
/// <li>UNSPECIFIED: This is used by a parent to determine the desired dimension
/// of a child view. For example, a LinearLayout may call measure() on its child
/// with the height set to UNSPECIFIED and a width of EXACTLY 240 to find out how
/// tall the child view wants to be given a width of 240 pixels.
/// <li>EXACTLY: This is used by the parent to impose an exact size on the
/// child. The child must use this size, and guarantee that all of its
/// descendants will fit within this size.
/// <li>AT_MOST: This is used by the parent to impose a maximum size on the
/// child. The child must guarantee that it and all of its descendants will fit
/// within this size.
/// </ul>
///
///
///
///
/// To initiate a layout, call \#requestLayout. This method is typically
/// called by a view on itself when it believes that is can no longer fit within
/// its current bounds.
///
///
///
/// <a name="Drawing"></a>
/// <h3>Drawing</h3>
///
/// Drawing is handled by walking the tree and recording the drawing commands of
/// any View that needs to update. After this, the drawing commands of the
/// entire tree are issued to screen, clipped to the newly damaged area.
///
///
///
///
/// The tree is largely recorded and drawn in order, with parents drawn before
/// (i.e., behind) their children, with siblings drawn in the order they appear
/// in the tree. If you set a background drawable for a View, then the View will
/// draw it before calling back to its <code>onDraw()</code> method. The child
/// drawing order can be overridden with
/// ViewGroup\#setChildrenDrawingOrderEnabled(boolean) custom child drawing order
/// in a ViewGroup, and with \#setZ(float) custom Z values} set on Views.
///
///
///
///
/// To force a view to draw, call \#invalidate().
///
///
///
/// <a name="EventHandlingThreading"></a>
/// <h3>Event Handling and Threading</h3>
///
/// The basic cycle of a view is as follows:
/// <ol>
/// <li>An event comes in and is dispatched to the appropriate view. The view
/// handles the event and notifies any listeners.</li>
/// <li>If in the course of processing the event, the view's bounds may need
/// to be changed, the view will call \#requestLayout().</li>
/// <li>Similarly, if in the course of processing the event the view's appearance
/// may need to be changed, the view will call \#invalidate().</li>
/// <li>If either \#requestLayout() or \#invalidate() were called,
/// the framework will take care of measuring, laying out, and drawing the tree
/// as appropriate.</li>
/// </ol>
///
///
///
/// _Note: The entire view tree is single threaded. You must always be on
/// the UI thread when calling any method on any view._
/// If you are doing work on other threads and want to update the state of a view
/// from that thread, you should use a Handler.
///
///
///
/// <a name="FocusHandling"></a>
/// <h3>Focus Handling</h3>
///
/// The framework will handle routine focus movement in response to user input.
/// This includes changing the focus as views are removed or hidden, or as new
/// views become available. Views indicate their willingness to take focus
/// through the \#isFocusable method. To change whether a view can take
/// focus, call \#setFocusable(boolean).  When in touch mode (see notes below)
/// views indicate whether they still would like focus via \#isFocusableInTouchMode
/// and can change this via \#setFocusableInTouchMode(boolean).
///
///
///
/// Focus movement is based on an algorithm which finds the nearest neighbor in a
/// given direction. In rare cases, the default algorithm may not match the
/// intended behavior of the developer. In these situations, you can provide
/// explicit overrides by using these XML attributes in the layout file:
/// <pre>
/// nextFocusDown
/// nextFocusLeft
/// nextFocusRight
/// nextFocusUp
/// </pre>
///
///
///
///
///
/// To get a particular view to take focus, call \#requestFocus().
///
///
///
/// <a name="TouchMode"></a>
/// <h3>Touch Mode</h3>
///
/// When a user is navigating a user interface via directional keys such as a D-pad, it is
/// necessary to give focus to actionable items such as buttons so the user can see
/// what will take input.  If the device has touch capabilities, however, and the user
/// begins interacting with the interface by touching it, it is no longer necessary to
/// always highlight, or give focus to, a particular view.  This motivates a mode
/// for interaction named 'touch mode'.
///
///
///
/// For a touch capable device, once the user touches the screen, the device
/// will enter touch mode.  From this point onward, only views for which
/// \#isFocusableInTouchMode is true will be focusable, such as text editing widgets.
/// Other views that are touchable, like buttons, will not take focus when touched; they will
/// only fire the on click listeners.
///
///
///
/// Any time a user hits a directional key, such as a D-pad direction, the view device will
/// exit touch mode, and find a view to take focus, so that the user may resume interacting
/// with the user interface without touching the screen again.
///
///
///
/// The touch mode state is maintained across android.app.Activitys.  Call
/// \#isInTouchMode to see whether the device is currently in touch mode.
///
///
///
/// <a name="Scrolling"></a>
/// <h3>Scrolling</h3>
///
/// The framework provides basic support for views that wish to internally
/// scroll their content. This includes keeping track of the X and Y scroll
/// offset as well as mechanisms for drawing scrollbars. See
/// \#scrollBy(int, int), \#scrollTo(int, int), and
/// \#awakenScrollBars() for more details.
///
///
///
/// <a name="Tags"></a>
/// <h3>Tags</h3>
///
/// Unlike IDs, tags are not used to identify views. Tags are essentially an
/// extra piece of information that can be associated with a view. They are most
/// often used as a convenience to store data related to views in the views
/// themselves rather than by putting them in a separate structure.
///
///
///
/// Tags may be specified with character sequence values in layout XML as either
/// a single tag using the android.R.styleable\#View_tag android:tag
/// attribute or multiple tags using the {@code <tag>} child element:
/// <pre>
///     &lt;View ...
///           android:tag="@string/mytag_value" /&gt;
///     &lt;View ...&gt;
///         &lt;tag android:id="@+id/mytag"
///              android:value="@string/mytag_value" /&gt;
///     &lt;/View>
/// </pre>
///
///
///
/// Tags may also be specified with arbitrary objects from code using
/// \#setTag(Object) or \#setTag(int, Object).
///
///
///
/// <a name="Themes"></a>
/// <h3>Themes</h3>
///
/// By default, Views are created using the theme of the Context object supplied
/// to their constructor; however, a different theme may be specified by using
/// the android.R.styleable\#View_theme android:theme attribute in layout
/// XML or by passing a ContextThemeWrapper to the constructor from
/// code.
///
///
///
/// When the android.R.styleable\#View_theme android:theme attribute is
/// used in XML, the specified theme is applied on top of the inflation
/// context's theme (see LayoutInflater) and used for the view itself as
/// well as any child elements.
///
///
///
/// In the following example, both views will be created using the Material dark
/// color scheme; however, because an overlay theme is used which only defines a
/// subset of attributes, the value of
/// android.R.styleable\#Theme_colorAccent android:colorAccent defined on
/// the inflation context's theme (e.g. the Activity theme) will be preserved.
/// <pre>
///     &lt;LinearLayout
///             ...
///             android:theme="@android:theme/ThemeOverlay.Material.Dark"&gt;
///         &lt;View ...&gt;
///     &lt;/LinearLayout&gt;
/// </pre>
///
///
///
/// <a name="Properties"></a>
/// <h3>Properties</h3>
///
/// The View class exposes an \#ALPHA property, as well as several transform-related
/// properties, such as \#TRANSLATION_X and \#TRANSLATION_Y. These properties are
/// available both in the Property form as well as in similarly-named setter/getter
/// methods (such as \#setAlpha(float) for \#ALPHA). These properties can
/// be used to set persistent state associated with these rendering-related properties on the view.
/// The properties and methods can also be used in conjunction with
/// android.animation.Animator Animator-based animations, described more in the
/// <a href="\#Animation">Animation</a> section.
///
///
///
/// <a name="Animation"></a>
/// <h3>Animation</h3>
///
/// Starting with Android 3.0, the preferred way of animating views is to use the
/// android.animation package APIs. These android.animation.Animator Animator-based
/// classes change actual properties of the View object, such as \#setAlpha(float) alpha and
/// \#setTranslationX(float) translationX. This behavior is contrasted to that of the pre-3.0
/// android.view.animation.Animation Animation-based classes, which instead animate only
/// how the view is drawn on the display. In particular, the ViewPropertyAnimator class
/// makes animating these View properties particularly easy and efficient.
///
///
///
/// Alternatively, you can use the pre-3.0 animation classes to animate how Views are rendered.
/// You can attach an Animation object to a view using
/// \#setAnimation(Animation) or
/// \#startAnimation(Animation). The animation can alter the scale,
/// rotation, translation and alpha of a view over time. If the animation is
/// attached to a view that has children, the animation will affect the entire
/// subtree rooted by that node. When an animation is started, the framework will
/// take care of redrawing the appropriate views until the animation completes.
///
///
///
/// <a name="Security"></a>
/// <h3>Security</h3>
///
/// Sometimes it is essential that an application be able to verify that an action
/// is being performed with the full knowledge and consent of the user, such as
/// granting a permission request, making a purchase or clicking on an advertisement.
/// Unfortunately, a malicious application could try to spoof the user into
/// performing these actions, unaware, by concealing the intended purpose of the view.
/// As a remedy, the framework offers a touch filtering mechanism that can be used to
/// improve the security of views that provide access to sensitive functionality.
///
///
/// To enable touch filtering, call \#setFilterTouchesWhenObscured(boolean) or set the
/// android:filterTouchesWhenObscured layout attribute to true.  When enabled, the framework
/// will discard touches that are received whenever the view's window is obscured by
/// another visible window.  As a result, the view will not receive touches whenever a
/// toast, dialog or other window appears above the view's window.
///
///
/// For more fine-grained control over security, consider overriding the
/// \#onFilterTouchEventForSecurity(MotionEvent) method to implement your own
/// security policy. See also MotionEvent\#FLAG_WINDOW_IS_OBSCURED.
///
///
///@attr ref android.R.styleable\#View_accessibilityHeading
///@attr ref android.R.styleable\#View_alpha
///@attr ref android.R.styleable\#View_background
///@attr ref android.R.styleable\#View_clickable
///@attr ref android.R.styleable\#View_contentDescription
///@attr ref android.R.styleable\#View_drawingCacheQuality
///@attr ref android.R.styleable\#View_duplicateParentState
///@attr ref android.R.styleable\#View_id
///@attr ref android.R.styleable\#View_requiresFadingEdge
///@attr ref android.R.styleable\#View_fadeScrollbars
///@attr ref android.R.styleable\#View_fadingEdgeLength
///@attr ref android.R.styleable\#View_filterTouchesWhenObscured
///@attr ref android.R.styleable\#View_fitsSystemWindows
///@attr ref android.R.styleable\#View_isScrollContainer
///@attr ref android.R.styleable\#View_focusable
///@attr ref android.R.styleable\#View_focusableInTouchMode
///@attr ref android.R.styleable\#View_focusedByDefault
///@attr ref android.R.styleable\#View_hapticFeedbackEnabled
///@attr ref android.R.styleable\#View_keepScreenOn
///@attr ref android.R.styleable\#View_keyboardNavigationCluster
///@attr ref android.R.styleable\#View_layerType
///@attr ref android.R.styleable\#View_layoutDirection
///@attr ref android.R.styleable\#View_longClickable
///@attr ref android.R.styleable\#View_minHeight
///@attr ref android.R.styleable\#View_minWidth
///@attr ref android.R.styleable\#View_nextClusterForward
///@attr ref android.R.styleable\#View_nextFocusDown
///@attr ref android.R.styleable\#View_nextFocusLeft
///@attr ref android.R.styleable\#View_nextFocusRight
///@attr ref android.R.styleable\#View_nextFocusUp
///@attr ref android.R.styleable\#View_onClick
///@attr ref android.R.styleable\#View_outlineSpotShadowColor
///@attr ref android.R.styleable\#View_outlineAmbientShadowColor
///@attr ref android.R.styleable\#View_padding
///@attr ref android.R.styleable\#View_paddingHorizontal
///@attr ref android.R.styleable\#View_paddingVertical
///@attr ref android.R.styleable\#View_paddingBottom
///@attr ref android.R.styleable\#View_paddingLeft
///@attr ref android.R.styleable\#View_paddingRight
///@attr ref android.R.styleable\#View_paddingTop
///@attr ref android.R.styleable\#View_paddingStart
///@attr ref android.R.styleable\#View_paddingEnd
///@attr ref android.R.styleable\#View_saveEnabled
///@attr ref android.R.styleable\#View_rotation
///@attr ref android.R.styleable\#View_rotationX
///@attr ref android.R.styleable\#View_rotationY
///@attr ref android.R.styleable\#View_scaleX
///@attr ref android.R.styleable\#View_scaleY
///@attr ref android.R.styleable\#View_scrollX
///@attr ref android.R.styleable\#View_scrollY
///@attr ref android.R.styleable\#View_scrollbarSize
///@attr ref android.R.styleable\#View_scrollbarStyle
///@attr ref android.R.styleable\#View_scrollbars
///@attr ref android.R.styleable\#View_scrollbarDefaultDelayBeforeFade
///@attr ref android.R.styleable\#View_scrollbarFadeDuration
///@attr ref android.R.styleable\#View_scrollbarTrackHorizontal
///@attr ref android.R.styleable\#View_scrollbarThumbHorizontal
///@attr ref android.R.styleable\#View_scrollbarThumbVertical
///@attr ref android.R.styleable\#View_scrollbarTrackVertical
///@attr ref android.R.styleable\#View_scrollbarAlwaysDrawHorizontalTrack
///@attr ref android.R.styleable\#View_scrollbarAlwaysDrawVerticalTrack
///@attr ref android.R.styleable\#View_stateListAnimator
///@attr ref android.R.styleable\#View_transitionName
///@attr ref android.R.styleable\#View_soundEffectsEnabled
///@attr ref android.R.styleable\#View_tag
///@attr ref android.R.styleable\#View_textAlignment
///@attr ref android.R.styleable\#View_textDirection
///@attr ref android.R.styleable\#View_transformPivotX
///@attr ref android.R.styleable\#View_transformPivotY
///@attr ref android.R.styleable\#View_translationX
///@attr ref android.R.styleable\#View_translationY
///@attr ref android.R.styleable\#View_translationZ
///@attr ref android.R.styleable\#View_visibility
///@attr ref android.R.styleable\#View_theme
///@see android.view.ViewGroup
class View extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/View");
  View.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_ASSERTIVE
  ///
  /// Live region mode specifying that accessibility services should interrupt
  /// ongoing speech to immediately announce changes to this view.
  ///
  /// Use with \#setAccessibilityLiveRegion(int).
  static const ACCESSIBILITY_LIVE_REGION_ASSERTIVE = 2;

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_NONE
  ///
  /// Live region mode specifying that accessibility services should not
  /// automatically announce changes to this view. This is the default live
  /// region mode for most views.
  ///
  /// Use with \#setAccessibilityLiveRegion(int).
  static const ACCESSIBILITY_LIVE_REGION_NONE = 0;

  /// from: static public final int ACCESSIBILITY_LIVE_REGION_POLITE
  ///
  /// Live region mode specifying that accessibility services should announce
  /// changes to this view.
  ///
  /// Use with \#setAccessibilityLiveRegion(int).
  static const ACCESSIBILITY_LIVE_REGION_POLITE = 1;

  static final _id_ALPHA = jniAccessors.getStaticFieldIDOf(
      _classRef, "ALPHA", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> ALPHA
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>alpha</code> functionality handled by the
  /// View\#setAlpha(float) and View\#getAlpha() methods.
  static property_.Property get ALPHA => property_.Property.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ALPHA, jni.JniType.objectType)
      .object);

  /// from: static public final int AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  ///
  /// Flag requesting you to add views that are marked as not important for autofill
  /// (see \#setImportantForAutofill(int)) to a ViewStructure.
  static const AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS = 1;

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE
  ///
  /// Hint indicating that this view can be autofilled with a credit card expiration date.
  ///
  /// It should be used when the credit card expiration date is represented by just one view;
  /// if it is represented by more than one (for example, one view for the month and another view
  /// for the year), then each of these views should use the hint specific for the unit
  /// (\#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY,
  /// \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH,
  /// or \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR).
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE}</code>).
  ///
  /// When annotating a view with this hint, it's recommended to use a date autofill value to
  /// avoid ambiguity when the autofill service provides a value for it. To understand why a
  /// value can be ambiguous, consider "April of 2020", which could be represented as either of
  /// the following options:
  ///
  /// <ul>
  ///   <li>{@code "04/2020"}
  ///   <li>{@code "4/2020"}
  ///   <li>{@code "2020/04"}
  ///   <li>{@code "2020/4"}
  ///   <li>{@code "April/2020"}
  ///   <li>{@code "Apr/2020"}
  /// </ul>
  ///
  /// You define a date autofill value for the view by overriding the following methods:
  ///
  /// <ol>
  ///   <li>\#getAutofillType() to return \#AUTOFILL_TYPE_DATE.
  ///   <li>\#getAutofillValue() to return a
  ///       AutofillValue\#forDate(long) date autofillvalue.
  ///   <li>\#autofill(AutofillValue) to expect a data autofillvalue.
  /// </ol>
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE =
      "creditCardExpirationDate";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY
  ///
  /// Hint indicating that this view can be autofilled with a credit card expiration day.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY =
      "creditCardExpirationDay";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH
  ///
  /// Hint indicating that this view can be autofilled with a credit card expiration month.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH}</code>).
  ///
  /// When annotating a view with this hint, it's recommended to use a text autofill value
  /// whose value is the numerical representation of the month, starting on {@code 1} to avoid
  /// ambiguity when the autofill service provides a value for it. To understand why a
  /// value can be ambiguous, consider "January", which could be represented as either of
  ///
  /// <ul>
  ///   <li>{@code "1"}: recommended way.
  ///   <li>{@code "0"}: if following the Calendar\#MONTH convention.
  ///   <li>{@code "January"}: full name, in English.
  ///   <li>{@code "jan"}: abbreviated name, in English.
  ///   <li>{@code "Janeiro"}: full name, in another language.
  /// </ul>
  ///
  /// Another recommended approach is to use a date autofill value - see
  /// \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE for more details.
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH =
      "creditCardExpirationMonth";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR
  ///
  /// Hint indicating that this view can be autofilled with a credit card expiration year.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR =
      "creditCardExpirationYear";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_NUMBER
  ///
  /// Hint indicating that this view can be autofilled with a credit card number.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_CREDIT_CARD_NUMBER}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_CREDIT_CARD_NUMBER = "creditCardNumber";

  /// from: static public final java.lang.String AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE
  ///
  /// Hint indicating that this view can be autofilled with a credit card security code.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE =
      "creditCardSecurityCode";

  /// from: static public final java.lang.String AUTOFILL_HINT_EMAIL_ADDRESS
  ///
  /// Hint indicating that this view can be autofilled with an email address.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_EMAIL_ADDRESS}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_EMAIL_ADDRESS = "emailAddress";

  /// from: static public final java.lang.String AUTOFILL_HINT_NAME
  ///
  /// Hint indicating that this view can be autofilled with a user's real name.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_NAME}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_NAME = "name";

  /// from: static public final java.lang.String AUTOFILL_HINT_PASSWORD
  ///
  /// Hint indicating that this view can be autofilled with a password.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_PASSWORD}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_PASSWORD = "password";

  /// from: static public final java.lang.String AUTOFILL_HINT_PHONE
  ///
  /// Hint indicating that this view can be autofilled with a phone number.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_PHONE}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_PHONE = "phone";

  /// from: static public final java.lang.String AUTOFILL_HINT_POSTAL_ADDRESS
  ///
  /// Hint indicating that this view can be autofilled with a postal address.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_POSTAL_ADDRESS}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_POSTAL_ADDRESS = "postalAddress";

  /// from: static public final java.lang.String AUTOFILL_HINT_POSTAL_CODE
  ///
  /// Hint indicating that this view can be autofilled with a postal code.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_POSTAL_CODE}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_POSTAL_CODE = "postalCode";

  /// from: static public final java.lang.String AUTOFILL_HINT_USERNAME
  ///
  /// Hint indicating that this view can be autofilled with a username.
  ///
  /// Can be used with either \#setAutofillHints(String[]) or
  /// <a href="\#attr_android:autofillHint"> {@code android:autofillHint}</a> (in which case the
  /// value should be <code>{@value \#AUTOFILL_HINT_USERNAME}</code>).
  ///
  /// See \#setAutofillHints(String...) for more info about autofill hints.
  static const AUTOFILL_HINT_USERNAME = "username";

  /// from: static public final int AUTOFILL_TYPE_DATE
  ///
  /// Autofill type for a field that contains a date, which is represented by a long representing
  /// the number of milliseconds since the standard base time known as "the epoch", namely
  /// January 1, 1970, 00:00:00 GMT (see java.util.Date\#getTime().
  ///
  /// AutofillValue instances for autofilling a View can be obtained through
  /// AutofillValue\#forDate(long), and the values passed to
  /// autofill a View can be fetched through AutofillValue\#getDateValue().
  ///@see \#getAutofillType()
  static const AUTOFILL_TYPE_DATE = 4;

  /// from: static public final int AUTOFILL_TYPE_LIST
  ///
  /// Autofill type for a selection list field, which is filled by an {@code int}
  /// representing the element index inside the list (starting at {@code 0}).
  ///
  /// AutofillValue instances for autofilling a View can be obtained through
  /// AutofillValue\#forList(int), and the value passed to autofill a
  /// View can be fetched through AutofillValue\#getListValue().
  ///
  /// The available options in the selection list are typically provided by
  /// android.app.assist.AssistStructure.ViewNode\#getAutofillOptions().
  ///@see \#getAutofillType()
  static const AUTOFILL_TYPE_LIST = 3;

  /// from: static public final int AUTOFILL_TYPE_NONE
  ///
  /// Autofill type for views that cannot be autofilled.
  ///
  /// Typically used when the view is read-only; for example, a text label.
  ///@see \#getAutofillType()
  static const AUTOFILL_TYPE_NONE = 0;

  /// from: static public final int AUTOFILL_TYPE_TEXT
  ///
  /// Autofill type for a text field, which is filled by a CharSequence.
  ///
  /// AutofillValue instances for autofilling a View can be obtained through
  /// AutofillValue\#forText(CharSequence), and the value passed to autofill a
  /// View can be fetched through AutofillValue\#getTextValue().
  ///@see \#getAutofillType()
  static const AUTOFILL_TYPE_TEXT = 1;

  /// from: static public final int AUTOFILL_TYPE_TOGGLE
  ///
  /// Autofill type for a togglable field, which is filled by a {@code boolean}.
  ///
  /// AutofillValue instances for autofilling a View can be obtained through
  /// AutofillValue\#forToggle(boolean), and the value passed to autofill a
  /// View can be fetched through AutofillValue\#getToggleValue().
  ///@see \#getAutofillType()
  static const AUTOFILL_TYPE_TOGGLE = 2;

  /// from: static public final int DRAG_FLAG_GLOBAL
  ///
  /// Flag indicating that a drag can cross window boundaries.  When
  /// \#startDragAndDrop(ClipData, DragShadowBuilder, Object, int) is called
  /// with this flag set, all visible applications with targetSdkVersion >=
  /// android.os.Build.VERSION_CODES\#N API 24 will be able to participate
  /// in the drag operation and receive the dragged content.
  ///
  /// If this is the only flag set, then the drag recipient will only have access to text data
  /// and intents contained in the ClipData object. Access to URIs contained in the
  /// ClipData is determined by other DRAG_FLAG_GLOBAL_* flags
  ///
  static const DRAG_FLAG_GLOBAL = 256;

  /// from: static public final int DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION
  ///
  /// When this flag is used with \#DRAG_FLAG_GLOBAL_URI_READ and/or \#DRAG_FLAG_GLOBAL_URI_WRITE, the URI permission grant can be persisted across device
  /// reboots until explicitly revoked with
  /// android.content.Context\#revokeUriPermission(Uri, int) Context.revokeUriPermission}.
  ///@see android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION
  static const DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION = 64;

  /// from: static public final int DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION
  ///
  /// When this flag is used with \#DRAG_FLAG_GLOBAL_URI_READ and/or \#DRAG_FLAG_GLOBAL_URI_WRITE, the URI permission grant applies to any URI that is a prefix
  /// match against the original granted URI.
  ///@see android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION
  static const DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION = 128;

  /// from: static public final int DRAG_FLAG_GLOBAL_URI_READ
  ///
  /// When this flag is used with \#DRAG_FLAG_GLOBAL, the drag recipient will be able to
  /// request read access to the content URI(s) contained in the ClipData object.
  ///@see android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION
  static const DRAG_FLAG_GLOBAL_URI_READ = 1;

  /// from: static public final int DRAG_FLAG_GLOBAL_URI_WRITE
  ///
  /// When this flag is used with \#DRAG_FLAG_GLOBAL, the drag recipient will be able to
  /// request write access to the content URI(s) contained in the ClipData object.
  ///@see android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  static const DRAG_FLAG_GLOBAL_URI_WRITE = 2;

  /// from: static public final int DRAG_FLAG_OPAQUE
  ///
  /// Flag indicating that the drag shadow will be opaque.  When
  /// \#startDragAndDrop(ClipData, DragShadowBuilder, Object, int) is called
  /// with this flag set, the drag shadow will be opaque, otherwise, it will be semitransparent.
  static const DRAG_FLAG_OPAQUE = 512;

  /// from: static public final int DRAWING_CACHE_QUALITY_AUTO
  ///
  /// Enables automatic quality mode for the drawing cache.
  ///
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  static const DRAWING_CACHE_QUALITY_AUTO = 0;

  /// from: static public final int DRAWING_CACHE_QUALITY_HIGH
  ///
  /// Enables high quality mode for the drawing cache.
  ///
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  static const DRAWING_CACHE_QUALITY_HIGH = 1048576;

  /// from: static public final int DRAWING_CACHE_QUALITY_LOW
  ///
  /// Enables low quality mode for the drawing cache.
  ///
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  static const DRAWING_CACHE_QUALITY_LOW = 524288;

  static final _id_EMPTY_STATE_SET =
      jniAccessors.getStaticFieldIDOf(_classRef, "EMPTY_STATE_SET", "[I");

  /// from: static protected final int[] EMPTY_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view has no states set. States are used with
  /// android.graphics.drawable.Drawable to change the drawing of the
  /// view depending on its state.
  ///@see android.graphics.drawable.Drawable
  ///@see \#getDrawableState()
  static jni.JniObject get EMPTY_STATE_SET => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_EMPTY_STATE_SET, jni.JniType.objectType)
      .object);

  static final _id_ENABLED_FOCUSED_SELECTED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENABLED_FOCUSED_SELECTED_STATE_SET", "[I");

  /// from: static protected final int[] ENABLED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is enabled, focused and selected.
  ///@see \#ENABLED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  static jni.JniObject get ENABLED_FOCUSED_SELECTED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ENABLED_FOCUSED_SELECTED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is enabled, focused, selected and its window
  /// has the focus.
  ///@see \#ENABLED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_ENABLED_FOCUSED_STATE_SET = jniAccessors.getStaticFieldIDOf(
      _classRef, "ENABLED_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] ENABLED_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is enabled and has the focus.
  ///@see \#ENABLED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  static jni.JniObject get ENABLED_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ENABLED_FOCUSED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is enabled, focused and its window has the focus.
  ///@see \#ENABLED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_ENABLED_SELECTED_STATE_SET = jniAccessors.getStaticFieldIDOf(
      _classRef, "ENABLED_SELECTED_STATE_SET", "[I");

  /// from: static protected final int[] ENABLED_SELECTED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is enabled and selected.
  ///@see \#ENABLED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  static jni.JniObject get ENABLED_SELECTED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ENABLED_SELECTED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is enabled, selected and its window has the focus.
  ///@see \#ENABLED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_ENABLED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(_classRef, "ENABLED_STATE_SET", "[I");

  /// from: static protected final int[] ENABLED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is enabled. States are used with
  /// android.graphics.drawable.Drawable to change the drawing of the
  /// view depending on its state.
  ///@see android.graphics.drawable.Drawable
  ///@see \#getDrawableState()
  static jni.JniObject get ENABLED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ENABLED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_ENABLED_WINDOW_FOCUSED_STATE_SET = jniAccessors
      .getStaticFieldIDOf(_classRef, "ENABLED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] ENABLED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is enabled and that its window has focus.
  ///@see \#ENABLED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get ENABLED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ENABLED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  /// from: static public final int FIND_VIEWS_WITH_CONTENT_DESCRIPTION
  ///
  /// Find find views that contain the specified content description.
  ///@see \#findViewsWithText(ArrayList, CharSequence, int)
  static const FIND_VIEWS_WITH_CONTENT_DESCRIPTION = 2;

  /// from: static public final int FIND_VIEWS_WITH_TEXT
  ///
  /// Find views that render the specified text.
  ///@see \#findViewsWithText(ArrayList, CharSequence, int)
  static const FIND_VIEWS_WITH_TEXT = 1;

  /// from: static public final int FOCUSABLE
  ///
  /// This view wants keystrokes.
  ///
  /// Use with \#setFocusable(int) and <a href="\#attr_android:focusable">{@code
  /// android:focusable}.
  static const FOCUSABLE = 1;

  /// from: static public final int FOCUSABLES_ALL
  ///
  /// View flag indicating whether \#addFocusables(ArrayList, int, int)
  /// should add all focusable Views regardless if they are focusable in touch mode.
  static const FOCUSABLES_ALL = 0;

  /// from: static public final int FOCUSABLES_TOUCH_MODE
  ///
  /// View flag indicating whether \#addFocusables(ArrayList, int, int)
  /// should add only Views focusable in touch mode.
  static const FOCUSABLES_TOUCH_MODE = 1;

  /// from: static public final int FOCUSABLE_AUTO
  ///
  /// This view determines focusability automatically. This is the default.
  ///
  /// Use with \#setFocusable(int) and <a href="\#attr_android:focusable">{@code
  /// android:focusable}.
  static const FOCUSABLE_AUTO = 16;

  static final _id_FOCUSED_SELECTED_STATE_SET = jniAccessors.getStaticFieldIDOf(
      _classRef, "FOCUSED_SELECTED_STATE_SET", "[I");

  /// from: static protected final int[] FOCUSED_SELECTED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is focused and selected.
  ///@see \#FOCUSED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  static jni.JniObject get FOCUSED_SELECTED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_FOCUSED_SELECTED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is focused, selected and its window has the focus.
  ///@see \#FOCUSED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(_classRef, "FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is focused. States are used with
  /// android.graphics.drawable.Drawable to change the drawing of the
  /// view depending on its state.
  ///@see android.graphics.drawable.Drawable
  ///@see \#getDrawableState()
  static jni.JniObject get FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_FOCUSED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_FOCUSED_WINDOW_FOCUSED_STATE_SET = jniAccessors
      .getStaticFieldIDOf(_classRef, "FOCUSED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view has the focus and that its window has the focus.
  ///@see \#FOCUSED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_FOCUSED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  /// from: static public final int FOCUS_BACKWARD
  ///
  /// Use with \#focusSearch(int). Move focus to the previous selectable
  /// item.
  static const FOCUS_BACKWARD = 1;

  /// from: static public final int FOCUS_DOWN
  ///
  /// Use with \#focusSearch(int). Move focus down.
  static const FOCUS_DOWN = 130;

  /// from: static public final int FOCUS_FORWARD
  ///
  /// Use with \#focusSearch(int). Move focus to the next selectable
  /// item.
  static const FOCUS_FORWARD = 2;

  /// from: static public final int FOCUS_LEFT
  ///
  /// Use with \#focusSearch(int). Move focus to the left.
  static const FOCUS_LEFT = 17;

  /// from: static public final int FOCUS_RIGHT
  ///
  /// Use with \#focusSearch(int). Move focus to the right.
  static const FOCUS_RIGHT = 66;

  /// from: static public final int FOCUS_UP
  ///
  /// Use with \#focusSearch(int). Move focus up.
  static const FOCUS_UP = 33;

  /// from: static public final int GONE
  ///
  /// This view is invisible, and it doesn't take any space for layout
  /// purposes. Use with \#setVisibility and <a href="\#attr_android:visibility">{@code
  /// android:visibility}.
  static const GONE = 8;

  /// from: static public final int HAPTIC_FEEDBACK_ENABLED
  ///
  /// View flag indicating whether this view should have haptic feedback
  /// enabled for events such as long presses.
  static const HAPTIC_FEEDBACK_ENABLED = 268435456;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_AUTO
  ///
  /// Automatically determine whether a view is important for accessibility.
  static const IMPORTANT_FOR_ACCESSIBILITY_AUTO = 0;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_NO
  ///
  /// The view is not important for accessibility.
  static const IMPORTANT_FOR_ACCESSIBILITY_NO = 2;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS
  ///
  /// The view is not important for accessibility, nor are any of its
  /// descendant views.
  static const IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS = 4;

  /// from: static public final int IMPORTANT_FOR_ACCESSIBILITY_YES
  ///
  /// The view is important for accessibility.
  static const IMPORTANT_FOR_ACCESSIBILITY_YES = 1;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_AUTO
  ///
  /// Automatically determine whether a view is important for autofill.
  ///@see \#isImportantForAutofill()
  ///@see \#setImportantForAutofill(int)
  static const IMPORTANT_FOR_AUTOFILL_AUTO = 0;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_NO
  ///
  /// The view is not important for autofill, but its children (if any) will be traversed.
  ///@see \#isImportantForAutofill()
  ///@see \#setImportantForAutofill(int)
  static const IMPORTANT_FOR_AUTOFILL_NO = 2;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
  ///
  /// The view is not important for autofill, and its children (if any) will not be traversed.
  ///@see \#isImportantForAutofill()
  ///@see \#setImportantForAutofill(int)
  static const IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS = 8;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_YES
  ///
  /// The view is important for autofill, and its children (if any) will be traversed.
  ///@see \#isImportantForAutofill()
  ///@see \#setImportantForAutofill(int)
  static const IMPORTANT_FOR_AUTOFILL_YES = 1;

  /// from: static public final int IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS
  ///
  /// The view is important for autofill, but its children (if any) will not be traversed.
  ///@see \#isImportantForAutofill()
  ///@see \#setImportantForAutofill(int)
  static const IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS = 4;

  /// from: static public final int INVISIBLE
  ///
  /// This view is invisible, but it still takes up space for layout purposes.
  /// Use with \#setVisibility and <a href="\#attr_android:visibility">{@code
  /// android:visibility}.
  static const INVISIBLE = 4;

  /// from: static public final int KEEP_SCREEN_ON
  ///
  /// View flag indicating that the screen should remain on while the
  /// window containing this view is visible to the user.  This effectively
  /// takes care of automatically setting the WindowManager's
  /// WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON.
  static const KEEP_SCREEN_ON = 67108864;

  /// from: static public final int LAYER_TYPE_HARDWARE
  ///
  /// Indicates that the view has a hardware layer. A hardware layer is backed
  /// by a hardware specific texture (generally Frame Buffer Objects or FBO on
  /// OpenGL hardware) and causes the view to be rendered using Android's hardware
  /// rendering pipeline, but only if hardware acceleration is turned on for the
  /// view hierarchy. When hardware acceleration is turned off, hardware layers
  /// behave exactly as \#LAYER_TYPE_SOFTWARE software layers.
  ///
  ///
  /// A hardware layer is useful to apply a specific color filter and/or
  /// blending mode and/or translucency to a view and all its children.
  ///
  /// A hardware layer can be used to cache a complex view tree into a
  /// texture and reduce the complexity of drawing operations. For instance,
  /// when animating a complex view tree with a translation, a hardware layer can
  /// be used to render the view tree only once.
  ///
  /// A hardware layer can also be used to increase the rendering quality when
  /// rotation transformations are applied on a view. It can also be used to
  /// prevent potential clipping issues when applying 3D transforms on a view.
  ///
  ///@see \#getLayerType()
  ///@see \#setLayerType(int, android.graphics.Paint)
  ///@see \#LAYER_TYPE_NONE
  ///@see \#LAYER_TYPE_SOFTWARE
  static const LAYER_TYPE_HARDWARE = 2;

  /// from: static public final int LAYER_TYPE_NONE
  ///
  /// Indicates that the view does not have a layer.
  ///@see \#getLayerType()
  ///@see \#setLayerType(int, android.graphics.Paint)
  ///@see \#LAYER_TYPE_SOFTWARE
  ///@see \#LAYER_TYPE_HARDWARE
  static const LAYER_TYPE_NONE = 0;

  /// from: static public final int LAYER_TYPE_SOFTWARE
  ///
  /// Indicates that the view has a software layer. A software layer is backed
  /// by a bitmap and causes the view to be rendered using Android's software
  /// rendering pipeline, even if hardware acceleration is enabled.
  ///
  ///
  /// Software layers have various usages:
  ///
  /// When the application is not using hardware acceleration, a software layer
  /// is useful to apply a specific color filter and/or blending mode and/or
  /// translucency to a view and all its children.
  ///
  /// When the application is using hardware acceleration, a software layer
  /// is useful to render drawing primitives not supported by the hardware
  /// accelerated pipeline. It can also be used to cache a complex view tree
  /// into a texture and reduce the complexity of drawing operations. For instance,
  /// when animating a complex view tree with a translation, a software layer can
  /// be used to render the view tree only once.
  ///
  /// Software layers should be avoided when the affected view tree updates
  /// often. Every update will require to re-render the software layer, which can
  /// potentially be slow (particularly when hardware acceleration is turned on
  /// since the layer will have to be uploaded into a hardware texture after every
  /// update.)
  ///
  ///@see \#getLayerType()
  ///@see \#setLayerType(int, android.graphics.Paint)
  ///@see \#LAYER_TYPE_NONE
  ///@see \#LAYER_TYPE_HARDWARE
  static const LAYER_TYPE_SOFTWARE = 1;

  /// from: static public final int LAYOUT_DIRECTION_INHERIT
  ///
  /// Horizontal layout direction of this view is inherited from its parent.
  /// Use with \#setLayoutDirection.
  static const LAYOUT_DIRECTION_INHERIT = 2;

  /// from: static public final int LAYOUT_DIRECTION_LOCALE
  ///
  /// Horizontal layout direction of this view is from deduced from the default language
  /// script for the locale. Use with \#setLayoutDirection.
  static const LAYOUT_DIRECTION_LOCALE = 3;

  /// from: static public final int LAYOUT_DIRECTION_LTR
  ///
  /// Horizontal layout direction of this view is from Left to Right.
  /// Use with \#setLayoutDirection.
  static const LAYOUT_DIRECTION_LTR = 0;

  /// from: static public final int LAYOUT_DIRECTION_RTL
  ///
  /// Horizontal layout direction of this view is from Right to Left.
  /// Use with \#setLayoutDirection.
  static const LAYOUT_DIRECTION_RTL = 1;

  /// from: static public final int MEASURED_HEIGHT_STATE_SHIFT
  ///
  /// Bit shift of \#MEASURED_STATE_MASK to get to the height bits
  /// for functions that combine both width and height into a single int,
  /// such as \#getMeasuredState() and the childState argument of
  /// \#resolveSizeAndState(int, int, int).
  static const MEASURED_HEIGHT_STATE_SHIFT = 16;

  /// from: static public final int MEASURED_SIZE_MASK
  ///
  /// Bits of \#getMeasuredWidthAndState() and
  /// \#getMeasuredWidthAndState() that provide the actual measured size.
  static const MEASURED_SIZE_MASK = 16777215;

  /// from: static public final int MEASURED_STATE_MASK
  ///
  /// Bits of \#getMeasuredWidthAndState() and
  /// \#getMeasuredWidthAndState() that provide the additional state bits.
  static const MEASURED_STATE_MASK = -16777216;

  /// from: static public final int MEASURED_STATE_TOO_SMALL
  ///
  /// Bit of \#getMeasuredWidthAndState() and
  /// \#getMeasuredWidthAndState() that indicates the measured size
  /// is smaller that the space the view would like to have.
  static const MEASURED_STATE_TOO_SMALL = 16777216;

  /// from: static public final int NOT_FOCUSABLE
  ///
  /// This view does not want keystrokes.
  ///
  /// Use with \#setFocusable(int) and <a href="\#attr_android:focusable">{@code
  /// android:focusable}.
  static const NOT_FOCUSABLE = 0;

  /// from: static public final int NO_ID
  ///
  /// Used to mark a View that has no ID.
  static const NO_ID = -1;

  /// from: static public final int OVER_SCROLL_ALWAYS
  ///
  /// Always allow a user to over-scroll this view, provided it is a
  /// view that can scroll.
  ///@see \#getOverScrollMode()
  ///@see \#setOverScrollMode(int)
  static const OVER_SCROLL_ALWAYS = 0;

  /// from: static public final int OVER_SCROLL_IF_CONTENT_SCROLLS
  ///
  /// Allow a user to over-scroll this view only if the content is large
  /// enough to meaningfully scroll, provided it is a view that can scroll.
  ///@see \#getOverScrollMode()
  ///@see \#setOverScrollMode(int)
  static const OVER_SCROLL_IF_CONTENT_SCROLLS = 1;

  /// from: static public final int OVER_SCROLL_NEVER
  ///
  /// Never allow a user to over-scroll this view.
  ///@see \#getOverScrollMode()
  ///@see \#setOverScrollMode(int)
  static const OVER_SCROLL_NEVER = 2;

  static final _id_PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, enabled, focused and selected.
  ///@see \#PRESSED_STATE_SET
  ///@see \#ENABLED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(_classRef,
          "PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, enabled, focused, selected and its window
  /// has the focus.
  ///@see \#PRESSED_STATE_SET
  ///@see \#ENABLED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject
      get PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
          jni.JniObject.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
                  jni.JniType.objectType)
              .object);

  static final _id_PRESSED_ENABLED_FOCUSED_STATE_SET = jniAccessors
      .getStaticFieldIDOf(_classRef, "PRESSED_ENABLED_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, enabled and focused.
  ///@see \#PRESSED_STATE_SET
  ///@see \#ENABLED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_ENABLED_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_PRESSED_ENABLED_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, enabled, focused and its window has the
  /// focus.
  ///@see \#PRESSED_STATE_SET
  ///@see \#ENABLED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_SELECTED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_ENABLED_SELECTED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_ENABLED_SELECTED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, enabled and selected.
  ///@see \#PRESSED_STATE_SET
  ///@see \#ENABLED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  static jni.JniObject get PRESSED_ENABLED_SELECTED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_PRESSED_ENABLED_SELECTED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, enabled, selected and its window has the
  /// focus.
  ///@see \#PRESSED_STATE_SET
  ///@see \#ENABLED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_STATE_SET = jniAccessors.getStaticFieldIDOf(
      _classRef, "PRESSED_ENABLED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_ENABLED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed and enabled.
  ///@see \#PRESSED_STATE_SET
  ///@see \#ENABLED_STATE_SET
  static jni.JniObject get PRESSED_ENABLED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_PRESSED_ENABLED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, enabled and its window has the focus.
  ///@see \#PRESSED_STATE_SET
  ///@see \#ENABLED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_FOCUSED_SELECTED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_FOCUSED_SELECTED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_FOCUSED_SELECTED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, focused and selected.
  ///@see \#PRESSED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_FOCUSED_SELECTED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_PRESSED_FOCUSED_SELECTED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, focused, selected and its window has the focus.
  ///@see \#PRESSED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_FOCUSED_STATE_SET = jniAccessors.getStaticFieldIDOf(
      _classRef, "PRESSED_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed and focused.
  ///@see \#PRESSED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_PRESSED_FOCUSED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, focused and its window has the focus.
  ///@see \#PRESSED_STATE_SET
  ///@see \#FOCUSED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_SELECTED_STATE_SET = jniAccessors.getStaticFieldIDOf(
      _classRef, "PRESSED_SELECTED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_SELECTED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed and selected.
  ///@see \#PRESSED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  static jni.JniObject get PRESSED_SELECTED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_PRESSED_SELECTED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed, selected and its window has the focus.
  ///@see \#PRESSED_STATE_SET
  ///@see \#SELECTED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef,
              _id_PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_PRESSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(_classRef, "PRESSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed. States are used with
  /// android.graphics.drawable.Drawable to change the drawing of the
  /// view depending on its state.
  ///@see android.graphics.drawable.Drawable
  ///@see \#getDrawableState()
  static jni.JniObject get PRESSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_PRESSED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_PRESSED_WINDOW_FOCUSED_STATE_SET = jniAccessors
      .getStaticFieldIDOf(_classRef, "PRESSED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] PRESSED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is pressed and its window has the focus.
  ///@see \#PRESSED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get PRESSED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_PRESSED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  static final _id_ROTATION = jniAccessors.getStaticFieldIDOf(
      _classRef, "ROTATION", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> ROTATION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>rotation</code> functionality handled by the
  /// View\#setRotation(float) and View\#getRotation() methods.
  static property_.Property get ROTATION =>
      property_.Property.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ROTATION, jni.JniType.objectType)
          .object);

  static final _id_ROTATION_X = jniAccessors.getStaticFieldIDOf(
      _classRef, "ROTATION_X", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> ROTATION_X
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>rotationX</code> functionality handled by the
  /// View\#setRotationX(float) and View\#getRotationX() methods.
  static property_.Property get ROTATION_X =>
      property_.Property.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ROTATION_X, jni.JniType.objectType)
          .object);

  static final _id_ROTATION_Y = jniAccessors.getStaticFieldIDOf(
      _classRef, "ROTATION_Y", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> ROTATION_Y
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>rotationY</code> functionality handled by the
  /// View\#setRotationY(float) and View\#getRotationY() methods.
  static property_.Property get ROTATION_Y =>
      property_.Property.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ROTATION_Y, jni.JniType.objectType)
          .object);

  static final _id_SCALE_X = jniAccessors.getStaticFieldIDOf(
      _classRef, "SCALE_X", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> SCALE_X
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>scaleX</code> functionality handled by the
  /// View\#setScaleX(float) and View\#getScaleX() methods.
  static property_.Property get SCALE_X =>
      property_.Property.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SCALE_X, jni.JniType.objectType)
          .object);

  static final _id_SCALE_Y = jniAccessors.getStaticFieldIDOf(
      _classRef, "SCALE_Y", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> SCALE_Y
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>scaleY</code> functionality handled by the
  /// View\#setScaleY(float) and View\#getScaleY() methods.
  static property_.Property get SCALE_Y =>
      property_.Property.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SCALE_Y, jni.JniType.objectType)
          .object);

  /// from: static public final int SCREEN_STATE_OFF
  ///
  /// Indicates that the screen has changed state and is now off.
  ///@see \#onScreenStateChanged(int)
  static const SCREEN_STATE_OFF = 0;

  /// from: static public final int SCREEN_STATE_ON
  ///
  /// Indicates that the screen has changed state and is now on.
  ///@see \#onScreenStateChanged(int)
  static const SCREEN_STATE_ON = 1;

  /// from: static public final int SCROLLBARS_INSIDE_INSET
  ///
  /// The scrollbar style to display the scrollbars inside the padded area,
  /// increasing the padding of the view. The scrollbars will not overlap the
  /// content area of the view.
  static const SCROLLBARS_INSIDE_INSET = 16777216;

  /// from: static public final int SCROLLBARS_INSIDE_OVERLAY
  ///
  /// The scrollbar style to display the scrollbars inside the content area,
  /// without increasing the padding. The scrollbars will be overlaid with
  /// translucency on the view's content.
  static const SCROLLBARS_INSIDE_OVERLAY = 0;

  /// from: static public final int SCROLLBARS_OUTSIDE_INSET
  ///
  /// The scrollbar style to display the scrollbars at the edge of the view,
  /// increasing the padding of the view. The scrollbars will only overlap the
  /// background, if any.
  static const SCROLLBARS_OUTSIDE_INSET = 50331648;

  /// from: static public final int SCROLLBARS_OUTSIDE_OVERLAY
  ///
  /// The scrollbar style to display the scrollbars at the edge of the view,
  /// without increasing the padding. The scrollbars will be overlaid with
  /// translucency.
  static const SCROLLBARS_OUTSIDE_OVERLAY = 33554432;

  /// from: static public final int SCROLLBAR_POSITION_DEFAULT
  ///
  /// Position the scroll bar at the default position as determined by the system.
  static const SCROLLBAR_POSITION_DEFAULT = 0;

  /// from: static public final int SCROLLBAR_POSITION_LEFT
  ///
  /// Position the scroll bar along the left edge.
  static const SCROLLBAR_POSITION_LEFT = 1;

  /// from: static public final int SCROLLBAR_POSITION_RIGHT
  ///
  /// Position the scroll bar along the right edge.
  static const SCROLLBAR_POSITION_RIGHT = 2;

  /// from: static public final int SCROLL_AXIS_HORIZONTAL
  ///
  /// Indicates scrolling along the horizontal axis.
  static const SCROLL_AXIS_HORIZONTAL = 1;

  /// from: static public final int SCROLL_AXIS_NONE
  ///
  /// Indicates no axis of view scrolling.
  static const SCROLL_AXIS_NONE = 0;

  /// from: static public final int SCROLL_AXIS_VERTICAL
  ///
  /// Indicates scrolling along the vertical axis.
  static const SCROLL_AXIS_VERTICAL = 2;

  /// from: static public final int SCROLL_INDICATOR_BOTTOM
  ///
  /// Scroll indicator direction for the bottom edge of the view.
  ///@see \#setScrollIndicators(int)
  ///@see \#setScrollIndicators(int, int)
  ///@see \#getScrollIndicators()
  static const SCROLL_INDICATOR_BOTTOM = 2;

  /// from: static public final int SCROLL_INDICATOR_END
  ///
  /// Scroll indicator direction for the ending edge of the view.
  ///
  /// Resolved according to the view's layout direction, see
  /// \#getLayoutDirection() for more information.
  ///@see \#setScrollIndicators(int)
  ///@see \#setScrollIndicators(int, int)
  ///@see \#getScrollIndicators()
  static const SCROLL_INDICATOR_END = 32;

  /// from: static public final int SCROLL_INDICATOR_LEFT
  ///
  /// Scroll indicator direction for the left edge of the view.
  ///@see \#setScrollIndicators(int)
  ///@see \#setScrollIndicators(int, int)
  ///@see \#getScrollIndicators()
  static const SCROLL_INDICATOR_LEFT = 4;

  /// from: static public final int SCROLL_INDICATOR_RIGHT
  ///
  /// Scroll indicator direction for the right edge of the view.
  ///@see \#setScrollIndicators(int)
  ///@see \#setScrollIndicators(int, int)
  ///@see \#getScrollIndicators()
  static const SCROLL_INDICATOR_RIGHT = 8;

  /// from: static public final int SCROLL_INDICATOR_START
  ///
  /// Scroll indicator direction for the starting edge of the view.
  ///
  /// Resolved according to the view's layout direction, see
  /// \#getLayoutDirection() for more information.
  ///@see \#setScrollIndicators(int)
  ///@see \#setScrollIndicators(int, int)
  ///@see \#getScrollIndicators()
  static const SCROLL_INDICATOR_START = 16;

  /// from: static public final int SCROLL_INDICATOR_TOP
  ///
  /// Scroll indicator direction for the top edge of the view.
  ///@see \#setScrollIndicators(int)
  ///@see \#setScrollIndicators(int, int)
  ///@see \#getScrollIndicators()
  static const SCROLL_INDICATOR_TOP = 1;

  static final _id_SELECTED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(_classRef, "SELECTED_STATE_SET", "[I");

  /// from: static protected final int[] SELECTED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is selected. States are used with
  /// android.graphics.drawable.Drawable to change the drawing of the
  /// view depending on its state.
  ///@see android.graphics.drawable.Drawable
  ///@see \#getDrawableState()
  static jni.JniObject get SELECTED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SELECTED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_SELECTED_WINDOW_FOCUSED_STATE_SET = jniAccessors
      .getStaticFieldIDOf(_classRef, "SELECTED_WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] SELECTED_WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view is selected and that its window has the focus.
  ///@see \#SELECTED_STATE_SET
  ///@see \#WINDOW_FOCUSED_STATE_SET
  static jni.JniObject get SELECTED_WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SELECTED_WINDOW_FOCUSED_STATE_SET,
              jni.JniType.objectType)
          .object);

  /// from: static public final int SOUND_EFFECTS_ENABLED
  ///
  /// View flag indicating whether this view should have sound effects enabled
  /// for events such as clicking and touching.
  static const SOUND_EFFECTS_ENABLED = 134217728;

  /// from: static public final int STATUS_BAR_HIDDEN
  ///
  /// @deprecated Use \#SYSTEM_UI_FLAG_LOW_PROFILE instead.
  static const STATUS_BAR_HIDDEN = 1;

  /// from: static public final int STATUS_BAR_VISIBLE
  ///
  /// @deprecated Use \#SYSTEM_UI_FLAG_VISIBLE instead.
  static const STATUS_BAR_VISIBLE = 0;

  /// from: static public final int SYSTEM_UI_FLAG_FULLSCREEN
  ///
  /// Flag for \#setSystemUiVisibility(int): View has requested to go
  /// into the normal fullscreen mode so that its content can take over the screen
  /// while still allowing the user to interact with the application.
  ///
  /// This has the same visual effect as
  /// android.view.WindowManager.LayoutParams\#FLAG_FULLSCREEN WindowManager.LayoutParams.FLAG_FULLSCREEN,
  /// meaning that non-critical screen decorations (such as the status bar) will be
  /// hidden while the user is in the View's window, focusing the experience on
  /// that content.  Unlike the window flag, if you are using ActionBar in
  /// overlay mode with Window\#FEATURE_ACTION_BAR_OVERLAY Window.FEATURE_ACTION_BAR_OVERLAY, then enabling this flag will also
  /// hide the action bar.
  ///
  /// This approach to going fullscreen is best used over the window flag when
  /// it is a transient state -- that is, the application does this at certain
  /// points in its user interaction where it wants to allow the user to focus
  /// on content, but not as a continuous state.  For situations where the application
  /// would like to simply stay full screen the entire time (such as a game that
  /// wants to take over the screen), the
  /// android.view.WindowManager.LayoutParams\#FLAG_FULLSCREEN window flag
  /// is usually a better approach.  The state set here will be removed by the system
  /// in various situations (such as the user moving to another application) like
  /// the other system UI states.
  ///
  /// When using this flag, the application should provide some easy facility
  /// for the user to go out of it.  A common example would be in an e-book
  /// reader, where tapping on the screen brings back whatever screen and UI
  /// decorations that had been hidden while the user was immersed in reading
  /// the book.
  ///@see \#setSystemUiVisibility(int)
  static const SYSTEM_UI_FLAG_FULLSCREEN = 4;

  /// from: static public final int SYSTEM_UI_FLAG_HIDE_NAVIGATION
  ///
  /// Flag for \#setSystemUiVisibility(int): View has requested that the
  /// system navigation be temporarily hidden.
  ///
  /// This is an even less obtrusive state than that called for by
  /// \#SYSTEM_UI_FLAG_LOW_PROFILE; on devices that draw essential navigation controls
  /// (Home, Back, and the like) on screen, <code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code> will cause
  /// those to disappear. This is useful (in conjunction with the
  /// android.view.WindowManager.LayoutParams\#FLAG_FULLSCREEN FLAG_FULLSCREEN and
  /// android.view.WindowManager.LayoutParams\#FLAG_LAYOUT_IN_SCREEN FLAG_LAYOUT_IN_SCREEN
  /// window flags) for displaying content using every last pixel on the display.
  ///
  /// There is a limitation: because navigation controls are so important, the least user
  /// interaction will cause them to reappear immediately.  When this happens, both
  /// this flag and \#SYSTEM_UI_FLAG_FULLSCREEN will be cleared automatically,
  /// so that both elements reappear at the same time.
  ///@see \#setSystemUiVisibility(int)
  static const SYSTEM_UI_FLAG_HIDE_NAVIGATION = 2;

  /// from: static public final int SYSTEM_UI_FLAG_IMMERSIVE
  ///
  /// Flag for \#setSystemUiVisibility(int): View would like to remain interactive when
  /// hiding the navigation bar with \#SYSTEM_UI_FLAG_HIDE_NAVIGATION.  If this flag is
  /// not set, \#SYSTEM_UI_FLAG_HIDE_NAVIGATION will be force cleared by the system on any
  /// user interaction.
  /// Since this flag is a modifier for \#SYSTEM_UI_FLAG_HIDE_NAVIGATION, it only
  /// has an effect when used in combination with that flag.
  ///
  static const SYSTEM_UI_FLAG_IMMERSIVE = 2048;

  /// from: static public final int SYSTEM_UI_FLAG_IMMERSIVE_STICKY
  ///
  /// Flag for \#setSystemUiVisibility(int): View would like to remain interactive when
  /// hiding the status bar with \#SYSTEM_UI_FLAG_FULLSCREEN and/or hiding the navigation
  /// bar with \#SYSTEM_UI_FLAG_HIDE_NAVIGATION.  Use this flag to create an immersive
  /// experience while also hiding the system bars.  If this flag is not set,
  /// \#SYSTEM_UI_FLAG_HIDE_NAVIGATION will be force cleared by the system on any user
  /// interaction, and \#SYSTEM_UI_FLAG_FULLSCREEN will be force-cleared by the system
  /// if the user swipes from the top of the screen.
  /// When system bars are hidden in immersive mode, they can be revealed temporarily with
  /// system gestures, such as swiping from the top of the screen.  These transient system bars
  /// will overlay app\u2019s content, may have some degree of transparency, and will automatically
  /// hide after a short timeout.
  ///
  ///Since this flag is a modifier for \#SYSTEM_UI_FLAG_FULLSCREEN and
  /// \#SYSTEM_UI_FLAG_HIDE_NAVIGATION, it only has an effect when used in combination
  /// with one or both of those flags.
  ///
  static const SYSTEM_UI_FLAG_IMMERSIVE_STICKY = 4096;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
  ///
  /// Flag for \#setSystemUiVisibility(int): View would like its window
  /// to be laid out as if it has requested
  /// \#SYSTEM_UI_FLAG_FULLSCREEN, even if it currently hasn't.  This
  /// allows it to avoid artifacts when switching in and out of that mode, at
  /// the expense that some of its user interface may be covered by screen
  /// decorations when they are shown.  You can perform layout of your inner
  /// UI elements to account for non-fullscreen system UI through the
  /// \#fitSystemWindows(Rect) method.
  ///
  /// Note: on displays that have a DisplayCutout, the window may still be placed
  ///  differently than if \#SYSTEM_UI_FLAG_FULLSCREEN was set, if the
  ///  window's WindowManager.LayoutParams\#layoutInDisplayCutoutMode layoutInDisplayCutoutMode is
  ///  WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT. To avoid this, use either of the other modes.
  ///@see WindowManager.LayoutParams\#layoutInDisplayCutoutMode
  ///@see WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
  ///@see WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS
  ///@see WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER
  static const SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN = 1024;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
  ///
  /// Flag for \#setSystemUiVisibility(int): View would like its window
  /// to be laid out as if it has requested
  /// \#SYSTEM_UI_FLAG_HIDE_NAVIGATION, even if it currently hasn't.  This
  /// allows it to avoid artifacts when switching in and out of that mode, at
  /// the expense that some of its user interface may be covered by screen
  /// decorations when they are shown.  You can perform layout of your inner
  /// UI elements to account for the navigation system UI through the
  /// \#fitSystemWindows(Rect) method.
  static const SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION = 512;

  /// from: static public final int SYSTEM_UI_FLAG_LAYOUT_STABLE
  ///
  /// Flag for \#setSystemUiVisibility(int): When using other layout
  /// flags, we would like a stable view of the content insets given to
  /// \#fitSystemWindows(Rect).  This means that the insets seen there
  /// will always represent the worst case that the application can expect
  /// as a continuous state.  In the stock Android UI this is the space for
  /// the system bar, nav bar, and status bar, but not more transient elements
  /// such as an input method.
  ///
  /// The stable layout your UI sees is based on the system UI modes you can
  /// switch to.  That is, if you specify \#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
  /// then you will get a stable layout for changes of the
  /// \#SYSTEM_UI_FLAG_FULLSCREEN mode; if you specify
  /// \#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN and
  /// \#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION, then you can transition
  /// to \#SYSTEM_UI_FLAG_FULLSCREEN and \#SYSTEM_UI_FLAG_HIDE_NAVIGATION
  /// with a stable layout.  (Note that you should avoid using
  /// \#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION by itself.)
  ///
  /// If you have set the window flag WindowManager.LayoutParams\#FLAG_FULLSCREEN
  /// to hide the status bar (instead of using \#SYSTEM_UI_FLAG_FULLSCREEN),
  /// then a hidden status bar will be considered a "stable" state for purposes
  /// here.  This allows your UI to continually hide the status bar, while still
  /// using the system UI flags to hide the action bar while still retaining
  /// a stable layout.  Note that changing the window fullscreen flag will never
  /// provide a stable layout for a clean transition.
  ///
  /// If you are using ActionBar in
  /// overlay mode with Window\#FEATURE_ACTION_BAR_OVERLAY Window.FEATURE_ACTION_BAR_OVERLAY, this flag will also impact the
  /// insets it adds to those given to the application.
  static const SYSTEM_UI_FLAG_LAYOUT_STABLE = 256;

  /// from: static public final int SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR
  ///
  /// Flag for \#setSystemUiVisibility(int): Requests the navigation bar to draw in a mode
  /// that is compatible with light navigation bar backgrounds.
  ///
  /// For this to take effect, the window must request
  /// android.view.WindowManager.LayoutParams\#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS but not
  /// android.view.WindowManager.LayoutParams\#FLAG_TRANSLUCENT_NAVIGATION FLAG_TRANSLUCENT_NAVIGATION.
  ///@see android.R.attr\#windowLightNavigationBar
  static const SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR = 16;

  /// from: static public final int SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
  ///
  /// Flag for \#setSystemUiVisibility(int): Requests the status bar to draw in a mode that
  /// is compatible with light status bar backgrounds.
  ///
  /// For this to take effect, the window must request
  /// android.view.WindowManager.LayoutParams\#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS but not
  /// android.view.WindowManager.LayoutParams\#FLAG_TRANSLUCENT_STATUS FLAG_TRANSLUCENT_STATUS.
  ///@see android.R.attr\#windowLightStatusBar
  static const SYSTEM_UI_FLAG_LIGHT_STATUS_BAR = 8192;

  /// from: static public final int SYSTEM_UI_FLAG_LOW_PROFILE
  ///
  /// Flag for \#setSystemUiVisibility(int): View has requested the
  /// system UI to enter an unobtrusive "low profile" mode.
  ///
  /// This is for use in games, book readers, video players, or any other
  /// "immersive" application where the usual system chrome is deemed too distracting.
  ///
  /// In low profile mode, the status bar and/or navigation icons may dim.
  ///@see \#setSystemUiVisibility(int)
  static const SYSTEM_UI_FLAG_LOW_PROFILE = 1;

  /// from: static public final int SYSTEM_UI_FLAG_VISIBLE
  ///
  /// Special constant for \#setSystemUiVisibility(int): View has
  /// requested the system UI (status bar) to be visible (the default).
  ///@see \#setSystemUiVisibility(int)
  static const SYSTEM_UI_FLAG_VISIBLE = 0;

  /// from: static public final int SYSTEM_UI_LAYOUT_FLAGS
  ///
  /// Flags that can impact the layout in relation to system UI.
  static const SYSTEM_UI_LAYOUT_FLAGS = 1536;

  /// from: static public final int TEXT_ALIGNMENT_CENTER
  ///
  /// Center the paragraph, e.g.&nbsp;ALIGN_CENTER.
  ///
  /// Use with \#setTextAlignment(int)
  static const TEXT_ALIGNMENT_CENTER = 4;

  /// from: static public final int TEXT_ALIGNMENT_GRAVITY
  ///
  /// Default for the root view. The gravity determines the text alignment, ALIGN_NORMAL,
  /// ALIGN_CENTER, or ALIGN_OPPOSITE, which are relative to each paragraph\u2019s text direction.
  ///
  /// Use with \#setTextAlignment(int)
  static const TEXT_ALIGNMENT_GRAVITY = 1;

  /// from: static public final int TEXT_ALIGNMENT_INHERIT
  ///
  /// Default text alignment. The text alignment of this View is inherited from its parent.
  /// Use with \#setTextAlignment(int)
  static const TEXT_ALIGNMENT_INHERIT = 0;

  /// from: static public final int TEXT_ALIGNMENT_TEXT_END
  ///
  /// Align to the end of the paragraph, e.g.&nbsp;ALIGN_OPPOSITE.
  ///
  /// Use with \#setTextAlignment(int)
  static const TEXT_ALIGNMENT_TEXT_END = 3;

  /// from: static public final int TEXT_ALIGNMENT_TEXT_START
  ///
  /// Align to the start of the paragraph, e.g.&nbsp;ALIGN_NORMAL.
  ///
  /// Use with \#setTextAlignment(int)
  static const TEXT_ALIGNMENT_TEXT_START = 2;

  /// from: static public final int TEXT_ALIGNMENT_VIEW_END
  ///
  /// Align to the end of the view, which is ALIGN_RIGHT if the view\u2019s resolved
  /// layoutDirection is LTR, and ALIGN_LEFT otherwise.
  ///
  /// Use with \#setTextAlignment(int)
  static const TEXT_ALIGNMENT_VIEW_END = 6;

  /// from: static public final int TEXT_ALIGNMENT_VIEW_START
  ///
  /// Align to the start of the view, which is ALIGN_LEFT if the view\u2019s resolved
  /// layoutDirection is LTR, and ALIGN_RIGHT otherwise.
  ///
  /// Use with \#setTextAlignment(int)
  static const TEXT_ALIGNMENT_VIEW_START = 5;

  /// from: static public final int TEXT_DIRECTION_ANY_RTL
  ///
  /// Text direction is using "any-RTL" algorithm. The paragraph direction is RTL if it contains
  /// any strong RTL character, otherwise it is LTR if it contains any strong LTR characters.
  /// If there are neither, the paragraph direction is the view's resolved layout direction.
  static const TEXT_DIRECTION_ANY_RTL = 2;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG
  ///
  /// Text direction is using "first strong algorithm". The first strong directional character
  /// determines the paragraph direction. If there is no strong directional character, the
  /// paragraph direction is the view's resolved layout direction.
  static const TEXT_DIRECTION_FIRST_STRONG = 1;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG_LTR
  ///
  /// Text direction is using "first strong algorithm". The first strong directional character
  /// determines the paragraph direction. If there is no strong directional character, the
  /// paragraph direction is LTR.
  static const TEXT_DIRECTION_FIRST_STRONG_LTR = 6;

  /// from: static public final int TEXT_DIRECTION_FIRST_STRONG_RTL
  ///
  /// Text direction is using "first strong algorithm". The first strong directional character
  /// determines the paragraph direction. If there is no strong directional character, the
  /// paragraph direction is RTL.
  static const TEXT_DIRECTION_FIRST_STRONG_RTL = 7;

  /// from: static public final int TEXT_DIRECTION_INHERIT
  ///
  /// Text direction is inherited through ViewGroup
  static const TEXT_DIRECTION_INHERIT = 0;

  /// from: static public final int TEXT_DIRECTION_LOCALE
  ///
  /// Text direction is coming from the system Locale.
  static const TEXT_DIRECTION_LOCALE = 5;

  /// from: static public final int TEXT_DIRECTION_LTR
  ///
  /// Text direction is forced to LTR.
  static const TEXT_DIRECTION_LTR = 3;

  /// from: static public final int TEXT_DIRECTION_RTL
  ///
  /// Text direction is forced to RTL.
  static const TEXT_DIRECTION_RTL = 4;

  static final _id_TRANSLATION_X = jniAccessors.getStaticFieldIDOf(
      _classRef, "TRANSLATION_X", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> TRANSLATION_X
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>translationX</code> functionality handled by the
  /// View\#setTranslationX(float) and View\#getTranslationX() methods.
  static property_.Property get TRANSLATION_X =>
      property_.Property.fromRef(jniAccessors
          .getStaticField(_classRef, _id_TRANSLATION_X, jni.JniType.objectType)
          .object);

  static final _id_TRANSLATION_Y = jniAccessors.getStaticFieldIDOf(
      _classRef, "TRANSLATION_Y", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> TRANSLATION_Y
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>translationY</code> functionality handled by the
  /// View\#setTranslationY(float) and View\#getTranslationY() methods.
  static property_.Property get TRANSLATION_Y =>
      property_.Property.fromRef(jniAccessors
          .getStaticField(_classRef, _id_TRANSLATION_Y, jni.JniType.objectType)
          .object);

  static final _id_TRANSLATION_Z = jniAccessors.getStaticFieldIDOf(
      _classRef, "TRANSLATION_Z", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> TRANSLATION_Z
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>translationZ</code> functionality handled by the
  /// View\#setTranslationZ(float) and View\#getTranslationZ() methods.
  static property_.Property get TRANSLATION_Z =>
      property_.Property.fromRef(jniAccessors
          .getStaticField(_classRef, _id_TRANSLATION_Z, jni.JniType.objectType)
          .object);

  /// from: static protected final java.lang.String VIEW_LOG_TAG
  ///
  /// The logging tag used by this class with android.util.Log.
  static const VIEW_LOG_TAG = "View";

  /// from: static public final int VISIBLE
  ///
  /// This view is visible.
  /// Use with \#setVisibility and <a href="\#attr_android:visibility">{@code
  /// android:visibility}.
  static const VISIBLE = 0;

  static final _id_WINDOW_FOCUSED_STATE_SET = jniAccessors.getStaticFieldIDOf(
      _classRef, "WINDOW_FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] WINDOW_FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the view's window has focus. States are used with
  /// android.graphics.drawable.Drawable to change the drawing of the
  /// view depending on its state.
  ///@see android.graphics.drawable.Drawable
  ///@see \#getDrawableState()
  static jni.JniObject get WINDOW_FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_WINDOW_FOCUSED_STATE_SET, jni.JniType.objectType)
          .object);

  static final _id_X = jniAccessors.getStaticFieldIDOf(
      _classRef, "X", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> X
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>x</code> functionality handled by the
  /// View\#setX(float) and View\#getX() methods.
  static property_.Property get X => property_.Property.fromRef(jniAccessors
      .getStaticField(_classRef, _id_X, jni.JniType.objectType)
      .object);

  static final _id_Y = jniAccessors.getStaticFieldIDOf(
      _classRef, "Y", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> Y
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>y</code> functionality handled by the
  /// View\#setY(float) and View\#getY() methods.
  static property_.Property get Y => property_.Property.fromRef(jniAccessors
      .getStaticField(_classRef, _id_Y, jni.JniType.objectType)
      .object);

  static final _id_Z = jniAccessors.getStaticFieldIDOf(
      _classRef, "Z", "Landroid/util/Property;");

  /// from: static public final android.util.Property<android.view.View,java.lang.Float> Z
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A Property wrapper around the <code>z</code> functionality handled by the
  /// View\#setZ(float) and View\#getZ() methods.
  static property_.Property get Z => property_.Property.fromRef(jniAccessors
      .getStaticField(_classRef, _id_Z, jni.JniType.objectType)
      .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Simple constructor to use when creating a view from code.
  ///@param context The Context the view is running in, through which it can
  ///        access the current theme, resources, etc.
  View(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor that is called when inflating a view from XML. This is called
  /// when a view is being constructed from an XML file, supplying attributes
  /// that were specified in the XML file. This version uses a default style of
  /// 0, so the only attribute values applied are those in the Context's Theme
  /// and the given AttributeSet.
  ///
  ///
  /// The method onFinishInflate() will be called after all children have been
  /// added.
  ///@param context The Context the view is running in, through which it can
  ///        access the current theme, resources, etc.
  ///@param attrs The attributes of the XML tag that is inflating the view.
  /// This value may be {@code null}.
  ///@see \#View(Context, AttributeSet, int)
  View.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform inflation from XML and apply a class-specific base style from a
  /// theme attribute. This constructor of View allows subclasses to use their
  /// own base style when they are inflating. For example, a Button class's
  /// constructor would call this version of the super class constructor and
  /// supply <code>R.attr.buttonStyle</code> for <var>defStyleAttr</var>; this
  /// allows the theme's button style to modify all of the base view attributes
  /// (in particular its background) as well as the Button class's attributes.
  ///@param context The Context the view is running in, through which it can
  ///        access the current theme, resources, etc.
  ///@param attrs The attributes of the XML tag that is inflating the view.
  /// This value may be {@code null}.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  ///@see \#View(Context, AttributeSet)
  View.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform inflation from XML and apply a class-specific base style from a
  /// theme attribute or style resource. This constructor of View allows
  /// subclasses to use their own base style when they are inflating.
  ///
  /// When determining the final value of a particular attribute, there are
  /// four inputs that come into play:
  /// <ol>
  /// <li>Any attribute values in the given AttributeSet.
  /// <li>The style resource specified in the AttributeSet (named "style").
  /// <li>The default style specified by <var>defStyleAttr</var>.
  /// <li>The default style specified by <var>defStyleRes</var>.
  /// <li>The base values in this theme.
  /// </ol>
  ///
  /// Each of these inputs is considered in-order, with the first listed taking
  /// precedence over the following ones. In other words, if in the
  /// AttributeSet you have supplied <code>&lt;Button * textColor="\#ff000000"&gt;</code>
  /// , then the button's text will _always_ be black, regardless of
  /// what is specified in any of the styles.
  ///@param context The Context the view is running in, through which it can
  ///        access the current theme, resources, etc.
  ///@param attrs The attributes of the XML tag that is inflating the view.
  /// This value may be {@code null}.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  ///@param defStyleRes A resource identifier of a style resource that
  ///        supplies default values for the view, used only if
  ///        defStyleAttr is 0 or can not be found in the theme. Can be 0
  ///        to not look for defaults.
  ///@see \#View(Context, AttributeSet, int)
  View.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_getVerticalFadingEdgeLength = jniAccessors.getMethodIDOf(
      _classRef, "getVerticalFadingEdgeLength", "()I");

  /// from: public int getVerticalFadingEdgeLength()
  ///
  /// Returns the size of the vertical faded edges used to indicate that more
  /// content in this view is visible.
  ///@return The size in pixels of the vertical faded edge or 0 if vertical
  ///         faded edges are not enabled for this view.
  ///@attr ref android.R.styleable\#View_fadingEdgeLength
  int getVerticalFadingEdgeLength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getVerticalFadingEdgeLength,
      jni.JniType.intType, []).integer;

  static final _id_setFadingEdgeLength =
      jniAccessors.getMethodIDOf(_classRef, "setFadingEdgeLength", "(I)V");

  /// from: public void setFadingEdgeLength(int length)
  ///
  /// Set the size of the faded edge used to indicate that more content in this
  /// view is available.  Will not change whether the fading edge is enabled; use
  /// \#setVerticalFadingEdgeEnabled(boolean) or
  /// \#setHorizontalFadingEdgeEnabled(boolean) to enable the fading edge
  /// for the vertical or horizontal fading edges.
  ///@param length The size in pixels of the faded edge used to indicate that more
  ///        content in this view is visible.
  void setFadingEdgeLength(int length) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFadingEdgeLength,
      jni.JniType.voidType,
      [length]).check();

  static final _id_getHorizontalFadingEdgeLength = jniAccessors.getMethodIDOf(
      _classRef, "getHorizontalFadingEdgeLength", "()I");

  /// from: public int getHorizontalFadingEdgeLength()
  ///
  /// Returns the size of the horizontal faded edges used to indicate that more
  /// content in this view is visible.
  ///@return The size in pixels of the horizontal faded edge or 0 if horizontal
  ///         faded edges are not enabled for this view.
  ///@attr ref android.R.styleable\#View_fadingEdgeLength
  int getHorizontalFadingEdgeLength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHorizontalFadingEdgeLength,
      jni.JniType.intType, []).integer;

  static final _id_getVerticalScrollbarWidth =
      jniAccessors.getMethodIDOf(_classRef, "getVerticalScrollbarWidth", "()I");

  /// from: public int getVerticalScrollbarWidth()
  ///
  /// Returns the width of the vertical scrollbar.
  ///@return The width in pixels of the vertical scrollbar or 0 if there
  ///         is no vertical scrollbar.
  int getVerticalScrollbarWidth() => jniAccessors.callMethodWithArgs(reference,
      _id_getVerticalScrollbarWidth, jni.JniType.intType, []).integer;

  static final _id_getHorizontalScrollbarHeight = jniAccessors.getMethodIDOf(
      _classRef, "getHorizontalScrollbarHeight", "()I");

  /// from: protected int getHorizontalScrollbarHeight()
  ///
  /// Returns the height of the horizontal scrollbar.
  ///@return The height in pixels of the horizontal scrollbar or 0 if
  ///         there is no horizontal scrollbar.
  int getHorizontalScrollbarHeight() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHorizontalScrollbarHeight,
      jni.JniType.intType, []).integer;

  static final _id_setVerticalScrollbarPosition = jniAccessors.getMethodIDOf(
      _classRef, "setVerticalScrollbarPosition", "(I)V");

  /// from: public void setVerticalScrollbarPosition(int position)
  ///
  /// Set the position of the vertical scroll bar. Should be one of
  /// \#SCROLLBAR_POSITION_DEFAULT, \#SCROLLBAR_POSITION_LEFT or
  /// \#SCROLLBAR_POSITION_RIGHT.
  ///@param position Where the vertical scroll bar should be positioned.
  void setVerticalScrollbarPosition(int position) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVerticalScrollbarPosition,
          jni.JniType.voidType,
          [position]).check();

  static final _id_getVerticalScrollbarPosition = jniAccessors.getMethodIDOf(
      _classRef, "getVerticalScrollbarPosition", "()I");

  /// from: public int getVerticalScrollbarPosition()
  ///
  /// @return The position where the vertical scroll bar will show, if applicable.
  ///@see \#setVerticalScrollbarPosition(int)
  int getVerticalScrollbarPosition() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getVerticalScrollbarPosition,
      jni.JniType.intType, []).integer;

  static final _id_setScrollIndicators =
      jniAccessors.getMethodIDOf(_classRef, "setScrollIndicators", "(I)V");

  /// from: public void setScrollIndicators(int indicators)
  ///
  /// Sets the state of all scroll indicators.
  ///
  /// See \#setScrollIndicators(int, int) for usage information.
  ///@param indicators a bitmask of indicators that should be enabled, or
  ///                   {@code 0} to disable all indicators
  /// Value is either <code>0</code> or a combination of android.view.View\#SCROLL_INDICATOR_TOP, android.view.View\#SCROLL_INDICATOR_BOTTOM, android.view.View\#SCROLL_INDICATOR_LEFT, android.view.View\#SCROLL_INDICATOR_RIGHT, android.view.View\#SCROLL_INDICATOR_START, and android.view.View\#SCROLL_INDICATOR_END
  ///@see \#setScrollIndicators(int, int)
  ///@see \#getScrollIndicators()
  ///@attr ref android.R.styleable\#View_scrollIndicators
  void setScrollIndicators(int indicators) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setScrollIndicators,
      jni.JniType.voidType,
      [indicators]).check();

  static final _id_setScrollIndicators1 =
      jniAccessors.getMethodIDOf(_classRef, "setScrollIndicators", "(II)V");

  /// from: public void setScrollIndicators(int indicators, int mask)
  ///
  /// Sets the state of the scroll indicators specified by the mask. To change
  /// all scroll indicators at once, see \#setScrollIndicators(int).
  ///
  /// When a scroll indicator is enabled, it will be displayed if the view
  /// can scroll in the direction of the indicator.
  ///
  /// Multiple indicator types may be enabled or disabled by passing the
  /// logical OR of the desired types. If multiple types are specified, they
  /// will all be set to the same enabled state.
  ///
  /// For example, to enable the top scroll indicatorExample: {@code setScrollIndicators
  ///@param indicators the indicator direction, or the logical OR of multiple
  ///             indicator directions. One or more of:
  ///             <ul>
  ///               <li>\#SCROLL_INDICATOR_TOP</li>
  ///               <li>\#SCROLL_INDICATOR_BOTTOM</li>
  ///               <li>\#SCROLL_INDICATOR_LEFT</li>
  ///               <li>\#SCROLL_INDICATOR_RIGHT</li>
  ///               <li>\#SCROLL_INDICATOR_START</li>
  ///               <li>\#SCROLL_INDICATOR_END</li>
  ///             </ul>
  ///@see \#setScrollIndicators(int)
  ///@see \#getScrollIndicators()
  ///@attr ref android.R.styleable\#View_scrollIndicators
  ///@param indicators Value is either <code>0</code> or a combination of android.view.View\#SCROLL_INDICATOR_TOP, android.view.View\#SCROLL_INDICATOR_BOTTOM, android.view.View\#SCROLL_INDICATOR_LEFT, android.view.View\#SCROLL_INDICATOR_RIGHT, android.view.View\#SCROLL_INDICATOR_START, and android.view.View\#SCROLL_INDICATOR_END
  ///@param mask Value is either <code>0</code> or a combination of android.view.View\#SCROLL_INDICATOR_TOP, android.view.View\#SCROLL_INDICATOR_BOTTOM, android.view.View\#SCROLL_INDICATOR_LEFT, android.view.View\#SCROLL_INDICATOR_RIGHT, android.view.View\#SCROLL_INDICATOR_START, and android.view.View\#SCROLL_INDICATOR_END
  void setScrollIndicators1(int indicators, int mask) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScrollIndicators1,
          jni.JniType.voidType, [indicators, mask]).check();

  static final _id_getScrollIndicators =
      jniAccessors.getMethodIDOf(_classRef, "getScrollIndicators", "()I");

  /// from: public int getScrollIndicators()
  ///
  /// Returns a bitmask representing the enabled scroll indicators.
  ///
  /// For example, if the top and left scroll indicators are enabled and all
  /// other indicators are disabled, the return value will be
  /// {@code View.SCROLL_INDICATOR_TOP | View.SCROLL_INDICATOR_LEFT}.
  ///
  /// To check whether the bottom scroll indicator is enabled, use the value
  /// of {@code (getScrollIndicators() & View.SCROLL_INDICATOR_BOTTOM) != 0}.
  ///@return a bitmask representing the enabled scroll indicators
  ///
  /// Value is either <code>0</code> or a combination of android.view.View\#SCROLL_INDICATOR_TOP, android.view.View\#SCROLL_INDICATOR_BOTTOM, android.view.View\#SCROLL_INDICATOR_LEFT, android.view.View\#SCROLL_INDICATOR_RIGHT, android.view.View\#SCROLL_INDICATOR_START, and android.view.View\#SCROLL_INDICATOR_END
  int getScrollIndicators() => jniAccessors.callMethodWithArgs(
      reference, _id_getScrollIndicators, jni.JniType.intType, []).integer;

  static final _id_setOnScrollChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnScrollChangeListener",
      "(Landroid/view/View\$OnScrollChangeListener;)V");

  /// from: public void setOnScrollChangeListener(android.view.View.OnScrollChangeListener l)
  ///
  /// Register a callback to be invoked when the scroll X or Y positions of
  /// this view change.
  ///
  /// __Note:__ Some views handle scrolling independently from View and may
  /// have their own separate listeners for scroll-type events. For example,
  /// android.widget.ListView ListView allows clients to register an
  /// android.widget.ListView\#setOnScrollListener(android.widget.AbsListView.OnScrollListener) AbsListView.OnScrollListener
  /// to listen for changes in list scroll position.
  ///@param l The listener to notify when the scroll X or Y position changes.
  ///@see android.view.View\#getScrollX()
  ///@see android.view.View\#getScrollY()
  void setOnScrollChangeListener(View_OnScrollChangeListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnScrollChangeListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnFocusChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnFocusChangeListener",
      "(Landroid/view/View\$OnFocusChangeListener;)V");

  /// from: public void setOnFocusChangeListener(android.view.View.OnFocusChangeListener l)
  ///
  /// Register a callback to be invoked when focus of this view changed.
  ///@param l The callback that will run.
  void setOnFocusChangeListener(View_OnFocusChangeListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnFocusChangeListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_addOnLayoutChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnLayoutChangeListener",
      "(Landroid/view/View\$OnLayoutChangeListener;)V");

  /// from: public void addOnLayoutChangeListener(android.view.View.OnLayoutChangeListener listener)
  ///
  /// Add a listener that will be called when the bounds of the view change due to
  /// layout processing.
  ///@param listener The listener that will be called when layout bounds change.
  void addOnLayoutChangeListener(View_OnLayoutChangeListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addOnLayoutChangeListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_removeOnLayoutChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnLayoutChangeListener",
      "(Landroid/view/View\$OnLayoutChangeListener;)V");

  /// from: public void removeOnLayoutChangeListener(android.view.View.OnLayoutChangeListener listener)
  ///
  /// Remove a listener for layout changes.
  ///@param listener The listener for layout bounds change.
  void removeOnLayoutChangeListener(View_OnLayoutChangeListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnLayoutChangeListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_addOnAttachStateChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnAttachStateChangeListener",
      "(Landroid/view/View\$OnAttachStateChangeListener;)V");

  /// from: public void addOnAttachStateChangeListener(android.view.View.OnAttachStateChangeListener listener)
  ///
  /// Add a listener for attach state changes.
  ///
  /// This listener will be called whenever this view is attached or detached
  /// from a window. Remove the listener using
  /// \#removeOnAttachStateChangeListener(OnAttachStateChangeListener).
  ///@param listener Listener to attach
  ///@see \#removeOnAttachStateChangeListener(OnAttachStateChangeListener)
  void addOnAttachStateChangeListener(
          View_OnAttachStateChangeListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnAttachStateChangeListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_removeOnAttachStateChangeListener =
      jniAccessors.getMethodIDOf(_classRef, "removeOnAttachStateChangeListener",
          "(Landroid/view/View\$OnAttachStateChangeListener;)V");

  /// from: public void removeOnAttachStateChangeListener(android.view.View.OnAttachStateChangeListener listener)
  ///
  /// Remove a listener for attach state changes. The listener will receive no further
  /// notification of window attach/detach events.
  ///@param listener Listener to remove
  ///@see \#addOnAttachStateChangeListener(OnAttachStateChangeListener)
  void removeOnAttachStateChangeListener(
          View_OnAttachStateChangeListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnAttachStateChangeListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_getOnFocusChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "getOnFocusChangeListener",
      "()Landroid/view/View\$OnFocusChangeListener;");

  /// from: public android.view.View.OnFocusChangeListener getOnFocusChangeListener()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the focus-change callback registered for this view.
  ///@return The callback, or null if one is not registered.
  View_OnFocusChangeListener getOnFocusChangeListener() =>
      View_OnFocusChangeListener.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getOnFocusChangeListener,
          jni.JniType.objectType, []).object);

  static final _id_setOnClickListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnClickListener", "(Landroid/view/View\$OnClickListener;)V");

  /// from: public void setOnClickListener(android.view.View.OnClickListener l)
  ///
  /// Register a callback to be invoked when this view is clicked. If this view is not
  /// clickable, it becomes clickable.
  ///@param l The callback that will run
  ///
  /// This value may be {@code null}.
  ///@see \#setClickable(boolean)
  void setOnClickListener(View_OnClickListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnClickListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_hasOnClickListeners =
      jniAccessors.getMethodIDOf(_classRef, "hasOnClickListeners", "()Z");

  /// from: public boolean hasOnClickListeners()
  ///
  /// Return whether this view has an attached OnClickListener.  Returns
  /// true if there is a listener, false if there is none.
  bool hasOnClickListeners() => jniAccessors.callMethodWithArgs(
      reference, _id_hasOnClickListeners, jni.JniType.booleanType, []).boolean;

  static final _id_setOnLongClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnLongClickListener",
      "(Landroid/view/View\$OnLongClickListener;)V");

  /// from: public void setOnLongClickListener(android.view.View.OnLongClickListener l)
  ///
  /// Register a callback to be invoked when this view is clicked and held. If this view is not
  /// long clickable, it becomes long clickable.
  ///@param l The callback that will run
  ///
  /// This value may be {@code null}.
  ///@see \#setLongClickable(boolean)
  void setOnLongClickListener(View_OnLongClickListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnLongClickListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnContextClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnContextClickListener",
      "(Landroid/view/View\$OnContextClickListener;)V");

  /// from: public void setOnContextClickListener(android.view.View.OnContextClickListener l)
  ///
  /// Register a callback to be invoked when this view is context clicked. If the view is not
  /// context clickable, it becomes context clickable.
  ///@param l The callback that will run
  /// This value may be {@code null}.
  ///@see \#setContextClickable(boolean)
  void setOnContextClickListener(View_OnContextClickListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnContextClickListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnCreateContextMenuListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnCreateContextMenuListener",
      "(Landroid/view/View\$OnCreateContextMenuListener;)V");

  /// from: public void setOnCreateContextMenuListener(android.view.View.OnCreateContextMenuListener l)
  ///
  /// Register a callback to be invoked when the context menu for this view is
  /// being built. If this view is not long clickable, it becomes long clickable.
  ///@param l The callback that will run
  void setOnCreateContextMenuListener(View_OnCreateContextMenuListener l) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnCreateContextMenuListener,
          jni.JniType.voidType,
          [l.reference]).check();

  static final _id_performClick =
      jniAccessors.getMethodIDOf(_classRef, "performClick", "()Z");

  /// from: public boolean performClick()
  ///
  /// Call this view's OnClickListener, if it is defined.  Performs all normal
  /// actions associated with clicking: reporting accessibility event, playing
  /// a sound, etc.
  ///@return True there was an assigned OnClickListener that was called, false
  ///         otherwise is returned.
  bool performClick() => jniAccessors.callMethodWithArgs(
      reference, _id_performClick, jni.JniType.booleanType, []).boolean;

  static final _id_callOnClick =
      jniAccessors.getMethodIDOf(_classRef, "callOnClick", "()Z");

  /// from: public boolean callOnClick()
  ///
  /// Directly call any attached OnClickListener.  Unlike \#performClick(),
  /// this only calls the listener, and does not do any associated clicking
  /// actions like reporting an accessibility event.
  ///@return True there was an assigned OnClickListener that was called, false
  ///         otherwise is returned.
  bool callOnClick() => jniAccessors.callMethodWithArgs(
      reference, _id_callOnClick, jni.JniType.booleanType, []).boolean;

  static final _id_performLongClick =
      jniAccessors.getMethodIDOf(_classRef, "performLongClick", "()Z");

  /// from: public boolean performLongClick()
  ///
  /// Calls this view's OnLongClickListener, if it is defined. Invokes the
  /// context menu if the OnLongClickListener did not consume the event.
  ///@return {@code true} if one of the above receivers consumed the event,
  ///         {@code false} otherwise
  bool performLongClick() => jniAccessors.callMethodWithArgs(
      reference, _id_performLongClick, jni.JniType.booleanType, []).boolean;

  static final _id_performLongClick1 =
      jniAccessors.getMethodIDOf(_classRef, "performLongClick", "(FF)Z");

  /// from: public boolean performLongClick(float x, float y)
  ///
  /// Calls this view's OnLongClickListener, if it is defined. Invokes the
  /// context menu if the OnLongClickListener did not consume the event,
  /// anchoring it to an (x,y) coordinate.
  ///@param x x coordinate of the anchoring touch event, or Float\#NaN
  ///          to disable anchoring
  ///@param y y coordinate of the anchoring touch event, or Float\#NaN
  ///          to disable anchoring
  ///@return {@code true} if one of the above receivers consumed the event,
  ///         {@code false} otherwise
  bool performLongClick1(double x, double y) => jniAccessors.callMethodWithArgs(
      reference,
      _id_performLongClick1,
      jni.JniType.booleanType,
      [x, y]).boolean;

  static final _id_performContextClick =
      jniAccessors.getMethodIDOf(_classRef, "performContextClick", "(FF)Z");

  /// from: public boolean performContextClick(float x, float y)
  ///
  /// Call this view's OnContextClickListener, if it is defined.
  ///@param x the x coordinate of the context click
  ///@param y the y coordinate of the context click
  ///@return True if there was an assigned OnContextClickListener that consumed the event, false
  ///         otherwise.
  bool performContextClick(double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_performContextClick,
          jni.JniType.booleanType, [x, y]).boolean;

  static final _id_performContextClick1 =
      jniAccessors.getMethodIDOf(_classRef, "performContextClick", "()Z");

  /// from: public boolean performContextClick()
  ///
  /// Call this view's OnContextClickListener, if it is defined.
  ///@return True if there was an assigned OnContextClickListener that consumed the event, false
  ///         otherwise.
  bool performContextClick1() => jniAccessors.callMethodWithArgs(
      reference, _id_performContextClick1, jni.JniType.booleanType, []).boolean;

  static final _id_showContextMenu =
      jniAccessors.getMethodIDOf(_classRef, "showContextMenu", "()Z");

  /// from: public boolean showContextMenu()
  ///
  /// Shows the context menu for this view.
  ///@return {@code true} if the context menu was shown, {@code false}
  ///         otherwise
  ///@see \#showContextMenu(float, float)
  bool showContextMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_showContextMenu, jni.JniType.booleanType, []).boolean;

  static final _id_showContextMenu1 =
      jniAccessors.getMethodIDOf(_classRef, "showContextMenu", "(FF)Z");

  /// from: public boolean showContextMenu(float x, float y)
  ///
  /// Shows the context menu for this view anchored to the specified
  /// view-relative coordinate.
  ///@param x the X coordinate in pixels relative to the view to which the
  ///          menu should be anchored, or Float\#NaN to disable anchoring
  ///@param y the Y coordinate in pixels relative to the view to which the
  ///          menu should be anchored, or Float\#NaN to disable anchoring
  ///@return {@code true} if the context menu was shown, {@code false}
  ///         otherwise
  bool showContextMenu1(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_showContextMenu1, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_startActionMode = jniAccessors.getMethodIDOf(
      _classRef,
      "startActionMode",
      "(Landroid/view/ActionMode\$Callback;)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start an action mode with the default type ActionMode\#TYPE_PRIMARY.
  ///@param callback Callback that will control the lifecycle of the action mode
  ///@return The new action mode if it is started, null otherwise
  ///@see ActionMode
  ///@see \#startActionMode(android.view.ActionMode.Callback, int)
  actionmode_.ActionMode startActionMode(
          actionmode_.ActionMode_Callback callback) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActionMode,
          jni.JniType.objectType,
          [callback.reference]).object);

  static final _id_startActionMode1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActionMode",
      "(Landroid/view/ActionMode\$Callback;I)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start an action mode with the given type.
  ///@param callback Callback that will control the lifecycle of the action mode
  ///@param type One of ActionMode\#TYPE_PRIMARY or ActionMode\#TYPE_FLOATING.
  ///@return The new action mode if it is started, null otherwise
  ///@see ActionMode
  actionmode_.ActionMode startActionMode1(
          actionmode_.ActionMode_Callback callback, int type) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActionMode1,
          jni.JniType.objectType,
          [callback.reference, type]).object);

  static final _id_setOnKeyListener = jniAccessors.getMethodIDOf(
      _classRef, "setOnKeyListener", "(Landroid/view/View\$OnKeyListener;)V");

  /// from: public void setOnKeyListener(android.view.View.OnKeyListener l)
  ///
  /// Register a callback to be invoked when a hardware key is pressed in this view.
  /// Key presses in software input methods will generally not trigger the methods of
  /// this listener.
  ///@param l the key listener to attach to this view
  void setOnKeyListener(View_OnKeyListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnKeyListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnTouchListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnTouchListener", "(Landroid/view/View\$OnTouchListener;)V");

  /// from: public void setOnTouchListener(android.view.View.OnTouchListener l)
  ///
  /// Register a callback to be invoked when a touch event is sent to this view.
  ///@param l the touch listener to attach to this view
  void setOnTouchListener(View_OnTouchListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnTouchListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnGenericMotionListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnGenericMotionListener",
      "(Landroid/view/View\$OnGenericMotionListener;)V");

  /// from: public void setOnGenericMotionListener(android.view.View.OnGenericMotionListener l)
  ///
  /// Register a callback to be invoked when a generic motion event is sent to this view.
  ///@param l the generic motion listener to attach to this view
  void setOnGenericMotionListener(View_OnGenericMotionListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnGenericMotionListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnHoverListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnHoverListener", "(Landroid/view/View\$OnHoverListener;)V");

  /// from: public void setOnHoverListener(android.view.View.OnHoverListener l)
  ///
  /// Register a callback to be invoked when a hover event is sent to this view.
  ///@param l the hover listener to attach to this view
  void setOnHoverListener(View_OnHoverListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnHoverListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnDragListener = jniAccessors.getMethodIDOf(
      _classRef, "setOnDragListener", "(Landroid/view/View\$OnDragListener;)V");

  /// from: public void setOnDragListener(android.view.View.OnDragListener l)
  ///
  /// Register a drag event listener callback object for this View. The parameter is
  /// an implementation of android.view.View.OnDragListener. To send a drag event to a
  /// View, the system calls the
  /// android.view.View.OnDragListener\#onDrag(View,DragEvent) method.
  ///@param l An implementation of android.view.View.OnDragListener.
  void setOnDragListener(View_OnDragListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDragListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setRevealOnFocusHint =
      jniAccessors.getMethodIDOf(_classRef, "setRevealOnFocusHint", "(Z)V");

  /// from: public final void setRevealOnFocusHint(boolean revealOnFocus)
  ///
  /// Sets this view's preference for reveal behavior when it gains focus.
  ///
  /// When set to true, this is a signal to ancestor views in the hierarchy that
  /// this view would prefer to be brought fully into view when it gains focus.
  /// For example, a text field that a user is meant to type into. Other views such
  /// as scrolling containers may prefer to opt-out of this behavior.
  ///
  ///
  /// The default value for views is true, though subclasses may change this
  /// based on their preferred behavior.
  ///
  ///@param revealOnFocus true to request reveal on focus in ancestors, false otherwise
  ///@see \#getRevealOnFocusHint()
  void setRevealOnFocusHint(bool revealOnFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRevealOnFocusHint,
          jni.JniType.voidType, [revealOnFocus]).check();

  static final _id_getRevealOnFocusHint =
      jniAccessors.getMethodIDOf(_classRef, "getRevealOnFocusHint", "()Z");

  /// from: public final boolean getRevealOnFocusHint()
  ///
  /// Returns this view's preference for reveal behavior when it gains focus.
  ///
  /// When this method returns true for a child view requesting focus, ancestor
  /// views responding to a focus change in ViewParent\#requestChildFocus(View, View)
  /// should make a best effort to make the newly focused child fully visible to the user.
  /// When it returns false, ancestor views should preferably not disrupt scroll positioning or
  /// other properties affecting visibility to the user as part of the focus change.
  ///
  ///@return true if this view would prefer to become fully visible when it gains focus,
  ///         false if it would prefer not to disrupt scroll positioning
  ///@see \#setRevealOnFocusHint(boolean)
  bool getRevealOnFocusHint() => jniAccessors.callMethodWithArgs(
      reference, _id_getRevealOnFocusHint, jni.JniType.booleanType, []).boolean;

  static final _id_requestRectangleOnScreen = jniAccessors.getMethodIDOf(
      _classRef, "requestRectangleOnScreen", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean requestRectangleOnScreen(android.graphics.Rect rectangle)
  ///
  /// Request that a rectangle of this view be visible on the screen,
  /// scrolling if necessary just enough.
  ///
  /// A View should call this if it maintains some notion of which part
  /// of its content is interesting.  For example, a text editing view
  /// should call this when its cursor moves.
  /// The Rectangle passed into this method should be in the View's content coordinate space.
  /// It should not be affected by which part of the View is currently visible or its scroll
  /// position.
  ///@param rectangle The rectangle in the View's content coordinate space
  ///@return Whether any parent scrolled.
  bool requestRectangleOnScreen(rect_.Rect rectangle) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestRectangleOnScreen,
          jni.JniType.booleanType, [rectangle.reference]).boolean;

  static final _id_requestRectangleOnScreen1 = jniAccessors.getMethodIDOf(
      _classRef, "requestRectangleOnScreen", "(Landroid/graphics/Rect;Z)Z");

  /// from: public boolean requestRectangleOnScreen(android.graphics.Rect rectangle, boolean immediate)
  ///
  /// Request that a rectangle of this view be visible on the screen,
  /// scrolling if necessary just enough.
  ///
  /// A View should call this if it maintains some notion of which part
  /// of its content is interesting.  For example, a text editing view
  /// should call this when its cursor moves.
  /// The Rectangle passed into this method should be in the View's content coordinate space.
  /// It should not be affected by which part of the View is currently visible or its scroll
  /// position.
  /// When <code>immediate</code> is set to true, scrolling will not be
  /// animated.
  ///@param rectangle The rectangle in the View's content coordinate space
  ///@param immediate True to forbid animated scrolling, false otherwise
  ///@return Whether any parent scrolled.
  bool requestRectangleOnScreen1(rect_.Rect rectangle, bool immediate) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestRectangleOnScreen1,
          jni.JniType.booleanType, [rectangle.reference, immediate]).boolean;

  static final _id_clearFocus =
      jniAccessors.getMethodIDOf(_classRef, "clearFocus", "()V");

  /// from: public void clearFocus()
  ///
  /// Called when this view wants to give up focus. If focus is cleared
  /// \#onFocusChanged(boolean, int, android.graphics.Rect) is called.
  ///
  /// <strong>Note:</strong> When not in touch-mode, the framework will try to give focus
  /// to the first focusable View from the top after focus is cleared. Hence, if this
  /// View is the first from the top that can take focus, then all callbacks
  /// related to clearing focus will be invoked after which the framework will
  /// give focus to this view.
  ///
  ///
  void clearFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_clearFocus, jni.JniType.voidType, []).check();

  static final _id_hasFocus =
      jniAccessors.getMethodIDOf(_classRef, "hasFocus", "()Z");

  /// from: public boolean hasFocus()
  ///
  /// Returns true if this view has focus itself, or is the ancestor of the
  /// view that has focus.
  ///@return True if this view has or contains focus, false otherwise.
  bool hasFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFocus, jni.JniType.booleanType, []).boolean;

  static final _id_hasFocusable =
      jniAccessors.getMethodIDOf(_classRef, "hasFocusable", "()Z");

  /// from: public boolean hasFocusable()
  ///
  /// Returns true if this view is focusable or if it contains a reachable View
  /// for which \#hasFocusable() returns {@code true}. A "reachable hasFocusable()"
  /// is a view whose parents do not block descendants focus.
  /// Only \#VISIBLE views are considered focusable.
  ///
  /// As of Build.VERSION_CODES\#O views that are determined to be focusable
  /// through \#FOCUSABLE_AUTO will also cause this method to return {@code true}.
  /// Apps that declare a android.content.pm.ApplicationInfo\#targetSdkVersion of
  /// earlier than Build.VERSION_CODES\#O will continue to see this method return
  /// {@code false} for views not explicitly marked as focusable.
  /// Use \#hasExplicitFocusable() if you require the pre-Build.VERSION_CODES\#O
  /// behavior.
  ///
  ///@return {@code true} if the view is focusable or if the view contains a focusable
  ///         view, {@code false} otherwise
  ///@see ViewGroup\#FOCUS_BLOCK_DESCENDANTS
  ///@see ViewGroup\#getTouchscreenBlocksFocus()
  ///@see \#hasExplicitFocusable()
  bool hasFocusable() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFocusable, jni.JniType.booleanType, []).boolean;

  static final _id_hasExplicitFocusable =
      jniAccessors.getMethodIDOf(_classRef, "hasExplicitFocusable", "()Z");

  /// from: public boolean hasExplicitFocusable()
  ///
  /// Returns true if this view is focusable or if it contains a reachable View
  /// for which \#hasExplicitFocusable() returns {@code true}.
  /// A "reachable hasExplicitFocusable()" is a view whose parents do not block descendants focus.
  /// Only \#VISIBLE views for which \#getFocusable() would return
  /// \#FOCUSABLE are considered focusable.
  ///
  /// This method preserves the pre-Build.VERSION_CODES\#O behavior of
  /// \#hasFocusable() in that only views explicitly set focusable will cause
  /// this method to return true. A view set to \#FOCUSABLE_AUTO that resolves
  /// to focusable will not.
  ///
  ///@return {@code true} if the view is focusable or if the view contains a focusable
  ///         view, {@code false} otherwise
  ///@see \#hasFocusable()
  bool hasExplicitFocusable() => jniAccessors.callMethodWithArgs(
      reference, _id_hasExplicitFocusable, jni.JniType.booleanType, []).boolean;

  static final _id_onFocusChanged = jniAccessors.getMethodIDOf(
      _classRef, "onFocusChanged", "(ZILandroid/graphics/Rect;)V");

  /// from: protected void onFocusChanged(boolean gainFocus, int direction, android.graphics.Rect previouslyFocusedRect)
  ///
  /// Called by the view system when the focus state of this view changes.
  /// When the focus change event is caused by directional navigation, direction
  /// and previouslyFocusedRect provide insight into where the focus is coming from.
  /// When overriding, be sure to call up through to the super class so that
  /// the standard focus handling will occur.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param gainFocus True if the View has focus; false otherwise.
  ///@param direction The direction focus has moved when requestFocus()
  ///                  is called to give this view focus. Values are
  ///                  \#FOCUS_UP, \#FOCUS_DOWN, \#FOCUS_LEFT,
  ///                  \#FOCUS_RIGHT, \#FOCUS_FORWARD, or \#FOCUS_BACKWARD.
  ///                  It may not always apply, in which case use the default.
  /// Value is android.view.View\#FOCUS_BACKWARD, android.view.View\#FOCUS_FORWARD, android.view.View\#FOCUS_LEFT, android.view.View\#FOCUS_UP, android.view.View\#FOCUS_RIGHT, or android.view.View\#FOCUS_DOWN
  ///@param previouslyFocusedRect The rectangle, in this view's coordinate
  ///        system, of the previously focused view.  If applicable, this will be
  ///        passed in as finer grained information about where the focus is coming
  ///        from (in addition to direction).  Will be <code>null</code> otherwise.
  ///
  /// This value may be {@code null}.
  void onFocusChanged(
          bool gainFocus, int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFocusChanged,
          jni.JniType.voidType,
          [gainFocus, direction, previouslyFocusedRect.reference]).check();

  static final _id_setAccessibilityPaneTitle = jniAccessors.getMethodIDOf(
      _classRef, "setAccessibilityPaneTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public void setAccessibilityPaneTitle(java.lang.CharSequence accessibilityPaneTitle)
  ///
  /// Visually distinct portion of a window with window-like semantics are considered panes for
  /// accessibility purposes. One example is the content view of a fragment that is replaced.
  /// In order for accessibility services to understand a pane's window-like behavior, panes
  /// should have descriptive titles. Views with pane titles produce AccessibilityEvents
  /// when they appear, disappear, or change title.
  ///@param accessibilityPaneTitle The pane's title. Setting to {@code null} indicates that this
  ///                               View is not a pane.
  ///
  /// {@see AccessibilityNodeInfo\#setPaneTitle(CharSequence)}
  ///
  /// This value may be {@code null}.
  void setAccessibilityPaneTitle(jni.JniObject accessibilityPaneTitle) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAccessibilityPaneTitle,
          jni.JniType.voidType, [accessibilityPaneTitle.reference]).check();

  static final _id_getAccessibilityPaneTitle = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityPaneTitle", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityPaneTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the title of the pane for purposes of accessibility.
  ///@return The current pane title.
  ///
  /// {@see \#setAccessibilityPaneTitle}.
  ///
  /// This value may be {@code null}.
  jni.JniObject getAccessibilityPaneTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityPaneTitle, jni.JniType.objectType, []).object);

  static final _id_sendAccessibilityEvent =
      jniAccessors.getMethodIDOf(_classRef, "sendAccessibilityEvent", "(I)V");

  /// from: public void sendAccessibilityEvent(int eventType)
  ///
  /// Sends an accessibility event of the given type. If accessibility is
  /// not enabled this method has no effect. The default implementation calls
  /// \#onInitializeAccessibilityEvent(AccessibilityEvent) first
  /// to populate information about the event source (this View), then calls
  /// \#dispatchPopulateAccessibilityEvent(AccessibilityEvent) to
  /// populate the text content of the event source including its descendants,
  /// and last calls
  /// ViewParent\#requestSendAccessibilityEvent(View, AccessibilityEvent)
  /// on its parent to request sending of the event to interested parties.
  ///
  /// If an AccessibilityDelegate has been specified via calling
  /// \#setAccessibilityDelegate(AccessibilityDelegate) its
  /// AccessibilityDelegate\#sendAccessibilityEvent(View, int) is
  /// responsible for handling this call.
  ///
  ///
  ///@param eventType The type of the event to send, as defined by several types from
  /// android.view.accessibility.AccessibilityEvent, such as
  /// android.view.accessibility.AccessibilityEvent\#TYPE_VIEW_CLICKED or
  /// android.view.accessibility.AccessibilityEvent\#TYPE_VIEW_HOVER_ENTER.
  ///@see \#onInitializeAccessibilityEvent(AccessibilityEvent)
  ///@see \#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
  ///@see ViewParent\#requestSendAccessibilityEvent(View, AccessibilityEvent)
  ///@see AccessibilityDelegate
  void sendAccessibilityEvent(int eventType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendAccessibilityEvent,
      jni.JniType.voidType,
      [eventType]).check();

  static final _id_announceForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "announceForAccessibility", "(Ljava/lang/CharSequence;)V");

  /// from: public void announceForAccessibility(java.lang.CharSequence text)
  ///
  /// Convenience method for sending a AccessibilityEvent\#TYPE_ANNOUNCEMENT
  /// AccessibilityEvent to make an announcement which is related to some
  /// sort of a context change for which none of the events representing UI transitions
  /// is a good fit. For example, announcing a new page in a book. If accessibility
  /// is not enabled this method does nothing.
  ///@param text The announcement text.
  void announceForAccessibility(jni.JniObject text) =>
      jniAccessors.callMethodWithArgs(reference, _id_announceForAccessibility,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_sendAccessibilityEventUnchecked = jniAccessors.getMethodIDOf(
      _classRef,
      "sendAccessibilityEventUnchecked",
      "(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent event)
  ///
  /// This method behaves exactly as \#sendAccessibilityEvent(int) but
  /// takes as an argument an empty AccessibilityEvent and does not
  /// perform a check whether accessibility is enabled.
  ///
  /// If an AccessibilityDelegate has been specified via calling
  /// \#setAccessibilityDelegate(AccessibilityDelegate) its
  /// AccessibilityDelegate\#sendAccessibilityEventUnchecked(View, AccessibilityEvent)
  /// is responsible for handling this call.
  ///
  ///
  ///@param event The event to send.
  ///@see \#sendAccessibilityEvent(int)
  void sendAccessibilityEventUnchecked(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendAccessibilityEventUnchecked,
          jni.JniType.voidType,
          [event.reference]).check();

  static final _id_dispatchPopulateAccessibilityEvent =
      jniAccessors.getMethodIDOf(
          _classRef,
          "dispatchPopulateAccessibilityEvent",
          "(Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Dispatches an AccessibilityEvent to the View first and then
  /// to its children for adding their text content to the event. Note that the
  /// event text is populated in a separate dispatch path since we add to the
  /// event not only the text of the source but also the text of all its descendants.
  /// A typical implementation will call
  /// \#onPopulateAccessibilityEvent(AccessibilityEvent) on the this view
  /// and then call the \#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
  /// on each child. Override this method if custom population of the event text
  /// content is required.
  ///
  /// If an AccessibilityDelegate has been specified via calling
  /// \#setAccessibilityDelegate(AccessibilityDelegate) its
  /// AccessibilityDelegate\#dispatchPopulateAccessibilityEvent(View, AccessibilityEvent)
  /// is responsible for handling this call.
  ///
  ///
  ///
  /// _Note:_ Accessibility events of certain types are not dispatched for
  /// populating the event text via this method. For details refer to AccessibilityEvent.
  ///
  ///
  ///@param event The event.
  ///@return True if the event population was completed.
  bool dispatchPopulateAccessibilityEvent(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPopulateAccessibilityEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_onPopulateAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onPopulateAccessibilityEvent",
      "(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void onPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Called from \#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
  /// giving a chance to this View to populate the accessibility event with its
  /// text content. While this method is free to modify event
  /// attributes other than text content, doing so should normally be performed in
  /// \#onInitializeAccessibilityEvent(AccessibilityEvent).
  ///
  /// Example: Adding formatted date string to an accessibility event in addition
  ///          to the text added by the super implementation:
  /// <pre> public void onPopulateAccessibilityEvent(AccessibilityEvent event) {
  ///     super.onPopulateAccessibilityEvent(event);
  ///     final int flags = DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY;
  ///     String selectedDateUtterance = DateUtils.formatDateTime(mContext,
  ///         mCurrentDate.getTimeInMillis(), flags);
  ///     event.getText().add(selectedDateUtterance);
  /// }</pre>
  ///
  /// If an AccessibilityDelegate has been specified via calling
  /// \#setAccessibilityDelegate(AccessibilityDelegate) its
  /// AccessibilityDelegate\#onPopulateAccessibilityEvent(View, AccessibilityEvent)
  /// is responsible for handling this call.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Always call the super implementation before adding
  /// information to the event, in case the default implementation has basic information to add.
  ///
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param event The accessibility event which to populate.
  ///@see \#sendAccessibilityEvent(int)
  ///@see \#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
  void onPopulateAccessibilityEvent(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPopulateAccessibilityEvent,
          jni.JniType.voidType,
          [event.reference]).check();

  static final _id_onInitializeAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onInitializeAccessibilityEvent",
      "(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Initializes an AccessibilityEvent with information about
  /// this View which is the event source. In other words, the source of
  /// an accessibility event is the view whose state change triggered firing
  /// the event.
  ///
  /// Example: Setting the password property of an event in addition
  ///          to properties set by the super implementation:
  /// <pre> public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
  ///     super.onInitializeAccessibilityEvent(event);
  ///     event.setPassword(true);
  /// }</pre>
  ///
  /// If an AccessibilityDelegate has been specified via calling
  /// \#setAccessibilityDelegate(AccessibilityDelegate) its
  /// AccessibilityDelegate\#onInitializeAccessibilityEvent(View, AccessibilityEvent)
  /// is responsible for handling this call.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Always call the super implementation before adding
  /// information to the event, in case the default implementation has basic information to add.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param event The event to initialize.
  ///@see \#sendAccessibilityEvent(int)
  ///@see \#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
  void onInitializeAccessibilityEvent(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onInitializeAccessibilityEvent,
          jni.JniType.voidType,
          [event.reference]).check();

  static final _id_createAccessibilityNodeInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "createAccessibilityNodeInfo",
      "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo createAccessibilityNodeInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an AccessibilityNodeInfo representing this view from the
  /// point of view of an android.accessibilityservice.AccessibilityService.
  /// This method is responsible for obtaining an accessibility node info from a
  /// pool of reusable instances and calling
  /// \#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo) on this view to
  /// initialize the former.
  ///
  /// Note: The client is responsible for recycling the obtained instance by calling
  ///       AccessibilityNodeInfo\#recycle() to minimize object creation.
  ///
  ///
  ///@return A populated AccessibilityNodeInfo.
  ///@see AccessibilityNodeInfo
  accessibilitynodeinfo_.AccessibilityNodeInfo createAccessibilityNodeInfo() =>
      accessibilitynodeinfo_.AccessibilityNodeInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createAccessibilityNodeInfo,
              jni.JniType.objectType, []).object);

  static final _id_onInitializeAccessibilityNodeInfo =
      jniAccessors.getMethodIDOf(_classRef, "onInitializeAccessibilityNodeInfo",
          "(Landroid/view/accessibility/AccessibilityNodeInfo;)V");

  /// from: public void onInitializeAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo info)
  ///
  /// Initializes an AccessibilityNodeInfo with information about this view.
  /// The base implementation sets:
  /// <ul>
  ///   <li>AccessibilityNodeInfo\#setParent(View),</li>
  ///   <li>AccessibilityNodeInfo\#setBoundsInParent(Rect),</li>
  ///   <li>AccessibilityNodeInfo\#setBoundsInScreen(Rect),</li>
  ///   <li>AccessibilityNodeInfo\#setPackageName(CharSequence),</li>
  ///   <li>AccessibilityNodeInfo\#setClassName(CharSequence),</li>
  ///   <li>AccessibilityNodeInfo\#setContentDescription(CharSequence),</li>
  ///   <li>AccessibilityNodeInfo\#setEnabled(boolean),</li>
  ///   <li>AccessibilityNodeInfo\#setClickable(boolean),</li>
  ///   <li>AccessibilityNodeInfo\#setFocusable(boolean),</li>
  ///   <li>AccessibilityNodeInfo\#setFocused(boolean),</li>
  ///   <li>AccessibilityNodeInfo\#setLongClickable(boolean),</li>
  ///   <li>AccessibilityNodeInfo\#setSelected(boolean),</li>
  ///   <li>AccessibilityNodeInfo\#setContextClickable(boolean)</li>
  /// </ul>
  ///
  /// Subclasses should override this method, call the super implementation,
  /// and set additional attributes.
  ///
  ///
  ///
  /// If an AccessibilityDelegate has been specified via calling
  /// \#setAccessibilityDelegate(AccessibilityDelegate) its
  /// AccessibilityDelegate\#onInitializeAccessibilityNodeInfo(View, AccessibilityNodeInfo)
  /// is responsible for handling this call.
  ///
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param info The instance to initialize.
  void onInitializeAccessibilityNodeInfo(
          accessibilitynodeinfo_.AccessibilityNodeInfo info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onInitializeAccessibilityNodeInfo,
          jni.JniType.voidType,
          [info.reference]).check();

  static final _id_getAccessibilityClassName = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the class name of this object to be used for accessibility purposes.
  /// Subclasses should only override this if they are implementing something that
  /// should be seen as a completely new class of view when used by accessibility,
  /// unrelated to the class it is deriving from.  This is used to fill in
  /// AccessibilityNodeInfo\#setClassName AccessibilityNodeInfo.setClassName.
  jni.JniObject getAccessibilityClassName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName, jni.JniType.objectType, []).object);

  static final _id_onProvideStructure = jniAccessors.getMethodIDOf(
      _classRef, "onProvideStructure", "(Landroid/view/ViewStructure;)V");

  /// from: public void onProvideStructure(android.view.ViewStructure structure)
  ///
  /// Called when assist structure is being retrieved from a view as part of
  /// android.app.Activity\#onProvideAssistData Activity.onProvideAssistData.
  ///@param structure Fill in with structured view data.  The default implementation
  /// fills in all data that can be inferred from the view itself.
  void onProvideStructure(viewstructure_.ViewStructure structure) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideStructure,
          jni.JniType.voidType, [structure.reference]).check();

  static final _id_onProvideAutofillStructure = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideAutofillStructure",
      "(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideAutofillStructure(android.view.ViewStructure structure, int flags)
  ///
  /// Populates a ViewStructure to fullfil an autofill request.
  ///
  /// The structure should contain at least the following properties:
  /// <ul>
  ///   <li>Autofill id (ViewStructure\#setAutofillId(AutofillId, int)).
  ///   <li>Autofill type (ViewStructure\#setAutofillType(int)).
  ///   <li>Autofill value (ViewStructure\#setAutofillValue(AutofillValue)).
  ///   <li>Whether the data is sensitive (ViewStructure\#setDataIsSensitive(boolean)).
  /// </ul>
  ///
  /// It's also recommended to set the following properties - the more properties the structure
  /// has, the higher the changes of an android.service.autofill.AutofillService properly
  /// using the structure:
  ///
  /// <ul>
  ///   <li>Autofill hints (ViewStructure\#setAutofillHints(String[])).
  ///   <li>Autofill options (ViewStructure\#setAutofillOptions(CharSequence[])) when the
  ///       view can only be filled with predefined values (typically used when the autofill type
  ///       is \#AUTOFILL_TYPE_LIST).
  ///   <li>Resource id (ViewStructure\#setId(int, String, String, String)).
  ///   <li>Class name (ViewStructure\#setClassName(String)).
  ///   <li>Content description (ViewStructure\#setContentDescription(CharSequence)).
  ///   <li>Visual properties such as visibility (ViewStructure\#setVisibility(int)),
  ///       dimensions (ViewStructure\#setDimens(int, int, int, int, int, int)), and
  ///       opacity (ViewStructure\#setOpaque(boolean)).
  ///   <li>For views representing text fields, text properties such as the text itself
  ///       (ViewStructure\#setText(CharSequence)), text hints
  ///       (ViewStructure\#setHint(CharSequence), input type
  ///       (ViewStructure\#setInputType(int)),
  ///   <li>For views representing HTML nodes, its web domain
  ///       (ViewStructure\#setWebDomain(String)) and HTML properties
  ///       ((ViewStructure\#setHtmlInfo(android.view.ViewStructure.HtmlInfo)).
  /// </ul>
  ///
  /// The default implementation of this method already sets most of these properties based on
  /// related View methods (for example, the autofill id is set using
  /// \#getAutofillId(), the autofill type set using \#getAutofillType(), etc.),
  /// and views in the standard Android widgets library also override it to set their
  /// relevant properties (for example, android.widget.TextView already sets the text
  /// properties), so it's recommended to only override this method
  /// (and call {@code super.onProvideAutofillStructure()}) when:
  ///
  /// <ul>
  ///   <li>The view contents does not include PII (Personally Identifiable Information), so it
  ///       can call ViewStructure\#setDataIsSensitive(boolean) passing {@code false}.
  ///   <li>The view can only be autofilled with predefined options, so it can call
  ///       ViewStructure\#setAutofillOptions(CharSequence[]).
  /// </ul>
  ///
  /// __Note:__ The {@code left} and {@code top} values set in
  /// ViewStructure\#setDimens(int, int, int, int, int, int) must be relative to the next
  /// ViewGroup\#isImportantForAutofill() predecessor view included in the structure.
  ///
  /// Views support the Autofill Framework mainly by:
  /// <ul>
  ///   <li>Providing the metadata defining what the view means and how it can be autofilled.
  ///   <li>Notifying the Android System when the view value changed by calling
  ///       AutofillManager\#notifyValueChanged(View).
  ///   <li>Implementing the methods that autofill the view.
  /// </ul>
  /// This method is responsible for the former; \#autofill(AutofillValue) is responsible
  /// for the latter.
  ///@param structure fill in with structured view data for autofill purposes.
  ///@param flags optional flags.
  ///
  /// Value is either <code>0</code> or android.view.View\#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  ///@see \#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  void onProvideAutofillStructure(
          viewstructure_.ViewStructure structure, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideAutofillStructure,
          jni.JniType.voidType, [structure.reference, flags]).check();

  static final _id_onProvideVirtualStructure = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideVirtualStructure",
      "(Landroid/view/ViewStructure;)V");

  /// from: public void onProvideVirtualStructure(android.view.ViewStructure structure)
  ///
  /// Called when assist structure is being retrieved from a view as part of
  /// android.app.Activity\#onProvideAssistData Activity.onProvideAssistData to
  /// generate additional virtual structure under this view.  The defaullt implementation
  /// uses \#getAccessibilityNodeProvider() to try to generate this from the
  /// view's virtual accessibility nodes, if any.  You can override this for a more
  /// optimal implementation providing this data.
  void onProvideVirtualStructure(viewstructure_.ViewStructure structure) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideVirtualStructure,
          jni.JniType.voidType, [structure.reference]).check();

  static final _id_onProvideAutofillVirtualStructure =
      jniAccessors.getMethodIDOf(_classRef, "onProvideAutofillVirtualStructure",
          "(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideAutofillVirtualStructure(android.view.ViewStructure structure, int flags)
  ///
  /// Populates a ViewStructure containing virtual children to fullfil an autofill
  /// request.
  ///
  /// This method should be used when the view manages a virtual structure under this view. For
  /// example, a view that draws input fields using \#draw(Canvas).
  ///
  /// When implementing this method, subclasses must follow the rules below:
  ///
  /// <ul>
  ///   <li>Add virtual children by calling the ViewStructure\#newChild(int) or
  ///       ViewStructure\#asyncNewChild(int) methods, where the {@code id} is an unique id
  ///       identifying the children in the virtual structure.
  ///   <li>The children hierarchy can have multiple levels if necessary, but ideally it should
  ///       exclude intermediate levels that are irrelevant for autofill; that would improve the
  ///       autofill performance.
  ///   <li>Also implement \#autofill(SparseArray) to autofill the virtual
  ///       children.
  ///   <li>Set the autofill properties of the child structure as defined by
  ///       \#onProvideAutofillStructure(ViewStructure, int), using
  ///       ViewStructure\#setAutofillId(AutofillId, int) to set its autofill id.
  ///   <li>Call android.view.autofill.AutofillManager\#notifyViewEntered(View, int, Rect)
  ///       and/or android.view.autofill.AutofillManager\#notifyViewExited(View, int)
  ///       when the focused virtual child changed.
  ///   <li>Override \#isVisibleToUserForAutofill(int) to allow the platform to query
  ///       whether a given virtual view is visible to the user in order to support triggering
  ///       save when all views of interest go away.
  ///   <li>Call
  ///    android.view.autofill.AutofillManager\#notifyValueChanged(View, int, AutofillValue)
  ///       when the value of a virtual child changed.
  ///   <li>Call android.view.autofill.AutofillManager\#notifyViewVisibilityChanged(View, int, boolean)
  ///       when the visibility of a virtual child changed.
  ///   <li>Call
  ///    android.view.autofill.AutofillManager\#notifyViewClicked(View, int) when a virtual
  ///       child is clicked.
  ///   <li>Call AutofillManager\#commit() when the autofill context of the view structure
  ///       changed and the current context should be committed (for example, when the user tapped
  ///       a {@code SUBMIT} button in an HTML page).
  ///   <li>Call AutofillManager\#cancel() when the autofill context of the view structure
  ///       changed and the current context should be canceled (for example, when the user tapped
  ///       a {@code CANCEL} button in an HTML page).
  ///   <li>Provide ways for users to manually request autofill by calling
  ///       AutofillManager\#requestAutofill(View, int, Rect).
  ///   <li>The {@code left} and {@code top} values set in
  ///       ViewStructure\#setDimens(int, int, int, int, int, int) must be relative to the
  ///       next ViewGroup\#isImportantForAutofill() predecessor view included in the
  ///       structure.
  /// </ul>
  ///
  /// Views with virtual children support the Autofill Framework mainly by:
  /// <ul>
  ///   <li>Providing the metadata defining what the virtual children mean and how they can be
  ///       autofilled.
  ///   <li>Implementing the methods that autofill the virtual children.
  /// </ul>
  /// This method is responsible for the former; \#autofill(SparseArray) is responsible
  /// for the latter.
  ///@param structure fill in with virtual children data for autofill purposes.
  ///@param flags optional flags.
  ///@see \#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  void onProvideAutofillVirtualStructure(
          viewstructure_.ViewStructure structure, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onProvideAutofillVirtualStructure,
          jni.JniType.voidType,
          [structure.reference, flags]).check();

  static final _id_autofill = jniAccessors.getMethodIDOf(
      _classRef, "autofill", "(Landroid/view/autofill/AutofillValue;)V");

  /// from: public void autofill(android.view.autofill.AutofillValue value)
  ///
  /// Automatically fills the content of this view with the {@code value}.
  ///
  /// Views support the Autofill Framework mainly by:
  /// <ul>
  ///   <li>Providing the metadata defining what the view means and how it can be autofilled.
  ///   <li>Implementing the methods that autofill the view.
  /// </ul>
  /// \#onProvideAutofillStructure(ViewStructure, int) is responsible for the former,
  /// this method is responsible for latter.
  ///
  /// This method does nothing by default, but when overridden it typically:
  /// <ol>
  ///   <li>Checks if the provided value matches the expected type (which is defined by
  ///       \#getAutofillType()).
  ///   <li>Checks if the view is editable - if it isn't, it should return right away.
  ///   <li>Call the proper getter method on AutofillValue to fetch the actual value.
  ///   <li>Pass the actual value to the equivalent setter in the view.
  /// </ol>
  ///
  /// For example, a text-field view could implement the method this way:
  ///
  /// <pre class="prettyprint">
  /// &\#64;Override
  /// public void autofill(AutofillValue value) {
  ///   if (!value.isText() || !this.isEditable()) {
  ///      return;
  ///   }
  ///   CharSequence text = value.getTextValue();
  ///   if (text != null) {
  ///     this.setText(text);
  ///   }
  /// }
  /// </pre>
  ///
  /// If the value is updated asynchronously, the next call to
  /// AutofillManager\#notifyValueChanged(View) must happen __after__ the value was
  /// changed to the autofilled value. If not, the view will not be considered autofilled.
  ///
  /// __Note:__ After this method is called, the value returned by
  /// \#getAutofillValue() must be equal to the {@code value} passed to it, otherwise the
  /// view will not be highlighted as autofilled.
  ///@param value value to be autofilled.
  void autofill(autofillvalue_.AutofillValue value) =>
      jniAccessors.callMethodWithArgs(reference, _id_autofill,
          jni.JniType.voidType, [value.reference]).check();

  static final _id_autofill1 = jniAccessors.getMethodIDOf(
      _classRef, "autofill", "(Landroid/util/SparseArray;)V");

  /// from: public void autofill(android.util.SparseArray<android.view.autofill.AutofillValue> values)
  ///
  /// Automatically fills the content of the virtual children within this view.
  ///
  /// Views with virtual children support the Autofill Framework mainly by:
  /// <ul>
  ///   <li>Providing the metadata defining what the virtual children mean and how they can be
  ///       autofilled.
  ///   <li>Implementing the methods that autofill the virtual children.
  /// </ul>
  /// \#onProvideAutofillVirtualStructure(ViewStructure, int) is responsible for the
  /// former, this method is responsible for the latter - see \#autofill(AutofillValue) and
  /// \#onProvideAutofillVirtualStructure(ViewStructure, int) for more info about autofill.
  ///
  /// If a child value is updated asynchronously, the next call to
  /// AutofillManager\#notifyValueChanged(View, int, AutofillValue) must happen
  /// __after__ the value was changed to the autofilled value. If not, the child will not be
  /// considered autofilled.
  ///
  /// __Note:__ To indicate that a virtual view was autofilled,
  /// <code>?android:attr/autofilledHighlight</code> should be drawn over it until the data
  /// changes.
  ///@param values map of values to be autofilled, keyed by virtual child id.
  ///
  /// This value must never be {@code null}.
  ///@attr ref android.R.styleable\#Theme_autofilledHighlight
  void autofill1(sparsearray_.SparseArray values) =>
      jniAccessors.callMethodWithArgs(reference, _id_autofill1,
          jni.JniType.voidType, [values.reference]).check();

  static final _id_getAutofillId = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillId", "()Landroid/view/autofill/AutofillId;");

  /// from: public final android.view.autofill.AutofillId getAutofillId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the unique, logical identifier of this view in the activity, for autofill purposes.
  ///
  /// The autofill id is created on demand, unless it is explicitly set by
  /// \#setAutofillId(AutofillId).
  ///
  /// See \#setAutofillId(AutofillId) for more info.
  ///@return The View's autofill id.
  autofillid_.AutofillId getAutofillId() =>
      autofillid_.AutofillId.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillId, jni.JniType.objectType, []).object);

  static final _id_setAutofillId = jniAccessors.getMethodIDOf(
      _classRef, "setAutofillId", "(Landroid/view/autofill/AutofillId;)V");

  /// from: public void setAutofillId(android.view.autofill.AutofillId id)
  ///
  /// Sets the unique, logical identifier of this view in the activity, for autofill purposes.
  ///
  /// The autofill id is created on demand, and this method should only be called when a view is
  /// reused after \#dispatchProvideAutofillStructure(ViewStructure, int) is called, as
  /// that method creates a snapshot of the view that is passed along to the autofill service.
  ///
  /// This method is typically used when view subtrees are recycled to represent different
  /// content* &mdash;in this case, the autofill id can be saved before the view content is swapped
  /// out, and restored later when it's swapped back in. For example:
  ///
  /// <pre>
  /// EditText reusableView = ...;
  /// ViewGroup parentView = ...;
  /// AutofillManager afm = ...;
  ///
  /// // Swap out the view and change its contents
  /// AutofillId oldId = reusableView.getAutofillId();
  /// CharSequence oldText = reusableView.getText();
  /// parentView.removeView(reusableView);
  /// AutofillId newId = afm.getNextAutofillId();
  /// reusableView.setText("New I am");
  /// reusableView.setAutofillId(newId);
  /// parentView.addView(reusableView);
  ///
  /// // Later, swap the old content back in
  /// parentView.removeView(reusableView);
  /// reusableView.setAutofillId(oldId);
  /// reusableView.setText(oldText);
  /// parentView.addView(reusableView);
  /// </pre>
  ///@param id an autofill ID that is unique in the android.app.Activity hosting the view,
  /// or {@code null} to reset it. Usually it's an id previously allocated to another view (and
  /// obtained through \#getAutofillId()), or a new value obtained through
  /// AutofillManager\#getNextAutofillId().
  ///
  /// This value may be {@code null}.
  ///@throws IllegalStateException if the view is already \#isAttachedToWindow() attached to
  /// a window.
  ///@throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
  void setAutofillId(autofillid_.AutofillId id) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAutofillId,
          jni.JniType.voidType, [id.reference]).check();

  static final _id_getAutofillType =
      jniAccessors.getMethodIDOf(_classRef, "getAutofillType", "()I");

  /// from: public int getAutofillType()
  ///
  /// Describes the autofill type of this view, so an
  /// android.service.autofill.AutofillService can create the proper AutofillValue
  /// when autofilling the view.
  ///
  /// By default returns \#AUTOFILL_TYPE_NONE, but views should override it to properly
  /// support the Autofill Framework.
  ///@return either \#AUTOFILL_TYPE_NONE, \#AUTOFILL_TYPE_TEXT,
  /// \#AUTOFILL_TYPE_LIST, \#AUTOFILL_TYPE_DATE, or \#AUTOFILL_TYPE_TOGGLE.
  ///
  /// Value is android.view.View\#AUTOFILL_TYPE_NONE, android.view.View\#AUTOFILL_TYPE_TEXT, android.view.View\#AUTOFILL_TYPE_TOGGLE, android.view.View\#AUTOFILL_TYPE_LIST, or android.view.View\#AUTOFILL_TYPE_DATE
  ///@see \#onProvideAutofillStructure(ViewStructure, int)
  ///@see \#autofill(AutofillValue)
  int getAutofillType() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutofillType, jni.JniType.intType, []).integer;

  static final _id_getAutofillHints = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillHints", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getAutofillHints()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the hints that help an android.service.autofill.AutofillService determine how
  /// to autofill the view with the user's data.
  ///
  /// See \#setAutofillHints(String...) for more info about these hints.
  ///@return The hints set via the attribute or \#setAutofillHints(String...), or
  /// {@code null} if no hints were set.
  ///@attr ref android.R.styleable\#View_autofillHints
  jni.JniObject getAutofillHints() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillHints, jni.JniType.objectType, []).object);

  static final _id_getAutofillValue = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillValue", "()Landroid/view/autofill/AutofillValue;");

  /// from: public android.view.autofill.AutofillValue getAutofillValue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the View's current autofill value.
  ///
  /// By default returns {@code null}, but subclasses should override it and return an
  /// appropriate value to properly support the Autofill Framework.
  ///@see \#onProvideAutofillStructure(ViewStructure, int)
  ///@see \#autofill(AutofillValue)
  autofillvalue_.AutofillValue getAutofillValue() =>
      autofillvalue_.AutofillValue.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillValue, jni.JniType.objectType, []).object);

  static final _id_getImportantForAutofill =
      jniAccessors.getMethodIDOf(_classRef, "getImportantForAutofill", "()I");

  /// from: public int getImportantForAutofill()
  ///
  /// Gets the mode for determining whether this view is important for autofill.
  ///
  /// See \#setImportantForAutofill(int) and \#isImportantForAutofill() for more
  /// info about this mode.
  ///@return \#IMPORTANT_FOR_AUTOFILL_AUTO by default, or value passed to
  /// \#setImportantForAutofill(int).
  ///
  /// Value is android.view.View\#IMPORTANT_FOR_AUTOFILL_AUTO, android.view.View\#IMPORTANT_FOR_AUTOFILL_YES, android.view.View\#IMPORTANT_FOR_AUTOFILL_NO, android.view.View\#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS, or android.view.View\#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
  ///@attr ref android.R.styleable\#View_importantForAutofill
  int getImportantForAutofill() => jniAccessors.callMethodWithArgs(
      reference, _id_getImportantForAutofill, jni.JniType.intType, []).integer;

  static final _id_setImportantForAutofill =
      jniAccessors.getMethodIDOf(_classRef, "setImportantForAutofill", "(I)V");

  /// from: public void setImportantForAutofill(int mode)
  ///
  /// Sets the mode for determining whether this view is considered important for autofill.
  ///
  /// The platform determines the importance for autofill automatically but you
  /// can use this method to customize the behavior. For example:
  ///
  /// <ol>
  ///   <li>When the view contents is irrelevant for autofill (for example, a text field used in a
  ///       "Captcha" challenge), it should be \#IMPORTANT_FOR_AUTOFILL_NO.
  ///   <li>When both the view and its children are irrelevant for autofill (for example, the root
  ///       view of an activity containing a spreadhseet editor), it should be
  ///       \#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS.
  ///   <li>When the view content is relevant for autofill but its children aren't (for example,
  ///       a credit card expiration date represented by a custom view that overrides the proper
  ///       autofill methods and has 2 children representing the month and year), it should
  ///       be \#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS.
  /// </ol>
  ///
  /// __Note:__ Setting the mode as \#IMPORTANT_FOR_AUTOFILL_NO or
  /// \#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS does not guarantee the view (and its
  /// children) will be always be considered not important; for example, when the user explicitly
  /// makes an autofill request, all views are considered important. See
  /// \#isImportantForAutofill() for more details about how the View's importance for
  /// autofill is used.
  ///@param mode \#IMPORTANT_FOR_AUTOFILL_AUTO, \#IMPORTANT_FOR_AUTOFILL_YES,
  /// \#IMPORTANT_FOR_AUTOFILL_NO, \#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS,
  /// or \#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS.
  ///
  /// Value is android.view.View\#IMPORTANT_FOR_AUTOFILL_AUTO, android.view.View\#IMPORTANT_FOR_AUTOFILL_YES, android.view.View\#IMPORTANT_FOR_AUTOFILL_NO, android.view.View\#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS, or android.view.View\#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
  ///@attr ref android.R.styleable\#View_importantForAutofill
  void setImportantForAutofill(int mode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setImportantForAutofill,
      jni.JniType.voidType,
      [mode]).check();

  static final _id_isImportantForAutofill =
      jniAccessors.getMethodIDOf(_classRef, "isImportantForAutofill", "()Z");

  /// from: public final boolean isImportantForAutofill()
  ///
  /// Hints the Android System whether the android.app.assist.AssistStructure.ViewNode
  /// associated with this view is considered important for autofill purposes.
  ///
  /// Generally speaking, a view is important for autofill if:
  /// <ol>
  /// <li>The view can be autofilled by an android.service.autofill.AutofillService.
  /// <li>The view contents can help an android.service.autofill.AutofillService
  ///     determine how other views can be autofilled.
  /// <ol>
  ///
  /// For example, view containers should typically return {@code false} for performance reasons
  /// (since the important info is provided by their children), but if its properties have relevant
  /// information (for example, a resource id called {@code credentials}, it should return
  /// {@code true}. On the other hand, views representing labels or editable fields should
  /// typically return {@code true}, but in some cases they could return {@code false}
  /// (for example, if they're part of a "Captcha" mechanism).
  ///
  /// The value returned by this method depends on the value returned by
  /// \#getImportantForAutofill():
  ///
  /// <ol>
  ///   <li>if it returns \#IMPORTANT_FOR_AUTOFILL_YES or
  ///       \#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS, then it returns {@code true}
  ///   <li>if it returns \#IMPORTANT_FOR_AUTOFILL_NO or
  ///       \#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS, then it returns {@code false}
  ///   <li>if it returns \#IMPORTANT_FOR_AUTOFILL_AUTO, then it uses some simple heuristics
  ///       that can return {@code true} in some cases (like a container with a resource id),
  ///       but {@code false} in most.
  ///   <li>otherwise, it returns {@code false}.
  /// </ol>
  ///
  /// When a view is considered important for autofill:
  /// <ul>
  ///   <li>The view might automatically trigger an autofill request when focused on.
  ///   <li>The contents of the view are included in the ViewStructure used in an autofill
  ///       request.
  /// </ul>
  ///
  /// On the other hand, when a view is considered not important for autofill:
  /// <ul>
  ///   <li>The view never automatically triggers autofill requests, but it can trigger a manual
  ///       request through AutofillManager\#requestAutofill(View).
  ///   <li>The contents of the view are not included in the ViewStructure used in an
  ///       autofill request, unless the request has the
  ///       \#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS flag.
  /// </ul>
  ///@return whether the view is considered important for autofill.
  ///@see \#setImportantForAutofill(int)
  ///@see \#IMPORTANT_FOR_AUTOFILL_AUTO
  ///@see \#IMPORTANT_FOR_AUTOFILL_YES
  ///@see \#IMPORTANT_FOR_AUTOFILL_NO
  ///@see \#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS
  ///@see \#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
  ///@see AutofillManager\#requestAutofill(View)
  bool isImportantForAutofill() => jniAccessors.callMethodWithArgs(reference,
      _id_isImportantForAutofill, jni.JniType.booleanType, []).boolean;

  static final _id_dispatchProvideStructure = jniAccessors.getMethodIDOf(
      _classRef, "dispatchProvideStructure", "(Landroid/view/ViewStructure;)V");

  /// from: public void dispatchProvideStructure(android.view.ViewStructure structure)
  ///
  /// Dispatch creation of ViewStructure down the hierarchy.  The default
  /// implementation calls \#onProvideStructure and
  /// \#onProvideVirtualStructure.
  void dispatchProvideStructure(viewstructure_.ViewStructure structure) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchProvideStructure,
          jni.JniType.voidType, [structure.reference]).check();

  static final _id_dispatchProvideAutofillStructure =
      jniAccessors.getMethodIDOf(_classRef, "dispatchProvideAutofillStructure",
          "(Landroid/view/ViewStructure;I)V");

  /// from: public void dispatchProvideAutofillStructure(android.view.ViewStructure structure, int flags)
  ///
  /// Dispatches creation of a ViewStructures for autofill purposes down the hierarchy,
  /// when an Assist structure is being created as part of an autofill request.
  ///
  /// The default implementation does the following:
  /// <ul>
  ///   <li>Sets the AutofillId in the structure.
  ///   <li>Calls \#onProvideAutofillStructure(ViewStructure, int).
  ///   <li>Calls \#onProvideAutofillVirtualStructure(ViewStructure, int).
  /// </ul>
  ///
  /// Typically, this method should only be overridden by subclasses that provide a view
  /// hierarchy (such as ViewGroup) - other classes should override
  /// \#onProvideAutofillStructure(ViewStructure, int) or
  /// \#onProvideAutofillVirtualStructure(ViewStructure, int) instead.
  ///
  /// When overridden, it must:
  ///
  /// <ul>
  ///   <li>Either call
  ///       {@code super.dispatchProvideAutofillStructure(structure, flags)} or explicitly
  ///       set the AutofillId in the structure (for example, by calling
  ///       {@code structure.setAutofillId(getAutofillId())}).
  ///   <li>Decide how to handle the \#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS flag - when
  ///       set, all views in the structure should be considered important for autofill,
  ///       regardless of what \#isImportantForAutofill() returns. We encourage you to
  ///       respect this flag to provide a better user experience - this flag is typically used
  ///       when an user explicitly requested autofill. If the flag is not set,
  ///       then only views marked as important for autofill should be included in the
  ///       structure - skipping non-important views optimizes the overall autofill performance.
  /// </ul>
  ///@param structure fill in with structured view data for autofill purposes.
  /// This value must never be {@code null}.
  ///@param flags optional flags.
  ///
  /// Value is either <code>0</code> or android.view.View\#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  ///@see \#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
  void dispatchProvideAutofillStructure(
          viewstructure_.ViewStructure structure, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchProvideAutofillStructure,
          jni.JniType.voidType,
          [structure.reference, flags]).check();

  static final _id_addExtraDataToAccessibilityNodeInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "addExtraDataToAccessibilityNodeInfo",
      "(Landroid/view/accessibility/AccessibilityNodeInfo;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void addExtraDataToAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo info, java.lang.String extraDataKey, android.os.Bundle arguments)
  ///
  /// Adds extra data to an AccessibilityNodeInfo based on an explicit request for the
  /// additional data.
  ///
  /// This method only needs overloading if the node is marked as having extra data available.
  ///
  ///
  ///@param info The info to which to add the extra data. Never {@code null}.
  /// This value must never be {@code null}.
  ///@param extraDataKey A key specifying the type of extra data to add to the info. The
  ///                     extra data should be added to the Bundle returned by
  ///                     the info's AccessibilityNodeInfo\#getExtras method. Never
  ///                     {@code null}.
  /// This value must never be {@code null}.
  ///@param arguments A Bundle holding any arguments relevant for this request. May be
  ///                  {@code null} if the service provided no arguments.
  ///
  /// This value may be {@code null}.
  ///@see AccessibilityNodeInfo\#setAvailableExtraData(List)
  void addExtraDataToAccessibilityNodeInfo(
          accessibilitynodeinfo_.AccessibilityNodeInfo info,
          jni.JniString extraDataKey,
          bundle_.Bundle arguments) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_addExtraDataToAccessibilityNodeInfo, jni.JniType.voidType, [
        info.reference,
        extraDataKey.reference,
        arguments.reference
      ]).check();

  static final _id_isVisibleToUserForAutofill = jniAccessors.getMethodIDOf(
      _classRef, "isVisibleToUserForAutofill", "(I)Z");

  /// from: public boolean isVisibleToUserForAutofill(int virtualId)
  ///
  /// Computes whether this virtual autofill view is visible to the user.
  ///
  /// __Note: __By default it returns {@code true}, but views providing a virtual hierarchy
  /// view must override it.
  ///@return Whether the view is visible on the screen.
  bool isVisibleToUserForAutofill(int virtualId) =>
      jniAccessors.callMethodWithArgs(reference, _id_isVisibleToUserForAutofill,
          jni.JniType.booleanType, [virtualId]).boolean;

  static final _id_setAccessibilityDelegate = jniAccessors.getMethodIDOf(
      _classRef,
      "setAccessibilityDelegate",
      "(Landroid/view/View\$AccessibilityDelegate;)V");

  /// from: public void setAccessibilityDelegate(android.view.View.AccessibilityDelegate delegate)
  ///
  /// Sets a delegate for implementing accessibility support via composition
  /// (as opposed to inheritance). For more details, see
  /// AccessibilityDelegate.
  ///
  /// <strong>Note:</strong> On platform versions prior to
  /// android.os.Build.VERSION_CODES\#M API 23, delegate methods on
  /// views in the {@code android.widget.*} package are called <i>before</i>
  /// host methods. This prevents certain properties such as class name from
  /// being modified by overriding
  /// AccessibilityDelegate\#onInitializeAccessibilityNodeInfo(View, AccessibilityNodeInfo),
  /// as any changes will be overwritten by the host class.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#M API 23, delegate
  /// methods are called <i>after</i> host methods, which all properties to be
  /// modified without being overwritten by the host class.
  ///@param delegate the object to which accessibility method calls should be
  ///                 delegated
  /// This value may be {@code null}.
  ///@see AccessibilityDelegate
  void setAccessibilityDelegate(View_AccessibilityDelegate delegate) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAccessibilityDelegate,
          jni.JniType.voidType, [delegate.reference]).check();

  static final _id_getAccessibilityNodeProvider = jniAccessors.getMethodIDOf(
      _classRef,
      "getAccessibilityNodeProvider",
      "()Landroid/view/accessibility/AccessibilityNodeProvider;");

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the provider for managing a virtual view hierarchy rooted at this View
  /// and reported to android.accessibilityservice.AccessibilityServices
  /// that explore the window content.
  ///
  /// If this method returns an instance, this instance is responsible for managing
  /// AccessibilityNodeInfos describing the virtual sub-tree rooted at this
  /// View including the one representing the View itself. Similarly the returned
  /// instance is responsible for performing accessibility actions on any virtual
  /// view or the root view itself.
  ///
  ///
  ///
  /// If an AccessibilityDelegate has been specified via calling
  /// \#setAccessibilityDelegate(AccessibilityDelegate) its
  /// AccessibilityDelegate\#getAccessibilityNodeProvider(View)
  /// is responsible for handling this call.
  ///
  ///
  ///@return The provider.
  ///@see AccessibilityNodeProvider
  accessibilitynodeprovider_.AccessibilityNodeProvider
      getAccessibilityNodeProvider() =>
          accessibilitynodeprovider_.AccessibilityNodeProvider.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_getAccessibilityNodeProvider,
                  jni.JniType.objectType, []).object);

  static final _id_getContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "getContentDescription", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getContentDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the View's content description.
  ///
  /// <strong>Note:</strong> Do not override this method, as it will have no
  /// effect on the content description presented to accessibility services.
  /// You must call \#setContentDescription(CharSequence) to modify the
  /// content description.
  ///@return the content description
  ///@see \#setContentDescription(CharSequence)
  ///@attr ref android.R.styleable\#View_contentDescription
  jni.JniObject getContentDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getContentDescription, jni.JniType.objectType, []).object);

  static final _id_setContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "setContentDescription", "(Ljava/lang/CharSequence;)V");

  /// from: public void setContentDescription(java.lang.CharSequence contentDescription)
  ///
  /// Sets the View's content description.
  ///
  /// A content description briefly describes the view and is primarily used
  /// for accessibility support to determine how a view should be presented to
  /// the user. In the case of a view with no textual representation, such as
  /// android.widget.ImageButton, a useful content description
  /// explains what the view does. For example, an image button with a phone
  /// icon that is used to place a call may use "Call" as its content
  /// description. An image of a floppy disk that is used to save a file may
  /// use "Save".
  ///@param contentDescription The content description.
  ///@see \#getContentDescription()
  ///@attr ref android.R.styleable\#View_contentDescription
  void setContentDescription(jni.JniObject contentDescription) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentDescription,
          jni.JniType.voidType, [contentDescription.reference]).check();

  static final _id_setAccessibilityTraversalBefore = jniAccessors.getMethodIDOf(
      _classRef, "setAccessibilityTraversalBefore", "(I)V");

  /// from: public void setAccessibilityTraversalBefore(int beforeId)
  ///
  /// Sets the id of a view before which this one is visited in accessibility traversal.
  /// A screen-reader must visit the content of this view before the content of the one
  /// it precedes. For example, if view B is set to be before view A, then a screen-reader
  /// will traverse the entire content of B before traversing the entire content of A,
  /// regardles of what traversal strategy it is using.
  ///
  /// Views that do not have specified before/after relationships are traversed in order
  /// determined by the screen-reader.
  ///
  ///
  ///
  /// Setting that this view is before a view that is not important for accessibility
  /// or if this view is not important for accessibility will have no effect as the
  /// screen-reader is not aware of unimportant views.
  ///
  ///
  ///@param beforeId The id of a view this one precedes in accessibility traversal.
  ///@attr ref android.R.styleable\#View_accessibilityTraversalBefore
  ///@see \#setImportantForAccessibility(int)
  void setAccessibilityTraversalBefore(int beforeId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAccessibilityTraversalBefore,
          jni.JniType.voidType,
          [beforeId]).check();

  static final _id_getAccessibilityTraversalBefore = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityTraversalBefore", "()I");

  /// from: public int getAccessibilityTraversalBefore()
  ///
  /// Gets the id of a view before which this one is visited in accessibility traversal.
  ///@return The id of a view this one precedes in accessibility traversal if
  ///         specified, otherwise \#NO_ID.
  ///@see \#setAccessibilityTraversalBefore(int)
  int getAccessibilityTraversalBefore() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAccessibilityTraversalBefore,
      jni.JniType.intType, []).integer;

  static final _id_setAccessibilityTraversalAfter = jniAccessors.getMethodIDOf(
      _classRef, "setAccessibilityTraversalAfter", "(I)V");

  /// from: public void setAccessibilityTraversalAfter(int afterId)
  ///
  /// Sets the id of a view after which this one is visited in accessibility traversal.
  /// A screen-reader must visit the content of the other view before the content of this
  /// one. For example, if view B is set to be after view A, then a screen-reader
  /// will traverse the entire content of A before traversing the entire content of B,
  /// regardles of what traversal strategy it is using.
  ///
  /// Views that do not have specified before/after relationships are traversed in order
  /// determined by the screen-reader.
  ///
  ///
  ///
  /// Setting that this view is after a view that is not important for accessibility
  /// or if this view is not important for accessibility will have no effect as the
  /// screen-reader is not aware of unimportant views.
  ///
  ///
  ///@param afterId The id of a view this one succedees in accessibility traversal.
  ///@attr ref android.R.styleable\#View_accessibilityTraversalAfter
  ///@see \#setImportantForAccessibility(int)
  void setAccessibilityTraversalAfter(int afterId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAccessibilityTraversalAfter,
          jni.JniType.voidType,
          [afterId]).check();

  static final _id_getAccessibilityTraversalAfter = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityTraversalAfter", "()I");

  /// from: public int getAccessibilityTraversalAfter()
  ///
  /// Gets the id of a view after which this one is visited in accessibility traversal.
  ///@return The id of a view this one succeedes in accessibility traversal if
  ///         specified, otherwise \#NO_ID.
  ///@see \#setAccessibilityTraversalAfter(int)
  int getAccessibilityTraversalAfter() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAccessibilityTraversalAfter,
      jni.JniType.intType, []).integer;

  static final _id_getLabelFor =
      jniAccessors.getMethodIDOf(_classRef, "getLabelFor", "()I");

  /// from: public int getLabelFor()
  ///
  /// Gets the id of a view for which this view serves as a label for
  /// accessibility purposes.
  ///@return The labeled view id.
  int getLabelFor() => jniAccessors.callMethodWithArgs(
      reference, _id_getLabelFor, jni.JniType.intType, []).integer;

  static final _id_setLabelFor =
      jniAccessors.getMethodIDOf(_classRef, "setLabelFor", "(I)V");

  /// from: public void setLabelFor(int id)
  ///
  /// Sets the id of a view for which this view serves as a label for
  /// accessibility purposes.
  ///@param id The labeled view id.
  void setLabelFor(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_setLabelFor, jni.JniType.voidType, [id]).check();

  static final _id_isFocused =
      jniAccessors.getMethodIDOf(_classRef, "isFocused", "()Z");

  /// from: public boolean isFocused()
  ///
  /// Returns true if this view has focus
  ///@return True if this view has focus, false otherwise.
  bool isFocused() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocused, jni.JniType.booleanType, []).boolean;

  static final _id_findFocus = jniAccessors.getMethodIDOf(
      _classRef, "findFocus", "()Landroid/view/View;");

  /// from: public android.view.View findFocus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the view in the hierarchy rooted at this view that currently has
  /// focus.
  ///@return The view that currently has focus, or null if no focused view can
  ///         be found.
  View findFocus() => View.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_findFocus, jni.JniType.objectType, []).object);

  static final _id_isScrollContainer =
      jniAccessors.getMethodIDOf(_classRef, "isScrollContainer", "()Z");

  /// from: public boolean isScrollContainer()
  ///
  /// Indicates whether this view is one of the set of scrollable containers in
  /// its window.
  ///@return whether this view is one of the set of scrollable containers in
  /// its window
  ///@attr ref android.R.styleable\#View_isScrollContainer
  bool isScrollContainer() => jniAccessors.callMethodWithArgs(
      reference, _id_isScrollContainer, jni.JniType.booleanType, []).boolean;

  static final _id_setScrollContainer =
      jniAccessors.getMethodIDOf(_classRef, "setScrollContainer", "(Z)V");

  /// from: public void setScrollContainer(boolean isScrollContainer)
  ///
  /// Change whether this view is one of the set of scrollable containers in
  /// its window.  This will be used to determine whether the window can
  /// resize or must pan when a soft input area is open -- scrollable
  /// containers allow the window to use resize mode since the container
  /// will appropriately shrink.
  ///@attr ref android.R.styleable\#View_isScrollContainer
  void setScrollContainer(bool isScrollContainer) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScrollContainer,
          jni.JniType.voidType, [isScrollContainer]).check();

  static final _id_getDrawingCacheQuality =
      jniAccessors.getMethodIDOf(_classRef, "getDrawingCacheQuality", "()I");

  /// from: public int getDrawingCacheQuality()
  ///
  /// Returns the quality of the drawing cache.
  ///@return One of \#DRAWING_CACHE_QUALITY_AUTO,
  ///         \#DRAWING_CACHE_QUALITY_LOW, or \#DRAWING_CACHE_QUALITY_HIGH
  ///
  /// Value is android.view.View\#DRAWING_CACHE_QUALITY_LOW, android.view.View\#DRAWING_CACHE_QUALITY_HIGH, or android.view.View\#DRAWING_CACHE_QUALITY_AUTO
  ///@see \#setDrawingCacheQuality(int)
  ///@see \#setDrawingCacheEnabled(boolean)
  ///@see \#isDrawingCacheEnabled()
  ///@attr ref android.R.styleable\#View_drawingCacheQuality
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  int getDrawingCacheQuality() => jniAccessors.callMethodWithArgs(
      reference, _id_getDrawingCacheQuality, jni.JniType.intType, []).integer;

  static final _id_setDrawingCacheQuality =
      jniAccessors.getMethodIDOf(_classRef, "setDrawingCacheQuality", "(I)V");

  /// from: public void setDrawingCacheQuality(int quality)
  ///
  /// Set the drawing cache quality of this view. This value is used only when the
  /// drawing cache is enabled
  ///@param quality One of \#DRAWING_CACHE_QUALITY_AUTO,
  ///        \#DRAWING_CACHE_QUALITY_LOW, or \#DRAWING_CACHE_QUALITY_HIGH
  ///
  /// Value is android.view.View\#DRAWING_CACHE_QUALITY_LOW, android.view.View\#DRAWING_CACHE_QUALITY_HIGH, or android.view.View\#DRAWING_CACHE_QUALITY_AUTO
  ///@see \#getDrawingCacheQuality()
  ///@see \#setDrawingCacheEnabled(boolean)
  ///@see \#isDrawingCacheEnabled()
  ///@attr ref android.R.styleable\#View_drawingCacheQuality
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void setDrawingCacheQuality(int quality) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDrawingCacheQuality,
      jni.JniType.voidType,
      [quality]).check();

  static final _id_getKeepScreenOn =
      jniAccessors.getMethodIDOf(_classRef, "getKeepScreenOn", "()Z");

  /// from: public boolean getKeepScreenOn()
  ///
  /// Returns whether the screen should remain on, corresponding to the current
  /// value of \#KEEP_SCREEN_ON.
  ///@return Returns true if \#KEEP_SCREEN_ON is set.
  ///@see \#setKeepScreenOn(boolean)
  ///@attr ref android.R.styleable\#View_keepScreenOn
  bool getKeepScreenOn() => jniAccessors.callMethodWithArgs(
      reference, _id_getKeepScreenOn, jni.JniType.booleanType, []).boolean;

  static final _id_setKeepScreenOn =
      jniAccessors.getMethodIDOf(_classRef, "setKeepScreenOn", "(Z)V");

  /// from: public void setKeepScreenOn(boolean keepScreenOn)
  ///
  /// Controls whether the screen should remain on, modifying the
  /// value of \#KEEP_SCREEN_ON.
  ///@param keepScreenOn Supply true to set \#KEEP_SCREEN_ON.
  ///@see \#getKeepScreenOn()
  ///@attr ref android.R.styleable\#View_keepScreenOn
  void setKeepScreenOn(bool keepScreenOn) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setKeepScreenOn,
      jni.JniType.voidType,
      [keepScreenOn]).check();

  static final _id_getNextFocusLeftId =
      jniAccessors.getMethodIDOf(_classRef, "getNextFocusLeftId", "()I");

  /// from: public int getNextFocusLeftId()
  ///
  /// Gets the id of the view to use when the next focus is \#FOCUS_LEFT.
  ///@return The next focus ID, or \#NO_ID if the framework should decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusLeft
  int getNextFocusLeftId() => jniAccessors.callMethodWithArgs(
      reference, _id_getNextFocusLeftId, jni.JniType.intType, []).integer;

  static final _id_setNextFocusLeftId =
      jniAccessors.getMethodIDOf(_classRef, "setNextFocusLeftId", "(I)V");

  /// from: public void setNextFocusLeftId(int nextFocusLeftId)
  ///
  /// Sets the id of the view to use when the next focus is \#FOCUS_LEFT.
  ///@param nextFocusLeftId The next focus ID, or \#NO_ID if the framework should
  /// decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusLeft
  void setNextFocusLeftId(int nextFocusLeftId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNextFocusLeftId,
          jni.JniType.voidType, [nextFocusLeftId]).check();

  static final _id_getNextFocusRightId =
      jniAccessors.getMethodIDOf(_classRef, "getNextFocusRightId", "()I");

  /// from: public int getNextFocusRightId()
  ///
  /// Gets the id of the view to use when the next focus is \#FOCUS_RIGHT.
  ///@return The next focus ID, or \#NO_ID if the framework should decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusRight
  int getNextFocusRightId() => jniAccessors.callMethodWithArgs(
      reference, _id_getNextFocusRightId, jni.JniType.intType, []).integer;

  static final _id_setNextFocusRightId =
      jniAccessors.getMethodIDOf(_classRef, "setNextFocusRightId", "(I)V");

  /// from: public void setNextFocusRightId(int nextFocusRightId)
  ///
  /// Sets the id of the view to use when the next focus is \#FOCUS_RIGHT.
  ///@param nextFocusRightId The next focus ID, or \#NO_ID if the framework should
  /// decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusRight
  void setNextFocusRightId(int nextFocusRightId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNextFocusRightId,
          jni.JniType.voidType, [nextFocusRightId]).check();

  static final _id_getNextFocusUpId =
      jniAccessors.getMethodIDOf(_classRef, "getNextFocusUpId", "()I");

  /// from: public int getNextFocusUpId()
  ///
  /// Gets the id of the view to use when the next focus is \#FOCUS_UP.
  ///@return The next focus ID, or \#NO_ID if the framework should decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusUp
  int getNextFocusUpId() => jniAccessors.callMethodWithArgs(
      reference, _id_getNextFocusUpId, jni.JniType.intType, []).integer;

  static final _id_setNextFocusUpId =
      jniAccessors.getMethodIDOf(_classRef, "setNextFocusUpId", "(I)V");

  /// from: public void setNextFocusUpId(int nextFocusUpId)
  ///
  /// Sets the id of the view to use when the next focus is \#FOCUS_UP.
  ///@param nextFocusUpId The next focus ID, or \#NO_ID if the framework should
  /// decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusUp
  void setNextFocusUpId(int nextFocusUpId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setNextFocusUpId,
      jni.JniType.voidType,
      [nextFocusUpId]).check();

  static final _id_getNextFocusDownId =
      jniAccessors.getMethodIDOf(_classRef, "getNextFocusDownId", "()I");

  /// from: public int getNextFocusDownId()
  ///
  /// Gets the id of the view to use when the next focus is \#FOCUS_DOWN.
  ///@return The next focus ID, or \#NO_ID if the framework should decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusDown
  int getNextFocusDownId() => jniAccessors.callMethodWithArgs(
      reference, _id_getNextFocusDownId, jni.JniType.intType, []).integer;

  static final _id_setNextFocusDownId =
      jniAccessors.getMethodIDOf(_classRef, "setNextFocusDownId", "(I)V");

  /// from: public void setNextFocusDownId(int nextFocusDownId)
  ///
  /// Sets the id of the view to use when the next focus is \#FOCUS_DOWN.
  ///@param nextFocusDownId The next focus ID, or \#NO_ID if the framework should
  /// decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusDown
  void setNextFocusDownId(int nextFocusDownId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNextFocusDownId,
          jni.JniType.voidType, [nextFocusDownId]).check();

  static final _id_getNextFocusForwardId =
      jniAccessors.getMethodIDOf(_classRef, "getNextFocusForwardId", "()I");

  /// from: public int getNextFocusForwardId()
  ///
  /// Gets the id of the view to use when the next focus is \#FOCUS_FORWARD.
  ///@return The next focus ID, or \#NO_ID if the framework should decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusForward
  int getNextFocusForwardId() => jniAccessors.callMethodWithArgs(
      reference, _id_getNextFocusForwardId, jni.JniType.intType, []).integer;

  static final _id_setNextFocusForwardId =
      jniAccessors.getMethodIDOf(_classRef, "setNextFocusForwardId", "(I)V");

  /// from: public void setNextFocusForwardId(int nextFocusForwardId)
  ///
  /// Sets the id of the view to use when the next focus is \#FOCUS_FORWARD.
  ///@param nextFocusForwardId The next focus ID, or \#NO_ID if the framework should
  /// decide automatically.
  ///@attr ref android.R.styleable\#View_nextFocusForward
  void setNextFocusForwardId(int nextFocusForwardId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNextFocusForwardId,
          jni.JniType.voidType, [nextFocusForwardId]).check();

  static final _id_getNextClusterForwardId =
      jniAccessors.getMethodIDOf(_classRef, "getNextClusterForwardId", "()I");

  /// from: public int getNextClusterForwardId()
  ///
  /// Gets the id of the root of the next keyboard navigation cluster.
  ///@return The next keyboard navigation cluster ID, or \#NO_ID if the framework should
  /// decide automatically.
  ///@attr ref android.R.styleable\#View_nextClusterForward
  int getNextClusterForwardId() => jniAccessors.callMethodWithArgs(
      reference, _id_getNextClusterForwardId, jni.JniType.intType, []).integer;

  static final _id_setNextClusterForwardId =
      jniAccessors.getMethodIDOf(_classRef, "setNextClusterForwardId", "(I)V");

  /// from: public void setNextClusterForwardId(int nextClusterForwardId)
  ///
  /// Sets the id of the view to use as the root of the next keyboard navigation cluster.
  ///@param nextClusterForwardId The next cluster ID, or \#NO_ID if the framework should
  /// decide automatically.
  ///@attr ref android.R.styleable\#View_nextClusterForward
  void setNextClusterForwardId(int nextClusterForwardId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNextClusterForwardId,
          jni.JniType.voidType, [nextClusterForwardId]).check();

  static final _id_isShown =
      jniAccessors.getMethodIDOf(_classRef, "isShown", "()Z");

  /// from: public boolean isShown()
  ///
  /// Returns the visibility of this view and all of its ancestors
  ///@return True if this view and all of its ancestors are \#VISIBLE
  bool isShown() => jniAccessors.callMethodWithArgs(
      reference, _id_isShown, jni.JniType.booleanType, []).boolean;

  static final _id_fitSystemWindows = jniAccessors.getMethodIDOf(
      _classRef, "fitSystemWindows", "(Landroid/graphics/Rect;)Z");

  /// from: protected boolean fitSystemWindows(android.graphics.Rect insets)
  ///
  /// Called by the view hierarchy when the content insets for a window have
  /// changed, to allow it to adjust its content to fit within those windows.
  /// The content insets tell you the space that the status bar, input method,
  /// and other system windows infringe on the application's window.
  ///
  /// You do not normally need to deal with this function, since the default
  /// window decoration given to applications takes care of applying it to the
  /// content of the window.  If you use \#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
  /// or \#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION this will not be the case,
  /// and your content can be placed under those system elements.  You can then
  /// use this method within your view hierarchy if you have parts of your UI
  /// which you would like to ensure are not being covered.
  ///
  /// The default implementation of this method simply applies the content
  /// insets to the view's padding, consuming that content (modifying the
  /// insets to be 0), and returning true.  This behavior is off by default, but can
  /// be enabled through \#setFitsSystemWindows(boolean).
  ///
  /// This function's traversal down the hierarchy is depth-first.  The same content
  /// insets object is propagated down the hierarchy, so any changes made to it will
  /// be seen by all following views (including potentially ones above in
  /// the hierarchy since this is a depth-first traversal).  The first view
  /// that returns true will abort the entire traversal.
  ///
  /// The default implementation works well for a situation where it is
  /// used with a container that covers the entire window, allowing it to
  /// apply the appropriate insets to its content on all edges.  If you need
  /// a more complicated layout (such as two different views fitting system
  /// windows, one on the top of the window, and one on the bottom),
  /// you can override the method and handle the insets however you would like.
  /// Note that the insets provided by the framework are always relative to the
  /// far edges of the window, not accounting for the location of the called view
  /// within that window.  (In fact when this method is called you do not yet know
  /// where the layout will place the view, as it is done before layout happens.)
  ///
  /// Note: unlike many View methods, there is no dispatch phase to this
  /// call.  If you are overriding it in a ViewGroup and want to allow the
  /// call to continue to your children, you must be sure to call the super
  /// implementation.
  ///
  /// Here is a sample layout that makes use of fitting system windows
  /// to have controls for a video view placed inside of the window decorations
  /// that it hides and shows.  This can be used with code like the second
  /// sample (video player) shown in \#setSystemUiVisibility(int).
  ///
  /// {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
  ///@param insets Current content insets of the window.  Prior to
  /// android.os.Build.VERSION_CODES\#JELLY_BEAN you must not modify
  /// the insets or else you and Android will be unhappy.
  ///@return {@code true} if this view applied the insets and it should not
  /// continue propagating further down the hierarchy, {@code false} otherwise.
  ///@see \#getFitsSystemWindows()
  ///@see \#setFitsSystemWindows(boolean)
  ///@see \#setSystemUiVisibility(int)
  ///@deprecated As of API 20 use \#dispatchApplyWindowInsets(WindowInsets) to apply
  /// insets to views. Views should override \#onApplyWindowInsets(WindowInsets) or use
  /// \#setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)
  /// to implement handling their own insets.
  bool fitSystemWindows(rect_.Rect insets) => jniAccessors.callMethodWithArgs(
      reference,
      _id_fitSystemWindows,
      jni.JniType.booleanType,
      [insets.reference]).boolean;

  static final _id_onApplyWindowInsets = jniAccessors.getMethodIDOf(
      _classRef,
      "onApplyWindowInsets",
      "(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets onApplyWindowInsets(android.view.WindowInsets insets)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when the view should apply WindowInsets according to its internal policy.
  ///
  /// This method should be overridden by views that wish to apply a policy different from or
  /// in addition to the default behavior. Clients that wish to force a view subtree
  /// to apply insets should call \#dispatchApplyWindowInsets(WindowInsets).
  ///
  ///
  /// Clients may supply an OnApplyWindowInsetsListener to a view. If one is set
  /// it will be called during dispatch instead of this method. The listener may optionally
  /// call this method from its own implementation if it wishes to apply the view's default
  /// insets policy in addition to its own.
  ///
  ///
  /// Implementations of this method should either return the insets parameter unchanged
  /// or a new WindowInsets cloned from the supplied insets with any insets consumed
  /// that this view applied itself. This allows new inset types added in future platform
  /// versions to pass through existing implementations unchanged without being erroneously
  /// consumed.
  ///
  ///
  /// By default if a view's \#setFitsSystemWindows(boolean) fitsSystemWindows
  /// property is set then the view will consume the system window insets and apply them
  /// as padding for the view.
  ///
  ///@param insets Insets to apply
  ///@return The supplied insets with any applied insets consumed
  windowinsets_.WindowInsets onApplyWindowInsets(
          windowinsets_.WindowInsets insets) =>
      windowinsets_.WindowInsets.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onApplyWindowInsets,
          jni.JniType.objectType,
          [insets.reference]).object);

  static final _id_setOnApplyWindowInsetsListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnApplyWindowInsetsListener",
      "(Landroid/view/View\$OnApplyWindowInsetsListener;)V");

  /// from: public void setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener listener)
  ///
  /// Set an OnApplyWindowInsetsListener to take over the policy for applying
  /// window insets to this view. The listener's
  /// OnApplyWindowInsetsListener\#onApplyWindowInsets(View, WindowInsets) onApplyWindowInsets
  /// method will be called instead of the view's
  /// \#onApplyWindowInsets(WindowInsets) onApplyWindowInsets method.
  ///@param listener Listener to set
  ///@see \#onApplyWindowInsets(WindowInsets)
  void setOnApplyWindowInsetsListener(
          View_OnApplyWindowInsetsListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnApplyWindowInsetsListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_dispatchApplyWindowInsets = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchApplyWindowInsets",
      "(Landroid/view/WindowInsets;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets dispatchApplyWindowInsets(android.view.WindowInsets insets)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request to apply the given window insets to this view or another view in its subtree.
  ///
  /// This method should be called by clients wishing to apply insets corresponding to areas
  /// obscured by window decorations or overlays. This can include the status and navigation bars,
  /// action bars, input methods and more. New inset categories may be added in the future.
  /// The method returns the insets provided minus any that were applied by this view or its
  /// children.
  ///
  ///
  /// Clients wishing to provide custom behavior should override the
  /// \#onApplyWindowInsets(WindowInsets) method or alternatively provide a
  /// OnApplyWindowInsetsListener via the
  /// \#setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener) setOnApplyWindowInsetsListener
  /// method.
  ///
  ///
  /// This method replaces the older \#fitSystemWindows(Rect) fitSystemWindows method.
  ///
  ///
  ///@param insets Insets to apply
  ///@return The provided insets minus the insets that were consumed
  windowinsets_.WindowInsets dispatchApplyWindowInsets(
          windowinsets_.WindowInsets insets) =>
      windowinsets_.WindowInsets.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchApplyWindowInsets,
          jni.JniType.objectType,
          [insets.reference]).object);

  static final _id_getRootWindowInsets = jniAccessors.getMethodIDOf(
      _classRef, "getRootWindowInsets", "()Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets getRootWindowInsets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide original WindowInsets that are dispatched to the view hierarchy. The insets are
  /// only available if the view is attached.
  ///@return WindowInsets from the top of the view hierarchy or null if View is detached
  windowinsets_.WindowInsets getRootWindowInsets() =>
      windowinsets_.WindowInsets.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getRootWindowInsets,
          jni.JniType.objectType, []).object);

  static final _id_computeSystemWindowInsets = jniAccessors.getMethodIDOf(
      _classRef,
      "computeSystemWindowInsets",
      "(Landroid/view/WindowInsets;Landroid/graphics/Rect;)Landroid/view/WindowInsets;");

  /// from: public android.view.WindowInsets computeSystemWindowInsets(android.view.WindowInsets in, android.graphics.Rect outLocalInsets)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Compute insets that should be consumed by this view and the ones that should propagate
  /// to those under it.
  ///@param in Insets currently being processed by this View, likely received as a parameter
  ///           to \#onApplyWindowInsets(WindowInsets).
  ///@param outLocalInsets A Rect that will receive the insets that should be consumed
  ///                       by this view
  ///@return Insets that should be passed along to views under this one
  windowinsets_.WindowInsets computeSystemWindowInsets(
          windowinsets_.WindowInsets in0, rect_.Rect outLocalInsets) =>
      windowinsets_.WindowInsets.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_computeSystemWindowInsets,
          jni.JniType.objectType,
          [in0.reference, outLocalInsets.reference]).object);

  static final _id_setFitsSystemWindows =
      jniAccessors.getMethodIDOf(_classRef, "setFitsSystemWindows", "(Z)V");

  /// from: public void setFitsSystemWindows(boolean fitSystemWindows)
  ///
  /// Sets whether or not this view should account for system screen decorations
  /// such as the status bar and inset its content; that is, controlling whether
  /// the default implementation of \#fitSystemWindows(Rect) will be
  /// executed.  See that method for more details.
  ///
  /// Note that if you are providing your own implementation of
  /// \#fitSystemWindows(Rect), then there is no need to set this
  /// flag to true -- your implementation will be overriding the default
  /// implementation that checks this flag.
  ///@param fitSystemWindows If true, then the default implementation of
  /// \#fitSystemWindows(Rect) will be executed.
  ///@attr ref android.R.styleable\#View_fitsSystemWindows
  ///@see \#getFitsSystemWindows()
  ///@see \#fitSystemWindows(Rect)
  ///@see \#setSystemUiVisibility(int)
  void setFitsSystemWindows(bool fitSystemWindows) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFitsSystemWindows,
          jni.JniType.voidType, [fitSystemWindows]).check();

  static final _id_getFitsSystemWindows =
      jniAccessors.getMethodIDOf(_classRef, "getFitsSystemWindows", "()Z");

  /// from: public boolean getFitsSystemWindows()
  ///
  /// Check for state of \#setFitsSystemWindows(boolean). If this method
  /// returns {@code true}, the default implementation of \#fitSystemWindows(Rect)
  /// will be executed.
  ///@return {@code true} if the default implementation of
  /// \#fitSystemWindows(Rect) will be executed.
  ///@attr ref android.R.styleable\#View_fitsSystemWindows
  ///@see \#setFitsSystemWindows(boolean)
  ///@see \#fitSystemWindows(Rect)
  ///@see \#setSystemUiVisibility(int)
  bool getFitsSystemWindows() => jniAccessors.callMethodWithArgs(
      reference, _id_getFitsSystemWindows, jni.JniType.booleanType, []).boolean;

  static final _id_requestFitSystemWindows =
      jniAccessors.getMethodIDOf(_classRef, "requestFitSystemWindows", "()V");

  /// from: public void requestFitSystemWindows()
  ///
  /// Ask that a new dispatch of \#fitSystemWindows(Rect) be performed.
  ///@deprecated Use \#requestApplyInsets() for newer platform versions.
  void requestFitSystemWindows() => jniAccessors.callMethodWithArgs(
      reference, _id_requestFitSystemWindows, jni.JniType.voidType, []).check();

  static final _id_requestApplyInsets =
      jniAccessors.getMethodIDOf(_classRef, "requestApplyInsets", "()V");

  /// from: public void requestApplyInsets()
  ///
  /// Ask that a new dispatch of \#onApplyWindowInsets(WindowInsets) be performed.
  void requestApplyInsets() => jniAccessors.callMethodWithArgs(
      reference, _id_requestApplyInsets, jni.JniType.voidType, []).check();

  static final _id_getVisibility =
      jniAccessors.getMethodIDOf(_classRef, "getVisibility", "()I");

  /// from: public int getVisibility()
  ///
  /// Returns the visibility status for this view.
  ///@return One of \#VISIBLE, \#INVISIBLE, or \#GONE.
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  ///@attr ref android.R.styleable\#View_visibility
  int getVisibility() => jniAccessors.callMethodWithArgs(
      reference, _id_getVisibility, jni.JniType.intType, []).integer;

  static final _id_setVisibility =
      jniAccessors.getMethodIDOf(_classRef, "setVisibility", "(I)V");

  /// from: public void setVisibility(int visibility)
  ///
  /// Set the visibility state of this view.
  ///@param visibility One of \#VISIBLE, \#INVISIBLE, or \#GONE.
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  ///@attr ref android.R.styleable\#View_visibility
  void setVisibility(int visibility) => jniAccessors.callMethodWithArgs(
      reference, _id_setVisibility, jni.JniType.voidType, [visibility]).check();

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Returns the enabled status for this view. The interpretation of the
  /// enabled state varies by subclass.
  ///@return True if this view is enabled, false otherwise.
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)V");

  /// from: public void setEnabled(boolean enabled)
  ///
  /// Set the enabled state of this view. The interpretation of the enabled
  /// state varies by subclass.
  ///@param enabled True if this view is enabled, false otherwise.
  void setEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled, jni.JniType.voidType, [enabled]).check();

  static final _id_setFocusable =
      jniAccessors.getMethodIDOf(_classRef, "setFocusable", "(Z)V");

  /// from: public void setFocusable(boolean focusable)
  ///
  /// Set whether this view can receive the focus.
  ///
  /// Setting this to false will also ensure that this view is not focusable
  /// in touch mode.
  ///@param focusable If true, this view can receive the focus.
  ///@see \#setFocusableInTouchMode(boolean)
  ///@see \#setFocusable(int)
  ///@attr ref android.R.styleable\#View_focusable
  void setFocusable(bool focusable) => jniAccessors.callMethodWithArgs(
      reference, _id_setFocusable, jni.JniType.voidType, [focusable]).check();

  static final _id_setFocusable1 =
      jniAccessors.getMethodIDOf(_classRef, "setFocusable", "(I)V");

  /// from: public void setFocusable(int focusable)
  ///
  /// Sets whether this view can receive focus.
  ///
  /// Setting this to \#FOCUSABLE_AUTO tells the framework to determine focusability
  /// automatically based on the view's interactivity. This is the default.
  ///
  /// Setting this to NOT_FOCUSABLE will ensure that this view is also not focusable
  /// in touch mode.
  ///@param focusable One of \#NOT_FOCUSABLE, \#FOCUSABLE,
  ///                  or \#FOCUSABLE_AUTO.
  /// Value is android.view.View\#NOT_FOCUSABLE, android.view.View\#FOCUSABLE, or android.view.View\#FOCUSABLE_AUTO
  ///@see \#setFocusableInTouchMode(boolean)
  ///@attr ref android.R.styleable\#View_focusable
  void setFocusable1(int focusable) => jniAccessors.callMethodWithArgs(
      reference, _id_setFocusable1, jni.JniType.voidType, [focusable]).check();

  static final _id_setFocusableInTouchMode =
      jniAccessors.getMethodIDOf(_classRef, "setFocusableInTouchMode", "(Z)V");

  /// from: public void setFocusableInTouchMode(boolean focusableInTouchMode)
  ///
  /// Set whether this view can receive focus while in touch mode.
  ///
  /// Setting this to true will also ensure that this view is focusable.
  ///@param focusableInTouchMode If true, this view can receive the focus while
  ///   in touch mode.
  ///@see \#setFocusable(boolean)
  ///@attr ref android.R.styleable\#View_focusableInTouchMode
  void setFocusableInTouchMode(bool focusableInTouchMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFocusableInTouchMode,
          jni.JniType.voidType, [focusableInTouchMode]).check();

  static final _id_setAutofillHints = jniAccessors.getMethodIDOf(
      _classRef, "setAutofillHints", "([Ljava/lang/String;)V");

  /// from: public void setAutofillHints(java.lang.String[] autofillHints)
  ///
  /// Sets the hints that help an android.service.autofill.AutofillService determine how
  /// to autofill the view with the user's data.
  ///
  /// Typically, there is only one way to autofill a view, but there could be more than one.
  /// For example, if the application accepts either an username or email address to identify
  /// an user.
  ///
  /// These hints are not validated by the Android System, but passed "as is" to the service.
  /// Hence, they can have any value, but it's recommended to use the {@code AUTOFILL_HINT_}
  /// constants such as:
  /// \#AUTOFILL_HINT_USERNAME, \#AUTOFILL_HINT_PASSWORD,
  /// \#AUTOFILL_HINT_EMAIL_ADDRESS,
  /// \#AUTOFILL_HINT_NAME,
  /// \#AUTOFILL_HINT_PHONE,
  /// \#AUTOFILL_HINT_POSTAL_ADDRESS, \#AUTOFILL_HINT_POSTAL_CODE,
  /// \#AUTOFILL_HINT_CREDIT_CARD_NUMBER, \#AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE,
  /// \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE,
  /// \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY,
  /// \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH or
  /// \#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR.
  ///@param autofillHints The autofill hints to set. If the array is emtpy, {@code null} is set.
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_autofillHints
  void setAutofillHints(jni.JniObject autofillHints) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAutofillHints,
          jni.JniType.voidType, [autofillHints.reference]).check();

  static final _id_setSoundEffectsEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setSoundEffectsEnabled", "(Z)V");

  /// from: public void setSoundEffectsEnabled(boolean soundEffectsEnabled)
  ///
  /// Set whether this view should have sound effects enabled for events such as
  /// clicking and touching.
  ///
  /// You may wish to disable sound effects for a view if you already play sounds,
  /// for instance, a dial key that plays dtmf tones.
  ///@param soundEffectsEnabled whether sound effects are enabled for this view.
  ///@see \#isSoundEffectsEnabled()
  ///@see \#playSoundEffect(int)
  ///@attr ref android.R.styleable\#View_soundEffectsEnabled
  void setSoundEffectsEnabled(bool soundEffectsEnabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSoundEffectsEnabled,
          jni.JniType.voidType, [soundEffectsEnabled]).check();

  static final _id_isSoundEffectsEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isSoundEffectsEnabled", "()Z");

  /// from: public boolean isSoundEffectsEnabled()
  ///
  /// @return whether this view should have sound effects enabled for events such as
  ///     clicking and touching.
  ///@see \#setSoundEffectsEnabled(boolean)
  ///@see \#playSoundEffect(int)
  ///@attr ref android.R.styleable\#View_soundEffectsEnabled
  bool isSoundEffectsEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isSoundEffectsEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setHapticFeedbackEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setHapticFeedbackEnabled", "(Z)V");

  /// from: public void setHapticFeedbackEnabled(boolean hapticFeedbackEnabled)
  ///
  /// Set whether this view should have haptic feedback for events such as
  /// long presses.
  ///
  /// You may wish to disable haptic feedback if your view already controls
  /// its own haptic feedback.
  ///@param hapticFeedbackEnabled whether haptic feedback enabled for this view.
  ///@see \#isHapticFeedbackEnabled()
  ///@see \#performHapticFeedback(int)
  ///@attr ref android.R.styleable\#View_hapticFeedbackEnabled
  void setHapticFeedbackEnabled(bool hapticFeedbackEnabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHapticFeedbackEnabled,
          jni.JniType.voidType, [hapticFeedbackEnabled]).check();

  static final _id_isHapticFeedbackEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isHapticFeedbackEnabled", "()Z");

  /// from: public boolean isHapticFeedbackEnabled()
  ///
  /// @return whether this view should have haptic feedback enabled for events
  /// long presses.
  ///@see \#setHapticFeedbackEnabled(boolean)
  ///@see \#performHapticFeedback(int)
  ///@attr ref android.R.styleable\#View_hapticFeedbackEnabled
  bool isHapticFeedbackEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isHapticFeedbackEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "setLayoutDirection", "(I)V");

  /// from: public void setLayoutDirection(int layoutDirection)
  ///
  /// Set the layout direction for this view. This will propagate a reset of layout direction
  /// resolution to the view's children and resolve layout direction for this view.
  ///@param layoutDirection the layout direction to set. Should be one of:
  ///
  /// \#LAYOUT_DIRECTION_LTR,
  /// \#LAYOUT_DIRECTION_RTL,
  /// \#LAYOUT_DIRECTION_INHERIT,
  /// \#LAYOUT_DIRECTION_LOCALE.
  ///
  /// Resolution will be done if the value is set to LAYOUT_DIRECTION_INHERIT. The resolution
  /// proceeds up the parent chain of the view to get the value. If there is no parent, then it
  /// will return the default \#LAYOUT_DIRECTION_LTR.
  ///
  /// Value is android.view.View\#LAYOUT_DIRECTION_LTR, android.view.View\#LAYOUT_DIRECTION_RTL, android.view.View\#LAYOUT_DIRECTION_INHERIT, or android.view.View\#LAYOUT_DIRECTION_LOCALE
  ///@attr ref android.R.styleable\#View_layoutDirection
  void setLayoutDirection(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutDirection,
          jni.JniType.voidType, [layoutDirection]).check();

  static final _id_getLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "getLayoutDirection", "()I");

  /// from: public int getLayoutDirection()
  ///
  /// Returns the resolved layout direction for this view.
  ///@return \#LAYOUT_DIRECTION_RTL if the layout direction is RTL or returns
  /// \#LAYOUT_DIRECTION_LTR if the layout direction is not RTL.
  ///
  /// For compatibility, this will return \#LAYOUT_DIRECTION_LTR if API version
  /// is lower than android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1.
  ///
  /// Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  ///@attr ref android.R.styleable\#View_layoutDirection
  int getLayoutDirection() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayoutDirection, jni.JniType.intType, []).integer;

  static final _id_hasTransientState =
      jniAccessors.getMethodIDOf(_classRef, "hasTransientState", "()Z");

  /// from: public boolean hasTransientState()
  ///
  /// Indicates whether the view is currently tracking transient state that the
  /// app should not need to concern itself with saving and restoring, but that
  /// the framework should take special note to preserve when possible.
  ///
  /// A view with transient state cannot be trivially rebound from an external
  /// data source, such as an adapter binding item views in a list. This may be
  /// because the view is performing an animation, tracking user selection
  /// of content, or similar.
  ///
  ///@return true if the view has transient state
  bool hasTransientState() => jniAccessors.callMethodWithArgs(
      reference, _id_hasTransientState, jni.JniType.booleanType, []).boolean;

  static final _id_setHasTransientState =
      jniAccessors.getMethodIDOf(_classRef, "setHasTransientState", "(Z)V");

  /// from: public void setHasTransientState(boolean hasTransientState)
  ///
  /// Set whether this view is currently tracking transient state that the
  /// framework should attempt to preserve when possible. This flag is reference counted,
  /// so every call to setHasTransientState(true) should be paired with a later call
  /// to setHasTransientState(false).
  ///
  /// A view with transient state cannot be trivially rebound from an external
  /// data source, such as an adapter binding item views in a list. This may be
  /// because the view is performing an animation, tracking user selection
  /// of content, or similar.
  ///
  ///@param hasTransientState true if this view has transient state
  void setHasTransientState(bool hasTransientState) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHasTransientState,
          jni.JniType.voidType, [hasTransientState]).check();

  static final _id_isAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "isAttachedToWindow", "()Z");

  /// from: public boolean isAttachedToWindow()
  ///
  /// Returns true if this view is currently attached to a window.
  bool isAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_isAttachedToWindow, jni.JniType.booleanType, []).boolean;

  static final _id_isLaidOut =
      jniAccessors.getMethodIDOf(_classRef, "isLaidOut", "()Z");

  /// from: public boolean isLaidOut()
  ///
  /// Returns true if this view has been through at least one layout since it
  /// was last attached to or detached from a window.
  bool isLaidOut() => jniAccessors.callMethodWithArgs(
      reference, _id_isLaidOut, jni.JniType.booleanType, []).boolean;

  static final _id_setWillNotDraw =
      jniAccessors.getMethodIDOf(_classRef, "setWillNotDraw", "(Z)V");

  /// from: public void setWillNotDraw(boolean willNotDraw)
  ///
  /// If this view doesn't do any drawing on its own, set this flag to
  /// allow further optimizations. By default, this flag is not set on
  /// View, but could be set on some View subclasses such as ViewGroup.
  ///
  /// Typically, if you override \#onDraw(android.graphics.Canvas)
  /// you should clear this flag.
  ///@param willNotDraw whether or not this View draw on its own
  void setWillNotDraw(bool willNotDraw) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWillNotDraw,
      jni.JniType.voidType,
      [willNotDraw]).check();

  static final _id_willNotDraw =
      jniAccessors.getMethodIDOf(_classRef, "willNotDraw", "()Z");

  /// from: public boolean willNotDraw()
  ///
  /// Returns whether or not this View draws on its own.
  ///@return true if this view has nothing to draw, false otherwise
  bool willNotDraw() => jniAccessors.callMethodWithArgs(
      reference, _id_willNotDraw, jni.JniType.booleanType, []).boolean;

  static final _id_setWillNotCacheDrawing =
      jniAccessors.getMethodIDOf(_classRef, "setWillNotCacheDrawing", "(Z)V");

  /// from: public void setWillNotCacheDrawing(boolean willNotCacheDrawing)
  ///
  /// When a View's drawing cache is enabled, drawing is redirected to an
  /// offscreen bitmap. Some views, like an ImageView, must be able to
  /// bypass this mechanism if they already draw a single bitmap, to avoid
  /// unnecessary usage of the memory.
  ///@param willNotCacheDrawing true if this view does not cache its
  ///        drawing, false otherwise
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void setWillNotCacheDrawing(bool willNotCacheDrawing) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWillNotCacheDrawing,
          jni.JniType.voidType, [willNotCacheDrawing]).check();

  static final _id_willNotCacheDrawing =
      jniAccessors.getMethodIDOf(_classRef, "willNotCacheDrawing", "()Z");

  /// from: public boolean willNotCacheDrawing()
  ///
  /// Returns whether or not this View can cache its drawing or not.
  ///@return true if this view does not cache its drawing, false otherwise
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  bool willNotCacheDrawing() => jniAccessors.callMethodWithArgs(
      reference, _id_willNotCacheDrawing, jni.JniType.booleanType, []).boolean;

  static final _id_isClickable =
      jniAccessors.getMethodIDOf(_classRef, "isClickable", "()Z");

  /// from: public boolean isClickable()
  ///
  /// Indicates whether this view reacts to click events or not.
  ///@return true if the view is clickable, false otherwise
  ///@see \#setClickable(boolean)
  ///@attr ref android.R.styleable\#View_clickable
  bool isClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isClickable, jni.JniType.booleanType, []).boolean;

  static final _id_setClickable =
      jniAccessors.getMethodIDOf(_classRef, "setClickable", "(Z)V");

  /// from: public void setClickable(boolean clickable)
  ///
  /// Enables or disables click events for this view. When a view
  /// is clickable it will change its state to "pressed" on every click.
  /// Subclasses should set the view clickable to visually react to
  /// user's clicks.
  ///@param clickable true to make the view clickable, false otherwise
  ///@see \#isClickable()
  ///@attr ref android.R.styleable\#View_clickable
  void setClickable(bool clickable) => jniAccessors.callMethodWithArgs(
      reference, _id_setClickable, jni.JniType.voidType, [clickable]).check();

  static final _id_isLongClickable =
      jniAccessors.getMethodIDOf(_classRef, "isLongClickable", "()Z");

  /// from: public boolean isLongClickable()
  ///
  /// Indicates whether this view reacts to long click events or not.
  ///@return true if the view is long clickable, false otherwise
  ///@see \#setLongClickable(boolean)
  ///@attr ref android.R.styleable\#View_longClickable
  bool isLongClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isLongClickable, jni.JniType.booleanType, []).boolean;

  static final _id_setLongClickable =
      jniAccessors.getMethodIDOf(_classRef, "setLongClickable", "(Z)V");

  /// from: public void setLongClickable(boolean longClickable)
  ///
  /// Enables or disables long click events for this view. When a view is long
  /// clickable it reacts to the user holding down the button for a longer
  /// duration than a tap. This event can either launch the listener or a
  /// context menu.
  ///@param longClickable true to make the view long clickable, false otherwise
  ///@see \#isLongClickable()
  ///@attr ref android.R.styleable\#View_longClickable
  void setLongClickable(bool longClickable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLongClickable,
      jni.JniType.voidType,
      [longClickable]).check();

  static final _id_isContextClickable =
      jniAccessors.getMethodIDOf(_classRef, "isContextClickable", "()Z");

  /// from: public boolean isContextClickable()
  ///
  /// Indicates whether this view reacts to context clicks or not.
  ///@return true if the view is context clickable, false otherwise
  ///@see \#setContextClickable(boolean)
  ///@attr ref android.R.styleable\#View_contextClickable
  bool isContextClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isContextClickable, jni.JniType.booleanType, []).boolean;

  static final _id_setContextClickable =
      jniAccessors.getMethodIDOf(_classRef, "setContextClickable", "(Z)V");

  /// from: public void setContextClickable(boolean contextClickable)
  ///
  /// Enables or disables context clicking for this view. This event can launch the listener.
  ///@param contextClickable true to make the view react to a context click, false otherwise
  ///@see \#isContextClickable()
  ///@attr ref android.R.styleable\#View_contextClickable
  void setContextClickable(bool contextClickable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContextClickable,
          jni.JniType.voidType, [contextClickable]).check();

  static final _id_setPressed =
      jniAccessors.getMethodIDOf(_classRef, "setPressed", "(Z)V");

  /// from: public void setPressed(boolean pressed)
  ///
  /// Sets the pressed state for this view.
  ///@see \#isClickable()
  ///@see \#setClickable(boolean)
  ///@param pressed Pass true to set the View's internal state to "pressed", or false to reverts
  ///        the View's internal state from a previously set "pressed" state.
  void setPressed(bool pressed) => jniAccessors.callMethodWithArgs(
      reference, _id_setPressed, jni.JniType.voidType, [pressed]).check();

  static final _id_dispatchSetPressed =
      jniAccessors.getMethodIDOf(_classRef, "dispatchSetPressed", "(Z)V");

  /// from: protected void dispatchSetPressed(boolean pressed)
  ///
  /// Dispatch setPressed to all of this View's children.
  ///@see \#setPressed(boolean)
  ///@param pressed The new pressed state
  void dispatchSetPressed(bool pressed) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchSetPressed,
      jni.JniType.voidType,
      [pressed]).check();

  static final _id_isPressed =
      jniAccessors.getMethodIDOf(_classRef, "isPressed", "()Z");

  /// from: public boolean isPressed()
  ///
  /// Indicates whether the view is currently in pressed state. Unless
  /// \#setPressed(boolean) is explicitly called, only clickable views can enter
  /// the pressed state.
  ///@see \#setPressed(boolean)
  ///@see \#isClickable()
  ///@see \#setClickable(boolean)
  ///@return true if the view is currently pressed, false otherwise
  bool isPressed() => jniAccessors.callMethodWithArgs(
      reference, _id_isPressed, jni.JniType.booleanType, []).boolean;

  static final _id_isSaveEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isSaveEnabled", "()Z");

  /// from: public boolean isSaveEnabled()
  ///
  /// Indicates whether this view will save its state (that is,
  /// whether its \#onSaveInstanceState method will be called).
  ///@return Returns true if the view state saving is enabled, else false.
  ///@see \#setSaveEnabled(boolean)
  ///@attr ref android.R.styleable\#View_saveEnabled
  bool isSaveEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isSaveEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setSaveEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setSaveEnabled", "(Z)V");

  /// from: public void setSaveEnabled(boolean enabled)
  ///
  /// Controls whether the saving of this view's state is
  /// enabled (that is, whether its \#onSaveInstanceState method
  /// will be called).  Note that even if freezing is enabled, the
  /// view still must have an id assigned to it (via \#setId(int))
  /// for its state to be saved.  This flag can only disable the
  /// saving of this view; any child views may still have their state saved.
  ///@param enabled Set to false to _disable_ state saving, or true
  /// (the default) to allow it.
  ///@see \#isSaveEnabled()
  ///@see \#setId(int)
  ///@see \#onSaveInstanceState()
  ///@attr ref android.R.styleable\#View_saveEnabled
  void setSaveEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setSaveEnabled, jni.JniType.voidType, [enabled]).check();

  static final _id_getFilterTouchesWhenObscured = jniAccessors.getMethodIDOf(
      _classRef, "getFilterTouchesWhenObscured", "()Z");

  /// from: public boolean getFilterTouchesWhenObscured()
  ///
  /// Gets whether the framework should discard touches when the view's
  /// window is obscured by another visible window.
  /// Refer to the View security documentation for more details.
  ///@return True if touch filtering is enabled.
  ///@see \#setFilterTouchesWhenObscured(boolean)
  ///@attr ref android.R.styleable\#View_filterTouchesWhenObscured
  bool getFilterTouchesWhenObscured() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getFilterTouchesWhenObscured,
      jni.JniType.booleanType, []).boolean;

  static final _id_setFilterTouchesWhenObscured = jniAccessors.getMethodIDOf(
      _classRef, "setFilterTouchesWhenObscured", "(Z)V");

  /// from: public void setFilterTouchesWhenObscured(boolean enabled)
  ///
  /// Sets whether the framework should discard touches when the view's
  /// window is obscured by another visible window.
  /// Refer to the View security documentation for more details.
  ///@param enabled True if touch filtering should be enabled.
  ///@see \#getFilterTouchesWhenObscured
  ///@attr ref android.R.styleable\#View_filterTouchesWhenObscured
  void setFilterTouchesWhenObscured(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setFilterTouchesWhenObscured,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_isSaveFromParentEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isSaveFromParentEnabled", "()Z");

  /// from: public boolean isSaveFromParentEnabled()
  ///
  /// Indicates whether the entire hierarchy under this view will save its
  /// state when a state saving traversal occurs from its parent.  The default
  /// is true; if false, these views will not be saved unless
  /// \#saveHierarchyState(SparseArray) is called directly on this view.
  ///@return Returns true if the view state saving from parent is enabled, else false.
  ///@see \#setSaveFromParentEnabled(boolean)
  bool isSaveFromParentEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isSaveFromParentEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setSaveFromParentEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setSaveFromParentEnabled", "(Z)V");

  /// from: public void setSaveFromParentEnabled(boolean enabled)
  ///
  /// Controls whether the entire hierarchy under this view will save its
  /// state when a state saving traversal occurs from its parent.  The default
  /// is true; if false, these views will not be saved unless
  /// \#saveHierarchyState(SparseArray) is called directly on this view.
  ///@param enabled Set to false to _disable_ state saving, or true
  /// (the default) to allow it.
  ///@see \#isSaveFromParentEnabled()
  ///@see \#setId(int)
  ///@see \#onSaveInstanceState()
  void setSaveFromParentEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSaveFromParentEnabled,
          jni.JniType.voidType, [enabled]).check();

  static final _id_isFocusable =
      jniAccessors.getMethodIDOf(_classRef, "isFocusable", "()Z");

  /// from: public final boolean isFocusable()
  ///
  /// Returns whether this View is currently able to take focus.
  ///@return True if this view can take focus, or false otherwise.
  bool isFocusable() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocusable, jni.JniType.booleanType, []).boolean;

  static final _id_getFocusable =
      jniAccessors.getMethodIDOf(_classRef, "getFocusable", "()I");

  /// from: public int getFocusable()
  ///
  /// Returns the focusable setting for this view.
  ///@return One of \#NOT_FOCUSABLE, \#FOCUSABLE, or \#FOCUSABLE_AUTO.
  /// Value is android.view.View\#NOT_FOCUSABLE, android.view.View\#FOCUSABLE, or android.view.View\#FOCUSABLE_AUTO
  ///@attr ref android.R.styleable\#View_focusable
  int getFocusable() => jniAccessors.callMethodWithArgs(
      reference, _id_getFocusable, jni.JniType.intType, []).integer;

  static final _id_isFocusableInTouchMode =
      jniAccessors.getMethodIDOf(_classRef, "isFocusableInTouchMode", "()Z");

  /// from: public final boolean isFocusableInTouchMode()
  ///
  /// When a view is focusable, it may not want to take focus when in touch mode.
  /// For example, a button would like focus when the user is navigating via a D-pad
  /// so that the user can click on it, but once the user starts touching the screen,
  /// the button shouldn't take focus
  ///@return Whether the view is focusable in touch mode.
  ///@attr ref android.R.styleable\#View_focusableInTouchMode
  bool isFocusableInTouchMode() => jniAccessors.callMethodWithArgs(reference,
      _id_isFocusableInTouchMode, jni.JniType.booleanType, []).boolean;

  static final _id_isScreenReaderFocusable =
      jniAccessors.getMethodIDOf(_classRef, "isScreenReaderFocusable", "()Z");

  /// from: public boolean isScreenReaderFocusable()
  ///
  /// Returns whether the view should be treated as a focusable unit by screen reader
  /// accessibility tools.
  ///@see \#setScreenReaderFocusable(boolean)
  ///@return Whether the view should be treated as a focusable unit by screen reader.
  bool isScreenReaderFocusable() => jniAccessors.callMethodWithArgs(reference,
      _id_isScreenReaderFocusable, jni.JniType.booleanType, []).boolean;

  static final _id_setScreenReaderFocusable =
      jniAccessors.getMethodIDOf(_classRef, "setScreenReaderFocusable", "(Z)V");

  /// from: public void setScreenReaderFocusable(boolean screenReaderFocusable)
  ///
  /// When screen readers (one type of accessibility tool) decide what should be read to the
  /// user, they typically look for input focusable (\#isFocusable()) parents of
  /// non-focusable text items, and read those focusable parents and their non-focusable children
  /// as a unit. In some situations, this behavior is desirable for views that should not take
  /// input focus. Setting an item to be screen reader focusable requests that the view be
  /// treated as a unit by screen readers without any effect on input focusability. The default
  /// value of {@code false} lets screen readers use other signals, like focusable, to determine
  /// how to group items.
  ///@param screenReaderFocusable Whether the view should be treated as a unit by screen reader
  ///                              accessibility tools.
  void setScreenReaderFocusable(bool screenReaderFocusable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScreenReaderFocusable,
          jni.JniType.voidType, [screenReaderFocusable]).check();

  static final _id_isAccessibilityHeading =
      jniAccessors.getMethodIDOf(_classRef, "isAccessibilityHeading", "()Z");

  /// from: public boolean isAccessibilityHeading()
  ///
  /// Gets whether this view is a heading for accessibility purposes.
  ///@return {@code true} if the view is a heading, {@code false} otherwise.
  ///@attr ref android.R.styleable\#View_accessibilityHeading
  bool isAccessibilityHeading() => jniAccessors.callMethodWithArgs(reference,
      _id_isAccessibilityHeading, jni.JniType.booleanType, []).boolean;

  static final _id_setAccessibilityHeading =
      jniAccessors.getMethodIDOf(_classRef, "setAccessibilityHeading", "(Z)V");

  /// from: public void setAccessibilityHeading(boolean isHeading)
  ///
  /// Set if view is a heading for a section of content for accessibility purposes.
  ///@param isHeading {@code true} if the view is a heading, {@code false} otherwise.
  ///@attr ref android.R.styleable\#View_accessibilityHeading
  void setAccessibilityHeading(bool isHeading) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAccessibilityHeading,
          jni.JniType.voidType, [isHeading]).check();

  static final _id_focusSearch = jniAccessors.getMethodIDOf(
      _classRef, "focusSearch", "(I)Landroid/view/View;");

  /// from: public android.view.View focusSearch(int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the nearest view in the specified direction that can take focus.
  /// This does not actually give focus to that view.
  ///@param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
  ///
  /// Value is android.view.View\#FOCUS_LEFT, android.view.View\#FOCUS_UP, android.view.View\#FOCUS_RIGHT, or android.view.View\#FOCUS_DOWN
  ///@return The nearest focusable in the specified direction, or null if none
  ///         can be found.
  View focusSearch(int direction) =>
      View.fromRef(jniAccessors.callMethodWithArgs(reference, _id_focusSearch,
          jni.JniType.objectType, [direction]).object);

  static final _id_isKeyboardNavigationCluster = jniAccessors.getMethodIDOf(
      _classRef, "isKeyboardNavigationCluster", "()Z");

  /// from: public final boolean isKeyboardNavigationCluster()
  ///
  /// Returns whether this View is a root of a keyboard navigation cluster.
  ///@return True if this view is a root of a cluster, or false otherwise.
  ///@attr ref android.R.styleable\#View_keyboardNavigationCluster
  bool isKeyboardNavigationCluster() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isKeyboardNavigationCluster,
      jni.JniType.booleanType, []).boolean;

  static final _id_setKeyboardNavigationCluster = jniAccessors.getMethodIDOf(
      _classRef, "setKeyboardNavigationCluster", "(Z)V");

  /// from: public void setKeyboardNavigationCluster(boolean isCluster)
  ///
  /// Set whether this view is a root of a keyboard navigation cluster.
  ///@param isCluster If true, this view is a root of a cluster.
  ///@attr ref android.R.styleable\#View_keyboardNavigationCluster
  void setKeyboardNavigationCluster(bool isCluster) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setKeyboardNavigationCluster,
          jni.JniType.voidType,
          [isCluster]).check();

  static final _id_isFocusedByDefault =
      jniAccessors.getMethodIDOf(_classRef, "isFocusedByDefault", "()Z");

  /// from: public final boolean isFocusedByDefault()
  ///
  /// Returns whether this View should receive focus when the focus is restored for the view
  /// hierarchy containing this view.
  ///
  /// Focus gets restored for a view hierarchy when the root of the hierarchy gets added to a
  /// window or serves as a target of cluster navigation.
  ///@see \#restoreDefaultFocus()
  ///@return {@code true} if this view is the default-focus view, {@code false} otherwise
  ///@attr ref android.R.styleable\#View_focusedByDefault
  bool isFocusedByDefault() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocusedByDefault, jni.JniType.booleanType, []).boolean;

  static final _id_setFocusedByDefault =
      jniAccessors.getMethodIDOf(_classRef, "setFocusedByDefault", "(Z)V");

  /// from: public void setFocusedByDefault(boolean isFocusedByDefault)
  ///
  /// Sets whether this View should receive focus when the focus is restored for the view
  /// hierarchy containing this view.
  ///
  /// Focus gets restored for a view hierarchy when the root of the hierarchy gets added to a
  /// window or serves as a target of cluster navigation.
  ///@param isFocusedByDefault {@code true} to set this view as the default-focus view,
  ///                           {@code false} otherwise.
  ///@see \#restoreDefaultFocus()
  ///@attr ref android.R.styleable\#View_focusedByDefault
  void setFocusedByDefault(bool isFocusedByDefault) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFocusedByDefault,
          jni.JniType.voidType, [isFocusedByDefault]).check();

  static final _id_keyboardNavigationClusterSearch = jniAccessors.getMethodIDOf(
      _classRef,
      "keyboardNavigationClusterSearch",
      "(Landroid/view/View;I)Landroid/view/View;");

  /// from: public android.view.View keyboardNavigationClusterSearch(android.view.View currentCluster, int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the nearest keyboard navigation cluster in the specified direction.
  /// This does not actually give focus to that cluster.
  ///@param currentCluster The starting point of the search. Null means the current cluster is not
  ///                       found yet
  ///@param direction Direction to look
  ///
  /// Value is android.view.View\#FOCUS_BACKWARD, android.view.View\#FOCUS_FORWARD, android.view.View\#FOCUS_LEFT, android.view.View\#FOCUS_UP, android.view.View\#FOCUS_RIGHT, or android.view.View\#FOCUS_DOWN
  ///@return The nearest keyboard navigation cluster in the specified direction, or null if none
  ///         can be found
  View keyboardNavigationClusterSearch(View currentCluster, int direction) =>
      View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_keyboardNavigationClusterSearch,
          jni.JniType.objectType,
          [currentCluster.reference, direction]).object);

  static final _id_dispatchUnhandledMove = jniAccessors.getMethodIDOf(
      _classRef, "dispatchUnhandledMove", "(Landroid/view/View;I)Z");

  /// from: public boolean dispatchUnhandledMove(android.view.View focused, int direction)
  ///
  /// This method is the last chance for the focused view and its ancestors to
  /// respond to an arrow key. This is called when the focused view did not
  /// consume the key internally, nor could the view system find a new view in
  /// the requested direction to give focus to.
  ///@param focused The currently focused view.
  ///@param direction The direction focus wants to move. One of FOCUS_UP,
  ///        FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT.
  /// Value is android.view.View\#FOCUS_LEFT, android.view.View\#FOCUS_UP, android.view.View\#FOCUS_RIGHT, or android.view.View\#FOCUS_DOWN
  ///@return True if the this view consumed this unhandled move.
  bool dispatchUnhandledMove(View focused, int direction) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchUnhandledMove,
          jni.JniType.booleanType, [focused.reference, direction]).boolean;

  static final _id_setDefaultFocusHighlightEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setDefaultFocusHighlightEnabled", "(Z)V");

  /// from: public void setDefaultFocusHighlightEnabled(boolean defaultFocusHighlightEnabled)
  ///
  /// Sets whether this View should use a default focus highlight when it gets focused but doesn't
  /// have android.R.attr\#state_focused defined in its background.
  ///@param defaultFocusHighlightEnabled {@code true} to set this view to use a default focus
  ///                                      highlight, {@code false} otherwise.
  ///@attr ref android.R.styleable\#View_defaultFocusHighlightEnabled
  void setDefaultFocusHighlightEnabled(bool defaultFocusHighlightEnabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDefaultFocusHighlightEnabled,
          jni.JniType.voidType,
          [defaultFocusHighlightEnabled]).check();

  static final _id_getDefaultFocusHighlightEnabled = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultFocusHighlightEnabled", "()Z");

  /// from: public final boolean getDefaultFocusHighlightEnabled()
  ///
  /// /**
  /// Returns whether this View should use a default focus highlight when it gets focused but
  /// doesn't have android.R.attr\#state_focused defined in its background.
  ///@return True if this View should use a default focus highlight.
  ///@attr ref android.R.styleable\#View_defaultFocusHighlightEnabled
  bool getDefaultFocusHighlightEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDefaultFocusHighlightEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_getFocusables = jniAccessors.getMethodIDOf(
      _classRef, "getFocusables", "(I)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<android.view.View> getFocusables(int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find and return all focusable views that are descendants of this view,
  /// possibly including this view if it is focusable itself.
  ///@param direction The direction of the focus
  /// Value is android.view.View\#FOCUS_BACKWARD, android.view.View\#FOCUS_FORWARD, android.view.View\#FOCUS_LEFT, android.view.View\#FOCUS_UP, android.view.View\#FOCUS_RIGHT, or android.view.View\#FOCUS_DOWN
  ///@return A list of focusable views
  jni.JniObject getFocusables(int direction) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFocusables, jni.JniType.objectType, [direction]).object);

  static final _id_addFocusables = jniAccessors.getMethodIDOf(
      _classRef, "addFocusables", "(Ljava/util/ArrayList;I)V");

  /// from: public void addFocusables(java.util.ArrayList<android.view.View> views, int direction)
  ///
  /// Add any focusable views that are descendants of this view (possibly
  /// including this view if it is focusable itself) to views.  If we are in touch mode,
  /// only add views that are also focusable in touch mode.
  ///@param views Focusable views found so far
  ///@param direction The direction of the focus
  ///
  /// Value is android.view.View\#FOCUS_BACKWARD, android.view.View\#FOCUS_FORWARD, android.view.View\#FOCUS_LEFT, android.view.View\#FOCUS_UP, android.view.View\#FOCUS_RIGHT, or android.view.View\#FOCUS_DOWN
  void addFocusables(jni.JniObject views, int direction) =>
      jniAccessors.callMethodWithArgs(reference, _id_addFocusables,
          jni.JniType.voidType, [views.reference, direction]).check();

  static final _id_addFocusables1 = jniAccessors.getMethodIDOf(
      _classRef, "addFocusables", "(Ljava/util/ArrayList;II)V");

  /// from: public void addFocusables(java.util.ArrayList<android.view.View> views, int direction, int focusableMode)
  ///
  /// Adds any focusable views that are descendants of this view (possibly
  /// including this view if it is focusable itself) to views. This method
  /// adds all focusable views regardless if we are in touch mode or
  /// only views focusable in touch mode if we are in touch mode or
  /// only views that can take accessibility focus if accessibility is enabled
  /// depending on the focusable mode parameter.
  ///@param views Focusable views found so far or null if all we are interested is
  ///        the number of focusables.
  ///@param direction The direction of the focus.
  /// Value is android.view.View\#FOCUS_BACKWARD, android.view.View\#FOCUS_FORWARD, android.view.View\#FOCUS_LEFT, android.view.View\#FOCUS_UP, android.view.View\#FOCUS_RIGHT, or android.view.View\#FOCUS_DOWN
  ///@param focusableMode The type of focusables to be added.
  ///
  /// Value is either <code>0</code> or a combination of android.view.View\#FOCUSABLES_ALL, and android.view.View\#FOCUSABLES_TOUCH_MODE
  ///@see \#FOCUSABLES_ALL
  ///@see \#FOCUSABLES_TOUCH_MODE
  void addFocusables1(jni.JniObject views, int direction, int focusableMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addFocusables1,
          jni.JniType.voidType,
          [views.reference, direction, focusableMode]).check();

  static final _id_addKeyboardNavigationClusters = jniAccessors.getMethodIDOf(
      _classRef, "addKeyboardNavigationClusters", "(Ljava/util/Collection;I)V");

  /// from: public void addKeyboardNavigationClusters(java.util.Collection<android.view.View> views, int direction)
  ///
  /// Adds any keyboard navigation cluster roots that are descendants of this view (possibly
  /// including this view if it is a cluster root itself) to views.
  ///@param views Keyboard navigation cluster roots found so far
  /// This value must never be {@code null}.
  ///@param direction Direction to look
  void addKeyboardNavigationClusters(jni.JniObject views, int direction) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addKeyboardNavigationClusters,
          jni.JniType.voidType,
          [views.reference, direction]).check();

  static final _id_findViewsWithText = jniAccessors.getMethodIDOf(_classRef,
      "findViewsWithText", "(Ljava/util/ArrayList;Ljava/lang/CharSequence;I)V");

  /// from: public void findViewsWithText(java.util.ArrayList<android.view.View> outViews, java.lang.CharSequence searched, int flags)
  ///
  /// Finds the Views that contain given text. The containment is case insensitive.
  /// The search is performed by either the text that the View renders or the content
  /// description that describes the view for accessibility purposes and the view does
  /// not render or both. Clients can specify how the search is to be performed via
  /// passing the \#FIND_VIEWS_WITH_TEXT and
  /// \#FIND_VIEWS_WITH_CONTENT_DESCRIPTION flags.
  ///@param outViews The output list of matching Views.
  ///@param searched The text to match against.
  ///@see \#FIND_VIEWS_WITH_TEXT
  ///@see \#FIND_VIEWS_WITH_CONTENT_DESCRIPTION
  ///@see \#setContentDescription(CharSequence)
  ///@param flags Value is either <code>0</code> or a combination of android.view.View\#FIND_VIEWS_WITH_TEXT, and android.view.View\#FIND_VIEWS_WITH_CONTENT_DESCRIPTION
  void findViewsWithText(
          jni.JniObject outViews, jni.JniObject searched, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_findViewsWithText,
          jni.JniType.voidType,
          [outViews.reference, searched.reference, flags]).check();

  static final _id_getTouchables = jniAccessors.getMethodIDOf(
      _classRef, "getTouchables", "()Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<android.view.View> getTouchables()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find and return all touchable views that are descendants of this view,
  /// possibly including this view if it is touchable itself.
  ///@return A list of touchable views
  jni.JniObject getTouchables() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTouchables, jni.JniType.objectType, []).object);

  static final _id_addTouchables = jniAccessors.getMethodIDOf(
      _classRef, "addTouchables", "(Ljava/util/ArrayList;)V");

  /// from: public void addTouchables(java.util.ArrayList<android.view.View> views)
  ///
  /// Add any touchable views that are descendants of this view (possibly
  /// including this view if it is touchable itself) to views.
  ///@param views Touchable views found so far
  void addTouchables(jni.JniObject views) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addTouchables,
      jni.JniType.voidType,
      [views.reference]).check();

  static final _id_isAccessibilityFocused =
      jniAccessors.getMethodIDOf(_classRef, "isAccessibilityFocused", "()Z");

  /// from: public boolean isAccessibilityFocused()
  ///
  /// Returns whether this View is accessibility focused.
  ///@return True if this View is accessibility focused.
  bool isAccessibilityFocused() => jniAccessors.callMethodWithArgs(reference,
      _id_isAccessibilityFocused, jni.JniType.booleanType, []).boolean;

  static final _id_requestFocus =
      jniAccessors.getMethodIDOf(_classRef, "requestFocus", "()Z");

  /// from: public final boolean requestFocus()
  ///
  /// Call this to try to give focus to a specific view or to one of its
  /// descendants.
  ///
  /// A view will not actually take focus if it is not focusable (\#isFocusable returns
  /// false), or if it can't be focused due to other conditions (not focusable in touch mode
  /// (\#isFocusableInTouchMode) while the device is in touch mode, not visible, not
  /// enabled, or has no size).
  ///
  /// See also \#focusSearch(int), which is what you call to say that you
  /// have focus, and you want your parent to look for the next one.
  ///
  /// This is equivalent to calling \#requestFocus(int, Rect) with arguments
  /// \#FOCUS_DOWN and <code>null</code>.
  ///@return Whether this view or one of its descendants actually took focus.
  bool requestFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_requestFocus, jni.JniType.booleanType, []).boolean;

  static final _id_restoreDefaultFocus =
      jniAccessors.getMethodIDOf(_classRef, "restoreDefaultFocus", "()Z");

  /// from: public boolean restoreDefaultFocus()
  ///
  /// Gives focus to the default-focus view in the view hierarchy that has this view as a root.
  /// If the default-focus view cannot be found, falls back to calling \#requestFocus(int).
  ///@return Whether this view or one of its descendants actually took focus
  bool restoreDefaultFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_restoreDefaultFocus, jni.JniType.booleanType, []).boolean;

  static final _id_requestFocus1 =
      jniAccessors.getMethodIDOf(_classRef, "requestFocus", "(I)Z");

  /// from: public final boolean requestFocus(int direction)
  ///
  /// Call this to try to give focus to a specific view or to one of its
  /// descendants and give it a hint about what direction focus is heading.
  ///
  /// A view will not actually take focus if it is not focusable (\#isFocusable returns
  /// false), or if it is focusable and it is not focusable in touch mode
  /// (\#isFocusableInTouchMode) while the device is in touch mode.
  ///
  /// See also \#focusSearch(int), which is what you call to say that you
  /// have focus, and you want your parent to look for the next one.
  ///
  /// This is equivalent to calling \#requestFocus(int, Rect) with
  /// <code>null</code> set for the previously focused rectangle.
  ///@param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
  ///@return Whether this view or one of its descendants actually took focus.
  bool requestFocus1(int direction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestFocus1,
      jni.JniType.booleanType,
      [direction]).boolean;

  static final _id_requestFocus2 = jniAccessors.getMethodIDOf(
      _classRef, "requestFocus", "(ILandroid/graphics/Rect;)Z");

  /// from: public boolean requestFocus(int direction, android.graphics.Rect previouslyFocusedRect)
  ///
  /// Call this to try to give focus to a specific view or to one of its descendants
  /// and give it hints about the direction and a specific rectangle that the focus
  /// is coming from.  The rectangle can help give larger views a finer grained hint
  /// about where focus is coming from, and therefore, where to show selection, or
  /// forward focus change internally.
  ///
  /// A view will not actually take focus if it is not focusable (\#isFocusable returns
  /// false), or if it is focusable and it is not focusable in touch mode
  /// (\#isFocusableInTouchMode) while the device is in touch mode.
  ///
  /// A View will not take focus if it is not visible.
  ///
  /// A View will not take focus if one of its parents has
  /// android.view.ViewGroup\#getDescendantFocusability() equal to
  /// ViewGroup\#FOCUS_BLOCK_DESCENDANTS.
  ///
  /// See also \#focusSearch(int), which is what you call to say that you
  /// have focus, and you want your parent to look for the next one.
  ///
  /// You may wish to override this method if your custom View has an internal
  /// View that it wishes to forward the request to.
  ///@param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
  ///@param previouslyFocusedRect The rectangle (in this View's coordinate system)
  ///        to give a finer grained hint about where focus is coming from.  May be null
  ///        if there is no hint.
  ///@return Whether this view or one of its descendants actually took focus.
  bool requestFocus2(int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestFocus2,
          jni.JniType.booleanType,
          [direction, previouslyFocusedRect.reference]).boolean;

  static final _id_requestFocusFromTouch =
      jniAccessors.getMethodIDOf(_classRef, "requestFocusFromTouch", "()Z");

  /// from: public final boolean requestFocusFromTouch()
  ///
  /// Call this to try to give focus to a specific view or to one of its descendants. This is a
  /// special variant of \#requestFocus() that will allow views that are not focusable in
  /// touch mode to request focus when they are touched.
  ///@return Whether this view or one of its descendants actually took focus.
  ///@see \#isInTouchMode()
  bool requestFocusFromTouch() => jniAccessors.callMethodWithArgs(reference,
      _id_requestFocusFromTouch, jni.JniType.booleanType, []).boolean;

  static final _id_getImportantForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "getImportantForAccessibility", "()I");

  /// from: public int getImportantForAccessibility()
  ///
  /// Gets the mode for determining whether this View is important for accessibility.
  /// A view is important for accessibility if it fires accessibility events and if it
  /// is reported to accessibility services that query the screen.
  ///@return The mode for determining whether a view is important for accessibility, one
  /// of \#IMPORTANT_FOR_ACCESSIBILITY_AUTO, \#IMPORTANT_FOR_ACCESSIBILITY_YES,
  /// \#IMPORTANT_FOR_ACCESSIBILITY_NO, or
  /// \#IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS.
  ///@attr ref android.R.styleable\#View_importantForAccessibility
  ///@see \#IMPORTANT_FOR_ACCESSIBILITY_YES
  ///@see \#IMPORTANT_FOR_ACCESSIBILITY_NO
  ///@see \#IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS
  ///@see \#IMPORTANT_FOR_ACCESSIBILITY_AUTO
  int getImportantForAccessibility() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getImportantForAccessibility,
      jni.JniType.intType, []).integer;

  static final _id_setAccessibilityLiveRegion = jniAccessors.getMethodIDOf(
      _classRef, "setAccessibilityLiveRegion", "(I)V");

  /// from: public void setAccessibilityLiveRegion(int mode)
  ///
  /// Sets the live region mode for this view. This indicates to accessibility
  /// services whether they should automatically notify the user about changes
  /// to the view's content description or text, or to the content descriptions
  /// or text of the view's children (where applicable).
  ///
  /// For example, in a login screen with a TextView that displays an "incorrect
  /// password" notification, that view should be marked as a live region with
  /// mode \#ACCESSIBILITY_LIVE_REGION_POLITE.
  ///
  /// To disable change notifications for this view, use
  /// \#ACCESSIBILITY_LIVE_REGION_NONE. This is the default live region
  /// mode for most views.
  ///
  /// To indicate that the user should be notified of changes, use
  /// \#ACCESSIBILITY_LIVE_REGION_POLITE.
  ///
  /// If the view's changes should interrupt ongoing speech and notify the user
  /// immediately, use \#ACCESSIBILITY_LIVE_REGION_ASSERTIVE.
  ///@param mode The live region mode for this view, one of:
  ///        <ul>
  ///        <li>\#ACCESSIBILITY_LIVE_REGION_NONE
  ///        <li>\#ACCESSIBILITY_LIVE_REGION_POLITE
  ///        <li>\#ACCESSIBILITY_LIVE_REGION_ASSERTIVE
  ///        </ul>
  ///@attr ref android.R.styleable\#View_accessibilityLiveRegion
  void setAccessibilityLiveRegion(int mode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAccessibilityLiveRegion,
      jni.JniType.voidType,
      [mode]).check();

  static final _id_getAccessibilityLiveRegion = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityLiveRegion", "()I");

  /// from: public int getAccessibilityLiveRegion()
  ///
  /// Gets the live region mode for this View.
  ///@return The live region mode for the view.
  ///@attr ref android.R.styleable\#View_accessibilityLiveRegion
  ///@see \#setAccessibilityLiveRegion(int)
  int getAccessibilityLiveRegion() => jniAccessors.callMethodWithArgs(reference,
      _id_getAccessibilityLiveRegion, jni.JniType.intType, []).integer;

  static final _id_setImportantForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "setImportantForAccessibility", "(I)V");

  /// from: public void setImportantForAccessibility(int mode)
  ///
  /// Sets how to determine whether this view is important for accessibility
  /// which is if it fires accessibility events and if it is reported to
  /// accessibility services that query the screen.
  ///@param mode How to determine whether this view is important for accessibility.
  ///@attr ref android.R.styleable\#View_importantForAccessibility
  ///@see \#IMPORTANT_FOR_ACCESSIBILITY_YES
  ///@see \#IMPORTANT_FOR_ACCESSIBILITY_NO
  ///@see \#IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS
  ///@see \#IMPORTANT_FOR_ACCESSIBILITY_AUTO
  void setImportantForAccessibility(int mode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setImportantForAccessibility,
          jni.JniType.voidType,
          [mode]).check();

  static final _id_isImportantForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "isImportantForAccessibility", "()Z");

  /// from: public boolean isImportantForAccessibility()
  ///
  /// Computes whether this view should be exposed for accessibility. In
  /// general, views that are interactive or provide information are exposed
  /// while views that serve only as containers are hidden.
  ///
  /// If an ancestor of this view has importance
  /// \#IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS, this method
  /// returns <code>false</code>.
  ///
  /// Otherwise, the value is computed according to the view's
  /// \#getImportantForAccessibility() value:
  /// <ol>
  /// <li>\#IMPORTANT_FOR_ACCESSIBILITY_NO or
  /// \#IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS, return <code>false
  /// </code>
  /// <li>\#IMPORTANT_FOR_ACCESSIBILITY_YES, return <code>true</code>
  /// <li>\#IMPORTANT_FOR_ACCESSIBILITY_AUTO, return <code>true</code> if
  /// view satisfies any of the following:
  /// <ul>
  /// <li>Is actionable, e.g. \#isClickable(),
  /// \#isLongClickable(), or \#isFocusable()
  /// <li>Has an AccessibilityDelegate
  /// <li>Has an interaction listener, e.g. OnTouchListener,
  /// OnKeyListener, etc.
  /// <li>Is an accessibility live region, e.g.
  /// \#getAccessibilityLiveRegion() is not
  /// \#ACCESSIBILITY_LIVE_REGION_NONE.
  /// </ul>
  /// <li>Has an accessibility pane title, see \#setAccessibilityPaneTitle</li>
  /// </ol>
  ///@return Whether the view is exposed for accessibility.
  ///@see \#setImportantForAccessibility(int)
  ///@see \#getImportantForAccessibility()
  bool isImportantForAccessibility() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isImportantForAccessibility,
      jni.JniType.booleanType, []).boolean;

  static final _id_getParentForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "getParentForAccessibility", "()Landroid/view/ViewParent;");

  /// from: public android.view.ViewParent getParentForAccessibility()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the parent for accessibility purposes. Note that the parent for
  /// accessibility is not necessary the immediate parent. It is the first
  /// predecessor that is important for accessibility.
  ///@return The parent for accessibility purposes.
  viewparent_.ViewParent getParentForAccessibility() =>
      viewparent_.ViewParent.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getParentForAccessibility, jni.JniType.objectType, []).object);

  static final _id_addChildrenForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "addChildrenForAccessibility", "(Ljava/util/ArrayList;)V");

  /// from: public void addChildrenForAccessibility(java.util.ArrayList<android.view.View> outChildren)
  ///
  /// Adds the children of this View relevant for accessibility to the given list
  /// as output. Since some Views are not important for accessibility the added
  /// child views are not necessarily direct children of this view, rather they are
  /// the first level of descendants important for accessibility.
  ///@param outChildren The output list that will receive children for accessibility.
  void addChildrenForAccessibility(jni.JniObject outChildren) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addChildrenForAccessibility,
          jni.JniType.voidType,
          [outChildren.reference]).check();

  static final _id_dispatchNestedPrePerformAccessibilityAction =
      jniAccessors.getMethodIDOf(
          _classRef,
          "dispatchNestedPrePerformAccessibilityAction",
          "(ILandroid/os/Bundle;)Z");

  /// from: public boolean dispatchNestedPrePerformAccessibilityAction(int action, android.os.Bundle arguments)
  ///
  /// Report an accessibility action to this view's parents for delegated processing.
  ///
  /// Implementations of \#performAccessibilityAction(int, Bundle) may internally
  /// call this method to delegate an accessibility action to a supporting parent. If the parent
  /// returns true from its
  /// ViewParent\#onNestedPrePerformAccessibilityAction(View, int, android.os.Bundle)
  /// method this method will return true to signify that the action was consumed.
  ///
  ///
  /// This method is useful for implementing nested scrolling child views. If
  /// \#isNestedScrollingEnabled() returns true and the action is a scrolling action
  /// a custom view implementation may invoke this method to allow a parent to consume the
  /// scroll first. If this method returns true the custom view should skip its own scrolling
  /// behavior.
  ///
  ///@param action Accessibility action to delegate
  ///@param arguments Optional action arguments
  ///@return true if the action was consumed by a parent
  bool dispatchNestedPrePerformAccessibilityAction(
          int action, bundle_.Bundle arguments) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchNestedPrePerformAccessibilityAction,
          jni.JniType.booleanType,
          [action, arguments.reference]).boolean;

  static final _id_performAccessibilityAction = jniAccessors.getMethodIDOf(
      _classRef, "performAccessibilityAction", "(ILandroid/os/Bundle;)Z");

  /// from: public boolean performAccessibilityAction(int action, android.os.Bundle arguments)
  ///
  /// Performs the specified accessibility action on the view. For
  /// possible accessibility actions look at AccessibilityNodeInfo.
  ///
  /// If an AccessibilityDelegate has been specified via calling
  /// \#setAccessibilityDelegate(AccessibilityDelegate) its
  /// AccessibilityDelegate\#performAccessibilityAction(View, int, Bundle)
  /// is responsible for handling this call.
  ///
  ///
  ///
  /// The default implementation will delegate
  /// AccessibilityNodeInfo\#ACTION_SCROLL_BACKWARD and
  /// AccessibilityNodeInfo\#ACTION_SCROLL_FORWARD to nested scrolling parents if
  /// \#isNestedScrollingEnabled() nested scrolling is enabled on this view.
  ///
  ///@param action The action to perform.
  ///@param arguments Optional action arguments.
  ///@return Whether the action was performed.
  bool performAccessibilityAction(int action, bundle_.Bundle arguments) =>
      jniAccessors.callMethodWithArgs(reference, _id_performAccessibilityAction,
          jni.JniType.booleanType, [action, arguments.reference]).boolean;

  static final _id_isTemporarilyDetached =
      jniAccessors.getMethodIDOf(_classRef, "isTemporarilyDetached", "()Z");

  /// from: public final boolean isTemporarilyDetached()
  ///
  /// Tells whether the View is in the state between \#onStartTemporaryDetach()
  /// and \#onFinishTemporaryDetach().
  ///
  /// This method always returns {@code true} when called directly or indirectly from
  /// \#onStartTemporaryDetach(). The return value when called directly or indirectly from
  /// \#onFinishTemporaryDetach(), however, depends on the OS version.
  /// <ul>
  ///     <li>{@code true} on android.os.Build.VERSION_CODES\#N API 24</li>
  ///     <li>{@code false} on android.os.Build.VERSION_CODES\#N_MR1 API 25} and later</li>
  /// </ul>
  ///
  ///
  ///@return {@code true} when the View is in the state between \#onStartTemporaryDetach()
  /// and \#onFinishTemporaryDetach().
  bool isTemporarilyDetached() => jniAccessors.callMethodWithArgs(reference,
      _id_isTemporarilyDetached, jni.JniType.booleanType, []).boolean;

  static final _id_dispatchStartTemporaryDetach = jniAccessors.getMethodIDOf(
      _classRef, "dispatchStartTemporaryDetach", "()V");

  /// from: public void dispatchStartTemporaryDetach()
  ///
  /// Dispatch \#onStartTemporaryDetach() to this View and its direct children if this is
  /// a container View.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void dispatchStartTemporaryDetach() => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchStartTemporaryDetach,
      jni.JniType.voidType, []).check();

  static final _id_onStartTemporaryDetach =
      jniAccessors.getMethodIDOf(_classRef, "onStartTemporaryDetach", "()V");

  /// from: public void onStartTemporaryDetach()
  ///
  /// This is called when a container is going to temporarily detach a child, with
  /// ViewGroup\#detachViewFromParent(View) ViewGroup.detachViewFromParent.
  /// It will either be followed by \#onFinishTemporaryDetach() or
  /// \#onDetachedFromWindow() when the container is done.
  void onStartTemporaryDetach() => jniAccessors.callMethodWithArgs(
      reference, _id_onStartTemporaryDetach, jni.JniType.voidType, []).check();

  static final _id_dispatchFinishTemporaryDetach = jniAccessors.getMethodIDOf(
      _classRef, "dispatchFinishTemporaryDetach", "()V");

  /// from: public void dispatchFinishTemporaryDetach()
  ///
  /// Dispatch \#onFinishTemporaryDetach() to this View and its direct children if this is
  /// a container View.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void dispatchFinishTemporaryDetach() => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchFinishTemporaryDetach,
      jni.JniType.voidType, []).check();

  static final _id_onFinishTemporaryDetach =
      jniAccessors.getMethodIDOf(_classRef, "onFinishTemporaryDetach", "()V");

  /// from: public void onFinishTemporaryDetach()
  ///
  /// Called after \#onStartTemporaryDetach when the container is done
  /// changing the view.
  void onFinishTemporaryDetach() => jniAccessors.callMethodWithArgs(
      reference, _id_onFinishTemporaryDetach, jni.JniType.voidType, []).check();

  static final _id_getKeyDispatcherState = jniAccessors.getMethodIDOf(_classRef,
      "getKeyDispatcherState", "()Landroid/view/KeyEvent\$DispatcherState;");

  /// from: public android.view.KeyEvent.DispatcherState getKeyDispatcherState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the global KeyEvent.DispatcherState KeyEvent.DispatcherState
  /// for this view's window.  Returns null if the view is not currently attached
  /// to the window.  Normally you will not need to use this directly, but
  /// just use the standard high-level event callbacks like
  /// \#onKeyDown(int, KeyEvent).
  keyevent_.KeyEvent_DispatcherState getKeyDispatcherState() =>
      keyevent_.KeyEvent_DispatcherState.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getKeyDispatcherState,
              jni.JniType.objectType, []).object);

  static final _id_dispatchKeyEventPreIme = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEventPreIme", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEventPreIme(android.view.KeyEvent event)
  ///
  /// Dispatch a key event before it is processed by any input method
  /// associated with the view hierarchy.  This can be used to intercept
  /// key events in special situations before the IME consumes them; a
  /// typical example would be handling the BACK key to update the application's
  /// UI instead of allowing the IME to see it and close itself.
  ///@param event The key event to be dispatched.
  ///@return True if the event was handled, false otherwise.
  bool dispatchKeyEventPreIme(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEventPreIme,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  ///
  /// Dispatch a key event to the next view on the focus path. This path runs
  /// from the top of the view tree down to the currently focused view. If this
  /// view has focus, it will dispatch to itself. Otherwise it will dispatch
  /// the next node down the focus path. This method also fires any key
  /// listeners.
  ///@param event The key event to be dispatched.
  ///@return True if the event was handled, false otherwise.
  bool dispatchKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchKeyShortcutEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyShortcutEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  ///
  /// Dispatches a key shortcut event.
  ///@param event The key event to be dispatched.
  ///@return True if the event was handled by the view, false otherwise.
  bool dispatchKeyShortcutEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyShortcutEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent event)
  ///
  /// Pass the touch screen motion event down to the target view, or this
  /// view if it is the target.
  ///@param event The motion event to be dispatched.
  ///@return True if the event was handled by the view, false otherwise.
  bool dispatchTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onFilterTouchEventForSecurity = jniAccessors.getMethodIDOf(
      _classRef,
      "onFilterTouchEventForSecurity",
      "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onFilterTouchEventForSecurity(android.view.MotionEvent event)
  ///
  /// Filter the touch event to apply security policies.
  ///@param event The motion event to be filtered.
  ///@return True if the event should be dispatched, false if the event should be dropped.
  ///@see \#getFilterTouchesWhenObscured
  bool onFilterTouchEventForSecurity(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFilterTouchEventForSecurity,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_dispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent event)
  ///
  /// Pass a trackball motion event down to the focused view.
  ///@param event The motion event to be dispatched.
  ///@return True if the event was handled by the view, false otherwise.
  bool dispatchTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchCapturedPointerEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchCapturedPointerEvent",
      "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchCapturedPointerEvent(android.view.MotionEvent event)
  ///
  /// Pass a captured pointer event down to the focused view.
  ///@param event The motion event to be dispatched.
  ///@return True if the event was handled by the view, false otherwise.
  bool dispatchCapturedPointerEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchCapturedPointerEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_dispatchGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Dispatch a generic motion event.
  ///
  /// Generic motion events with source class InputDevice\#SOURCE_CLASS_POINTER
  /// are delivered to the view under the pointer.  All other generic motion events are
  /// delivered to the focused view.  Hover events are handled specially and are delivered
  /// to \#onHoverEvent(MotionEvent).
  ///
  ///
  ///@param event The motion event to be dispatched.
  ///@return True if the event was handled by the view, false otherwise.
  bool dispatchGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchHoverEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchHoverEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchHoverEvent(android.view.MotionEvent event)
  ///
  /// Dispatch a hover event.
  ///
  /// Do not call this method directly.
  /// Call \#dispatchGenericMotionEvent(MotionEvent) instead.
  ///
  ///
  ///@param event The motion event to be dispatched.
  ///@return True if the event was handled by the view, false otherwise.
  bool dispatchHoverEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchHoverEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchGenericPointerEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchGenericPointerEvent",
      "(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchGenericPointerEvent(android.view.MotionEvent event)
  ///
  /// Dispatch a generic motion event to the view under the first pointer.
  ///
  /// Do not call this method directly.
  /// Call \#dispatchGenericMotionEvent(MotionEvent) instead.
  ///
  ///
  ///@param event The motion event to be dispatched.
  ///@return True if the event was handled by the view, false otherwise.
  bool dispatchGenericPointerEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchGenericPointerEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_dispatchGenericFocusedEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchGenericFocusedEvent",
      "(Landroid/view/MotionEvent;)Z");

  /// from: protected boolean dispatchGenericFocusedEvent(android.view.MotionEvent event)
  ///
  /// Dispatch a generic motion event to the currently focused view.
  ///
  /// Do not call this method directly.
  /// Call \#dispatchGenericMotionEvent(MotionEvent) instead.
  ///
  ///
  ///@param event The motion event to be dispatched.
  ///@return True if the event was handled by the view, false otherwise.
  bool dispatchGenericFocusedEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchGenericFocusedEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_dispatchWindowFocusChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchWindowFocusChanged", "(Z)V");

  /// from: public void dispatchWindowFocusChanged(boolean hasFocus)
  ///
  /// Called when the window containing this view gains or loses window focus.
  /// ViewGroups should override to route to their children.
  ///@param hasFocus True if the window containing this view now has focus,
  ///        false otherwise.
  void dispatchWindowFocusChanged(bool hasFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchWindowFocusChanged,
          jni.JniType.voidType, [hasFocus]).check();

  static final _id_onWindowFocusChanged =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasWindowFocus)
  ///
  /// Called when the window containing this view gains or loses focus.  Note
  /// that this is separate from view focus: to receive key events, both
  /// your view and its window must have focus.  If a window is displayed
  /// on top of yours that takes input focus, then your own window will lose
  /// focus but the view focus will remain unchanged.
  ///@param hasWindowFocus True if the window containing this view now has
  ///        focus, false otherwise.
  void onWindowFocusChanged(bool hasWindowFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowFocusChanged,
          jni.JniType.voidType, [hasWindowFocus]).check();

  static final _id_hasWindowFocus =
      jniAccessors.getMethodIDOf(_classRef, "hasWindowFocus", "()Z");

  /// from: public boolean hasWindowFocus()
  ///
  /// Returns true if this view is in a window that currently has window focus.
  /// Note that this is not the same as the view itself having focus.
  ///@return True if this view is in a window that currently has window focus.
  bool hasWindowFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_hasWindowFocus, jni.JniType.booleanType, []).boolean;

  static final _id_dispatchVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchVisibilityChanged", "(Landroid/view/View;I)V");

  /// from: protected void dispatchVisibilityChanged(android.view.View changedView, int visibility)
  ///
  /// Dispatch a view visibility change down the view hierarchy.
  /// ViewGroups should override to route to their children.
  ///@param changedView The view whose visibility changed. Could be 'this' or
  /// an ancestor view.
  /// This value must never be {@code null}.
  ///@param visibility The new visibility of changedView: \#VISIBLE,
  /// \#INVISIBLE or \#GONE.
  ///
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  void dispatchVisibilityChanged(View changedView, int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchVisibilityChanged,
          jni.JniType.voidType, [changedView.reference, visibility]).check();

  static final _id_onVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "onVisibilityChanged", "(Landroid/view/View;I)V");

  /// from: protected void onVisibilityChanged(android.view.View changedView, int visibility)
  ///
  /// Called when the visibility of the view or an ancestor of the view has
  /// changed.
  ///@param changedView The view whose visibility changed. May be
  ///                    {@code this} or an ancestor view.
  /// This value must never be {@code null}.
  ///@param visibility The new visibility, one of \#VISIBLE,
  ///                   \#INVISIBLE or \#GONE.
  ///
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  void onVisibilityChanged(View changedView, int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVisibilityChanged,
          jni.JniType.voidType, [changedView.reference, visibility]).check();

  static final _id_dispatchDisplayHint =
      jniAccessors.getMethodIDOf(_classRef, "dispatchDisplayHint", "(I)V");

  /// from: public void dispatchDisplayHint(int hint)
  ///
  /// Dispatch a hint about whether this view is displayed. For instance, when
  /// a View moves out of the screen, it might receives a display hint indicating
  /// the view is not displayed. Applications should not _rely_ on this hint
  /// as there is no guarantee that they will receive one.
  ///@param hint A hint about whether or not this view is displayed:
  /// \#VISIBLE or \#INVISIBLE.
  ///
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  void dispatchDisplayHint(int hint) => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchDisplayHint, jni.JniType.voidType, [hint]).check();

  static final _id_onDisplayHint =
      jniAccessors.getMethodIDOf(_classRef, "onDisplayHint", "(I)V");

  /// from: protected void onDisplayHint(int hint)
  ///
  /// Gives this view a hint about whether is displayed or not. For instance, when
  /// a View moves out of the screen, it might receives a display hint indicating
  /// the view is not displayed. Applications should not _rely_ on this hint
  /// as there is no guarantee that they will receive one.
  ///@param hint A hint about whether or not this view is displayed:
  /// \#VISIBLE or \#INVISIBLE.
  ///
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  void onDisplayHint(int hint) => jniAccessors.callMethodWithArgs(
      reference, _id_onDisplayHint, jni.JniType.voidType, [hint]).check();

  static final _id_dispatchWindowVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchWindowVisibilityChanged", "(I)V");

  /// from: public void dispatchWindowVisibilityChanged(int visibility)
  ///
  /// Dispatch a window visibility change down the view hierarchy.
  /// ViewGroups should override to route to their children.
  ///@param visibility The new visibility of the window.
  ///
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  ///@see \#onWindowVisibilityChanged(int)
  void dispatchWindowVisibilityChanged(int visibility) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchWindowVisibilityChanged,
          jni.JniType.voidType,
          [visibility]).check();

  static final _id_onWindowVisibilityChanged = jniAccessors.getMethodIDOf(
      _classRef, "onWindowVisibilityChanged", "(I)V");

  /// from: protected void onWindowVisibilityChanged(int visibility)
  ///
  /// Called when the window containing has change its visibility
  /// (between \#GONE, \#INVISIBLE, and \#VISIBLE).  Note
  /// that this tells you whether or not your window is being made visible
  /// to the window manager; this does _not_ tell you whether or not
  /// your window is obscured by other windows on the screen, even if it
  /// is itself visible.
  ///@param visibility The new visibility of the window.
  ///
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  void onWindowVisibilityChanged(int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowVisibilityChanged,
          jni.JniType.voidType, [visibility]).check();

  static final _id_onVisibilityAggregated =
      jniAccessors.getMethodIDOf(_classRef, "onVisibilityAggregated", "(Z)V");

  /// from: public void onVisibilityAggregated(boolean isVisible)
  ///
  /// Called when the user-visibility of this View is potentially affected by a change
  /// to this view itself, an ancestor view or the window this view is attached to.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param isVisible true if this view and all of its ancestors are \#VISIBLE
  ///                  and this view's window is also visible
  void onVisibilityAggregated(bool isVisible) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVisibilityAggregated,
          jni.JniType.voidType, [isVisible]).check();

  static final _id_getWindowVisibility =
      jniAccessors.getMethodIDOf(_classRef, "getWindowVisibility", "()I");

  /// from: public int getWindowVisibility()
  ///
  /// Returns the current visibility of the window this view is attached to
  /// (either \#GONE, \#INVISIBLE, or \#VISIBLE).
  ///@return Returns the current visibility of the view's window.
  ///
  /// Value is android.view.View\#VISIBLE, android.view.View\#INVISIBLE, or android.view.View\#GONE
  int getWindowVisibility() => jniAccessors.callMethodWithArgs(
      reference, _id_getWindowVisibility, jni.JniType.intType, []).integer;

  static final _id_getWindowVisibleDisplayFrame = jniAccessors.getMethodIDOf(
      _classRef, "getWindowVisibleDisplayFrame", "(Landroid/graphics/Rect;)V");

  /// from: public void getWindowVisibleDisplayFrame(android.graphics.Rect outRect)
  ///
  /// Retrieve the overall visible display size in which the window this view is
  /// attached to has been positioned in.  This takes into account screen
  /// decorations above the window, for both cases where the window itself
  /// is being position inside of them or the window is being placed under
  /// then and covered insets are used for the window to position its content
  /// inside.  In effect, this tells you the available area where content can
  /// be placed and remain visible to users.
  ///
  /// This function requires an IPC back to the window manager to retrieve
  /// the requested information, so should not be used in performance critical
  /// code like drawing.
  ///@param outRect Filled in with the visible display frame.  If the view
  /// is not attached to a window, this is simply the raw display size.
  void getWindowVisibleDisplayFrame(rect_.Rect outRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getWindowVisibleDisplayFrame,
          jni.JniType.voidType,
          [outRect.reference]).check();

  static final _id_dispatchConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void dispatchConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Dispatch a notification about a resource configuration change down
  /// the view hierarchy.
  /// ViewGroups should override to route to their children.
  ///@param newConfig The new resource configuration.
  ///@see \#onConfigurationChanged(android.content.res.Configuration)
  void dispatchConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchConfigurationChanged,
          jni.JniType.voidType,
          [newConfig.reference]).check();

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: protected void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Called when the current configuration of the resources being used
  /// by the application have changed.  You can use this to decide when
  /// to reload resources that can changed based on orientation and other
  /// configuration characteristics.  You only need to use this if you are
  /// not relying on the normal android.app.Activity mechanism of
  /// recreating the activity instance upon a configuration change.
  ///@param newConfig The new resource configuration.
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_isInTouchMode =
      jniAccessors.getMethodIDOf(_classRef, "isInTouchMode", "()Z");

  /// from: public boolean isInTouchMode()
  ///
  /// Returns whether the device is currently in touch mode.  Touch mode is entered
  /// once the user begins interacting with the device by touch, and affects various
  /// things like whether focus is always visible to the user.
  ///@return Whether the device is in touch mode.
  bool isInTouchMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isInTouchMode, jni.JniType.booleanType, []).boolean;

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public final android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the context the view is running in, through which it can
  /// access the current theme, resources, etc.
  ///@return The view's Context.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_onKeyPreIme = jniAccessors.getMethodIDOf(
      _classRef, "onKeyPreIme", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyPreIme(int keyCode, android.view.KeyEvent event)
  ///
  /// Handle a key event before it is processed by any input method
  /// associated with the view hierarchy.  This can be used to intercept
  /// key events in special situations before the IME consumes them; a
  /// typical example would be handling the BACK key to update the application's
  /// UI instead of allowing the IME to see it and close itself.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  ///@return If you handled the event, return true. If you want to allow the
  ///         event to be handled by the next receiver, return false.
  bool onKeyPreIme(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyPreIme,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyDown = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyDown(int, KeyEvent) KeyEvent.Callback.onKeyDown(): perform press of the view
  /// when KeyEvent\#KEYCODE_DPAD_CENTER or KeyEvent\#KEYCODE_ENTER
  /// is released, if the view is enabled and clickable.
  ///
  /// Key presses in software keyboards will generally NOT trigger this
  /// listener, although some may elect to do so in some situations. Do not
  /// rely on this to catch software key presses.
  ///@param keyCode a key code that represents the button pressed, from
  ///                android.view.KeyEvent
  ///@param event the KeyEvent object that defines the button action
  bool onKeyDown(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyLongPress = jniAccessors.getMethodIDOf(
      _classRef, "onKeyLongPress", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle
  /// the event).
  /// Key presses in software keyboards will generally NOT trigger this listener,
  /// although some may elect to do so in some situations. Do not rely on this to
  /// catch software key presses.
  bool onKeyLongPress(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyLongPress,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyUp = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyUp(int, KeyEvent) KeyEvent.Callback.onKeyUp(): perform clicking of the view
  /// when KeyEvent\#KEYCODE_DPAD_CENTER, KeyEvent\#KEYCODE_ENTER
  /// or KeyEvent\#KEYCODE_SPACE is released.
  /// Key presses in software keyboards will generally NOT trigger this listener,
  /// although some may elect to do so in some situations. Do not rely on this to
  /// catch software key presses.
  ///@param keyCode A key code that represents the button pressed, from
  ///                android.view.KeyEvent.
  ///@param event The KeyEvent object that defines the button action.
  bool onKeyUp(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyMultiple = jniAccessors.getMethodIDOf(
      _classRef, "onKeyMultiple", "(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyMultiple(int, int, KeyEvent) KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle
  /// the event).
  /// Key presses in software keyboards will generally NOT trigger this listener,
  /// although some may elect to do so in some situations. Do not rely on this to
  /// catch software key presses.
  ///@param keyCode A key code that represents the button pressed, from
  ///                    android.view.KeyEvent.
  ///@param repeatCount The number of times the action was made.
  ///@param event The KeyEvent object that defines the button action.
  bool onKeyMultiple(int keyCode, int repeatCount, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onKeyMultiple,
          jni.JniType.booleanType,
          [keyCode, repeatCount, event.reference]).boolean;

  static final _id_onKeyShortcut = jniAccessors.getMethodIDOf(
      _classRef, "onKeyShortcut", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyShortcut(int keyCode, android.view.KeyEvent event)
  ///
  /// Called on the focused view when a key shortcut event is not handled.
  /// Override this method to implement local key shortcuts for the View.
  /// Key shortcuts can also be implemented by setting the
  /// MenuItem\#setShortcut(char, char) shortcut property of menu items.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  ///@return If you handled the event, return true. If you want to allow the
  ///         event to be handled by the next receiver, return false.
  bool onKeyShortcut(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyShortcut,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onCheckIsTextEditor =
      jniAccessors.getMethodIDOf(_classRef, "onCheckIsTextEditor", "()Z");

  /// from: public boolean onCheckIsTextEditor()
  ///
  /// Check whether the called view is a text editor, in which case it
  /// would make sense to automatically display a soft input window for
  /// it.  Subclasses should override this if they implement
  /// \#onCreateInputConnection(EditorInfo) to return true if
  /// a call on that method would return a non-null InputConnection, and
  /// they are really a first-class editor that the user would normally
  /// start typing on when the go into a window containing your view.
  ///
  /// The default implementation always returns false.  This does
  /// _not_ mean that its \#onCreateInputConnection(EditorInfo)
  /// will not be called or the user can not otherwise perform edits on your
  /// view; it is just a hint to the system that this is not the primary
  /// purpose of this view.
  ///@return Returns true if this view is a text editor, else false.
  bool onCheckIsTextEditor() => jniAccessors.callMethodWithArgs(
      reference, _id_onCheckIsTextEditor, jni.JniType.booleanType, []).boolean;

  static final _id_onCreateInputConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateInputConnection",
      "(Landroid/view/inputmethod/EditorInfo;)Landroid/view/inputmethod/InputConnection;");

  /// from: public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo outAttrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new InputConnection for an InputMethod to interact
  /// with the view.  The default implementation returns null, since it doesn't
  /// support input methods.  You can override this to implement such support.
  /// This is only needed for views that take focus and text input.
  ///
  /// When implementing this, you probably also want to implement
  /// \#onCheckIsTextEditor() to indicate you will return a
  /// non-null InputConnection.
  ///
  ///
  /// Also, take good care to fill in the android.view.inputmethod.EditorInfo
  /// object correctly and in its entirety, so that the connected IME can rely
  /// on its values. For example, android.view.inputmethod.EditorInfo\#initialSelStart
  /// and  android.view.inputmethod.EditorInfo\#initialSelEnd members
  /// must be filled in with the correct cursor position for IMEs to work correctly
  /// with your application.
  ///
  ///@param outAttrs Fill in with attribute information about the connection.
  inputconnection_.InputConnection onCreateInputConnection(
          editorinfo_.EditorInfo outAttrs) =>
      inputconnection_.InputConnection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateInputConnection,
          jni.JniType.objectType,
          [outAttrs.reference]).object);

  static final _id_checkInputConnectionProxy = jniAccessors.getMethodIDOf(
      _classRef, "checkInputConnectionProxy", "(Landroid/view/View;)Z");

  /// from: public boolean checkInputConnectionProxy(android.view.View view)
  ///
  /// Called by the android.view.inputmethod.InputMethodManager
  /// when a view who is not the current
  /// input connection target is trying to make a call on the manager.  The
  /// default implementation returns false; you can override this to return
  /// true for certain views if you are performing InputConnection proxying
  /// to them.
  ///@param view The View that is making the InputMethodManager call.
  ///@return Return true to allow the call, false to reject.
  bool checkInputConnectionProxy(View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_checkInputConnectionProxy,
      jni.JniType.booleanType,
      [view.reference]).boolean;

  static final _id_createContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "createContextMenu", "(Landroid/view/ContextMenu;)V");

  /// from: public void createContextMenu(android.view.ContextMenu menu)
  ///
  /// Show the context menu for this view. It is not safe to hold on to the
  /// menu after returning from this method.
  ///
  /// You should normally not overload this method. Overload
  /// \#onCreateContextMenu(ContextMenu) or define an
  /// OnCreateContextMenuListener to add items to the context menu.
  ///@param menu The context menu to populate
  void createContextMenu(contextmenu_.ContextMenu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_createContextMenu,
          jni.JniType.voidType, [menu.reference]).check();

  static final _id_getContextMenuInfo = jniAccessors.getMethodIDOf(_classRef,
      "getContextMenuInfo", "()Landroid/view/ContextMenu\$ContextMenuInfo;");

  /// from: protected android.view.ContextMenu.ContextMenuInfo getContextMenuInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Views should implement this if they have extra information to associate
  /// with the context menu. The return result is supplied as a parameter to
  /// the OnCreateContextMenuListener\#onCreateContextMenu(ContextMenu, View, ContextMenuInfo)
  /// callback.
  ///@return Extra information about the item for which the context menu
  ///         should be shown. This information will vary across different
  ///         subclasses of View.
  contextmenu_.ContextMenu_ContextMenuInfo getContextMenuInfo() =>
      contextmenu_.ContextMenu_ContextMenuInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getContextMenuInfo,
              jni.JniType.objectType, []).object);

  static final _id_onCreateContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "onCreateContextMenu", "(Landroid/view/ContextMenu;)V");

  /// from: protected void onCreateContextMenu(android.view.ContextMenu menu)
  ///
  /// Views should implement this if the view itself is going to add items to
  /// the context menu.
  ///@param menu the context menu to populate
  void onCreateContextMenu(contextmenu_.ContextMenu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreateContextMenu,
          jni.JniType.voidType, [menu.reference]).check();

  static final _id_onTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to handle trackball motion events.  The
  /// _relative_ movement of the trackball since the last event
  /// can be retrieve with MotionEvent\#getX MotionEvent.getX() and
  /// MotionEvent\#getY MotionEvent.getY().  These are normalized so
  /// that a movement of 1 corresponds to the user pressing one DPAD key (so
  /// they will often be fractional values, representing the more fine-grained
  /// movement information available from a trackball).
  ///@param event The motion event.
  ///@return True if the event was handled, false otherwise.
  bool onTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to handle generic motion events.
  ///
  /// Generic motion events describe joystick movements, mouse hovers, track pad
  /// touches, scroll wheel movements and other input events.  The
  /// MotionEvent\#getSource() source of the motion event specifies
  /// the class of input that was received.  Implementations of this method
  /// must examine the bits in the source before processing the event.
  /// The following code example shows how this is done.
  ///
  ///
  /// Generic motion events with source class InputDevice\#SOURCE_CLASS_POINTER
  /// are delivered to the view under the pointer.  All other generic motion events are
  /// delivered to the focused view.
  ///
  ///
  /// <pre> public boolean onGenericMotionEvent(MotionEvent event) {
  ///     if (event.isFromSource(InputDevice.SOURCE_CLASS_JOYSTICK)) {
  ///         if (event.getAction() == MotionEvent.ACTION_MOVE) {
  ///             // process the joystick movement...
  ///             return true;
  ///         }
  ///     }
  ///     if (event.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) {
  ///         switch (event.getAction()) {
  ///             case MotionEvent.ACTION_HOVER_MOVE:
  ///                 // process the mouse hover movement...
  ///                 return true;
  ///             case MotionEvent.ACTION_SCROLL:
  ///                 // process the scroll wheel movement...
  ///                 return true;
  ///         }
  ///     }
  ///     return super.onGenericMotionEvent(event);
  /// }</pre>
  ///@param event The generic motion event being processed.
  ///@return True if the event was handled, false otherwise.
  bool onGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onHoverEvent = jniAccessors.getMethodIDOf(
      _classRef, "onHoverEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onHoverEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to handle hover events.
  ///
  /// This method is called whenever a pointer is hovering into, over, or out of the
  /// bounds of a view and the view is not currently being touched.
  /// Hover events are represented as pointer events with action
  /// MotionEvent\#ACTION_HOVER_ENTER, MotionEvent\#ACTION_HOVER_MOVE,
  /// or MotionEvent\#ACTION_HOVER_EXIT.
  ///
  ///
  /// <ul>
  /// <li>The view receives a hover event with action MotionEvent\#ACTION_HOVER_ENTER
  /// when the pointer enters the bounds of the view.</li>
  /// <li>The view receives a hover event with action MotionEvent\#ACTION_HOVER_MOVE
  /// when the pointer has already entered the bounds of the view and has moved.</li>
  /// <li>The view receives a hover event with action MotionEvent\#ACTION_HOVER_EXIT
  /// when the pointer has exited the bounds of the view or when the pointer is
  /// about to go down due to a button click, tap, or similar user action that
  /// causes the view to be touched.</li>
  /// </ul>
  ///
  /// The view should implement this method to return true to indicate that it is
  /// handling the hover event, such as by changing its drawable state.
  ///
  ///
  /// The default implementation calls \#setHovered to update the hovered state
  /// of the view when a hover enter or hover exit event is received, if the view
  /// is enabled and is clickable.  The default implementation also sends hover
  /// accessibility events.
  ///
  ///
  ///@param event The motion event that describes the hover.
  ///@return True if the view handled the hover event.
  ///@see \#isHovered
  ///@see \#setHovered
  ///@see \#onHoverChanged
  bool onHoverEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onHoverEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_isHovered =
      jniAccessors.getMethodIDOf(_classRef, "isHovered", "()Z");

  /// from: public boolean isHovered()
  ///
  /// Returns true if the view is currently hovered.
  ///@return True if the view is currently hovered.
  ///@see \#setHovered
  ///@see \#onHoverChanged
  bool isHovered() => jniAccessors.callMethodWithArgs(
      reference, _id_isHovered, jni.JniType.booleanType, []).boolean;

  static final _id_setHovered =
      jniAccessors.getMethodIDOf(_classRef, "setHovered", "(Z)V");

  /// from: public void setHovered(boolean hovered)
  ///
  /// Sets whether the view is currently hovered.
  ///
  /// Calling this method also changes the drawable state of the view.  This
  /// enables the view to react to hover by using different drawable resources
  /// to change its appearance.
  ///
  ///
  /// The \#onHoverChanged method is called when the hovered state changes.
  ///
  ///
  ///@param hovered True if the view is hovered.
  ///@see \#isHovered
  ///@see \#onHoverChanged
  void setHovered(bool hovered) => jniAccessors.callMethodWithArgs(
      reference, _id_setHovered, jni.JniType.voidType, [hovered]).check();

  static final _id_onHoverChanged =
      jniAccessors.getMethodIDOf(_classRef, "onHoverChanged", "(Z)V");

  /// from: public void onHoverChanged(boolean hovered)
  ///
  /// Implement this method to handle hover state changes.
  ///
  /// This method is called whenever the hover state changes as a result of a
  /// call to \#setHovered.
  ///
  ///
  ///@param hovered The current hover state, as returned by \#isHovered.
  ///@see \#isHovered
  ///@see \#setHovered
  void onHoverChanged(bool hovered) => jniAccessors.callMethodWithArgs(
      reference, _id_onHoverChanged, jni.JniType.voidType, [hovered]).check();

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to handle touch screen motion events.
  ///
  /// If this method is used to detect click actions, it is recommended that
  /// the actions be performed by implementing and calling
  /// \#performClick(). This will ensure consistent system behavior,
  /// including:
  /// <ul>
  /// <li>obeying click sound preferences
  /// <li>dispatching OnClickListener calls
  /// <li>handling AccessibilityNodeInfo\#ACTION_CLICK ACTION_CLICK when
  /// accessibility features are enabled
  /// </ul>
  ///@param event The motion event.
  ///@return True if the event was handled, false otherwise.
  bool onTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_cancelLongPress =
      jniAccessors.getMethodIDOf(_classRef, "cancelLongPress", "()V");

  /// from: public void cancelLongPress()
  ///
  /// Cancels a pending long press.  Your subclass can use this if you
  /// want the context menu to come up if the user presses and holds
  /// at the same place, but you don't want it to come up if they press
  /// and then move around enough to cause scrolling.
  void cancelLongPress() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelLongPress, jni.JniType.voidType, []).check();

  static final _id_setTouchDelegate = jniAccessors.getMethodIDOf(
      _classRef, "setTouchDelegate", "(Landroid/view/TouchDelegate;)V");

  /// from: public void setTouchDelegate(android.view.TouchDelegate delegate)
  ///
  /// Sets the TouchDelegate for this View.
  void setTouchDelegate(touchdelegate_.TouchDelegate delegate) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTouchDelegate,
          jni.JniType.voidType, [delegate.reference]).check();

  static final _id_getTouchDelegate = jniAccessors.getMethodIDOf(
      _classRef, "getTouchDelegate", "()Landroid/view/TouchDelegate;");

  /// from: public android.view.TouchDelegate getTouchDelegate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the TouchDelegate for this View.
  touchdelegate_.TouchDelegate getTouchDelegate() =>
      touchdelegate_.TouchDelegate.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTouchDelegate, jni.JniType.objectType, []).object);

  static final _id_requestUnbufferedDispatch = jniAccessors.getMethodIDOf(
      _classRef, "requestUnbufferedDispatch", "(Landroid/view/MotionEvent;)V");

  /// from: public final void requestUnbufferedDispatch(android.view.MotionEvent event)
  ///
  /// Request unbuffered dispatch of the given stream of MotionEvents to this View.
  ///
  /// Until this View receives a corresponding MotionEvent\#ACTION_UP, ask that the input
  /// system not batch MotionEvents but instead deliver them as soon as they're
  /// available. This method should only be called for touch events.
  ///
  /// <p class="note">This api is not intended for most applications. Buffered dispatch
  /// provides many of benefits, and just requesting unbuffered dispatch on most MotionEvent
  /// streams will not improve your input latency. Side effects include: increased latency,
  /// jittery scrolls and inability to take advantage of system resampling. Talk to your input
  /// professional to see if \#requestUnbufferedDispatch(MotionEvent) is right for
  /// you.
  ///
  void requestUnbufferedDispatch(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestUnbufferedDispatch,
          jni.JniType.voidType, [event.reference]).check();

  static final _id_bringToFront =
      jniAccessors.getMethodIDOf(_classRef, "bringToFront", "()V");

  /// from: public void bringToFront()
  ///
  /// Change the view's z order in the tree, so it's on top of other sibling
  /// views. This ordering change may affect layout, if the parent container
  /// uses an order-dependent layout scheme (e.g., LinearLayout). Prior
  /// to android.os.Build.VERSION_CODES\#KITKAT this
  /// method should be followed by calls to \#requestLayout() and
  /// View\#invalidate() on the view's parent to force the parent to redraw
  /// with the new child ordering.
  ///@see ViewGroup\#bringChildToFront(View)
  void bringToFront() => jniAccessors.callMethodWithArgs(
      reference, _id_bringToFront, jni.JniType.voidType, []).check();

  static final _id_onScrollChanged =
      jniAccessors.getMethodIDOf(_classRef, "onScrollChanged", "(IIII)V");

  /// from: protected void onScrollChanged(int l, int t, int oldl, int oldt)
  ///
  /// This is called in response to an internal scroll in this view (i.e., the
  /// view scrolled its own contents). This is typically as a result of
  /// \#scrollBy(int, int) or \#scrollTo(int, int) having been
  /// called.
  ///@param l Current horizontal scroll origin.
  ///@param t Current vertical scroll origin.
  ///@param oldl Previous horizontal scroll origin.
  ///@param oldt Previous vertical scroll origin.
  void onScrollChanged(int l, int t, int oldl, int oldt) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScrollChanged,
          jni.JniType.voidType, [l, t, oldl, oldt]).check();

  static final _id_onSizeChanged =
      jniAccessors.getMethodIDOf(_classRef, "onSizeChanged", "(IIII)V");

  /// from: protected void onSizeChanged(int w, int h, int oldw, int oldh)
  ///
  /// This is called during layout when the size of this view has changed. If
  /// you were just added to the view hierarchy, you're called with the old
  /// values of 0.
  ///@param w Current width of this view.
  ///@param h Current height of this view.
  ///@param oldw Old width of this view.
  ///@param oldh Old height of this view.
  void onSizeChanged(int w, int h, int oldw, int oldh) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSizeChanged,
          jni.JniType.voidType, [w, h, oldw, oldh]).check();

  static final _id_dispatchDraw = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  ///
  /// Called by draw to draw the child views. This may be overridden
  /// by derived classes to gain control just before its children are drawn
  /// (but after its own view has been drawn).
  ///@param canvas the canvas on which to draw the view
  void dispatchDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_getParent = jniAccessors.getMethodIDOf(
      _classRef, "getParent", "()Landroid/view/ViewParent;");

  /// from: public final android.view.ViewParent getParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the parent of this view. Note that the parent is a
  /// ViewParent and not necessarily a View.
  ///@return Parent of this view.
  viewparent_.ViewParent getParent() =>
      viewparent_.ViewParent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getParent, jni.JniType.objectType, []).object);

  static final _id_setScrollX =
      jniAccessors.getMethodIDOf(_classRef, "setScrollX", "(I)V");

  /// from: public void setScrollX(int value)
  ///
  /// Set the horizontal scrolled position of your view. This will cause a call to
  /// \#onScrollChanged(int, int, int, int) and the view will be
  /// invalidated.
  ///@param value the x position to scroll to
  void setScrollX(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_setScrollX, jni.JniType.voidType, [value]).check();

  static final _id_setScrollY =
      jniAccessors.getMethodIDOf(_classRef, "setScrollY", "(I)V");

  /// from: public void setScrollY(int value)
  ///
  /// Set the vertical scrolled position of your view. This will cause a call to
  /// \#onScrollChanged(int, int, int, int) and the view will be
  /// invalidated.
  ///@param value the y position to scroll to
  void setScrollY(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_setScrollY, jni.JniType.voidType, [value]).check();

  static final _id_getScrollX =
      jniAccessors.getMethodIDOf(_classRef, "getScrollX", "()I");

  /// from: public final int getScrollX()
  ///
  /// Return the scrolled left position of this view. This is the left edge of
  /// the displayed part of your view. You do not need to draw any pixels
  /// farther left, since those are outside of the frame of your view on
  /// screen.
  ///@return The left edge of the displayed part of your view, in pixels.
  int getScrollX() => jniAccessors.callMethodWithArgs(
      reference, _id_getScrollX, jni.JniType.intType, []).integer;

  static final _id_getScrollY =
      jniAccessors.getMethodIDOf(_classRef, "getScrollY", "()I");

  /// from: public final int getScrollY()
  ///
  /// Return the scrolled top position of this view. This is the top edge of
  /// the displayed part of your view. You do not need to draw any pixels above
  /// it, since those are outside of the frame of your view on screen.
  ///@return The top edge of the displayed part of your view, in pixels.
  int getScrollY() => jniAccessors.callMethodWithArgs(
      reference, _id_getScrollY, jni.JniType.intType, []).integer;

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public final int getWidth()
  ///
  /// Return the width of your view.
  ///@return The width of your view, in pixels.
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public final int getHeight()
  ///
  /// Return the height of your view.
  ///@return The height of your view, in pixels.
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getDrawingRect = jniAccessors.getMethodIDOf(
      _classRef, "getDrawingRect", "(Landroid/graphics/Rect;)V");

  /// from: public void getDrawingRect(android.graphics.Rect outRect)
  ///
  /// Return the visible drawing bounds of your view. Fills in the output
  /// rectangle with the values from getScrollX(), getScrollY(),
  /// getWidth(), and getHeight(). These bounds do not account for any
  /// transformation properties currently set on the view, such as
  /// \#setScaleX(float) or \#setRotation(float).
  ///@param outRect The (scrolled) drawing bounds of the view.
  void getDrawingRect(rect_.Rect outRect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDrawingRect,
      jni.JniType.voidType,
      [outRect.reference]).check();

  static final _id_getMeasuredWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMeasuredWidth", "()I");

  /// from: public final int getMeasuredWidth()
  ///
  /// Like \#getMeasuredWidthAndState(), but only returns the
  /// raw width component (that is the result is masked by
  /// \#MEASURED_SIZE_MASK).
  ///@return The raw measured width of this view.
  int getMeasuredWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMeasuredWidth, jni.JniType.intType, []).integer;

  static final _id_getMeasuredWidthAndState =
      jniAccessors.getMethodIDOf(_classRef, "getMeasuredWidthAndState", "()I");

  /// from: public final int getMeasuredWidthAndState()
  ///
  /// Return the full width measurement information for this view as computed
  /// by the most recent call to \#measure(int, int).  This result is a bit mask
  /// as defined by \#MEASURED_SIZE_MASK and \#MEASURED_STATE_TOO_SMALL.
  /// This should be used during measurement and layout calculations only. Use
  /// \#getWidth() to see how wide a view is after layout.
  ///@return The measured width of this view as a bit mask.
  int getMeasuredWidthAndState() => jniAccessors.callMethodWithArgs(
      reference, _id_getMeasuredWidthAndState, jni.JniType.intType, []).integer;

  static final _id_getMeasuredHeight =
      jniAccessors.getMethodIDOf(_classRef, "getMeasuredHeight", "()I");

  /// from: public final int getMeasuredHeight()
  ///
  /// Like \#getMeasuredHeightAndState(), but only returns the
  /// raw height component (that is the result is masked by
  /// \#MEASURED_SIZE_MASK).
  ///@return The raw measured height of this view.
  int getMeasuredHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getMeasuredHeight, jni.JniType.intType, []).integer;

  static final _id_getMeasuredHeightAndState =
      jniAccessors.getMethodIDOf(_classRef, "getMeasuredHeightAndState", "()I");

  /// from: public final int getMeasuredHeightAndState()
  ///
  /// Return the full height measurement information for this view as computed
  /// by the most recent call to \#measure(int, int).  This result is a bit mask
  /// as defined by \#MEASURED_SIZE_MASK and \#MEASURED_STATE_TOO_SMALL.
  /// This should be used during measurement and layout calculations only. Use
  /// \#getHeight() to see how wide a view is after layout.
  ///@return The measured height of this view as a bit mask.
  int getMeasuredHeightAndState() => jniAccessors.callMethodWithArgs(reference,
      _id_getMeasuredHeightAndState, jni.JniType.intType, []).integer;

  static final _id_getMeasuredState =
      jniAccessors.getMethodIDOf(_classRef, "getMeasuredState", "()I");

  /// from: public final int getMeasuredState()
  ///
  /// Return only the state bits of \#getMeasuredWidthAndState()
  /// and \#getMeasuredHeightAndState(), combined into one integer.
  /// The width component is in the regular bits \#MEASURED_STATE_MASK
  /// and the height component is at the shifted bits
  /// \#MEASURED_HEIGHT_STATE_SHIFT>>\#MEASURED_STATE_MASK.
  int getMeasuredState() => jniAccessors.callMethodWithArgs(
      reference, _id_getMeasuredState, jni.JniType.intType, []).integer;

  static final _id_getMatrix = jniAccessors.getMethodIDOf(
      _classRef, "getMatrix", "()Landroid/graphics/Matrix;");

  /// from: public android.graphics.Matrix getMatrix()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The transform matrix of this view, which is calculated based on the current
  /// rotation, scale, and pivot properties.
  ///@see \#getRotation()
  ///@see \#getScaleX()
  ///@see \#getScaleY()
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@return The current transform matrix for the view
  matrix_.Matrix getMatrix() =>
      matrix_.Matrix.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMatrix, jni.JniType.objectType, []).object);

  static final _id_getCameraDistance =
      jniAccessors.getMethodIDOf(_classRef, "getCameraDistance", "()F");

  /// from: public float getCameraDistance()
  ///
  /// Gets the distance along the Z axis from the camera to this view.
  ///@see \#setCameraDistance(float)
  ///@return The distance along the Z axis.
  double getCameraDistance() => jniAccessors.callMethodWithArgs(
      reference, _id_getCameraDistance, jni.JniType.floatType, []).float;

  static final _id_setCameraDistance =
      jniAccessors.getMethodIDOf(_classRef, "setCameraDistance", "(F)V");

  /// from: public void setCameraDistance(float distance)
  ///
  /// Sets the distance along the Z axis (orthogonal to the X/Y plane on which
  /// views are drawn) from the camera to this view. The camera's distance
  /// affects 3D transformations, for instance rotations around the X and Y
  /// axis. If the rotationX or rotationY properties are changed and this view is
  /// large (more than half the size of the screen), it is recommended to always
  /// use a camera distance that's greater than the height (X axis rotation) or
  /// the width (Y axis rotation) of this view.
  ///
  ///
  /// The distance of the camera from the view plane can have an affect on the
  /// perspective distortion of the view when it is rotated around the x or y axis.
  /// For example, a large distance will result in a large viewing angle, and there
  /// will not be much perspective distortion of the view as it rotates. A short
  /// distance may cause much more perspective distortion upon rotation, and can
  /// also result in some drawing artifacts if the rotated view ends up partially
  /// behind the camera (which is why the recommendation is to use a distance at
  /// least as far as the size of the view, if the view is to be rotated.)
  ///
  ///
  /// The distance is expressed in "depth pixels." The default distance depends
  /// on the screen density. For instance, on a medium density display, the
  /// default distance is 1280. On a high density display, the default distance
  /// is 1920.
  ///
  ///
  /// If you want to specify a distance that leads to visually consistent
  /// results across various densities, use the following formula:
  ///
  /// <pre>
  /// float scale = context.getResources().getDisplayMetrics().density;
  /// view.setCameraDistance(distance * scale);
  /// </pre>
  ///
  /// The density scale factor of a high density display is 1.5,
  /// and 1920 = 1280 * 1.5.
  ///
  ///@param distance The distance in "depth pixels", if negative the opposite
  ///        value is used
  ///@see \#setRotationX(float)
  ///@see \#setRotationY(float)
  void setCameraDistance(double distance) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCameraDistance,
      jni.JniType.voidType,
      [distance]).check();

  static final _id_getRotation =
      jniAccessors.getMethodIDOf(_classRef, "getRotation", "()F");

  /// from: public float getRotation()
  ///
  /// The degrees that the view is rotated around the pivot point.
  ///@see \#setRotation(float)
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@return The degrees of rotation.
  double getRotation() => jniAccessors.callMethodWithArgs(
      reference, _id_getRotation, jni.JniType.floatType, []).float;

  static final _id_setRotation =
      jniAccessors.getMethodIDOf(_classRef, "setRotation", "(F)V");

  /// from: public void setRotation(float rotation)
  ///
  /// Sets the degrees that the view is rotated around the pivot point. Increasing values
  /// result in clockwise rotation.
  ///@param rotation The degrees of rotation.
  ///@see \#getRotation()
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@see \#setRotationX(float)
  ///@see \#setRotationY(float)
  ///@attr ref android.R.styleable\#View_rotation
  void setRotation(double rotation) => jniAccessors.callMethodWithArgs(
      reference, _id_setRotation, jni.JniType.voidType, [rotation]).check();

  static final _id_getRotationY =
      jniAccessors.getMethodIDOf(_classRef, "getRotationY", "()F");

  /// from: public float getRotationY()
  ///
  /// The degrees that the view is rotated around the vertical axis through the pivot point.
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@see \#setRotationY(float)
  ///@return The degrees of Y rotation.
  double getRotationY() => jniAccessors.callMethodWithArgs(
      reference, _id_getRotationY, jni.JniType.floatType, []).float;

  static final _id_setRotationY =
      jniAccessors.getMethodIDOf(_classRef, "setRotationY", "(F)V");

  /// from: public void setRotationY(float rotationY)
  ///
  /// Sets the degrees that the view is rotated around the vertical axis through the pivot point.
  /// Increasing values result in counter-clockwise rotation from the viewpoint of looking
  /// down the y axis.
  ///
  /// When rotating large views, it is recommended to adjust the camera distance
  /// accordingly. Refer to \#setCameraDistance(float) for more information.
  ///@param rotationY The degrees of Y rotation.
  ///@see \#getRotationY()
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@see \#setRotation(float)
  ///@see \#setRotationX(float)
  ///@see \#setCameraDistance(float)
  ///@attr ref android.R.styleable\#View_rotationY
  void setRotationY(double rotationY) => jniAccessors.callMethodWithArgs(
      reference, _id_setRotationY, jni.JniType.voidType, [rotationY]).check();

  static final _id_getRotationX =
      jniAccessors.getMethodIDOf(_classRef, "getRotationX", "()F");

  /// from: public float getRotationX()
  ///
  /// The degrees that the view is rotated around the horizontal axis through the pivot point.
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@see \#setRotationX(float)
  ///@return The degrees of X rotation.
  double getRotationX() => jniAccessors.callMethodWithArgs(
      reference, _id_getRotationX, jni.JniType.floatType, []).float;

  static final _id_setRotationX =
      jniAccessors.getMethodIDOf(_classRef, "setRotationX", "(F)V");

  /// from: public void setRotationX(float rotationX)
  ///
  /// Sets the degrees that the view is rotated around the horizontal axis through the pivot point.
  /// Increasing values result in clockwise rotation from the viewpoint of looking down the
  /// x axis.
  ///
  /// When rotating large views, it is recommended to adjust the camera distance
  /// accordingly. Refer to \#setCameraDistance(float) for more information.
  ///@param rotationX The degrees of X rotation.
  ///@see \#getRotationX()
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@see \#setRotation(float)
  ///@see \#setRotationY(float)
  ///@see \#setCameraDistance(float)
  ///@attr ref android.R.styleable\#View_rotationX
  void setRotationX(double rotationX) => jniAccessors.callMethodWithArgs(
      reference, _id_setRotationX, jni.JniType.voidType, [rotationX]).check();

  static final _id_getScaleX =
      jniAccessors.getMethodIDOf(_classRef, "getScaleX", "()F");

  /// from: public float getScaleX()
  ///
  /// The amount that the view is scaled in x around the pivot point, as a proportion of
  /// the view's unscaled width. A value of 1, the default, means that no scaling is applied.
  ///
  /// By default, this is 1.0f.
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@return The scaling factor.
  double getScaleX() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaleX, jni.JniType.floatType, []).float;

  static final _id_setScaleX =
      jniAccessors.getMethodIDOf(_classRef, "setScaleX", "(F)V");

  /// from: public void setScaleX(float scaleX)
  ///
  /// Sets the amount that the view is scaled in x around the pivot point, as a proportion of
  /// the view's unscaled width. A value of 1 means that no scaling is applied.
  ///@param scaleX The scaling factor.
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@attr ref android.R.styleable\#View_scaleX
  void setScaleX(double scaleX) => jniAccessors.callMethodWithArgs(
      reference, _id_setScaleX, jni.JniType.voidType, [scaleX]).check();

  static final _id_getScaleY =
      jniAccessors.getMethodIDOf(_classRef, "getScaleY", "()F");

  /// from: public float getScaleY()
  ///
  /// The amount that the view is scaled in y around the pivot point, as a proportion of
  /// the view's unscaled height. A value of 1, the default, means that no scaling is applied.
  ///
  /// By default, this is 1.0f.
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@return The scaling factor.
  double getScaleY() => jniAccessors.callMethodWithArgs(
      reference, _id_getScaleY, jni.JniType.floatType, []).float;

  static final _id_setScaleY =
      jniAccessors.getMethodIDOf(_classRef, "setScaleY", "(F)V");

  /// from: public void setScaleY(float scaleY)
  ///
  /// Sets the amount that the view is scaled in Y around the pivot point, as a proportion of
  /// the view's unscaled width. A value of 1 means that no scaling is applied.
  ///@param scaleY The scaling factor.
  ///@see \#getPivotX()
  ///@see \#getPivotY()
  ///@attr ref android.R.styleable\#View_scaleY
  void setScaleY(double scaleY) => jniAccessors.callMethodWithArgs(
      reference, _id_setScaleY, jni.JniType.voidType, [scaleY]).check();

  static final _id_getPivotX =
      jniAccessors.getMethodIDOf(_classRef, "getPivotX", "()F");

  /// from: public float getPivotX()
  ///
  /// The x location of the point around which the view is \#setRotation(float) rotated
  /// and \#setScaleX(float) scaled.
  ///@see \#getRotation()
  ///@see \#getScaleX()
  ///@see \#getScaleY()
  ///@see \#getPivotY()
  ///@return The x location of the pivot point.
  ///@attr ref android.R.styleable\#View_transformPivotX
  double getPivotX() => jniAccessors.callMethodWithArgs(
      reference, _id_getPivotX, jni.JniType.floatType, []).float;

  static final _id_setPivotX =
      jniAccessors.getMethodIDOf(_classRef, "setPivotX", "(F)V");

  /// from: public void setPivotX(float pivotX)
  ///
  /// Sets the x location of the point around which the view is
  /// \#setRotation(float) rotated and \#setScaleX(float) scaled.
  /// By default, the pivot point is centered on the object.
  /// Setting this property disables this behavior and causes the view to use only the
  /// explicitly set pivotX and pivotY values.
  ///@param pivotX The x location of the pivot point.
  ///@see \#getRotation()
  ///@see \#getScaleX()
  ///@see \#getScaleY()
  ///@see \#getPivotY()
  ///@attr ref android.R.styleable\#View_transformPivotX
  void setPivotX(double pivotX) => jniAccessors.callMethodWithArgs(
      reference, _id_setPivotX, jni.JniType.voidType, [pivotX]).check();

  static final _id_getPivotY =
      jniAccessors.getMethodIDOf(_classRef, "getPivotY", "()F");

  /// from: public float getPivotY()
  ///
  /// The y location of the point around which the view is \#setRotation(float) rotated
  /// and \#setScaleY(float) scaled.
  ///@see \#getRotation()
  ///@see \#getScaleX()
  ///@see \#getScaleY()
  ///@see \#getPivotY()
  ///@return The y location of the pivot point.
  ///@attr ref android.R.styleable\#View_transformPivotY
  double getPivotY() => jniAccessors.callMethodWithArgs(
      reference, _id_getPivotY, jni.JniType.floatType, []).float;

  static final _id_setPivotY =
      jniAccessors.getMethodIDOf(_classRef, "setPivotY", "(F)V");

  /// from: public void setPivotY(float pivotY)
  ///
  /// Sets the y location of the point around which the view is \#setRotation(float) rotated
  /// and \#setScaleY(float) scaled. By default, the pivot point is centered on the object.
  /// Setting this property disables this behavior and causes the view to use only the
  /// explicitly set pivotX and pivotY values.
  ///@param pivotY The y location of the pivot point.
  ///@see \#getRotation()
  ///@see \#getScaleX()
  ///@see \#getScaleY()
  ///@see \#getPivotY()
  ///@attr ref android.R.styleable\#View_transformPivotY
  void setPivotY(double pivotY) => jniAccessors.callMethodWithArgs(
      reference, _id_setPivotY, jni.JniType.voidType, [pivotY]).check();

  static final _id_isPivotSet =
      jniAccessors.getMethodIDOf(_classRef, "isPivotSet", "()Z");

  /// from: public boolean isPivotSet()
  ///
  /// Returns whether or not a pivot has been set by a call to \#setPivotX(float) or
  /// \#setPivotY(float). If no pivot has been set then the pivot will be the center
  /// of the view.
  ///@return True if a pivot has been set, false if the default pivot is being used
  bool isPivotSet() => jniAccessors.callMethodWithArgs(
      reference, _id_isPivotSet, jni.JniType.booleanType, []).boolean;

  static final _id_resetPivot =
      jniAccessors.getMethodIDOf(_classRef, "resetPivot", "()V");

  /// from: public void resetPivot()
  ///
  /// Clears any pivot previously set by a call to  \#setPivotX(float) or
  /// \#setPivotY(float). After calling this \#isPivotSet() will be false
  /// and the pivot used for rotation will return to default of being centered on the view.
  void resetPivot() => jniAccessors.callMethodWithArgs(
      reference, _id_resetPivot, jni.JniType.voidType, []).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()F");

  /// from: public float getAlpha()
  ///
  /// The opacity of the view. This is a value from 0 to 1, where 0 means the view is
  /// completely transparent and 1 means the view is completely opaque.
  ///
  /// By default this is 1.0f.
  ///@return The opacity of the view.
  double getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.floatType, []).float;

  static final _id_forceHasOverlappingRendering = jniAccessors.getMethodIDOf(
      _classRef, "forceHasOverlappingRendering", "(Z)V");

  /// from: public void forceHasOverlappingRendering(boolean hasOverlappingRendering)
  ///
  /// Sets the behavior for overlapping rendering for this view (see \#hasOverlappingRendering() for more details on this behavior). Calling this method
  /// is an alternative to overriding \#hasOverlappingRendering() in a subclass,
  /// providing the value which is then used internally. That is, when \#forceHasOverlappingRendering(boolean) is called, the value of \#hasOverlappingRendering() is ignored and the value passed into this method is used
  /// instead.
  ///@param hasOverlappingRendering The value for overlapping rendering to be used internally
  /// instead of that returned by \#hasOverlappingRendering().
  ///@attr ref android.R.styleable\#View_forceHasOverlappingRendering
  void forceHasOverlappingRendering(bool hasOverlappingRendering) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_forceHasOverlappingRendering,
          jni.JniType.voidType,
          [hasOverlappingRendering]).check();

  static final _id_getHasOverlappingRendering = jniAccessors.getMethodIDOf(
      _classRef, "getHasOverlappingRendering", "()Z");

  /// from: public final boolean getHasOverlappingRendering()
  ///
  /// Returns the value for overlapping rendering that is used internally. This is either
  /// the value passed into \#forceHasOverlappingRendering(boolean), if called, or
  /// the return value of \#hasOverlappingRendering(), otherwise.
  ///@return The value for overlapping rendering being used internally.
  bool getHasOverlappingRendering() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHasOverlappingRendering,
      jni.JniType.booleanType, []).boolean;

  static final _id_hasOverlappingRendering =
      jniAccessors.getMethodIDOf(_classRef, "hasOverlappingRendering", "()Z");

  /// from: public boolean hasOverlappingRendering()
  ///
  /// Returns whether this View has content which overlaps.
  ///
  /// This function, intended to be overridden by specific View types, is an optimization when
  /// alpha is set on a view. If rendering overlaps in a view with alpha < 1, that view is drawn to
  /// an offscreen buffer and then composited into place, which can be expensive. If the view has
  /// no overlapping rendering, the view can draw each primitive with the appropriate alpha value
  /// directly. An example of overlapping rendering is a TextView with a background image, such as
  /// a Button. An example of non-overlapping rendering is a TextView with no background, or an
  /// ImageView with only the foreground image. The default implementation returns true; subclasses
  /// should override if they have cases which can be optimized.
  ///
  ///
  /// <strong>Note:</strong> The return value of this method is ignored if \#forceHasOverlappingRendering(boolean) has been called on this view.
  ///
  ///@return true if the content in this view might overlap, false otherwise.
  bool hasOverlappingRendering() => jniAccessors.callMethodWithArgs(reference,
      _id_hasOverlappingRendering, jni.JniType.booleanType, []).boolean;

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(F)V");

  /// from: public void setAlpha(float alpha)
  ///
  /// Sets the opacity of the view to a value from 0 to 1, where 0 means the view is
  /// completely transparent and 1 means the view is completely opaque.
  ///
  /// <p class="note"><strong>Note:</strong> setting alpha to a translucent value (0 < alpha < 1)
  /// can have significant performance implications, especially for large views. It is best to use
  /// the alpha property sparingly and transiently, as in the case of fading animations.
  ///
  ///
  /// For a view with a frequently changing alpha, such as during a fading animation, it is
  /// strongly recommended for performance reasons to either override
  /// \#hasOverlappingRendering() to return <code>false</code> if appropriate, or setting a
  /// \#setLayerType(int, android.graphics.Paint) layer type on the view for the duration
  /// of the animation. On versions android.os.Build.VERSION_CODES\#M and below,
  /// the default path for rendering an unlayered View with alpha could add multiple milliseconds
  /// of rendering cost, even for simple or small views. Starting with
  /// android.os.Build.VERSION_CODES\#M, \#LAYER_TYPE_HARDWARE is automatically
  /// applied to the view at the rendering level.
  ///
  ///
  /// If this view overrides \#onSetAlpha(int) to return true, then this view is
  /// responsible for applying the opacity itself.
  ///
  ///
  /// On versions android.os.Build.VERSION_CODES\#LOLLIPOP_MR1 and below, note that if
  /// the view is backed by a \#setLayerType(int, android.graphics.Paint) layer and is
  /// associated with a \#setLayerPaint(android.graphics.Paint) layer paint, setting an
  /// alpha value less than 1.0 will supersede the alpha of the layer paint.
  ///
  ///
  /// Starting with android.os.Build.VERSION_CODES\#M, setting a translucent alpha
  /// value will clip a View to its bounds, unless the View returns <code>false</code> from
  /// \#hasOverlappingRendering.
  ///
  ///@param alpha The opacity of the view.
  ///
  /// Value is between 0.0 and 1.0 inclusive
  ///@see \#hasOverlappingRendering()
  ///@see \#setLayerType(int, android.graphics.Paint)
  ///@attr ref android.R.styleable\#View_alpha
  void setAlpha(double alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_getTop =
      jniAccessors.getMethodIDOf(_classRef, "getTop", "()I");

  /// from: public final int getTop()
  ///
  /// Top position of this view relative to its parent.
  ///@return The top of this view, in pixels.
  int getTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getTop, jni.JniType.intType, []).integer;

  static final _id_setTop =
      jniAccessors.getMethodIDOf(_classRef, "setTop", "(I)V");

  /// from: public final void setTop(int top)
  ///
  /// Sets the top position of this view relative to its parent. This method is meant to be called
  /// by the layout system and should not generally be called otherwise, because the property
  /// may be changed at any time by the layout.
  ///@param top The top of this view, in pixels.
  void setTop(int top) => jniAccessors.callMethodWithArgs(
      reference, _id_setTop, jni.JniType.voidType, [top]).check();

  static final _id_getBottom =
      jniAccessors.getMethodIDOf(_classRef, "getBottom", "()I");

  /// from: public final int getBottom()
  ///
  /// Bottom position of this view relative to its parent.
  ///@return The bottom of this view, in pixels.
  int getBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getBottom, jni.JniType.intType, []).integer;

  static final _id_isDirty =
      jniAccessors.getMethodIDOf(_classRef, "isDirty", "()Z");

  /// from: public boolean isDirty()
  ///
  /// True if this view has changed since the last time being drawn.
  ///@return The dirty state of this view.
  bool isDirty() => jniAccessors.callMethodWithArgs(
      reference, _id_isDirty, jni.JniType.booleanType, []).boolean;

  static final _id_setBottom =
      jniAccessors.getMethodIDOf(_classRef, "setBottom", "(I)V");

  /// from: public final void setBottom(int bottom)
  ///
  /// Sets the bottom position of this view relative to its parent. This method is meant to be
  /// called by the layout system and should not generally be called otherwise, because the
  /// property may be changed at any time by the layout.
  ///@param bottom The bottom of this view, in pixels.
  void setBottom(int bottom) => jniAccessors.callMethodWithArgs(
      reference, _id_setBottom, jni.JniType.voidType, [bottom]).check();

  static final _id_getLeft =
      jniAccessors.getMethodIDOf(_classRef, "getLeft", "()I");

  /// from: public final int getLeft()
  ///
  /// Left position of this view relative to its parent.
  ///@return The left edge of this view, in pixels.
  int getLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getLeft, jni.JniType.intType, []).integer;

  static final _id_setLeft =
      jniAccessors.getMethodIDOf(_classRef, "setLeft", "(I)V");

  /// from: public final void setLeft(int left)
  ///
  /// Sets the left position of this view relative to its parent. This method is meant to be called
  /// by the layout system and should not generally be called otherwise, because the property
  /// may be changed at any time by the layout.
  ///@param left The left of this view, in pixels.
  void setLeft(int left) => jniAccessors.callMethodWithArgs(
      reference, _id_setLeft, jni.JniType.voidType, [left]).check();

  static final _id_getRight =
      jniAccessors.getMethodIDOf(_classRef, "getRight", "()I");

  /// from: public final int getRight()
  ///
  /// Right position of this view relative to its parent.
  ///@return The right edge of this view, in pixels.
  int getRight() => jniAccessors.callMethodWithArgs(
      reference, _id_getRight, jni.JniType.intType, []).integer;

  static final _id_setRight =
      jniAccessors.getMethodIDOf(_classRef, "setRight", "(I)V");

  /// from: public final void setRight(int right)
  ///
  /// Sets the right position of this view relative to its parent. This method is meant to be called
  /// by the layout system and should not generally be called otherwise, because the property
  /// may be changed at any time by the layout.
  ///@param right The right of this view, in pixels.
  void setRight(int right) => jniAccessors.callMethodWithArgs(
      reference, _id_setRight, jni.JniType.voidType, [right]).check();

  static final _id_getX = jniAccessors.getMethodIDOf(_classRef, "getX", "()F");

  /// from: public float getX()
  ///
  /// The visual x position of this view, in pixels. This is equivalent to the
  /// \#setTranslationX(float) translationX property plus the current
  /// \#getLeft() left property.
  ///@return The visual x position of this view, in pixels.
  double getX() => jniAccessors
      .callMethodWithArgs(reference, _id_getX, jni.JniType.floatType, []).float;

  static final _id_setX = jniAccessors.getMethodIDOf(_classRef, "setX", "(F)V");

  /// from: public void setX(float x)
  ///
  /// Sets the visual x position of this view, in pixels. This is equivalent to setting the
  /// \#setTranslationX(float) translationX property to be the difference between
  /// the x value passed in and the current \#getLeft() left property.
  ///@param x The visual x position of this view, in pixels.
  void setX(double x) => jniAccessors.callMethodWithArgs(
      reference, _id_setX, jni.JniType.voidType, [x]).check();

  static final _id_getY = jniAccessors.getMethodIDOf(_classRef, "getY", "()F");

  /// from: public float getY()
  ///
  /// The visual y position of this view, in pixels. This is equivalent to the
  /// \#setTranslationY(float) translationY property plus the current
  /// \#getTop() top property.
  ///@return The visual y position of this view, in pixels.
  double getY() => jniAccessors
      .callMethodWithArgs(reference, _id_getY, jni.JniType.floatType, []).float;

  static final _id_setY = jniAccessors.getMethodIDOf(_classRef, "setY", "(F)V");

  /// from: public void setY(float y)
  ///
  /// Sets the visual y position of this view, in pixels. This is equivalent to setting the
  /// \#setTranslationY(float) translationY property to be the difference between
  /// the y value passed in and the current \#getTop() top property.
  ///@param y The visual y position of this view, in pixels.
  void setY(double y) => jniAccessors.callMethodWithArgs(
      reference, _id_setY, jni.JniType.voidType, [y]).check();

  static final _id_getZ = jniAccessors.getMethodIDOf(_classRef, "getZ", "()F");

  /// from: public float getZ()
  ///
  /// The visual z position of this view, in pixels. This is equivalent to the
  /// \#setTranslationZ(float) translationZ property plus the current
  /// \#getElevation() elevation property.
  ///@return The visual z position of this view, in pixels.
  double getZ() => jniAccessors
      .callMethodWithArgs(reference, _id_getZ, jni.JniType.floatType, []).float;

  static final _id_setZ = jniAccessors.getMethodIDOf(_classRef, "setZ", "(F)V");

  /// from: public void setZ(float z)
  ///
  /// Sets the visual z position of this view, in pixels. This is equivalent to setting the
  /// \#setTranslationZ(float) translationZ property to be the difference between
  /// the x value passed in and the current \#getElevation() elevation property.
  ///@param z The visual z position of this view, in pixels.
  void setZ(double z) => jniAccessors.callMethodWithArgs(
      reference, _id_setZ, jni.JniType.voidType, [z]).check();

  static final _id_getElevation =
      jniAccessors.getMethodIDOf(_classRef, "getElevation", "()F");

  /// from: public float getElevation()
  ///
  /// The base elevation of this view relative to its parent, in pixels.
  ///@return The base depth position of the view, in pixels.
  double getElevation() => jniAccessors.callMethodWithArgs(
      reference, _id_getElevation, jni.JniType.floatType, []).float;

  static final _id_setElevation =
      jniAccessors.getMethodIDOf(_classRef, "setElevation", "(F)V");

  /// from: public void setElevation(float elevation)
  ///
  /// Sets the base elevation of this view, in pixels.
  ///@attr ref android.R.styleable\#View_elevation
  void setElevation(double elevation) => jniAccessors.callMethodWithArgs(
      reference, _id_setElevation, jni.JniType.voidType, [elevation]).check();

  static final _id_getTranslationX =
      jniAccessors.getMethodIDOf(_classRef, "getTranslationX", "()F");

  /// from: public float getTranslationX()
  ///
  /// The horizontal location of this view relative to its \#getLeft() left position.
  /// This position is post-layout, in addition to wherever the object's
  /// layout placed it.
  ///@return The horizontal position of this view relative to its left position, in pixels.
  double getTranslationX() => jniAccessors.callMethodWithArgs(
      reference, _id_getTranslationX, jni.JniType.floatType, []).float;

  static final _id_setTranslationX =
      jniAccessors.getMethodIDOf(_classRef, "setTranslationX", "(F)V");

  /// from: public void setTranslationX(float translationX)
  ///
  /// Sets the horizontal location of this view relative to its \#getLeft() left position.
  /// This effectively positions the object post-layout, in addition to wherever the object's
  /// layout placed it.
  ///@param translationX The horizontal position of this view relative to its left position,
  /// in pixels.
  ///@attr ref android.R.styleable\#View_translationX
  void setTranslationX(double translationX) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTranslationX,
      jni.JniType.voidType,
      [translationX]).check();

  static final _id_getTranslationY =
      jniAccessors.getMethodIDOf(_classRef, "getTranslationY", "()F");

  /// from: public float getTranslationY()
  ///
  /// The vertical location of this view relative to its \#getTop() top position.
  /// This position is post-layout, in addition to wherever the object's
  /// layout placed it.
  ///@return The vertical position of this view relative to its top position,
  /// in pixels.
  double getTranslationY() => jniAccessors.callMethodWithArgs(
      reference, _id_getTranslationY, jni.JniType.floatType, []).float;

  static final _id_setTranslationY =
      jniAccessors.getMethodIDOf(_classRef, "setTranslationY", "(F)V");

  /// from: public void setTranslationY(float translationY)
  ///
  /// Sets the vertical location of this view relative to its \#getTop() top position.
  /// This effectively positions the object post-layout, in addition to wherever the object's
  /// layout placed it.
  ///@param translationY The vertical position of this view relative to its top position,
  /// in pixels.
  ///@attr ref android.R.styleable\#View_translationY
  void setTranslationY(double translationY) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTranslationY,
      jni.JniType.voidType,
      [translationY]).check();

  static final _id_getTranslationZ =
      jniAccessors.getMethodIDOf(_classRef, "getTranslationZ", "()F");

  /// from: public float getTranslationZ()
  ///
  /// The depth location of this view relative to its \#getElevation() elevation.
  ///@return The depth of this view relative to its elevation.
  double getTranslationZ() => jniAccessors.callMethodWithArgs(
      reference, _id_getTranslationZ, jni.JniType.floatType, []).float;

  static final _id_setTranslationZ =
      jniAccessors.getMethodIDOf(_classRef, "setTranslationZ", "(F)V");

  /// from: public void setTranslationZ(float translationZ)
  ///
  /// Sets the depth location of this view relative to its \#getElevation() elevation.
  ///@attr ref android.R.styleable\#View_translationZ
  void setTranslationZ(double translationZ) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTranslationZ,
      jni.JniType.voidType,
      [translationZ]).check();

  static final _id_getStateListAnimator = jniAccessors.getMethodIDOf(_classRef,
      "getStateListAnimator", "()Landroid/animation/StateListAnimator;");

  /// from: public android.animation.StateListAnimator getStateListAnimator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current StateListAnimator if exists.
  ///@return StateListAnimator or null if it does not exists
  ///@see \#setStateListAnimator(android.animation.StateListAnimator)
  statelistanimator_.StateListAnimator getStateListAnimator() =>
      statelistanimator_.StateListAnimator.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getStateListAnimator,
              jni.JniType.objectType, []).object);

  static final _id_setStateListAnimator = jniAccessors.getMethodIDOf(_classRef,
      "setStateListAnimator", "(Landroid/animation/StateListAnimator;)V");

  /// from: public void setStateListAnimator(android.animation.StateListAnimator stateListAnimator)
  ///
  /// Attaches the provided StateListAnimator to this View.
  ///
  /// Any previously attached StateListAnimator will be detached.
  ///@param stateListAnimator The StateListAnimator to update the view
  ///@see android.animation.StateListAnimator
  void setStateListAnimator(
          statelistanimator_.StateListAnimator stateListAnimator) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStateListAnimator,
          jni.JniType.voidType, [stateListAnimator.reference]).check();

  static final _id_getClipToOutline =
      jniAccessors.getMethodIDOf(_classRef, "getClipToOutline", "()Z");

  /// from: public final boolean getClipToOutline()
  ///
  /// Returns whether the Outline should be used to clip the contents of the View.
  ///
  /// Note that this flag will only be respected if the View's Outline returns true from
  /// Outline\#canClip().
  ///@see \#setOutlineProvider(ViewOutlineProvider)
  ///@see \#setClipToOutline(boolean)
  bool getClipToOutline() => jniAccessors.callMethodWithArgs(
      reference, _id_getClipToOutline, jni.JniType.booleanType, []).boolean;

  static final _id_setClipToOutline =
      jniAccessors.getMethodIDOf(_classRef, "setClipToOutline", "(Z)V");

  /// from: public void setClipToOutline(boolean clipToOutline)
  ///
  /// Sets whether the View's Outline should be used to clip the contents of the View.
  ///
  /// Only a single non-rectangular clip can be applied on a View at any time.
  /// Circular clips from a ViewAnimationUtils\#createCircularReveal(View, int, int, float, float) circular reveal animation take priority over Outline clipping, and
  /// child Outline clipping takes priority over Outline clipping done by a
  /// parent.
  ///
  /// Note that this flag will only be respected if the View's Outline returns true from
  /// Outline\#canClip().
  ///@see \#setOutlineProvider(ViewOutlineProvider)
  ///@see \#getClipToOutline()
  void setClipToOutline(bool clipToOutline) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClipToOutline,
      jni.JniType.voidType,
      [clipToOutline]).check();

  static final _id_setOutlineProvider = jniAccessors.getMethodIDOf(
      _classRef, "setOutlineProvider", "(Landroid/view/ViewOutlineProvider;)V");

  /// from: public void setOutlineProvider(android.view.ViewOutlineProvider provider)
  ///
  /// Sets the ViewOutlineProvider of the view, which generates the Outline that defines
  /// the shape of the shadow it casts, and enables outline clipping.
  ///
  /// The default ViewOutlineProvider, ViewOutlineProvider\#BACKGROUND, queries the Outline
  /// from the View's background drawable, via Drawable\#getOutline(Outline). Changing the
  /// outline provider with this method allows this behavior to be overridden.
  ///
  /// If the ViewOutlineProvider is null, if querying it for an outline returns false,
  /// or if the produced Outline is Outline\#isEmpty(), shadows will not be cast.
  ///
  /// Only outlines that return true from Outline\#canClip() may be used for clipping.
  ///@see \#setClipToOutline(boolean)
  ///@see \#getClipToOutline()
  ///@see \#getOutlineProvider()
  void setOutlineProvider(viewoutlineprovider_.ViewOutlineProvider provider) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOutlineProvider,
          jni.JniType.voidType, [provider.reference]).check();

  static final _id_getOutlineProvider = jniAccessors.getMethodIDOf(
      _classRef, "getOutlineProvider", "()Landroid/view/ViewOutlineProvider;");

  /// from: public android.view.ViewOutlineProvider getOutlineProvider()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current ViewOutlineProvider of the view, which generates the Outline
  /// that defines the shape of the shadow it casts, and enables outline clipping.
  ///@see \#setOutlineProvider(ViewOutlineProvider)
  viewoutlineprovider_.ViewOutlineProvider getOutlineProvider() =>
      viewoutlineprovider_.ViewOutlineProvider.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getOutlineProvider,
              jni.JniType.objectType, []).object);

  static final _id_invalidateOutline =
      jniAccessors.getMethodIDOf(_classRef, "invalidateOutline", "()V");

  /// from: public void invalidateOutline()
  ///
  /// Called to rebuild this View's Outline from its ViewOutlineProvider outline provider
  ///@see \#setOutlineProvider(ViewOutlineProvider)
  void invalidateOutline() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidateOutline, jni.JniType.voidType, []).check();

  static final _id_setOutlineSpotShadowColor = jniAccessors.getMethodIDOf(
      _classRef, "setOutlineSpotShadowColor", "(I)V");

  /// from: public void setOutlineSpotShadowColor(int color)
  ///
  /// Sets the color of the spot shadow that is drawn when the view has a positive Z or
  /// elevation value.
  ///
  /// By default the shadow color is black. Generally, this color will be opaque so the intensity
  /// of the shadow is consistent between different views with different colors.
  ///
  /// The opacity of the final spot shadow is a function of the shadow caster height, the
  /// alpha channel of the outlineSpotShadowColor (typically opaque), and the
  /// android.R.attr\#spotShadowAlpha theme attribute.
  ///@attr ref android.R.styleable\#View_outlineSpotShadowColor
  ///@param color The color this View will cast for its elevation spot shadow.
  void setOutlineSpotShadowColor(int color) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOutlineSpotShadowColor,
      jni.JniType.voidType,
      [color]).check();

  static final _id_getOutlineSpotShadowColor =
      jniAccessors.getMethodIDOf(_classRef, "getOutlineSpotShadowColor", "()I");

  /// from: public int getOutlineSpotShadowColor()
  ///
  /// @return The shadow color set by \#setOutlineSpotShadowColor(int), or black if nothing
  /// was set
  int getOutlineSpotShadowColor() => jniAccessors.callMethodWithArgs(reference,
      _id_getOutlineSpotShadowColor, jni.JniType.intType, []).integer;

  static final _id_setOutlineAmbientShadowColor = jniAccessors.getMethodIDOf(
      _classRef, "setOutlineAmbientShadowColor", "(I)V");

  /// from: public void setOutlineAmbientShadowColor(int color)
  ///
  /// Sets the color of the ambient shadow that is drawn when the view has a positive Z or
  /// elevation value.
  ///
  /// By default the shadow color is black. Generally, this color will be opaque so the intensity
  /// of the shadow is consistent between different views with different colors.
  ///
  /// The opacity of the final ambient shadow is a function of the shadow caster height, the
  /// alpha channel of the outlineAmbientShadowColor (typically opaque), and the
  /// android.R.attr\#ambientShadowAlpha theme attribute.
  ///@attr ref android.R.styleable\#View_outlineAmbientShadowColor
  ///@param color The color this View will cast for its elevation shadow.
  void setOutlineAmbientShadowColor(int color) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOutlineAmbientShadowColor,
          jni.JniType.voidType,
          [color]).check();

  static final _id_getOutlineAmbientShadowColor = jniAccessors.getMethodIDOf(
      _classRef, "getOutlineAmbientShadowColor", "()I");

  /// from: public int getOutlineAmbientShadowColor()
  ///
  /// @return The shadow color set by \#setOutlineAmbientShadowColor(int), or black if
  /// nothing was set
  int getOutlineAmbientShadowColor() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getOutlineAmbientShadowColor,
      jni.JniType.intType, []).integer;

  static final _id_getHitRect = jniAccessors.getMethodIDOf(
      _classRef, "getHitRect", "(Landroid/graphics/Rect;)V");

  /// from: public void getHitRect(android.graphics.Rect outRect)
  ///
  /// Hit rectangle in parent's coordinates
  ///@param outRect The hit rectangle of the view.
  void getHitRect(rect_.Rect outRect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHitRect,
      jni.JniType.voidType,
      [outRect.reference]).check();

  static final _id_getFocusedRect = jniAccessors.getMethodIDOf(
      _classRef, "getFocusedRect", "(Landroid/graphics/Rect;)V");

  /// from: public void getFocusedRect(android.graphics.Rect r)
  ///
  /// When a view has focus and the user navigates away from it, the next view is searched for
  /// starting from the rectangle filled in by this method.
  ///
  /// By default, the rectangle is the \#getDrawingRect(android.graphics.Rect))
  /// of the view.  However, if your view maintains some idea of internal selection,
  /// such as a cursor, or a selected row or column, you should override this method and
  /// fill in a more specific rectangle.
  ///@param r The rectangle to fill in, in this view's coordinates.
  void getFocusedRect(rect_.Rect r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getFocusedRect,
      jni.JniType.voidType,
      [r.reference]).check();

  static final _id_getGlobalVisibleRect = jniAccessors.getMethodIDOf(
      _classRef,
      "getGlobalVisibleRect",
      "(Landroid/graphics/Rect;Landroid/graphics/Point;)Z");

  /// from: public boolean getGlobalVisibleRect(android.graphics.Rect r, android.graphics.Point globalOffset)
  ///
  /// If some part of this view is not clipped by any of its parents, then
  /// return that area in r in global (root) coordinates. To convert r to local
  /// coordinates (without taking possible View rotations into account), offset
  /// it by -globalOffset (e.g. r.offset(-globalOffset.x, -globalOffset.y)).
  /// If the view is completely clipped or translated out, return false.
  ///@param r If true is returned, r holds the global coordinates of the
  ///        visible portion of this view.
  ///@param globalOffset If true is returned, globalOffset holds the dx,dy
  ///        between this view and its root. globalOffet may be null.
  ///@return true if r is non-empty (i.e. part of the view is visible at the
  ///         root level.
  bool getGlobalVisibleRect(rect_.Rect r, point_.Point globalOffset) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getGlobalVisibleRect,
          jni.JniType.booleanType,
          [r.reference, globalOffset.reference]).boolean;

  static final _id_getGlobalVisibleRect1 = jniAccessors.getMethodIDOf(
      _classRef, "getGlobalVisibleRect", "(Landroid/graphics/Rect;)Z");

  /// from: public final boolean getGlobalVisibleRect(android.graphics.Rect r)
  bool getGlobalVisibleRect1(rect_.Rect r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getGlobalVisibleRect1,
      jni.JniType.booleanType,
      [r.reference]).boolean;

  static final _id_getLocalVisibleRect = jniAccessors.getMethodIDOf(
      _classRef, "getLocalVisibleRect", "(Landroid/graphics/Rect;)Z");

  /// from: public final boolean getLocalVisibleRect(android.graphics.Rect r)
  bool getLocalVisibleRect(rect_.Rect r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLocalVisibleRect,
      jni.JniType.booleanType,
      [r.reference]).boolean;

  static final _id_offsetTopAndBottom =
      jniAccessors.getMethodIDOf(_classRef, "offsetTopAndBottom", "(I)V");

  /// from: public void offsetTopAndBottom(int offset)
  ///
  /// Offset this view's vertical location by the specified number of pixels.
  ///@param offset the number of pixels to offset the view by
  void offsetTopAndBottom(int offset) => jniAccessors.callMethodWithArgs(
      reference,
      _id_offsetTopAndBottom,
      jni.JniType.voidType,
      [offset]).check();

  static final _id_offsetLeftAndRight =
      jniAccessors.getMethodIDOf(_classRef, "offsetLeftAndRight", "(I)V");

  /// from: public void offsetLeftAndRight(int offset)
  ///
  /// Offset this view's horizontal location by the specified amount of pixels.
  ///@param offset the number of pixels to offset the view by
  void offsetLeftAndRight(int offset) => jniAccessors.callMethodWithArgs(
      reference,
      _id_offsetLeftAndRight,
      jni.JniType.voidType,
      [offset]).check();

  static final _id_getLayoutParams = jniAccessors.getMethodIDOf(
      _classRef, "getLayoutParams", "()Landroid/view/ViewGroup\$LayoutParams;");

  /// from: public android.view.ViewGroup.LayoutParams getLayoutParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the LayoutParams associated with this view. All views should have
  /// layout parameters. These supply parameters to the <i>parent</i> of this
  /// view specifying how it should be arranged. There are many subclasses of
  /// ViewGroup.LayoutParams, and these correspond to the different subclasses
  /// of ViewGroup that are responsible for arranging their children.
  ///
  /// This method may return null if this View is not attached to a parent
  /// ViewGroup or \#setLayoutParams(android.view.ViewGroup.LayoutParams)
  /// was not invoked successfully. When a View is attached to a parent
  /// ViewGroup, this method must not return null.
  ///@return The LayoutParams associated with this view, or null if no
  ///         parameters have been set yet
  viewgroup_.ViewGroup_LayoutParams getLayoutParams() =>
      viewgroup_.ViewGroup_LayoutParams.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLayoutParams, jni.JniType.objectType, []).object);

  static final _id_setLayoutParams = jniAccessors.getMethodIDOf(_classRef,
      "setLayoutParams", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void setLayoutParams(android.view.ViewGroup.LayoutParams params)
  ///
  /// Set the layout parameters associated with this view. These supply
  /// parameters to the <i>parent</i> of this view specifying how it should be
  /// arranged. There are many subclasses of ViewGroup.LayoutParams, and these
  /// correspond to the different subclasses of ViewGroup that are responsible
  /// for arranging their children.
  ///@param params The layout parameters for this view, cannot be null
  void setLayoutParams(viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutParams,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_scrollTo =
      jniAccessors.getMethodIDOf(_classRef, "scrollTo", "(II)V");

  /// from: public void scrollTo(int x, int y)
  ///
  /// Set the scrolled position of your view. This will cause a call to
  /// \#onScrollChanged(int, int, int, int) and the view will be
  /// invalidated.
  ///@param x the x position to scroll to
  ///@param y the y position to scroll to
  void scrollTo(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_scrollTo, jni.JniType.voidType, [x, y]).check();

  static final _id_scrollBy =
      jniAccessors.getMethodIDOf(_classRef, "scrollBy", "(II)V");

  /// from: public void scrollBy(int x, int y)
  ///
  /// Move the scrolled position of your view. This will cause a call to
  /// \#onScrollChanged(int, int, int, int) and the view will be
  /// invalidated.
  ///@param x the amount of pixels to scroll by horizontally
  ///@param y the amount of pixels to scroll by vertically
  void scrollBy(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_scrollBy, jni.JniType.voidType, [x, y]).check();

  static final _id_awakenScrollBars =
      jniAccessors.getMethodIDOf(_classRef, "awakenScrollBars", "()Z");

  /// from: protected boolean awakenScrollBars()
  ///
  /// Trigger the scrollbars to draw. When invoked this method starts an
  /// animation to fade the scrollbars out after a default delay. If a subclass
  /// provides animated scrolling, the start delay should equal the duration
  /// of the scrolling animation.
  ///
  ///
  /// The animation starts only if at least one of the scrollbars is
  /// enabled, as specified by \#isHorizontalScrollBarEnabled() and
  /// \#isVerticalScrollBarEnabled(). When the animation is started,
  /// this method returns true, and false otherwise. If the animation is
  /// started, this method calls \#invalidate(); in that case the
  /// caller should not call \#invalidate().
  ///
  ///
  /// This method should be invoked every time a subclass directly updates
  /// the scroll parameters.
  ///
  ///
  /// This method is automatically invoked by \#scrollBy(int, int)
  /// and \#scrollTo(int, int).
  ///
  ///@return true if the animation is played, false otherwise
  ///@see \#awakenScrollBars(int)
  ///@see \#scrollBy(int, int)
  ///@see \#scrollTo(int, int)
  ///@see \#isHorizontalScrollBarEnabled()
  ///@see \#isVerticalScrollBarEnabled()
  ///@see \#setHorizontalScrollBarEnabled(boolean)
  ///@see \#setVerticalScrollBarEnabled(boolean)
  bool awakenScrollBars() => jniAccessors.callMethodWithArgs(
      reference, _id_awakenScrollBars, jni.JniType.booleanType, []).boolean;

  static final _id_awakenScrollBars1 =
      jniAccessors.getMethodIDOf(_classRef, "awakenScrollBars", "(I)Z");

  /// from: protected boolean awakenScrollBars(int startDelay)
  ///
  ///
  /// Trigger the scrollbars to draw. When invoked this method starts an
  /// animation to fade the scrollbars out after a fixed delay. If a subclass
  /// provides animated scrolling, the start delay should equal the duration of
  /// the scrolling animation.
  ///
  ///
  ///
  ///
  /// The animation starts only if at least one of the scrollbars is enabled,
  /// as specified by \#isHorizontalScrollBarEnabled() and
  /// \#isVerticalScrollBarEnabled(). When the animation is started,
  /// this method returns true, and false otherwise. If the animation is
  /// started, this method calls \#invalidate(); in that case the caller
  /// should not call \#invalidate().
  ///
  ///
  ///
  ///
  /// This method should be invoked every time a subclass directly updates the
  /// scroll parameters.
  ///
  ///
  ///@param startDelay the delay, in milliseconds, after which the animation
  ///        should start; when the delay is 0, the animation starts
  ///        immediately
  ///@return true if the animation is played, false otherwise
  ///@see \#scrollBy(int, int)
  ///@see \#scrollTo(int, int)
  ///@see \#isHorizontalScrollBarEnabled()
  ///@see \#isVerticalScrollBarEnabled()
  ///@see \#setHorizontalScrollBarEnabled(boolean)
  ///@see \#setVerticalScrollBarEnabled(boolean)
  bool awakenScrollBars1(int startDelay) => jniAccessors.callMethodWithArgs(
      reference,
      _id_awakenScrollBars1,
      jni.JniType.booleanType,
      [startDelay]).boolean;

  static final _id_awakenScrollBars2 =
      jniAccessors.getMethodIDOf(_classRef, "awakenScrollBars", "(IZ)Z");

  /// from: protected boolean awakenScrollBars(int startDelay, boolean invalidate)
  ///
  ///
  /// Trigger the scrollbars to draw. When invoked this method starts an
  /// animation to fade the scrollbars out after a fixed delay. If a subclass
  /// provides animated scrolling, the start delay should equal the duration of
  /// the scrolling animation.
  ///
  ///
  ///
  ///
  /// The animation starts only if at least one of the scrollbars is enabled,
  /// as specified by \#isHorizontalScrollBarEnabled() and
  /// \#isVerticalScrollBarEnabled(). When the animation is started,
  /// this method returns true, and false otherwise. If the animation is
  /// started, this method calls \#invalidate() if the invalidate parameter
  /// is set to true; in that case the caller
  /// should not call \#invalidate().
  ///
  ///
  ///
  ///
  /// This method should be invoked every time a subclass directly updates the
  /// scroll parameters.
  ///
  ///
  ///@param startDelay the delay, in milliseconds, after which the animation
  ///        should start; when the delay is 0, the animation starts
  ///        immediately
  ///@param invalidate Whether this method should call invalidate
  ///@return true if the animation is played, false otherwise
  ///@see \#scrollBy(int, int)
  ///@see \#scrollTo(int, int)
  ///@see \#isHorizontalScrollBarEnabled()
  ///@see \#isVerticalScrollBarEnabled()
  ///@see \#setHorizontalScrollBarEnabled(boolean)
  ///@see \#setVerticalScrollBarEnabled(boolean)
  bool awakenScrollBars2(int startDelay, bool invalidate) =>
      jniAccessors.callMethodWithArgs(reference, _id_awakenScrollBars2,
          jni.JniType.booleanType, [startDelay, invalidate]).boolean;

  static final _id_invalidate = jniAccessors.getMethodIDOf(
      _classRef, "invalidate", "(Landroid/graphics/Rect;)V");

  /// from: public void invalidate(android.graphics.Rect dirty)
  ///
  /// Mark the area defined by dirty as needing to be drawn. If the view is
  /// visible, \#onDraw(android.graphics.Canvas) will be called at some
  /// point in the future.
  ///
  /// This must be called from a UI thread. To call from a non-UI thread, call
  /// \#postInvalidate().
  ///
  /// __WARNING:__ In API 19 and below, this method may be destructive to
  /// {@code dirty}.
  ///@param dirty the rectangle representing the bounds of the dirty region
  ///@deprecated The switch to hardware accelerated rendering in API 14 reduced
  /// the importance of the dirty rectangle. In API 21 the given rectangle is
  /// ignored entirely in favor of an internally-calculated area instead.
  /// Because of this, clients are encouraged to just call \#invalidate().
  void invalidate(rect_.Rect dirty) => jniAccessors.callMethodWithArgs(
      reference,
      _id_invalidate,
      jni.JniType.voidType,
      [dirty.reference]).check();

  static final _id_invalidate1 =
      jniAccessors.getMethodIDOf(_classRef, "invalidate", "(IIII)V");

  /// from: public void invalidate(int l, int t, int r, int b)
  ///
  /// Mark the area defined by the rect (l,t,r,b) as needing to be drawn. The
  /// coordinates of the dirty rect are relative to the view. If the view is
  /// visible, \#onDraw(android.graphics.Canvas) will be called at some
  /// point in the future.
  ///
  /// This must be called from a UI thread. To call from a non-UI thread, call
  /// \#postInvalidate().
  ///@param l the left position of the dirty region
  ///@param t the top position of the dirty region
  ///@param r the right position of the dirty region
  ///@param b the bottom position of the dirty region
  ///@deprecated The switch to hardware accelerated rendering in API 14 reduced
  /// the importance of the dirty rectangle. In API 21 the given rectangle is
  /// ignored entirely in favor of an internally-calculated area instead.
  /// Because of this, clients are encouraged to just call \#invalidate().
  void invalidate1(int l, int t, int r, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidate1,
          jni.JniType.voidType, [l, t, r, b]).check();

  static final _id_invalidate2 =
      jniAccessors.getMethodIDOf(_classRef, "invalidate", "()V");

  /// from: public void invalidate()
  ///
  /// Invalidate the whole view. If the view is visible,
  /// \#onDraw(android.graphics.Canvas) will be called at some point in
  /// the future.
  ///
  /// This must be called from a UI thread. To call from a non-UI thread, call
  /// \#postInvalidate().
  void invalidate2() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidate2, jni.JniType.voidType, []).check();

  static final _id_isOpaque =
      jniAccessors.getMethodIDOf(_classRef, "isOpaque", "()Z");

  /// from: public boolean isOpaque()
  ///
  /// Indicates whether this View is opaque. An opaque View guarantees that it will
  /// draw all the pixels overlapping its bounds using a fully opaque color.
  ///
  /// Subclasses of View should override this method whenever possible to indicate
  /// whether an instance is opaque. Opaque Views are treated in a special way by
  /// the View hierarchy, possibly allowing it to perform optimizations during
  /// invalidate/draw passes.
  ///@return True if this View is guaranteed to be fully opaque, false otherwise.
  bool isOpaque() => jniAccessors.callMethodWithArgs(
      reference, _id_isOpaque, jni.JniType.booleanType, []).boolean;

  static final _id_getHandler = jniAccessors.getMethodIDOf(
      _classRef, "getHandler", "()Landroid/os/Handler;");

  /// from: public android.os.Handler getHandler()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return A handler associated with the thread running the View. This
  /// handler can be used to pump events in the UI events queue.
  handler_.Handler getHandler() =>
      handler_.Handler.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHandler, jni.JniType.objectType, []).object);

  static final _id_post =
      jniAccessors.getMethodIDOf(_classRef, "post", "(Ljava/lang/Runnable;)Z");

  /// from: public boolean post(java.lang.Runnable action)
  ///
  /// Causes the Runnable to be added to the message queue.
  /// The runnable will be run on the user interface thread.
  ///
  ///@param action The Runnable that will be executed.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  ///@see \#postDelayed
  ///@see \#removeCallbacks
  bool post(jni.JniObject action) => jniAccessors.callMethodWithArgs(
      reference, _id_post, jni.JniType.booleanType, [action.reference]).boolean;

  static final _id_postDelayed = jniAccessors.getMethodIDOf(
      _classRef, "postDelayed", "(Ljava/lang/Runnable;J)Z");

  /// from: public boolean postDelayed(java.lang.Runnable action, long delayMillis)
  ///
  /// Causes the Runnable to be added to the message queue, to be run
  /// after the specified amount of time elapses.
  /// The runnable will be run on the user interface thread.
  ///
  ///@param action The Runnable that will be executed.
  ///@param delayMillis The delay (in milliseconds) until the Runnable
  ///        will be executed.
  ///@return true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed --
  ///         if the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  ///@see \#post
  ///@see \#removeCallbacks
  bool postDelayed(jni.JniObject action, int delayMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_postDelayed,
          jni.JniType.booleanType, [action.reference, delayMillis]).boolean;

  static final _id_postOnAnimation = jniAccessors.getMethodIDOf(
      _classRef, "postOnAnimation", "(Ljava/lang/Runnable;)V");

  /// from: public void postOnAnimation(java.lang.Runnable action)
  ///
  /// Causes the Runnable to execute on the next animation time step.
  /// The runnable will be run on the user interface thread.
  ///
  ///@param action The Runnable that will be executed.
  ///@see \#postOnAnimationDelayed
  ///@see \#removeCallbacks
  void postOnAnimation(jni.JniObject action) => jniAccessors.callMethodWithArgs(
      reference,
      _id_postOnAnimation,
      jni.JniType.voidType,
      [action.reference]).check();

  static final _id_postOnAnimationDelayed = jniAccessors.getMethodIDOf(
      _classRef, "postOnAnimationDelayed", "(Ljava/lang/Runnable;J)V");

  /// from: public void postOnAnimationDelayed(java.lang.Runnable action, long delayMillis)
  ///
  /// Causes the Runnable to execute on the next animation time step,
  /// after the specified amount of time elapses.
  /// The runnable will be run on the user interface thread.
  ///
  ///@param action The Runnable that will be executed.
  ///@param delayMillis The delay (in milliseconds) until the Runnable
  ///        will be executed.
  ///@see \#postOnAnimation
  ///@see \#removeCallbacks
  void postOnAnimationDelayed(jni.JniObject action, int delayMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_postOnAnimationDelayed,
          jni.JniType.voidType, [action.reference, delayMillis]).check();

  static final _id_removeCallbacks = jniAccessors.getMethodIDOf(
      _classRef, "removeCallbacks", "(Ljava/lang/Runnable;)Z");

  /// from: public boolean removeCallbacks(java.lang.Runnable action)
  ///
  /// Removes the specified Runnable from the message queue.
  ///
  ///@param action The Runnable to remove from the message handling queue
  ///@return true if this view could ask the Handler to remove the Runnable,
  ///         false otherwise. When the returned value is true, the Runnable
  ///         may or may not have been actually removed from the message queue
  ///         (for instance, if the Runnable was not in the queue already.)
  ///@see \#post
  ///@see \#postDelayed
  ///@see \#postOnAnimation
  ///@see \#postOnAnimationDelayed
  bool removeCallbacks(jni.JniObject action) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeCallbacks,
      jni.JniType.booleanType,
      [action.reference]).boolean;

  static final _id_postInvalidate =
      jniAccessors.getMethodIDOf(_classRef, "postInvalidate", "()V");

  /// from: public void postInvalidate()
  ///
  /// Cause an invalidate to happen on a subsequent cycle through the event loop.
  /// Use this to invalidate the View from a non-UI thread.
  ///
  ///
  /// This method can be invoked from outside of the UI thread
  /// only when this View is attached to a window.
  ///
  ///@see \#invalidate()
  ///@see \#postInvalidateDelayed(long)
  void postInvalidate() => jniAccessors.callMethodWithArgs(
      reference, _id_postInvalidate, jni.JniType.voidType, []).check();

  static final _id_postInvalidate1 =
      jniAccessors.getMethodIDOf(_classRef, "postInvalidate", "(IIII)V");

  /// from: public void postInvalidate(int left, int top, int right, int bottom)
  ///
  /// Cause an invalidate of the specified area to happen on a subsequent cycle
  /// through the event loop. Use this to invalidate the View from a non-UI thread.
  ///
  ///
  /// This method can be invoked from outside of the UI thread
  /// only when this View is attached to a window.
  ///
  ///@param left The left coordinate of the rectangle to invalidate.
  ///@param top The top coordinate of the rectangle to invalidate.
  ///@param right The right coordinate of the rectangle to invalidate.
  ///@param bottom The bottom coordinate of the rectangle to invalidate.
  ///@see \#invalidate(int, int, int, int)
  ///@see \#invalidate(Rect)
  ///@see \#postInvalidateDelayed(long, int, int, int, int)
  void postInvalidate1(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_postInvalidate1,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_postInvalidateDelayed =
      jniAccessors.getMethodIDOf(_classRef, "postInvalidateDelayed", "(J)V");

  /// from: public void postInvalidateDelayed(long delayMilliseconds)
  ///
  /// Cause an invalidate to happen on a subsequent cycle through the event
  /// loop. Waits for the specified amount of time.
  ///
  ///
  /// This method can be invoked from outside of the UI thread
  /// only when this View is attached to a window.
  ///
  ///@param delayMilliseconds the duration in milliseconds to delay the
  ///         invalidation by
  ///@see \#invalidate()
  ///@see \#postInvalidate()
  void postInvalidateDelayed(int delayMilliseconds) =>
      jniAccessors.callMethodWithArgs(reference, _id_postInvalidateDelayed,
          jni.JniType.voidType, [delayMilliseconds]).check();

  static final _id_postInvalidateDelayed1 = jniAccessors.getMethodIDOf(
      _classRef, "postInvalidateDelayed", "(JIIII)V");

  /// from: public void postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom)
  ///
  /// Cause an invalidate of the specified area to happen on a subsequent cycle
  /// through the event loop. Waits for the specified amount of time.
  ///
  ///
  /// This method can be invoked from outside of the UI thread
  /// only when this View is attached to a window.
  ///
  ///@param delayMilliseconds the duration in milliseconds to delay the
  ///         invalidation by
  ///@param left The left coordinate of the rectangle to invalidate.
  ///@param top The top coordinate of the rectangle to invalidate.
  ///@param right The right coordinate of the rectangle to invalidate.
  ///@param bottom The bottom coordinate of the rectangle to invalidate.
  ///@see \#invalidate(int, int, int, int)
  ///@see \#invalidate(Rect)
  ///@see \#postInvalidate(int, int, int, int)
  void postInvalidateDelayed1(
          int delayMilliseconds, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_postInvalidateDelayed1,
          jni.JniType.voidType,
          [delayMilliseconds, left, top, right, bottom]).check();

  static final _id_postInvalidateOnAnimation =
      jniAccessors.getMethodIDOf(_classRef, "postInvalidateOnAnimation", "()V");

  /// from: public void postInvalidateOnAnimation()
  ///
  /// Cause an invalidate to happen on the next animation time step, typically the
  /// next display frame.
  ///
  ///
  /// This method can be invoked from outside of the UI thread
  /// only when this View is attached to a window.
  ///
  ///@see \#invalidate()
  void postInvalidateOnAnimation() => jniAccessors.callMethodWithArgs(reference,
      _id_postInvalidateOnAnimation, jni.JniType.voidType, []).check();

  static final _id_postInvalidateOnAnimation1 = jniAccessors.getMethodIDOf(
      _classRef, "postInvalidateOnAnimation", "(IIII)V");

  /// from: public void postInvalidateOnAnimation(int left, int top, int right, int bottom)
  ///
  /// Cause an invalidate of the specified area to happen on the next animation
  /// time step, typically the next display frame.
  ///
  ///
  /// This method can be invoked from outside of the UI thread
  /// only when this View is attached to a window.
  ///
  ///@param left The left coordinate of the rectangle to invalidate.
  ///@param top The top coordinate of the rectangle to invalidate.
  ///@param right The right coordinate of the rectangle to invalidate.
  ///@param bottom The bottom coordinate of the rectangle to invalidate.
  ///@see \#invalidate(int, int, int, int)
  ///@see \#invalidate(Rect)
  void postInvalidateOnAnimation1(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_postInvalidateOnAnimation1,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_computeScroll =
      jniAccessors.getMethodIDOf(_classRef, "computeScroll", "()V");

  /// from: public void computeScroll()
  ///
  /// Called by a parent to request that a child update its values for mScrollX
  /// and mScrollY if necessary. This will typically be done if the child is
  /// animating a scroll using a android.widget.Scroller Scroller
  /// object.
  void computeScroll() => jniAccessors.callMethodWithArgs(
      reference, _id_computeScroll, jni.JniType.voidType, []).check();

  static final _id_isHorizontalFadingEdgeEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isHorizontalFadingEdgeEnabled", "()Z");

  /// from: public boolean isHorizontalFadingEdgeEnabled()
  ///
  /// Indicate whether the horizontal edges are faded when the view is
  /// scrolled horizontally.
  ///
  ///@return true if the horizontal edges should are faded on scroll, false
  ///         otherwise
  ///@see \#setHorizontalFadingEdgeEnabled(boolean)
  ///@attr ref android.R.styleable\#View_requiresFadingEdge
  bool isHorizontalFadingEdgeEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isHorizontalFadingEdgeEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setHorizontalFadingEdgeEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setHorizontalFadingEdgeEnabled", "(Z)V");

  /// from: public void setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled)
  ///
  /// Define whether the horizontal edges should be faded when this view
  /// is scrolled horizontally.
  ///
  ///@param horizontalFadingEdgeEnabled true if the horizontal edges should
  ///                                    be faded when the view is scrolled
  ///                                    horizontally
  ///@see \#isHorizontalFadingEdgeEnabled()
  ///@attr ref android.R.styleable\#View_requiresFadingEdge
  void setHorizontalFadingEdgeEnabled(bool horizontalFadingEdgeEnabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setHorizontalFadingEdgeEnabled,
          jni.JniType.voidType,
          [horizontalFadingEdgeEnabled]).check();

  static final _id_isVerticalFadingEdgeEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isVerticalFadingEdgeEnabled", "()Z");

  /// from: public boolean isVerticalFadingEdgeEnabled()
  ///
  /// Indicate whether the vertical edges are faded when the view is
  /// scrolled horizontally.
  ///
  ///@return true if the vertical edges should are faded on scroll, false
  ///         otherwise
  ///@see \#setVerticalFadingEdgeEnabled(boolean)
  ///@attr ref android.R.styleable\#View_requiresFadingEdge
  bool isVerticalFadingEdgeEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isVerticalFadingEdgeEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setVerticalFadingEdgeEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setVerticalFadingEdgeEnabled", "(Z)V");

  /// from: public void setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled)
  ///
  /// Define whether the vertical edges should be faded when this view
  /// is scrolled vertically.
  ///
  ///@param verticalFadingEdgeEnabled true if the vertical edges should
  ///                                  be faded when the view is scrolled
  ///                                  vertically
  ///@see \#isVerticalFadingEdgeEnabled()
  ///@attr ref android.R.styleable\#View_requiresFadingEdge
  void setVerticalFadingEdgeEnabled(bool verticalFadingEdgeEnabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVerticalFadingEdgeEnabled,
          jni.JniType.voidType,
          [verticalFadingEdgeEnabled]).check();

  static final _id_getTopFadingEdgeStrength =
      jniAccessors.getMethodIDOf(_classRef, "getTopFadingEdgeStrength", "()F");

  /// from: protected float getTopFadingEdgeStrength()
  ///
  /// Returns the strength, or intensity, of the top faded edge. The strength is
  /// a value between 0.0 (no fade) and 1.0 (full fade). The default implementation
  /// returns 0.0 or 1.0 but no value in between.
  ///
  /// Subclasses should override this method to provide a smoother fade transition
  /// when scrolling occurs.
  ///@return the intensity of the top fade as a float between 0.0f and 1.0f
  double getTopFadingEdgeStrength() => jniAccessors.callMethodWithArgs(
      reference, _id_getTopFadingEdgeStrength, jni.JniType.floatType, []).float;

  static final _id_getBottomFadingEdgeStrength = jniAccessors.getMethodIDOf(
      _classRef, "getBottomFadingEdgeStrength", "()F");

  /// from: protected float getBottomFadingEdgeStrength()
  ///
  /// Returns the strength, or intensity, of the bottom faded edge. The strength is
  /// a value between 0.0 (no fade) and 1.0 (full fade). The default implementation
  /// returns 0.0 or 1.0 but no value in between.
  ///
  /// Subclasses should override this method to provide a smoother fade transition
  /// when scrolling occurs.
  ///@return the intensity of the bottom fade as a float between 0.0f and 1.0f
  double getBottomFadingEdgeStrength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getBottomFadingEdgeStrength,
      jni.JniType.floatType, []).float;

  static final _id_getLeftFadingEdgeStrength =
      jniAccessors.getMethodIDOf(_classRef, "getLeftFadingEdgeStrength", "()F");

  /// from: protected float getLeftFadingEdgeStrength()
  ///
  /// Returns the strength, or intensity, of the left faded edge. The strength is
  /// a value between 0.0 (no fade) and 1.0 (full fade). The default implementation
  /// returns 0.0 or 1.0 but no value in between.
  ///
  /// Subclasses should override this method to provide a smoother fade transition
  /// when scrolling occurs.
  ///@return the intensity of the left fade as a float between 0.0f and 1.0f
  double getLeftFadingEdgeStrength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLeftFadingEdgeStrength,
      jni.JniType.floatType, []).float;

  static final _id_getRightFadingEdgeStrength = jniAccessors.getMethodIDOf(
      _classRef, "getRightFadingEdgeStrength", "()F");

  /// from: protected float getRightFadingEdgeStrength()
  ///
  /// Returns the strength, or intensity, of the right faded edge. The strength is
  /// a value between 0.0 (no fade) and 1.0 (full fade). The default implementation
  /// returns 0.0 or 1.0 but no value in between.
  ///
  /// Subclasses should override this method to provide a smoother fade transition
  /// when scrolling occurs.
  ///@return the intensity of the right fade as a float between 0.0f and 1.0f
  double getRightFadingEdgeStrength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getRightFadingEdgeStrength,
      jni.JniType.floatType, []).float;

  static final _id_isHorizontalScrollBarEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isHorizontalScrollBarEnabled", "()Z");

  /// from: public boolean isHorizontalScrollBarEnabled()
  ///
  /// Indicate whether the horizontal scrollbar should be drawn or not. The
  /// scrollbar is not drawn by default.
  ///
  ///@return true if the horizontal scrollbar should be painted, false
  ///         otherwise
  ///@see \#setHorizontalScrollBarEnabled(boolean)
  bool isHorizontalScrollBarEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isHorizontalScrollBarEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setHorizontalScrollBarEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setHorizontalScrollBarEnabled", "(Z)V");

  /// from: public void setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled)
  ///
  /// Define whether the horizontal scrollbar should be drawn or not. The
  /// scrollbar is not drawn by default.
  ///
  ///@param horizontalScrollBarEnabled true if the horizontal scrollbar should
  ///                                   be painted
  ///@see \#isHorizontalScrollBarEnabled()
  void setHorizontalScrollBarEnabled(bool horizontalScrollBarEnabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setHorizontalScrollBarEnabled,
          jni.JniType.voidType,
          [horizontalScrollBarEnabled]).check();

  static final _id_isVerticalScrollBarEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isVerticalScrollBarEnabled", "()Z");

  /// from: public boolean isVerticalScrollBarEnabled()
  ///
  /// Indicate whether the vertical scrollbar should be drawn or not. The
  /// scrollbar is not drawn by default.
  ///
  ///@return true if the vertical scrollbar should be painted, false
  ///         otherwise
  ///@see \#setVerticalScrollBarEnabled(boolean)
  bool isVerticalScrollBarEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isVerticalScrollBarEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setVerticalScrollBarEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setVerticalScrollBarEnabled", "(Z)V");

  /// from: public void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled)
  ///
  /// Define whether the vertical scrollbar should be drawn or not. The
  /// scrollbar is not drawn by default.
  ///
  ///@param verticalScrollBarEnabled true if the vertical scrollbar should
  ///                                 be painted
  ///@see \#isVerticalScrollBarEnabled()
  void setVerticalScrollBarEnabled(bool verticalScrollBarEnabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVerticalScrollBarEnabled,
          jni.JniType.voidType,
          [verticalScrollBarEnabled]).check();

  static final _id_setScrollbarFadingEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setScrollbarFadingEnabled", "(Z)V");

  /// from: public void setScrollbarFadingEnabled(boolean fadeScrollbars)
  ///
  /// Define whether scrollbars will fade when the view is not scrolling.
  ///@param fadeScrollbars whether to enable fading
  ///@attr ref android.R.styleable\#View_fadeScrollbars
  void setScrollbarFadingEnabled(bool fadeScrollbars) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScrollbarFadingEnabled,
          jni.JniType.voidType, [fadeScrollbars]).check();

  static final _id_isScrollbarFadingEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isScrollbarFadingEnabled", "()Z");

  /// from: public boolean isScrollbarFadingEnabled()
  ///
  /// Returns true if scrollbars will fade when this view is not scrolling
  ///@return true if scrollbar fading is enabled
  ///@attr ref android.R.styleable\#View_fadeScrollbars
  bool isScrollbarFadingEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isScrollbarFadingEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getScrollBarDefaultDelayBeforeFade = jniAccessors
      .getMethodIDOf(_classRef, "getScrollBarDefaultDelayBeforeFade", "()I");

  /// from: public int getScrollBarDefaultDelayBeforeFade()
  ///
  /// Returns the delay before scrollbars fade.
  ///@return the delay before scrollbars fade
  ///@attr ref android.R.styleable\#View_scrollbarDefaultDelayBeforeFade
  int getScrollBarDefaultDelayBeforeFade() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScrollBarDefaultDelayBeforeFade,
      jni.JniType.intType, []).integer;

  static final _id_setScrollBarDefaultDelayBeforeFade = jniAccessors
      .getMethodIDOf(_classRef, "setScrollBarDefaultDelayBeforeFade", "(I)V");

  /// from: public void setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade)
  ///
  /// Define the delay before scrollbars fade.
  ///@param scrollBarDefaultDelayBeforeFade - the delay before scrollbars fade
  ///@attr ref android.R.styleable\#View_scrollbarDefaultDelayBeforeFade
  void setScrollBarDefaultDelayBeforeFade(
          int scrollBarDefaultDelayBeforeFade) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setScrollBarDefaultDelayBeforeFade,
          jni.JniType.voidType,
          [scrollBarDefaultDelayBeforeFade]).check();

  static final _id_getScrollBarFadeDuration =
      jniAccessors.getMethodIDOf(_classRef, "getScrollBarFadeDuration", "()I");

  /// from: public int getScrollBarFadeDuration()
  ///
  /// Returns the scrollbar fade duration.
  ///@return the scrollbar fade duration, in milliseconds
  ///@attr ref android.R.styleable\#View_scrollbarFadeDuration
  int getScrollBarFadeDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getScrollBarFadeDuration, jni.JniType.intType, []).integer;

  static final _id_setScrollBarFadeDuration =
      jniAccessors.getMethodIDOf(_classRef, "setScrollBarFadeDuration", "(I)V");

  /// from: public void setScrollBarFadeDuration(int scrollBarFadeDuration)
  ///
  /// Define the scrollbar fade duration.
  ///@param scrollBarFadeDuration - the scrollbar fade duration, in milliseconds
  ///@attr ref android.R.styleable\#View_scrollbarFadeDuration
  void setScrollBarFadeDuration(int scrollBarFadeDuration) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScrollBarFadeDuration,
          jni.JniType.voidType, [scrollBarFadeDuration]).check();

  static final _id_getScrollBarSize =
      jniAccessors.getMethodIDOf(_classRef, "getScrollBarSize", "()I");

  /// from: public int getScrollBarSize()
  ///
  /// Returns the scrollbar size.
  ///@return the scrollbar size
  ///@attr ref android.R.styleable\#View_scrollbarSize
  int getScrollBarSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getScrollBarSize, jni.JniType.intType, []).integer;

  static final _id_setScrollBarSize =
      jniAccessors.getMethodIDOf(_classRef, "setScrollBarSize", "(I)V");

  /// from: public void setScrollBarSize(int scrollBarSize)
  ///
  /// Define the scrollbar size.
  ///@param scrollBarSize - the scrollbar size
  ///@attr ref android.R.styleable\#View_scrollbarSize
  void setScrollBarSize(int scrollBarSize) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setScrollBarSize,
      jni.JniType.voidType,
      [scrollBarSize]).check();

  static final _id_setScrollBarStyle =
      jniAccessors.getMethodIDOf(_classRef, "setScrollBarStyle", "(I)V");

  /// from: public void setScrollBarStyle(int style)
  ///
  /// Specify the style of the scrollbars. The scrollbars can be overlaid or
  /// inset. When inset, they add to the padding of the view. And the scrollbars
  /// can be drawn inside the padding area or on the edge of the view. For example,
  /// if a view has a background drawable and you want to draw the scrollbars
  /// inside the padding specified by the drawable, you can use
  /// SCROLLBARS_INSIDE_OVERLAY or SCROLLBARS_INSIDE_INSET. If you want them to
  /// appear at the edge of the view, ignoring the padding, then you can use
  /// SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET.
  ///
  ///@param style the style of the scrollbars. Should be one of
  /// SCROLLBARS_INSIDE_OVERLAY, SCROLLBARS_INSIDE_INSET,
  /// SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET.
  /// Value is android.view.View\#SCROLLBARS_INSIDE_OVERLAY, android.view.View\#SCROLLBARS_INSIDE_INSET, android.view.View\#SCROLLBARS_OUTSIDE_OVERLAY, or android.view.View\#SCROLLBARS_OUTSIDE_INSET
  ///@see \#SCROLLBARS_INSIDE_OVERLAY
  ///@see \#SCROLLBARS_INSIDE_INSET
  ///@see \#SCROLLBARS_OUTSIDE_OVERLAY
  ///@see \#SCROLLBARS_OUTSIDE_INSET
  ///@attr ref android.R.styleable\#View_scrollbarStyle
  void setScrollBarStyle(int style) => jniAccessors.callMethodWithArgs(
      reference, _id_setScrollBarStyle, jni.JniType.voidType, [style]).check();

  static final _id_getScrollBarStyle =
      jniAccessors.getMethodIDOf(_classRef, "getScrollBarStyle", "()I");

  /// from: public int getScrollBarStyle()
  ///
  /// Returns the current scrollbar style.
  ///
  ///@return the current scrollbar style
  /// Value is android.view.View\#SCROLLBARS_INSIDE_OVERLAY, android.view.View\#SCROLLBARS_INSIDE_INSET, android.view.View\#SCROLLBARS_OUTSIDE_OVERLAY, or android.view.View\#SCROLLBARS_OUTSIDE_INSET
  ///@see \#SCROLLBARS_INSIDE_OVERLAY
  ///@see \#SCROLLBARS_INSIDE_INSET
  ///@see \#SCROLLBARS_OUTSIDE_OVERLAY
  ///@see \#SCROLLBARS_OUTSIDE_INSET
  ///@attr ref android.R.styleable\#View_scrollbarStyle
  int getScrollBarStyle() => jniAccessors.callMethodWithArgs(
      reference, _id_getScrollBarStyle, jni.JniType.intType, []).integer;

  static final _id_computeHorizontalScrollRange = jniAccessors.getMethodIDOf(
      _classRef, "computeHorizontalScrollRange", "()I");

  /// from: protected int computeHorizontalScrollRange()
  ///
  /// Compute the horizontal range that the horizontal scrollbar
  /// represents.
  ///
  ///
  /// The range is expressed in arbitrary units that must be the same as the
  /// units used by \#computeHorizontalScrollExtent() and
  /// \#computeHorizontalScrollOffset().
  ///
  ///
  /// The default range is the drawing width of this view.
  ///
  ///@return the total horizontal range represented by the horizontal
  ///         scrollbar
  ///@see \#computeHorizontalScrollExtent()
  ///@see \#computeHorizontalScrollOffset()
  ///@see android.widget.ScrollBarDrawable
  int computeHorizontalScrollRange() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeHorizontalScrollRange,
      jni.JniType.intType, []).integer;

  static final _id_computeHorizontalScrollOffset = jniAccessors.getMethodIDOf(
      _classRef, "computeHorizontalScrollOffset", "()I");

  /// from: protected int computeHorizontalScrollOffset()
  ///
  /// Compute the horizontal offset of the horizontal scrollbar's thumb
  /// within the horizontal range. This value is used to compute the position
  /// of the thumb within the scrollbar's track.
  ///
  ///
  /// The range is expressed in arbitrary units that must be the same as the
  /// units used by \#computeHorizontalScrollRange() and
  /// \#computeHorizontalScrollExtent().
  ///
  ///
  /// The default offset is the scroll offset of this view.
  ///
  ///@return the horizontal offset of the scrollbar's thumb
  ///@see \#computeHorizontalScrollRange()
  ///@see \#computeHorizontalScrollExtent()
  ///@see android.widget.ScrollBarDrawable
  int computeHorizontalScrollOffset() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeHorizontalScrollOffset,
      jni.JniType.intType, []).integer;

  static final _id_computeHorizontalScrollExtent = jniAccessors.getMethodIDOf(
      _classRef, "computeHorizontalScrollExtent", "()I");

  /// from: protected int computeHorizontalScrollExtent()
  ///
  /// Compute the horizontal extent of the horizontal scrollbar's thumb
  /// within the horizontal range. This value is used to compute the length
  /// of the thumb within the scrollbar's track.
  ///
  ///
  /// The range is expressed in arbitrary units that must be the same as the
  /// units used by \#computeHorizontalScrollRange() and
  /// \#computeHorizontalScrollOffset().
  ///
  ///
  /// The default extent is the drawing width of this view.
  ///
  ///@return the horizontal extent of the scrollbar's thumb
  ///@see \#computeHorizontalScrollRange()
  ///@see \#computeHorizontalScrollOffset()
  ///@see android.widget.ScrollBarDrawable
  int computeHorizontalScrollExtent() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeHorizontalScrollExtent,
      jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollRange = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollRange", "()I");

  /// from: protected int computeVerticalScrollRange()
  ///
  /// Compute the vertical range that the vertical scrollbar represents.
  ///
  ///
  /// The range is expressed in arbitrary units that must be the same as the
  /// units used by \#computeVerticalScrollExtent() and
  /// \#computeVerticalScrollOffset().
  ///
  ///@return the total vertical range represented by the vertical scrollbar
  ///
  /// The default range is the drawing height of this view.
  ///
  ///@see \#computeVerticalScrollExtent()
  ///@see \#computeVerticalScrollOffset()
  ///@see android.widget.ScrollBarDrawable
  int computeVerticalScrollRange() => jniAccessors.callMethodWithArgs(reference,
      _id_computeVerticalScrollRange, jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollOffset = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollOffset", "()I");

  /// from: protected int computeVerticalScrollOffset()
  ///
  /// Compute the vertical offset of the vertical scrollbar's thumb
  /// within the horizontal range. This value is used to compute the position
  /// of the thumb within the scrollbar's track.
  ///
  ///
  /// The range is expressed in arbitrary units that must be the same as the
  /// units used by \#computeVerticalScrollRange() and
  /// \#computeVerticalScrollExtent().
  ///
  ///
  /// The default offset is the scroll offset of this view.
  ///
  ///@return the vertical offset of the scrollbar's thumb
  ///@see \#computeVerticalScrollRange()
  ///@see \#computeVerticalScrollExtent()
  ///@see android.widget.ScrollBarDrawable
  int computeVerticalScrollOffset() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollOffset,
      jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollExtent = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollExtent", "()I");

  /// from: protected int computeVerticalScrollExtent()
  ///
  /// Compute the vertical extent of the vertical scrollbar's thumb
  /// within the vertical range. This value is used to compute the length
  /// of the thumb within the scrollbar's track.
  ///
  ///
  /// The range is expressed in arbitrary units that must be the same as the
  /// units used by \#computeVerticalScrollRange() and
  /// \#computeVerticalScrollOffset().
  ///
  ///
  /// The default extent is the drawing height of this view.
  ///
  ///@return the vertical extent of the scrollbar's thumb
  ///@see \#computeVerticalScrollRange()
  ///@see \#computeVerticalScrollOffset()
  ///@see android.widget.ScrollBarDrawable
  int computeVerticalScrollExtent() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollExtent,
      jni.JniType.intType, []).integer;

  static final _id_canScrollHorizontally =
      jniAccessors.getMethodIDOf(_classRef, "canScrollHorizontally", "(I)Z");

  /// from: public boolean canScrollHorizontally(int direction)
  ///
  /// Check if this view can be scrolled horizontally in a certain direction.
  ///@param direction Negative to check scrolling left, positive to check scrolling right.
  ///@return true if this view can be scrolled in the specified direction, false otherwise.
  bool canScrollHorizontally(int direction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_canScrollHorizontally,
      jni.JniType.booleanType,
      [direction]).boolean;

  static final _id_canScrollVertically =
      jniAccessors.getMethodIDOf(_classRef, "canScrollVertically", "(I)Z");

  /// from: public boolean canScrollVertically(int direction)
  ///
  /// Check if this view can be scrolled vertically in a certain direction.
  ///@param direction Negative to check scrolling up, positive to check scrolling down.
  ///@return true if this view can be scrolled in the specified direction, false otherwise.
  bool canScrollVertically(int direction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_canScrollVertically,
      jni.JniType.booleanType,
      [direction]).boolean;

  static final _id_onDrawScrollBars = jniAccessors.getMethodIDOf(
      _classRef, "onDrawScrollBars", "(Landroid/graphics/Canvas;)V");

  /// from: protected final void onDrawScrollBars(android.graphics.Canvas canvas)
  ///
  /// Request the drawing of the horizontal and the vertical scrollbar. The
  /// scrollbars are painted only if they have been awakened first.
  ///
  ///@param canvas the canvas on which to draw the scrollbars
  ///@see \#awakenScrollBars(int)
  void onDrawScrollBars(canvas_.Canvas canvas) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDrawScrollBars,
          jni.JniType.voidType, [canvas.reference]).check();

  static final _id_onDraw = jniAccessors.getMethodIDOf(
      _classRef, "onDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  ///
  /// Implement this to do your drawing.
  ///@param canvas the canvas on which the background will be drawn
  void onDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_onDraw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  ///
  /// This is called when the view is attached to a window.  At this point it
  /// has a Surface and will start drawing.  Note that this function is
  /// guaranteed to be called before \#onDraw(android.graphics.Canvas),
  /// however it may be called any time before the first onDraw -- including
  /// before or after \#onMeasure(int, int).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onDetachedFromWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onScreenStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "onScreenStateChanged", "(I)V");

  /// from: public void onScreenStateChanged(int screenState)
  ///
  /// This method is called whenever the state of the screen this view is
  /// attached to changes. A state change will usually occurs when the screen
  /// turns on or off (whether it happens automatically or the user does it
  /// manually.)
  ///@param screenState The new state of the screen. Can be either
  ///                    \#SCREEN_STATE_ON or \#SCREEN_STATE_OFF
  void onScreenStateChanged(int screenState) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onScreenStateChanged,
      jni.JniType.voidType,
      [screenState]).check();

  static final _id_onRtlPropertiesChanged =
      jniAccessors.getMethodIDOf(_classRef, "onRtlPropertiesChanged", "(I)V");

  /// from: public void onRtlPropertiesChanged(int layoutDirection)
  ///
  /// Called when any RTL property (layout direction or text direction or text alignment) has
  /// been changed.
  ///
  /// Subclasses need to override this method to take care of cached information that depends on the
  /// resolved layout direction, or to inform child views that inherit their layout direction.
  ///
  /// The default implementation does nothing.
  ///@param layoutDirection the direction of the layout
  ///
  /// Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  ///@see \#LAYOUT_DIRECTION_LTR
  ///@see \#LAYOUT_DIRECTION_RTL
  void onRtlPropertiesChanged(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRtlPropertiesChanged,
          jni.JniType.voidType, [layoutDirection]).check();

  static final _id_canResolveLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "canResolveLayoutDirection", "()Z");

  /// from: public boolean canResolveLayoutDirection()
  ///
  /// Check if layout direction resolution can be done.
  ///@return true if layout direction resolution can be done otherwise return false.
  bool canResolveLayoutDirection() => jniAccessors.callMethodWithArgs(reference,
      _id_canResolveLayoutDirection, jni.JniType.booleanType, []).boolean;

  static final _id_isLayoutDirectionResolved =
      jniAccessors.getMethodIDOf(_classRef, "isLayoutDirectionResolved", "()Z");

  /// from: public boolean isLayoutDirectionResolved()
  ///
  /// @return true if layout direction has been resolved.
  bool isLayoutDirectionResolved() => jniAccessors.callMethodWithArgs(reference,
      _id_isLayoutDirectionResolved, jni.JniType.booleanType, []).boolean;

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  ///
  /// This is called when the view is detached from a window.  At this point it
  /// no longer has a surface for drawing.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onAttachedToWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_getWindowAttachCount =
      jniAccessors.getMethodIDOf(_classRef, "getWindowAttachCount", "()I");

  /// from: protected int getWindowAttachCount()
  ///
  /// @return The number of times this view has been attached to a window
  int getWindowAttachCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getWindowAttachCount, jni.JniType.intType, []).integer;

  static final _id_getWindowToken = jniAccessors.getMethodIDOf(
      _classRef, "getWindowToken", "()Landroid/os/IBinder;");

  /// from: public android.os.IBinder getWindowToken()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a unique token identifying the window this view is attached to.
  ///@return Return the window's token for use in
  /// WindowManager.LayoutParams\#token WindowManager.LayoutParams.token.
  ibinder_.IBinder getWindowToken() =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindowToken, jni.JniType.objectType, []).object);

  static final _id_getWindowId = jniAccessors.getMethodIDOf(
      _classRef, "getWindowId", "()Landroid/view/WindowId;");

  /// from: public android.view.WindowId getWindowId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the WindowId for the window this view is
  /// currently attached to.
  windowid_.WindowId getWindowId() =>
      windowid_.WindowId.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindowId, jni.JniType.objectType, []).object);

  static final _id_getApplicationWindowToken = jniAccessors.getMethodIDOf(
      _classRef, "getApplicationWindowToken", "()Landroid/os/IBinder;");

  /// from: public android.os.IBinder getApplicationWindowToken()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a unique token identifying the top-level "real" window of
  /// the window that this view is attached to.  That is, this is like
  /// \#getWindowToken, except if the window this view in is a panel
  /// window (attached to another containing window), then the token of
  /// the containing window is returned instead.
  ///@return Returns the associated window token, either
  /// \#getWindowToken() or the containing window's token.
  ibinder_.IBinder getApplicationWindowToken() =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getApplicationWindowToken, jni.JniType.objectType, []).object);

  static final _id_getDisplay = jniAccessors.getMethodIDOf(
      _classRef, "getDisplay", "()Landroid/view/Display;");

  /// from: public android.view.Display getDisplay()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the logical display to which the view's window has been attached.
  ///@return The logical display, or null if the view is not currently attached to a window.
  display_.Display getDisplay() =>
      display_.Display.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDisplay, jni.JniType.objectType, []).object);

  static final _id_cancelPendingInputEvents =
      jniAccessors.getMethodIDOf(_classRef, "cancelPendingInputEvents", "()V");

  /// from: public final void cancelPendingInputEvents()
  ///
  /// Cancel any deferred high-level input events that were previously posted to the event queue.
  ///
  /// Many views post high-level events such as click handlers to the event queue
  /// to run deferred in order to preserve a desired user experience - clearing visible
  /// pressed states before executing, etc. This method will abort any events of this nature
  /// that are currently in flight.
  ///
  ///
  /// Custom views that generate their own high-level deferred input events should override
  /// \#onCancelPendingInputEvents() and remove those pending events from the queue.
  ///
  ///
  /// This will also cancel pending input events for any child views.
  ///
  ///
  /// Note that this may not be sufficient as a debouncing strategy for clicks in all cases.
  /// This will not impact newer events posted after this call that may occur as a result of
  /// lower-level input events still waiting in the queue. If you are trying to prevent
  /// double-submitted  events for the duration of some sort of asynchronous transaction
  /// you should also take other steps to protect against unexpected double inputs e.g. calling
  /// \#setEnabled(boolean) setEnabled(false) and re-enabling the view when
  /// the transaction completes, tracking already submitted transaction IDs, etc.
  ///
  void cancelPendingInputEvents() => jniAccessors.callMethodWithArgs(reference,
      _id_cancelPendingInputEvents, jni.JniType.voidType, []).check();

  static final _id_onCancelPendingInputEvents = jniAccessors.getMethodIDOf(
      _classRef, "onCancelPendingInputEvents", "()V");

  /// from: public void onCancelPendingInputEvents()
  ///
  /// Called as the result of a call to \#cancelPendingInputEvents() on this view or
  /// a parent view.
  ///
  /// This method is responsible for removing any pending high-level input events that were
  /// posted to the event queue to run later. Custom view classes that post their own deferred
  /// high-level events via \#post(Runnable), \#postDelayed(Runnable, long) or
  /// android.os.Handler should override this method, call
  /// <code>super.onCancelPendingInputEvents()</code> and remove those callbacks as appropriate.
  ///
  ///
  void onCancelPendingInputEvents() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCancelPendingInputEvents,
      jni.JniType.voidType, []).check();

  static final _id_saveHierarchyState = jniAccessors.getMethodIDOf(
      _classRef, "saveHierarchyState", "(Landroid/util/SparseArray;)V");

  /// from: public void saveHierarchyState(android.util.SparseArray<android.os.Parcelable> container)
  ///
  /// Store this view hierarchy's frozen state into the given container.
  ///@param container The SparseArray in which to save the view's state.
  ///@see \#restoreHierarchyState(android.util.SparseArray)
  ///@see \#dispatchSaveInstanceState(android.util.SparseArray)
  ///@see \#onSaveInstanceState()
  void saveHierarchyState(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(reference, _id_saveHierarchyState,
          jni.JniType.voidType, [container.reference]).check();

  static final _id_dispatchSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "dispatchSaveInstanceState", "(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchSaveInstanceState(android.util.SparseArray<android.os.Parcelable> container)
  ///
  /// Called by \#saveHierarchyState(android.util.SparseArray) to store the state for
  /// this view and its children. May be overridden to modify how freezing happens to a
  /// view's children; for example, some views may want to not store state for their children.
  ///@param container The SparseArray in which to save the view's state.
  ///@see \#dispatchRestoreInstanceState(android.util.SparseArray)
  ///@see \#saveHierarchyState(android.util.SparseArray)
  ///@see \#onSaveInstanceState()
  void dispatchSaveInstanceState(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchSaveInstanceState,
          jni.JniType.voidType, [container.reference]).check();

  static final _id_onSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: protected android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Hook allowing a view to generate a representation of its internal state
  /// that can later be used to create a new instance with that same state.
  /// This state should only contain information that is not persistent or can
  /// not be reconstructed later. For example, you will never store your
  /// current position on screen because that will be computed again when a
  /// new instance of the view is placed in its view hierarchy.
  ///
  /// Some examples of things you may store here: the current cursor position
  /// in a text view (but usually not the text itself since that is stored in a
  /// content provider or other persistent storage), the currently selected
  /// item in a list view.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@return Returns a Parcelable object containing the view's current dynamic
  ///         state, or null if there is nothing interesting to save.
  ///@see \#onRestoreInstanceState(Parcelable)
  ///@see \#saveHierarchyState(SparseArray)
  ///@see \#dispatchSaveInstanceState(SparseArray)
  ///@see \#setSaveEnabled(boolean)
  parcelable_.Parcelable onSaveInstanceState() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState, jni.JniType.objectType, []).object);

  static final _id_restoreHierarchyState = jniAccessors.getMethodIDOf(
      _classRef, "restoreHierarchyState", "(Landroid/util/SparseArray;)V");

  /// from: public void restoreHierarchyState(android.util.SparseArray<android.os.Parcelable> container)
  ///
  /// Restore this view hierarchy's frozen state from the given container.
  ///@param container The SparseArray which holds previously frozen states.
  ///@see \#saveHierarchyState(android.util.SparseArray)
  ///@see \#dispatchRestoreInstanceState(android.util.SparseArray)
  ///@see \#onRestoreInstanceState(android.os.Parcelable)
  void restoreHierarchyState(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(reference, _id_restoreHierarchyState,
          jni.JniType.voidType, [container.reference]).check();

  static final _id_dispatchRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchRestoreInstanceState",
      "(Landroid/util/SparseArray;)V");

  /// from: protected void dispatchRestoreInstanceState(android.util.SparseArray<android.os.Parcelable> container)
  ///
  /// Called by \#restoreHierarchyState(android.util.SparseArray) to retrieve the
  /// state for this view and its children. May be overridden to modify how restoring
  /// happens to a view's children; for example, some views may want to not store state
  /// for their children.
  ///@param container The SparseArray which holds previously saved state.
  ///@see \#dispatchSaveInstanceState(android.util.SparseArray)
  ///@see \#restoreHierarchyState(android.util.SparseArray)
  ///@see \#onRestoreInstanceState(android.os.Parcelable)
  void dispatchRestoreInstanceState(sparsearray_.SparseArray container) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchRestoreInstanceState,
          jni.JniType.voidType,
          [container.reference]).check();

  static final _id_onRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: protected void onRestoreInstanceState(android.os.Parcelable state)
  ///
  /// Hook allowing a view to re-apply a representation of its internal state that had previously
  /// been generated by \#onSaveInstanceState. This function will never be called with a
  /// null state.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param state The frozen state that had previously been returned by
  ///        \#onSaveInstanceState.
  ///@see \#onSaveInstanceState()
  ///@see \#restoreHierarchyState(android.util.SparseArray)
  ///@see \#dispatchRestoreInstanceState(android.util.SparseArray)
  void onRestoreInstanceState(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_getDrawingTime =
      jniAccessors.getMethodIDOf(_classRef, "getDrawingTime", "()J");

  /// from: public long getDrawingTime()
  ///
  /// Return the time at which the drawing of the view hierarchy started.
  ///
  ///@return the drawing start time in milliseconds
  int getDrawingTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getDrawingTime, jni.JniType.longType, []).long;

  static final _id_setDuplicateParentStateEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setDuplicateParentStateEnabled", "(Z)V");

  /// from: public void setDuplicateParentStateEnabled(boolean enabled)
  ///
  /// Enables or disables the duplication of the parent's state into this view. When
  /// duplication is enabled, this view gets its drawable state from its parent rather
  /// than from its own internal properties.
  ///
  ///
  /// Note: in the current implementation, setting this property to true after the
  /// view was added to a ViewGroup might have no effect at all. This property should
  /// always be used from XML or set to true before adding this view to a ViewGroup.
  ///
  ///
  /// Note: if this view's parent addStateFromChildren property is enabled and this
  /// property is enabled, an exception will be thrown.
  ///
  ///
  /// Note: if the child view uses and updates additional states which are unknown to the
  /// parent, these states should not be affected by this method.
  ///
  ///@param enabled True to enable duplication of the parent's drawable state, false
  ///                to disable it.
  ///@see \#getDrawableState()
  ///@see \#isDuplicateParentStateEnabled()
  void setDuplicateParentStateEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDuplicateParentStateEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_isDuplicateParentStateEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isDuplicateParentStateEnabled", "()Z");

  /// from: public boolean isDuplicateParentStateEnabled()
  ///
  /// Indicates whether this duplicates its drawable state from its parent.
  ///
  ///@return True if this view's drawable state is duplicated from the parent,
  ///         false otherwise
  ///@see \#getDrawableState()
  ///@see \#setDuplicateParentStateEnabled(boolean)
  bool isDuplicateParentStateEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isDuplicateParentStateEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setLayerType = jniAccessors.getMethodIDOf(
      _classRef, "setLayerType", "(ILandroid/graphics/Paint;)V");

  /// from: public void setLayerType(int layerType, android.graphics.Paint paint)
  ///
  /// Specifies the type of layer backing this view. The layer can be
  /// \#LAYER_TYPE_NONE, \#LAYER_TYPE_SOFTWARE or
  /// \#LAYER_TYPE_HARDWARE.
  ///
  ///
  /// A layer is associated with an optional android.graphics.Paint
  /// instance that controls how the layer is composed on screen. The following
  /// properties of the paint are taken into account when composing the layer:
  ///
  /// <ul>
  /// <li>android.graphics.Paint\#getAlpha() Translucency (alpha)</li>
  /// <li>android.graphics.Paint\#getXfermode() Blending mode</li>
  /// <li>android.graphics.Paint\#getColorFilter() Color filter</li>
  /// </ul>
  ///
  /// If this view has an alpha value set to < 1.0 by calling
  /// \#setAlpha(float), the alpha value of the layer's paint is superseded
  /// by this view's alpha value.
  ///
  ///
  /// Refer to the documentation of \#LAYER_TYPE_NONE,
  /// \#LAYER_TYPE_SOFTWARE and \#LAYER_TYPE_HARDWARE
  /// for more information on when and how to use layers.
  ///
  ///@param layerType The type of layer to use with this view, must be one of
  ///        \#LAYER_TYPE_NONE, \#LAYER_TYPE_SOFTWARE or
  ///        \#LAYER_TYPE_HARDWARE
  ///@param paint The paint used to compose the layer. This argument is optional
  ///        and can be null. It is ignored when the layer type is
  ///        \#LAYER_TYPE_NONE
  ///
  /// This value may be {@code null}.
  ///@see \#getLayerType()
  ///@see \#LAYER_TYPE_NONE
  ///@see \#LAYER_TYPE_SOFTWARE
  ///@see \#LAYER_TYPE_HARDWARE
  ///@see \#setAlpha(float)
  ///@attr ref android.R.styleable\#View_layerType
  void setLayerType(int layerType, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayerType,
          jni.JniType.voidType, [layerType, paint.reference]).check();

  static final _id_setLayerPaint = jniAccessors.getMethodIDOf(
      _classRef, "setLayerPaint", "(Landroid/graphics/Paint;)V");

  /// from: public void setLayerPaint(android.graphics.Paint paint)
  ///
  /// Updates the Paint object used with the current layer (used only if the current
  /// layer type is not set to \#LAYER_TYPE_NONE). Changed properties of the Paint
  /// provided to \#setLayerType(int, android.graphics.Paint) will be used the next time
  /// the View is redrawn, but \#setLayerPaint(android.graphics.Paint) must be called to
  /// ensure that the view gets redrawn immediately.
  ///
  /// A layer is associated with an optional android.graphics.Paint
  /// instance that controls how the layer is composed on screen. The following
  /// properties of the paint are taken into account when composing the layer:
  ///
  /// <ul>
  /// <li>android.graphics.Paint\#getAlpha() Translucency (alpha)</li>
  /// <li>android.graphics.Paint\#getXfermode() Blending mode</li>
  /// <li>android.graphics.Paint\#getColorFilter() Color filter</li>
  /// </ul>
  ///
  /// If this view has an alpha value set to < 1.0 by calling \#setAlpha(float), the
  /// alpha value of the layer's paint is superseded by this view's alpha value.
  ///
  ///@param paint The paint used to compose the layer. This argument is optional
  ///        and can be null. It is ignored when the layer type is
  ///        \#LAYER_TYPE_NONE
  ///
  /// This value may be {@code null}.
  ///@see \#setLayerType(int, android.graphics.Paint)
  void setLayerPaint(paint_.Paint paint) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayerPaint,
      jni.JniType.voidType,
      [paint.reference]).check();

  static final _id_getLayerType =
      jniAccessors.getMethodIDOf(_classRef, "getLayerType", "()I");

  /// from: public int getLayerType()
  ///
  /// Indicates what type of layer is currently associated with this view. By default
  /// a view does not have a layer, and the layer type is \#LAYER_TYPE_NONE.
  /// Refer to the documentation of \#setLayerType(int, android.graphics.Paint)
  /// for more information on the different types of layers.
  ///@return \#LAYER_TYPE_NONE, \#LAYER_TYPE_SOFTWARE or
  ///         \#LAYER_TYPE_HARDWARE
  ///@see \#setLayerType(int, android.graphics.Paint)
  ///@see \#buildLayer()
  ///@see \#LAYER_TYPE_NONE
  ///@see \#LAYER_TYPE_SOFTWARE
  ///@see \#LAYER_TYPE_HARDWARE
  int getLayerType() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerType, jni.JniType.intType, []).integer;

  static final _id_buildLayer =
      jniAccessors.getMethodIDOf(_classRef, "buildLayer", "()V");

  /// from: public void buildLayer()
  ///
  /// Forces this view's layer to be created and this view to be rendered
  /// into its layer. If this view's layer type is set to \#LAYER_TYPE_NONE,
  /// invoking this method will have no effect.
  ///
  /// This method can for instance be used to render a view into its layer before
  /// starting an animation. If this view is complex, rendering into the layer
  /// before starting the animation will avoid skipping frames.
  ///@throws IllegalStateException If this view is not attached to a window
  ///@see \#setLayerType(int, android.graphics.Paint)
  void buildLayer() => jniAccessors.callMethodWithArgs(
      reference, _id_buildLayer, jni.JniType.voidType, []).check();

  static final _id_setDrawingCacheEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setDrawingCacheEnabled", "(Z)V");

  /// from: public void setDrawingCacheEnabled(boolean enabled)
  ///
  /// Enables or disables the drawing cache. When the drawing cache is enabled, the next call
  /// to \#getDrawingCache() or \#buildDrawingCache() will draw the view in a
  /// bitmap. Calling \#draw(android.graphics.Canvas) will not draw from the cache when
  /// the cache is enabled. To benefit from the cache, you must request the drawing cache by
  /// calling \#getDrawingCache() and draw it on screen if the returned bitmap is not
  /// null.
  ///
  ///
  /// Enabling the drawing cache is similar to
  /// \#setLayerType(int, android.graphics.Paint) setting a layer when hardware
  /// acceleration is turned off. When hardware acceleration is turned on, enabling the
  /// drawing cache has no effect on rendering because the system uses a different mechanism
  /// for acceleration which ignores the flag. If you want to use a Bitmap for the view, even
  /// when hardware acceleration is enabled, see \#setLayerType(int, android.graphics.Paint)
  /// for information on how to enable software and hardware layers.
  ///
  ///
  /// This API can be used to manually generate
  /// a bitmap copy of this view, by setting the flag to <code>true</code> and calling
  /// \#getDrawingCache().
  ///
  ///@param enabled true to enable the drawing cache, false otherwise
  ///@see \#isDrawingCacheEnabled()
  ///@see \#getDrawingCache()
  ///@see \#buildDrawingCache()
  ///@see \#setLayerType(int, android.graphics.Paint)
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void setDrawingCacheEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDrawingCacheEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_isDrawingCacheEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isDrawingCacheEnabled", "()Z");

  /// from: public boolean isDrawingCacheEnabled()
  ///
  /// Indicates whether the drawing cache is enabled for this view.
  ///
  ///@return true if the drawing cache is enabled
  ///@see \#setDrawingCacheEnabled(boolean)
  ///@see \#getDrawingCache()
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  bool isDrawingCacheEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isDrawingCacheEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getDrawingCache = jniAccessors.getMethodIDOf(
      _classRef, "getDrawingCache", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getDrawingCache()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calling this method is equivalent to calling <code>getDrawingCache(false)</code>.
  ///
  ///@return A non-scaled bitmap representing this view or null if cache is disabled.
  ///@see \#getDrawingCache(boolean)
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  bitmap_.Bitmap getDrawingCache() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrawingCache, jni.JniType.objectType, []).object);

  static final _id_getDrawingCache1 = jniAccessors.getMethodIDOf(
      _classRef, "getDrawingCache", "(Z)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getDrawingCache(boolean autoScale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the bitmap in which this view drawing is cached. The returned bitmap
  /// is null when caching is disabled. If caching is enabled and the cache is not ready,
  /// this method will create it. Calling \#draw(android.graphics.Canvas) will not
  /// draw from the cache when the cache is enabled. To benefit from the cache, you must
  /// request the drawing cache by calling this method and draw it on screen if the
  /// returned bitmap is not null.
  ///
  ///
  /// Note about auto scaling in compatibility mode: When auto scaling is not enabled,
  /// this method will create a bitmap of the same size as this view. Because this bitmap
  /// will be drawn scaled by the parent ViewGroup, the result on screen might show
  /// scaling artifacts. To avoid such artifacts, you should call this method by setting
  /// the auto scaling to true. Doing so, however, will generate a bitmap of a different
  /// size than the view. This implies that your application must be able to handle this
  /// size.
  ///
  ///@param autoScale Indicates whether the generated bitmap should be scaled based on
  ///        the current density of the screen when the application is in compatibility
  ///        mode.
  ///@return A bitmap representing this view or null if cache is disabled.
  ///@see \#setDrawingCacheEnabled(boolean)
  ///@see \#isDrawingCacheEnabled()
  ///@see \#buildDrawingCache(boolean)
  ///@see \#destroyDrawingCache()
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  bitmap_.Bitmap getDrawingCache1(bool autoScale) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDrawingCache1, jni.JniType.objectType, [autoScale]).object);

  static final _id_destroyDrawingCache =
      jniAccessors.getMethodIDOf(_classRef, "destroyDrawingCache", "()V");

  /// from: public void destroyDrawingCache()
  ///
  /// Frees the resources used by the drawing cache. If you call
  /// \#buildDrawingCache() manually without calling
  /// \#setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true), you
  /// should cleanup the cache with this method afterwards.
  ///
  ///@see \#setDrawingCacheEnabled(boolean)
  ///@see \#buildDrawingCache()
  ///@see \#getDrawingCache()
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void destroyDrawingCache() => jniAccessors.callMethodWithArgs(
      reference, _id_destroyDrawingCache, jni.JniType.voidType, []).check();

  static final _id_setDrawingCacheBackgroundColor = jniAccessors.getMethodIDOf(
      _classRef, "setDrawingCacheBackgroundColor", "(I)V");

  /// from: public void setDrawingCacheBackgroundColor(int color)
  ///
  /// Setting a solid background color for the drawing cache's bitmaps will improve
  /// performance and memory usage. Note, though that this should only be used if this
  /// view will always be drawn on top of a solid color.
  ///@param color The background color to use for the drawing cache's bitmap
  ///@see \#setDrawingCacheEnabled(boolean)
  ///@see \#buildDrawingCache()
  ///@see \#getDrawingCache()
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void setDrawingCacheBackgroundColor(int color) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDrawingCacheBackgroundColor,
          jni.JniType.voidType,
          [color]).check();

  static final _id_getDrawingCacheBackgroundColor = jniAccessors.getMethodIDOf(
      _classRef, "getDrawingCacheBackgroundColor", "()I");

  /// from: public int getDrawingCacheBackgroundColor()
  ///
  /// @see \#setDrawingCacheBackgroundColor(int)
  ///@return The background color to used for the drawing cache's bitmap
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  int getDrawingCacheBackgroundColor() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDrawingCacheBackgroundColor,
      jni.JniType.intType, []).integer;

  static final _id_buildDrawingCache =
      jniAccessors.getMethodIDOf(_classRef, "buildDrawingCache", "()V");

  /// from: public void buildDrawingCache()
  ///
  /// Calling this method is equivalent to calling <code>buildDrawingCache(false)</code>.
  ///
  ///@see \#buildDrawingCache(boolean)
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void buildDrawingCache() => jniAccessors.callMethodWithArgs(
      reference, _id_buildDrawingCache, jni.JniType.voidType, []).check();

  static final _id_buildDrawingCache1 =
      jniAccessors.getMethodIDOf(_classRef, "buildDrawingCache", "(Z)V");

  /// from: public void buildDrawingCache(boolean autoScale)
  ///
  /// Forces the drawing cache to be built if the drawing cache is invalid.
  ///
  ///
  /// If you call \#buildDrawingCache() manually without calling
  /// \#setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true), you
  /// should cleanup the cache by calling \#destroyDrawingCache() afterwards.
  ///
  ///
  /// Note about auto scaling in compatibility mode: When auto scaling is not enabled,
  /// this method will create a bitmap of the same size as this view. Because this bitmap
  /// will be drawn scaled by the parent ViewGroup, the result on screen might show
  /// scaling artifacts. To avoid such artifacts, you should call this method by setting
  /// the auto scaling to true. Doing so, however, will generate a bitmap of a different
  /// size than the view. This implies that your application must be able to handle this
  /// size.
  ///
  ///
  /// You should avoid calling this method when hardware acceleration is enabled. If
  /// you do not need the drawing cache bitmap, calling this method will increase memory
  /// usage and cause the view to be rendered in software once, thus negatively impacting
  /// performance.
  ///
  ///@see \#getDrawingCache()
  ///@see \#destroyDrawingCache()
  ///@deprecated The view drawing cache was largely made obsolete with the introduction of
  /// hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
  /// layers are largely unnecessary and can easily result in a net loss in performance due to the
  /// cost of creating and updating the layer. In the rare cases where caching layers are useful,
  /// such as for alpha animations, \#setLayerType(int, Paint) handles this with hardware
  /// rendering. For software-rendered snapshots of a small part of the View hierarchy or
  /// individual Views it is recommended to create a Canvas from either a Bitmap or
  /// android.graphics.Picture and call \#draw(Canvas) on the View. However these
  /// software-rendered usages are discouraged and have compatibility issues with hardware-only
  /// rendering features such as android.graphics.Bitmap.Config\#HARDWARE Config.HARDWARE
  /// bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
  /// reports or unit testing the PixelCopy API is recommended.
  void buildDrawingCache1(bool autoScale) => jniAccessors.callMethodWithArgs(
      reference,
      _id_buildDrawingCache1,
      jni.JniType.voidType,
      [autoScale]).check();

  static final _id_isInEditMode =
      jniAccessors.getMethodIDOf(_classRef, "isInEditMode", "()Z");

  /// from: public boolean isInEditMode()
  ///
  /// Indicates whether this View is currently in edit mode. A View is usually
  /// in edit mode when displayed within a developer tool. For instance, if
  /// this View is being drawn by a visual user interface builder, this method
  /// should return true.
  ///
  /// Subclasses should check the return value of this method to provide
  /// different behaviors if their normal behavior might interfere with the
  /// host environment. For instance: the class spawns a thread in its
  /// constructor, the drawing code relies on device-specific features, etc.
  ///
  /// This method is usually checked in the drawing code of custom widgets.
  ///@return True if this View is in edit mode, false otherwise.
  bool isInEditMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isInEditMode, jni.JniType.booleanType, []).boolean;

  static final _id_isPaddingOffsetRequired =
      jniAccessors.getMethodIDOf(_classRef, "isPaddingOffsetRequired", "()Z");

  /// from: protected boolean isPaddingOffsetRequired()
  ///
  /// If the View draws content inside its padding and enables fading edges,
  /// it needs to support padding offsets. Padding offsets are added to the
  /// fading edges to extend the length of the fade so that it covers pixels
  /// drawn inside the padding.
  ///
  /// Subclasses of this class should override this method if they need
  /// to draw content inside the padding.
  ///@return True if padding offset must be applied, false otherwise.
  ///@see \#getLeftPaddingOffset()
  ///@see \#getRightPaddingOffset()
  ///@see \#getTopPaddingOffset()
  ///@see \#getBottomPaddingOffset()
  ///@since CURRENT
  bool isPaddingOffsetRequired() => jniAccessors.callMethodWithArgs(reference,
      _id_isPaddingOffsetRequired, jni.JniType.booleanType, []).boolean;

  static final _id_getLeftPaddingOffset =
      jniAccessors.getMethodIDOf(_classRef, "getLeftPaddingOffset", "()I");

  /// from: protected int getLeftPaddingOffset()
  ///
  /// Amount by which to extend the left fading region. Called only when
  /// \#isPaddingOffsetRequired() returns true.
  ///@return The left padding offset in pixels.
  ///@see \#isPaddingOffsetRequired()
  ///@since CURRENT
  int getLeftPaddingOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getLeftPaddingOffset, jni.JniType.intType, []).integer;

  static final _id_getRightPaddingOffset =
      jniAccessors.getMethodIDOf(_classRef, "getRightPaddingOffset", "()I");

  /// from: protected int getRightPaddingOffset()
  ///
  /// Amount by which to extend the right fading region. Called only when
  /// \#isPaddingOffsetRequired() returns true.
  ///@return The right padding offset in pixels.
  ///@see \#isPaddingOffsetRequired()
  ///@since CURRENT
  int getRightPaddingOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getRightPaddingOffset, jni.JniType.intType, []).integer;

  static final _id_getTopPaddingOffset =
      jniAccessors.getMethodIDOf(_classRef, "getTopPaddingOffset", "()I");

  /// from: protected int getTopPaddingOffset()
  ///
  /// Amount by which to extend the top fading region. Called only when
  /// \#isPaddingOffsetRequired() returns true.
  ///@return The top padding offset in pixels.
  ///@see \#isPaddingOffsetRequired()
  ///@since CURRENT
  int getTopPaddingOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getTopPaddingOffset, jni.JniType.intType, []).integer;

  static final _id_getBottomPaddingOffset =
      jniAccessors.getMethodIDOf(_classRef, "getBottomPaddingOffset", "()I");

  /// from: protected int getBottomPaddingOffset()
  ///
  /// Amount by which to extend the bottom fading region. Called only when
  /// \#isPaddingOffsetRequired() returns true.
  ///@return The bottom padding offset in pixels.
  ///@see \#isPaddingOffsetRequired()
  ///@since CURRENT
  int getBottomPaddingOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getBottomPaddingOffset, jni.JniType.intType, []).integer;

  static final _id_isHardwareAccelerated =
      jniAccessors.getMethodIDOf(_classRef, "isHardwareAccelerated", "()Z");

  /// from: public boolean isHardwareAccelerated()
  ///
  /// Indicates whether this view is attached to a hardware accelerated
  /// window or not.
  ///
  ///
  /// Even if this method returns true, it does not mean that every call
  /// to \#draw(android.graphics.Canvas) will be made with an hardware
  /// accelerated android.graphics.Canvas. For instance, if this view
  /// is drawn onto an offscreen android.graphics.Bitmap and its
  /// window is hardware accelerated,
  /// android.graphics.Canvas\#isHardwareAccelerated() will likely
  /// return false, and this method will return true.
  ///
  ///@return True if the view is attached to a window and the window is
  ///         hardware accelerated; false in any other case.
  bool isHardwareAccelerated() => jniAccessors.callMethodWithArgs(reference,
      _id_isHardwareAccelerated, jni.JniType.booleanType, []).boolean;

  static final _id_setClipBounds = jniAccessors.getMethodIDOf(
      _classRef, "setClipBounds", "(Landroid/graphics/Rect;)V");

  /// from: public void setClipBounds(android.graphics.Rect clipBounds)
  ///
  /// Sets a rectangular area on this view to which the view will be clipped
  /// when it is drawn. Setting the value to null will remove the clip bounds
  /// and the view will draw normally, using its full bounds.
  ///@param clipBounds The rectangular area, in the local coordinates of
  /// this view, to which future drawing operations will be clipped.
  void setClipBounds(rect_.Rect clipBounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClipBounds,
      jni.JniType.voidType,
      [clipBounds.reference]).check();

  static final _id_getClipBounds = jniAccessors.getMethodIDOf(
      _classRef, "getClipBounds", "()Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect getClipBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of the current \#setClipBounds(Rect) clipBounds.
  ///@return A copy of the current clip bounds if clip bounds are set,
  /// otherwise null.
  rect_.Rect getClipBounds() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClipBounds, jni.JniType.objectType, []).object);

  static final _id_getClipBounds1 = jniAccessors.getMethodIDOf(
      _classRef, "getClipBounds", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean getClipBounds(android.graphics.Rect outRect)
  ///
  /// Populates an output rectangle with the clip bounds of the view,
  /// returning {@code true} if successful or {@code false} if the view's
  /// clip bounds are {@code null}.
  ///@param outRect rectangle in which to place the clip bounds of the view
  ///@return {@code true} if successful or {@code false} if the view's
  ///         clip bounds are {@code null}
  bool getClipBounds1(rect_.Rect outRect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getClipBounds1,
      jni.JniType.booleanType,
      [outRect.reference]).boolean;

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  ///
  /// Manually render this view (and all of its children) to the given Canvas.
  /// The view must have already done a full layout before this function is
  /// called.  When implementing a view, implement
  /// \#onDraw(android.graphics.Canvas) instead of overriding this method.
  /// If you do need to override this method, call the superclass version.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param canvas The Canvas to which the View is rendered.
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getOverlay = jniAccessors.getMethodIDOf(
      _classRef, "getOverlay", "()Landroid/view/ViewOverlay;");

  /// from: public android.view.ViewOverlay getOverlay()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the overlay for this view, creating it if it does not yet exist.
  /// Adding drawables to the overlay will cause them to be displayed whenever
  /// the view itself is redrawn. Objects in the overlay should be actively
  /// managed: remove them when they should not be displayed anymore. The
  /// overlay will always have the same size as its host view.
  ///
  /// Note: Overlays do not currently work correctly with SurfaceView or TextureView; contents in overlays for these
  /// types of views may not display correctly.
  ///
  ///@return The ViewOverlay object for this view.
  ///@see ViewOverlay
  viewoverlay_.ViewOverlay getOverlay() =>
      viewoverlay_.ViewOverlay.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOverlay, jni.JniType.objectType, []).object);

  static final _id_getSolidColor =
      jniAccessors.getMethodIDOf(_classRef, "getSolidColor", "()I");

  /// from: public int getSolidColor()
  ///
  /// Override this if your view is known to always be drawn on top of a solid color background,
  /// and needs to draw fading edges. Returning a non-zero color enables the view system to
  /// optimize the drawing of the fading edges. If you do return a non-zero color, the alpha
  /// should be set to 0xFF.
  ///@see \#setVerticalFadingEdgeEnabled(boolean)
  ///@see \#setHorizontalFadingEdgeEnabled(boolean)
  ///@return The known solid color background for this view, or 0 if the color may vary
  int getSolidColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getSolidColor, jni.JniType.intType, []).integer;

  static final _id_isLayoutRequested =
      jniAccessors.getMethodIDOf(_classRef, "isLayoutRequested", "()Z");

  /// from: public boolean isLayoutRequested()
  ///
  /// Indicates whether or not this view's layout will be requested during
  /// the next hierarchy layout pass.
  ///
  ///@return true if the layout will be forced during next layout pass
  bool isLayoutRequested() => jniAccessors.callMethodWithArgs(
      reference, _id_isLayoutRequested, jni.JniType.booleanType, []).boolean;

  static final _id_layout =
      jniAccessors.getMethodIDOf(_classRef, "layout", "(IIII)V");

  /// from: public void layout(int l, int t, int r, int b)
  ///
  /// Assign a size and position to a view and all of its
  /// descendants
  ///
  /// This is the second phase of the layout mechanism.
  /// (The first is measuring). In this phase, each parent calls
  /// layout on all of its children to position them.
  /// This is typically done using the child measurements
  /// that were stored in the measure pass().
  ///
  ///
  /// Derived classes should not override this method.
  /// Derived classes with children should override
  /// onLayout. In that method, they should
  /// call layout on each of their children.
  ///
  ///@param l Left position, relative to parent
  ///@param t Top position, relative to parent
  ///@param r Right position, relative to parent
  ///@param b Bottom position, relative to parent
  void layout(int l, int t, int r, int b) => jniAccessors.callMethodWithArgs(
      reference, _id_layout, jni.JniType.voidType, [l, t, r, b]).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int left, int top, int right, int bottom)
  ///
  /// Called from layout when this view should
  /// assign a size and position to each of its children.
  ///
  /// Derived classes with children should override
  /// this method and call layout on each of
  /// their children.
  ///@param changed This is a new size or position for this view
  ///@param left Left position, relative to parent
  ///@param top Top position, relative to parent
  ///@param right Right position, relative to parent
  ///@param bottom Bottom position, relative to parent
  void onLayout(bool changed, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, left, top, right, bottom]).check();

  static final _id_onFinishInflate =
      jniAccessors.getMethodIDOf(_classRef, "onFinishInflate", "()V");

  /// from: protected void onFinishInflate()
  ///
  /// Finalize inflating a view from XML.  This is called as the last phase
  /// of inflation, after all child views have been added.
  ///
  /// Even if the subclass overrides onFinishInflate, they should always be
  /// sure to call the super method, so that we get called.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onFinishInflate() => jniAccessors.callMethodWithArgs(
      reference, _id_onFinishInflate, jni.JniType.voidType, []).check();

  static final _id_getResources = jniAccessors.getMethodIDOf(
      _classRef, "getResources", "()Landroid/content/res/Resources;");

  /// from: public android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the resources associated with this view.
  ///@return Resources object.
  resources_.Resources getResources() =>
      resources_.Resources.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getResources, jni.JniType.objectType, []).object);

  static final _id_invalidateDrawable = jniAccessors.getMethodIDOf(_classRef,
      "invalidateDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable drawable)
  ///
  /// Invalidates the specified Drawable.
  ///@param drawable the drawable to invalidate
  ///
  /// This value must never be {@code null}.
  void invalidateDrawable(drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateDrawable,
          jni.JniType.voidType, [drawable.reference]).check();

  static final _id_scheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "scheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;J)V");

  /// from: public void scheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what, long when)
  ///
  /// Schedules an action on a drawable to occur at a specified time.
  ///@param who the recipient of the action
  /// This value must never be {@code null}.
  ///@param what the action to run on the drawable
  /// This value must never be {@code null}.
  ///@param when the time at which the action must occur. Uses the
  ///        SystemClock\#uptimeMillis timebase.
  void scheduleDrawable(drawable_.Drawable who, jni.JniObject what, int when) =>
      jniAccessors.callMethodWithArgs(reference, _id_scheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference, when]).check();

  static final _id_unscheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "unscheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;)V");

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what)
  ///
  /// Cancels a scheduled action on a drawable.
  ///@param who the recipient of the action
  /// This value must never be {@code null}.
  ///@param what the action to cancel
  ///
  /// This value must never be {@code null}.
  void unscheduleDrawable(drawable_.Drawable who, jni.JniObject what) =>
      jniAccessors.callMethodWithArgs(reference, _id_unscheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference]).check();

  static final _id_unscheduleDrawable1 = jniAccessors.getMethodIDOf(_classRef,
      "unscheduleDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable who)
  ///
  /// Unschedule any events associated with the given Drawable.  This can be
  /// used when selecting a new Drawable into a view, so that the previous
  /// one is completely unscheduled.
  ///@param who The Drawable to unschedule.
  ///@see \#drawableStateChanged
  void unscheduleDrawable1(drawable_.Drawable who) =>
      jniAccessors.callMethodWithArgs(reference, _id_unscheduleDrawable1,
          jni.JniType.voidType, [who.reference]).check();

  static final _id_verifyDrawable = jniAccessors.getMethodIDOf(
      _classRef, "verifyDrawable", "(Landroid/graphics/drawable/Drawable;)Z");

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable who)
  ///
  /// If your view subclass is displaying its own Drawable objects, it should
  /// override this function and return true for any Drawable it is
  /// displaying.  This allows animations for those drawables to be
  /// scheduled.
  ///
  /// Be sure to call through to the super class when overriding this
  /// function.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param who The Drawable to verify.  Return true if it is one you are
  ///            displaying, else return the result of calling through to the
  ///            super class.
  ///
  /// This value must never be {@code null}.
  ///@return boolean If true than the Drawable is being displayed in the
  ///         view; else false and it is not allowed to animate.
  ///@see \#unscheduleDrawable(android.graphics.drawable.Drawable)
  ///@see \#drawableStateChanged()
  bool verifyDrawable(drawable_.Drawable who) =>
      jniAccessors.callMethodWithArgs(reference, _id_verifyDrawable,
          jni.JniType.booleanType, [who.reference]).boolean;

  static final _id_drawableStateChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableStateChanged", "()V");

  /// from: protected void drawableStateChanged()
  ///
  /// This function is called whenever the state of the view changes in such
  /// a way that it impacts the state of drawables being shown.
  ///
  /// If the View has a StateListAnimator, it will also be called to run necessary state
  /// change animations.
  ///
  /// Be sure to call through to the superclass when overriding this function.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see Drawable\#setState(int[])
  void drawableStateChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_drawableStateChanged, jni.JniType.voidType, []).check();

  static final _id_drawableHotspotChanged =
      jniAccessors.getMethodIDOf(_classRef, "drawableHotspotChanged", "(FF)V");

  /// from: public void drawableHotspotChanged(float x, float y)
  ///
  /// This function is called whenever the view hotspot changes and needs to
  /// be propagated to drawables or child views managed by the view.
  ///
  /// Dispatching to child views is handled by
  /// \#dispatchDrawableHotspotChanged(float, float).
  ///
  /// Be sure to call through to the superclass when overriding this function.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param x hotspot x coordinate
  ///@param y hotspot y coordinate
  void drawableHotspotChanged(double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawableHotspotChanged,
          jni.JniType.voidType, [x, y]).check();

  static final _id_dispatchDrawableHotspotChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDrawableHotspotChanged", "(FF)V");

  /// from: public void dispatchDrawableHotspotChanged(float x, float y)
  ///
  /// Dispatches drawableHotspotChanged to all of this View's children.
  ///@param x hotspot x coordinate
  ///@param y hotspot y coordinate
  ///@see \#drawableHotspotChanged(float, float)
  void dispatchDrawableHotspotChanged(double x, double y) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchDrawableHotspotChanged,
          jni.JniType.voidType,
          [x, y]).check();

  static final _id_refreshDrawableState =
      jniAccessors.getMethodIDOf(_classRef, "refreshDrawableState", "()V");

  /// from: public void refreshDrawableState()
  ///
  /// Call this to force a view to update its drawable state. This will cause
  /// drawableStateChanged to be called on this view. Views that are interested
  /// in the new state should call getDrawableState.
  ///@see \#drawableStateChanged
  ///@see \#getDrawableState
  void refreshDrawableState() => jniAccessors.callMethodWithArgs(
      reference, _id_refreshDrawableState, jni.JniType.voidType, []).check();

  static final _id_getDrawableState =
      jniAccessors.getMethodIDOf(_classRef, "getDrawableState", "()[I");

  /// from: public final int[] getDrawableState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an array of resource IDs of the drawable states representing the
  /// current state of the view.
  ///@return The current drawable state
  ///@see Drawable\#setState(int[])
  ///@see \#drawableStateChanged()
  ///@see \#onCreateDrawableState(int)
  jni.JniObject getDrawableState() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrawableState, jni.JniType.objectType, []).object);

  static final _id_onCreateDrawableState =
      jniAccessors.getMethodIDOf(_classRef, "onCreateDrawableState", "(I)[I");

  /// from: protected int[] onCreateDrawableState(int extraSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generate the new android.graphics.drawable.Drawable state for
  /// this view. This is called by the view
  /// system when the cached Drawable state is determined to be invalid.  To
  /// retrieve the current state, you should use \#getDrawableState.
  ///@param extraSpace if non-zero, this is the number of extra entries you
  /// would like in the returned array in which you can place your own
  /// states.
  ///@return Returns an array holding the current Drawable state of
  /// the view.
  ///@see \#mergeDrawableStates(int[], int[])
  jni.JniObject onCreateDrawableState(int extraSpace) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateDrawableState,
          jni.JniType.objectType,
          [extraSpace]).object);

  static final _id_mergeDrawableStates = jniAccessors.getStaticMethodIDOf(
      _classRef, "mergeDrawableStates", "([I[I)[I");

  /// from: static protected int[] mergeDrawableStates(int[] baseState, int[] additionalState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Merge your own state values in <var>additionalState</var> into the base
  /// state values <var>baseState</var> that were returned by
  /// \#onCreateDrawableState(int).
  ///@param baseState The base state values returned by
  /// \#onCreateDrawableState(int), which will be modified to also hold your
  /// own additional state values.
  ///@param additionalState The additional state values you would like
  /// added to <var>baseState</var>; this array is not modified.
  ///@return As a convenience, the <var>baseState</var> array you originally
  /// passed into the function is returned.
  ///@see \#onCreateDrawableState(int)
  static jni.JniObject mergeDrawableStates(
          jni.JniObject baseState, jni.JniObject additionalState) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_mergeDrawableStates,
          jni.JniType.objectType,
          [baseState.reference, additionalState.reference]).object);

  static final _id_jumpDrawablesToCurrentState = jniAccessors.getMethodIDOf(
      _classRef, "jumpDrawablesToCurrentState", "()V");

  /// from: public void jumpDrawablesToCurrentState()
  ///
  /// Call Drawable\#jumpToCurrentState() Drawable.jumpToCurrentState()
  /// on all Drawable objects associated with this view.
  ///
  /// Also calls StateListAnimator\#jumpToCurrentState() if there is a StateListAnimator
  /// attached to this view.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void jumpDrawablesToCurrentState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_jumpDrawablesToCurrentState,
      jni.JniType.voidType, []).check();

  static final _id_setBackgroundColor =
      jniAccessors.getMethodIDOf(_classRef, "setBackgroundColor", "(I)V");

  /// from: public void setBackgroundColor(int color)
  ///
  /// Sets the background color for this view.
  ///@param color the color of the background
  void setBackgroundColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setBackgroundColor, jni.JniType.voidType, [color]).check();

  static final _id_setBackgroundResource =
      jniAccessors.getMethodIDOf(_classRef, "setBackgroundResource", "(I)V");

  /// from: public void setBackgroundResource(int resid)
  ///
  /// Set the background to a given resource. The resource should refer to
  /// a Drawable object or 0 to remove the background.
  ///@param resid The identifier of the resource.
  ///@attr ref android.R.styleable\#View_background
  void setBackgroundResource(int resid) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBackgroundResource,
      jni.JniType.voidType,
      [resid]).check();

  static final _id_setBackground = jniAccessors.getMethodIDOf(
      _classRef, "setBackground", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setBackground(android.graphics.drawable.Drawable background)
  ///
  /// Set the background to a given Drawable, or remove the background. If the
  /// background has padding, this View's padding is set to the background's
  /// padding. However, when a background is removed, this View's padding isn't
  /// touched. If setting the padding is desired, please use
  /// \#setPadding(int, int, int, int).
  ///@param background The Drawable to use as the background, or null to remove the
  ///        background
  void setBackground(drawable_.Drawable background) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBackground,
          jni.JniType.voidType, [background.reference]).check();

  static final _id_setBackgroundDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setBackgroundDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setBackgroundDrawable(android.graphics.drawable.Drawable background)
  ///
  /// @deprecated use \#setBackground(Drawable) instead
  void setBackgroundDrawable(drawable_.Drawable background) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBackgroundDrawable,
          jni.JniType.voidType, [background.reference]).check();

  static final _id_getBackground = jniAccessors.getMethodIDOf(
      _classRef, "getBackground", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getBackground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the background drawable
  ///@return The drawable used as the background for this view, if any.
  ///@see \#setBackground(Drawable)
  ///@attr ref android.R.styleable\#View_background
  drawable_.Drawable getBackground() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBackground, jni.JniType.objectType, []).object);

  static final _id_setBackgroundTintList = jniAccessors.getMethodIDOf(_classRef,
      "setBackgroundTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setBackgroundTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the background drawable. Does not modify the current tint
  /// mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// Subsequent calls to \#setBackground(Drawable) will automatically
  /// mutate the drawable and apply the specified tint and tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_backgroundTint
  ///@see \#getBackgroundTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setBackgroundTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBackgroundTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_getBackgroundTintList = jniAccessors.getMethodIDOf(_classRef,
      "getBackgroundTintList", "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getBackgroundTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the tint applied to the background drawable, if specified.
  ///@return the tint applied to the background drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_backgroundTint
  ///@see \#setBackgroundTintList(ColorStateList)
  colorstatelist_.ColorStateList getBackgroundTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBackgroundTintList,
          jni.JniType.objectType, []).object);

  static final _id_setBackgroundTintMode = jniAccessors.getMethodIDOf(_classRef,
      "setBackgroundTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setBackgroundTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setBackgroundTintList(ColorStateList)} to the background
  /// drawable. The default mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_backgroundTintMode
  ///@see \#getBackgroundTintMode()
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setBackgroundTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBackgroundTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_getBackgroundTintMode = jniAccessors.getMethodIDOf(_classRef,
      "getBackgroundTintMode", "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getBackgroundTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the blending mode used to apply the tint to the background
  /// drawable, if specified.
  ///@return the blending mode used to apply the tint to the background
  ///         drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_backgroundTintMode
  ///@see \#setBackgroundTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getBackgroundTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBackgroundTintMode,
          jni.JniType.objectType, []).object);

  static final _id_getForeground = jniAccessors.getMethodIDOf(
      _classRef, "getForeground", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getForeground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the drawable used as the foreground of this View. The
  /// foreground drawable, if non-null, is always drawn on top of the view's content.
  ///@return a Drawable or null if no foreground was set
  ///@see \#onDrawForeground(Canvas)
  drawable_.Drawable getForeground() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getForeground, jni.JniType.objectType, []).object);

  static final _id_setForeground = jniAccessors.getMethodIDOf(
      _classRef, "setForeground", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setForeground(android.graphics.drawable.Drawable foreground)
  ///
  /// Supply a Drawable that is to be rendered on top of all of the content in the view.
  ///@param foreground the Drawable to be drawn on top of the children
  ///@attr ref android.R.styleable\#View_foreground
  void setForeground(drawable_.Drawable foreground) =>
      jniAccessors.callMethodWithArgs(reference, _id_setForeground,
          jni.JniType.voidType, [foreground.reference]).check();

  static final _id_getForegroundGravity =
      jniAccessors.getMethodIDOf(_classRef, "getForegroundGravity", "()I");

  /// from: public int getForegroundGravity()
  ///
  /// Describes how the foreground is positioned.
  ///@return foreground gravity.
  ///@see \#setForegroundGravity(int)
  ///@attr ref android.R.styleable\#View_foregroundGravity
  int getForegroundGravity() => jniAccessors.callMethodWithArgs(
      reference, _id_getForegroundGravity, jni.JniType.intType, []).integer;

  static final _id_setForegroundGravity =
      jniAccessors.getMethodIDOf(_classRef, "setForegroundGravity", "(I)V");

  /// from: public void setForegroundGravity(int gravity)
  ///
  /// Describes how the foreground is positioned. Defaults to START and TOP.
  ///@param gravity see android.view.Gravity
  ///@see \#getForegroundGravity()
  ///@attr ref android.R.styleable\#View_foregroundGravity
  void setForegroundGravity(int gravity) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setForegroundGravity,
      jni.JniType.voidType,
      [gravity]).check();

  static final _id_setForegroundTintList = jniAccessors.getMethodIDOf(_classRef,
      "setForegroundTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setForegroundTintList(android.content.res.ColorStateList tint)
  ///
  /// Applies a tint to the foreground drawable. Does not modify the current tint
  /// mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// Subsequent calls to \#setForeground(Drawable) will automatically
  /// mutate the drawable and apply the specified tint and tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_foregroundTint
  ///@see \#getForegroundTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  void setForegroundTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setForegroundTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_getForegroundTintList = jniAccessors.getMethodIDOf(_classRef,
      "getForegroundTintList", "()Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList getForegroundTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the tint applied to the foreground drawable, if specified.
  ///@return the tint applied to the foreground drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_foregroundTint
  ///@see \#setForegroundTintList(ColorStateList)
  colorstatelist_.ColorStateList getForegroundTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getForegroundTintList,
          jni.JniType.objectType, []).object);

  static final _id_setForegroundTintMode = jniAccessors.getMethodIDOf(_classRef,
      "setForegroundTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setForegroundTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setForegroundTintList(ColorStateList)} to the background
  /// drawable. The default mode is PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_foregroundTintMode
  ///@see \#getForegroundTintMode()
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  void setForegroundTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setForegroundTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_getForegroundTintMode = jniAccessors.getMethodIDOf(_classRef,
      "getForegroundTintMode", "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: public android.graphics.PorterDuff.Mode getForegroundTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the blending mode used to apply the tint to the foreground
  /// drawable, if specified.
  ///@return the blending mode used to apply the tint to the foreground
  ///         drawable
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#View_foregroundTintMode
  ///@see \#setForegroundTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getForegroundTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getForegroundTintMode,
          jni.JniType.objectType, []).object);

  static final _id_onDrawForeground = jniAccessors.getMethodIDOf(
      _classRef, "onDrawForeground", "(Landroid/graphics/Canvas;)V");

  /// from: public void onDrawForeground(android.graphics.Canvas canvas)
  ///
  /// Draw any foreground content for this view.
  ///
  /// Foreground content may consist of scroll bars, a \#setForeground foreground
  /// drawable or other view-specific decorations. The foreground is drawn on top of the
  /// primary view content.
  ///
  ///@param canvas canvas to draw into
  void onDrawForeground(canvas_.Canvas canvas) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDrawForeground,
          jni.JniType.voidType, [canvas.reference]).check();

  static final _id_setPadding =
      jniAccessors.getMethodIDOf(_classRef, "setPadding", "(IIII)V");

  /// from: public void setPadding(int left, int top, int right, int bottom)
  ///
  /// Sets the padding. The view may add on the space required to display
  /// the scrollbars, depending on the style and visibility of the scrollbars.
  /// So the values returned from \#getPaddingLeft, \#getPaddingTop,
  /// \#getPaddingRight and \#getPaddingBottom may be different
  /// from the values set in this call.
  ///@attr ref android.R.styleable\#View_padding
  ///@attr ref android.R.styleable\#View_paddingBottom
  ///@attr ref android.R.styleable\#View_paddingLeft
  ///@attr ref android.R.styleable\#View_paddingRight
  ///@attr ref android.R.styleable\#View_paddingTop
  ///@param left the left padding in pixels
  ///@param top the top padding in pixels
  ///@param right the right padding in pixels
  ///@param bottom the bottom padding in pixels
  void setPadding(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPadding,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_setPaddingRelative =
      jniAccessors.getMethodIDOf(_classRef, "setPaddingRelative", "(IIII)V");

  /// from: public void setPaddingRelative(int start, int top, int end, int bottom)
  ///
  /// Sets the relative padding. The view may add on the space required to display
  /// the scrollbars, depending on the style and visibility of the scrollbars.
  /// So the values returned from \#getPaddingStart, \#getPaddingTop,
  /// \#getPaddingEnd and \#getPaddingBottom may be different
  /// from the values set in this call.
  ///@attr ref android.R.styleable\#View_padding
  ///@attr ref android.R.styleable\#View_paddingBottom
  ///@attr ref android.R.styleable\#View_paddingStart
  ///@attr ref android.R.styleable\#View_paddingEnd
  ///@attr ref android.R.styleable\#View_paddingTop
  ///@param start the start padding in pixels
  ///@param top the top padding in pixels
  ///@param end the end padding in pixels
  ///@param bottom the bottom padding in pixels
  void setPaddingRelative(int start, int top, int end, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPaddingRelative,
          jni.JniType.voidType, [start, top, end, bottom]).check();

  static final _id_getPaddingTop =
      jniAccessors.getMethodIDOf(_classRef, "getPaddingTop", "()I");

  /// from: public int getPaddingTop()
  ///
  /// Returns the top padding of this view.
  ///@return the top padding in pixels
  int getPaddingTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getPaddingTop, jni.JniType.intType, []).integer;

  static final _id_getPaddingBottom =
      jniAccessors.getMethodIDOf(_classRef, "getPaddingBottom", "()I");

  /// from: public int getPaddingBottom()
  ///
  /// Returns the bottom padding of this view. If there are inset and enabled
  /// scrollbars, this value may include the space required to display the
  /// scrollbars as well.
  ///@return the bottom padding in pixels
  int getPaddingBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getPaddingBottom, jni.JniType.intType, []).integer;

  static final _id_getPaddingLeft =
      jniAccessors.getMethodIDOf(_classRef, "getPaddingLeft", "()I");

  /// from: public int getPaddingLeft()
  ///
  /// Returns the left padding of this view. If there are inset and enabled
  /// scrollbars, this value may include the space required to display the
  /// scrollbars as well.
  ///@return the left padding in pixels
  int getPaddingLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getPaddingLeft, jni.JniType.intType, []).integer;

  static final _id_getPaddingStart =
      jniAccessors.getMethodIDOf(_classRef, "getPaddingStart", "()I");

  /// from: public int getPaddingStart()
  ///
  /// Returns the start padding of this view depending on its resolved layout direction.
  /// If there are inset and enabled scrollbars, this value may include the space
  /// required to display the scrollbars as well.
  ///@return the start padding in pixels
  int getPaddingStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getPaddingStart, jni.JniType.intType, []).integer;

  static final _id_getPaddingRight =
      jniAccessors.getMethodIDOf(_classRef, "getPaddingRight", "()I");

  /// from: public int getPaddingRight()
  ///
  /// Returns the right padding of this view. If there are inset and enabled
  /// scrollbars, this value may include the space required to display the
  /// scrollbars as well.
  ///@return the right padding in pixels
  int getPaddingRight() => jniAccessors.callMethodWithArgs(
      reference, _id_getPaddingRight, jni.JniType.intType, []).integer;

  static final _id_getPaddingEnd =
      jniAccessors.getMethodIDOf(_classRef, "getPaddingEnd", "()I");

  /// from: public int getPaddingEnd()
  ///
  /// Returns the end padding of this view depending on its resolved layout direction.
  /// If there are inset and enabled scrollbars, this value may include the space
  /// required to display the scrollbars as well.
  ///@return the end padding in pixels
  int getPaddingEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getPaddingEnd, jni.JniType.intType, []).integer;

  static final _id_isPaddingRelative =
      jniAccessors.getMethodIDOf(_classRef, "isPaddingRelative", "()Z");

  /// from: public boolean isPaddingRelative()
  ///
  /// Return if the padding has been set through relative values
  /// \#setPaddingRelative(int, int, int, int) or through
  ///@attr ref android.R.styleable\#View_paddingStart or
  ///@attr ref android.R.styleable\#View_paddingEnd
  ///@return true if the padding is relative or false if it is not.
  bool isPaddingRelative() => jniAccessors.callMethodWithArgs(
      reference, _id_isPaddingRelative, jni.JniType.booleanType, []).boolean;

  static final _id_setSelected =
      jniAccessors.getMethodIDOf(_classRef, "setSelected", "(Z)V");

  /// from: public void setSelected(boolean selected)
  ///
  /// Changes the selection state of this view. A view can be selected or not.
  /// Note that selection is not the same as focus. Views are typically
  /// selected in the context of an AdapterView like ListView or GridView;
  /// the selected view is the view that is highlighted.
  ///@param selected true if the view must be selected, false otherwise
  void setSelected(bool selected) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelected, jni.JniType.voidType, [selected]).check();

  static final _id_dispatchSetSelected =
      jniAccessors.getMethodIDOf(_classRef, "dispatchSetSelected", "(Z)V");

  /// from: protected void dispatchSetSelected(boolean selected)
  ///
  /// Dispatch setSelected to all of this View's children.
  ///@see \#setSelected(boolean)
  ///@param selected The new selected state
  void dispatchSetSelected(bool selected) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchSetSelected,
      jni.JniType.voidType,
      [selected]).check();

  static final _id_isSelected =
      jniAccessors.getMethodIDOf(_classRef, "isSelected", "()Z");

  /// from: public boolean isSelected()
  ///
  /// Indicates the selection state of this view.
  ///@return true if the view is selected, false otherwise
  bool isSelected() => jniAccessors.callMethodWithArgs(
      reference, _id_isSelected, jni.JniType.booleanType, []).boolean;

  static final _id_setActivated =
      jniAccessors.getMethodIDOf(_classRef, "setActivated", "(Z)V");

  /// from: public void setActivated(boolean activated)
  ///
  /// Changes the activated state of this view. A view can be activated or not.
  /// Note that activation is not the same as selection.  Selection is
  /// a transient property, representing the view (hierarchy) the user is
  /// currently interacting with.  Activation is a longer-term state that the
  /// user can move views in and out of.  For example, in a list view with
  /// single or multiple selection enabled, the views in the current selection
  /// set are activated.  (Um, yeah, we are deeply sorry about the terminology
  /// here.)  The activated state is propagated down to children of the view it
  /// is set on.
  ///@param activated true if the view must be activated, false otherwise
  void setActivated(bool activated) => jniAccessors.callMethodWithArgs(
      reference, _id_setActivated, jni.JniType.voidType, [activated]).check();

  static final _id_dispatchSetActivated =
      jniAccessors.getMethodIDOf(_classRef, "dispatchSetActivated", "(Z)V");

  /// from: protected void dispatchSetActivated(boolean activated)
  ///
  /// Dispatch setActivated to all of this View's children.
  ///@see \#setActivated(boolean)
  ///@param activated The new activated state
  void dispatchSetActivated(bool activated) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchSetActivated,
      jni.JniType.voidType,
      [activated]).check();

  static final _id_isActivated =
      jniAccessors.getMethodIDOf(_classRef, "isActivated", "()Z");

  /// from: public boolean isActivated()
  ///
  /// Indicates the activation state of this view.
  ///@return true if the view is activated, false otherwise
  bool isActivated() => jniAccessors.callMethodWithArgs(
      reference, _id_isActivated, jni.JniType.booleanType, []).boolean;

  static final _id_getViewTreeObserver = jniAccessors.getMethodIDOf(
      _classRef, "getViewTreeObserver", "()Landroid/view/ViewTreeObserver;");

  /// from: public android.view.ViewTreeObserver getViewTreeObserver()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ViewTreeObserver for this view's hierarchy. The view tree
  /// observer can be used to get notifications when global events, like
  /// layout, happen.
  ///
  /// The returned ViewTreeObserver observer is not guaranteed to remain
  /// valid for the lifetime of this View. If the caller of this method keeps
  /// a long-lived reference to ViewTreeObserver, it should always check for
  /// the return value of ViewTreeObserver\#isAlive().
  ///@return The ViewTreeObserver for this view's hierarchy.
  viewtreeobserver_.ViewTreeObserver getViewTreeObserver() =>
      viewtreeobserver_.ViewTreeObserver.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getViewTreeObserver,
              jni.JniType.objectType, []).object);

  static final _id_getRootView = jniAccessors.getMethodIDOf(
      _classRef, "getRootView", "()Landroid/view/View;");

  /// from: public android.view.View getRootView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds the topmost view in the current view hierarchy.
  ///
  ///@return the topmost view containing this view
  View getRootView() => View.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getRootView, jni.JniType.objectType, []).object);

  static final _id_getLocationOnScreen =
      jniAccessors.getMethodIDOf(_classRef, "getLocationOnScreen", "([I)V");

  /// from: public void getLocationOnScreen(int[] outLocation)
  ///
  /// Computes the coordinates of this view on the screen. The argument
  /// must be an array of two integers. After the method returns, the array
  /// contains the x and y location in that order.
  ///
  ///@param outLocation an array of two integers in which to hold the coordinates
  void getLocationOnScreen(jni.JniObject outLocation) =>
      jniAccessors.callMethodWithArgs(reference, _id_getLocationOnScreen,
          jni.JniType.voidType, [outLocation.reference]).check();

  static final _id_getLocationInWindow =
      jniAccessors.getMethodIDOf(_classRef, "getLocationInWindow", "([I)V");

  /// from: public void getLocationInWindow(int[] outLocation)
  ///
  /// Computes the coordinates of this view in its window. The argument
  /// must be an array of two integers. After the method returns, the array
  /// contains the x and y location in that order.
  ///
  ///@param outLocation an array of two integers in which to hold the coordinates
  void getLocationInWindow(jni.JniObject outLocation) =>
      jniAccessors.callMethodWithArgs(reference, _id_getLocationInWindow,
          jni.JniType.voidType, [outLocation.reference]).check();

  static final _id_setId =
      jniAccessors.getMethodIDOf(_classRef, "setId", "(I)V");

  /// from: public void setId(int id)
  ///
  /// Sets the identifier for this view. The identifier does not have to be
  /// unique in this view's hierarchy. The identifier should be a positive
  /// number.
  ///@see \#NO_ID
  ///@see \#getId()
  ///@see \#findViewById(int)
  ///@param id a number used to identify the view
  ///@attr ref android.R.styleable\#View_id
  void setId(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_setId, jni.JniType.voidType, [id]).check();

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// Returns this view's identifier.
  ///@return a positive integer used to identify the view or \#NO_ID
  ///         if the view has no ID
  ///@see \#setId(int)
  ///@see \#findViewById(int)
  ///@attr ref android.R.styleable\#View_id
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Ljava/lang/Object;");

  /// from: public java.lang.Object getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns this view's tag.
  ///@return the Object stored in this view as a tag, or {@code null} if not
  ///         set
  ///@see \#setTag(Object)
  ///@see \#getTag(int)
  jni.JniObject getTag() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_setTag =
      jniAccessors.getMethodIDOf(_classRef, "setTag", "(Ljava/lang/Object;)V");

  /// from: public void setTag(java.lang.Object tag)
  ///
  /// Sets the tag associated with this view. A tag can be used to mark
  /// a view in its hierarchy and does not have to be unique within the
  /// hierarchy. Tags can also be used to store data within a view without
  /// resorting to another data structure.
  ///@param tag an Object to tag the view with
  ///@see \#getTag()
  ///@see \#setTag(int, Object)
  void setTag(jni.JniObject tag) => jniAccessors.callMethodWithArgs(
      reference, _id_setTag, jni.JniType.voidType, [tag.reference]).check();

  static final _id_getTag1 =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "(I)Ljava/lang/Object;");

  /// from: public java.lang.Object getTag(int key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the tag associated with this view and the specified key.
  ///@param key The key identifying the tag
  ///@return the Object stored in this view as a tag, or {@code null} if not
  ///         set
  ///@see \#setTag(int, Object)
  ///@see \#getTag()
  jni.JniObject getTag1(int key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTag1, jni.JniType.objectType, [key]).object);

  static final _id_setTag1 =
      jniAccessors.getMethodIDOf(_classRef, "setTag", "(ILjava/lang/Object;)V");

  /// from: public void setTag(int key, java.lang.Object tag)
  ///
  /// Sets a tag associated with this view and a key. A tag can be used
  /// to mark a view in its hierarchy and does not have to be unique within
  /// the hierarchy. Tags can also be used to store data within a view
  /// without resorting to another data structure.
  ///
  /// The specified key should be an id declared in the resources of the
  /// application to ensure it is unique (see the <a href="{@docRoot}guide/topics/resources/more-resources.html\#Id">ID resource type</a>).
  /// Keys identified as belonging to
  /// the Android framework or not associated with any package will cause
  /// an IllegalArgumentException to be thrown.
  ///@param key The key identifying the tag
  ///@param tag An Object to tag the view with
  ///@throws IllegalArgumentException If they specified key is not valid
  ///@see \#setTag(Object)
  ///@see \#getTag(int)
  void setTag1(int key, jni.JniObject tag) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTag1,
      jni.JniType.voidType,
      [key, tag.reference]).check();

  static final _id_getBaseline =
      jniAccessors.getMethodIDOf(_classRef, "getBaseline", "()I");

  /// from: public int getBaseline()
  ///
  /// Return the offset of the widget's text baseline from the widget's top
  /// boundary. If this widget does not support baseline alignment, this
  /// method returns -1.
  ///
  ///@return the offset of the baseline within the widget's bounds or -1
  ///         if baseline alignment is not supported
  int getBaseline() => jniAccessors.callMethodWithArgs(
      reference, _id_getBaseline, jni.JniType.intType, []).integer;

  static final _id_isInLayout =
      jniAccessors.getMethodIDOf(_classRef, "isInLayout", "()Z");

  /// from: public boolean isInLayout()
  ///
  /// Returns whether the view hierarchy is currently undergoing a layout pass. This
  /// information is useful to avoid situations such as calling \#requestLayout() during
  /// a layout pass.
  ///@return whether the view hierarchy is currently undergoing a layout pass
  bool isInLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_isInLayout, jni.JniType.booleanType, []).boolean;

  static final _id_requestLayout =
      jniAccessors.getMethodIDOf(_classRef, "requestLayout", "()V");

  /// from: public void requestLayout()
  ///
  /// Call this when something has changed which has invalidated the
  /// layout of this view. This will schedule a layout pass of the view
  /// tree. This should not be called while the view hierarchy is currently in a layout
  /// pass (\#isInLayout(). If layout is happening, the request may be honored at the
  /// end of the current layout pass (and then layout will run again) or after the current
  /// frame is drawn and the next layout occurs.
  ///
  /// Subclasses which override this method should call the superclass method to
  /// handle possible request-during-layout errors correctly.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void requestLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_requestLayout, jni.JniType.voidType, []).check();

  static final _id_forceLayout =
      jniAccessors.getMethodIDOf(_classRef, "forceLayout", "()V");

  /// from: public void forceLayout()
  ///
  /// Forces this view to be laid out during the next layout pass.
  /// This method does not call requestLayout() or forceLayout()
  /// on the parent.
  void forceLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_forceLayout, jni.JniType.voidType, []).check();

  static final _id_measure =
      jniAccessors.getMethodIDOf(_classRef, "measure", "(II)V");

  /// from: public final void measure(int widthMeasureSpec, int heightMeasureSpec)
  ///
  ///
  /// This is called to find out how big a view should be. The parent
  /// supplies constraint information in the width and height parameters.
  ///
  ///
  ///
  ///
  /// The actual measurement work of a view is performed in
  /// \#onMeasure(int, int), called by this method. Therefore, only
  /// \#onMeasure(int, int) can and must be overridden by subclasses.
  ///
  ///
  ///@param widthMeasureSpec Horizontal space requirements as imposed by the
  ///        parent
  ///@param heightMeasureSpec Vertical space requirements as imposed by the
  ///        parent
  ///@see \#onMeasure(int, int)
  void measure(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_measure,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_onMeasure =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  ///
  ///
  /// Measure the view and its content to determine the measured width and the
  /// measured height. This method is invoked by \#measure(int, int) and
  /// should be overridden by subclasses to provide accurate and efficient
  /// measurement of their contents.
  ///
  ///
  ///
  ///
  /// <strong>CONTRACT:</strong> When overriding this method, you
  /// _must_ call \#setMeasuredDimension(int, int) to store the
  /// measured width and height of this view. Failure to do so will trigger an
  /// <code>IllegalStateException</code>, thrown by
  /// \#measure(int, int). Calling the superclass'
  /// \#onMeasure(int, int) is a valid use.
  ///
  ///
  ///
  ///
  /// The base class implementation of measure defaults to the background size,
  /// unless a larger size is allowed by the MeasureSpec. Subclasses should
  /// override \#onMeasure(int, int) to provide better measurements of
  /// their content.
  ///
  ///
  ///
  ///
  /// If this method is overridden, it is the subclass's responsibility to make
  /// sure the measured height and width are at least the view's minimum height
  /// and width (\#getSuggestedMinimumHeight() and
  /// \#getSuggestedMinimumWidth()).
  ///
  ///
  ///@param widthMeasureSpec horizontal space requirements as imposed by the parent.
  ///                         The requirements are encoded with
  ///                         android.view.View.MeasureSpec.
  ///@param heightMeasureSpec vertical space requirements as imposed by the parent.
  ///                         The requirements are encoded with
  ///                         android.view.View.MeasureSpec.
  ///@see \#getMeasuredWidth()
  ///@see \#getMeasuredHeight()
  ///@see \#setMeasuredDimension(int, int)
  ///@see \#getSuggestedMinimumHeight()
  ///@see \#getSuggestedMinimumWidth()
  ///@see android.view.View.MeasureSpec\#getMode(int)
  ///@see android.view.View.MeasureSpec\#getSize(int)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_setMeasuredDimension =
      jniAccessors.getMethodIDOf(_classRef, "setMeasuredDimension", "(II)V");

  /// from: protected final void setMeasuredDimension(int measuredWidth, int measuredHeight)
  ///
  /// This method must be called by \#onMeasure(int, int) to store the
  /// measured width and measured height. Failing to do so will trigger an
  /// exception at measurement time.
  ///
  ///@param measuredWidth The measured width of this view.  May be a complex
  /// bit mask as defined by \#MEASURED_SIZE_MASK and
  /// \#MEASURED_STATE_TOO_SMALL.
  ///@param measuredHeight The measured height of this view.  May be a complex
  /// bit mask as defined by \#MEASURED_SIZE_MASK and
  /// \#MEASURED_STATE_TOO_SMALL.
  void setMeasuredDimension(int measuredWidth, int measuredHeight) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMeasuredDimension,
          jni.JniType.voidType, [measuredWidth, measuredHeight]).check();

  static final _id_combineMeasuredStates = jniAccessors.getStaticMethodIDOf(
      _classRef, "combineMeasuredStates", "(II)I");

  /// from: static public int combineMeasuredStates(int curState, int newState)
  ///
  /// Merge two states as returned by \#getMeasuredState().
  ///@param curState The current state as returned from a view or the result
  /// of combining multiple views.
  ///@param newState The new view state to combine.
  ///@return Returns a new integer reflecting the combination of the two
  /// states.
  static int combineMeasuredStates(int curState, int newState) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_combineMeasuredStates,
          jni.JniType.intType,
          [curState, newState]).integer;

  static final _id_resolveSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "resolveSize", "(II)I");

  /// from: static public int resolveSize(int size, int measureSpec)
  ///
  /// Version of \#resolveSizeAndState(int, int, int)
  /// returning only the \#MEASURED_SIZE_MASK bits of the result.
  static int resolveSize(int size, int measureSpec) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_resolveSize,
          jni.JniType.intType, [size, measureSpec]).integer;

  static final _id_resolveSizeAndState = jniAccessors.getStaticMethodIDOf(
      _classRef, "resolveSizeAndState", "(III)I");

  /// from: static public int resolveSizeAndState(int size, int measureSpec, int childMeasuredState)
  ///
  /// Utility to reconcile a desired size and state, with constraints imposed
  /// by a MeasureSpec. Will take the desired size, unless a different size
  /// is imposed by the constraints. The returned value is a compound integer,
  /// with the resolved size in the \#MEASURED_SIZE_MASK bits and
  /// optionally the bit \#MEASURED_STATE_TOO_SMALL set if the
  /// resulting size is smaller than the size the view wants to be.
  ///@param size How big the view wants to be.
  ///@param measureSpec Constraints imposed by the parent.
  ///@param childMeasuredState Size information bit mask for the view's
  ///                           children.
  ///@return Size information bit mask as defined by
  ///         \#MEASURED_SIZE_MASK and
  ///         \#MEASURED_STATE_TOO_SMALL.
  static int resolveSizeAndState(
          int size, int measureSpec, int childMeasuredState) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_resolveSizeAndState,
          jni.JniType.intType, [size, measureSpec, childMeasuredState]).integer;

  static final _id_getDefaultSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "getDefaultSize", "(II)I");

  /// from: static public int getDefaultSize(int size, int measureSpec)
  ///
  /// Utility to return a default size. Uses the supplied size if the
  /// MeasureSpec imposed no constraints. Will get larger if allowed
  /// by the MeasureSpec.
  ///@param size Default size for this view
  ///@param measureSpec Constraints imposed by the parent
  ///@return The size this view should be.
  static int getDefaultSize(int size, int measureSpec) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getDefaultSize,
          jni.JniType.intType, [size, measureSpec]).integer;

  static final _id_getSuggestedMinimumHeight =
      jniAccessors.getMethodIDOf(_classRef, "getSuggestedMinimumHeight", "()I");

  /// from: protected int getSuggestedMinimumHeight()
  ///
  /// Returns the suggested minimum height that the view should use. This
  /// returns the maximum of the view's minimum height
  /// and the background's minimum height
  /// (android.graphics.drawable.Drawable\#getMinimumHeight()).
  ///
  /// When being used in \#onMeasure(int, int), the caller should still
  /// ensure the returned height is within the requirements of the parent.
  ///@return The suggested minimum height of the view.
  int getSuggestedMinimumHeight() => jniAccessors.callMethodWithArgs(reference,
      _id_getSuggestedMinimumHeight, jni.JniType.intType, []).integer;

  static final _id_getSuggestedMinimumWidth =
      jniAccessors.getMethodIDOf(_classRef, "getSuggestedMinimumWidth", "()I");

  /// from: protected int getSuggestedMinimumWidth()
  ///
  /// Returns the suggested minimum width that the view should use. This
  /// returns the maximum of the view's minimum width
  /// and the background's minimum width
  ///  (android.graphics.drawable.Drawable\#getMinimumWidth()).
  ///
  /// When being used in \#onMeasure(int, int), the caller should still
  /// ensure the returned width is within the requirements of the parent.
  ///@return The suggested minimum width of the view.
  int getSuggestedMinimumWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getSuggestedMinimumWidth, jni.JniType.intType, []).integer;

  static final _id_getMinimumHeight =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumHeight", "()I");

  /// from: public int getMinimumHeight()
  ///
  /// Returns the minimum height of the view.
  ///@return the minimum height the view will try to be, in pixels
  ///@see \#setMinimumHeight(int)
  ///@attr ref android.R.styleable\#View_minHeight
  int getMinimumHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumHeight, jni.JniType.intType, []).integer;

  static final _id_setMinimumHeight =
      jniAccessors.getMethodIDOf(_classRef, "setMinimumHeight", "(I)V");

  /// from: public void setMinimumHeight(int minHeight)
  ///
  /// Sets the minimum height of the view. It is not guaranteed the view will
  /// be able to achieve this minimum height (for example, if its parent layout
  /// constrains it with less available height).
  ///@param minHeight The minimum height the view will try to be, in pixels
  ///@see \#getMinimumHeight()
  ///@attr ref android.R.styleable\#View_minHeight
  void setMinimumHeight(int minHeight) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMinimumHeight,
      jni.JniType.voidType,
      [minHeight]).check();

  static final _id_getMinimumWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumWidth", "()I");

  /// from: public int getMinimumWidth()
  ///
  /// Returns the minimum width of the view.
  ///@return the minimum width the view will try to be, in pixels
  ///@see \#setMinimumWidth(int)
  ///@attr ref android.R.styleable\#View_minWidth
  int getMinimumWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumWidth, jni.JniType.intType, []).integer;

  static final _id_setMinimumWidth =
      jniAccessors.getMethodIDOf(_classRef, "setMinimumWidth", "(I)V");

  /// from: public void setMinimumWidth(int minWidth)
  ///
  /// Sets the minimum width of the view. It is not guaranteed the view will
  /// be able to achieve this minimum width (for example, if its parent layout
  /// constrains it with less available width).
  ///@param minWidth The minimum width the view will try to be, in pixels
  ///@see \#getMinimumWidth()
  ///@attr ref android.R.styleable\#View_minWidth
  void setMinimumWidth(int minWidth) => jniAccessors.callMethodWithArgs(
      reference, _id_setMinimumWidth, jni.JniType.voidType, [minWidth]).check();

  static final _id_getAnimation = jniAccessors.getMethodIDOf(
      _classRef, "getAnimation", "()Landroid/view/animation/Animation;");

  /// from: public android.view.animation.Animation getAnimation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the animation currently associated with this view.
  ///@return The animation that is currently playing or
  ///         scheduled to play for this view.
  animation_.Animation getAnimation() =>
      animation_.Animation.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAnimation, jni.JniType.objectType, []).object);

  static final _id_startAnimation = jniAccessors.getMethodIDOf(
      _classRef, "startAnimation", "(Landroid/view/animation/Animation;)V");

  /// from: public void startAnimation(android.view.animation.Animation animation)
  ///
  /// Start the specified animation now.
  ///@param animation the animation to start now
  void startAnimation(animation_.Animation animation) =>
      jniAccessors.callMethodWithArgs(reference, _id_startAnimation,
          jni.JniType.voidType, [animation.reference]).check();

  static final _id_clearAnimation =
      jniAccessors.getMethodIDOf(_classRef, "clearAnimation", "()V");

  /// from: public void clearAnimation()
  ///
  /// Cancels any animations for this view.
  void clearAnimation() => jniAccessors.callMethodWithArgs(
      reference, _id_clearAnimation, jni.JniType.voidType, []).check();

  static final _id_setAnimation = jniAccessors.getMethodIDOf(
      _classRef, "setAnimation", "(Landroid/view/animation/Animation;)V");

  /// from: public void setAnimation(android.view.animation.Animation animation)
  ///
  /// Sets the next animation to play for this view.
  /// If you want the animation to play immediately, use
  /// \#startAnimation(android.view.animation.Animation) instead.
  /// This method provides allows fine-grained
  /// control over the start time and invalidation, but you
  /// must make sure that 1) the animation has a start time set, and
  /// 2) the view's parent (which controls animations on its children)
  /// will be invalidated when the animation is supposed to
  /// start.
  ///@param animation The next animation, or null.
  void setAnimation(animation_.Animation animation) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAnimation,
          jni.JniType.voidType, [animation.reference]).check();

  static final _id_onAnimationStart =
      jniAccessors.getMethodIDOf(_classRef, "onAnimationStart", "()V");

  /// from: protected void onAnimationStart()
  ///
  /// Invoked by a parent ViewGroup to notify the start of the animation
  /// currently associated with this view. If you override this method,
  /// always call super.onAnimationStart();
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#setAnimation(android.view.animation.Animation)
  ///@see \#getAnimation()
  void onAnimationStart() => jniAccessors.callMethodWithArgs(
      reference, _id_onAnimationStart, jni.JniType.voidType, []).check();

  static final _id_onAnimationEnd =
      jniAccessors.getMethodIDOf(_classRef, "onAnimationEnd", "()V");

  /// from: protected void onAnimationEnd()
  ///
  /// Invoked by a parent ViewGroup to notify the end of the animation
  /// currently associated with this view. If you override this method,
  /// always call super.onAnimationEnd();
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#setAnimation(android.view.animation.Animation)
  ///@see \#getAnimation()
  void onAnimationEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_onAnimationEnd, jni.JniType.voidType, []).check();

  static final _id_onSetAlpha =
      jniAccessors.getMethodIDOf(_classRef, "onSetAlpha", "(I)Z");

  /// from: protected boolean onSetAlpha(int alpha)
  ///
  /// Invoked if there is a Transform that involves alpha. Subclass that can
  /// draw themselves with the specified alpha should return true, and then
  /// respect that alpha when their onDraw() is called. If this returns false
  /// then the view may be redirected to draw into an offscreen buffer to
  /// fulfill the request, which will look fine, but may be slower than if the
  /// subclass handles it internally. The default implementation returns false.
  ///@param alpha The alpha (0..255) to apply to the view's drawing
  ///@return true if the view can draw with the specified alpha.
  bool onSetAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_onSetAlpha, jni.JniType.booleanType, [alpha]).boolean;

  static final _id_playSoundEffect =
      jniAccessors.getMethodIDOf(_classRef, "playSoundEffect", "(I)V");

  /// from: public void playSoundEffect(int soundConstant)
  ///
  /// Play a sound effect for this view.
  ///
  /// The framework will play sound effects for some built in actions, such as
  /// clicking, but you may wish to play these effects in your widget,
  /// for instance, for internal navigation.
  ///
  /// The sound effect will only be played if sound effects are enabled by the user, and
  /// \#isSoundEffectsEnabled() is true.
  ///@param soundConstant One of the constants defined in SoundEffectConstants
  void playSoundEffect(int soundConstant) => jniAccessors.callMethodWithArgs(
      reference,
      _id_playSoundEffect,
      jni.JniType.voidType,
      [soundConstant]).check();

  static final _id_performHapticFeedback =
      jniAccessors.getMethodIDOf(_classRef, "performHapticFeedback", "(I)Z");

  /// from: public boolean performHapticFeedback(int feedbackConstant)
  ///
  /// BZZZTT!!1!
  ///
  /// Provide haptic feedback to the user for this view.
  ///
  /// The framework will provide haptic feedback for some built in actions,
  /// such as long presses, but you may wish to provide feedback for your
  /// own widget.
  ///
  /// The feedback will only be performed if
  /// \#isHapticFeedbackEnabled() is true.
  ///@param feedbackConstant One of the constants defined in
  /// HapticFeedbackConstants
  bool performHapticFeedback(int feedbackConstant) =>
      jniAccessors.callMethodWithArgs(reference, _id_performHapticFeedback,
          jni.JniType.booleanType, [feedbackConstant]).boolean;

  static final _id_performHapticFeedback1 =
      jniAccessors.getMethodIDOf(_classRef, "performHapticFeedback", "(II)Z");

  /// from: public boolean performHapticFeedback(int feedbackConstant, int flags)
  ///
  /// BZZZTT!!1!
  ///
  /// Like \#performHapticFeedback(int), with additional options.
  ///@param feedbackConstant One of the constants defined in
  /// HapticFeedbackConstants
  ///@param flags Additional flags as per HapticFeedbackConstants.
  bool performHapticFeedback1(int feedbackConstant, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_performHapticFeedback1,
          jni.JniType.booleanType, [feedbackConstant, flags]).boolean;

  static final _id_setSystemUiVisibility =
      jniAccessors.getMethodIDOf(_classRef, "setSystemUiVisibility", "(I)V");

  /// from: public void setSystemUiVisibility(int visibility)
  ///
  /// Request that the visibility of the status bar or other screen/window
  /// decorations be changed.
  ///
  /// This method is used to put the over device UI into temporary modes
  /// where the user's attention is focused more on the application content,
  /// by dimming or hiding surrounding system affordances.  This is typically
  /// used in conjunction with Window\#FEATURE_ACTION_BAR_OVERLAY Window.FEATURE_ACTION_BAR_OVERLAY, allowing the applications content
  /// to be placed behind the action bar (and with these flags other system
  /// affordances) so that smooth transitions between hiding and showing them
  /// can be done.
  ///
  /// Two representative examples of the use of system UI visibility is
  /// implementing a content browsing application (like a magazine reader)
  /// and a video playing application.
  ///
  /// The first code shows a typical implementation of a View in a content
  /// browsing application.  In this implementation, the application goes
  /// into a content-oriented mode by hiding the status bar and action bar,
  /// and putting the navigation elements into lights out mode.  The user can
  /// then interact with content while in this mode.  Such an application should
  /// provide an easy way for the user to toggle out of the mode (such as to
  /// check information in the status bar or access notifications).  In the
  /// implementation here, this is done simply by tapping on the content.
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
  ///      content}
  ///
  /// This second code sample shows a typical implementation of a View
  /// in a video playing application.  In this situation, while the video is
  /// playing the application would like to go into a complete full-screen mode,
  /// to use as much of the display as possible for the video.  When in this state
  /// the user can not interact with the application; the system intercepts
  /// touching on the screen to pop the UI out of full screen mode.  See
  /// \#fitSystemWindows(Rect) for a sample layout that goes with this code.
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
  ///      content}
  ///@param visibility Bitwise-or of flags \#SYSTEM_UI_FLAG_LOW_PROFILE,
  /// \#SYSTEM_UI_FLAG_HIDE_NAVIGATION, \#SYSTEM_UI_FLAG_FULLSCREEN,
  /// \#SYSTEM_UI_FLAG_LAYOUT_STABLE, \#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION,
  /// \#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN, \#SYSTEM_UI_FLAG_IMMERSIVE,
  /// and \#SYSTEM_UI_FLAG_IMMERSIVE_STICKY.
  void setSystemUiVisibility(int visibility) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSystemUiVisibility,
      jni.JniType.voidType,
      [visibility]).check();

  static final _id_getSystemUiVisibility =
      jniAccessors.getMethodIDOf(_classRef, "getSystemUiVisibility", "()I");

  /// from: public int getSystemUiVisibility()
  ///
  /// Returns the last \#setSystemUiVisibility(int) that this view has requested.
  ///@return Bitwise-or of flags \#SYSTEM_UI_FLAG_LOW_PROFILE,
  /// \#SYSTEM_UI_FLAG_HIDE_NAVIGATION, \#SYSTEM_UI_FLAG_FULLSCREEN,
  /// \#SYSTEM_UI_FLAG_LAYOUT_STABLE, \#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION,
  /// \#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN, \#SYSTEM_UI_FLAG_IMMERSIVE,
  /// and \#SYSTEM_UI_FLAG_IMMERSIVE_STICKY.
  int getSystemUiVisibility() => jniAccessors.callMethodWithArgs(
      reference, _id_getSystemUiVisibility, jni.JniType.intType, []).integer;

  static final _id_getWindowSystemUiVisibility = jniAccessors.getMethodIDOf(
      _classRef, "getWindowSystemUiVisibility", "()I");

  /// from: public int getWindowSystemUiVisibility()
  ///
  /// Returns the current system UI visibility that is currently set for
  /// the entire window.  This is the combination of the
  /// \#setSystemUiVisibility(int) values supplied by all of the
  /// views in the window.
  int getWindowSystemUiVisibility() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getWindowSystemUiVisibility,
      jni.JniType.intType, []).integer;

  static final _id_onWindowSystemUiVisibilityChanged = jniAccessors
      .getMethodIDOf(_classRef, "onWindowSystemUiVisibilityChanged", "(I)V");

  /// from: public void onWindowSystemUiVisibilityChanged(int visible)
  ///
  /// Override to find out when the window's requested system UI visibility
  /// has changed, that is the value returned by \#getWindowSystemUiVisibility().
  /// This is different from the callbacks received through
  /// \#setOnSystemUiVisibilityChangeListener(OnSystemUiVisibilityChangeListener)
  /// in that this is only telling you about the local request of the window,
  /// not the actual values applied by the system.
  void onWindowSystemUiVisibilityChanged(int visible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowSystemUiVisibilityChanged,
          jni.JniType.voidType,
          [visible]).check();

  static final _id_dispatchWindowSystemUiVisiblityChanged =
      jniAccessors.getMethodIDOf(
          _classRef, "dispatchWindowSystemUiVisiblityChanged", "(I)V");

  /// from: public void dispatchWindowSystemUiVisiblityChanged(int visible)
  ///
  /// Dispatch callbacks to \#onWindowSystemUiVisibilityChanged(int) down
  /// the view hierarchy.
  void dispatchWindowSystemUiVisiblityChanged(int visible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchWindowSystemUiVisiblityChanged,
          jni.JniType.voidType,
          [visible]).check();

  static final _id_setOnSystemUiVisibilityChangeListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setOnSystemUiVisibilityChangeListener",
          "(Landroid/view/View\$OnSystemUiVisibilityChangeListener;)V");

  /// from: public void setOnSystemUiVisibilityChangeListener(android.view.View.OnSystemUiVisibilityChangeListener l)
  ///
  /// Set a listener to receive callbacks when the visibility of the system bar changes.
  ///@param l The OnSystemUiVisibilityChangeListener to receive callbacks.
  void setOnSystemUiVisibilityChangeListener(
          View_OnSystemUiVisibilityChangeListener l) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnSystemUiVisibilityChangeListener,
          jni.JniType.voidType,
          [l.reference]).check();

  static final _id_dispatchSystemUiVisibilityChanged = jniAccessors
      .getMethodIDOf(_classRef, "dispatchSystemUiVisibilityChanged", "(I)V");

  /// from: public void dispatchSystemUiVisibilityChanged(int visibility)
  ///
  /// Dispatch callbacks to \#setOnSystemUiVisibilityChangeListener down
  /// the view hierarchy.
  void dispatchSystemUiVisibilityChanged(int visibility) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchSystemUiVisibilityChanged,
          jni.JniType.voidType,
          [visibility]).check();

  static final _id_startDrag = jniAccessors.getMethodIDOf(
      _classRef,
      "startDrag",
      "(Landroid/content/ClipData;Landroid/view/View\$DragShadowBuilder;Ljava/lang/Object;I)Z");

  /// from: public final boolean startDrag(android.content.ClipData data, android.view.View.DragShadowBuilder shadowBuilder, java.lang.Object myLocalState, int flags)
  ///
  /// @deprecated Use \#startDragAndDrop(ClipData, DragShadowBuilder, Object, int) startDragAndDrop() for newer platform versions.
  bool startDrag(clipdata_.ClipData data, View_DragShadowBuilder shadowBuilder,
          jni.JniObject myLocalState, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startDrag, jni.JniType.booleanType, [
        data.reference,
        shadowBuilder.reference,
        myLocalState.reference,
        flags
      ]).boolean;

  static final _id_startDragAndDrop = jniAccessors.getMethodIDOf(
      _classRef,
      "startDragAndDrop",
      "(Landroid/content/ClipData;Landroid/view/View\$DragShadowBuilder;Ljava/lang/Object;I)Z");

  /// from: public final boolean startDragAndDrop(android.content.ClipData data, android.view.View.DragShadowBuilder shadowBuilder, java.lang.Object myLocalState, int flags)
  ///
  /// Starts a drag and drop operation. When your application calls this method, it passes a
  /// android.view.View.DragShadowBuilder object to the system. The
  /// system calls this object's DragShadowBuilder\#onProvideShadowMetrics(Point, Point)
  /// to get metrics for the drag shadow, and then calls the object's
  /// DragShadowBuilder\#onDrawShadow(Canvas) to draw the drag shadow itself.
  ///
  ///  Once the system has the drag shadow, it begins the drag and drop operation by sending
  ///  drag events to all the View objects in your application that are currently visible. It does
  ///  this either by calling the View object's drag listener (an implementation of
  ///  android.view.View.OnDragListener\#onDrag(View,DragEvent) onDrag() or by calling the
  ///  View object's android.view.View\#onDragEvent(DragEvent) onDragEvent() method.
  ///  Both are passed a android.view.DragEvent object that has a
  ///  android.view.DragEvent\#getAction() value of
  ///  android.view.DragEvent\#ACTION_DRAG_STARTED.
  ///
  ///
  ///
  /// Your application can invoke \#startDragAndDrop(ClipData, DragShadowBuilder, Object,
  /// int) startDragAndDrop() on any attached View object. The View object does not need to be
  /// the one used in android.view.View.DragShadowBuilder, nor does it need to be related
  /// to the View the user selected for dragging.
  ///
  ///
  ///@param data A android.content.ClipData object pointing to the data to be
  /// transferred by the drag and drop operation.
  ///@param shadowBuilder A android.view.View.DragShadowBuilder object for building the
  /// drag shadow.
  ///@param myLocalState An java.lang.Object containing local data about the drag and
  /// drop operation. When dispatching drag events to views in the same activity this object
  /// will be available through android.view.DragEvent\#getLocalState(). Views in other
  /// activities will not have access to this data (android.view.DragEvent\#getLocalState()
  /// will return null).
  ///
  /// myLocalState is a lightweight mechanism for the sending information from the dragged View
  /// to the target Views. For example, it can contain flags that differentiate between a
  /// a copy operation and a move operation.
  ///
  ///
  ///@param flags Flags that control the drag and drop operation. This can be set to 0 for no
  /// flags, or any combination of the following:
  ///     <ul>
  ///         <li>\#DRAG_FLAG_GLOBAL</li>
  ///         <li>\#DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION</li>
  ///         <li>\#DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION</li>
  ///         <li>\#DRAG_FLAG_GLOBAL_URI_READ</li>
  ///         <li>\#DRAG_FLAG_GLOBAL_URI_WRITE</li>
  ///         <li>\#DRAG_FLAG_OPAQUE</li>
  ///     </ul>
  ///@return {@code true} if the method completes successfully, or
  /// {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
  /// do a drag, and so no drag operation is in progress.
  bool startDragAndDrop(
          clipdata_.ClipData data,
          View_DragShadowBuilder shadowBuilder,
          jni.JniObject myLocalState,
          int flags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startDragAndDrop, jni.JniType.booleanType, [
        data.reference,
        shadowBuilder.reference,
        myLocalState.reference,
        flags
      ]).boolean;

  static final _id_cancelDragAndDrop =
      jniAccessors.getMethodIDOf(_classRef, "cancelDragAndDrop", "()V");

  /// from: public final void cancelDragAndDrop()
  ///
  /// Cancels an ongoing drag and drop operation.
  ///
  /// A android.view.DragEvent object with
  /// android.view.DragEvent\#getAction() value of
  /// android.view.DragEvent\#ACTION_DRAG_ENDED and
  /// android.view.DragEvent\#getResult() value of {@code false}
  /// will be sent to every
  /// View that received android.view.DragEvent\#ACTION_DRAG_STARTED
  /// even if they are not currently visible.
  ///
  ///
  ///
  /// This method can be called on any View in the same window as the View on which
  /// \#startDragAndDrop(ClipData, DragShadowBuilder, Object, int) startDragAndDrop
  /// was called.
  ///
  ///
  void cancelDragAndDrop() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelDragAndDrop, jni.JniType.voidType, []).check();

  static final _id_updateDragShadow = jniAccessors.getMethodIDOf(_classRef,
      "updateDragShadow", "(Landroid/view/View\$DragShadowBuilder;)V");

  /// from: public final void updateDragShadow(android.view.View.DragShadowBuilder shadowBuilder)
  ///
  /// Updates the drag shadow for the ongoing drag and drop operation.
  ///@param shadowBuilder A android.view.View.DragShadowBuilder object for building the
  /// new drag shadow.
  void updateDragShadow(View_DragShadowBuilder shadowBuilder) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateDragShadow,
          jni.JniType.voidType, [shadowBuilder.reference]).check();

  static final _id_onDragEvent = jniAccessors.getMethodIDOf(
      _classRef, "onDragEvent", "(Landroid/view/DragEvent;)Z");

  /// from: public boolean onDragEvent(android.view.DragEvent event)
  ///
  /// Handles drag events sent by the system following a call to
  /// android.view.View\#startDragAndDrop(ClipData,DragShadowBuilder,Object,int) startDragAndDrop().
  ///
  /// When the system calls this method, it passes a
  /// android.view.DragEvent object. A call to
  /// android.view.DragEvent\#getAction() returns one of the action type constants defined
  /// in DragEvent. The method uses these to determine what is happening in the drag and drop
  /// operation.
  ///@param event The android.view.DragEvent sent by the system.
  /// The android.view.DragEvent\#getAction() method returns an action type constant defined
  /// in DragEvent, indicating the type of drag event represented by this object.
  ///@return {@code true} if the method was successful, otherwise {@code false}.
  ///
  ///  The method should return {@code true} in response to an action type of
  ///  android.view.DragEvent\#ACTION_DRAG_STARTED to receive drag events for the current
  ///  operation.
  ///
  ///
  ///
  ///  The method should also return {@code true} in response to an action type of
  ///  android.view.DragEvent\#ACTION_DROP if it consumed the drop, or
  ///  {@code false} if it didn't.
  ///
  ///
  ///
  ///  For all other events, the return value is ignored.
  ///
  ///
  bool onDragEvent(dragevent_.DragEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDragEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchDragEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDragEvent", "(Landroid/view/DragEvent;)Z");

  /// from: public boolean dispatchDragEvent(android.view.DragEvent event)
  ///
  /// Detects if this View is enabled and has a drag event listener.
  /// If both are true, then it calls the drag event listener with the
  /// android.view.DragEvent it received. If the drag event listener returns
  /// {@code true}, then dispatchDragEvent() returns {@code true}.
  ///
  /// For all other cases, the method calls the
  /// android.view.View\#onDragEvent(DragEvent) onDragEvent() drag event handler
  /// method and returns its result.
  ///
  ///
  ///
  /// This ensures that a drag event is always consumed, even if the View does not have a drag
  /// event listener. However, if the View has a listener and the listener returns true, then
  /// onDragEvent() is not called.
  ///
  ///
  bool dispatchDragEvent(dragevent_.DragEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchDragEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_inflate = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "inflate",
      "(Landroid/content/Context;ILandroid/view/ViewGroup;)Landroid/view/View;");

  /// from: static public android.view.View inflate(android.content.Context context, int resource, android.view.ViewGroup root)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inflate a view from an XML resource.  This convenience method wraps the LayoutInflater class, which provides a full range of options for view inflation.
  ///@param context The Context object for your activity or application.
  ///@param resource The resource ID to inflate
  ///@param root A view group that will be the parent.  Used to properly inflate the
  /// layout_* parameters.
  ///@see LayoutInflater
  static View inflate(
          context_.Context context, int resource, viewgroup_.ViewGroup root) =>
      View.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_inflate,
          jni.JniType.objectType,
          [context.reference, resource, root.reference]).object);

  static final _id_overScrollBy =
      jniAccessors.getMethodIDOf(_classRef, "overScrollBy", "(IIIIIIIIZ)Z");

  /// from: protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent)
  ///
  /// Scroll the view with standard behavior for scrolling beyond the normal
  /// content boundaries. Views that call this method should override
  /// \#onOverScrolled(int, int, boolean, boolean) to respond to the
  /// results of an over-scroll operation.
  ///
  /// Views can use this method to handle any touch or fling-based scrolling.
  ///@param deltaX Change in X in pixels
  ///@param deltaY Change in Y in pixels
  ///@param scrollX Current X scroll value in pixels before applying deltaX
  ///@param scrollY Current Y scroll value in pixels before applying deltaY
  ///@param scrollRangeX Maximum content scroll range along the X axis
  ///@param scrollRangeY Maximum content scroll range along the Y axis
  ///@param maxOverScrollX Number of pixels to overscroll by in either direction
  ///          along the X axis.
  ///@param maxOverScrollY Number of pixels to overscroll by in either direction
  ///          along the Y axis.
  ///@param isTouchEvent true if this scroll operation is the result of a touch event.
  ///@return true if scrolling was clamped to an over-scroll boundary along either
  ///          axis, false otherwise.
  bool overScrollBy(
          int deltaX,
          int deltaY,
          int scrollX,
          int scrollY,
          int scrollRangeX,
          int scrollRangeY,
          int maxOverScrollX,
          int maxOverScrollY,
          bool isTouchEvent) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_overScrollBy, jni.JniType.booleanType, [
        deltaX,
        deltaY,
        scrollX,
        scrollY,
        scrollRangeX,
        scrollRangeY,
        maxOverScrollX,
        maxOverScrollY,
        isTouchEvent
      ]).boolean;

  static final _id_onOverScrolled =
      jniAccessors.getMethodIDOf(_classRef, "onOverScrolled", "(IIZZ)V");

  /// from: protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)
  ///
  /// Called by \#overScrollBy(int, int, int, int, int, int, int, int, boolean) to
  /// respond to the results of an over-scroll operation.
  ///@param scrollX New X scroll value in pixels
  ///@param scrollY New Y scroll value in pixels
  ///@param clampedX True if scrollX was clamped to an over-scroll boundary
  ///@param clampedY True if scrollY was clamped to an over-scroll boundary
  void onOverScrolled(int scrollX, int scrollY, bool clampedX, bool clampedY) =>
      jniAccessors.callMethodWithArgs(reference, _id_onOverScrolled,
          jni.JniType.voidType, [scrollX, scrollY, clampedX, clampedY]).check();

  static final _id_getOverScrollMode =
      jniAccessors.getMethodIDOf(_classRef, "getOverScrollMode", "()I");

  /// from: public int getOverScrollMode()
  ///
  /// Returns the over-scroll mode for this view. The result will be
  /// one of \#OVER_SCROLL_ALWAYS (default), \#OVER_SCROLL_IF_CONTENT_SCROLLS
  /// (allow over-scrolling only if the view content is larger than the container),
  /// or \#OVER_SCROLL_NEVER.
  ///@return This view's over-scroll mode.
  int getOverScrollMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getOverScrollMode, jni.JniType.intType, []).integer;

  static final _id_setOverScrollMode =
      jniAccessors.getMethodIDOf(_classRef, "setOverScrollMode", "(I)V");

  /// from: public void setOverScrollMode(int overScrollMode)
  ///
  /// Set the over-scroll mode for this view. Valid over-scroll modes are
  /// \#OVER_SCROLL_ALWAYS (default), \#OVER_SCROLL_IF_CONTENT_SCROLLS
  /// (allow over-scrolling only if the view content is larger than the container),
  /// or \#OVER_SCROLL_NEVER.
  ///
  /// Setting the over-scroll mode of a view will have an effect only if the
  /// view is capable of scrolling.
  ///@param overScrollMode The new over-scroll mode for this view.
  void setOverScrollMode(int overScrollMode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOverScrollMode,
      jni.JniType.voidType,
      [overScrollMode]).check();

  static final _id_setNestedScrollingEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setNestedScrollingEnabled", "(Z)V");

  /// from: public void setNestedScrollingEnabled(boolean enabled)
  ///
  /// Enable or disable nested scrolling for this view.
  ///
  /// If this property is set to true the view will be permitted to initiate nested
  /// scrolling operations with a compatible parent view in the current hierarchy. If this
  /// view does not implement nested scrolling this will have no effect. Disabling nested scrolling
  /// while a nested scroll is in progress has the effect of \#stopNestedScroll() stopping
  /// the nested scroll.
  ///
  ///@param enabled true to enable nested scrolling, false to disable
  ///@see \#isNestedScrollingEnabled()
  void setNestedScrollingEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNestedScrollingEnabled,
          jni.JniType.voidType, [enabled]).check();

  static final _id_isNestedScrollingEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isNestedScrollingEnabled", "()Z");

  /// from: public boolean isNestedScrollingEnabled()
  ///
  /// Returns true if nested scrolling is enabled for this view.
  ///
  /// If nested scrolling is enabled and this View class implementation supports it,
  /// this view will act as a nested scrolling child view when applicable, forwarding data
  /// about the scroll operation in progress to a compatible and cooperating nested scrolling
  /// parent.
  ///
  ///@return true if nested scrolling is enabled
  ///@see \#setNestedScrollingEnabled(boolean)
  bool isNestedScrollingEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isNestedScrollingEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_startNestedScroll =
      jniAccessors.getMethodIDOf(_classRef, "startNestedScroll", "(I)Z");

  /// from: public boolean startNestedScroll(int axes)
  ///
  /// Begin a nestable scroll operation along the given axes.
  ///
  /// A view starting a nested scroll promises to abide by the following contract:
  ///
  ///
  /// The view will call startNestedScroll upon initiating a scroll operation. In the case
  /// of a touch scroll this corresponds to the initial MotionEvent\#ACTION_DOWN.
  /// In the case of touch scrolling the nested scroll will be terminated automatically in
  /// the same manner as ViewParent\#requestDisallowInterceptTouchEvent(boolean).
  /// In the event of programmatic scrolling the caller must explicitly call
  /// \#stopNestedScroll() to indicate the end of the nested scroll.
  ///
  ///
  /// If <code>startNestedScroll</code> returns true, a cooperative parent was found.
  /// If it returns false the caller may ignore the rest of this contract until the next scroll.
  /// Calling startNestedScroll while a nested scroll is already in progress will return true.
  ///
  ///
  /// At each incremental step of the scroll the caller should invoke
  /// \#dispatchNestedPreScroll(int, int, int[], int[]) dispatchNestedPreScroll
  /// once it has calculated the requested scrolling delta. If it returns true the nested scrolling
  /// parent at least partially consumed the scroll and the caller should adjust the amount it
  /// scrolls by.
  ///
  ///
  /// After applying the remainder of the scroll delta the caller should invoke
  /// \#dispatchNestedScroll(int, int, int, int, int[]) dispatchNestedScroll, passing
  /// both the delta consumed and the delta unconsumed. A nested scrolling parent may treat
  /// these values differently. See ViewParent\#onNestedScroll(View, int, int, int, int).
  ///
  ///
  ///@param axes Flags consisting of a combination of \#SCROLL_AXIS_HORIZONTAL and/or
  ///             \#SCROLL_AXIS_VERTICAL.
  ///@return true if a cooperative parent was found and nested scrolling has been enabled for
  ///         the current gesture.
  ///@see \#stopNestedScroll()
  ///@see \#dispatchNestedPreScroll(int, int, int[], int[])
  ///@see \#dispatchNestedScroll(int, int, int, int, int[])
  bool startNestedScroll(int axes) => jniAccessors.callMethodWithArgs(reference,
      _id_startNestedScroll, jni.JniType.booleanType, [axes]).boolean;

  static final _id_stopNestedScroll =
      jniAccessors.getMethodIDOf(_classRef, "stopNestedScroll", "()V");

  /// from: public void stopNestedScroll()
  ///
  /// Stop a nested scroll in progress.
  ///
  /// Calling this method when a nested scroll is not currently in progress is harmless.
  ///
  ///@see \#startNestedScroll(int)
  void stopNestedScroll() => jniAccessors.callMethodWithArgs(
      reference, _id_stopNestedScroll, jni.JniType.voidType, []).check();

  static final _id_hasNestedScrollingParent =
      jniAccessors.getMethodIDOf(_classRef, "hasNestedScrollingParent", "()Z");

  /// from: public boolean hasNestedScrollingParent()
  ///
  /// Returns true if this view has a nested scrolling parent.
  ///
  /// The presence of a nested scrolling parent indicates that this view has initiated
  /// a nested scroll and it was accepted by an ancestor view further up the view hierarchy.
  ///
  ///@return whether this view has a nested scrolling parent
  bool hasNestedScrollingParent() => jniAccessors.callMethodWithArgs(reference,
      _id_hasNestedScrollingParent, jni.JniType.booleanType, []).boolean;

  static final _id_dispatchNestedScroll = jniAccessors.getMethodIDOf(
      _classRef, "dispatchNestedScroll", "(IIII[I)Z");

  /// from: public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)
  ///
  /// Dispatch one step of a nested scroll in progress.
  ///
  /// Implementations of views that support nested scrolling should call this to report
  /// info about a scroll in progress to the current nested scrolling parent. If a nested scroll
  /// is not currently in progress or nested scrolling is not
  /// \#isNestedScrollingEnabled() enabled for this view this method does nothing.
  ///
  ///
  /// Compatible View implementations should also call
  /// \#dispatchNestedPreScroll(int, int, int[], int[]) dispatchNestedPreScroll before
  /// consuming a component of the scroll event themselves.
  ///
  ///@param dxConsumed Horizontal distance in pixels consumed by this view during this scroll step
  ///@param dyConsumed Vertical distance in pixels consumed by this view during this scroll step
  ///@param dxUnconsumed Horizontal scroll distance in pixels not consumed by this view
  ///@param dyUnconsumed Horizontal scroll distance in pixels not consumed by this view
  ///@param offsetInWindow Optional. If not null, on return this will contain the offset
  ///                       in local view coordinates of this view from before this operation
  ///                       to after it completes. View implementations may use this to adjust
  ///                       expected input coordinate tracking.
  /// This value may be {@code null}.
  ///@return true if the event was dispatched, false if it could not be dispatched.
  ///@see \#dispatchNestedPreScroll(int, int, int[], int[])
  bool dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed,
          int dyUnconsumed, jni.JniObject offsetInWindow) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dispatchNestedScroll, jni.JniType.booleanType, [
        dxConsumed,
        dyConsumed,
        dxUnconsumed,
        dyUnconsumed,
        offsetInWindow.reference
      ]).boolean;

  static final _id_dispatchNestedPreScroll = jniAccessors.getMethodIDOf(
      _classRef, "dispatchNestedPreScroll", "(II[I[I)Z");

  /// from: public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)
  ///
  /// Dispatch one step of a nested scroll in progress before this view consumes any portion of it.
  ///
  /// Nested pre-scroll events are to nested scroll events what touch intercept is to touch.
  /// <code>dispatchNestedPreScroll</code> offers an opportunity for the parent view in a nested
  /// scrolling operation to consume some or all of the scroll operation before the child view
  /// consumes it.
  ///
  ///@param dx Horizontal scroll distance in pixels
  ///@param dy Vertical scroll distance in pixels
  ///@param consumed Output. If not null, consumed[0] will contain the consumed component of dx
  ///                 and consumed[1] the consumed dy.
  /// This value may be {@code null}.
  ///@param offsetInWindow Optional. If not null, on return this will contain the offset
  ///                       in local view coordinates of this view from before this operation
  ///                       to after it completes. View implementations may use this to adjust
  ///                       expected input coordinate tracking.
  /// This value may be {@code null}.
  ///@return true if the parent consumed some or all of the scroll delta
  ///@see \#dispatchNestedScroll(int, int, int, int, int[])
  bool dispatchNestedPreScroll(int dx, int dy, jni.JniObject consumed,
          jni.JniObject offsetInWindow) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchNestedPreScroll,
          jni.JniType.booleanType,
          [dx, dy, consumed.reference, offsetInWindow.reference]).boolean;

  static final _id_dispatchNestedFling =
      jniAccessors.getMethodIDOf(_classRef, "dispatchNestedFling", "(FFZ)Z");

  /// from: public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed)
  ///
  /// Dispatch a fling to a nested scrolling parent.
  ///
  /// This method should be used to indicate that a nested scrolling child has detected
  /// suitable conditions for a fling. Generally this means that a touch scroll has ended with a
  /// VelocityTracker velocity in the direction of scrolling that meets or exceeds
  /// the ViewConfiguration\#getScaledMinimumFlingVelocity() minimum fling velocity
  /// along a scrollable axis.
  ///
  ///
  /// If a nested scrolling child view would normally fling but it is at the edge of
  /// its own content, it can use this method to delegate the fling to its nested scrolling
  /// parent instead. The parent may optionally consume the fling or observe a child fling.
  ///
  ///@param velocityX Horizontal fling velocity in pixels per second
  ///@param velocityY Vertical fling velocity in pixels per second
  ///@param consumed true if the child consumed the fling, false otherwise
  ///@return true if the nested scrolling parent consumed or otherwise reacted to the fling
  bool dispatchNestedFling(double velocityX, double velocityY, bool consumed) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchNestedFling,
          jni.JniType.booleanType, [velocityX, velocityY, consumed]).boolean;

  static final _id_dispatchNestedPreFling =
      jniAccessors.getMethodIDOf(_classRef, "dispatchNestedPreFling", "(FF)Z");

  /// from: public boolean dispatchNestedPreFling(float velocityX, float velocityY)
  ///
  /// Dispatch a fling to a nested scrolling parent before it is processed by this view.
  ///
  /// Nested pre-fling events are to nested fling events what touch intercept is to touch
  /// and what nested pre-scroll is to nested scroll. <code>dispatchNestedPreFling</code>
  /// offsets an opportunity for the parent view in a nested fling to fully consume the fling
  /// before the child view consumes it. If this method returns <code>true</code>, a nested
  /// parent view consumed the fling and this view should not scroll as a result.
  ///
  ///
  /// For a better user experience, only one view in a nested scrolling chain should consume
  /// the fling at a time. If a parent view consumed the fling this method will return false.
  /// Custom view implementations should account for this in two ways:
  ///
  ///
  /// <ul>
  ///     <li>If a custom view is paged and needs to settle to a fixed page-point, do not
  ///     call <code>dispatchNestedPreFling</code>; consume the fling and settle to a valid
  ///     position regardless.</li>
  ///     <li>If a nested parent does consume the fling, this view should not scroll at all,
  ///     even to settle back to a valid idle position.</li>
  /// </ul>
  ///
  /// Views should also not offer fling velocities to nested parent views along an axis
  /// where scrolling is not currently supported; a android.widget.ScrollView ScrollView
  /// should not offer a horizontal fling velocity to its parents since scrolling along that
  /// axis is not permitted and carrying velocity along that motion does not make sense.
  ///
  ///@param velocityX Horizontal fling velocity in pixels per second
  ///@param velocityY Vertical fling velocity in pixels per second
  ///@return true if a nested scrolling parent consumed the fling
  bool dispatchNestedPreFling(double velocityX, double velocityY) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchNestedPreFling,
          jni.JniType.booleanType, [velocityX, velocityY]).boolean;

  static final _id_setTextDirection =
      jniAccessors.getMethodIDOf(_classRef, "setTextDirection", "(I)V");

  /// from: public void setTextDirection(int textDirection)
  ///
  /// Set the text direction.
  ///@param textDirection the direction to set. Should be one of:
  ///
  /// \#TEXT_DIRECTION_INHERIT,
  /// \#TEXT_DIRECTION_FIRST_STRONG,
  /// \#TEXT_DIRECTION_ANY_RTL,
  /// \#TEXT_DIRECTION_LTR,
  /// \#TEXT_DIRECTION_RTL,
  /// \#TEXT_DIRECTION_LOCALE
  /// \#TEXT_DIRECTION_FIRST_STRONG_LTR,
  /// \#TEXT_DIRECTION_FIRST_STRONG_RTL,
  ///
  /// Resolution will be done if the value is set to TEXT_DIRECTION_INHERIT. The resolution
  /// proceeds up the parent chain of the view to get the value. If there is no parent, then it will
  /// return the default \#TEXT_DIRECTION_FIRST_STRONG.
  ///@attr ref android.R.styleable\#View_textDirection
  void setTextDirection(int textDirection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextDirection,
      jni.JniType.voidType,
      [textDirection]).check();

  static final _id_getTextDirection =
      jniAccessors.getMethodIDOf(_classRef, "getTextDirection", "()I");

  /// from: public int getTextDirection()
  ///
  /// Return the resolved text direction.
  ///@return the resolved text direction. Returns one of:
  ///
  /// \#TEXT_DIRECTION_FIRST_STRONG,
  /// \#TEXT_DIRECTION_ANY_RTL,
  /// \#TEXT_DIRECTION_LTR,
  /// \#TEXT_DIRECTION_RTL,
  /// \#TEXT_DIRECTION_LOCALE,
  /// \#TEXT_DIRECTION_FIRST_STRONG_LTR,
  /// \#TEXT_DIRECTION_FIRST_STRONG_RTL
  ///@attr ref android.R.styleable\#View_textDirection
  int getTextDirection() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextDirection, jni.JniType.intType, []).integer;

  static final _id_canResolveTextDirection =
      jniAccessors.getMethodIDOf(_classRef, "canResolveTextDirection", "()Z");

  /// from: public boolean canResolveTextDirection()
  ///
  /// Check if text direction resolution can be done.
  ///@return true if text direction resolution can be done otherwise return false.
  bool canResolveTextDirection() => jniAccessors.callMethodWithArgs(reference,
      _id_canResolveTextDirection, jni.JniType.booleanType, []).boolean;

  static final _id_isTextDirectionResolved =
      jniAccessors.getMethodIDOf(_classRef, "isTextDirectionResolved", "()Z");

  /// from: public boolean isTextDirectionResolved()
  ///
  /// @return true if text direction is resolved.
  bool isTextDirectionResolved() => jniAccessors.callMethodWithArgs(reference,
      _id_isTextDirectionResolved, jni.JniType.booleanType, []).boolean;

  static final _id_setTextAlignment =
      jniAccessors.getMethodIDOf(_classRef, "setTextAlignment", "(I)V");

  /// from: public void setTextAlignment(int textAlignment)
  ///
  /// Set the text alignment.
  ///@param textAlignment The text alignment to set. Should be one of
  ///
  /// \#TEXT_ALIGNMENT_INHERIT,
  /// \#TEXT_ALIGNMENT_GRAVITY,
  /// \#TEXT_ALIGNMENT_CENTER,
  /// \#TEXT_ALIGNMENT_TEXT_START,
  /// \#TEXT_ALIGNMENT_TEXT_END,
  /// \#TEXT_ALIGNMENT_VIEW_START,
  /// \#TEXT_ALIGNMENT_VIEW_END
  ///
  /// Resolution will be done if the value is set to TEXT_ALIGNMENT_INHERIT. The resolution
  /// proceeds up the parent chain of the view to get the value. If there is no parent, then it
  /// will return the default \#TEXT_ALIGNMENT_GRAVITY.
  ///
  /// Value is android.view.View\#TEXT_ALIGNMENT_INHERIT, android.view.View\#TEXT_ALIGNMENT_GRAVITY, android.view.View\#TEXT_ALIGNMENT_CENTER, android.view.View\#TEXT_ALIGNMENT_TEXT_START, android.view.View\#TEXT_ALIGNMENT_TEXT_END, android.view.View\#TEXT_ALIGNMENT_VIEW_START, or android.view.View\#TEXT_ALIGNMENT_VIEW_END
  ///@attr ref android.R.styleable\#View_textAlignment
  void setTextAlignment(int textAlignment) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextAlignment,
      jni.JniType.voidType,
      [textAlignment]).check();

  static final _id_getTextAlignment =
      jniAccessors.getMethodIDOf(_classRef, "getTextAlignment", "()I");

  /// from: public int getTextAlignment()
  ///
  /// Return the resolved text alignment.
  ///@return the resolved text alignment. Returns one of:
  ///
  /// \#TEXT_ALIGNMENT_GRAVITY,
  /// \#TEXT_ALIGNMENT_CENTER,
  /// \#TEXT_ALIGNMENT_TEXT_START,
  /// \#TEXT_ALIGNMENT_TEXT_END,
  /// \#TEXT_ALIGNMENT_VIEW_START,
  /// \#TEXT_ALIGNMENT_VIEW_END
  ///
  /// Value is android.view.View\#TEXT_ALIGNMENT_INHERIT, android.view.View\#TEXT_ALIGNMENT_GRAVITY, android.view.View\#TEXT_ALIGNMENT_CENTER, android.view.View\#TEXT_ALIGNMENT_TEXT_START, android.view.View\#TEXT_ALIGNMENT_TEXT_END, android.view.View\#TEXT_ALIGNMENT_VIEW_START, or android.view.View\#TEXT_ALIGNMENT_VIEW_END
  ///@attr ref android.R.styleable\#View_textAlignment
  int getTextAlignment() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextAlignment, jni.JniType.intType, []).integer;

  static final _id_canResolveTextAlignment =
      jniAccessors.getMethodIDOf(_classRef, "canResolveTextAlignment", "()Z");

  /// from: public boolean canResolveTextAlignment()
  ///
  /// Check if text alignment resolution can be done.
  ///@return true if text alignment resolution can be done otherwise return false.
  bool canResolveTextAlignment() => jniAccessors.callMethodWithArgs(reference,
      _id_canResolveTextAlignment, jni.JniType.booleanType, []).boolean;

  static final _id_isTextAlignmentResolved =
      jniAccessors.getMethodIDOf(_classRef, "isTextAlignmentResolved", "()Z");

  /// from: public boolean isTextAlignmentResolved()
  ///
  /// @return true if text alignment is resolved.
  bool isTextAlignmentResolved() => jniAccessors.callMethodWithArgs(reference,
      _id_isTextAlignmentResolved, jni.JniType.booleanType, []).boolean;

  static final _id_generateViewId =
      jniAccessors.getStaticMethodIDOf(_classRef, "generateViewId", "()I");

  /// from: static public int generateViewId()
  ///
  /// Generate a value suitable for use in \#setId(int).
  /// This value will not collide with ID values generated at build time by aapt for R.id.
  ///@return a generated ID value
  static int generateViewId() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_generateViewId, jni.JniType.intType, []).integer;

  static final _id_onResolvePointerIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "onResolvePointerIcon",
      "(Landroid/view/MotionEvent;I)Landroid/view/PointerIcon;");

  /// from: public android.view.PointerIcon onResolvePointerIcon(android.view.MotionEvent event, int pointerIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the pointer icon for the motion event, or null if it doesn't specify the icon.
  /// The default implementation does not care the location or event types, but some subclasses
  /// may use it (such as WebViews).
  ///@param event The MotionEvent from a mouse
  ///@param pointerIndex The index of the pointer for which to retrieve the PointerIcon.
  ///                     This will be between 0 and MotionEvent\#getPointerCount().
  ///@see PointerIcon
  pointericon_.PointerIcon onResolvePointerIcon(
          motionevent_.MotionEvent event, int pointerIndex) =>
      pointericon_.PointerIcon.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onResolvePointerIcon,
          jni.JniType.objectType,
          [event.reference, pointerIndex]).object);

  static final _id_setPointerIcon = jniAccessors.getMethodIDOf(
      _classRef, "setPointerIcon", "(Landroid/view/PointerIcon;)V");

  /// from: public void setPointerIcon(android.view.PointerIcon pointerIcon)
  ///
  /// Set the pointer icon for the current view.
  /// Passing {@code null} will restore the pointer icon to its default value.
  ///@param pointerIcon A PointerIcon instance which will be shown when the mouse hovers.
  void setPointerIcon(pointericon_.PointerIcon pointerIcon) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPointerIcon,
          jni.JniType.voidType, [pointerIcon.reference]).check();

  static final _id_getPointerIcon = jniAccessors.getMethodIDOf(
      _classRef, "getPointerIcon", "()Landroid/view/PointerIcon;");

  /// from: public android.view.PointerIcon getPointerIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the pointer icon for the current view.
  pointericon_.PointerIcon getPointerIcon() =>
      pointericon_.PointerIcon.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPointerIcon, jni.JniType.objectType, []).object);

  static final _id_hasPointerCapture =
      jniAccessors.getMethodIDOf(_classRef, "hasPointerCapture", "()Z");

  /// from: public boolean hasPointerCapture()
  ///
  /// Checks pointer capture status.
  ///@return true if the view has pointer capture.
  ///@see \#requestPointerCapture()
  ///@see \#hasPointerCapture()
  bool hasPointerCapture() => jniAccessors.callMethodWithArgs(
      reference, _id_hasPointerCapture, jni.JniType.booleanType, []).boolean;

  static final _id_requestPointerCapture =
      jniAccessors.getMethodIDOf(_classRef, "requestPointerCapture", "()V");

  /// from: public void requestPointerCapture()
  ///
  /// Requests pointer capture mode.
  ///
  /// When the window has pointer capture, the mouse pointer icon will disappear and will not
  /// change its position. Further mouse will be dispatched with the source
  /// InputDevice\#SOURCE_MOUSE_RELATIVE, and relative position changes will be available
  /// through MotionEvent\#getX and MotionEvent\#getY. Non-mouse events
  /// (touchscreens, or stylus) will not be affected.
  ///
  /// If the window already has pointer capture, this call does nothing.
  ///
  /// The capture may be released through \#releasePointerCapture(), or will be lost
  /// automatically when the window loses focus.
  ///@see \#releasePointerCapture()
  ///@see \#hasPointerCapture()
  void requestPointerCapture() => jniAccessors.callMethodWithArgs(
      reference, _id_requestPointerCapture, jni.JniType.voidType, []).check();

  static final _id_releasePointerCapture =
      jniAccessors.getMethodIDOf(_classRef, "releasePointerCapture", "()V");

  /// from: public void releasePointerCapture()
  ///
  /// Releases the pointer capture.
  ///
  /// If the window does not have pointer capture, this call will do nothing.
  ///@see \#requestPointerCapture()
  ///@see \#hasPointerCapture()
  void releasePointerCapture() => jniAccessors.callMethodWithArgs(
      reference, _id_releasePointerCapture, jni.JniType.voidType, []).check();

  static final _id_onPointerCaptureChange =
      jniAccessors.getMethodIDOf(_classRef, "onPointerCaptureChange", "(Z)V");

  /// from: public void onPointerCaptureChange(boolean hasCapture)
  ///
  /// Called when the window has just acquired or lost pointer capture.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param hasCapture True if the view now has pointerCapture, false otherwise.
  void onPointerCaptureChange(bool hasCapture) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPointerCaptureChange,
          jni.JniType.voidType, [hasCapture]).check();

  static final _id_dispatchPointerCaptureChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchPointerCaptureChanged", "(Z)V");

  /// from: public void dispatchPointerCaptureChanged(boolean hasCapture)
  ///
  /// @see \#onPointerCaptureChange
  void dispatchPointerCaptureChanged(bool hasCapture) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPointerCaptureChanged,
          jni.JniType.voidType,
          [hasCapture]).check();

  static final _id_onCapturedPointerEvent = jniAccessors.getMethodIDOf(
      _classRef, "onCapturedPointerEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onCapturedPointerEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to handle captured pointer events
  ///@param event The captured pointer event.
  ///@return True if the event was handled, false otherwise.
  ///@see \#requestPointerCapture()
  bool onCapturedPointerEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCapturedPointerEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_setOnCapturedPointerListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnCapturedPointerListener",
      "(Landroid/view/View\$OnCapturedPointerListener;)V");

  /// from: public void setOnCapturedPointerListener(android.view.View.OnCapturedPointerListener l)
  ///
  /// Set a listener to receive callbacks when the pointer capture state of a view changes.
  ///@param l The OnCapturedPointerListener to receive callbacks.
  void setOnCapturedPointerListener(View_OnCapturedPointerListener l) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnCapturedPointerListener,
          jni.JniType.voidType,
          [l.reference]).check();

  static final _id_animate = jniAccessors.getMethodIDOf(
      _classRef, "animate", "()Landroid/view/ViewPropertyAnimator;");

  /// from: public android.view.ViewPropertyAnimator animate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method returns a ViewPropertyAnimator object, which can be used to animate
  /// specific properties on this View.
  ///@return ViewPropertyAnimator The ViewPropertyAnimator associated with this View.
  viewpropertyanimator_.ViewPropertyAnimator animate() =>
      viewpropertyanimator_.ViewPropertyAnimator.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_animate, jni.JniType.objectType, []).object);

  static final _id_setTransitionName = jniAccessors.getMethodIDOf(
      _classRef, "setTransitionName", "(Ljava/lang/String;)V");

  /// from: public final void setTransitionName(java.lang.String transitionName)
  ///
  /// Sets the name of the View to be used to identify Views in Transitions.
  /// Names should be unique in the View hierarchy.
  ///@param transitionName The name of the View to uniquely identify it for Transitions.
  void setTransitionName(jni.JniString transitionName) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTransitionName,
          jni.JniType.voidType, [transitionName.reference]).check();

  static final _id_getTransitionName = jniAccessors.getMethodIDOf(
      _classRef, "getTransitionName", "()Ljava/lang/String;");

  /// from: public java.lang.String getTransitionName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of the View to be used to identify Views in Transitions.
  /// Names should be unique in the View hierarchy.
  ///
  /// This returns null if the View has not been given a name.
  ///
  ///@return The name used of the View to be used to identify Views in Transitions or null
  /// if no name has been given.
  jni.JniString getTransitionName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTransitionName, jni.JniType.objectType, []).object);

  static final _id_setTooltipText = jniAccessors.getMethodIDOf(
      _classRef, "setTooltipText", "(Ljava/lang/CharSequence;)V");

  /// from: public void setTooltipText(java.lang.CharSequence tooltipText)
  ///
  /// Sets the tooltip text which will be displayed in a small popup next to the view.
  ///
  /// The tooltip will be displayed:
  /// <ul>
  /// <li>On long click, unless it is handled otherwise (by OnLongClickListener or a context
  /// menu). </li>
  /// <li>On hover, after a brief delay since the pointer has stopped moving </li>
  /// </ul>
  ///
  /// <strong>Note:</strong> Do not override this method, as it will have no
  /// effect on the text displayed in the tooltip.
  ///@param tooltipText the tooltip text, or null if no tooltip is required
  /// This value may be {@code null}.
  ///@see \#getTooltipText()
  ///@attr ref android.R.styleable\#View_tooltipText
  void setTooltipText(jni.JniObject tooltipText) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTooltipText,
          jni.JniType.voidType, [tooltipText.reference]).check();

  static final _id_getTooltipText = jniAccessors.getMethodIDOf(
      _classRef, "getTooltipText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTooltipText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the view's tooltip text.
  ///
  /// <strong>Note:</strong> Do not override this method, as it will have no
  /// effect on the text displayed in the tooltip. You must call
  /// \#setTooltipText(CharSequence) to modify the tooltip text.
  ///@return the tooltip text
  /// This value may be {@code null}.
  ///@see \#setTooltipText(CharSequence)
  ///@attr ref android.R.styleable\#View_tooltipText
  jni.JniObject getTooltipText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTooltipText, jni.JniType.objectType, []).object);

  static final _id_addOnUnhandledKeyEventListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnUnhandledKeyEventListener",
      "(Landroid/view/View\$OnUnhandledKeyEventListener;)V");

  /// from: public void addOnUnhandledKeyEventListener(android.view.View.OnUnhandledKeyEventListener listener)
  ///
  /// Adds a listener which will receive unhandled KeyEvents. This must be called on the
  /// UI thread.
  ///@param listener a receiver of unhandled KeyEvents.
  ///@see \#removeOnUnhandledKeyEventListener
  void addOnUnhandledKeyEventListener(
          View_OnUnhandledKeyEventListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnUnhandledKeyEventListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_removeOnUnhandledKeyEventListener =
      jniAccessors.getMethodIDOf(_classRef, "removeOnUnhandledKeyEventListener",
          "(Landroid/view/View\$OnUnhandledKeyEventListener;)V");

  /// from: public void removeOnUnhandledKeyEventListener(android.view.View.OnUnhandledKeyEventListener listener)
  ///
  /// Removes a listener which will receive unhandled KeyEvents. This must be called on the
  /// UI thread.
  ///@param listener a receiver of unhandled KeyEvents.
  ///@see \#addOnUnhandledKeyEventListener
  void removeOnUnhandledKeyEventListener(
          View_OnUnhandledKeyEventListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnUnhandledKeyEventListener,
          jni.JniType.voidType,
          [listener.reference]).check();
}

/// from: android.view.View$OnUnhandledKeyEventListener
///
/// Interface definition for a callback to be invoked when a hardware key event hasn't
/// been handled by the view hierarchy.
class View_OnUnhandledKeyEventListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnUnhandledKeyEventListener");
  View_OnUnhandledKeyEventListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onUnhandledKeyEvent = jniAccessors.getMethodIDOf(_classRef,
      "onUnhandledKeyEvent", "(Landroid/view/View;Landroid/view/KeyEvent;)Z");

  /// from: public abstract boolean onUnhandledKeyEvent(android.view.View v, android.view.KeyEvent event)
  ///
  /// Called when a hardware key is dispatched to a view after being unhandled during normal
  /// KeyEvent dispatch.
  ///@param v The view the key has been dispatched to.
  ///@param event The KeyEvent object containing information about the event.
  ///@return {@code true} if the listener has consumed the event, {@code false} otherwise.
  bool onUnhandledKeyEvent(View v, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onUnhandledKeyEvent,
          jni.JniType.booleanType, [v.reference, event.reference]).boolean;
}

/// from: android.view.View$OnTouchListener
///
/// Interface definition for a callback to be invoked when a touch event is
/// dispatched to this view. The callback will be invoked before the touch
/// event is given to the view.
class View_OnTouchListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnTouchListener");
  View_OnTouchListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onTouch = jniAccessors.getMethodIDOf(
      _classRef, "onTouch", "(Landroid/view/View;Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onTouch(android.view.View v, android.view.MotionEvent event)
  ///
  /// Called when a touch event is dispatched to a view. This allows listeners to
  /// get a chance to respond before the target view.
  ///@param v The view the touch event has been dispatched to.
  ///@param event The MotionEvent object containing full information about
  ///        the event.
  ///@return True if the listener has consumed the event, false otherwise.
  bool onTouch(View v, motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouch,
          jni.JniType.booleanType, [v.reference, event.reference]).boolean;
}

/// from: android.view.View$OnSystemUiVisibilityChangeListener
///
/// Interface definition for a callback to be invoked when the status bar changes
/// visibility.  This reports <strong>global</strong> changes to the system UI
/// state, not what the application is requesting.
///@see View\#setOnSystemUiVisibilityChangeListener(android.view.View.OnSystemUiVisibilityChangeListener)
class View_OnSystemUiVisibilityChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/View\$OnSystemUiVisibilityChangeListener");
  View_OnSystemUiVisibilityChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onSystemUiVisibilityChange = jniAccessors.getMethodIDOf(
      _classRef, "onSystemUiVisibilityChange", "(I)V");

  /// from: public abstract void onSystemUiVisibilityChange(int visibility)
  ///
  /// Called when the status bar changes visibility because of a call to
  /// View\#setSystemUiVisibility(int).
  ///@param visibility Bitwise-or of flags \#SYSTEM_UI_FLAG_LOW_PROFILE,
  /// \#SYSTEM_UI_FLAG_HIDE_NAVIGATION, and \#SYSTEM_UI_FLAG_FULLSCREEN.
  /// This tells you the <strong>global</strong> state of these UI visibility
  /// flags, not what your app is currently applying.
  void onSystemUiVisibilityChange(int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSystemUiVisibilityChange,
          jni.JniType.voidType, [visibility]).check();
}

/// from: android.view.View$OnScrollChangeListener
///
/// Interface definition for a callback to be invoked when the scroll
/// X or Y positions of a view change.
///
/// __Note:__ Some views handle scrolling independently from View and may
/// have their own separate listeners for scroll-type events. For example,
/// android.widget.ListView ListView allows clients to register an
/// android.widget.ListView\#setOnScrollListener(android.widget.AbsListView.OnScrollListener) AbsListView.OnScrollListener
/// to listen for changes in list scroll position.
///@see \#setOnScrollChangeListener(View.OnScrollChangeListener)
class View_OnScrollChangeListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnScrollChangeListener");
  View_OnScrollChangeListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onScrollChange = jniAccessors.getMethodIDOf(
      _classRef, "onScrollChange", "(Landroid/view/View;IIII)V");

  /// from: public abstract void onScrollChange(android.view.View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY)
  ///
  /// Called when the scroll position of a view changes.
  ///@param v The view whose scroll position has changed.
  ///@param scrollX Current horizontal scroll origin.
  ///@param scrollY Current vertical scroll origin.
  ///@param oldScrollX Previous horizontal scroll origin.
  ///@param oldScrollY Previous vertical scroll origin.
  void onScrollChange(
          View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onScrollChange,
          jni.JniType.voidType,
          [v.reference, scrollX, scrollY, oldScrollX, oldScrollY]).check();
}

/// from: android.view.View$OnLongClickListener
///
/// Interface definition for a callback to be invoked when a view has been clicked and held.
class View_OnLongClickListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnLongClickListener");
  View_OnLongClickListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onLongClick = jniAccessors.getMethodIDOf(
      _classRef, "onLongClick", "(Landroid/view/View;)Z");

  /// from: public abstract boolean onLongClick(android.view.View v)
  ///
  /// Called when a view has been clicked and held.
  ///@param v The view that was clicked and held.
  ///@return true if the callback consumed the long click, false otherwise.
  bool onLongClick(View v) => jniAccessors.callMethodWithArgs(reference,
      _id_onLongClick, jni.JniType.booleanType, [v.reference]).boolean;
}

/// from: android.view.View$OnLayoutChangeListener
///
/// Interface definition for a callback to be invoked when the layout bounds of a view
/// changes due to layout processing.
class View_OnLayoutChangeListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnLayoutChangeListener");
  View_OnLayoutChangeListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onLayoutChange = jniAccessors.getMethodIDOf(
      _classRef, "onLayoutChange", "(Landroid/view/View;IIIIIIII)V");

  /// from: public abstract void onLayoutChange(android.view.View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom)
  ///
  /// Called when the layout bounds of a view changes due to layout processing.
  ///@param v The view whose bounds have changed.
  ///@param left The new value of the view's left property.
  ///@param top The new value of the view's top property.
  ///@param right The new value of the view's right property.
  ///@param bottom The new value of the view's bottom property.
  ///@param oldLeft The previous value of the view's left property.
  ///@param oldTop The previous value of the view's top property.
  ///@param oldRight The previous value of the view's right property.
  ///@param oldBottom The previous value of the view's bottom property.
  void onLayoutChange(View v, int left, int top, int right, int bottom,
          int oldLeft, int oldTop, int oldRight, int oldBottom) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onLayoutChange, jni.JniType.voidType, [
        v.reference,
        left,
        top,
        right,
        bottom,
        oldLeft,
        oldTop,
        oldRight,
        oldBottom
      ]).check();
}

/// from: android.view.View$OnKeyListener
///
/// Interface definition for a callback to be invoked when a hardware key event is
/// dispatched to this view. The callback will be invoked before the key event is
/// given to the view. This is only useful for hardware keyboards; a software input
/// method has no obligation to trigger this listener.
class View_OnKeyListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnKeyListener");
  View_OnKeyListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onKey = jniAccessors.getMethodIDOf(
      _classRef, "onKey", "(Landroid/view/View;ILandroid/view/KeyEvent;)Z");

  /// from: public abstract boolean onKey(android.view.View v, int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a hardware key is dispatched to a view. This allows listeners to
  /// get a chance to respond before the target view.
  /// Key presses in software keyboards will generally NOT trigger this method,
  /// although some may elect to do so in some situations. Do not assume a
  /// software input method has to be key-based; even if it is, it may use key presses
  /// in a different way than you expect, so there is no way to reliably catch soft
  /// input key presses.
  ///@param v The view the key has been dispatched to.
  ///@param keyCode The code for the physical key that was pressed
  ///@param event The KeyEvent object containing full information about
  ///        the event.
  ///@return True if the listener has consumed the event, false otherwise.
  bool onKey(View v, int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onKey,
          jni.JniType.booleanType,
          [v.reference, keyCode, event.reference]).boolean;
}

/// from: android.view.View$OnHoverListener
///
/// Interface definition for a callback to be invoked when a hover event is
/// dispatched to this view. The callback will be invoked before the hover
/// event is given to the view.
class View_OnHoverListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnHoverListener");
  View_OnHoverListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onHover = jniAccessors.getMethodIDOf(
      _classRef, "onHover", "(Landroid/view/View;Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onHover(android.view.View v, android.view.MotionEvent event)
  ///
  /// Called when a hover event is dispatched to a view. This allows listeners to
  /// get a chance to respond before the target view.
  ///@param v The view the hover event has been dispatched to.
  ///@param event The MotionEvent object containing full information about
  ///        the event.
  ///@return True if the listener has consumed the event, false otherwise.
  bool onHover(View v, motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onHover,
          jni.JniType.booleanType, [v.reference, event.reference]).boolean;
}

/// from: android.view.View$OnGenericMotionListener
///
/// Interface definition for a callback to be invoked when a generic motion event is
/// dispatched to this view. The callback will be invoked before the generic motion
/// event is given to the view.
class View_OnGenericMotionListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnGenericMotionListener");
  View_OnGenericMotionListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onGenericMotion = jniAccessors.getMethodIDOf(_classRef,
      "onGenericMotion", "(Landroid/view/View;Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onGenericMotion(android.view.View v, android.view.MotionEvent event)
  ///
  /// Called when a generic motion event is dispatched to a view. This allows listeners to
  /// get a chance to respond before the target view.
  ///@param v The view the generic motion event has been dispatched to.
  ///@param event The MotionEvent object containing full information about
  ///        the event.
  ///@return True if the listener has consumed the event, false otherwise.
  bool onGenericMotion(View v, motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotion,
          jni.JniType.booleanType, [v.reference, event.reference]).boolean;
}

/// from: android.view.View$OnFocusChangeListener
///
/// Interface definition for a callback to be invoked when the focus state of
/// a view changed.
class View_OnFocusChangeListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnFocusChangeListener");
  View_OnFocusChangeListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onFocusChange = jniAccessors.getMethodIDOf(
      _classRef, "onFocusChange", "(Landroid/view/View;Z)V");

  /// from: public abstract void onFocusChange(android.view.View v, boolean hasFocus)
  ///
  /// Called when the focus state of a view has changed.
  ///@param v The view whose state has changed.
  ///@param hasFocus The new focus state of v.
  void onFocusChange(View v, bool hasFocus) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onFocusChange,
      jni.JniType.voidType,
      [v.reference, hasFocus]).check();
}

/// from: android.view.View$OnDragListener
///
/// Interface definition for a callback to be invoked when a drag is being dispatched
/// to this view.  The callback will be invoked before the hosting view's own
/// onDrag(event) method.  If the listener wants to fall back to the hosting view's
/// onDrag(event) behavior, it should return 'false' from this callback.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a guide to implementing drag and drop features, read the
/// <a href="{@docRoot}guide/topics/ui/drag-drop.html">Drag and Drop</a> developer guide.
///
/// </div>
class View_OnDragListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnDragListener");
  View_OnDragListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onDrag = jniAccessors.getMethodIDOf(
      _classRef, "onDrag", "(Landroid/view/View;Landroid/view/DragEvent;)Z");

  /// from: public abstract boolean onDrag(android.view.View v, android.view.DragEvent event)
  ///
  /// Called when a drag event is dispatched to a view. This allows listeners
  /// to get a chance to override base View behavior.
  ///@param v The View that received the drag event.
  ///@param event The android.view.DragEvent object for the drag event.
  ///@return {@code true} if the drag event was handled successfully, or {@code false}
  /// if the drag event was not handled. Note that {@code false} will trigger the View
  /// to call its \#onDragEvent(DragEvent) onDragEvent() handler.
  bool onDrag(View v, dragevent_.DragEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDrag,
          jni.JniType.booleanType, [v.reference, event.reference]).boolean;
}

/// from: android.view.View$OnCreateContextMenuListener
///
/// Interface definition for a callback to be invoked when the context menu
/// for this view is being built.
class View_OnCreateContextMenuListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnCreateContextMenuListener");
  View_OnCreateContextMenuListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onCreateContextMenu = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateContextMenu",
      "(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu\$ContextMenuInfo;)V");

  /// from: public abstract void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  ///
  /// Called when the context menu for this view is being built. It is not
  /// safe to hold onto the menu after this method returns.
  ///@param menu The context menu that is being built
  ///@param v The view for which the context menu is being built
  ///@param menuInfo Extra information about the item for which the
  ///            context menu should be shown. This information will vary
  ///            depending on the class of v.
  void onCreateContextMenu(contextmenu_.ContextMenu menu, View v,
          contextmenu_.ContextMenu_ContextMenuInfo menuInfo) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateContextMenu,
          jni.JniType.voidType,
          [menu.reference, v.reference, menuInfo.reference]).check();
}

/// from: android.view.View$OnContextClickListener
///
/// Interface definition for a callback to be invoked when a view is context clicked.
class View_OnContextClickListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnContextClickListener");
  View_OnContextClickListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onContextClick = jniAccessors.getMethodIDOf(
      _classRef, "onContextClick", "(Landroid/view/View;)Z");

  /// from: public abstract boolean onContextClick(android.view.View v)
  ///
  /// Called when a view is context clicked.
  ///@param v The view that has been context clicked.
  ///@return true if the callback consumed the context click, false otherwise.
  bool onContextClick(View v) => jniAccessors.callMethodWithArgs(reference,
      _id_onContextClick, jni.JniType.booleanType, [v.reference]).boolean;
}

/// from: android.view.View$OnClickListener
///
/// Interface definition for a callback to be invoked when a view is clicked.
class View_OnClickListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnClickListener");
  View_OnClickListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onClick = jniAccessors.getMethodIDOf(
      _classRef, "onClick", "(Landroid/view/View;)V");

  /// from: public abstract void onClick(android.view.View v)
  ///
  /// Called when a view has been clicked.
  ///@param v The view that was clicked.
  void onClick(View v) => jniAccessors.callMethodWithArgs(
      reference, _id_onClick, jni.JniType.voidType, [v.reference]).check();
}

/// from: android.view.View$OnCapturedPointerListener
///
/// Interface definition for a callback to be invoked when a captured pointer event
/// is being dispatched this view. The callback will be invoked before the event is
/// given to the view.
class View_OnCapturedPointerListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnCapturedPointerListener");
  View_OnCapturedPointerListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onCapturedPointer = jniAccessors.getMethodIDOf(_classRef,
      "onCapturedPointer", "(Landroid/view/View;Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean onCapturedPointer(android.view.View view, android.view.MotionEvent event)
  ///
  /// Called when a captured pointer event is dispatched to a view.
  ///@param view The view this event has been dispatched to.
  ///@param event The captured event.
  ///@return True if the listener has consumed the event, false otherwise.
  bool onCapturedPointer(View view, motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCapturedPointer,
          jni.JniType.booleanType, [view.reference, event.reference]).boolean;
}

/// from: android.view.View$OnAttachStateChangeListener
///
/// Interface definition for a callback to be invoked when this view is attached
/// or detached from its window.
class View_OnAttachStateChangeListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnAttachStateChangeListener");
  View_OnAttachStateChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onViewAttachedToWindow = jniAccessors.getMethodIDOf(
      _classRef, "onViewAttachedToWindow", "(Landroid/view/View;)V");

  /// from: public abstract void onViewAttachedToWindow(android.view.View v)
  ///
  /// Called when the view is attached to a window.
  ///@param v The view that was attached
  void onViewAttachedToWindow(View v) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onViewAttachedToWindow,
      jni.JniType.voidType,
      [v.reference]).check();

  static final _id_onViewDetachedFromWindow = jniAccessors.getMethodIDOf(
      _classRef, "onViewDetachedFromWindow", "(Landroid/view/View;)V");

  /// from: public abstract void onViewDetachedFromWindow(android.view.View v)
  ///
  /// Called when the view is detached from a window.
  ///@param v The view that was detached
  void onViewDetachedFromWindow(View v) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onViewDetachedFromWindow,
      jni.JniType.voidType,
      [v.reference]).check();
}

/// from: android.view.View$OnApplyWindowInsetsListener
///
/// Listener for applying window insets on a view in a custom way.
///
/// Apps may choose to implement this interface if they want to apply custom policy
/// to the way that window insets are treated for a view. If an OnApplyWindowInsetsListener
/// is set, its
/// OnApplyWindowInsetsListener\#onApplyWindowInsets(View, WindowInsets) onApplyWindowInsets
/// method will be called instead of the View's own
/// \#onApplyWindowInsets(WindowInsets) onApplyWindowInsets method. The listener
/// may optionally call the parameter View's <code>onApplyWindowInsets</code> method to apply
/// the View's normal behavior as part of its own.
///
class View_OnApplyWindowInsetsListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$OnApplyWindowInsetsListener");
  View_OnApplyWindowInsetsListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onApplyWindowInsets = jniAccessors.getMethodIDOf(
      _classRef,
      "onApplyWindowInsets",
      "(Landroid/view/View;Landroid/view/WindowInsets;)Landroid/view/WindowInsets;");

  /// from: public abstract android.view.WindowInsets onApplyWindowInsets(android.view.View v, android.view.WindowInsets insets)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// When View\#setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener) set
  /// on a View, this listener method will be called instead of the view's own
  /// View\#onApplyWindowInsets(WindowInsets) onApplyWindowInsets method.
  ///@param v The view applying window insets
  ///@param insets The insets to apply
  ///@return The insets supplied, minus any insets that were consumed
  windowinsets_.WindowInsets onApplyWindowInsets(
          View v, windowinsets_.WindowInsets insets) =>
      windowinsets_.WindowInsets.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onApplyWindowInsets,
          jni.JniType.objectType,
          [v.reference, insets.reference]).object);
}

/// from: android.view.View$MeasureSpec
///
/// A MeasureSpec encapsulates the layout requirements passed from parent to child.
/// Each MeasureSpec represents a requirement for either the width or the height.
/// A MeasureSpec is comprised of a size and a mode. There are three possible
/// modes:
/// <dl>
/// <dt>UNSPECIFIED</dt>
/// <dd>
/// The parent has not imposed any constraint on the child. It can be whatever size
/// it wants.
/// </dd>
///
/// <dt>EXACTLY</dt>
/// <dd>
/// The parent has determined an exact size for the child. The child is going to be
/// given those bounds regardless of how big it wants to be.
/// </dd>
///
/// <dt>AT_MOST</dt>
/// <dd>
/// The child can be as large as it wants up to the specified size.
/// </dd>
/// </dl>
///
/// MeasureSpecs are implemented as ints to reduce object allocation. This class
/// is provided to pack and unpack the &lt;size, mode&gt; tuple into the int.
class View_MeasureSpec extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$MeasureSpec");
  View_MeasureSpec.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AT_MOST
  ///
  /// Measure specification mode: The child can be as large as it wants up
  /// to the specified size.
  static const AT_MOST = -2147483648;

  /// from: static public final int EXACTLY
  ///
  /// Measure specification mode: The parent has determined an exact size
  /// for the child. The child is going to be given those bounds regardless
  /// of how big it wants to be.
  static const EXACTLY = 1073741824;

  /// from: static public final int UNSPECIFIED
  ///
  /// Measure specification mode: The parent has not imposed any constraint
  /// on the child. It can be whatever size it wants.
  static const UNSPECIFIED = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  View_MeasureSpec()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_makeMeasureSpec =
      jniAccessors.getStaticMethodIDOf(_classRef, "makeMeasureSpec", "(II)I");

  /// from: static public int makeMeasureSpec(int size, int mode)
  ///
  /// Creates a measure specification based on the supplied size and mode.
  ///
  /// The mode must always be one of the following:
  /// <ul>
  ///  <li>android.view.View.MeasureSpec\#UNSPECIFIED</li>
  ///  <li>android.view.View.MeasureSpec\#EXACTLY</li>
  ///  <li>android.view.View.MeasureSpec\#AT_MOST</li>
  /// </ul>
  ///
  /// <strong>Note:</strong> On API level 17 and lower, makeMeasureSpec's
  /// implementation was such that the order of arguments did not matter
  /// and overflow in either value could impact the resulting MeasureSpec.
  /// android.widget.RelativeLayout was affected by this bug.
  /// Apps targeting API levels greater than 17 will get the fixed, more strict
  /// behavior.
  ///
  ///@param size the size of the measure specification
  /// Value is between 0 and (1 << MeasureSpec.MODE_SHIFT) - 1 inclusive
  ///@param mode the mode of the measure specification
  /// Value is android.view.View.MeasureSpec\#UNSPECIFIED, android.view.View.MeasureSpec\#EXACTLY, or android.view.View.MeasureSpec\#AT_MOST
  ///@return the measure specification based on size and mode
  static int makeMeasureSpec(int size, int mode) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_makeMeasureSpec,
          jni.JniType.intType, [size, mode]).integer;

  static final _id_getMode =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMode", "(I)I");

  /// from: static public int getMode(int measureSpec)
  ///
  /// Extracts the mode from the supplied measure specification.
  ///@param measureSpec the measure specification to extract the mode from
  ///@return android.view.View.MeasureSpec\#UNSPECIFIED,
  ///         android.view.View.MeasureSpec\#AT_MOST or
  ///         android.view.View.MeasureSpec\#EXACTLY
  ///
  /// Value is android.view.View.MeasureSpec\#UNSPECIFIED, android.view.View.MeasureSpec\#EXACTLY, or android.view.View.MeasureSpec\#AT_MOST
  static int getMode(int measureSpec) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMode, jni.JniType.intType, [measureSpec]).integer;

  static final _id_getSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "getSize", "(I)I");

  /// from: static public int getSize(int measureSpec)
  ///
  /// Extracts the size from the supplied measure specification.
  ///@param measureSpec the measure specification to extract the size from
  ///@return the size in pixels defined in the supplied measure specification
  static int getSize(int measureSpec) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getSize, jni.JniType.intType, [measureSpec]).integer;

  static final _id_toString1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "toString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String toString(int measureSpec)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a String representation of the specified measure
  /// specification.
  ///@param measureSpec the measure specification to convert to a String
  ///@return a String with the following format: "MeasureSpec: MODE SIZE"
  static jni.JniString toString1(int measureSpec) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_toString1, jni.JniType.objectType, [measureSpec]).object);
}

/// from: android.view.View$DragShadowBuilder
///
/// Creates an image that the system displays during the drag and drop
/// operation. This is called a &quot;drag shadow&quot;. The default implementation
/// for a DragShadowBuilder based on a View returns an image that has exactly the same
/// appearance as the given View. The default also positions the center of the drag shadow
/// directly under the touch point. If no View is provided (the constructor with no parameters
/// is used), and \#onProvideShadowMetrics(Point,Point) onProvideShadowMetrics() and
/// \#onDrawShadow(Canvas) onDrawShadow() are not overridden, then the
/// default is an invisible drag shadow.
///
/// You are not required to use the View you provide to the constructor as the basis of the
/// drag shadow. The \#onDrawShadow(Canvas) onDrawShadow() method allows you to draw
/// anything you want as the drag shadow.
///
///
///
///  You pass a DragShadowBuilder object to the system when you start the drag. The system
///  calls \#onProvideShadowMetrics(Point,Point) onProvideShadowMetrics() to get the
///  size and position of the drag shadow. It uses this data to construct a
///  android.graphics.Canvas object, then it calls \#onDrawShadow(Canvas) onDrawShadow()
///  so that your application can draw the shadow image in the Canvas.
///
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a guide to implementing drag and drop features, read the
/// <a href="{@docRoot}guide/topics/ui/drag-drop.html">Drag and Drop</a> developer guide.
///
/// </div>
class View_DragShadowBuilder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$DragShadowBuilder");
  View_DragShadowBuilder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/view/View;)V");

  /// from: public void <init>(android.view.View view)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a shadow image builder based on a View. By default, the resulting drag
  /// shadow will have the same appearance and dimensions as the View, with the touch point
  /// over the center of the View.
  ///@param view A View. Any View in scope can be used.
  View_DragShadowBuilder(View view)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [view.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a shadow builder object with no associated View.  This
  /// constructor variant is only useful when the \#onProvideShadowMetrics(Point, Point)
  /// and \#onDrawShadow(Canvas) methods are also overridden in order
  /// to supply the drag shadow's dimensions and appearance without
  /// reference to any View object.
  View_DragShadowBuilder.ctor1()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, []).object);

  static final _id_getView =
      jniAccessors.getMethodIDOf(_classRef, "getView", "()Landroid/view/View;");

  /// from: public final android.view.View getView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the View object that had been passed to the
  /// \#View.DragShadowBuilder(View)
  /// constructor.  If that View parameter was {@code null} or if the
  /// \#View.DragShadowBuilder()
  /// constructor was used to instantiate the builder object, this method will return
  /// null.
  ///@return The View object associate with this builder object.
  View getView() => View.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getView, jni.JniType.objectType, []).object);

  static final _id_onProvideShadowMetrics = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideShadowMetrics",
      "(Landroid/graphics/Point;Landroid/graphics/Point;)V");

  /// from: public void onProvideShadowMetrics(android.graphics.Point outShadowSize, android.graphics.Point outShadowTouchPoint)
  ///
  /// Provides the metrics for the shadow image. These include the dimensions of
  /// the shadow image, and the point within that shadow that should
  /// be centered under the touch location while dragging.
  ///
  /// The default implementation sets the dimensions of the shadow to be the
  /// same as the dimensions of the View itself and centers the shadow under
  /// the touch point.
  ///
  ///
  ///@param outShadowSize A android.graphics.Point containing the width and height
  /// of the shadow image. Your application must set android.graphics.Point\#x to the
  /// desired width and must set android.graphics.Point\#y to the desired height of the
  /// image.
  ///@param outShadowTouchPoint A android.graphics.Point for the position within the
  /// shadow image that should be underneath the touch point during the drag and drop
  /// operation. Your application must set android.graphics.Point\#x to the
  /// X coordinate and android.graphics.Point\#y to the Y coordinate of this position.
  void onProvideShadowMetrics(
          point_.Point outShadowSize, point_.Point outShadowTouchPoint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onProvideShadowMetrics,
          jni.JniType.voidType,
          [outShadowSize.reference, outShadowTouchPoint.reference]).check();

  static final _id_onDrawShadow = jniAccessors.getMethodIDOf(
      _classRef, "onDrawShadow", "(Landroid/graphics/Canvas;)V");

  /// from: public void onDrawShadow(android.graphics.Canvas canvas)
  ///
  /// Draws the shadow image. The system creates the android.graphics.Canvas object
  /// based on the dimensions it received from the
  /// \#onProvideShadowMetrics(Point, Point) callback.
  ///@param canvas A android.graphics.Canvas object in which to draw the shadow image.
  void onDrawShadow(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onDrawShadow,
      jni.JniType.voidType,
      [canvas.reference]).check();
}

/// from: android.view.View$BaseSavedState
///
/// Base class for derived classes that want to save and restore their own
/// state in android.view.View\#onSaveInstanceState().
class View_BaseSavedState extends abssavedstate_.AbsSavedState {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$BaseSavedState");
  View_BaseSavedState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR1 = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.View.BaseSavedState> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR1 =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR1, jni.JniType.objectType)
          .object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor used when reading from a parcel. Reads the state of the superclass.
  ///@param source parcel to read from
  View_BaseSavedState.ctor1(parcel_.Parcel source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [source.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/Parcel;Ljava/lang/ClassLoader;)V");

  /// from: public void <init>(android.os.Parcel source, java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor used when reading from a parcel using a given class loader.
  /// Reads the state of the superclass.
  ///@param source parcel to read from
  ///@param loader ClassLoader to use for reading
  View_BaseSavedState.ctor2(parcel_.Parcel source, jni.JniObject loader)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [source.reference, loader.reference]).object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/Parcelable;)V");

  /// from: public void <init>(android.os.Parcelable superState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor called by derived classes when creating their SavedState objects
  ///@param superState The state of the superclass of this view
  View_BaseSavedState(parcelable_.Parcelable superState)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [superState.reference]).object);

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();
}

/// from: android.view.View$AccessibilityDelegate
///
///
/// This class represents a delegate that can be registered in a View
/// to enhance accessibility support via composition rather via inheritance.
/// It is specifically targeted to widget developers that extend basic View
/// classes i.e. classes in package android.view, that would like their
/// applications to be backwards compatible.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about making applications accessible, read the
/// <a href="{@docRoot}guide/topics/ui/accessibility/index.html">Accessibility</a>
/// developer guide.
///
/// </div>
///
/// A scenario in which a developer would like to use an accessibility delegate
/// is overriding a method introduced in a later API version than the minimal API
/// version supported by the application. For example, the method
/// View\#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo) is not available
/// in API version 4 when the accessibility APIs were first introduced. If a
/// developer would like their application to run on API version 4 devices (assuming
/// all other APIs used by the application are version 4 or lower) and take advantage
/// of this method, instead of overriding the method which would break the application's
/// backwards compatibility, they can override the corresponding method in this
/// delegate and register the delegate in the target View if the API version of
/// the system is high enough, i.e. the API version is the same as or higher than the API
/// version that introduced
/// View\#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo).
///
///
///
/// Here is an example implementation:
///
///
/// <code><pre>
/// if (Build.VERSION.SDK_INT >= 14) {
///     // If the API version is equal of higher than the version in
///     // which onInitializeAccessibilityNodeInfo was introduced we
///     // register a delegate with a customized implementation.
///     View view = findViewById(R.id.view_id);
///     view.setAccessibilityDelegate(new AccessibilityDelegate() {
///         public void onInitializeAccessibilityNodeInfo(View host,
///                 AccessibilityNodeInfo info) {
///             // Let the default implementation populate the info.
///             super.onInitializeAccessibilityNodeInfo(host, info);
///             // Set some other information.
///             info.setEnabled(host.isEnabled());
///         }
///     });
/// }
/// </code></pre>
///
///
/// This delegate contains methods that correspond to the accessibility methods
/// in View. If a delegate has been specified the implementation in View hands
/// off handling to the corresponding method in this delegate. The default
/// implementation the delegate methods behaves exactly as the corresponding
/// method in View for the case of no accessibility delegate been set. Hence,
/// to customize the behavior of a View method, clients can override only the
/// corresponding delegate method without altering the behavior of the rest
/// accessibility related methods of the host view.
///
///
///
/// <strong>Note:</strong> On platform versions prior to
/// android.os.Build.VERSION_CODES\#M API 23, delegate methods on
/// views in the {@code android.widget.*} package are called <i>before</i>
/// host methods. This prevents certain properties such as class name from
/// being modified by overriding
/// AccessibilityDelegate\#onInitializeAccessibilityNodeInfo(View, AccessibilityNodeInfo),
/// as any changes will be overwritten by the host class.
///
/// Starting in android.os.Build.VERSION_CODES\#M API 23, delegate
/// methods are called <i>after</i> host methods, which all properties to be
/// modified without being overwritten by the host class.
class View_AccessibilityDelegate extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/View\$AccessibilityDelegate");
  View_AccessibilityDelegate.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  View_AccessibilityDelegate()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_sendAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef, "sendAccessibilityEvent", "(Landroid/view/View;I)V");

  /// from: public void sendAccessibilityEvent(android.view.View host, int eventType)
  ///
  /// Sends an accessibility event of the given type. If accessibility is not
  /// enabled this method has no effect.
  ///
  /// The default implementation behaves as View\#sendAccessibilityEvent(int) View\#sendAccessibilityEvent(int) for the case of no accessibility delegate
  /// been set.
  ///
  ///
  ///@param host The View hosting the delegate.
  ///@param eventType The type of the event to send.
  ///@see View\#sendAccessibilityEvent(int) View\#sendAccessibilityEvent(int)
  void sendAccessibilityEvent(View host, int eventType) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendAccessibilityEvent,
          jni.JniType.voidType, [host.reference, eventType]).check();

  static final _id_performAccessibilityAction = jniAccessors.getMethodIDOf(
      _classRef,
      "performAccessibilityAction",
      "(Landroid/view/View;ILandroid/os/Bundle;)Z");

  /// from: public boolean performAccessibilityAction(android.view.View host, int action, android.os.Bundle args)
  ///
  /// Performs the specified accessibility action on the view. For
  /// possible accessibility actions look at AccessibilityNodeInfo.
  ///
  /// The default implementation behaves as
  /// View\#performAccessibilityAction(int, Bundle) View\#performAccessibilityAction(int, Bundle) for the case of
  ///  no accessibility delegate been set.
  ///
  ///
  ///@param action The action to perform.
  ///@return Whether the action was performed.
  ///@see View\#performAccessibilityAction(int, Bundle) View\#performAccessibilityAction(int, Bundle)
  bool performAccessibilityAction(View host, int action, bundle_.Bundle args) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_performAccessibilityAction,
          jni.JniType.booleanType,
          [host.reference, action, args.reference]).boolean;

  static final _id_sendAccessibilityEventUnchecked = jniAccessors.getMethodIDOf(
      _classRef,
      "sendAccessibilityEventUnchecked",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void sendAccessibilityEventUnchecked(android.view.View host, android.view.accessibility.AccessibilityEvent event)
  ///
  /// Sends an accessibility event. This method behaves exactly as
  /// \#sendAccessibilityEvent(View, int) but takes as an argument an
  /// empty AccessibilityEvent and does not perform a check whether
  /// accessibility is enabled.
  ///
  /// The default implementation behaves as
  /// View\#sendAccessibilityEventUnchecked(AccessibilityEvent) View\#sendAccessibilityEventUnchecked(AccessibilityEvent) for
  /// the case of no accessibility delegate been set.
  ///
  ///
  ///@param host The View hosting the delegate.
  ///@param event The event to send.
  ///@see View\#sendAccessibilityEventUnchecked(AccessibilityEvent) View\#sendAccessibilityEventUnchecked(AccessibilityEvent)
  void sendAccessibilityEventUnchecked(
          View host, accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendAccessibilityEventUnchecked,
          jni.JniType.voidType,
          [host.reference, event.reference]).check();

  static final _id_dispatchPopulateAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchPopulateAccessibilityEvent",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.View host, android.view.accessibility.AccessibilityEvent event)
  ///
  /// Dispatches an AccessibilityEvent to the host View first and then
  /// to its children for adding their text content to the event.
  ///
  /// The default implementation behaves as
  /// View\#dispatchPopulateAccessibilityEvent(AccessibilityEvent) View\#dispatchPopulateAccessibilityEvent(AccessibilityEvent) for
  /// the case of no accessibility delegate been set.
  ///
  ///
  ///@param host The View hosting the delegate.
  ///@param event The event.
  ///@return True if the event population was completed.
  ///@see View\#dispatchPopulateAccessibilityEvent(AccessibilityEvent) View\#dispatchPopulateAccessibilityEvent(AccessibilityEvent)
  bool dispatchPopulateAccessibilityEvent(
          View host, accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPopulateAccessibilityEvent,
          jni.JniType.booleanType,
          [host.reference, event.reference]).boolean;

  static final _id_onPopulateAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onPopulateAccessibilityEvent",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void onPopulateAccessibilityEvent(android.view.View host, android.view.accessibility.AccessibilityEvent event)
  ///
  /// Gives a chance to the host View to populate the accessibility event with its
  /// text content.
  ///
  /// The default implementation behaves as
  /// View\#onPopulateAccessibilityEvent(AccessibilityEvent) View\#onPopulateAccessibilityEvent(AccessibilityEvent) for
  /// the case of no accessibility delegate been set.
  ///
  ///
  ///@param host The View hosting the delegate.
  ///@param event The accessibility event which to populate.
  ///@see View\#onPopulateAccessibilityEvent(AccessibilityEvent) View\#onPopulateAccessibilityEvent(AccessibilityEvent)
  void onPopulateAccessibilityEvent(
          View host, accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPopulateAccessibilityEvent,
          jni.JniType.voidType,
          [host.reference, event.reference]).check();

  static final _id_onInitializeAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onInitializeAccessibilityEvent",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public void onInitializeAccessibilityEvent(android.view.View host, android.view.accessibility.AccessibilityEvent event)
  ///
  /// Initializes an AccessibilityEvent with information about the
  /// the host View which is the event source.
  ///
  /// The default implementation behaves as
  /// View\#onInitializeAccessibilityEvent(AccessibilityEvent) View\#onInitializeAccessibilityEvent(AccessibilityEvent) for
  /// the case of no accessibility delegate been set.
  ///
  ///
  ///@param host The View hosting the delegate.
  ///@param event The event to initialize.
  ///@see View\#onInitializeAccessibilityEvent(AccessibilityEvent) View\#onInitializeAccessibilityEvent(AccessibilityEvent)
  void onInitializeAccessibilityEvent(
          View host, accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onInitializeAccessibilityEvent,
          jni.JniType.voidType,
          [host.reference, event.reference]).check();

  static final _id_onInitializeAccessibilityNodeInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "onInitializeAccessibilityNodeInfo",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityNodeInfo;)V");

  /// from: public void onInitializeAccessibilityNodeInfo(android.view.View host, android.view.accessibility.AccessibilityNodeInfo info)
  ///
  /// Initializes an AccessibilityNodeInfo with information about the host view.
  ///
  /// The default implementation behaves as
  /// View\#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo) View\#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo) for
  /// the case of no accessibility delegate been set.
  ///
  ///
  ///@param host The View hosting the delegate.
  ///@param info The instance to initialize.
  ///@see View\#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo) View\#onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
  void onInitializeAccessibilityNodeInfo(
          View host, accessibilitynodeinfo_.AccessibilityNodeInfo info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onInitializeAccessibilityNodeInfo,
          jni.JniType.voidType,
          [host.reference, info.reference]).check();

  static final _id_addExtraDataToAccessibilityNodeInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "addExtraDataToAccessibilityNodeInfo",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityNodeInfo;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void addExtraDataToAccessibilityNodeInfo(android.view.View host, android.view.accessibility.AccessibilityNodeInfo info, java.lang.String extraDataKey, android.os.Bundle arguments)
  ///
  /// Adds extra data to an AccessibilityNodeInfo based on an explicit request for the
  /// additional data.
  ///
  /// This method only needs to be implemented if the View offers to provide additional data.
  ///
  ///
  ///
  /// The default implementation behaves as
  /// View\#addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo, String, Bundle) for the case where no accessibility delegate is set.
  ///
  ///
  ///@param host The View hosting the delegate. Never {@code null}.
  ///@param info The info to which to add the extra data. Never {@code null}.
  ///@param extraDataKey A key specifying the type of extra data to add to the info. The
  ///                     extra data should be added to the Bundle returned by
  ///                     the info's AccessibilityNodeInfo\#getExtras method.  Never
  ///                     {@code null}.
  ///@param arguments A Bundle holding any arguments relevant for this request.
  ///                  May be {@code null} if the if the service provided no arguments.
  ///@see AccessibilityNodeInfo\#setExtraAvailableData
  ///@param host This value must never be {@code null}.
  ///@param info This value must never be {@code null}.
  ///@param extraDataKey This value must never be {@code null}.
  ///@param arguments This value may be {@code null}.
  void addExtraDataToAccessibilityNodeInfo(
          View host,
          accessibilitynodeinfo_.AccessibilityNodeInfo info,
          jni.JniString extraDataKey,
          bundle_.Bundle arguments) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_addExtraDataToAccessibilityNodeInfo, jni.JniType.voidType, [
        host.reference,
        info.reference,
        extraDataKey.reference,
        arguments.reference
      ]).check();

  static final _id_onRequestSendAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestSendAccessibilityEvent",
      "(Landroid/view/ViewGroup;Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean onRequestSendAccessibilityEvent(android.view.ViewGroup host, android.view.View child, android.view.accessibility.AccessibilityEvent event)
  ///
  /// Called when a child of the host View has requested sending an
  /// AccessibilityEvent and gives an opportunity to the parent (the host)
  /// to augment the event.
  ///
  /// The default implementation behaves as
  /// ViewGroup\#onRequestSendAccessibilityEvent(View, AccessibilityEvent) ViewGroup\#onRequestSendAccessibilityEvent(View, AccessibilityEvent) for
  /// the case of no accessibility delegate been set.
  ///
  ///
  ///@param host The View hosting the delegate.
  ///@param child The child which requests sending the event.
  ///@param event The event to be sent.
  ///@return True if the event should be sent
  ///@see ViewGroup\#onRequestSendAccessibilityEvent(View, AccessibilityEvent) ViewGroup\#onRequestSendAccessibilityEvent(View, AccessibilityEvent)
  bool onRequestSendAccessibilityEvent(viewgroup_.ViewGroup host, View child,
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRequestSendAccessibilityEvent,
          jni.JniType.booleanType,
          [host.reference, child.reference, event.reference]).boolean;

  static final _id_getAccessibilityNodeProvider = jniAccessors.getMethodIDOf(
      _classRef,
      "getAccessibilityNodeProvider",
      "(Landroid/view/View;)Landroid/view/accessibility/AccessibilityNodeProvider;");

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider(android.view.View host)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the provider for managing a virtual view hierarchy rooted at this View
  /// and reported to android.accessibilityservice.AccessibilityServices
  /// that explore the window content.
  ///
  /// The default implementation behaves as
  /// View\#getAccessibilityNodeProvider() View\#getAccessibilityNodeProvider() for
  /// the case of no accessibility delegate been set.
  ///
  ///
  ///@return The provider.
  ///@see AccessibilityNodeProvider
  accessibilitynodeprovider_.AccessibilityNodeProvider
      getAccessibilityNodeProvider(View host) =>
          accessibilitynodeprovider_.AccessibilityNodeProvider.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_getAccessibilityNodeProvider,
                  jni.JniType.objectType,
                  [host.reference]).object);
}
