// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Display.dart" as display_;

import "View.dart" as view_;

import "ViewGroup.dart" as viewgroup_;

import "../os/Parcelable.dart" as parcelable_;

import "../os/IBinder.dart" as ibinder_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.WindowManager
///
/// The interface that apps use to talk to the window manager.
///
///
/// Each window manager instance is bound to a particular Display.
/// To obtain a WindowManager for a different display, use
/// Context\#createDisplayContext to obtain a Context for that
/// display, then use <code>Context.getSystemService(Context.WINDOW_SERVICE)</code>
/// to get the WindowManager.
///
///
/// The simplest way to show a window on another display is to create a
/// Presentation.  The presentation will automatically obtain a
/// WindowManager and Context for that display.
///
///
class WindowManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/WindowManager");
  WindowManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getDefaultDisplay = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultDisplay", "()Landroid/view/Display;");

  /// from: public abstract android.view.Display getDefaultDisplay()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Display upon which this WindowManager instance
  /// will create new windows.
  ///
  /// Despite the name of this method, the display that is returned is not
  /// necessarily the primary display of the system (see Display\#DEFAULT_DISPLAY).
  /// The returned display could instead be a secondary display that this
  /// window manager instance is managing.  Think of it as the display that
  /// this WindowManager instance uses by default.
  ///
  ///
  /// To create windows on a different display, you need to obtain a
  /// WindowManager for that Display.  (See the WindowManager
  /// class documentation for more information.)
  ///
  ///
  ///@return The display that this window manager is managing.
  display_.Display getDefaultDisplay() =>
      display_.Display.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDefaultDisplay, jni.JniType.objectType, []).object);

  static final _id_removeViewImmediate = jniAccessors.getMethodIDOf(
      _classRef, "removeViewImmediate", "(Landroid/view/View;)V");

  /// from: public abstract void removeViewImmediate(android.view.View view)
  ///
  /// Special variation of \#removeView that immediately invokes
  /// the given view hierarchy's View\#onDetachedFromWindow() View.onDetachedFromWindow() methods before returning.  This is not
  /// for normal applications; using it correctly requires great care.
  ///@param view The view to be removed.
  void removeViewImmediate(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeViewImmediate,
      jni.JniType.voidType,
      [view.reference]).check();
}

/// from: android.view.WindowManager$LayoutParams
class WindowManager_LayoutParams extends viewgroup_.ViewGroup_LayoutParams {
  static final _classRef =
      jniAccessors.getClassOf("android/view/WindowManager\$LayoutParams");
  WindowManager_LayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ALPHA_CHANGED
  static const ALPHA_CHANGED = 128;

  /// from: static public final int ANIMATION_CHANGED
  static const ANIMATION_CHANGED = 16;

  /// from: static public final float BRIGHTNESS_OVERRIDE_FULL
  ///
  /// Value for \#screenBrightness and \#buttonBrightness
  /// indicating that the screen or button backlight brightness should be set
  /// to the hightest value when this window is in front.
  static const BRIGHTNESS_OVERRIDE_FULL = 1.0;

  /// from: static public final float BRIGHTNESS_OVERRIDE_NONE
  ///
  /// Default value for \#screenBrightness and \#buttonBrightness
  /// indicating that the brightness value is not overridden for this window
  /// and normal brightness policy should be used.
  static const BRIGHTNESS_OVERRIDE_NONE = -1.0;

  /// from: static public final float BRIGHTNESS_OVERRIDE_OFF
  ///
  /// Value for \#screenBrightness and \#buttonBrightness
  /// indicating that the screen or button backlight brightness should be set
  /// to the lowest value when this window is in front.
  static const BRIGHTNESS_OVERRIDE_OFF = 0.0;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.view.WindowManager.LayoutParams> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int DIM_AMOUNT_CHANGED
  static const DIM_AMOUNT_CHANGED = 32;

  /// from: static public final int FIRST_APPLICATION_WINDOW
  ///
  /// Start of window types that represent normal application windows.
  static const FIRST_APPLICATION_WINDOW = 1;

  /// from: static public final int FIRST_SUB_WINDOW
  ///
  /// Start of types of sub-windows.  The \#token of these windows
  /// must be set to the window they are attached to.  These types of
  /// windows are kept next to their attached window in Z-order, and their
  /// coordinate space is relative to their attached window.
  static const FIRST_SUB_WINDOW = 1000;

  /// from: static public final int FIRST_SYSTEM_WINDOW
  ///
  /// Start of system-specific window types.  These are not normally
  /// created by applications.
  static const FIRST_SYSTEM_WINDOW = 2000;

  /// from: static public final int FLAGS_CHANGED
  static const FLAGS_CHANGED = 4;

  /// from: static public final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON
  ///
  /// Window flag: as long as this window is visible to the user, allow
  ///  the lock screen to activate while the screen is on.
  ///  This can be used independently, or in combination with
  ///  \#FLAG_KEEP_SCREEN_ON and/or \#FLAG_SHOW_WHEN_LOCKED
  static const FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 1;

  /// from: static public final int FLAG_ALT_FOCUSABLE_IM
  ///
  /// Window flag: invert the state of \#FLAG_NOT_FOCUSABLE with
  /// respect to how this window interacts with the current method.  That
  /// is, if FLAG_NOT_FOCUSABLE is set and this flag is set, then the
  /// window will behave as if it needs to interact with the input method
  /// and thus be placed behind/away from it; if FLAG_NOT_FOCUSABLE is
  /// not set and this flag is set, then the window will behave as if it
  /// doesn't need to interact with the input method and can be placed
  /// to use more space and cover the input method.
  static const FLAG_ALT_FOCUSABLE_IM = 131072;

  /// from: static public final int FLAG_BLUR_BEHIND
  ///
  /// Window flag: blur everything behind this window.
  ///@deprecated Blurring is no longer supported.
  static const FLAG_BLUR_BEHIND = 4;

  /// from: static public final int FLAG_DIM_BEHIND
  ///
  /// Window flag: everything behind this window will be dimmed.
  ///  Use \#dimAmount to control the amount of dim.
  static const FLAG_DIM_BEHIND = 2;

  /// from: static public final int FLAG_DISMISS_KEYGUARD
  ///
  /// Window flag: when set the window will cause the keyguard to be
  /// dismissed, only if it is not a secure lock keyguard. Because such a
  /// keyguard is not needed for security, it will never re-appear if the
  /// user navigates to another window (in contrast to
  /// \#FLAG_SHOW_WHEN_LOCKED, which will only temporarily hide both
  /// secure and non-secure keyguards but ensure they reappear when the
  /// user moves to another UI that doesn't hide them). If the keyguard is
  /// currently active and is secure (requires an unlock credential) than
  /// the user will still need to confirm it before seeing this window,
  /// unless \#FLAG_SHOW_WHEN_LOCKED has also been set.
  ///@deprecated Use \#FLAG_SHOW_WHEN_LOCKED or
  ///             KeyguardManager\#requestDismissKeyguard instead.
  ///             Since keyguard was dismissed all the time as long as an
  ///             activity with this flag on its window was focused,
  ///             keyguard couldn't guard against unintentional touches on
  ///             the screen, which isn't desired.
  static const FLAG_DISMISS_KEYGUARD = 4194304;

  /// from: static public final int FLAG_DITHER
  ///
  /// Window flag: turn on dithering when compositing this window to
  ///  the screen.
  ///@deprecated This flag is no longer used.
  static const FLAG_DITHER = 4096;

  /// from: static public final int FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS
  ///
  /// Flag indicating that this Window is responsible for drawing the background for the
  /// system bars. If set, the system bars are drawn with a transparent background and the
  /// corresponding areas in this window are filled with the colors specified in
  /// Window\#getStatusBarColor() and Window\#getNavigationBarColor().
  static const FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS = -2147483648;

  /// from: static public final int FLAG_FORCE_NOT_FULLSCREEN
  ///
  /// Window flag: override \#FLAG_FULLSCREEN and force the
  ///  screen decorations (such as the status bar) to be shown.
  static const FLAG_FORCE_NOT_FULLSCREEN = 2048;

  /// from: static public final int FLAG_FULLSCREEN
  ///
  /// Window flag: hide all screen decorations (such as the status bar) while
  /// this window is displayed.  This allows the window to use the entire
  /// display space for itself -- the status bar will be hidden when
  /// an app window with this flag set is on the top layer. A fullscreen window
  /// will ignore a value of \#SOFT_INPUT_ADJUST_RESIZE for the window's
  /// \#softInputMode field; the window will stay fullscreen
  /// and will not resize.
  ///
  /// This flag can be controlled in your theme through the
  /// android.R.attr\#windowFullscreen attribute; this attribute
  /// is automatically set for you in the standard fullscreen themes
  /// such as android.R.style\#Theme_NoTitleBar_Fullscreen,
  /// android.R.style\#Theme_Black_NoTitleBar_Fullscreen,
  /// android.R.style\#Theme_Light_NoTitleBar_Fullscreen,
  /// android.R.style\#Theme_Holo_NoActionBar_Fullscreen,
  /// android.R.style\#Theme_Holo_Light_NoActionBar_Fullscreen,
  /// android.R.style\#Theme_DeviceDefault_NoActionBar_Fullscreen, and
  /// android.R.style\#Theme_DeviceDefault_Light_NoActionBar_Fullscreen.
  ///
  static const FLAG_FULLSCREEN = 1024;

  /// from: static public final int FLAG_HARDWARE_ACCELERATED
  ///
  /// Indicates whether this window should be hardware accelerated.
  /// Requesting hardware acceleration does not guarantee it will happen.
  ///
  ///
  /// This flag can be controlled programmatically _only_ to enable
  /// hardware acceleration. To enable hardware acceleration for a given
  /// window programmatically, do the following:
  ///
  ///
  /// <pre>
  /// Window w = activity.getWindow(); // in Activity's onCreate() for instance
  /// w.setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
  ///         WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
  /// </pre>
  ///
  /// It is important to remember that this flag <strong>must</strong>
  /// be set before setting the content view of your activity or dialog.
  ///
  ///
  /// This flag cannot be used to disable hardware acceleration after it
  /// was enabled in your manifest using
  /// android.R.attr\#hardwareAccelerated. If you need to selectively
  /// and programmatically disable hardware acceleration (for automated testing
  /// for instance), make sure it is turned off in your manifest and enable it
  /// on your activity or dialog when you need it instead, using the method
  /// described above.
  ///
  ///
  /// This flag is automatically set by the system if the
  /// android.R.attr\#hardwareAccelerated android:hardwareAccelerated
  /// XML attribute is set to true on an activity or on the application.
  ///
  static const FLAG_HARDWARE_ACCELERATED = 16777216;

  /// from: static public final int FLAG_IGNORE_CHEEK_PRESSES
  ///
  /// Window flag: intended for windows that will often be used when the user is
  /// holding the screen against their face, it will aggressively filter the event
  /// stream to prevent unintended presses in this situation that may not be
  /// desired for a particular window, when such an event stream is detected, the
  /// application will receive a CANCEL motion event to indicate this so applications
  /// can handle this accordingly by taking no action on the event
  /// until the finger is released.
  static const FLAG_IGNORE_CHEEK_PRESSES = 32768;

  /// from: static public final int FLAG_KEEP_SCREEN_ON
  ///
  /// Window flag: as long as this window is visible to the user, keep
  ///  the device's screen turned on and bright.
  static const FLAG_KEEP_SCREEN_ON = 128;

  /// from: static public final int FLAG_LAYOUT_ATTACHED_IN_DECOR
  ///
  /// Window flag: When requesting layout with an attached window, the attached window may
  /// overlap with the screen decorations of the parent window such as the navigation bar. By
  /// including this flag, the window manager will layout the attached window within the decor
  /// frame of the parent window such that it doesn't overlap with screen decorations.
  static const FLAG_LAYOUT_ATTACHED_IN_DECOR = 1073741824;

  /// from: static public final int FLAG_LAYOUT_INSET_DECOR
  ///
  /// Window flag: a special option only for use in combination with
  /// \#FLAG_LAYOUT_IN_SCREEN.  When requesting layout in the
  /// screen your window may appear on top of or behind screen decorations
  /// such as the status bar.  By also including this flag, the window
  /// manager will report the inset rectangle needed to ensure your
  /// content is not covered by screen decorations.  This flag is normally
  /// set for you by Window as described in Window\#setFlags.
  static const FLAG_LAYOUT_INSET_DECOR = 65536;

  /// from: static public final int FLAG_LAYOUT_IN_OVERSCAN
  ///
  /// Window flag: allow window contents to extend in to the screen's
  /// overscan area, if there is one.  The window should still correctly
  /// position its contents to take the overscan area into account.
  ///
  /// This flag can be controlled in your theme through the
  /// android.R.attr\#windowOverscan attribute; this attribute
  /// is automatically set for you in the standard overscan themes
  /// such as
  /// android.R.style\#Theme_Holo_NoActionBar_Overscan,
  /// android.R.style\#Theme_Holo_Light_NoActionBar_Overscan,
  /// android.R.style\#Theme_DeviceDefault_NoActionBar_Overscan, and
  /// android.R.style\#Theme_DeviceDefault_Light_NoActionBar_Overscan.
  ///
  ///
  /// When this flag is enabled for a window, its normal content may be obscured
  /// to some degree by the overscan region of the display.  To ensure key parts of
  /// that content are visible to the user, you can use
  /// View\#setFitsSystemWindows(boolean) View.setFitsSystemWindows(boolean)
  /// to set the point in the view hierarchy where the appropriate offsets should
  /// be applied.  (This can be done either by directly calling this function, using
  /// the android.R.attr\#fitsSystemWindows attribute in your view hierarchy,
  /// or implementing you own View\#fitSystemWindows(android.graphics.Rect) View.fitSystemWindows(Rect) method).
  ///
  ///
  /// This mechanism for positioning content elements is identical to its equivalent
  /// use with layout and View\#setSystemUiVisibility(int) View.setSystemUiVisibility(int); here is an example layout that will correctly
  /// position its UI elements with this overscan flag is set:
  ///
  ///
  /// {@sample development/samples/ApiDemos/res/layout/overscan_activity.xml complete}
  static const FLAG_LAYOUT_IN_OVERSCAN = 33554432;

  /// from: static public final int FLAG_LAYOUT_IN_SCREEN
  ///
  /// Window flag: place the window within the entire screen, ignoring
  ///  decorations around the border (such as the status bar).  The
  ///  window must correctly position its contents to take the screen
  ///  decoration into account.  This flag is normally set for you
  ///  by Window as described in Window\#setFlags.
  ///
  ///  Note: on displays that have a DisplayCutout, the window may be placed
  ///  such that it avoids the DisplayCutout area if necessary according to the
  ///  \#layoutInDisplayCutoutMode.
  static const FLAG_LAYOUT_IN_SCREEN = 256;

  /// from: static public final int FLAG_LAYOUT_NO_LIMITS
  ///
  /// Window flag: allow window to extend outside of the screen.
  static const FLAG_LAYOUT_NO_LIMITS = 512;

  /// from: static public final int FLAG_LOCAL_FOCUS_MODE
  ///
  /// Flag for a window in local focus mode.
  /// Window in local focus mode can control focus independent of window manager using
  /// Window\#setLocalFocus(boolean, boolean).
  /// Usually window in this mode will not get touch/key events from window manager, but will
  /// get events only via local injection using Window\#injectInputEvent(InputEvent).
  static const FLAG_LOCAL_FOCUS_MODE = 268435456;

  /// from: static public final int FLAG_NOT_FOCUSABLE
  ///
  /// Window flag: this window won't ever get key input focus, so the
  /// user can not send key or other button events to it.  Those will
  /// instead go to whatever focusable window is behind it.  This flag
  /// will also enable \#FLAG_NOT_TOUCH_MODAL whether or not that
  /// is explicitly set.
  ///
  /// Setting this flag also implies that the window will not need to
  /// interact with
  /// a soft input method, so it will be Z-ordered and positioned
  /// independently of any active input method (typically this means it
  /// gets Z-ordered on top of the input method, so it can use the full
  /// screen for its content and cover the input method if needed.  You
  /// can use \#FLAG_ALT_FOCUSABLE_IM to modify this behavior.
  static const FLAG_NOT_FOCUSABLE = 8;

  /// from: static public final int FLAG_NOT_TOUCHABLE
  ///
  /// Window flag: this window can never receive touch events.
  static const FLAG_NOT_TOUCHABLE = 16;

  /// from: static public final int FLAG_NOT_TOUCH_MODAL
  ///
  /// Window flag: even when this window is focusable (its
  /// \#FLAG_NOT_FOCUSABLE is not set), allow any pointer events
  /// outside of the window to be sent to the windows behind it.  Otherwise
  /// it will consume all pointer events itself, regardless of whether they
  /// are inside of the window.
  static const FLAG_NOT_TOUCH_MODAL = 32;

  /// from: static public final int FLAG_SCALED
  ///
  /// Window flag: a special mode where the layout parameters are used
  /// to perform scaling of the surface when it is composited to the
  /// screen.
  static const FLAG_SCALED = 16384;

  /// from: static public final int FLAG_SECURE
  ///
  /// Window flag: treat the content of the window as secure, preventing
  /// it from appearing in screenshots or from being viewed on non-secure
  /// displays.
  ///
  /// See android.view.Display\#FLAG_SECURE for more details about
  /// secure surfaces and secure displays.
  static const FLAG_SECURE = 8192;

  /// from: static public final int FLAG_SHOW_WALLPAPER
  ///
  /// Window flag: ask that the system wallpaper be shown behind
  /// your window.  The window surface must be translucent to be able
  /// to actually see the wallpaper behind it; this flag just ensures
  /// that the wallpaper surface will be there if this window actually
  /// has translucent regions.
  ///
  /// This flag can be controlled in your theme through the
  /// android.R.attr\#windowShowWallpaper attribute; this attribute
  /// is automatically set for you in the standard wallpaper themes
  /// such as android.R.style\#Theme_Wallpaper,
  /// android.R.style\#Theme_Wallpaper_NoTitleBar,
  /// android.R.style\#Theme_Wallpaper_NoTitleBar_Fullscreen,
  /// android.R.style\#Theme_Holo_Wallpaper,
  /// android.R.style\#Theme_Holo_Wallpaper_NoTitleBar,
  /// android.R.style\#Theme_DeviceDefault_Wallpaper, and
  /// android.R.style\#Theme_DeviceDefault_Wallpaper_NoTitleBar.
  ///
  static const FLAG_SHOW_WALLPAPER = 1048576;

  /// from: static public final int FLAG_SHOW_WHEN_LOCKED
  ///
  /// Window flag: special flag to let windows be shown when the screen
  /// is locked. This will let application windows take precedence over
  /// key guard or any other lock screens. Can be used with
  /// \#FLAG_KEEP_SCREEN_ON to turn screen on and display windows
  /// directly before showing the key guard window.  Can be used with
  /// \#FLAG_DISMISS_KEYGUARD to automatically fully dismisss
  /// non-secure keyguards.  This flag only applies to the top-most
  /// full-screen window.
  ///@deprecated Use android.R.attr\#showWhenLocked or
  /// android.app.Activity\#setShowWhenLocked(boolean) instead to prevent an
  /// unintentional double life-cycle event.
  static const FLAG_SHOW_WHEN_LOCKED = 524288;

  /// from: static public final int FLAG_SPLIT_TOUCH
  ///
  /// Window flag: when set the window will accept for touch events
  /// outside of its bounds to be sent to other windows that also
  /// support split touch.  When this flag is not set, the first pointer
  /// that goes down determines the window to which all subsequent touches
  /// go until all pointers go up.  When this flag is set, each pointer
  /// (not necessarily the first) that goes down determines the window
  /// to which all subsequent touches of that pointer will go until that
  /// pointer goes up thereby enabling touches with multiple pointers
  /// to be split across multiple windows.
  static const FLAG_SPLIT_TOUCH = 8388608;

  /// from: static public final int FLAG_TOUCHABLE_WHEN_WAKING
  ///
  /// Window flag: when set, if the device is asleep when the touch
  /// screen is pressed, you will receive this first touch event.  Usually
  /// the first touch event is consumed by the system since the user can
  /// not see what they are pressing on.
  ///@deprecated This flag has no effect.
  static const FLAG_TOUCHABLE_WHEN_WAKING = 64;

  /// from: static public final int FLAG_TRANSLUCENT_NAVIGATION
  ///
  /// Window flag: request a translucent navigation bar with minimal system-provided
  /// background protection.
  ///
  /// This flag can be controlled in your theme through the
  /// android.R.attr\#windowTranslucentNavigation attribute; this attribute
  /// is automatically set for you in the standard translucent decor themes
  /// such as
  /// android.R.style\#Theme_Holo_NoActionBar_TranslucentDecor,
  /// android.R.style\#Theme_Holo_Light_NoActionBar_TranslucentDecor,
  /// android.R.style\#Theme_DeviceDefault_NoActionBar_TranslucentDecor, and
  /// android.R.style\#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor.
  ///
  ///
  /// When this flag is enabled for a window, it automatically sets
  /// the system UI visibility flags View\#SYSTEM_UI_FLAG_LAYOUT_STABLE and
  /// View\#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION.
  ///
  static const FLAG_TRANSLUCENT_NAVIGATION = 134217728;

  /// from: static public final int FLAG_TRANSLUCENT_STATUS
  ///
  /// Window flag: request a translucent status bar with minimal system-provided
  /// background protection.
  ///
  /// This flag can be controlled in your theme through the
  /// android.R.attr\#windowTranslucentStatus attribute; this attribute
  /// is automatically set for you in the standard translucent decor themes
  /// such as
  /// android.R.style\#Theme_Holo_NoActionBar_TranslucentDecor,
  /// android.R.style\#Theme_Holo_Light_NoActionBar_TranslucentDecor,
  /// android.R.style\#Theme_DeviceDefault_NoActionBar_TranslucentDecor, and
  /// android.R.style\#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor.
  ///
  ///
  /// When this flag is enabled for a window, it automatically sets
  /// the system UI visibility flags View\#SYSTEM_UI_FLAG_LAYOUT_STABLE and
  /// View\#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN.
  ///
  static const FLAG_TRANSLUCENT_STATUS = 67108864;

  /// from: static public final int FLAG_TURN_SCREEN_ON
  ///
  /// Window flag: when set as a window is being added or made
  /// visible, once the window has been shown then the system will
  /// poke the power manager's user activity (as if the user had woken
  /// up the device) to turn the screen on.
  ///@deprecated Use android.R.attr\#turnScreenOn or
  /// android.app.Activity\#setTurnScreenOn(boolean) instead to prevent an
  /// unintentional double life-cycle event.
  static const FLAG_TURN_SCREEN_ON = 2097152;

  /// from: static public final int FLAG_WATCH_OUTSIDE_TOUCH
  ///
  /// Window flag: if you have set \#FLAG_NOT_TOUCH_MODAL, you
  /// can set this flag to receive a single special MotionEvent with
  /// the action
  /// MotionEvent\#ACTION_OUTSIDE MotionEvent.ACTION_OUTSIDE for
  /// touches that occur outside of your window.  Note that you will not
  /// receive the full down/move/up gesture, only the location of the
  /// first down as an ACTION_OUTSIDE.
  static const FLAG_WATCH_OUTSIDE_TOUCH = 262144;

  /// from: static public final int FORMAT_CHANGED
  static const FORMAT_CHANGED = 8;

  /// from: static public final int LAST_APPLICATION_WINDOW
  ///
  /// End of types of application windows.
  static const LAST_APPLICATION_WINDOW = 99;

  /// from: static public final int LAST_SUB_WINDOW
  ///
  /// End of types of sub-windows.
  static const LAST_SUB_WINDOW = 1999;

  /// from: static public final int LAST_SYSTEM_WINDOW
  ///
  /// End of types of system windows.
  static const LAST_SYSTEM_WINDOW = 2999;

  /// from: static public final int LAYOUT_CHANGED
  static const LAYOUT_CHANGED = 1;

  /// from: static public final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
  ///
  /// The window is allowed to extend into the DisplayCutout area, only if the
  /// DisplayCutout is fully contained within a system bar. Otherwise, the window is
  /// laid out such that it does not overlap with the DisplayCutout area.
  ///
  ///
  /// In practice, this means that if the window did not set \#FLAG_FULLSCREEN or
  /// View\#SYSTEM_UI_FLAG_FULLSCREEN, it can extend into the cutout area in portrait
  /// if the cutout is at the top edge. Similarly for
  /// View\#SYSTEM_UI_FLAG_HIDE_NAVIGATION and a cutout at the bottom of the screen.
  /// Otherwise (i.e. fullscreen or landscape) it is laid out such that it does not overlap the
  /// cutout area.
  ///
  ///
  /// The usual precautions for not overlapping with the status and navigation bar are
  /// sufficient for ensuring that no important content overlaps with the DisplayCutout.
  ///@see DisplayCutout
  ///@see WindowInsets
  ///@see \#layoutInDisplayCutoutMode
  ///@see android.R.attr\#windowLayoutInDisplayCutoutMode android:windowLayoutInDisplayCutoutMode
  static const LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT = 0;

  /// from: static public final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER
  ///
  /// The window is never allowed to overlap with the DisplayCutout area.
  ///
  ///
  /// This should be used with windows that transiently set
  /// View\#SYSTEM_UI_FLAG_FULLSCREEN or View\#SYSTEM_UI_FLAG_HIDE_NAVIGATION
  /// to avoid a relayout of the window when the respective flag is set or cleared.
  ///@see DisplayCutout
  ///@see \#layoutInDisplayCutoutMode
  ///@see android.R.attr\#windowLayoutInDisplayCutoutMode android:windowLayoutInDisplayCutoutMode
  static const LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER = 2;

  /// from: static public final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
  ///
  /// The window is always allowed to extend into the DisplayCutout areas on the short
  /// edges of the screen.
  ///
  /// The window will never extend into a DisplayCutout area on the long edges of the
  /// screen.
  ///
  ///
  /// The window must make sure that no important content overlaps with the
  /// DisplayCutout.
  ///
  ///
  /// In this mode, the window extends under cutouts on the short edge of the display in both
  /// portrait and landscape, regardless of whether the window is hiding the system bars:<br/>
  /// <img src="{@docRoot}reference/android/images/display_cutout/short_edge/fullscreen_top_no_letterbox.png"height="720"alt="Screenshot of a fullscreen activity on a display with a cutout at the top edge in
  ///         portrait, no letterbox is applied."/>
  ///
  /// <img src="{@docRoot}reference/android/images/display_cutout/short_edge/landscape_top_no_letterbox.png"width="720"alt="Screenshot of an activity on a display with a cutout at the top edge in landscape,
  ///         no letterbox is applied."/>
  ///
  ///
  /// A cutout in the corner is considered to be on the short edge: <br/>
  /// <img src="{@docRoot}reference/android/images/display_cutout/short_edge/fullscreen_corner_no_letterbox.png"height="720"alt="Screenshot of a fullscreen activity on a display with a cutout in the corner in
  ///         portrait, no letterbox is applied."/>
  ///
  ///
  /// On the other hand, should the cutout be on the long edge of the display, a letterbox will
  /// be applied such that the window does not extend into the cutout on either long edge:
  /// <br/>
  /// <img src="{@docRoot}reference/android/images/display_cutout/short_edge/portrait_side_letterbox.png"height="720"alt="Screenshot of an activity on a display with a cutout on the long edge in portrait,
  ///         letterbox is applied."/>
  ///@see DisplayCutout
  ///@see WindowInsets\#getDisplayCutout()
  ///@see \#layoutInDisplayCutoutMode
  ///@see android.R.attr\#windowLayoutInDisplayCutoutMode android:windowLayoutInDisplayCutoutMode
  static const LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES = 1;

  /// from: static public final int MEMORY_TYPE_CHANGED
  static const MEMORY_TYPE_CHANGED = 256;

  /// from: static public final int MEMORY_TYPE_GPU
  ///
  /// @deprecated this is ignored, this value is set automatically when needed.
  static const MEMORY_TYPE_GPU = 2;

  /// from: static public final int MEMORY_TYPE_HARDWARE
  ///
  /// @deprecated this is ignored, this value is set automatically when needed.
  static const MEMORY_TYPE_HARDWARE = 1;

  /// from: static public final int MEMORY_TYPE_NORMAL
  ///
  /// @deprecated this is ignored, this value is set automatically when needed.
  static const MEMORY_TYPE_NORMAL = 0;

  /// from: static public final int MEMORY_TYPE_PUSH_BUFFERS
  ///
  /// @deprecated this is ignored, this value is set automatically when needed.
  static const MEMORY_TYPE_PUSH_BUFFERS = 3;

  /// from: static public final int ROTATION_ANIMATION_CHANGED
  static const ROTATION_ANIMATION_CHANGED = 4096;

  /// from: static public final int ROTATION_ANIMATION_CROSSFADE
  ///
  /// Value for \#rotationAnimation which specifies that this
  /// window will fade in or out following a rotation.
  static const ROTATION_ANIMATION_CROSSFADE = 1;

  /// from: static public final int ROTATION_ANIMATION_JUMPCUT
  ///
  /// Value for \#rotationAnimation which specifies that this window
  /// will immediately disappear or appear following a rotation.
  static const ROTATION_ANIMATION_JUMPCUT = 2;

  /// from: static public final int ROTATION_ANIMATION_ROTATE
  ///
  /// Value for \#rotationAnimation which specifies that this
  /// window will visually rotate in or out following a rotation.
  static const ROTATION_ANIMATION_ROTATE = 0;

  /// from: static public final int ROTATION_ANIMATION_SEAMLESS
  ///
  /// Value for \#rotationAnimation to specify seamless rotation mode.
  /// This works like JUMPCUT but will fall back to CROSSFADE if rotation
  /// can't be applied without pausing the screen. For example, this is ideal
  /// for Camera apps which don't want the viewfinder contents to ever rotate
  /// or fade (and rather to be seamless) but also don't want ROTATION_ANIMATION_JUMPCUT
  /// during app transition scenarios where seamless rotation can't be applied.
  static const ROTATION_ANIMATION_SEAMLESS = 3;

  /// from: static public final int SCREEN_BRIGHTNESS_CHANGED
  static const SCREEN_BRIGHTNESS_CHANGED = 2048;

  /// from: static public final int SCREEN_ORIENTATION_CHANGED
  static const SCREEN_ORIENTATION_CHANGED = 1024;

  /// from: static public final int SOFT_INPUT_ADJUST_NOTHING
  ///
  /// Adjustment option for \#softInputMode: set to have a window
  /// not adjust for a shown input method.  The window will not be resized,
  /// and it will not be panned to make its focus visible.
  static const SOFT_INPUT_ADJUST_NOTHING = 48;

  /// from: static public final int SOFT_INPUT_ADJUST_PAN
  ///
  /// Adjustment option for \#softInputMode: set to have a window
  /// pan when an input method is
  /// shown, so it doesn't need to deal with resizing but just panned
  /// by the framework to ensure the current input focus is visible.  This
  /// can _not_ be combined with \#SOFT_INPUT_ADJUST_RESIZE; if
  /// neither of these are set, then the system will try to pick one or
  /// the other depending on the contents of the window.
  static const SOFT_INPUT_ADJUST_PAN = 32;

  /// from: static public final int SOFT_INPUT_ADJUST_RESIZE
  ///
  /// Adjustment option for \#softInputMode: set to allow the
  /// window to be resized when an input
  /// method is shown, so that its contents are not covered by the input
  /// method.  This can _not_ be combined with
  /// \#SOFT_INPUT_ADJUST_PAN; if
  /// neither of these are set, then the system will try to pick one or
  /// the other depending on the contents of the window. If the window's
  /// layout parameter flags include \#FLAG_FULLSCREEN, this
  /// value for \#softInputMode will be ignored; the window will
  /// not resize, but will stay fullscreen.
  static const SOFT_INPUT_ADJUST_RESIZE = 16;

  /// from: static public final int SOFT_INPUT_ADJUST_UNSPECIFIED
  ///
  /// Adjustment option for \#softInputMode: nothing specified.
  /// The system will try to pick one or
  /// the other depending on the contents of the window.
  static const SOFT_INPUT_ADJUST_UNSPECIFIED = 0;

  /// from: static public final int SOFT_INPUT_IS_FORWARD_NAVIGATION
  ///
  /// Bit for \#softInputMode: set when the user has navigated
  /// forward to the window.  This is normally set automatically for
  /// you by the system, though you may want to set it in certain cases
  /// when you are displaying a window yourself.  This flag will always
  /// be cleared automatically after the window is displayed.
  static const SOFT_INPUT_IS_FORWARD_NAVIGATION = 256;

  /// from: static public final int SOFT_INPUT_MASK_ADJUST
  ///
  /// Mask for \#softInputMode of the bits that determine the
  /// way that the window should be adjusted to accommodate the soft
  /// input window.
  static const SOFT_INPUT_MASK_ADJUST = 240;

  /// from: static public final int SOFT_INPUT_MASK_STATE
  ///
  /// Mask for \#softInputMode of the bits that determine the
  /// desired visibility state of the soft input area for this window.
  static const SOFT_INPUT_MASK_STATE = 15;

  /// from: static public final int SOFT_INPUT_MODE_CHANGED
  static const SOFT_INPUT_MODE_CHANGED = 512;

  /// from: static public final int SOFT_INPUT_STATE_ALWAYS_HIDDEN
  ///
  /// Visibility state for \#softInputMode: please always hide any
  /// soft input area when this window receives focus.
  static const SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;

  /// from: static public final int SOFT_INPUT_STATE_ALWAYS_VISIBLE
  ///
  /// Visibility state for \#softInputMode: please always make the
  /// soft input area visible when this window receives input focus.
  ///
  /// Applications that target android.os.Build.VERSION_CODES\#P and later, this flag
  /// is ignored unless there is a focused view that returns {@code true} from
  /// View\#isInEditMode() when the window is focused.
  ///
  static const SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5;

  /// from: static public final int SOFT_INPUT_STATE_HIDDEN
  ///
  /// Visibility state for \#softInputMode: please hide any soft input
  /// area when normally appropriate (when the user is navigating
  /// forward to your window).
  static const SOFT_INPUT_STATE_HIDDEN = 2;

  /// from: static public final int SOFT_INPUT_STATE_UNCHANGED
  ///
  /// Visibility state for \#softInputMode: please don't change the state of
  /// the soft input area.
  static const SOFT_INPUT_STATE_UNCHANGED = 1;

  /// from: static public final int SOFT_INPUT_STATE_UNSPECIFIED
  ///
  /// Visibility state for \#softInputMode: no state has been specified. The system may
  /// show or hide the software keyboard for better user experience when the window gains
  /// focus.
  static const SOFT_INPUT_STATE_UNSPECIFIED = 0;

  /// from: static public final int SOFT_INPUT_STATE_VISIBLE
  ///
  /// Visibility state for \#softInputMode: please show the soft
  /// input area when normally appropriate (when the user is navigating
  /// forward to your window).
  ///
  /// Applications that target android.os.Build.VERSION_CODES\#P and later, this flag
  /// is ignored unless there is a focused view that returns {@code true} from
  /// View\#isInEditMode() when the window is focused.
  ///
  static const SOFT_INPUT_STATE_VISIBLE = 4;

  /// from: static public final int TITLE_CHANGED
  static const TITLE_CHANGED = 64;

  /// from: static public final int TYPE_ACCESSIBILITY_OVERLAY
  ///
  /// Window type: Windows that are overlaid _only_ by a connected android.accessibilityservice.AccessibilityService for interception of
  /// user interactions without changing the windows an accessibility service
  /// can introspect. In particular, an accessibility service can introspect
  /// only windows that a sighted user can interact with which is they can touch
  /// these windows or can type into these windows. For example, if there
  /// is a full screen accessibility overlay that is touchable, the windows
  /// below it will be introspectable by an accessibility service even though
  /// they are covered by a touchable window.
  static const TYPE_ACCESSIBILITY_OVERLAY = 2032;

  /// from: static public final int TYPE_APPLICATION
  ///
  /// Window type: a normal application window.  The \#token must be
  /// an Activity token identifying who the window belongs to.
  /// In multiuser systems shows only on the owning user's window.
  static const TYPE_APPLICATION = 2;

  /// from: static public final int TYPE_APPLICATION_ATTACHED_DIALOG
  ///
  /// Window type: like \#TYPE_APPLICATION_PANEL, but layout
  /// of the window happens as that of a top-level window, _not_
  /// as a child of its container.
  static const TYPE_APPLICATION_ATTACHED_DIALOG = 1003;

  /// from: static public final int TYPE_APPLICATION_MEDIA
  ///
  /// Window type: window for showing media (such as video).  These windows
  /// are displayed behind their attached window.
  static const TYPE_APPLICATION_MEDIA = 1001;

  /// from: static public final int TYPE_APPLICATION_OVERLAY
  ///
  /// Window type: Application overlay windows are displayed above all activity windows
  /// (types between \#FIRST_APPLICATION_WINDOW and \#LAST_APPLICATION_WINDOW)
  /// but below critical system windows like the status bar or IME.
  ///
  /// The system may change the position, size, or visibility of these windows at anytime
  /// to reduce visual clutter to the user and also manage resources.
  ///
  /// Requires android.Manifest.permission\#SYSTEM_ALERT_WINDOW permission.
  ///
  /// The system will adjust the importance of processes with this window type to reduce the
  /// chance of the low-memory-killer killing them.
  ///
  /// In multi-user systems shows only on the owning user's screen.
  static const TYPE_APPLICATION_OVERLAY = 2038;

  /// from: static public final int TYPE_APPLICATION_PANEL
  ///
  /// Window type: a panel on top of an application window.  These windows
  /// appear on top of their attached window.
  static const TYPE_APPLICATION_PANEL = 1000;

  /// from: static public final int TYPE_APPLICATION_STARTING
  ///
  /// Window type: special application window that is displayed while the
  /// application is starting.  Not for use by applications themselves;
  /// this is used by the system to display something until the
  /// application can show its own windows.
  /// In multiuser systems shows on all users' windows.
  static const TYPE_APPLICATION_STARTING = 3;

  /// from: static public final int TYPE_APPLICATION_SUB_PANEL
  ///
  /// Window type: a sub-panel on top of an application window.  These
  /// windows are displayed on top their attached window and any
  /// \#TYPE_APPLICATION_PANEL panels.
  static const TYPE_APPLICATION_SUB_PANEL = 1002;

  /// from: static public final int TYPE_BASE_APPLICATION
  ///
  /// Window type: an application window that serves as the "base" window
  /// of the overall application; all other application windows will
  /// appear on top of it.
  /// In multiuser systems shows only on the owning user's window.
  static const TYPE_BASE_APPLICATION = 1;

  /// from: static public final int TYPE_CHANGED
  static const TYPE_CHANGED = 2;

  /// from: static public final int TYPE_DRAWN_APPLICATION
  ///
  /// Window type: a variation on TYPE_APPLICATION that ensures the window
  /// manager will wait for this window to be drawn before the app is shown.
  /// In multiuser systems shows only on the owning user's window.
  static const TYPE_DRAWN_APPLICATION = 4;

  /// from: static public final int TYPE_INPUT_METHOD
  ///
  /// Window type: internal input methods windows, which appear above
  /// the normal UI.  Application windows may be resized or panned to keep
  /// the input focus visible while this window is displayed.
  /// In multiuser systems shows only on the owning user's window.
  static const TYPE_INPUT_METHOD = 2011;

  /// from: static public final int TYPE_INPUT_METHOD_DIALOG
  ///
  /// Window type: internal input methods dialog windows, which appear above
  /// the current input method window.
  /// In multiuser systems shows only on the owning user's window.
  static const TYPE_INPUT_METHOD_DIALOG = 2012;

  /// from: static public final int TYPE_KEYGUARD_DIALOG
  ///
  /// Window type: dialogs that the keyguard shows
  /// In multiuser systems shows on all users' windows.
  static const TYPE_KEYGUARD_DIALOG = 2009;

  /// from: static public final int TYPE_PHONE
  ///
  /// Window type: phone.  These are non-application windows providing
  /// user interaction with the phone (in particular incoming calls).
  /// These windows are normally placed above all applications, but behind
  /// the status bar.
  /// In multiuser systems shows on all users' windows.
  ///@deprecated for non-system apps. Use \#TYPE_APPLICATION_OVERLAY instead.
  static const TYPE_PHONE = 2002;

  /// from: static public final int TYPE_PRIORITY_PHONE
  ///
  /// Window type: priority phone UI, which needs to be displayed even if
  /// the keyguard is active.  These windows must not take input
  /// focus, or they will interfere with the keyguard.
  /// In multiuser systems shows on all users' windows.
  ///@deprecated for non-system apps. Use \#TYPE_APPLICATION_OVERLAY instead.
  static const TYPE_PRIORITY_PHONE = 2007;

  /// from: static public final int TYPE_PRIVATE_PRESENTATION
  ///
  /// Window type: Window for Presentation on top of private
  /// virtual display.
  static const TYPE_PRIVATE_PRESENTATION = 2030;

  /// from: static public final int TYPE_SEARCH_BAR
  ///
  /// Window type: the search bar.  There can be only one search bar
  /// window; it is placed at the top of the screen.
  /// In multiuser systems shows on all users' windows.
  static const TYPE_SEARCH_BAR = 2001;

  /// from: static public final int TYPE_STATUS_BAR
  ///
  /// Window type: the status bar.  There can be only one status bar
  /// window; it is placed at the top of the screen, and all other
  /// windows are shifted down so they are below it.
  /// In multiuser systems shows on all users' windows.
  static const TYPE_STATUS_BAR = 2000;

  /// from: static public final int TYPE_STATUS_BAR_PANEL
  ///
  /// Window type: panel that slides out from over the status bar
  /// In multiuser systems shows on all users' windows.
  static const TYPE_STATUS_BAR_PANEL = 2014;

  /// from: static public final int TYPE_SYSTEM_ALERT
  ///
  /// Window type: system window, such as low power alert. These windows
  /// are always on top of application windows.
  /// In multiuser systems shows only on the owning user's window.
  ///@deprecated for non-system apps. Use \#TYPE_APPLICATION_OVERLAY instead.
  static const TYPE_SYSTEM_ALERT = 2003;

  /// from: static public final int TYPE_SYSTEM_DIALOG
  ///
  /// Window type: panel that slides out from the status bar
  /// In multiuser systems shows on all users' windows.
  static const TYPE_SYSTEM_DIALOG = 2008;

  /// from: static public final int TYPE_SYSTEM_ERROR
  ///
  /// Window type: internal system error windows, appear on top of
  /// everything they can.
  /// In multiuser systems shows only on the owning user's window.
  ///@deprecated for non-system apps. Use \#TYPE_APPLICATION_OVERLAY instead.
  static const TYPE_SYSTEM_ERROR = 2010;

  /// from: static public final int TYPE_SYSTEM_OVERLAY
  ///
  /// Window type: system overlay windows, which need to be displayed
  /// on top of everything else.  These windows must not take input
  /// focus, or they will interfere with the keyguard.
  /// In multiuser systems shows only on the owning user's window.
  ///@deprecated for non-system apps. Use \#TYPE_APPLICATION_OVERLAY instead.
  static const TYPE_SYSTEM_OVERLAY = 2006;

  /// from: static public final int TYPE_TOAST
  ///
  /// Window type: transient notifications.
  /// In multiuser systems shows only on the owning user's window.
  ///@deprecated for non-system apps. Use \#TYPE_APPLICATION_OVERLAY instead.
  static const TYPE_TOAST = 2005;

  /// from: static public final int TYPE_WALLPAPER
  ///
  /// Window type: wallpaper window, placed behind any window that wants
  /// to sit on top of the wallpaper.
  /// In multiuser systems shows only on the owning user's window.
  static const TYPE_WALLPAPER = 2013;

  static final _id_alpha = jniAccessors.getFieldIDOf(_classRef, "alpha", "F");

  /// from: public float alpha
  ///
  /// An alpha value to apply to this entire window.
  /// An alpha of 1.0 means fully opaque and 0.0 means fully transparent
  double get alpha =>
      jniAccessors.getField(reference, _id_alpha, jni.JniType.floatType).float;

  /// from: public float alpha
  ///
  /// An alpha value to apply to this entire window.
  /// An alpha of 1.0 means fully opaque and 0.0 means fully transparent
  set alpha(double value) => jniEnv.SetFloatField(reference, _id_alpha, value);

  static final _id_buttonBrightness =
      jniAccessors.getFieldIDOf(_classRef, "buttonBrightness", "F");

  /// from: public float buttonBrightness
  ///
  /// This can be used to override the standard behavior of the button and
  /// keyboard backlights.  A value of less than 0, the default, means to
  /// use the standard backlight behavior.  0 to 1 adjusts the brightness
  /// from dark to full bright.
  double get buttonBrightness => jniAccessors
      .getField(reference, _id_buttonBrightness, jni.JniType.floatType)
      .float;

  /// from: public float buttonBrightness
  ///
  /// This can be used to override the standard behavior of the button and
  /// keyboard backlights.  A value of less than 0, the default, means to
  /// use the standard backlight behavior.  0 to 1 adjusts the brightness
  /// from dark to full bright.
  set buttonBrightness(double value) =>
      jniEnv.SetFloatField(reference, _id_buttonBrightness, value);

  static final _id_dimAmount =
      jniAccessors.getFieldIDOf(_classRef, "dimAmount", "F");

  /// from: public float dimAmount
  ///
  /// When \#FLAG_DIM_BEHIND is set, this is the amount of dimming
  /// to apply.  Range is from 1.0 for completely opaque to 0.0 for no
  /// dim.
  double get dimAmount => jniAccessors
      .getField(reference, _id_dimAmount, jni.JniType.floatType)
      .float;

  /// from: public float dimAmount
  ///
  /// When \#FLAG_DIM_BEHIND is set, this is the amount of dimming
  /// to apply.  Range is from 1.0 for completely opaque to 0.0 for no
  /// dim.
  set dimAmount(double value) =>
      jniEnv.SetFloatField(reference, _id_dimAmount, value);

  static final _id_flags = jniAccessors.getFieldIDOf(_classRef, "flags", "I");

  /// from: public int flags
  ///
  /// Various behavioral options/flags.  Default is none.
  ///@see \#FLAG_ALLOW_LOCK_WHILE_SCREEN_ON
  ///@see \#FLAG_DIM_BEHIND
  ///@see \#FLAG_NOT_FOCUSABLE
  ///@see \#FLAG_NOT_TOUCHABLE
  ///@see \#FLAG_NOT_TOUCH_MODAL
  ///@see \#FLAG_TOUCHABLE_WHEN_WAKING
  ///@see \#FLAG_KEEP_SCREEN_ON
  ///@see \#FLAG_LAYOUT_IN_SCREEN
  ///@see \#FLAG_LAYOUT_NO_LIMITS
  ///@see \#FLAG_FULLSCREEN
  ///@see \#FLAG_FORCE_NOT_FULLSCREEN
  ///@see \#FLAG_SECURE
  ///@see \#FLAG_SCALED
  ///@see \#FLAG_IGNORE_CHEEK_PRESSES
  ///@see \#FLAG_LAYOUT_INSET_DECOR
  ///@see \#FLAG_ALT_FOCUSABLE_IM
  ///@see \#FLAG_WATCH_OUTSIDE_TOUCH
  ///@see \#FLAG_SHOW_WHEN_LOCKED
  ///@see \#FLAG_SHOW_WALLPAPER
  ///@see \#FLAG_TURN_SCREEN_ON
  ///@see \#FLAG_DISMISS_KEYGUARD
  ///@see \#FLAG_SPLIT_TOUCH
  ///@see \#FLAG_HARDWARE_ACCELERATED
  ///@see \#FLAG_LOCAL_FOCUS_MODE
  ///@see \#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS
  int get flags =>
      jniAccessors.getField(reference, _id_flags, jni.JniType.intType).integer;

  /// from: public int flags
  ///
  /// Various behavioral options/flags.  Default is none.
  ///@see \#FLAG_ALLOW_LOCK_WHILE_SCREEN_ON
  ///@see \#FLAG_DIM_BEHIND
  ///@see \#FLAG_NOT_FOCUSABLE
  ///@see \#FLAG_NOT_TOUCHABLE
  ///@see \#FLAG_NOT_TOUCH_MODAL
  ///@see \#FLAG_TOUCHABLE_WHEN_WAKING
  ///@see \#FLAG_KEEP_SCREEN_ON
  ///@see \#FLAG_LAYOUT_IN_SCREEN
  ///@see \#FLAG_LAYOUT_NO_LIMITS
  ///@see \#FLAG_FULLSCREEN
  ///@see \#FLAG_FORCE_NOT_FULLSCREEN
  ///@see \#FLAG_SECURE
  ///@see \#FLAG_SCALED
  ///@see \#FLAG_IGNORE_CHEEK_PRESSES
  ///@see \#FLAG_LAYOUT_INSET_DECOR
  ///@see \#FLAG_ALT_FOCUSABLE_IM
  ///@see \#FLAG_WATCH_OUTSIDE_TOUCH
  ///@see \#FLAG_SHOW_WHEN_LOCKED
  ///@see \#FLAG_SHOW_WALLPAPER
  ///@see \#FLAG_TURN_SCREEN_ON
  ///@see \#FLAG_DISMISS_KEYGUARD
  ///@see \#FLAG_SPLIT_TOUCH
  ///@see \#FLAG_HARDWARE_ACCELERATED
  ///@see \#FLAG_LOCAL_FOCUS_MODE
  ///@see \#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS
  set flags(int value) => jniEnv.SetIntField(reference, _id_flags, value);

  static final _id_format = jniAccessors.getFieldIDOf(_classRef, "format", "I");

  /// from: public int format
  ///
  /// The desired bitmap format.  May be one of the constants in
  /// android.graphics.PixelFormat. The choice of format
  /// might be overridden by \#setColorMode(int). Default is OPAQUE.
  int get format =>
      jniAccessors.getField(reference, _id_format, jni.JniType.intType).integer;

  /// from: public int format
  ///
  /// The desired bitmap format.  May be one of the constants in
  /// android.graphics.PixelFormat. The choice of format
  /// might be overridden by \#setColorMode(int). Default is OPAQUE.
  set format(int value) => jniEnv.SetIntField(reference, _id_format, value);

  static final _id_gravity =
      jniAccessors.getFieldIDOf(_classRef, "gravity", "I");

  /// from: public int gravity
  ///
  /// Placement of window within the screen as per Gravity.  Both
  /// Gravity\#apply(int, int, int, android.graphics.Rect, int, int,
  /// android.graphics.Rect) Gravity.apply and
  /// Gravity\#applyDisplay(int, android.graphics.Rect, android.graphics.Rect) Gravity.applyDisplay are used during window layout, with this value
  /// given as the desired gravity.  For example you can specify
  /// Gravity\#DISPLAY_CLIP_HORIZONTAL Gravity.DISPLAY_CLIP_HORIZONTAL and
  /// Gravity\#DISPLAY_CLIP_VERTICAL Gravity.DISPLAY_CLIP_VERTICAL here
  /// to control the behavior of
  /// Gravity\#applyDisplay(int, android.graphics.Rect, android.graphics.Rect) Gravity.applyDisplay.
  ///@see Gravity
  int get gravity => jniAccessors
      .getField(reference, _id_gravity, jni.JniType.intType)
      .integer;

  /// from: public int gravity
  ///
  /// Placement of window within the screen as per Gravity.  Both
  /// Gravity\#apply(int, int, int, android.graphics.Rect, int, int,
  /// android.graphics.Rect) Gravity.apply and
  /// Gravity\#applyDisplay(int, android.graphics.Rect, android.graphics.Rect) Gravity.applyDisplay are used during window layout, with this value
  /// given as the desired gravity.  For example you can specify
  /// Gravity\#DISPLAY_CLIP_HORIZONTAL Gravity.DISPLAY_CLIP_HORIZONTAL and
  /// Gravity\#DISPLAY_CLIP_VERTICAL Gravity.DISPLAY_CLIP_VERTICAL here
  /// to control the behavior of
  /// Gravity\#applyDisplay(int, android.graphics.Rect, android.graphics.Rect) Gravity.applyDisplay.
  ///@see Gravity
  set gravity(int value) => jniEnv.SetIntField(reference, _id_gravity, value);

  static final _id_horizontalMargin =
      jniAccessors.getFieldIDOf(_classRef, "horizontalMargin", "F");

  /// from: public float horizontalMargin
  ///
  /// The horizontal margin, as a percentage of the container's width,
  /// between the container and the widget.  See
  /// Gravity\#apply(int, int, int, android.graphics.Rect, int, int,
  /// android.graphics.Rect) Gravity.apply for how this is used.  This
  /// field is added with \#x to supply the <var>xAdj</var> parameter.
  double get horizontalMargin => jniAccessors
      .getField(reference, _id_horizontalMargin, jni.JniType.floatType)
      .float;

  /// from: public float horizontalMargin
  ///
  /// The horizontal margin, as a percentage of the container's width,
  /// between the container and the widget.  See
  /// Gravity\#apply(int, int, int, android.graphics.Rect, int, int,
  /// android.graphics.Rect) Gravity.apply for how this is used.  This
  /// field is added with \#x to supply the <var>xAdj</var> parameter.
  set horizontalMargin(double value) =>
      jniEnv.SetFloatField(reference, _id_horizontalMargin, value);

  static final _id_horizontalWeight =
      jniAccessors.getFieldIDOf(_classRef, "horizontalWeight", "F");

  /// from: public float horizontalWeight
  ///
  /// Indicates how much of the extra space will be allocated horizontally
  /// to the view associated with these LayoutParams. Specify 0 if the view
  /// should not be stretched. Otherwise the extra pixels will be pro-rated
  /// among all views whose weight is greater than 0.
  double get horizontalWeight => jniAccessors
      .getField(reference, _id_horizontalWeight, jni.JniType.floatType)
      .float;

  /// from: public float horizontalWeight
  ///
  /// Indicates how much of the extra space will be allocated horizontally
  /// to the view associated with these LayoutParams. Specify 0 if the view
  /// should not be stretched. Otherwise the extra pixels will be pro-rated
  /// among all views whose weight is greater than 0.
  set horizontalWeight(double value) =>
      jniEnv.SetFloatField(reference, _id_horizontalWeight, value);

  static final _id_layoutInDisplayCutoutMode =
      jniAccessors.getFieldIDOf(_classRef, "layoutInDisplayCutoutMode", "I");

  /// from: public int layoutInDisplayCutoutMode
  ///
  /// Controls how the window is laid out if there is a DisplayCutout.
  ///
  ///
  /// Defaults to \#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT.
  ///
  /// Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT, android.view.WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES, and android.view.WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER
  ///@see \#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
  ///@see \#LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
  ///@see \#LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER
  ///@see DisplayCutout
  ///@see android.R.attr\#windowLayoutInDisplayCutoutMode android:windowLayoutInDisplayCutoutMode
  int get layoutInDisplayCutoutMode => jniAccessors
      .getField(reference, _id_layoutInDisplayCutoutMode, jni.JniType.intType)
      .integer;

  /// from: public int layoutInDisplayCutoutMode
  ///
  /// Controls how the window is laid out if there is a DisplayCutout.
  ///
  ///
  /// Defaults to \#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT.
  ///
  /// Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT, android.view.WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES, and android.view.WindowManager.LayoutParams\#LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER
  ///@see \#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
  ///@see \#LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
  ///@see \#LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER
  ///@see DisplayCutout
  ///@see android.R.attr\#windowLayoutInDisplayCutoutMode android:windowLayoutInDisplayCutoutMode
  set layoutInDisplayCutoutMode(int value) =>
      jniEnv.SetIntField(reference, _id_layoutInDisplayCutoutMode, value);

  static final _id_memoryType =
      jniAccessors.getFieldIDOf(_classRef, "memoryType", "I");

  /// from: public int memoryType
  ///
  /// @deprecated this is ignored
  int get memoryType => jniAccessors
      .getField(reference, _id_memoryType, jni.JniType.intType)
      .integer;

  /// from: public int memoryType
  ///
  /// @deprecated this is ignored
  set memoryType(int value) =>
      jniEnv.SetIntField(reference, _id_memoryType, value);

  static final _id_packageName =
      jniAccessors.getFieldIDOf(_classRef, "packageName", "Ljava/lang/String;");

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Name of the package owning this window.
  jni.JniString get packageName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_packageName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Name of the package owning this window.
  set packageName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_packageName, value.reference);

  static final _id_preferredDisplayModeId =
      jniAccessors.getFieldIDOf(_classRef, "preferredDisplayModeId", "I");

  /// from: public int preferredDisplayModeId
  ///
  /// Id of the preferred display mode for the window.
  ///
  /// This must be one of the supported modes obtained for the display(s) the window is on.
  /// A value of {@code 0} means no preference.
  ///@see Display\#getSupportedModes()
  ///@see Display.Mode\#getModeId()
  int get preferredDisplayModeId => jniAccessors
      .getField(reference, _id_preferredDisplayModeId, jni.JniType.intType)
      .integer;

  /// from: public int preferredDisplayModeId
  ///
  /// Id of the preferred display mode for the window.
  ///
  /// This must be one of the supported modes obtained for the display(s) the window is on.
  /// A value of {@code 0} means no preference.
  ///@see Display\#getSupportedModes()
  ///@see Display.Mode\#getModeId()
  set preferredDisplayModeId(int value) =>
      jniEnv.SetIntField(reference, _id_preferredDisplayModeId, value);

  static final _id_preferredRefreshRate =
      jniAccessors.getFieldIDOf(_classRef, "preferredRefreshRate", "F");

  /// from: public float preferredRefreshRate
  ///
  /// The preferred refresh rate for the window.
  ///
  /// This must be one of the supported refresh rates obtained for the display(s) the window
  /// is on. The selected refresh rate will be applied to the display's default mode.
  ///
  /// This value is ignored if \#preferredDisplayModeId is set.
  ///@see Display\#getSupportedRefreshRates()
  ///@deprecated use \#preferredDisplayModeId instead
  double get preferredRefreshRate => jniAccessors
      .getField(reference, _id_preferredRefreshRate, jni.JniType.floatType)
      .float;

  /// from: public float preferredRefreshRate
  ///
  /// The preferred refresh rate for the window.
  ///
  /// This must be one of the supported refresh rates obtained for the display(s) the window
  /// is on. The selected refresh rate will be applied to the display's default mode.
  ///
  /// This value is ignored if \#preferredDisplayModeId is set.
  ///@see Display\#getSupportedRefreshRates()
  ///@deprecated use \#preferredDisplayModeId instead
  set preferredRefreshRate(double value) =>
      jniEnv.SetFloatField(reference, _id_preferredRefreshRate, value);

  static final _id_rotationAnimation =
      jniAccessors.getFieldIDOf(_classRef, "rotationAnimation", "I");

  /// from: public int rotationAnimation
  ///
  /// Define the exit and entry animations used on this window when the device is rotated.
  /// This only has an affect if the incoming and outgoing topmost
  /// opaque windows have the \#FLAG_FULLSCREEN bit set and are not covered
  /// by other windows. All other situations default to the
  /// \#ROTATION_ANIMATION_ROTATE behavior.
  ///@see \#ROTATION_ANIMATION_ROTATE
  ///@see \#ROTATION_ANIMATION_CROSSFADE
  ///@see \#ROTATION_ANIMATION_JUMPCUT
  int get rotationAnimation => jniAccessors
      .getField(reference, _id_rotationAnimation, jni.JniType.intType)
      .integer;

  /// from: public int rotationAnimation
  ///
  /// Define the exit and entry animations used on this window when the device is rotated.
  /// This only has an affect if the incoming and outgoing topmost
  /// opaque windows have the \#FLAG_FULLSCREEN bit set and are not covered
  /// by other windows. All other situations default to the
  /// \#ROTATION_ANIMATION_ROTATE behavior.
  ///@see \#ROTATION_ANIMATION_ROTATE
  ///@see \#ROTATION_ANIMATION_CROSSFADE
  ///@see \#ROTATION_ANIMATION_JUMPCUT
  set rotationAnimation(int value) =>
      jniEnv.SetIntField(reference, _id_rotationAnimation, value);

  static final _id_screenBrightness =
      jniAccessors.getFieldIDOf(_classRef, "screenBrightness", "F");

  /// from: public float screenBrightness
  ///
  /// This can be used to override the user's preferred brightness of
  /// the screen.  A value of less than 0, the default, means to use the
  /// preferred screen brightness.  0 to 1 adjusts the brightness from
  /// dark to full bright.
  double get screenBrightness => jniAccessors
      .getField(reference, _id_screenBrightness, jni.JniType.floatType)
      .float;

  /// from: public float screenBrightness
  ///
  /// This can be used to override the user's preferred brightness of
  /// the screen.  A value of less than 0, the default, means to use the
  /// preferred screen brightness.  0 to 1 adjusts the brightness from
  /// dark to full bright.
  set screenBrightness(double value) =>
      jniEnv.SetFloatField(reference, _id_screenBrightness, value);

  static final _id_screenOrientation =
      jniAccessors.getFieldIDOf(_classRef, "screenOrientation", "I");

  /// from: public int screenOrientation
  ///
  /// Specific orientation value for a window.
  /// May be any of the same values allowed
  /// for android.content.pm.ActivityInfo\#screenOrientation.
  /// If not set, a default value of
  /// android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED
  /// will be used.
  int get screenOrientation => jniAccessors
      .getField(reference, _id_screenOrientation, jni.JniType.intType)
      .integer;

  /// from: public int screenOrientation
  ///
  /// Specific orientation value for a window.
  /// May be any of the same values allowed
  /// for android.content.pm.ActivityInfo\#screenOrientation.
  /// If not set, a default value of
  /// android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED
  /// will be used.
  set screenOrientation(int value) =>
      jniEnv.SetIntField(reference, _id_screenOrientation, value);

  static final _id_softInputMode =
      jniAccessors.getFieldIDOf(_classRef, "softInputMode", "I");

  /// from: public int softInputMode
  ///
  /// Desired operating mode for any soft input area.  May be any combination
  /// of:
  ///
  /// <ul>
  /// <li> One of the visibility states
  /// \#SOFT_INPUT_STATE_UNSPECIFIED, \#SOFT_INPUT_STATE_UNCHANGED,
  /// \#SOFT_INPUT_STATE_HIDDEN, \#SOFT_INPUT_STATE_ALWAYS_HIDDEN,
  /// \#SOFT_INPUT_STATE_VISIBLE, or \#SOFT_INPUT_STATE_ALWAYS_VISIBLE.
  /// <li> One of the adjustment options
  /// \#SOFT_INPUT_ADJUST_UNSPECIFIED, \#SOFT_INPUT_ADJUST_RESIZE,
  /// \#SOFT_INPUT_ADJUST_PAN, or \#SOFT_INPUT_ADJUST_NOTHING.
  /// </ul>
  ///
  ///
  /// This flag can be controlled in your theme through the
  /// android.R.attr\#windowSoftInputMode attribute.
  ///
  ///
  /// Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNCHANGED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_RESIZE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_PAN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_NOTHING, and android.view.WindowManager.LayoutParams\#SOFT_INPUT_IS_FORWARD_NAVIGATION
  int get softInputMode => jniAccessors
      .getField(reference, _id_softInputMode, jni.JniType.intType)
      .integer;

  /// from: public int softInputMode
  ///
  /// Desired operating mode for any soft input area.  May be any combination
  /// of:
  ///
  /// <ul>
  /// <li> One of the visibility states
  /// \#SOFT_INPUT_STATE_UNSPECIFIED, \#SOFT_INPUT_STATE_UNCHANGED,
  /// \#SOFT_INPUT_STATE_HIDDEN, \#SOFT_INPUT_STATE_ALWAYS_HIDDEN,
  /// \#SOFT_INPUT_STATE_VISIBLE, or \#SOFT_INPUT_STATE_ALWAYS_VISIBLE.
  /// <li> One of the adjustment options
  /// \#SOFT_INPUT_ADJUST_UNSPECIFIED, \#SOFT_INPUT_ADJUST_RESIZE,
  /// \#SOFT_INPUT_ADJUST_PAN, or \#SOFT_INPUT_ADJUST_NOTHING.
  /// </ul>
  ///
  ///
  /// This flag can be controlled in your theme through the
  /// android.R.attr\#windowSoftInputMode attribute.
  ///
  ///
  /// Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNCHANGED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_RESIZE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_PAN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_NOTHING, and android.view.WindowManager.LayoutParams\#SOFT_INPUT_IS_FORWARD_NAVIGATION
  set softInputMode(int value) =>
      jniEnv.SetIntField(reference, _id_softInputMode, value);

  static final _id_systemUiVisibility =
      jniAccessors.getFieldIDOf(_classRef, "systemUiVisibility", "I");

  /// from: public int systemUiVisibility
  ///
  /// Control the visibility of the status bar.
  ///@see View\#STATUS_BAR_VISIBLE
  ///@see View\#STATUS_BAR_HIDDEN
  int get systemUiVisibility => jniAccessors
      .getField(reference, _id_systemUiVisibility, jni.JniType.intType)
      .integer;

  /// from: public int systemUiVisibility
  ///
  /// Control the visibility of the status bar.
  ///@see View\#STATUS_BAR_VISIBLE
  ///@see View\#STATUS_BAR_HIDDEN
  set systemUiVisibility(int value) =>
      jniEnv.SetIntField(reference, _id_systemUiVisibility, value);

  static final _id_token =
      jniAccessors.getFieldIDOf(_classRef, "token", "Landroid/os/IBinder;");

  /// from: public android.os.IBinder token
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Identifier for this window.  This will usually be filled in for
  /// you.
  ibinder_.IBinder get token => ibinder_.IBinder.fromRef(jniAccessors
      .getField(reference, _id_token, jni.JniType.objectType)
      .object);

  /// from: public android.os.IBinder token
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Identifier for this window.  This will usually be filled in for
  /// you.
  set token(ibinder_.IBinder value) =>
      jniEnv.SetObjectField(reference, _id_token, value.reference);

  static final _id_type = jniAccessors.getFieldIDOf(_classRef, "type", "I");

  /// from: public int type
  ///
  /// The general type of window.  There are three main classes of
  /// window types:
  /// <ul>
  /// <li> <strong>Application windows</strong> (ranging from
  /// \#FIRST_APPLICATION_WINDOW to
  /// \#LAST_APPLICATION_WINDOW) are normal top-level application
  /// windows.  For these types of windows, the \#token must be
  /// set to the token of the activity they are a part of (this will
  /// normally be done for you if \#token is null).
  /// <li> <strong>Sub-windows</strong> (ranging from
  /// \#FIRST_SUB_WINDOW to
  /// \#LAST_SUB_WINDOW) are associated with another top-level
  /// window.  For these types of windows, the \#token must be
  /// the token of the window it is attached to.
  /// <li> <strong>System windows</strong> (ranging from
  /// \#FIRST_SYSTEM_WINDOW to
  /// \#LAST_SYSTEM_WINDOW) are special types of windows for
  /// use by the system for specific purposes.  They should not normally
  /// be used by applications, and a special permission is required
  /// to use them.
  /// </ul>
  ///@see \#TYPE_BASE_APPLICATION
  ///@see \#TYPE_APPLICATION
  ///@see \#TYPE_APPLICATION_STARTING
  ///@see \#TYPE_DRAWN_APPLICATION
  ///@see \#TYPE_APPLICATION_PANEL
  ///@see \#TYPE_APPLICATION_MEDIA
  ///@see \#TYPE_APPLICATION_SUB_PANEL
  ///@see \#TYPE_APPLICATION_ABOVE_SUB_PANEL
  ///@see \#TYPE_APPLICATION_ATTACHED_DIALOG
  ///@see \#TYPE_STATUS_BAR
  ///@see \#TYPE_SEARCH_BAR
  ///@see \#TYPE_PHONE
  ///@see \#TYPE_SYSTEM_ALERT
  ///@see \#TYPE_TOAST
  ///@see \#TYPE_SYSTEM_OVERLAY
  ///@see \#TYPE_PRIORITY_PHONE
  ///@see \#TYPE_STATUS_BAR_PANEL
  ///@see \#TYPE_SYSTEM_DIALOG
  ///@see \#TYPE_KEYGUARD_DIALOG
  ///@see \#TYPE_SYSTEM_ERROR
  ///@see \#TYPE_INPUT_METHOD
  ///@see \#TYPE_INPUT_METHOD_DIALOG
  int get type =>
      jniAccessors.getField(reference, _id_type, jni.JniType.intType).integer;

  /// from: public int type
  ///
  /// The general type of window.  There are three main classes of
  /// window types:
  /// <ul>
  /// <li> <strong>Application windows</strong> (ranging from
  /// \#FIRST_APPLICATION_WINDOW to
  /// \#LAST_APPLICATION_WINDOW) are normal top-level application
  /// windows.  For these types of windows, the \#token must be
  /// set to the token of the activity they are a part of (this will
  /// normally be done for you if \#token is null).
  /// <li> <strong>Sub-windows</strong> (ranging from
  /// \#FIRST_SUB_WINDOW to
  /// \#LAST_SUB_WINDOW) are associated with another top-level
  /// window.  For these types of windows, the \#token must be
  /// the token of the window it is attached to.
  /// <li> <strong>System windows</strong> (ranging from
  /// \#FIRST_SYSTEM_WINDOW to
  /// \#LAST_SYSTEM_WINDOW) are special types of windows for
  /// use by the system for specific purposes.  They should not normally
  /// be used by applications, and a special permission is required
  /// to use them.
  /// </ul>
  ///@see \#TYPE_BASE_APPLICATION
  ///@see \#TYPE_APPLICATION
  ///@see \#TYPE_APPLICATION_STARTING
  ///@see \#TYPE_DRAWN_APPLICATION
  ///@see \#TYPE_APPLICATION_PANEL
  ///@see \#TYPE_APPLICATION_MEDIA
  ///@see \#TYPE_APPLICATION_SUB_PANEL
  ///@see \#TYPE_APPLICATION_ABOVE_SUB_PANEL
  ///@see \#TYPE_APPLICATION_ATTACHED_DIALOG
  ///@see \#TYPE_STATUS_BAR
  ///@see \#TYPE_SEARCH_BAR
  ///@see \#TYPE_PHONE
  ///@see \#TYPE_SYSTEM_ALERT
  ///@see \#TYPE_TOAST
  ///@see \#TYPE_SYSTEM_OVERLAY
  ///@see \#TYPE_PRIORITY_PHONE
  ///@see \#TYPE_STATUS_BAR_PANEL
  ///@see \#TYPE_SYSTEM_DIALOG
  ///@see \#TYPE_KEYGUARD_DIALOG
  ///@see \#TYPE_SYSTEM_ERROR
  ///@see \#TYPE_INPUT_METHOD
  ///@see \#TYPE_INPUT_METHOD_DIALOG
  set type(int value) => jniEnv.SetIntField(reference, _id_type, value);

  static final _id_verticalMargin =
      jniAccessors.getFieldIDOf(_classRef, "verticalMargin", "F");

  /// from: public float verticalMargin
  ///
  /// The vertical margin, as a percentage of the container's height,
  /// between the container and the widget.  See
  /// Gravity\#apply(int, int, int, android.graphics.Rect, int, int,
  /// android.graphics.Rect) Gravity.apply for how this is used.  This
  /// field is added with \#y to supply the <var>yAdj</var> parameter.
  double get verticalMargin => jniAccessors
      .getField(reference, _id_verticalMargin, jni.JniType.floatType)
      .float;

  /// from: public float verticalMargin
  ///
  /// The vertical margin, as a percentage of the container's height,
  /// between the container and the widget.  See
  /// Gravity\#apply(int, int, int, android.graphics.Rect, int, int,
  /// android.graphics.Rect) Gravity.apply for how this is used.  This
  /// field is added with \#y to supply the <var>yAdj</var> parameter.
  set verticalMargin(double value) =>
      jniEnv.SetFloatField(reference, _id_verticalMargin, value);

  static final _id_verticalWeight =
      jniAccessors.getFieldIDOf(_classRef, "verticalWeight", "F");

  /// from: public float verticalWeight
  ///
  /// Indicates how much of the extra space will be allocated vertically
  /// to the view associated with these LayoutParams. Specify 0 if the view
  /// should not be stretched. Otherwise the extra pixels will be pro-rated
  /// among all views whose weight is greater than 0.
  double get verticalWeight => jniAccessors
      .getField(reference, _id_verticalWeight, jni.JniType.floatType)
      .float;

  /// from: public float verticalWeight
  ///
  /// Indicates how much of the extra space will be allocated vertically
  /// to the view associated with these LayoutParams. Specify 0 if the view
  /// should not be stretched. Otherwise the extra pixels will be pro-rated
  /// among all views whose weight is greater than 0.
  set verticalWeight(double value) =>
      jniEnv.SetFloatField(reference, _id_verticalWeight, value);

  static final _id_windowAnimations =
      jniAccessors.getFieldIDOf(_classRef, "windowAnimations", "I");

  /// from: public int windowAnimations
  ///
  /// A style resource defining the animations to use for this window.
  /// This must be a system resource; it can not be an application resource
  /// because the window manager does not have access to applications.
  int get windowAnimations => jniAccessors
      .getField(reference, _id_windowAnimations, jni.JniType.intType)
      .integer;

  /// from: public int windowAnimations
  ///
  /// A style resource defining the animations to use for this window.
  /// This must be a system resource; it can not be an application resource
  /// because the window manager does not have access to applications.
  set windowAnimations(int value) =>
      jniEnv.SetIntField(reference, _id_windowAnimations, value);

  static final _id_x = jniAccessors.getFieldIDOf(_classRef, "x", "I");

  /// from: public int x
  ///
  /// X position for this window.  With the default gravity it is ignored.
  /// When using Gravity\#LEFT or Gravity\#START or Gravity\#RIGHT or
  /// Gravity\#END it provides an offset from the given edge.
  int get x =>
      jniAccessors.getField(reference, _id_x, jni.JniType.intType).integer;

  /// from: public int x
  ///
  /// X position for this window.  With the default gravity it is ignored.
  /// When using Gravity\#LEFT or Gravity\#START or Gravity\#RIGHT or
  /// Gravity\#END it provides an offset from the given edge.
  set x(int value) => jniEnv.SetIntField(reference, _id_x, value);

  static final _id_y = jniAccessors.getFieldIDOf(_classRef, "y", "I");

  /// from: public int y
  ///
  /// Y position for this window.  With the default gravity it is ignored.
  /// When using Gravity\#TOP or Gravity\#BOTTOM it provides
  /// an offset from the given edge.
  int get y =>
      jniAccessors.getField(reference, _id_y, jni.JniType.intType).integer;

  /// from: public int y
  ///
  /// Y position for this window.  With the default gravity it is ignored.
  /// When using Gravity\#TOP or Gravity\#BOTTOM it provides
  /// an offset from the given edge.
  set y(int value) => jniEnv.SetIntField(reference, _id_y, value);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_LayoutParams.ctor3()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, []).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int _type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_LayoutParams.ctor4(int _type)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor4, [_type]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int _type, int _flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_LayoutParams.ctor1(int _type, int _flags)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [_type, _flags]).object);

  static final _id_ctor5 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(III)V");

  /// from: public void <init>(int _type, int _flags, int _format)
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_LayoutParams.ctor5(int _type, int _flags, int _format)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor5, [_type, _flags, _format]).object);

  static final _id_ctor6 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIIII)V");

  /// from: public void <init>(int w, int h, int _type, int _flags, int _format)
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_LayoutParams.ctor6(
      int w, int h, int _type, int _flags, int _format)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor6, [w, h, _type, _flags, _format]).object);

  static final _id_ctor7 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIIIIII)V");

  /// from: public void <init>(int w, int h, int xpos, int ypos, int _type, int _flags, int _format)
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_LayoutParams.ctor7(
      int w, int h, int xpos, int ypos, int _type, int _flags, int _format)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor7,
            [w, h, xpos, ypos, _type, _flags, _format]).object);

  static final _id_ctor8 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_LayoutParams.ctor8(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor8, [in0.reference]).object);

  static final _id_mayUseInputMethod =
      jniAccessors.getStaticMethodIDOf(_classRef, "mayUseInputMethod", "(I)Z");

  /// from: static public boolean mayUseInputMethod(int flags)
  ///
  /// Given a particular set of window manager flags, determine whether
  /// such a window may be a target for an input method when it has
  /// focus.  In particular, this checks the
  /// \#FLAG_NOT_FOCUSABLE and \#FLAG_ALT_FOCUSABLE_IM
  /// flags and returns true if the combination of the two corresponds
  /// to a window that needs to be behind the input method so that the
  /// user can type into it.
  ///@param flags The current window manager flags.
  ///@return Returns true if such a window should be behind/interact
  /// with an input method, false if not.
  static bool mayUseInputMethod(int flags) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_mayUseInputMethod,
          jni.JniType.booleanType, [flags]).boolean;

  static final _id_setTitle = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public final void setTitle(java.lang.CharSequence title)
  void setTitle(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle, jni.JniType.voidType, [title.reference]).check();

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public final java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_setColorMode =
      jniAccessors.getMethodIDOf(_classRef, "setColorMode", "(I)V");

  /// from: public void setColorMode(int colorMode)
  ///
  /// Set the color mode of the window. Setting the color mode might
  /// override the window's pixel WindowManager.LayoutParams\#format format.
  ///
  ///
  /// The color mode must be one of ActivityInfo\#COLOR_MODE_DEFAULT,
  /// ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT or
  /// ActivityInfo\#COLOR_MODE_HDR.
  ///
  ///@see \#getColorMode()
  ///@param colorMode Value is android.content.pm.ActivityInfo\#COLOR_MODE_DEFAULT, android.content.pm.ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT, or android.content.pm.ActivityInfo\#COLOR_MODE_HDR
  void setColorMode(int colorMode) => jniAccessors.callMethodWithArgs(
      reference, _id_setColorMode, jni.JniType.voidType, [colorMode]).check();

  static final _id_getColorMode =
      jniAccessors.getMethodIDOf(_classRef, "getColorMode", "()I");

  /// from: public int getColorMode()
  ///
  /// Returns the color mode of the window, one of ActivityInfo\#COLOR_MODE_DEFAULT,
  /// ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT or ActivityInfo\#COLOR_MODE_HDR.
  ///@see \#setColorMode(int)
  ///@return Value is android.content.pm.ActivityInfo\#COLOR_MODE_DEFAULT, android.content.pm.ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT, or android.content.pm.ActivityInfo\#COLOR_MODE_HDR
  int getColorMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getColorMode, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int parcelableFlags)
  void writeToParcel(parcel_.Parcel out, int parcelableFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, parcelableFlags]).check();

  static final _id_copyFrom = jniAccessors.getMethodIDOf(
      _classRef, "copyFrom", "(Landroid/view/WindowManager\$LayoutParams;)I");

  /// from: public final int copyFrom(android.view.WindowManager.LayoutParams o)
  int copyFrom(WindowManager_LayoutParams o) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom, jni.JniType.intType, [o.reference]).integer;

  static final _id_debug = jniAccessors.getMethodIDOf(
      _classRef, "debug", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String debug(java.lang.String output)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString debug(jni.JniString output) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_debug, jni.JniType.objectType, [output.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.view.WindowManager$InvalidDisplayException
///
/// Exception that is thrown when calling \#addView to a secondary display that cannot
/// be found. See android.app.Presentation for more information on secondary displays.
class WindowManager_InvalidDisplayException extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/WindowManager\$InvalidDisplayException");
  WindowManager_InvalidDisplayException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_InvalidDisplayException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_InvalidDisplayException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);
}

/// from: android.view.WindowManager$BadTokenException
///
/// Exception that is thrown when trying to add view whose
/// LayoutParams LayoutParams\#token
/// is invalid.
class WindowManager_BadTokenException extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/WindowManager\$BadTokenException");
  WindowManager_BadTokenException.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_BadTokenException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  WindowManager_BadTokenException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);
}
