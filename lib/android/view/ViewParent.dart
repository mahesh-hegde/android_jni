// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "View.dart" as view_;

import "../graphics/Rect.dart" as rect_;

import "../graphics/Point.dart" as point_;

import "ContextMenu.dart" as contextmenu_;

import "ActionMode.dart" as actionmode_;

import "accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.ViewParent
///
/// Defines the responsibilities for a class that will be a parent of a View.
/// This is the API that a view sees when it wants to interact with its parent.
class ViewParent extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/ViewParent");
  ViewParent.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_requestLayout =
      jniAccessors.getMethodIDOf(_classRef, "requestLayout", "()V");

  /// from: public abstract void requestLayout()
  ///
  /// Called when something has changed which has invalidated the layout of a
  /// child of this view parent. This will schedule a layout pass of the view
  /// tree.
  void requestLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_requestLayout, jni.JniType.voidType, []).check();

  static final _id_isLayoutRequested =
      jniAccessors.getMethodIDOf(_classRef, "isLayoutRequested", "()Z");

  /// from: public abstract boolean isLayoutRequested()
  ///
  /// Indicates whether layout was requested on this view parent.
  ///@return true if layout was requested, false otherwise
  bool isLayoutRequested() => jniAccessors.callMethodWithArgs(
      reference, _id_isLayoutRequested, jni.JniType.booleanType, []).boolean;

  static final _id_requestTransparentRegion = jniAccessors.getMethodIDOf(
      _classRef, "requestTransparentRegion", "(Landroid/view/View;)V");

  /// from: public abstract void requestTransparentRegion(android.view.View child)
  ///
  /// Called when a child wants the view hierarchy to gather and report
  /// transparent regions to the window compositor. Views that "punch" holes in
  /// the view hierarchy, such as SurfaceView can use this API to improve
  /// performance of the system. When no such a view is present in the
  /// hierarchy, this optimization in unnecessary and might slightly reduce the
  /// view hierarchy performance.
  ///@param child the view requesting the transparent region computation
  void requestTransparentRegion(view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestTransparentRegion,
          jni.JniType.voidType, [child.reference]).check();

  static final _id_onDescendantInvalidated = jniAccessors.getMethodIDOf(
      _classRef,
      "onDescendantInvalidated",
      "(Landroid/view/View;Landroid/view/View;)V");

  /// from: default public void onDescendantInvalidated(android.view.View child, android.view.View target)
  ///
  /// The target View has been invalidated, or has had a drawing property changed that
  /// requires the hierarchy to re-render.
  ///
  /// This method is called by the View hierarchy to signal ancestors that a View either needs to
  /// re-record its drawing commands, or drawing properties have changed. This is how Views
  /// schedule a drawing traversal.
  ///
  /// This signal is generally only dispatched for attached Views, since only they need to draw.
  ///@param child Direct child of this ViewParent containing target
  /// This value must never be {@code null}.
  ///@param target The view that needs to redraw
  ///
  /// This value must never be {@code null}.
  void onDescendantInvalidated(view_.View child, view_.View target) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDescendantInvalidated,
          jni.JniType.voidType, [child.reference, target.reference]).check();

  static final _id_invalidateChild = jniAccessors.getMethodIDOf(_classRef,
      "invalidateChild", "(Landroid/view/View;Landroid/graphics/Rect;)V");

  /// from: public abstract void invalidateChild(android.view.View child, android.graphics.Rect r)
  ///
  /// All or part of a child is dirty and needs to be redrawn.
  ///@param child The child which is dirty
  ///@param r The area within the child that is invalid
  ///@deprecated Use \#onDescendantInvalidated(View, View) instead.
  void invalidateChild(view_.View child, rect_.Rect r) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateChild,
          jni.JniType.voidType, [child.reference, r.reference]).check();

  static final _id_invalidateChildInParent = jniAccessors.getMethodIDOf(
      _classRef,
      "invalidateChildInParent",
      "([ILandroid/graphics/Rect;)Landroid/view/ViewParent;");

  /// from: public abstract android.view.ViewParent invalidateChildInParent(int[] location, android.graphics.Rect r)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// All or part of a child is dirty and needs to be redrawn.
  ///
  /// The location array is an array of two int values which respectively
  /// define the left and the top position of the dirty child.
  ///
  ///
  /// This method must return the parent of this ViewParent if the specified
  /// rectangle must be invalidated in the parent. If the specified rectangle
  /// does not require invalidation in the parent or if the parent does not
  /// exist, this method must return null.
  ///
  ///
  /// When this method returns a non-null value, the location array must
  /// have been updated with the left and top coordinates of this ViewParent.
  ///
  ///@param location An array of 2 ints containing the left and top
  ///        coordinates of the child to invalidate
  ///@param r The area within the child that is invalid
  ///@return the parent of this ViewParent or null
  ///@deprecated Use \#onDescendantInvalidated(View, View) instead.
  ViewParent invalidateChildInParent(jni.JniObject location, rect_.Rect r) =>
      ViewParent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_invalidateChildInParent,
          jni.JniType.objectType,
          [location.reference, r.reference]).object);

  static final _id_getParent = jniAccessors.getMethodIDOf(
      _classRef, "getParent", "()Landroid/view/ViewParent;");

  /// from: public abstract android.view.ViewParent getParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the parent if it exists, or null.
  ///@return a ViewParent or null if this ViewParent does not have a parent
  ViewParent getParent() => ViewParent.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getParent, jni.JniType.objectType, []).object);

  static final _id_requestChildFocus = jniAccessors.getMethodIDOf(_classRef,
      "requestChildFocus", "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public abstract void requestChildFocus(android.view.View child, android.view.View focused)
  ///
  /// Called when a child of this parent wants focus
  ///@param child The child of this ViewParent that wants focus. This view
  ///        will contain the focused view. It is not necessarily the view that
  ///        actually has focus.
  ///@param focused The view that is a descendant of child that actually has
  ///        focus
  void requestChildFocus(view_.View child, view_.View focused) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestChildFocus,
          jni.JniType.voidType, [child.reference, focused.reference]).check();

  static final _id_recomputeViewAttributes = jniAccessors.getMethodIDOf(
      _classRef, "recomputeViewAttributes", "(Landroid/view/View;)V");

  /// from: public abstract void recomputeViewAttributes(android.view.View child)
  ///
  /// Tell view hierarchy that the global view attributes need to be
  /// re-evaluated.
  ///@param child View whose attributes have changed.
  void recomputeViewAttributes(view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_recomputeViewAttributes,
          jni.JniType.voidType, [child.reference]).check();

  static final _id_clearChildFocus = jniAccessors.getMethodIDOf(
      _classRef, "clearChildFocus", "(Landroid/view/View;)V");

  /// from: public abstract void clearChildFocus(android.view.View child)
  ///
  /// Called when a child of this parent is giving up focus
  ///@param child The view that is giving up focus
  void clearChildFocus(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_clearChildFocus,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_getChildVisibleRect = jniAccessors.getMethodIDOf(
      _classRef,
      "getChildVisibleRect",
      "(Landroid/view/View;Landroid/graphics/Rect;Landroid/graphics/Point;)Z");

  /// from: public abstract boolean getChildVisibleRect(android.view.View child, android.graphics.Rect r, android.graphics.Point offset)
  ///
  /// Compute the visible part of a rectangular region defined in terms of a child view's
  /// coordinates.
  ///
  /// Returns the clipped visible part of the rectangle <code>r</code>, defined in the
  /// <code>child</code>'s local coordinate system. <code>r</code> is modified by this method to
  /// contain the result, expressed in the global (root) coordinate system.
  ///
  ///
  /// The resulting rectangle is always axis aligned. If a rotation is applied to a node in the
  /// View hierarchy, the result is the axis-aligned bounding box of the visible rectangle.
  ///
  ///@param child A child View, whose rectangular visible region we want to compute
  ///@param r The input rectangle, defined in the child coordinate system. Will be overwritten to
  /// contain the resulting visible rectangle, expressed in global (root) coordinates
  ///@param offset The input coordinates of a point, defined in the child coordinate system.
  /// As with the <code>r</code> parameter, this will be overwritten to contain the global (root)
  /// coordinates of that point.
  /// A <code>null</code> value is valid (in case you are not interested in this result)
  ///@return true if the resulting rectangle is not empty, false otherwise
  bool getChildVisibleRect(
          view_.View child, rect_.Rect r, point_.Point offset) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getChildVisibleRect,
          jni.JniType.booleanType,
          [child.reference, r.reference, offset.reference]).boolean;

  static final _id_focusSearch = jniAccessors.getMethodIDOf(
      _classRef, "focusSearch", "(Landroid/view/View;I)Landroid/view/View;");

  /// from: public abstract android.view.View focusSearch(android.view.View v, int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the nearest view in the specified direction that wants to take focus
  ///@param v The view that currently has focus
  ///@param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
  view_.View focusSearch(view_.View v, int direction) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_focusSearch,
          jni.JniType.objectType,
          [v.reference, direction]).object);

  static final _id_keyboardNavigationClusterSearch = jniAccessors.getMethodIDOf(
      _classRef,
      "keyboardNavigationClusterSearch",
      "(Landroid/view/View;I)Landroid/view/View;");

  /// from: public abstract android.view.View keyboardNavigationClusterSearch(android.view.View currentCluster, int direction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the nearest keyboard navigation cluster in the specified direction.
  /// This does not actually give focus to that cluster.
  ///@param currentCluster The starting point of the search. Null means the current cluster is not
  ///                       found yet
  ///@param direction Direction to look
  ///@return The nearest keyboard navigation cluster in the specified direction, or null if none
  ///         can be found
  view_.View keyboardNavigationClusterSearch(
          view_.View currentCluster, int direction) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_keyboardNavigationClusterSearch,
          jni.JniType.objectType,
          [currentCluster.reference, direction]).object);

  static final _id_bringChildToFront = jniAccessors.getMethodIDOf(
      _classRef, "bringChildToFront", "(Landroid/view/View;)V");

  /// from: public abstract void bringChildToFront(android.view.View child)
  ///
  /// Change the z order of the child so it's on top of all other children.
  /// This ordering change may affect layout, if this container
  /// uses an order-dependent layout scheme (e.g., LinearLayout). Prior
  /// to android.os.Build.VERSION_CODES\#KITKAT this
  /// method should be followed by calls to \#requestLayout() and
  /// View\#invalidate() on this parent to force the parent to redraw
  /// with the new child ordering.
  ///@param child The child to bring to the top of the z order
  void bringChildToFront(view_.View child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_bringChildToFront,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_focusableViewAvailable = jniAccessors.getMethodIDOf(
      _classRef, "focusableViewAvailable", "(Landroid/view/View;)V");

  /// from: public abstract void focusableViewAvailable(android.view.View v)
  ///
  /// Tells the parent that a new focusable view has become available. This is
  /// to handle transitions from the case where there are no focusable views to
  /// the case where the first focusable view appears.
  ///@param v The view that has become newly focusable
  void focusableViewAvailable(view_.View v) => jniAccessors.callMethodWithArgs(
      reference,
      _id_focusableViewAvailable,
      jni.JniType.voidType,
      [v.reference]).check();

  static final _id_showContextMenuForChild = jniAccessors.getMethodIDOf(
      _classRef, "showContextMenuForChild", "(Landroid/view/View;)Z");

  /// from: public abstract boolean showContextMenuForChild(android.view.View originalView)
  ///
  /// Shows the context menu for the specified view or its ancestors.
  ///
  /// In most cases, a subclass does not need to override this. However, if
  /// the subclass is added directly to the window manager (for example,
  /// ViewManager\#addView(View, android.view.ViewGroup.LayoutParams))
  /// then it should override this and show the context menu.
  ///@param originalView the source view where the context menu was first
  ///                     invoked
  ///@return {@code true} if the context menu was shown, {@code false}
  ///         otherwise
  ///@see \#showContextMenuForChild(View, float, float)
  bool showContextMenuForChild(view_.View originalView) =>
      jniAccessors.callMethodWithArgs(reference, _id_showContextMenuForChild,
          jni.JniType.booleanType, [originalView.reference]).boolean;

  static final _id_showContextMenuForChild1 = jniAccessors.getMethodIDOf(
      _classRef, "showContextMenuForChild", "(Landroid/view/View;FF)Z");

  /// from: public abstract boolean showContextMenuForChild(android.view.View originalView, float x, float y)
  ///
  /// Shows the context menu for the specified view or its ancestors anchored
  /// to the specified view-relative coordinate.
  ///
  /// In most cases, a subclass does not need to override this. However, if
  /// the subclass is added directly to the window manager (for example,
  /// ViewManager\#addView(View, android.view.ViewGroup.LayoutParams))
  /// then it should override this and show the context menu.
  ///
  /// If a subclass overrides this method it should also override
  /// \#showContextMenuForChild(View).
  ///@param originalView the source view where the context menu was first
  ///                     invoked
  ///@param x the X coordinate in pixels relative to the original view to
  ///          which the menu should be anchored, or Float\#NaN to
  ///          disable anchoring
  ///@param y the Y coordinate in pixels relative to the original view to
  ///          which the menu should be anchored, or Float\#NaN to
  ///          disable anchoring
  ///@return {@code true} if the context menu was shown, {@code false}
  ///         otherwise
  bool showContextMenuForChild1(view_.View originalView, double x, double y) =>
      jniAccessors.callMethodWithArgs(reference, _id_showContextMenuForChild1,
          jni.JniType.booleanType, [originalView.reference, x, y]).boolean;

  static final _id_createContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "createContextMenu", "(Landroid/view/ContextMenu;)V");

  /// from: public abstract void createContextMenu(android.view.ContextMenu menu)
  ///
  /// Have the parent populate the specified context menu if it has anything to
  /// add (and then recurse on its parent).
  ///@param menu The menu to populate
  void createContextMenu(contextmenu_.ContextMenu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_createContextMenu,
          jni.JniType.voidType, [menu.reference]).check();

  static final _id_startActionModeForChild = jniAccessors.getMethodIDOf(
      _classRef,
      "startActionModeForChild",
      "(Landroid/view/View;Landroid/view/ActionMode\$Callback;)Landroid/view/ActionMode;");

  /// from: public abstract android.view.ActionMode startActionModeForChild(android.view.View originalView, android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start an action mode for the specified view with the default type
  /// ActionMode\#TYPE_PRIMARY.
  ///
  /// In most cases, a subclass does not need to override this. However, if the
  /// subclass is added directly to the window manager (for example,
  /// ViewManager\#addView(View, android.view.ViewGroup.LayoutParams))
  /// then it should override this and start the action mode.
  ///
  ///@param originalView The source view where the action mode was first invoked
  ///@param callback The callback that will handle lifecycle events for the action mode
  ///@return The new action mode if it was started, null otherwise
  ///@see \#startActionModeForChild(View, android.view.ActionMode.Callback, int)
  actionmode_.ActionMode startActionModeForChild(
          view_.View originalView, actionmode_.ActionMode_Callback callback) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActionModeForChild,
          jni.JniType.objectType,
          [originalView.reference, callback.reference]).object);

  static final _id_startActionModeForChild1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActionModeForChild",
      "(Landroid/view/View;Landroid/view/ActionMode\$Callback;I)Landroid/view/ActionMode;");

  /// from: public abstract android.view.ActionMode startActionModeForChild(android.view.View originalView, android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start an action mode of a specific type for the specified view.
  ///
  /// In most cases, a subclass does not need to override this. However, if the
  /// subclass is added directly to the window manager (for example,
  /// ViewManager\#addView(View, android.view.ViewGroup.LayoutParams))
  /// then it should override this and start the action mode.
  ///
  ///@param originalView The source view where the action mode was first invoked
  ///@param callback The callback that will handle lifecycle events for the action mode
  ///@param type One of ActionMode\#TYPE_PRIMARY or ActionMode\#TYPE_FLOATING.
  ///@return The new action mode if it was started, null otherwise
  actionmode_.ActionMode startActionModeForChild1(view_.View originalView,
          actionmode_.ActionMode_Callback callback, int type) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActionModeForChild1,
          jni.JniType.objectType,
          [originalView.reference, callback.reference, type]).object);

  static final _id_childDrawableStateChanged = jniAccessors.getMethodIDOf(
      _classRef, "childDrawableStateChanged", "(Landroid/view/View;)V");

  /// from: public abstract void childDrawableStateChanged(android.view.View child)
  ///
  /// This method is called on the parent when a child's drawable state
  /// has changed.
  ///@param child The child whose drawable state has changed.
  void childDrawableStateChanged(view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_childDrawableStateChanged,
          jni.JniType.voidType, [child.reference]).check();

  static final _id_requestDisallowInterceptTouchEvent = jniAccessors
      .getMethodIDOf(_classRef, "requestDisallowInterceptTouchEvent", "(Z)V");

  /// from: public abstract void requestDisallowInterceptTouchEvent(boolean disallowIntercept)
  ///
  /// Called when a child does not want this parent and its ancestors to
  /// intercept touch events with
  /// ViewGroup\#onInterceptTouchEvent(MotionEvent).
  ///
  /// This parent should pass this call onto its parents. This parent must obey
  /// this request for the duration of the touch (that is, only clear the flag
  /// after this parent has received an up or a cancel.
  ///
  ///@param disallowIntercept True if the child does not want the parent to
  ///            intercept touch events.
  void requestDisallowInterceptTouchEvent(bool disallowIntercept) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestDisallowInterceptTouchEvent,
          jni.JniType.voidType,
          [disallowIntercept]).check();

  static final _id_requestChildRectangleOnScreen = jniAccessors.getMethodIDOf(
      _classRef,
      "requestChildRectangleOnScreen",
      "(Landroid/view/View;Landroid/graphics/Rect;Z)Z");

  /// from: public abstract boolean requestChildRectangleOnScreen(android.view.View child, android.graphics.Rect rectangle, boolean immediate)
  ///
  /// Called when a child of this group wants a particular rectangle to be
  /// positioned onto the screen.  ViewGroups overriding this can trust
  /// that:
  /// <ul>
  ///   <li>child will be a direct child of this group</li>
  ///   <li>rectangle will be in the child's content coordinates</li>
  /// </ul>
  ///
  /// ViewGroups overriding this should uphold the contract:
  ///
  /// <ul>
  ///   <li>nothing will change if the rectangle is already visible</li>
  ///   <li>the view port will be scrolled only just enough to make the
  ///       rectangle visible</li>
  /// <ul>
  ///@param child The direct child making the request.
  ///@param rectangle The rectangle in the child's coordinates the child
  ///        wishes to be on the screen.
  ///@param immediate True to forbid animated or delayed scrolling,
  ///        false otherwise
  ///@return Whether the group scrolled to handle the operation
  bool requestChildRectangleOnScreen(
          view_.View child, rect_.Rect rectangle, bool immediate) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestChildRectangleOnScreen,
          jni.JniType.booleanType,
          [child.reference, rectangle.reference, immediate]).boolean;

  static final _id_requestSendAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "requestSendAccessibilityEvent",
      "(Landroid/view/View;Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public abstract boolean requestSendAccessibilityEvent(android.view.View child, android.view.accessibility.AccessibilityEvent event)
  ///
  /// Called by a child to request from its parent to send an AccessibilityEvent.
  /// The child has already populated a record for itself in the event and is delegating
  /// to its parent to send the event. The parent can optionally add a record for itself.
  ///
  /// Note: An accessibility event is fired by an individual view which populates the
  ///       event with a record for its state and requests from its parent to perform
  ///       the sending. The parent can optionally add a record for itself before
  ///       dispatching the request to its parent. A parent can also choose not to
  ///       respect the request for sending the event. The accessibility event is sent
  ///       by the topmost view in the view tree.
  ///
  ///@param child The child which requests sending the event.
  ///@param event The event to be sent.
  ///@return True if the event was sent.
  bool requestSendAccessibilityEvent(
          view_.View child, accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestSendAccessibilityEvent,
          jni.JniType.booleanType,
          [child.reference, event.reference]).boolean;

  static final _id_childHasTransientStateChanged = jniAccessors.getMethodIDOf(
      _classRef, "childHasTransientStateChanged", "(Landroid/view/View;Z)V");

  /// from: public abstract void childHasTransientStateChanged(android.view.View child, boolean hasTransientState)
  ///
  /// Called when a child view now has or no longer is tracking transient state.
  ///
  /// "Transient state" is any state that a View might hold that is not expected to
  /// be reflected in the data model that the View currently presents. This state only
  /// affects the presentation to the user within the View itself, such as the current
  /// state of animations in progress or the state of a text selection operation.
  ///
  ///
  /// Transient state is useful for hinting to other components of the View system
  /// that a particular view is tracking something complex but encapsulated.
  /// A <code>ListView</code> for example may acknowledge that list item Views
  /// with transient state should be preserved within their position or stable item ID
  /// instead of treating that view as trivially replaceable by the backing adapter.
  /// This allows adapter implementations to be simpler instead of needing to track
  /// the state of item view animations in progress such that they could be restored
  /// in the event of an unexpected recycling and rebinding of attached item views.
  ///
  ///
  /// This method is called on a parent view when a child view or a view within
  /// its subtree begins or ends tracking of internal transient state.
  ///
  ///@param child Child view whose state has changed
  ///@param hasTransientState true if this child has transient state
  void childHasTransientStateChanged(
          view_.View child, bool hasTransientState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_childHasTransientStateChanged,
          jni.JniType.voidType,
          [child.reference, hasTransientState]).check();

  static final _id_requestFitSystemWindows =
      jniAccessors.getMethodIDOf(_classRef, "requestFitSystemWindows", "()V");

  /// from: public abstract void requestFitSystemWindows()
  ///
  /// Ask that a new dispatch of View\#fitSystemWindows(Rect) View.fitSystemWindows(Rect) be performed.
  void requestFitSystemWindows() => jniAccessors.callMethodWithArgs(
      reference, _id_requestFitSystemWindows, jni.JniType.voidType, []).check();

  static final _id_getParentForAccessibility = jniAccessors.getMethodIDOf(
      _classRef, "getParentForAccessibility", "()Landroid/view/ViewParent;");

  /// from: public abstract android.view.ViewParent getParentForAccessibility()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the parent of a given View for accessibility. Since some Views are not
  /// exposed to the accessibility layer the parent for accessibility is not
  /// necessarily the direct parent of the View, rather it is a predecessor.
  ///@return The parent or <code>null</code> if no such is found.
  ViewParent getParentForAccessibility() =>
      ViewParent.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getParentForAccessibility, jni.JniType.objectType, []).object);

  static final _id_notifySubtreeAccessibilityStateChanged =
      jniAccessors.getMethodIDOf(
          _classRef,
          "notifySubtreeAccessibilityStateChanged",
          "(Landroid/view/View;Landroid/view/View;I)V");

  /// from: public abstract void notifySubtreeAccessibilityStateChanged(android.view.View child, android.view.View source, int changeType)
  ///
  /// Notifies a view parent that the accessibility state of one of its
  /// descendants has changed and that the structure of the subtree is
  /// different.
  ///@param child The direct child whose subtree has changed.
  ///@param source The descendant view that changed. May not be {@code null}.
  /// This value must never be {@code null}.
  ///@param changeType A bit mask of the types of changes that occurred. One
  ///            or more of:
  ///            <ul>
  ///            <li>AccessibilityEvent\#CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION
  ///            <li>AccessibilityEvent\#CONTENT_CHANGE_TYPE_SUBTREE
  ///            <li>AccessibilityEvent\#CONTENT_CHANGE_TYPE_TEXT
  ///            <li>AccessibilityEvent\#CONTENT_CHANGE_TYPE_UNDEFINED
  ///            </ul>
  void notifySubtreeAccessibilityStateChanged(
          view_.View child, view_.View source, int changeType) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifySubtreeAccessibilityStateChanged,
          jni.JniType.voidType,
          [child.reference, source.reference, changeType]).check();

  static final _id_canResolveLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "canResolveLayoutDirection", "()Z");

  /// from: public abstract boolean canResolveLayoutDirection()
  ///
  /// Tells if this view parent can resolve the layout direction.
  /// See View\#setLayoutDirection(int)
  ///@return True if this view parent can resolve the layout direction.
  bool canResolveLayoutDirection() => jniAccessors.callMethodWithArgs(reference,
      _id_canResolveLayoutDirection, jni.JniType.booleanType, []).boolean;

  static final _id_isLayoutDirectionResolved =
      jniAccessors.getMethodIDOf(_classRef, "isLayoutDirectionResolved", "()Z");

  /// from: public abstract boolean isLayoutDirectionResolved()
  ///
  /// Tells if this view parent layout direction is resolved.
  /// See View\#setLayoutDirection(int)
  ///@return True if this view parent layout direction is resolved.
  bool isLayoutDirectionResolved() => jniAccessors.callMethodWithArgs(reference,
      _id_isLayoutDirectionResolved, jni.JniType.booleanType, []).boolean;

  static final _id_getLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "getLayoutDirection", "()I");

  /// from: public abstract int getLayoutDirection()
  ///
  /// Return this view parent layout direction. See View\#getLayoutDirection()
  ///@return View\#LAYOUT_DIRECTION_RTL if the layout direction is RTL or returns
  /// View\#LAYOUT_DIRECTION_LTR if the layout direction is not RTL.
  int getLayoutDirection() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayoutDirection, jni.JniType.intType, []).integer;

  static final _id_canResolveTextDirection =
      jniAccessors.getMethodIDOf(_classRef, "canResolveTextDirection", "()Z");

  /// from: public abstract boolean canResolveTextDirection()
  ///
  /// Tells if this view parent can resolve the text direction.
  /// See View\#setTextDirection(int)
  ///@return True if this view parent can resolve the text direction.
  bool canResolveTextDirection() => jniAccessors.callMethodWithArgs(reference,
      _id_canResolveTextDirection, jni.JniType.booleanType, []).boolean;

  static final _id_isTextDirectionResolved =
      jniAccessors.getMethodIDOf(_classRef, "isTextDirectionResolved", "()Z");

  /// from: public abstract boolean isTextDirectionResolved()
  ///
  /// Tells if this view parent text direction is resolved.
  /// See View\#setTextDirection(int)
  ///@return True if this view parent text direction is resolved.
  bool isTextDirectionResolved() => jniAccessors.callMethodWithArgs(reference,
      _id_isTextDirectionResolved, jni.JniType.booleanType, []).boolean;

  static final _id_getTextDirection =
      jniAccessors.getMethodIDOf(_classRef, "getTextDirection", "()I");

  /// from: public abstract int getTextDirection()
  ///
  /// Return this view parent text direction. See View\#getTextDirection()
  ///@return the resolved text direction. Returns one of:
  ///
  /// View\#TEXT_DIRECTION_FIRST_STRONG
  /// View\#TEXT_DIRECTION_ANY_RTL,
  /// View\#TEXT_DIRECTION_LTR,
  /// View\#TEXT_DIRECTION_RTL,
  /// View\#TEXT_DIRECTION_LOCALE
  int getTextDirection() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextDirection, jni.JniType.intType, []).integer;

  static final _id_canResolveTextAlignment =
      jniAccessors.getMethodIDOf(_classRef, "canResolveTextAlignment", "()Z");

  /// from: public abstract boolean canResolveTextAlignment()
  ///
  /// Tells if this view parent can resolve the text alignment.
  /// See View\#setTextAlignment(int)
  ///@return True if this view parent can resolve the text alignment.
  bool canResolveTextAlignment() => jniAccessors.callMethodWithArgs(reference,
      _id_canResolveTextAlignment, jni.JniType.booleanType, []).boolean;

  static final _id_isTextAlignmentResolved =
      jniAccessors.getMethodIDOf(_classRef, "isTextAlignmentResolved", "()Z");

  /// from: public abstract boolean isTextAlignmentResolved()
  ///
  /// Tells if this view parent text alignment is resolved.
  /// See View\#setTextAlignment(int)
  ///@return True if this view parent text alignment is resolved.
  bool isTextAlignmentResolved() => jniAccessors.callMethodWithArgs(reference,
      _id_isTextAlignmentResolved, jni.JniType.booleanType, []).boolean;

  static final _id_getTextAlignment =
      jniAccessors.getMethodIDOf(_classRef, "getTextAlignment", "()I");

  /// from: public abstract int getTextAlignment()
  ///
  /// Return this view parent text alignment. See android.view.View\#getTextAlignment()
  ///@return the resolved text alignment. Returns one of:
  ///
  /// View\#TEXT_ALIGNMENT_GRAVITY,
  /// View\#TEXT_ALIGNMENT_CENTER,
  /// View\#TEXT_ALIGNMENT_TEXT_START,
  /// View\#TEXT_ALIGNMENT_TEXT_END,
  /// View\#TEXT_ALIGNMENT_VIEW_START,
  /// View\#TEXT_ALIGNMENT_VIEW_END
  int getTextAlignment() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextAlignment, jni.JniType.intType, []).integer;

  static final _id_onStartNestedScroll = jniAccessors.getMethodIDOf(_classRef,
      "onStartNestedScroll", "(Landroid/view/View;Landroid/view/View;I)Z");

  /// from: public abstract boolean onStartNestedScroll(android.view.View child, android.view.View target, int nestedScrollAxes)
  ///
  /// React to a descendant view initiating a nestable scroll operation, claiming the
  /// nested scroll operation if appropriate.
  ///
  /// This method will be called in response to a descendant view invoking
  /// View\#startNestedScroll(int). Each parent up the view hierarchy will be
  /// given an opportunity to respond and claim the nested scrolling operation by returning
  /// <code>true</code>.
  ///
  ///
  /// This method may be overridden by ViewParent implementations to indicate when the view
  /// is willing to support a nested scrolling operation that is about to begin. If it returns
  /// true, this ViewParent will become the target view's nested scrolling parent for the duration
  /// of the scroll operation in progress. When the nested scroll is finished this ViewParent
  /// will receive a call to \#onStopNestedScroll(View).
  ///
  ///
  ///@param child Direct child of this ViewParent containing target
  ///@param target View that initiated the nested scroll
  ///@param nestedScrollAxes Flags consisting of View\#SCROLL_AXIS_HORIZONTAL,
  ///                         View\#SCROLL_AXIS_VERTICAL or both
  ///@return true if this ViewParent accepts the nested scroll operation
  bool onStartNestedScroll(
          view_.View child, view_.View target, int nestedScrollAxes) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onStartNestedScroll,
          jni.JniType.booleanType,
          [child.reference, target.reference, nestedScrollAxes]).boolean;

  static final _id_onNestedScrollAccepted = jniAccessors.getMethodIDOf(
      _classRef,
      "onNestedScrollAccepted",
      "(Landroid/view/View;Landroid/view/View;I)V");

  /// from: public abstract void onNestedScrollAccepted(android.view.View child, android.view.View target, int nestedScrollAxes)
  ///
  /// React to the successful claiming of a nested scroll operation.
  ///
  /// This method will be called after
  /// \#onStartNestedScroll(View, View, int) onStartNestedScroll returns true. It offers
  /// an opportunity for the view and its superclasses to perform initial configuration
  /// for the nested scroll. Implementations of this method should always call their superclass's
  /// implementation of this method if one is present.
  ///
  ///@param child Direct child of this ViewParent containing target
  ///@param target View that initiated the nested scroll
  ///@param nestedScrollAxes Flags consisting of View\#SCROLL_AXIS_HORIZONTAL,
  ///                         View\#SCROLL_AXIS_VERTICAL or both
  ///@see \#onStartNestedScroll(View, View, int)
  ///@see \#onStopNestedScroll(View)
  void onNestedScrollAccepted(
          view_.View child, view_.View target, int nestedScrollAxes) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedScrollAccepted,
          jni.JniType.voidType,
          [child.reference, target.reference, nestedScrollAxes]).check();

  static final _id_onStopNestedScroll = jniAccessors.getMethodIDOf(
      _classRef, "onStopNestedScroll", "(Landroid/view/View;)V");

  /// from: public abstract void onStopNestedScroll(android.view.View target)
  ///
  /// React to a nested scroll operation ending.
  ///
  /// Perform cleanup after a nested scrolling operation.
  /// This method will be called when a nested scroll stops, for example when a nested touch
  /// scroll ends with a MotionEvent\#ACTION_UP or MotionEvent\#ACTION_CANCEL event.
  /// Implementations of this method should always call their superclass's implementation of this
  /// method if one is present.
  ///
  ///@param target View that initiated the nested scroll
  void onStopNestedScroll(view_.View target) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStopNestedScroll,
      jni.JniType.voidType,
      [target.reference]).check();

  static final _id_onNestedScroll = jniAccessors.getMethodIDOf(
      _classRef, "onNestedScroll", "(Landroid/view/View;IIII)V");

  /// from: public abstract void onNestedScroll(android.view.View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)
  ///
  /// React to a nested scroll in progress.
  ///
  /// This method will be called when the ViewParent's current nested scrolling child view
  /// dispatches a nested scroll event. To receive calls to this method the ViewParent must have
  /// previously returned <code>true</code> for a call to
  /// \#onStartNestedScroll(View, View, int).
  ///
  ///
  /// Both the consumed and unconsumed portions of the scroll distance are reported to the
  /// ViewParent. An implementation may choose to use the consumed portion to match or chase scroll
  /// position of multiple child elements, for example. The unconsumed portion may be used to
  /// allow continuous dragging of multiple scrolling or draggable elements, such as scrolling
  /// a list within a vertical drawer where the drawer begins dragging once the edge of inner
  /// scrolling content is reached.
  ///
  ///@param target The descendent view controlling the nested scroll
  ///@param dxConsumed Horizontal scroll distance in pixels already consumed by target
  ///@param dyConsumed Vertical scroll distance in pixels already consumed by target
  ///@param dxUnconsumed Horizontal scroll distance in pixels not consumed by target
  ///@param dyUnconsumed Vertical scroll distance in pixels not consumed by target
  void onNestedScroll(view_.View target, int dxConsumed, int dyConsumed,
          int dxUnconsumed, int dyUnconsumed) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onNestedScroll, jni.JniType.voidType, [
        target.reference,
        dxConsumed,
        dyConsumed,
        dxUnconsumed,
        dyUnconsumed
      ]).check();

  static final _id_onNestedPreScroll = jniAccessors.getMethodIDOf(
      _classRef, "onNestedPreScroll", "(Landroid/view/View;II[I)V");

  /// from: public abstract void onNestedPreScroll(android.view.View target, int dx, int dy, int[] consumed)
  ///
  /// React to a nested scroll in progress before the target view consumes a portion of the scroll.
  ///
  /// When working with nested scrolling often the parent view may want an opportunity
  /// to consume the scroll before the nested scrolling child does. An example of this is a
  /// drawer that contains a scrollable list. The user will want to be able to scroll the list
  /// fully into view before the list itself begins scrolling.
  ///
  ///
  /// <code>onNestedPreScroll</code> is called when a nested scrolling child invokes
  /// View\#dispatchNestedPreScroll(int, int, int[], int[]). The implementation should
  /// report how any pixels of the scroll reported by dx, dy were consumed in the
  /// <code>consumed</code> array. Index 0 corresponds to dx and index 1 corresponds to dy.
  /// This parameter will never be null. Initial values for consumed[0] and consumed[1]
  /// will always be 0.
  ///
  ///@param target View that initiated the nested scroll
  ///@param dx Horizontal scroll distance in pixels
  ///@param dy Vertical scroll distance in pixels
  ///@param consumed Output. The horizontal and vertical scroll distance consumed by this parent
  void onNestedPreScroll(
          view_.View target, int dx, int dy, jni.JniObject consumed) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedPreScroll,
          jni.JniType.voidType,
          [target.reference, dx, dy, consumed.reference]).check();

  static final _id_onNestedFling = jniAccessors.getMethodIDOf(
      _classRef, "onNestedFling", "(Landroid/view/View;FFZ)Z");

  /// from: public abstract boolean onNestedFling(android.view.View target, float velocityX, float velocityY, boolean consumed)
  ///
  /// Request a fling from a nested scroll.
  ///
  /// This method signifies that a nested scrolling child has detected suitable conditions
  /// for a fling. Generally this means that a touch scroll has ended with a
  /// VelocityTracker velocity in the direction of scrolling that meets or exceeds
  /// the ViewConfiguration\#getScaledMinimumFlingVelocity() minimum fling velocity
  /// along a scrollable axis.
  ///
  ///
  /// If a nested scrolling child view would normally fling but it is at the edge of
  /// its own content, it can use this method to delegate the fling to its nested scrolling
  /// parent instead. The parent may optionally consume the fling or observe a child fling.
  ///
  ///@param target View that initiated the nested scroll
  ///@param velocityX Horizontal velocity in pixels per second
  ///@param velocityY Vertical velocity in pixels per second
  ///@param consumed true if the child consumed the fling, false otherwise
  ///@return true if this parent consumed or otherwise reacted to the fling
  bool onNestedFling(view_.View target, double velocityX, double velocityY,
          bool consumed) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedFling,
          jni.JniType.booleanType,
          [target.reference, velocityX, velocityY, consumed]).boolean;

  static final _id_onNestedPreFling = jniAccessors.getMethodIDOf(
      _classRef, "onNestedPreFling", "(Landroid/view/View;FF)Z");

  /// from: public abstract boolean onNestedPreFling(android.view.View target, float velocityX, float velocityY)
  ///
  /// React to a nested fling before the target view consumes it.
  ///
  /// This method siginfies that a nested scrolling child has detected a fling with the given
  /// velocity along each axis. Generally this means that a touch scroll has ended with a
  /// VelocityTracker velocity in the direction of scrolling that meets or exceeds
  /// the ViewConfiguration\#getScaledMinimumFlingVelocity() minimum fling velocity
  /// along a scrollable axis.
  ///
  ///
  /// If a nested scrolling parent is consuming motion as part of a
  /// \#onNestedPreScroll(View, int, int, int[]) pre-scroll, it may be appropriate for
  /// it to also consume the pre-fling to complete that same motion. By returning
  /// <code>true</code> from this method, the parent indicates that the child should not
  /// fling its own internal content as well.
  ///
  ///@param target View that initiated the nested scroll
  ///@param velocityX Horizontal velocity in pixels per second
  ///@param velocityY Vertical velocity in pixels per second
  ///@return true if this parent consumed the fling ahead of the target view
  bool onNestedPreFling(
          view_.View target, double velocityX, double velocityY) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedPreFling,
          jni.JniType.booleanType,
          [target.reference, velocityX, velocityY]).boolean;

  static final _id_onNestedPrePerformAccessibilityAction =
      jniAccessors.getMethodIDOf(
          _classRef,
          "onNestedPrePerformAccessibilityAction",
          "(Landroid/view/View;ILandroid/os/Bundle;)Z");

  /// from: public abstract boolean onNestedPrePerformAccessibilityAction(android.view.View target, int action, android.os.Bundle arguments)
  ///
  /// React to an accessibility action delegated by a target descendant view before the target
  /// processes it.
  ///
  /// This method may be called by a target descendant view if the target wishes to give
  /// a view in its parent chain a chance to react to the event before normal processing occurs.
  /// Most commonly this will be a scroll event such as
  /// android.view.accessibility.AccessibilityNodeInfo\#ACTION_SCROLL_FORWARD.
  /// A ViewParent that supports acting as a nested scrolling parent should override this
  /// method and act accordingly to implement scrolling via accesibility systems.
  ///
  ///@param target The target view dispatching this action
  ///@param action Action being performed; see
  ///               android.view.accessibility.AccessibilityNodeInfo
  ///@param arguments Optional action arguments
  ///@return true if the action was consumed by this ViewParent
  bool onNestedPrePerformAccessibilityAction(
          view_.View target, int action, bundle_.Bundle arguments) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNestedPrePerformAccessibilityAction,
          jni.JniType.booleanType,
          [target.reference, action, arguments.reference]).boolean;
}
