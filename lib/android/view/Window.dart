// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../content/res/TypedArray.dart" as typedarray_;

import "WindowManager.dart" as windowmanager_;

import "../os/IBinder.dart" as ibinder_;

import "../os/Handler.dart" as handler_;

import "SurfaceHolder.dart" as surfaceholder_;

import "InputQueue.dart" as inputqueue_;

import "View.dart" as view_;

import "ViewGroup.dart" as viewgroup_;

import "LayoutInflater.dart" as layoutinflater_;

import "KeyEvent.dart" as keyevent_;

import "../content/res/Configuration.dart" as configuration_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../net/Uri.dart" as uri_;

import "MotionEvent.dart" as motionevent_;

import "../os/Bundle.dart" as bundle_;

import "../media/session/MediaController.dart" as mediacontroller_;

import "InputEvent.dart" as inputevent_;

import "../transition/TransitionManager.dart" as transitionmanager_;

import "../transition/Scene.dart" as scene_;

import "../transition/Transition.dart" as transition_;

import "../graphics/Rect.dart" as rect_;

import "FrameMetrics.dart" as framemetrics_;

import "accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "Menu.dart" as menu_;

import "MenuItem.dart" as menuitem_;

import "SearchEvent.dart" as searchevent_;

import "ActionMode.dart" as actionmode_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.Window
///
/// Abstract base class for a top-level window look and behavior policy.  An
/// instance of this class should be used as the top-level view added to the
/// window manager. It provides standard UI policies such as a background, title
/// area, default key processing, etc.
///
/// The only existing implementation of this abstract class is
/// android.view.PhoneWindow, which you should instantiate when needing a
/// Window.
class Window extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/Window");
  Window.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DECOR_CAPTION_SHADE_AUTO
  ///
  /// Flag for letting the theme drive the color of the window caption controls. Use with
  /// \#setDecorCaptionShade(int). This is the default value.
  static const DECOR_CAPTION_SHADE_AUTO = 0;

  /// from: static public final int DECOR_CAPTION_SHADE_DARK
  ///
  /// Flag for setting dark-color controls on the window caption. Use with
  /// \#setDecorCaptionShade(int).
  static const DECOR_CAPTION_SHADE_DARK = 2;

  /// from: static public final int DECOR_CAPTION_SHADE_LIGHT
  ///
  /// Flag for setting light-color controls on the window caption. Use with
  /// \#setDecorCaptionShade(int).
  static const DECOR_CAPTION_SHADE_LIGHT = 1;

  /// from: static protected final int DEFAULT_FEATURES
  ///
  /// The default features enabled.
  ///@deprecated use \#getDefaultFeatures(android.content.Context) instead.
  static const DEFAULT_FEATURES = 65;

  /// from: static public final int FEATURE_ACTION_BAR
  ///
  /// Flag for enabling the Action Bar.
  /// This is enabled by default for some devices. The Action Bar
  /// replaces the title bar and provides an alternate location
  /// for an on-screen menu button on some devices.
  static const FEATURE_ACTION_BAR = 8;

  /// from: static public final int FEATURE_ACTION_BAR_OVERLAY
  ///
  /// Flag for requesting an Action Bar that overlays window content.
  /// Normally an Action Bar will sit in the space above window content, but if this
  /// feature is requested along with \#FEATURE_ACTION_BAR it will be layered over
  /// the window content itself. This is useful if you would like your app to have more control
  /// over how the Action Bar is displayed, such as letting application content scroll beneath
  /// an Action Bar with a transparent background or otherwise displaying a transparent/translucent
  /// Action Bar over application content.
  ///
  /// This mode is especially useful with View\#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN, which allows you to seamlessly hide the
  /// action bar in conjunction with other screen decorations.
  ///
  /// As of android.os.Build.VERSION_CODES\#JELLY_BEAN, when an
  /// ActionBar is in this mode it will adjust the insets provided to
  /// View\#fitSystemWindows(android.graphics.Rect) View.fitSystemWindows(Rect)
  /// to include the content covered by the action bar, so you can do layout within
  /// that space.
  static const FEATURE_ACTION_BAR_OVERLAY = 9;

  /// from: static public final int FEATURE_ACTION_MODE_OVERLAY
  ///
  /// Flag for specifying the behavior of action modes when an Action Bar is not present.
  /// If overlay is enabled, the action mode UI will be allowed to cover existing window content.
  static const FEATURE_ACTION_MODE_OVERLAY = 10;

  /// from: static public final int FEATURE_ACTIVITY_TRANSITIONS
  ///
  /// Enables Activities to run Activity Transitions either through sending or receiving
  /// ActivityOptions bundle created with
  /// android.app.ActivityOptions\#makeSceneTransitionAnimation(android.app.Activity,
  /// android.util.Pair[]) or android.app.ActivityOptions\#makeSceneTransitionAnimation(
  /// android.app.Activity, View, String).
  static const FEATURE_ACTIVITY_TRANSITIONS = 13;

  /// from: static public final int FEATURE_CONTENT_TRANSITIONS
  ///
  /// Flag for requesting that window content changes should be animated using a
  /// TransitionManager.
  ///
  /// The TransitionManager is set using
  /// \#setTransitionManager(android.transition.TransitionManager). If none is set,
  /// a default TransitionManager will be used.
  ///
  ///@see \#setContentView
  static const FEATURE_CONTENT_TRANSITIONS = 12;

  /// from: static public final int FEATURE_CONTEXT_MENU
  ///
  /// Flag for the context menu.  This is enabled by default.
  static const FEATURE_CONTEXT_MENU = 6;

  /// from: static public final int FEATURE_CUSTOM_TITLE
  ///
  /// Flag for custom title. You cannot combine this feature with other title features.
  static const FEATURE_CUSTOM_TITLE = 7;

  /// from: static public final int FEATURE_INDETERMINATE_PROGRESS
  ///
  /// Flag for indeterminate progress.
  ///@deprecated No longer supported starting in API 21.
  static const FEATURE_INDETERMINATE_PROGRESS = 5;

  /// from: static public final int FEATURE_LEFT_ICON
  ///
  /// Flag for having an icon on the left side of the title bar
  static const FEATURE_LEFT_ICON = 3;

  /// from: static public final int FEATURE_NO_TITLE
  ///
  /// Flag for the "no title" feature, turning off the title at the top
  ///  of the screen.
  static const FEATURE_NO_TITLE = 1;

  /// from: static public final int FEATURE_OPTIONS_PANEL
  ///
  /// Flag for the "options panel" feature.  This is enabled by default.
  static const FEATURE_OPTIONS_PANEL = 0;

  /// from: static public final int FEATURE_PROGRESS
  ///
  /// Flag for the progress indicator feature.
  ///@deprecated No longer supported starting in API 21.
  static const FEATURE_PROGRESS = 2;

  /// from: static public final int FEATURE_RIGHT_ICON
  ///
  /// Flag for having an icon on the right side of the title bar
  static const FEATURE_RIGHT_ICON = 4;

  /// from: static public final int FEATURE_SWIPE_TO_DISMISS
  ///
  /// Flag for requesting a decoration-free window that is dismissed by swiping from the left.
  static const FEATURE_SWIPE_TO_DISMISS = 11;

  /// from: static public final int ID_ANDROID_CONTENT
  ///
  /// The ID that the main layout in the XML layout file should have.
  static const ID_ANDROID_CONTENT = 16908290;

  /// from: static public final java.lang.String NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME
  ///
  /// The transitionName for the navigation bar background View when a custom background is used.
  ///@see android.view.Window\#setNavigationBarColor(int)
  static const NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME =
      "android:navigation:background";

  /// from: static public final int PROGRESS_END
  ///
  /// Ending value for the (primary) progress.
  ///@deprecated \#FEATURE_PROGRESS and related methods are no longer
  ///             supported starting in API 21.
  static const PROGRESS_END = 10000;

  /// from: static public final int PROGRESS_INDETERMINATE_OFF
  ///
  /// Flag for setting the progress bar's indeterminate mode off.
  ///@deprecated \#FEATURE_INDETERMINATE_PROGRESS and related methods
  ///             are no longer supported starting in API 21.
  static const PROGRESS_INDETERMINATE_OFF = -4;

  /// from: static public final int PROGRESS_INDETERMINATE_ON
  ///
  /// Flag for setting the progress bar's indeterminate mode on.
  ///@deprecated \#FEATURE_INDETERMINATE_PROGRESS and related methods
  ///             are no longer supported starting in API 21.
  static const PROGRESS_INDETERMINATE_ON = -3;

  /// from: static public final int PROGRESS_SECONDARY_END
  ///
  /// Highest possible value for the secondary progress.
  ///@deprecated \#FEATURE_PROGRESS and related methods are no longer
  ///             supported starting in API 21.
  static const PROGRESS_SECONDARY_END = 30000;

  /// from: static public final int PROGRESS_SECONDARY_START
  ///
  /// Lowest possible value for the secondary progress.
  ///@deprecated \#FEATURE_PROGRESS and related methods are no longer
  ///             supported starting in API 21.
  static const PROGRESS_SECONDARY_START = 20000;

  /// from: static public final int PROGRESS_START
  ///
  /// Starting value for the (primary) progress.
  ///@deprecated \#FEATURE_PROGRESS and related methods are no longer
  ///             supported starting in API 21.
  static const PROGRESS_START = 0;

  /// from: static public final int PROGRESS_VISIBILITY_OFF
  ///
  /// Flag for setting the progress bar's visibility to GONE.
  ///@deprecated \#FEATURE_PROGRESS and related methods are no longer
  ///             supported starting in API 21.
  static const PROGRESS_VISIBILITY_OFF = -2;

  /// from: static public final int PROGRESS_VISIBILITY_ON
  ///
  /// Flag for setting the progress bar's visibility to VISIBLE.
  ///@deprecated \#FEATURE_PROGRESS and related methods are no longer
  ///             supported starting in API 21.
  static const PROGRESS_VISIBILITY_ON = -1;

  /// from: static public final java.lang.String STATUS_BAR_BACKGROUND_TRANSITION_NAME
  ///
  /// The transitionName for the status bar background View when a custom background is used.
  ///@see android.view.Window\#setStatusBarColor(int)
  static const STATUS_BAR_BACKGROUND_TRANSITION_NAME =
      "android:status:background";

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Window(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public final android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Context this window policy is running in, for retrieving
  /// resources and other information.
  ///@return Context The Context that was supplied to the constructor.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getWindowStyle = jniAccessors.getMethodIDOf(
      _classRef, "getWindowStyle", "()Landroid/content/res/TypedArray;");

  /// from: public final android.content.res.TypedArray getWindowStyle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the android.R.styleable\#Window attributes from this
  /// window's theme.
  typedarray_.TypedArray getWindowStyle() =>
      typedarray_.TypedArray.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindowStyle, jni.JniType.objectType, []).object);

  static final _id_setContainer = jniAccessors.getMethodIDOf(
      _classRef, "setContainer", "(Landroid/view/Window;)V");

  /// from: public void setContainer(android.view.Window container)
  ///
  /// Set the container for this window.  If not set, the DecorWindow
  /// operates as a top-level window; otherwise, it negotiates with the
  /// container to display itself appropriately.
  ///@param container The desired containing Window.
  void setContainer(Window container) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContainer,
      jni.JniType.voidType,
      [container.reference]).check();

  static final _id_getContainer = jniAccessors.getMethodIDOf(
      _classRef, "getContainer", "()Landroid/view/Window;");

  /// from: public final android.view.Window getContainer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the container for this Window.
  ///@return Window The containing window, or null if this is a
  ///         top-level window.
  Window getContainer() => Window.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getContainer, jni.JniType.objectType, []).object);

  static final _id_hasChildren =
      jniAccessors.getMethodIDOf(_classRef, "hasChildren", "()Z");

  /// from: public final boolean hasChildren()
  bool hasChildren() => jniAccessors.callMethodWithArgs(
      reference, _id_hasChildren, jni.JniType.booleanType, []).boolean;

  static final _id_setWindowManager = jniAccessors.getMethodIDOf(
      _classRef,
      "setWindowManager",
      "(Landroid/view/WindowManager;Landroid/os/IBinder;Ljava/lang/String;)V");

  /// from: public void setWindowManager(android.view.WindowManager wm, android.os.IBinder appToken, java.lang.String appName)
  ///
  /// Set the window manager for use by this Window to, for example,
  /// display panels.  This is _not_ used for displaying the
  /// Window itself -- that must be done by the client.
  ///@param wm The window manager for adding new windows.
  void setWindowManager(windowmanager_.WindowManager wm,
          ibinder_.IBinder appToken, jni.JniString appName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setWindowManager,
          jni.JniType.voidType,
          [wm.reference, appToken.reference, appName.reference]).check();

  static final _id_setWindowManager1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setWindowManager",
      "(Landroid/view/WindowManager;Landroid/os/IBinder;Ljava/lang/String;Z)V");

  /// from: public void setWindowManager(android.view.WindowManager wm, android.os.IBinder appToken, java.lang.String appName, boolean hardwareAccelerated)
  ///
  /// Set the window manager for use by this Window to, for example,
  /// display panels.  This is _not_ used for displaying the
  /// Window itself -- that must be done by the client.
  ///@param wm The window manager for adding new windows.
  void setWindowManager1(
          windowmanager_.WindowManager wm,
          ibinder_.IBinder appToken,
          jni.JniString appName,
          bool hardwareAccelerated) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setWindowManager1, jni.JniType.voidType, [
        wm.reference,
        appToken.reference,
        appName.reference,
        hardwareAccelerated
      ]).check();

  static final _id_getWindowManager = jniAccessors.getMethodIDOf(
      _classRef, "getWindowManager", "()Landroid/view/WindowManager;");

  /// from: public android.view.WindowManager getWindowManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the window manager allowing this Window to display its own
  /// windows.
  ///@return WindowManager The ViewManager.
  windowmanager_.WindowManager getWindowManager() =>
      windowmanager_.WindowManager.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindowManager, jni.JniType.objectType, []).object);

  static final _id_setCallback = jniAccessors.getMethodIDOf(
      _classRef, "setCallback", "(Landroid/view/Window\$Callback;)V");

  /// from: public void setCallback(android.view.Window.Callback callback)
  ///
  /// Set the Callback interface for this window, used to intercept key
  /// events and other dynamic operations in the window.
  ///@param callback The desired Callback interface.
  void setCallback(Window_Callback callback) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCallback,
      jni.JniType.voidType,
      [callback.reference]).check();

  static final _id_getCallback = jniAccessors.getMethodIDOf(
      _classRef, "getCallback", "()Landroid/view/Window\$Callback;");

  /// from: public final android.view.Window.Callback getCallback()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current Callback interface for this window.
  Window_Callback getCallback() =>
      Window_Callback.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallback, jni.JniType.objectType, []).object);

  static final _id_addOnFrameMetricsAvailableListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnFrameMetricsAvailableListener",
      "(Landroid/view/Window\$OnFrameMetricsAvailableListener;Landroid/os/Handler;)V");

  /// from: public final void addOnFrameMetricsAvailableListener(android.view.Window.OnFrameMetricsAvailableListener listener, android.os.Handler handler)
  ///
  /// Set an observer to collect frame stats for each frame rendererd in this window.
  ///
  /// Must be in hardware rendering mode.
  ///@param listener This value must never be {@code null}.
  void addOnFrameMetricsAvailableListener(
          Window_OnFrameMetricsAvailableListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnFrameMetricsAvailableListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeOnFrameMetricsAvailableListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "removeOnFrameMetricsAvailableListener",
          "(Landroid/view/Window\$OnFrameMetricsAvailableListener;)V");

  /// from: public final void removeOnFrameMetricsAvailableListener(android.view.Window.OnFrameMetricsAvailableListener listener)
  ///
  /// Remove observer and stop listening to frame stats for this window.
  void removeOnFrameMetricsAvailableListener(
          Window_OnFrameMetricsAvailableListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnFrameMetricsAvailableListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setRestrictedCaptionAreaListener =
      jniAccessors.getMethodIDOf(_classRef, "setRestrictedCaptionAreaListener",
          "(Landroid/view/Window\$OnRestrictedCaptionAreaChangedListener;)V");

  /// from: public final void setRestrictedCaptionAreaListener(android.view.Window.OnRestrictedCaptionAreaChangedListener listener)
  ///
  /// Set a callback for changes of area where caption will draw its content.
  ///@param listener Callback that will be called when the area changes.
  void setRestrictedCaptionAreaListener(
          Window_OnRestrictedCaptionAreaChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRestrictedCaptionAreaListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_takeSurface = jniAccessors.getMethodIDOf(
      _classRef, "takeSurface", "(Landroid/view/SurfaceHolder\$Callback2;)V");

  /// from: public abstract void takeSurface(android.view.SurfaceHolder.Callback2 callback)
  ///
  /// Take ownership of this window's surface.  The window's view hierarchy
  /// will no longer draw into the surface, though it will otherwise continue
  /// to operate (such as for receiving input events).  The given SurfaceHolder
  /// callback will be used to tell you about state changes to the surface.
  void takeSurface(surfaceholder_.SurfaceHolder_Callback2 callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_takeSurface,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_takeInputQueue = jniAccessors.getMethodIDOf(
      _classRef, "takeInputQueue", "(Landroid/view/InputQueue\$Callback;)V");

  /// from: public abstract void takeInputQueue(android.view.InputQueue.Callback callback)
  ///
  /// Take ownership of this window's InputQueue.  The window will no
  /// longer read and dispatch input events from the queue; it is your
  /// responsibility to do so.
  void takeInputQueue(inputqueue_.InputQueue_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_takeInputQueue,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_isFloating =
      jniAccessors.getMethodIDOf(_classRef, "isFloating", "()Z");

  /// from: public abstract boolean isFloating()
  ///
  /// Return whether this window is being displayed with a floating style
  /// (based on the android.R.attr\#windowIsFloating attribute in
  /// the style/theme).
  ///@return Returns true if the window is configured to be displayed floating
  /// on top of whatever is behind it.
  bool isFloating() => jniAccessors.callMethodWithArgs(
      reference, _id_isFloating, jni.JniType.booleanType, []).boolean;

  static final _id_setLayout =
      jniAccessors.getMethodIDOf(_classRef, "setLayout", "(II)V");

  /// from: public void setLayout(int width, int height)
  ///
  /// Set the width and height layout parameters of the window.  The default
  /// for both of these is MATCH_PARENT; you can change them to WRAP_CONTENT
  /// or an absolute value to make a window that is not full-screen.
  ///@param width The desired layout width of the window.
  ///@param height The desired layout height of the window.
  ///@see ViewGroup.LayoutParams\#height
  ///@see ViewGroup.LayoutParams\#width
  void setLayout(int width, int height) => jniAccessors.callMethodWithArgs(
      reference, _id_setLayout, jni.JniType.voidType, [width, height]).check();

  static final _id_setGravity =
      jniAccessors.getMethodIDOf(_classRef, "setGravity", "(I)V");

  /// from: public void setGravity(int gravity)
  ///
  /// Set the gravity of the window, as per the Gravity constants.  This
  /// controls how the window manager is positioned in the overall window; it
  /// is only useful when using WRAP_CONTENT for the layout width or height.
  ///@param gravity The desired gravity constant.
  ///@see Gravity
  ///@see \#setLayout
  void setGravity(int gravity) => jniAccessors.callMethodWithArgs(
      reference, _id_setGravity, jni.JniType.voidType, [gravity]).check();

  static final _id_setType =
      jniAccessors.getMethodIDOf(_classRef, "setType", "(I)V");

  /// from: public void setType(int type)
  ///
  /// Set the type of the window, as per the WindowManager.LayoutParams
  /// types.
  ///@param type The new window type (see WindowManager.LayoutParams).
  void setType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setType, jni.JniType.voidType, [type]).check();

  static final _id_setFormat =
      jniAccessors.getMethodIDOf(_classRef, "setFormat", "(I)V");

  /// from: public void setFormat(int format)
  ///
  /// Set the format of window, as per the PixelFormat types.  This overrides
  /// the default format that is selected by the Window based on its
  /// window decorations.
  ///@param format The new window format (see PixelFormat).  Use
  ///               PixelFormat.UNKNOWN to allow the Window to select
  ///               the format.
  ///@see PixelFormat
  void setFormat(int format) => jniAccessors.callMethodWithArgs(
      reference, _id_setFormat, jni.JniType.voidType, [format]).check();

  static final _id_setWindowAnimations =
      jniAccessors.getMethodIDOf(_classRef, "setWindowAnimations", "(I)V");

  /// from: public void setWindowAnimations(int resId)
  ///
  /// Specify custom animations to use for the window, as per
  /// WindowManager.LayoutParams\#windowAnimations WindowManager.LayoutParams.windowAnimations.  Providing anything besides
  /// 0 here will override the animations the window would
  /// normally retrieve from its theme.
  void setWindowAnimations(int resId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWindowAnimations,
      jni.JniType.voidType,
      [resId]).check();

  static final _id_setSoftInputMode =
      jniAccessors.getMethodIDOf(_classRef, "setSoftInputMode", "(I)V");

  /// from: public void setSoftInputMode(int mode)
  ///
  /// Specify an explicit soft input mode to use for the window, as per
  /// WindowManager.LayoutParams\#softInputMode WindowManager.LayoutParams.softInputMode.  Providing anything besides
  /// "unspecified" here will override the input mode the window would
  /// normally retrieve from its theme.
  void setSoftInputMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setSoftInputMode, jni.JniType.voidType, [mode]).check();

  static final _id_addFlags =
      jniAccessors.getMethodIDOf(_classRef, "addFlags", "(I)V");

  /// from: public void addFlags(int flags)
  ///
  /// Convenience function to set the flag bits as specified in flags, as
  /// per \#setFlags.
  ///@param flags The flag bits to be set.
  ///@see \#setFlags
  ///@see \#clearFlags
  void addFlags(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_addFlags, jni.JniType.voidType, [flags]).check();

  static final _id_clearFlags =
      jniAccessors.getMethodIDOf(_classRef, "clearFlags", "(I)V");

  /// from: public void clearFlags(int flags)
  ///
  /// Convenience function to clear the flag bits as specified in flags, as
  /// per \#setFlags.
  ///@param flags The flag bits to be cleared.
  ///@see \#setFlags
  ///@see \#addFlags
  void clearFlags(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_clearFlags, jni.JniType.voidType, [flags]).check();

  static final _id_setFlags =
      jniAccessors.getMethodIDOf(_classRef, "setFlags", "(II)V");

  /// from: public void setFlags(int flags, int mask)
  ///
  /// Set the flags of the window, as per the
  /// WindowManager.LayoutParams WindowManager.LayoutParams
  /// flags.
  ///
  /// Note that some flags must be set before the window decoration is
  /// created (by the first call to
  /// \#setContentView(View, android.view.ViewGroup.LayoutParams) or
  /// \#getDecorView():
  /// WindowManager.LayoutParams\#FLAG_LAYOUT_IN_SCREEN and
  /// WindowManager.LayoutParams\#FLAG_LAYOUT_INSET_DECOR.  These
  /// will be set for you based on the android.R.attr\#windowIsFloating
  /// attribute.
  ///@param flags The new window flags (see WindowManager.LayoutParams).
  ///@param mask Which of the window flag bits to modify.
  ///@see \#addFlags
  ///@see \#clearFlags
  void setFlags(int flags, int mask) => jniAccessors.callMethodWithArgs(
      reference, _id_setFlags, jni.JniType.voidType, [flags, mask]).check();

  static final _id_setColorMode =
      jniAccessors.getMethodIDOf(_classRef, "setColorMode", "(I)V");

  /// from: public void setColorMode(int colorMode)
  ///
  /// Sets the requested color mode of the window. The requested the color mode might
  /// override the window's pixel WindowManager.LayoutParams\#format format.
  ///
  ///
  /// The requested color mode must be one of ActivityInfo\#COLOR_MODE_DEFAULT,
  /// ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT or ActivityInfo\#COLOR_MODE_HDR.
  ///
  ///
  /// The requested color mode is not guaranteed to be honored. Please refer to
  /// \#getColorMode() for more information.
  ///
  ///@see \#getColorMode()
  ///@see Display\#isWideColorGamut()
  ///@see Configuration\#isScreenWideColorGamut()
  ///@param colorMode Value is android.content.pm.ActivityInfo\#COLOR_MODE_DEFAULT, android.content.pm.ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT, or android.content.pm.ActivityInfo\#COLOR_MODE_HDR
  void setColorMode(int colorMode) => jniAccessors.callMethodWithArgs(
      reference, _id_setColorMode, jni.JniType.voidType, [colorMode]).check();

  static final _id_getColorMode =
      jniAccessors.getMethodIDOf(_classRef, "getColorMode", "()I");

  /// from: public int getColorMode()
  ///
  /// Returns the requested color mode of the window, one of
  /// ActivityInfo\#COLOR_MODE_DEFAULT, ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT
  /// or ActivityInfo\#COLOR_MODE_HDR. If ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT
  /// was requested it is possible the window will not be put in wide color gamut mode depending
  /// on device and display support for that mode. Use \#isWideColorGamut to determine
  /// if the window is currently in wide color gamut mode.
  ///@see \#setColorMode(int)
  ///@see Display\#isWideColorGamut()
  ///@see Configuration\#isScreenWideColorGamut()
  ///@return Value is android.content.pm.ActivityInfo\#COLOR_MODE_DEFAULT, android.content.pm.ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT, or android.content.pm.ActivityInfo\#COLOR_MODE_HDR
  int getColorMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getColorMode, jni.JniType.intType, []).integer;

  static final _id_isWideColorGamut =
      jniAccessors.getMethodIDOf(_classRef, "isWideColorGamut", "()Z");

  /// from: public boolean isWideColorGamut()
  ///
  /// Returns true if this window's color mode is ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT,
  /// the display has a wide color gamut and this device supports wide color gamut rendering.
  ///@see Display\#isWideColorGamut()
  ///@see Configuration\#isScreenWideColorGamut()
  bool isWideColorGamut() => jniAccessors.callMethodWithArgs(
      reference, _id_isWideColorGamut, jni.JniType.booleanType, []).boolean;

  static final _id_setDimAmount =
      jniAccessors.getMethodIDOf(_classRef, "setDimAmount", "(F)V");

  /// from: public void setDimAmount(float amount)
  ///
  /// Set the amount of dim behind the window when using
  /// WindowManager.LayoutParams\#FLAG_DIM_BEHIND.  This overrides
  /// the default dim amount of that is selected by the Window based on
  /// its theme.
  ///@param amount The new dim amount, from 0 for no dim to 1 for full dim.
  void setDimAmount(double amount) => jniAccessors.callMethodWithArgs(
      reference, _id_setDimAmount, jni.JniType.voidType, [amount]).check();

  static final _id_setAttributes = jniAccessors.getMethodIDOf(_classRef,
      "setAttributes", "(Landroid/view/WindowManager\$LayoutParams;)V");

  /// from: public void setAttributes(android.view.WindowManager.LayoutParams a)
  ///
  /// Specify custom window attributes.  <strong>PLEASE NOTE:</strong> the
  /// layout params you give here should generally be from values previously
  /// retrieved with \#getAttributes(); you probably do not want to
  /// blindly create and apply your own, since this will blow away any values
  /// set by the framework that you are not interested in.
  ///@param a The new window attributes, which will completely override any
  ///          current values.
  void setAttributes(windowmanager_.WindowManager_LayoutParams a) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAttributes,
          jni.JniType.voidType, [a.reference]).check();

  static final _id_getAttributes = jniAccessors.getMethodIDOf(_classRef,
      "getAttributes", "()Landroid/view/WindowManager\$LayoutParams;");

  /// from: public final android.view.WindowManager.LayoutParams getAttributes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current window attributes associated with this panel.
  ///@return WindowManager.LayoutParams Either the existing window
  ///         attributes object, or a freshly created one if there is none.
  windowmanager_.WindowManager_LayoutParams getAttributes() =>
      windowmanager_.WindowManager_LayoutParams.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getAttributes, jni.JniType.objectType, []).object);

  static final _id_getForcedWindowFlags =
      jniAccessors.getMethodIDOf(_classRef, "getForcedWindowFlags", "()I");

  /// from: protected final int getForcedWindowFlags()
  ///
  /// Return the window flags that have been explicitly set by the client,
  /// so will not be modified by \#getDecorView.
  int getForcedWindowFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getForcedWindowFlags, jni.JniType.intType, []).integer;

  static final _id_hasSoftInputMode =
      jniAccessors.getMethodIDOf(_classRef, "hasSoftInputMode", "()Z");

  /// from: protected final boolean hasSoftInputMode()
  ///
  /// Has the app specified their own soft input mode?
  bool hasSoftInputMode() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSoftInputMode, jni.JniType.booleanType, []).boolean;

  static final _id_setSustainedPerformanceMode = jniAccessors.getMethodIDOf(
      _classRef, "setSustainedPerformanceMode", "(Z)V");

  /// from: public void setSustainedPerformanceMode(boolean enable)
  void setSustainedPerformanceMode(bool enable) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSustainedPerformanceMode,
          jni.JniType.voidType,
          [enable]).check();

  static final _id_requestFeature =
      jniAccessors.getMethodIDOf(_classRef, "requestFeature", "(I)Z");

  /// from: public boolean requestFeature(int featureId)
  ///
  /// Enable extended screen features.  This must be called before
  /// setContentView().  May be called as many times as desired as long as it
  /// is before setContentView().  If not called, no extended features
  /// will be available.  You can not turn off a feature once it is requested.
  /// You canot use other title features with \#FEATURE_CUSTOM_TITLE.
  ///@param featureId The desired features, defined as constants by Window.
  ///@return The features that are now set.
  bool requestFeature(int featureId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestFeature,
      jni.JniType.booleanType,
      [featureId]).boolean;

  static final _id_makeActive =
      jniAccessors.getMethodIDOf(_classRef, "makeActive", "()V");

  /// from: public final void makeActive()
  void makeActive() => jniAccessors.callMethodWithArgs(
      reference, _id_makeActive, jni.JniType.voidType, []).check();

  static final _id_isActive =
      jniAccessors.getMethodIDOf(_classRef, "isActive", "()Z");

  /// from: public final boolean isActive()
  bool isActive() => jniAccessors.callMethodWithArgs(
      reference, _id_isActive, jni.JniType.booleanType, []).boolean;

  static final _id_setContentView =
      jniAccessors.getMethodIDOf(_classRef, "setContentView", "(I)V");

  /// from: public abstract void setContentView(int layoutResID)
  ///
  /// Convenience for
  /// \#setContentView(View, android.view.ViewGroup.LayoutParams)
  /// to set the screen content from a layout resource.  The resource will be
  /// inflated, adding all top-level views to the screen.
  ///@param layoutResID Resource ID to be inflated.
  ///@see \#setContentView(View, android.view.ViewGroup.LayoutParams)
  void setContentView(int layoutResID) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView,
      jni.JniType.voidType,
      [layoutResID]).check();

  static final _id_setContentView1 = jniAccessors.getMethodIDOf(
      _classRef, "setContentView", "(Landroid/view/View;)V");

  /// from: public abstract void setContentView(android.view.View view)
  ///
  /// Convenience for
  /// \#setContentView(View, android.view.ViewGroup.LayoutParams)
  /// set the screen content to an explicit view.  This view is placed
  /// directly into the screen's view hierarchy.  It can itself be a complex
  /// view hierarhcy.
  ///@param view The desired content to display.
  ///@see \#setContentView(View, android.view.ViewGroup.LayoutParams)
  void setContentView1(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView1,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setContentView2 = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public abstract void setContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Set the screen content to an explicit view.  This view is placed
  /// directly into the screen's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///
  /// Note that calling this function "locks in" various characteristics
  /// of the window that can not, from this point forward, be changed: the
  /// features that have been requested with \#requestFeature(int),
  /// and certain window flags as described in \#setFlags(int, int).
  ///
  ///
  /// If \#FEATURE_CONTENT_TRANSITIONS is set, the window's
  /// TransitionManager will be used to animate content from the current
  /// content View to view.
  ///
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  ///@see \#getTransitionManager()
  ///@see \#setTransitionManager(android.transition.TransitionManager)
  void setContentView2(
          view_.View view, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentView2,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_addContentView = jniAccessors.getMethodIDOf(
      _classRef,
      "addContentView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public abstract void addContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Variation on
  /// \#setContentView(View, android.view.ViewGroup.LayoutParams)
  /// to add an additional content view to the screen.  Added after any existing
  /// ones in the screen -- existing views are NOT removed.
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  void addContentView(
          view_.View view, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_addContentView,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_getCurrentFocus = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentFocus", "()Landroid/view/View;");

  /// from: public abstract android.view.View getCurrentFocus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the view in this Window that currently has focus, or null if
  /// there are none.  Note that this does not look in any containing
  /// Window.
  ///@return View The current View with focus or null.
  view_.View getCurrentFocus() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCurrentFocus, jni.JniType.objectType, []).object);

  static final _id_getLayoutInflater = jniAccessors.getMethodIDOf(
      _classRef, "getLayoutInflater", "()Landroid/view/LayoutInflater;");

  /// from: public abstract android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Quick access to the LayoutInflater instance that this Window
  /// retrieved from its Context.
  ///@return LayoutInflater The shared LayoutInflater.
  ///
  /// This value will never be {@code null}.
  layoutinflater_.LayoutInflater getLayoutInflater() =>
      layoutinflater_.LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLayoutInflater, jni.JniType.objectType, []).object);

  static final _id_setTitle = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public abstract void setTitle(java.lang.CharSequence title)
  void setTitle(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle, jni.JniType.voidType, [title.reference]).check();

  static final _id_setTitleColor =
      jniAccessors.getMethodIDOf(_classRef, "setTitleColor", "(I)V");

  /// from: public abstract void setTitleColor(int textColor)
  void setTitleColor(int textColor) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitleColor, jni.JniType.voidType, [textColor]).check();

  static final _id_openPanel = jniAccessors.getMethodIDOf(
      _classRef, "openPanel", "(ILandroid/view/KeyEvent;)V");

  /// from: public abstract void openPanel(int featureId, android.view.KeyEvent event)
  void openPanel(int featureId, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_openPanel,
          jni.JniType.voidType, [featureId, event.reference]).check();

  static final _id_closePanel =
      jniAccessors.getMethodIDOf(_classRef, "closePanel", "(I)V");

  /// from: public abstract void closePanel(int featureId)
  void closePanel(int featureId) => jniAccessors.callMethodWithArgs(
      reference, _id_closePanel, jni.JniType.voidType, [featureId]).check();

  static final _id_togglePanel = jniAccessors.getMethodIDOf(
      _classRef, "togglePanel", "(ILandroid/view/KeyEvent;)V");

  /// from: public abstract void togglePanel(int featureId, android.view.KeyEvent event)
  void togglePanel(int featureId, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_togglePanel,
          jni.JniType.voidType, [featureId, event.reference]).check();

  static final _id_invalidatePanelMenu =
      jniAccessors.getMethodIDOf(_classRef, "invalidatePanelMenu", "(I)V");

  /// from: public abstract void invalidatePanelMenu(int featureId)
  void invalidatePanelMenu(int featureId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_invalidatePanelMenu,
      jni.JniType.voidType,
      [featureId]).check();

  static final _id_performPanelShortcut = jniAccessors.getMethodIDOf(
      _classRef, "performPanelShortcut", "(IILandroid/view/KeyEvent;I)Z");

  /// from: public abstract boolean performPanelShortcut(int featureId, int keyCode, android.view.KeyEvent event, int flags)
  bool performPanelShortcut(
          int featureId, int keyCode, keyevent_.KeyEvent event, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_performPanelShortcut,
          jni.JniType.booleanType,
          [featureId, keyCode, event.reference, flags]).boolean;

  static final _id_performPanelIdentifierAction = jniAccessors.getMethodIDOf(
      _classRef, "performPanelIdentifierAction", "(III)Z");

  /// from: public abstract boolean performPanelIdentifierAction(int featureId, int id, int flags)
  bool performPanelIdentifierAction(int featureId, int id, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_performPanelIdentifierAction,
          jni.JniType.booleanType,
          [featureId, id, flags]).boolean;

  static final _id_closeAllPanels =
      jniAccessors.getMethodIDOf(_classRef, "closeAllPanels", "()V");

  /// from: public abstract void closeAllPanels()
  void closeAllPanels() => jniAccessors.callMethodWithArgs(
      reference, _id_closeAllPanels, jni.JniType.voidType, []).check();

  static final _id_performContextMenuIdentifierAction = jniAccessors
      .getMethodIDOf(_classRef, "performContextMenuIdentifierAction", "(II)Z");

  /// from: public abstract boolean performContextMenuIdentifierAction(int id, int flags)
  bool performContextMenuIdentifierAction(int id, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_performContextMenuIdentifierAction,
          jni.JniType.booleanType,
          [id, flags]).boolean;

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public abstract void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Should be called when the configuration is changed.
  ///@param newConfig The new configuration.
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_setElevation =
      jniAccessors.getMethodIDOf(_classRef, "setElevation", "(F)V");

  /// from: public void setElevation(float elevation)
  ///
  /// Sets the window elevation.
  ///
  /// Changes to this property take effect immediately and will cause the
  /// window surface to be recreated. This is an expensive operation and as a
  /// result, this property should not be animated.
  ///@param elevation The window elevation.
  ///@see View\#setElevation(float)
  ///@see android.R.styleable\#Window_windowElevation
  void setElevation(double elevation) => jniAccessors.callMethodWithArgs(
      reference, _id_setElevation, jni.JniType.voidType, [elevation]).check();

  static final _id_setClipToOutline =
      jniAccessors.getMethodIDOf(_classRef, "setClipToOutline", "(Z)V");

  /// from: public void setClipToOutline(boolean clipToOutline)
  ///
  /// Sets whether window content should be clipped to the outline of the
  /// window background.
  ///@param clipToOutline Whether window content should be clipped to the
  ///                      outline of the window background.
  ///@see View\#setClipToOutline(boolean)
  ///@see android.R.styleable\#Window_windowClipToOutline
  void setClipToOutline(bool clipToOutline) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClipToOutline,
      jni.JniType.voidType,
      [clipToOutline]).check();

  static final _id_setBackgroundDrawableResource = jniAccessors.getMethodIDOf(
      _classRef, "setBackgroundDrawableResource", "(I)V");

  /// from: public void setBackgroundDrawableResource(int resId)
  ///
  /// Change the background of this window to a Drawable resource. Setting the
  /// background to null will make the window be opaque. To make the window
  /// transparent, you can use an empty drawable (for instance a ColorDrawable
  /// with the color 0 or the system drawable android:drawable/empty.)
  ///@param resId The resource identifier of a drawable resource which will
  ///              be installed as the new background.
  void setBackgroundDrawableResource(int resId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setBackgroundDrawableResource,
          jni.JniType.voidType,
          [resId]).check();

  static final _id_setBackgroundDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setBackgroundDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public abstract void setBackgroundDrawable(android.graphics.drawable.Drawable drawable)
  ///
  /// Change the background of this window to a custom Drawable. Setting the
  /// background to null will make the window be opaque. To make the window
  /// transparent, you can use an empty drawable (for instance a ColorDrawable
  /// with the color 0 or the system drawable android:drawable/empty.)
  ///@param drawable The new Drawable to use for this window's background.
  void setBackgroundDrawable(drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBackgroundDrawable,
          jni.JniType.voidType, [drawable.reference]).check();

  static final _id_setFeatureDrawableResource = jniAccessors.getMethodIDOf(
      _classRef, "setFeatureDrawableResource", "(II)V");

  /// from: public abstract void setFeatureDrawableResource(int featureId, int resId)
  ///
  /// Set the value for a drawable feature of this window, from a resource
  /// identifier.  You must have called requestFeature(featureId) before
  /// calling this function.
  ///@see android.content.res.Resources\#getDrawable(int)
  ///@param featureId The desired drawable feature to change, defined as a
  /// constant by Window.
  ///@param resId Resource identifier of the desired image.
  void setFeatureDrawableResource(int featureId, int resId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableResource,
          jni.JniType.voidType, [featureId, resId]).check();

  static final _id_setFeatureDrawableUri = jniAccessors.getMethodIDOf(
      _classRef, "setFeatureDrawableUri", "(ILandroid/net/Uri;)V");

  /// from: public abstract void setFeatureDrawableUri(int featureId, android.net.Uri uri)
  ///
  /// Set the value for a drawable feature of this window, from a URI. You
  /// must have called requestFeature(featureId) before calling this
  /// function.
  ///
  /// The only URI currently supported is "content:", specifying an image
  /// in a content provider.
  ///@see android.widget.ImageView\#setImageURI
  ///@param featureId The desired drawable feature to change. Features are
  /// constants defined by Window.
  ///@param uri The desired URI.
  void setFeatureDrawableUri(int featureId, uri_.Uri uri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableUri,
          jni.JniType.voidType, [featureId, uri.reference]).check();

  static final _id_setFeatureDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setFeatureDrawable", "(ILandroid/graphics/drawable/Drawable;)V");

  /// from: public abstract void setFeatureDrawable(int featureId, android.graphics.drawable.Drawable drawable)
  ///
  /// Set an explicit Drawable value for feature of this window. You must
  /// have called requestFeature(featureId) before calling this function.
  ///@param featureId The desired drawable feature to change. Features are
  ///                  constants defined by Window.
  ///@param drawable A Drawable object to display.
  void setFeatureDrawable(int featureId, drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawable,
          jni.JniType.voidType, [featureId, drawable.reference]).check();

  static final _id_setFeatureDrawableAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setFeatureDrawableAlpha", "(II)V");

  /// from: public abstract void setFeatureDrawableAlpha(int featureId, int alpha)
  ///
  /// Set a custom alpha value for the given drawable feature, controlling how
  /// much the background is visible through it.
  ///@param featureId The desired drawable feature to change. Features are
  ///                  constants defined by Window.
  ///@param alpha The alpha amount, 0 is completely transparent and 255 is
  ///              completely opaque.
  void setFeatureDrawableAlpha(int featureId, int alpha) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableAlpha,
          jni.JniType.voidType, [featureId, alpha]).check();

  static final _id_setFeatureInt =
      jniAccessors.getMethodIDOf(_classRef, "setFeatureInt", "(II)V");

  /// from: public abstract void setFeatureInt(int featureId, int value)
  ///
  /// Set the integer value for a feature. The range of the value depends on
  /// the feature being set. For \#FEATURE_PROGRESS, it should go from
  /// 0 to 10000. At 10000 the progress is complete and the indicator hidden.
  ///@param featureId The desired feature to change. Features are constants
  ///                  defined by Window.
  ///@param value The value for the feature. The interpretation of this
  ///              value is feature-specific.
  void setFeatureInt(int featureId, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureInt,
          jni.JniType.voidType, [featureId, value]).check();

  static final _id_takeKeyEvents =
      jniAccessors.getMethodIDOf(_classRef, "takeKeyEvents", "(Z)V");

  /// from: public abstract void takeKeyEvents(boolean get)
  ///
  /// Request that key events come to this activity. Use this if your
  /// activity has no views with focus, but the activity still wants
  /// a chance to process key events.
  void takeKeyEvents(bool get0) => jniAccessors.callMethodWithArgs(
      reference, _id_takeKeyEvents, jni.JniType.voidType, [get0]).check();

  static final _id_superDispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "superDispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public abstract boolean superDispatchKeyEvent(android.view.KeyEvent event)
  ///
  /// Used by custom windows, such as Dialog, to pass the key press event
  /// further down the view hierarchy. Application developers should
  /// not need to implement or call this.
  bool superDispatchKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_superDispatchKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_superDispatchKeyShortcutEvent = jniAccessors.getMethodIDOf(
      _classRef, "superDispatchKeyShortcutEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public abstract boolean superDispatchKeyShortcutEvent(android.view.KeyEvent event)
  ///
  /// Used by custom windows, such as Dialog, to pass the key shortcut press event
  /// further down the view hierarchy. Application developers should
  /// not need to implement or call this.
  bool superDispatchKeyShortcutEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_superDispatchKeyShortcutEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_superDispatchTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "superDispatchTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean superDispatchTouchEvent(android.view.MotionEvent event)
  ///
  /// Used by custom windows, such as Dialog, to pass the touch screen event
  /// further down the view hierarchy. Application developers should
  /// not need to implement or call this.
  bool superDispatchTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_superDispatchTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_superDispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "superDispatchTrackballEvent",
      "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean superDispatchTrackballEvent(android.view.MotionEvent event)
  ///
  /// Used by custom windows, such as Dialog, to pass the trackball event
  /// further down the view hierarchy. Application developers should
  /// not need to implement or call this.
  bool superDispatchTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_superDispatchTrackballEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_superDispatchGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "superDispatchGenericMotionEvent",
      "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean superDispatchGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Used by custom windows, such as Dialog, to pass the generic motion event
  /// further down the view hierarchy. Application developers should
  /// not need to implement or call this.
  bool superDispatchGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_superDispatchGenericMotionEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_getDecorView = jniAccessors.getMethodIDOf(
      _classRef, "getDecorView", "()Landroid/view/View;");

  /// from: public abstract android.view.View getDecorView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the top-level window decor view (containing the standard
  /// window frame/decorations and the client's content inside of that), which
  /// can be added as a window to the window manager.
  ///
  /// _Note that calling this function for the first time "locks in"
  /// various window characteristics as described in
  /// \#setContentView(View, android.view.ViewGroup.LayoutParams)._
  ///
  ///@return Returns the top-level window decor view.
  view_.View getDecorView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDecorView, jni.JniType.objectType, []).object);

  static final _id_peekDecorView = jniAccessors.getMethodIDOf(
      _classRef, "peekDecorView", "()Landroid/view/View;");

  /// from: public abstract android.view.View peekDecorView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current decor view, but only if it has already been created;
  /// otherwise returns null.
  ///@return Returns the top-level window decor or null.
  ///@see \#getDecorView
  view_.View peekDecorView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_peekDecorView, jni.JniType.objectType, []).object);

  static final _id_saveHierarchyState = jniAccessors.getMethodIDOf(
      _classRef, "saveHierarchyState", "()Landroid/os/Bundle;");

  /// from: public abstract android.os.Bundle saveHierarchyState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  bundle_.Bundle saveHierarchyState() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_saveHierarchyState, jni.JniType.objectType, []).object);

  static final _id_restoreHierarchyState = jniAccessors.getMethodIDOf(
      _classRef, "restoreHierarchyState", "(Landroid/os/Bundle;)V");

  /// from: public abstract void restoreHierarchyState(android.os.Bundle savedInstanceState)
  void restoreHierarchyState(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_restoreHierarchyState,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onActive =
      jniAccessors.getMethodIDOf(_classRef, "onActive", "()V");

  /// from: protected abstract void onActive()
  void onActive() => jniAccessors.callMethodWithArgs(
      reference, _id_onActive, jni.JniType.voidType, []).check();

  static final _id_getFeatures =
      jniAccessors.getMethodIDOf(_classRef, "getFeatures", "()I");

  /// from: protected final int getFeatures()
  ///
  /// Return the feature bits that are enabled.  This is the set of features
  /// that were given to requestFeature(), and are being handled by this
  /// Window itself or its container.  That is, it is the set of
  /// requested features that you can actually use.
  ///
  /// To do: add a public version of this API that allows you to check for
  /// features by their feature ID.
  ///@return int The feature bits.
  int getFeatures() => jniAccessors.callMethodWithArgs(
      reference, _id_getFeatures, jni.JniType.intType, []).integer;

  static final _id_getDefaultFeatures = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDefaultFeatures", "(Landroid/content/Context;)I");

  /// from: static public int getDefaultFeatures(android.content.Context context)
  ///
  /// Return the feature bits set by default on a window.
  ///@param context The context used to access resources
  static int getDefaultFeatures(context_.Context context) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getDefaultFeatures,
          jni.JniType.intType, [context.reference]).integer;

  static final _id_hasFeature =
      jniAccessors.getMethodIDOf(_classRef, "hasFeature", "(I)Z");

  /// from: public boolean hasFeature(int feature)
  ///
  /// Query for the availability of a certain feature.
  ///@param feature The feature ID to check
  ///@return true if the feature is enabled, false otherwise.
  bool hasFeature(int feature) => jniAccessors.callMethodWithArgs(
      reference, _id_hasFeature, jni.JniType.booleanType, [feature]).boolean;

  static final _id_getLocalFeatures =
      jniAccessors.getMethodIDOf(_classRef, "getLocalFeatures", "()I");

  /// from: protected final int getLocalFeatures()
  ///
  /// Return the feature bits that are being implemented by this Window.
  /// This is the set of features that were given to requestFeature(), and are
  /// being handled by only this Window itself, not by its containers.
  ///@return int The feature bits.
  int getLocalFeatures() => jniAccessors.callMethodWithArgs(
      reference, _id_getLocalFeatures, jni.JniType.intType, []).integer;

  static final _id_setDefaultWindowFormat =
      jniAccessors.getMethodIDOf(_classRef, "setDefaultWindowFormat", "(I)V");

  /// from: protected void setDefaultWindowFormat(int format)
  ///
  /// Set the default format of window, as per the PixelFormat types.  This
  /// is the format that will be used unless the client specifies in explicit
  /// format with setFormat();
  ///@param format The new window format (see PixelFormat).
  ///@see \#setFormat
  ///@see PixelFormat
  void setDefaultWindowFormat(int format) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDefaultWindowFormat,
      jni.JniType.voidType,
      [format]).check();

  static final _id_setChildDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setChildDrawable", "(ILandroid/graphics/drawable/Drawable;)V");

  /// from: public abstract void setChildDrawable(int featureId, android.graphics.drawable.Drawable drawable)
  void setChildDrawable(int featureId, drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setChildDrawable,
          jni.JniType.voidType, [featureId, drawable.reference]).check();

  static final _id_setChildInt =
      jniAccessors.getMethodIDOf(_classRef, "setChildInt", "(II)V");

  /// from: public abstract void setChildInt(int featureId, int value)
  void setChildInt(int featureId, int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setChildInt,
      jni.JniType.voidType,
      [featureId, value]).check();

  static final _id_isShortcutKey = jniAccessors.getMethodIDOf(
      _classRef, "isShortcutKey", "(ILandroid/view/KeyEvent;)Z");

  /// from: public abstract boolean isShortcutKey(int keyCode, android.view.KeyEvent event)
  ///
  /// Is a keypress one of the defined shortcut keys for this window.
  ///@param keyCode the key code from android.view.KeyEvent to check.
  ///@param event the android.view.KeyEvent to use to help check.
  bool isShortcutKey(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_isShortcutKey,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_setVolumeControlStream =
      jniAccessors.getMethodIDOf(_classRef, "setVolumeControlStream", "(I)V");

  /// from: public abstract void setVolumeControlStream(int streamType)
  ///
  /// @see android.app.Activity\#setVolumeControlStream(int)
  void setVolumeControlStream(int streamType) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVolumeControlStream,
          jni.JniType.voidType, [streamType]).check();

  static final _id_getVolumeControlStream =
      jniAccessors.getMethodIDOf(_classRef, "getVolumeControlStream", "()I");

  /// from: public abstract int getVolumeControlStream()
  ///
  /// @see android.app.Activity\#getVolumeControlStream()
  int getVolumeControlStream() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolumeControlStream, jni.JniType.intType, []).integer;

  static final _id_setMediaController = jniAccessors.getMethodIDOf(_classRef,
      "setMediaController", "(Landroid/media/session/MediaController;)V");

  /// from: public void setMediaController(android.media.session.MediaController controller)
  ///
  /// Sets a MediaController to send media keys and volume changes to.
  /// If set, this should be preferred for all media keys and volume requests
  /// sent to this window.
  ///@param controller The controller for the session which should receive
  ///            media keys and volume changes.
  ///@see android.app.Activity\#setMediaController(android.media.session.MediaController)
  void setMediaController(mediacontroller_.MediaController controller) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMediaController,
          jni.JniType.voidType, [controller.reference]).check();

  static final _id_getMediaController = jniAccessors.getMethodIDOf(_classRef,
      "getMediaController", "()Landroid/media/session/MediaController;");

  /// from: public android.media.session.MediaController getMediaController()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the MediaController that was previously set.
  ///@return The controller which should receive events.
  ///@see \#setMediaController(android.media.session.MediaController)
  ///@see android.app.Activity\#getMediaController()
  mediacontroller_.MediaController getMediaController() =>
      mediacontroller_.MediaController.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getMediaController,
          jni.JniType.objectType, []).object);

  static final _id_setUiOptions =
      jniAccessors.getMethodIDOf(_classRef, "setUiOptions", "(I)V");

  /// from: public void setUiOptions(int uiOptions)
  ///
  /// Set extra options that will influence the UI for this window.
  ///@param uiOptions Flags specifying extra options for this window.
  void setUiOptions(int uiOptions) => jniAccessors.callMethodWithArgs(
      reference, _id_setUiOptions, jni.JniType.voidType, [uiOptions]).check();

  static final _id_setUiOptions1 =
      jniAccessors.getMethodIDOf(_classRef, "setUiOptions", "(II)V");

  /// from: public void setUiOptions(int uiOptions, int mask)
  ///
  /// Set extra options that will influence the UI for this window.
  /// Only the bits filtered by mask will be modified.
  ///@param uiOptions Flags specifying extra options for this window.
  ///@param mask Flags specifying which options should be modified. Others will remain unchanged.
  void setUiOptions1(int uiOptions, int mask) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUiOptions1,
          jni.JniType.voidType, [uiOptions, mask]).check();

  static final _id_setIcon =
      jniAccessors.getMethodIDOf(_classRef, "setIcon", "(I)V");

  /// from: public void setIcon(int resId)
  ///
  /// Set the primary icon for this window.
  ///@param resId resource ID of a drawable to set
  void setIcon(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setIcon, jni.JniType.voidType, [resId]).check();

  static final _id_setLogo =
      jniAccessors.getMethodIDOf(_classRef, "setLogo", "(I)V");

  /// from: public void setLogo(int resId)
  ///
  /// Set the logo for this window. A logo is often shown in place of an
  /// \#setIcon(int) icon but is generally wider and communicates window title information
  /// as well.
  ///@param resId resource ID of a drawable to set
  void setLogo(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setLogo, jni.JniType.voidType, [resId]).check();

  static final _id_setLocalFocus =
      jniAccessors.getMethodIDOf(_classRef, "setLocalFocus", "(ZZ)V");

  /// from: public void setLocalFocus(boolean hasFocus, boolean inTouchMode)
  ///
  /// Set focus locally. The window should have the
  /// WindowManager.LayoutParams\#FLAG_LOCAL_FOCUS_MODE flag set already.
  ///@param hasFocus Whether this window has focus or not.
  ///@param inTouchMode Whether this window is in touch mode or not.
  void setLocalFocus(bool hasFocus, bool inTouchMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLocalFocus,
          jni.JniType.voidType, [hasFocus, inTouchMode]).check();

  static final _id_injectInputEvent = jniAccessors.getMethodIDOf(
      _classRef, "injectInputEvent", "(Landroid/view/InputEvent;)V");

  /// from: public void injectInputEvent(android.view.InputEvent event)
  ///
  /// Inject an event to window locally.
  ///@param event A key or touch event to inject to this window.
  void injectInputEvent(inputevent_.InputEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_injectInputEvent,
          jni.JniType.voidType, [event.reference]).check();

  static final _id_getTransitionManager = jniAccessors.getMethodIDOf(_classRef,
      "getTransitionManager", "()Landroid/transition/TransitionManager;");

  /// from: public android.transition.TransitionManager getTransitionManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the TransitionManager responsible for  for default transitions
  /// in this window. Requires \#FEATURE_CONTENT_TRANSITIONS.
  ///
  /// This method will return non-null after content has been initialized (e.g. by using
  /// \#setContentView) if \#FEATURE_CONTENT_TRANSITIONS has been granted.
  ///
  ///@return This window's content TransitionManager or null if none is set.
  ///@attr ref android.R.styleable\#Window_windowContentTransitionManager
  transitionmanager_.TransitionManager getTransitionManager() =>
      transitionmanager_.TransitionManager.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getTransitionManager,
              jni.JniType.objectType, []).object);

  static final _id_setTransitionManager = jniAccessors.getMethodIDOf(_classRef,
      "setTransitionManager", "(Landroid/transition/TransitionManager;)V");

  /// from: public void setTransitionManager(android.transition.TransitionManager tm)
  ///
  /// Set the TransitionManager to use for default transitions in this window.
  /// Requires \#FEATURE_CONTENT_TRANSITIONS.
  ///@param tm The TransitionManager to use for scene changes.
  ///@attr ref android.R.styleable\#Window_windowContentTransitionManager
  void setTransitionManager(transitionmanager_.TransitionManager tm) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTransitionManager,
          jni.JniType.voidType, [tm.reference]).check();

  static final _id_getContentScene = jniAccessors.getMethodIDOf(
      _classRef, "getContentScene", "()Landroid/transition/Scene;");

  /// from: public android.transition.Scene getContentScene()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Scene representing this window's current content.
  /// Requires \#FEATURE_CONTENT_TRANSITIONS.
  ///
  /// This method will return null if the current content is not represented by a Scene.
  ///
  ///@return Current Scene being shown or null
  scene_.Scene getContentScene() =>
      scene_.Scene.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContentScene, jni.JniType.objectType, []).object);

  static final _id_setEnterTransition = jniAccessors.getMethodIDOf(
      _classRef, "setEnterTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setEnterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views into the initial scene. The entering
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#INVISIBLE to View\#VISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected.
  ///@param transition The Transition to use to move Views into the initial Scene.
  ///@attr ref android.R.styleable\#Window_windowEnterTransition
  void setEnterTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEnterTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_setReturnTransition = jniAccessors.getMethodIDOf(
      _classRef, "setReturnTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setReturnTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views out of the scene when the Window is
  /// preparing to close, for example after a call to
  /// android.app.Activity\#finishAfterTransition(). The exiting
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#VISIBLE to View\#INVISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected. If nothing is set, the default will be to
  /// use the same value as set in \#setEnterTransition(android.transition.Transition).
  ///@param transition The Transition to use to move Views out of the Scene when the Window
  ///                   is preparing to close.
  ///@attr ref android.R.styleable\#Window_windowReturnTransition
  void setReturnTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setReturnTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_setExitTransition = jniAccessors.getMethodIDOf(
      _classRef, "setExitTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setExitTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views out of the scene when starting a
  /// new Activity. The exiting Views will be those that are regular Views or ViewGroups that
  /// have ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as exiting is governed by changing visibility
  /// from View\#VISIBLE to View\#INVISIBLE. If transition is null, the views will
  /// remain unaffected. Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param transition The Transition to use to move Views out of the scene when calling a
  ///                   new Activity.
  ///@attr ref android.R.styleable\#Window_windowExitTransition
  void setExitTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setExitTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_setReenterTransition = jniAccessors.getMethodIDOf(
      _classRef, "setReenterTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setReenterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views in to the scene when returning from
  /// a previously-started Activity. The entering Views will be those that are regular Views
  /// or ViewGroups that have ViewGroup\#isTransitionGroup return true. Typical Transitions
  /// will extend android.transition.Visibility as exiting is governed by changing
  /// visibility from View\#VISIBLE to View\#INVISIBLE. If transition is null,
  /// the views will remain unaffected. If nothing is set, the default will be to use the same
  /// transition as \#setExitTransition(android.transition.Transition).
  /// Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param transition The Transition to use to move Views into the scene when reentering from a
  ///                   previously-started Activity.
  ///@attr ref android.R.styleable\#Window_windowReenterTransition
  void setReenterTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setReenterTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_getEnterTransition = jniAccessors.getMethodIDOf(
      _classRef, "getEnterTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getEnterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the transition used to move Views into the initial scene. The entering
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#INVISIBLE to View\#VISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected.  Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@return the Transition to use to move Views into the initial Scene.
  ///@attr ref android.R.styleable\#Window_windowEnterTransition
  transition_.Transition getEnterTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getEnterTransition, jni.JniType.objectType, []).object);

  static final _id_getReturnTransition = jniAccessors.getMethodIDOf(
      _classRef, "getReturnTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getReturnTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views out of the scene when the Window is
  /// preparing to close, for example after a call to
  /// android.app.Activity\#finishAfterTransition(). The exiting
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#VISIBLE to View\#INVISIBLE.
  ///@return The Transition to use to move Views out of the Scene when the Window
  ///         is preparing to close.
  ///@attr ref android.R.styleable\#Window_windowReturnTransition
  transition_.Transition getReturnTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getReturnTransition, jni.JniType.objectType, []).object);

  static final _id_getExitTransition = jniAccessors.getMethodIDOf(
      _classRef, "getExitTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getExitTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views out of the scene when starting a
  /// new Activity. The exiting Views will be those that are regular Views or ViewGroups that
  /// have ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as exiting is governed by changing visibility
  /// from View\#VISIBLE to View\#INVISIBLE. If transition is null, the views will
  /// remain unaffected. Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@return the Transition to use to move Views out of the scene when calling a
  /// new Activity.
  ///@attr ref android.R.styleable\#Window_windowExitTransition
  transition_.Transition getExitTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExitTransition, jni.JniType.objectType, []).object);

  static final _id_getReenterTransition = jniAccessors.getMethodIDOf(
      _classRef, "getReenterTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getReenterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views in to the scene when returning from
  /// a previously-started Activity. The entering Views will be those that are regular Views
  /// or ViewGroups that have ViewGroup\#isTransitionGroup return true. Typical Transitions
  /// will extend android.transition.Visibility as exiting is governed by changing
  /// visibility from View\#VISIBLE to View\#INVISIBLE.
  /// Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@return The Transition to use to move Views into the scene when reentering from a
  ///         previously-started Activity.
  ///@attr ref android.R.styleable\#Window_windowReenterTransition
  transition_.Transition getReenterTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getReenterTransition, jni.JniType.objectType, []).object);

  static final _id_setSharedElementEnterTransition = jniAccessors.getMethodIDOf(
      _classRef,
      "setSharedElementEnterTransition",
      "(Landroid/transition/Transition;)V");

  /// from: public void setSharedElementEnterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used for shared elements transferred into the content
  /// Scene. Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  /// Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param transition The Transition to use for shared elements transferred into the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Window_windowSharedElementEnterTransition
  void setSharedElementEnterTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSharedElementEnterTransition,
          jni.JniType.voidType,
          [transition.reference]).check();

  static final _id_setSharedElementReturnTransition =
      jniAccessors.getMethodIDOf(_classRef, "setSharedElementReturnTransition",
          "(Landroid/transition/Transition;)V");

  /// from: public void setSharedElementReturnTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used for shared elements transferred back to a
  /// calling Activity. Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  /// If no value is set, the default will be to use the same value as
  /// \#setSharedElementEnterTransition(android.transition.Transition).
  /// Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param transition The Transition to use for shared elements transferred out of the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Window_windowSharedElementReturnTransition
  void setSharedElementReturnTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSharedElementReturnTransition,
          jni.JniType.voidType,
          [transition.reference]).check();

  static final _id_getSharedElementEnterTransition = jniAccessors.getMethodIDOf(
      _classRef,
      "getSharedElementEnterTransition",
      "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getSharedElementEnterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used for shared elements transferred into the content
  /// Scene. Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@return Transition to use for sharend elements transferred into the content Scene.
  ///@attr ref android.R.styleable\#Window_windowSharedElementEnterTransition
  transition_.Transition getSharedElementEnterTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSharedElementEnterTransition,
          jni.JniType.objectType, []).object);

  static final _id_getSharedElementReturnTransition =
      jniAccessors.getMethodIDOf(_classRef, "getSharedElementReturnTransition",
          "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getSharedElementReturnTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used for shared elements transferred back to a
  /// calling Activity. Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@return Transition to use for sharend elements transferred into the content Scene.
  ///@attr ref android.R.styleable\#Window_windowSharedElementReturnTransition
  transition_.Transition getSharedElementReturnTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSharedElementReturnTransition,
          jni.JniType.objectType, []).object);

  static final _id_setSharedElementExitTransition = jniAccessors.getMethodIDOf(
      _classRef,
      "setSharedElementExitTransition",
      "(Landroid/transition/Transition;)V");

  /// from: public void setSharedElementExitTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used for shared elements after starting a new Activity
  /// before the shared elements are transferred to the called Activity. If the shared elements
  /// must animate during the exit transition, this Transition should be used. Upon completion,
  /// the shared elements may be transferred to the started Activity.
  /// Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param transition The Transition to use for shared elements in the launching Window
  ///                   prior to transferring to the launched Activity's Window.
  ///@attr ref android.R.styleable\#Window_windowSharedElementExitTransition
  void setSharedElementExitTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSharedElementExitTransition,
          jni.JniType.voidType,
          [transition.reference]).check();

  static final _id_setSharedElementReenterTransition =
      jniAccessors.getMethodIDOf(_classRef, "setSharedElementReenterTransition",
          "(Landroid/transition/Transition;)V");

  /// from: public void setSharedElementReenterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used for shared elements reentering from a started
  /// Activity after it has returned the shared element to it start location. If no value
  /// is set, this will default to
  /// \#setSharedElementExitTransition(android.transition.Transition).
  /// Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param transition The Transition to use for shared elements in the launching Window
  ///                   after the shared element has returned to the Window.
  ///@attr ref android.R.styleable\#Window_windowSharedElementReenterTransition
  void setSharedElementReenterTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSharedElementReenterTransition,
          jni.JniType.voidType,
          [transition.reference]).check();

  static final _id_getSharedElementExitTransition = jniAccessors.getMethodIDOf(
      _classRef,
      "getSharedElementExitTransition",
      "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getSharedElementExitTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition to use for shared elements in the launching Window prior
  /// to transferring to the launched Activity's Window.
  /// Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@return the Transition to use for shared elements in the launching Window prior
  /// to transferring to the launched Activity's Window.
  ///@attr ref android.R.styleable\#Window_windowSharedElementExitTransition
  transition_.Transition getSharedElementExitTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSharedElementExitTransition,
          jni.JniType.objectType, []).object);

  static final _id_getSharedElementReenterTransition =
      jniAccessors.getMethodIDOf(_classRef, "getSharedElementReenterTransition",
          "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getSharedElementReenterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used for shared elements reentering from a started
  /// Activity after it has returned the shared element to it start location.
  /// Requires \#FEATURE_ACTIVITY_TRANSITIONS.
  ///@return the Transition that will be used for shared elements reentering from a started
  /// Activity after it has returned the shared element to it start location.
  ///@attr ref android.R.styleable\#Window_windowSharedElementReenterTransition
  transition_.Transition getSharedElementReenterTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSharedElementReenterTransition,
          jni.JniType.objectType, []).object);

  static final _id_setAllowEnterTransitionOverlap = jniAccessors.getMethodIDOf(
      _classRef, "setAllowEnterTransitionOverlap", "(Z)V");

  /// from: public void setAllowEnterTransitionOverlap(boolean allow)
  ///
  /// Controls how the transition set in
  /// \#setEnterTransition(android.transition.Transition) overlaps with the exit
  /// transition of the calling Activity. When true, the transition will start as soon as possible.
  /// When false, the transition will wait until the remote exiting transition completes before
  /// starting. The default value is true.
  ///@param allow true to start the enter transition when possible or false to
  ///              wait until the exiting transition completes.
  ///@attr ref android.R.styleable\#Window_windowAllowEnterTransitionOverlap
  void setAllowEnterTransitionOverlap(bool allow) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAllowEnterTransitionOverlap,
          jni.JniType.voidType,
          [allow]).check();

  static final _id_getAllowEnterTransitionOverlap = jniAccessors.getMethodIDOf(
      _classRef, "getAllowEnterTransitionOverlap", "()Z");

  /// from: public boolean getAllowEnterTransitionOverlap()
  ///
  /// Returns how the transition set in
  /// \#setEnterTransition(android.transition.Transition) overlaps with the exit
  /// transition of the calling Activity. When true, the transition will start as soon as possible.
  /// When false, the transition will wait until the remote exiting transition completes before
  /// starting. The default value is true.
  ///@return true when the enter transition should start as soon as possible or false to
  /// when it should wait until the exiting transition completes.
  ///@attr ref android.R.styleable\#Window_windowAllowEnterTransitionOverlap
  bool getAllowEnterTransitionOverlap() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAllowEnterTransitionOverlap,
      jni.JniType.booleanType, []).boolean;

  static final _id_setAllowReturnTransitionOverlap = jniAccessors.getMethodIDOf(
      _classRef, "setAllowReturnTransitionOverlap", "(Z)V");

  /// from: public void setAllowReturnTransitionOverlap(boolean allow)
  ///
  /// Controls how the transition set in
  /// \#setExitTransition(android.transition.Transition) overlaps with the exit
  /// transition of the called Activity when reentering after if finishes. When true,
  /// the transition will start as soon as possible. When false, the transition will wait
  /// until the called Activity's exiting transition completes before starting.
  /// The default value is true.
  ///@param allow true to start the transition when possible or false to wait until the
  ///              called Activity's exiting transition completes.
  ///@attr ref android.R.styleable\#Window_windowAllowReturnTransitionOverlap
  void setAllowReturnTransitionOverlap(bool allow) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAllowReturnTransitionOverlap,
          jni.JniType.voidType,
          [allow]).check();

  static final _id_getAllowReturnTransitionOverlap = jniAccessors.getMethodIDOf(
      _classRef, "getAllowReturnTransitionOverlap", "()Z");

  /// from: public boolean getAllowReturnTransitionOverlap()
  ///
  /// Returns how the transition set in
  /// \#setExitTransition(android.transition.Transition) overlaps with the exit
  /// transition of the called Activity when reentering after if finishes. When true,
  /// the transition will start as soon as possible. When false, the transition will wait
  /// until the called Activity's exiting transition completes before starting.
  /// The default value is true.
  ///@return true when the transition should start when possible or false when it should wait
  /// until the called Activity's exiting transition completes.
  ///@attr ref android.R.styleable\#Window_windowAllowReturnTransitionOverlap
  bool getAllowReturnTransitionOverlap() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAllowReturnTransitionOverlap,
      jni.JniType.booleanType, []).boolean;

  static final _id_getTransitionBackgroundFadeDuration = jniAccessors
      .getMethodIDOf(_classRef, "getTransitionBackgroundFadeDuration", "()J");

  /// from: public long getTransitionBackgroundFadeDuration()
  ///
  /// Returns the duration, in milliseconds, of the window background fade
  /// when transitioning into or away from an Activity when called with an Activity Transition.
  /// When executing the enter transition, the background starts transparent
  /// and fades in. This requires \#FEATURE_ACTIVITY_TRANSITIONS. The default is
  /// 300 milliseconds.
  ///
  ///@return The duration of the window background fade to opaque during enter transition.
  ///@see \#getEnterTransition()
  ///@attr ref android.R.styleable\#Window_windowTransitionBackgroundFadeDuration
  int getTransitionBackgroundFadeDuration() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getTransitionBackgroundFadeDuration,
      jni.JniType.longType, []).long;

  static final _id_setTransitionBackgroundFadeDuration = jniAccessors
      .getMethodIDOf(_classRef, "setTransitionBackgroundFadeDuration", "(J)V");

  /// from: public void setTransitionBackgroundFadeDuration(long fadeDurationMillis)
  ///
  /// Sets the duration, in milliseconds, of the window background fade
  /// when transitioning into or away from an Activity when called with an Activity Transition.
  /// When executing the enter transition, the background starts transparent
  /// and fades in. This requires \#FEATURE_ACTIVITY_TRANSITIONS. The default is
  /// 300 milliseconds.
  ///
  ///@param fadeDurationMillis The duration of the window background fade to or from opaque
  ///                           during enter transition.
  ///@see \#setEnterTransition(android.transition.Transition)
  ///@attr ref android.R.styleable\#Window_windowTransitionBackgroundFadeDuration
  void setTransitionBackgroundFadeDuration(int fadeDurationMillis) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTransitionBackgroundFadeDuration,
          jni.JniType.voidType,
          [fadeDurationMillis]).check();

  static final _id_getSharedElementsUseOverlay = jniAccessors.getMethodIDOf(
      _classRef, "getSharedElementsUseOverlay", "()Z");

  /// from: public boolean getSharedElementsUseOverlay()
  ///
  /// Returns <code>true</code> when shared elements should use an Overlay during
  /// shared element transitions or <code>false</code> when they should animate as
  /// part of the normal View hierarchy. The default value is true.
  ///@return <code>true</code> when shared elements should use an Overlay during
  /// shared element transitions or <code>false</code> when they should animate as
  /// part of the normal View hierarchy.
  ///@attr ref android.R.styleable\#Window_windowSharedElementsUseOverlay
  bool getSharedElementsUseOverlay() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getSharedElementsUseOverlay,
      jni.JniType.booleanType, []).boolean;

  static final _id_setSharedElementsUseOverlay = jniAccessors.getMethodIDOf(
      _classRef, "setSharedElementsUseOverlay", "(Z)V");

  /// from: public void setSharedElementsUseOverlay(boolean sharedElementsUseOverlay)
  ///
  /// Sets whether or not shared elements should use an Overlay during shared element transitions.
  /// The default value is true.
  ///@param sharedElementsUseOverlay <code>true</code> indicates that shared elements should
  ///                                 be transitioned with an Overlay or <code>false</code>
  ///                                 to transition within the normal View hierarchy.
  ///@attr ref android.R.styleable\#Window_windowSharedElementsUseOverlay
  void setSharedElementsUseOverlay(bool sharedElementsUseOverlay) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSharedElementsUseOverlay,
          jni.JniType.voidType,
          [sharedElementsUseOverlay]).check();

  static final _id_getStatusBarColor =
      jniAccessors.getMethodIDOf(_classRef, "getStatusBarColor", "()I");

  /// from: public abstract int getStatusBarColor()
  ///
  /// @return the color of the status bar.
  int getStatusBarColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getStatusBarColor, jni.JniType.intType, []).integer;

  static final _id_setStatusBarColor =
      jniAccessors.getMethodIDOf(_classRef, "setStatusBarColor", "(I)V");

  /// from: public abstract void setStatusBarColor(int color)
  ///
  /// Sets the color of the status bar to {@code color}.
  ///
  /// For this to take effect,
  /// the window must be drawing the system bar backgrounds with
  /// android.view.WindowManager.LayoutParams\#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS and
  /// android.view.WindowManager.LayoutParams\#FLAG_TRANSLUCENT_STATUS must not be set.
  ///
  /// If {@code color} is not opaque, consider setting
  /// android.view.View\#SYSTEM_UI_FLAG_LAYOUT_STABLE and
  /// android.view.View\#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN.
  ///
  /// The transitionName for the view background will be "android:status:background".
  ///
  ///
  void setStatusBarColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setStatusBarColor, jni.JniType.voidType, [color]).check();

  static final _id_getNavigationBarColor =
      jniAccessors.getMethodIDOf(_classRef, "getNavigationBarColor", "()I");

  /// from: public abstract int getNavigationBarColor()
  ///
  /// @return the color of the navigation bar.
  int getNavigationBarColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getNavigationBarColor, jni.JniType.intType, []).integer;

  static final _id_setNavigationBarColor =
      jniAccessors.getMethodIDOf(_classRef, "setNavigationBarColor", "(I)V");

  /// from: public abstract void setNavigationBarColor(int color)
  ///
  /// Sets the color of the navigation bar to {@param color}.
  ///
  /// For this to take effect,
  /// the window must be drawing the system bar backgrounds with
  /// android.view.WindowManager.LayoutParams\#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS and
  /// android.view.WindowManager.LayoutParams\#FLAG_TRANSLUCENT_NAVIGATION must not be set.
  ///
  /// If {@param color} is not opaque, consider setting
  /// android.view.View\#SYSTEM_UI_FLAG_LAYOUT_STABLE and
  /// android.view.View\#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION.
  ///
  /// The transitionName for the view background will be "android:navigation:background".
  ///
  ///
  ///@attr ref android.R.styleable\#Window_navigationBarColor
  void setNavigationBarColor(int color) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setNavigationBarColor,
      jni.JniType.voidType,
      [color]).check();

  static final _id_setNavigationBarDividerColor = jniAccessors.getMethodIDOf(
      _classRef, "setNavigationBarDividerColor", "(I)V");

  /// from: public void setNavigationBarDividerColor(int dividerColor)
  ///
  /// Shows a thin line of the specified color between the navigation bar and the app
  /// content.
  ///
  /// For this to take effect,
  /// the window must be drawing the system bar backgrounds with
  /// android.view.WindowManager.LayoutParams\#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS and
  /// android.view.WindowManager.LayoutParams\#FLAG_TRANSLUCENT_NAVIGATION must not be set.
  ///@param dividerColor The color of the thin line.
  ///@attr ref android.R.styleable\#Window_navigationBarDividerColor
  void setNavigationBarDividerColor(int dividerColor) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setNavigationBarDividerColor,
          jni.JniType.voidType,
          [dividerColor]).check();

  static final _id_getNavigationBarDividerColor = jniAccessors.getMethodIDOf(
      _classRef, "getNavigationBarDividerColor", "()I");

  /// from: public int getNavigationBarDividerColor()
  ///
  /// Retrieves the color of the navigation bar divider.
  ///@return The color of the navigation bar divider color.
  ///@see \#setNavigationBarColor(int)
  ///@attr ref android.R.styleable\#Window_navigationBarDividerColor
  int getNavigationBarDividerColor() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getNavigationBarDividerColor,
      jni.JniType.intType, []).integer;

  static final _id_setDecorCaptionShade =
      jniAccessors.getMethodIDOf(_classRef, "setDecorCaptionShade", "(I)V");

  /// from: public abstract void setDecorCaptionShade(int decorCaptionShade)
  ///
  /// Set what color should the caption controls be. By default the system will try to determine
  /// the color from the theme. You can overwrite this by using \#DECOR_CAPTION_SHADE_DARK,
  /// \#DECOR_CAPTION_SHADE_LIGHT, or \#DECOR_CAPTION_SHADE_AUTO.
  ///@see \#DECOR_CAPTION_SHADE_DARK
  ///@see \#DECOR_CAPTION_SHADE_LIGHT
  ///@see \#DECOR_CAPTION_SHADE_AUTO
  void setDecorCaptionShade(int decorCaptionShade) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDecorCaptionShade,
          jni.JniType.voidType, [decorCaptionShade]).check();

  static final _id_setResizingCaptionDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "setResizingCaptionDrawable",
      "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public abstract void setResizingCaptionDrawable(android.graphics.drawable.Drawable drawable)
  ///
  /// Set the drawable that is drawn underneath the caption during the resizing.
  ///
  /// During the resizing the caption might not be drawn fast enough to match the new dimensions.
  /// There is a second caption drawn underneath it that will be fast enough. By default the
  /// caption is constructed from the theme. You can provide a drawable, that will be drawn instead
  /// to better match your application.
  void setResizingCaptionDrawable(drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setResizingCaptionDrawable,
          jni.JniType.voidType, [drawable.reference]).check();
}

/// from: android.view.Window$OnRestrictedCaptionAreaChangedListener
///
/// Callback for clients that want to be aware of where caption draws content.
class Window_OnRestrictedCaptionAreaChangedListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/view/Window\$OnRestrictedCaptionAreaChangedListener");
  Window_OnRestrictedCaptionAreaChangedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onRestrictedCaptionAreaChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onRestrictedCaptionAreaChanged",
      "(Landroid/graphics/Rect;)V");

  /// from: public abstract void onRestrictedCaptionAreaChanged(android.graphics.Rect rect)
  ///
  /// Called when the area where caption draws content changes.
  ///@param rect The area where caption content is positioned, relative to the top view.
  void onRestrictedCaptionAreaChanged(rect_.Rect rect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRestrictedCaptionAreaChanged,
          jni.JniType.voidType,
          [rect.reference]).check();
}

/// from: android.view.Window$OnFrameMetricsAvailableListener
///
/// Callback for clients that want frame timing information for each
/// frame rendered by the Window.
class Window_OnFrameMetricsAvailableListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/view/Window\$OnFrameMetricsAvailableListener");
  Window_OnFrameMetricsAvailableListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onFrameMetricsAvailable = jniAccessors.getMethodIDOf(
      _classRef,
      "onFrameMetricsAvailable",
      "(Landroid/view/Window;Landroid/view/FrameMetrics;I)V");

  /// from: public abstract void onFrameMetricsAvailable(android.view.Window window, android.view.FrameMetrics frameMetrics, int dropCountSinceLastInvocation)
  ///
  /// Called when information is available for the previously rendered frame.
  ///
  /// Reports can be dropped if this callback takes too
  /// long to execute, as the report producer cannot wait for the consumer to
  /// complete.
  ///
  /// It is highly recommended that clients copy the passed in FrameMetrics
  /// via FrameMetrics\#FrameMetrics(FrameMetrics) within this method and defer
  /// additional computation or storage to another thread to avoid unnecessarily
  /// dropping reports.
  ///@param window The Window on which the frame was displayed.
  ///@param frameMetrics the available metrics. This object is reused on every call
  /// and thus <strong>this reference is not valid outside the scope of this method</strong>.
  ///@param dropCountSinceLastInvocation the number of reports dropped since the last time
  /// this callback was invoked.
  void onFrameMetricsAvailable(
          Window window,
          framemetrics_.FrameMetrics frameMetrics,
          int dropCountSinceLastInvocation) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onFrameMetricsAvailable, jni.JniType.voidType, [
        window.reference,
        frameMetrics.reference,
        dropCountSinceLastInvocation
      ]).check();
}

/// from: android.view.Window$Callback
///
/// API from a Window back to its caller.  This allows the client to
/// intercept key dispatching, panels and menus, etc.
class Window_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/Window\$Callback");
  Window_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_dispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public abstract boolean dispatchKeyEvent(android.view.KeyEvent event)
  ///
  /// Called to process key events.  At the very least your
  /// implementation must call
  /// android.view.Window\#superDispatchKeyEvent to do the
  /// standard key processing.
  ///@param event The key event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchKeyShortcutEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyShortcutEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public abstract boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  ///
  /// Called to process a key shortcut event.
  /// At the very least your implementation must call
  /// android.view.Window\#superDispatchKeyShortcutEvent to do the
  /// standard key shortcut processing.
  ///@param event The key shortcut event.
  ///@return True if this event was consumed.
  bool dispatchKeyShortcutEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyShortcutEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean dispatchTouchEvent(android.view.MotionEvent event)
  ///
  /// Called to process touch screen events.  At the very least your
  /// implementation must call
  /// android.view.Window\#superDispatchTouchEvent to do the
  /// standard touch screen processing.
  ///@param event The touch screen event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean dispatchTrackballEvent(android.view.MotionEvent event)
  ///
  /// Called to process trackball events.  At the very least your
  /// implementation must call
  /// android.view.Window\#superDispatchTrackballEvent to do the
  /// standard trackball processing.
  ///@param event The trackball event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public abstract boolean dispatchGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Called to process generic motion events.  At the very least your
  /// implementation must call
  /// android.view.Window\#superDispatchGenericMotionEvent to do the
  /// standard processing.
  ///@param event The generic motion event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchPopulateAccessibilityEvent =
      jniAccessors.getMethodIDOf(
          _classRef,
          "dispatchPopulateAccessibilityEvent",
          "(Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public abstract boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Called to process population of AccessibilityEvents.
  ///@param event The event.
  ///@return boolean Return true if event population was completed.
  bool dispatchPopulateAccessibilityEvent(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPopulateAccessibilityEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_onCreatePanelView = jniAccessors.getMethodIDOf(
      _classRef, "onCreatePanelView", "(I)Landroid/view/View;");

  /// from: public abstract android.view.View onCreatePanelView(int featureId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiate the view to display in the panel for 'featureId'.
  /// You can return null, in which case the default content (typically
  /// a menu) will be created for you.
  ///@param featureId Which panel is being created.
  ///@return view The top-level view to place in the panel.
  ///@see \#onPreparePanel
  view_.View onCreatePanelView(int featureId) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreatePanelView, jni.JniType.objectType, [featureId]).object);

  static final _id_onCreatePanelMenu = jniAccessors.getMethodIDOf(
      _classRef, "onCreatePanelMenu", "(ILandroid/view/Menu;)Z");

  /// from: public abstract boolean onCreatePanelMenu(int featureId, android.view.Menu menu)
  ///
  /// Initialize the contents of the menu for panel 'featureId'.  This is
  /// called if onCreatePanelView() returns null, giving you a standard
  /// menu in which you can place your items.  It is only called once for
  /// the panel, the first time it is shown.
  ///
  /// You can safely hold on to <var>menu</var> (and any items created
  /// from it), making modifications to it as desired, until the next
  /// time onCreatePanelMenu() is called for this feature.
  ///@param featureId The panel being created.
  ///@param menu The menu inside the panel.
  ///@return boolean You must return true for the panel to be displayed;
  ///         if you return false it will not be shown.
  bool onCreatePanelMenu(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreatePanelMenu,
          jni.JniType.booleanType, [featureId, menu.reference]).boolean;

  static final _id_onPreparePanel = jniAccessors.getMethodIDOf(_classRef,
      "onPreparePanel", "(ILandroid/view/View;Landroid/view/Menu;)Z");

  /// from: public abstract boolean onPreparePanel(int featureId, android.view.View view, android.view.Menu menu)
  ///
  /// Prepare a panel to be displayed.  This is called right before the
  /// panel window is shown, every time it is shown.
  ///@param featureId The panel that is being displayed.
  ///@param view The View that was returned by onCreatePanelView().
  ///@param menu If onCreatePanelView() returned null, this is the Menu
  ///             being displayed in the panel.
  ///@return boolean You must return true for the panel to be displayed;
  ///         if you return false it will not be shown.
  ///@see \#onCreatePanelView
  bool onPreparePanel(int featureId, view_.View view, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPreparePanel,
          jni.JniType.booleanType,
          [featureId, view.reference, menu.reference]).boolean;

  static final _id_onMenuOpened = jniAccessors.getMethodIDOf(
      _classRef, "onMenuOpened", "(ILandroid/view/Menu;)Z");

  /// from: public abstract boolean onMenuOpened(int featureId, android.view.Menu menu)
  ///
  /// Called when a panel's menu is opened by the user. This may also be
  /// called when the menu is changing from one type to another (for
  /// example, from the icon menu to the expanded menu).
  ///@param featureId The panel that the menu is in.
  ///@param menu The menu that is opened.
  ///@return Return true to allow the menu to open, or false to prevent
  ///         the menu from opening.
  bool onMenuOpened(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuOpened,
          jni.JniType.booleanType, [featureId, menu.reference]).boolean;

  static final _id_onMenuItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onMenuItemSelected", "(ILandroid/view/MenuItem;)Z");

  /// from: public abstract boolean onMenuItemSelected(int featureId, android.view.MenuItem item)
  ///
  /// Called when a panel's menu item has been selected by the user.
  ///@param featureId The panel that the menu is in.
  ///@param item The menu item that was selected.
  ///@return boolean Return true to finish processing of selection, or
  ///         false to perform the normal menu handling (calling its
  ///         Runnable or sending a Message to its target Handler).
  bool onMenuItemSelected(int featureId, menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuItemSelected,
          jni.JniType.booleanType, [featureId, item.reference]).boolean;

  static final _id_onWindowAttributesChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowAttributesChanged",
      "(Landroid/view/WindowManager\$LayoutParams;)V");

  /// from: public abstract void onWindowAttributesChanged(android.view.WindowManager.LayoutParams attrs)
  ///
  /// This is called whenever the current window attributes change.
  void onWindowAttributesChanged(
          windowmanager_.WindowManager_LayoutParams attrs) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowAttributesChanged,
          jni.JniType.voidType, [attrs.reference]).check();

  static final _id_onContentChanged =
      jniAccessors.getMethodIDOf(_classRef, "onContentChanged", "()V");

  /// from: public abstract void onContentChanged()
  ///
  /// This hook is called whenever the content view of the screen changes
  /// (due to a call to
  /// Window\#setContentView(View, android.view.ViewGroup.LayoutParams) Window.setContentView or
  /// Window\#addContentView(View, android.view.ViewGroup.LayoutParams) Window.addContentView).
  void onContentChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_onContentChanged, jni.JniType.voidType, []).check();

  static final _id_onWindowFocusChanged =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public abstract void onWindowFocusChanged(boolean hasFocus)
  ///
  /// This hook is called whenever the window focus changes.  See
  /// View\#onWindowFocusChanged(boolean) View.onWindowFocusChangedNotLocked(boolean) for more information.
  ///@param hasFocus Whether the window now has focus.
  void onWindowFocusChanged(bool hasFocus) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onWindowFocusChanged,
      jni.JniType.voidType,
      [hasFocus]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: public abstract void onAttachedToWindow()
  ///
  /// Called when the window has been attached to the window manager.
  /// See View\#onAttachedToWindow() View.onAttachedToWindow()
  /// for more information.
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: public abstract void onDetachedFromWindow()
  ///
  /// Called when the window has been detached from the window manager.
  /// See View\#onDetachedFromWindow() View.onDetachedFromWindow()
  /// for more information.
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_onPanelClosed = jniAccessors.getMethodIDOf(
      _classRef, "onPanelClosed", "(ILandroid/view/Menu;)V");

  /// from: public abstract void onPanelClosed(int featureId, android.view.Menu menu)
  ///
  /// Called when a panel is being closed.  If another logical subsequent
  /// panel is being opened (and this panel is being closed to make room for the subsequent
  /// panel), this method will NOT be called.
  ///@param featureId The panel that is being displayed.
  ///@param menu If onCreatePanelView() returned null, this is the Menu
  ///            being displayed in the panel.
  void onPanelClosed(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPanelClosed,
          jni.JniType.voidType, [featureId, menu.reference]).check();

  static final _id_onSearchRequested =
      jniAccessors.getMethodIDOf(_classRef, "onSearchRequested", "()Z");

  /// from: public abstract boolean onSearchRequested()
  ///
  /// Called when the user signals the desire to start a search.
  ///@return true if search launched, false if activity refuses (blocks)
  ///@see android.app.Activity\#onSearchRequested()
  bool onSearchRequested() => jniAccessors.callMethodWithArgs(
      reference, _id_onSearchRequested, jni.JniType.booleanType, []).boolean;

  static final _id_onSearchRequested1 = jniAccessors.getMethodIDOf(
      _classRef, "onSearchRequested", "(Landroid/view/SearchEvent;)Z");

  /// from: public abstract boolean onSearchRequested(android.view.SearchEvent searchEvent)
  ///
  /// Called when the user signals the desire to start a search.
  ///@param searchEvent A SearchEvent describing the signal to
  ///                   start a search.
  ///@return true if search launched, false if activity refuses (blocks)
  bool onSearchRequested1(searchevent_.SearchEvent searchEvent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSearchRequested1,
          jni.JniType.booleanType, [searchEvent.reference]).boolean;

  static final _id_onWindowStartingActionMode = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowStartingActionMode",
      "(Landroid/view/ActionMode\$Callback;)Landroid/view/ActionMode;");

  /// from: public abstract android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when an action mode is being started for this window. Gives the
  /// callback an opportunity to handle the action mode in its own unique and
  /// beautiful way. If this method returns null the system can choose a way
  /// to present the mode or choose not to start the mode at all. This is equivalent
  /// to \#onWindowStartingActionMode(android.view.ActionMode.Callback, int)
  /// with type ActionMode\#TYPE_PRIMARY.
  ///@param callback Callback to control the lifecycle of this action mode
  ///@return The ActionMode that was started, or null if the system should present it
  actionmode_.ActionMode onWindowStartingActionMode(
          actionmode_.ActionMode_Callback callback) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowStartingActionMode,
          jni.JniType.objectType,
          [callback.reference]).object);

  static final _id_onWindowStartingActionMode1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowStartingActionMode",
      "(Landroid/view/ActionMode\$Callback;I)Landroid/view/ActionMode;");

  /// from: public abstract android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when an action mode is being started for this window. Gives the
  /// callback an opportunity to handle the action mode in its own unique and
  /// beautiful way. If this method returns null the system can choose a way
  /// to present the mode or choose not to start the mode at all.
  ///@param callback Callback to control the lifecycle of this action mode
  ///@param type One of ActionMode\#TYPE_PRIMARY or ActionMode\#TYPE_FLOATING.
  ///@return The ActionMode that was started, or null if the system should present it
  actionmode_.ActionMode onWindowStartingActionMode1(
          actionmode_.ActionMode_Callback callback, int type) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowStartingActionMode1,
          jni.JniType.objectType,
          [callback.reference, type]).object);

  static final _id_onActionModeStarted = jniAccessors.getMethodIDOf(
      _classRef, "onActionModeStarted", "(Landroid/view/ActionMode;)V");

  /// from: public abstract void onActionModeStarted(android.view.ActionMode mode)
  ///
  /// Called when an action mode has been started. The appropriate mode callback
  /// method will have already been invoked.
  ///@param mode The new mode that has just been started.
  void onActionModeStarted(actionmode_.ActionMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionModeStarted,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_onActionModeFinished = jniAccessors.getMethodIDOf(
      _classRef, "onActionModeFinished", "(Landroid/view/ActionMode;)V");

  /// from: public abstract void onActionModeFinished(android.view.ActionMode mode)
  ///
  /// Called when an action mode has been finished. The appropriate mode callback
  /// method will have already been invoked.
  ///@param mode The mode that was just finished.
  void onActionModeFinished(actionmode_.ActionMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionModeFinished,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_onProvideKeyboardShortcuts = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideKeyboardShortcuts",
      "(Ljava/util/List;Landroid/view/Menu;I)V");

  /// from: default public void onProvideKeyboardShortcuts(java.util.List<android.view.KeyboardShortcutGroup> data, android.view.Menu menu, int deviceId)
  ///
  /// Called when Keyboard Shortcuts are requested for the current window.
  ///@param data The data list to populate with shortcuts.
  ///@param menu The current menu, which may be null.
  /// This value may be {@code null}.
  ///@param deviceId The id for the connected device the shortcuts should be provided for.
  void onProvideKeyboardShortcuts(
          jni.JniObject data, menu_.Menu menu, int deviceId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onProvideKeyboardShortcuts,
          jni.JniType.voidType,
          [data.reference, menu.reference, deviceId]).check();

  static final _id_onPointerCaptureChanged =
      jniAccessors.getMethodIDOf(_classRef, "onPointerCaptureChanged", "(Z)V");

  /// from: default public void onPointerCaptureChanged(boolean hasCapture)
  ///
  /// Called when pointer capture is enabled or disabled for the current window.
  ///@param hasCapture True if the window has pointer capture.
  void onPointerCaptureChanged(bool hasCapture) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPointerCaptureChanged,
          jni.JniType.voidType, [hasCapture]).check();
}
