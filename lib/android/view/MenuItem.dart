// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../content/res/ColorStateList.dart" as colorstatelist_;

import "../graphics/PorterDuff.dart" as porterduff_;

import "../content/Intent.dart" as intent_;

import "SubMenu.dart" as submenu_;

import "ContextMenu.dart" as contextmenu_;

import "View.dart" as view_;

import "ActionProvider.dart" as actionprovider_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.view.MenuItem
///
/// Interface for direct access to a previously created menu item.
///
/// An Item is returned by calling one of the android.view.Menu\#add
/// methods.
///
/// For a feature set of specific menu types, see Menu.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about creating menus, read the
/// <a href="{@docRoot}guide/topics/ui/menus.html">Menus</a> developer guide.
///
/// </div>
class MenuItem extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/view/MenuItem");
  MenuItem.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SHOW_AS_ACTION_ALWAYS
  ///
  /// Always show this item as a button in an Action Bar.
  /// Use sparingly! If too many items are set to always show in the Action Bar it can
  /// crowd the Action Bar and degrade the user experience on devices with smaller screens.
  /// A good rule of thumb is to have no more than 2 items set to always show at a time.
  static const SHOW_AS_ACTION_ALWAYS = 2;

  /// from: static public final int SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW
  ///
  /// This item's action view collapses to a normal menu item.
  /// When expanded, the action view temporarily takes over
  /// a larger segment of its container.
  static const SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW = 8;

  /// from: static public final int SHOW_AS_ACTION_IF_ROOM
  ///
  /// Show this item as a button in an Action Bar if the system decides there is room for it.
  static const SHOW_AS_ACTION_IF_ROOM = 1;

  /// from: static public final int SHOW_AS_ACTION_NEVER
  ///
  /// Never show this item as a button in an Action Bar.
  static const SHOW_AS_ACTION_NEVER = 0;

  /// from: static public final int SHOW_AS_ACTION_WITH_TEXT
  ///
  /// When this item is in the action bar, always show it with a text label even if
  /// it also has an icon specified.
  static const SHOW_AS_ACTION_WITH_TEXT = 4;

  static final _id_getItemId =
      jniAccessors.getMethodIDOf(_classRef, "getItemId", "()I");

  /// from: public abstract int getItemId()
  ///
  /// Return the identifier for this menu item.  The identifier can not
  /// be changed after the menu is created.
  ///@return The menu item's identifier.
  int getItemId() => jniAccessors.callMethodWithArgs(
      reference, _id_getItemId, jni.JniType.intType, []).integer;

  static final _id_getGroupId =
      jniAccessors.getMethodIDOf(_classRef, "getGroupId", "()I");

  /// from: public abstract int getGroupId()
  ///
  /// Return the group identifier that this menu item is part of. The group
  /// identifier can not be changed after the menu is created.
  ///@return The menu item's group identifier.
  int getGroupId() => jniAccessors.callMethodWithArgs(
      reference, _id_getGroupId, jni.JniType.intType, []).integer;

  static final _id_getOrder =
      jniAccessors.getMethodIDOf(_classRef, "getOrder", "()I");

  /// from: public abstract int getOrder()
  ///
  /// Return the category and order within the category of this item. This
  /// item will be shown before all items (within its category) that have
  /// order greater than this value.
  ///
  /// An order integer contains the item's category (the upper bits of the
  /// integer; set by or/add the category with the order within the
  /// category) and the ordering of the item within that category (the
  /// lower bits). Example categories are Menu\#CATEGORY_SYSTEM,
  /// Menu\#CATEGORY_SECONDARY, Menu\#CATEGORY_ALTERNATIVE,
  /// Menu\#CATEGORY_CONTAINER. See Menu for a full list.
  ///@return The order of this item.
  int getOrder() => jniAccessors.callMethodWithArgs(
      reference, _id_getOrder, jni.JniType.intType, []).integer;

  static final _id_setTitle = jniAccessors.getMethodIDOf(_classRef, "setTitle",
      "(Ljava/lang/CharSequence;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the title associated with this item.
  ///@param title The new text to be displayed.
  ///@return This Item so additional setters can be called.
  MenuItem setTitle(jni.JniObject title) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(reference, _id_setTitle,
          jni.JniType.objectType, [title.reference]).object);

  static final _id_setTitle1 = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(I)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setTitle(int title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the title associated with this item.
  ///
  /// Some menu types do not sufficient space to show the full title, and
  /// instead a condensed title is preferred. See Menu for more
  /// information.
  ///@param title The resource id of the new text to be displayed.
  ///@return This Item so additional setters can be called.
  ///@see \#setTitleCondensed(CharSequence)
  MenuItem setTitle1(int title) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setTitle1, jni.JniType.objectType, [title]).object);

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current title of the item.
  ///@return The title.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_setTitleCondensed = jniAccessors.getMethodIDOf(_classRef,
      "setTitleCondensed", "(Ljava/lang/CharSequence;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setTitleCondensed(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the condensed title associated with this item. The condensed
  /// title is used in situations where the normal title may be too long to
  /// be displayed.
  ///@param title The new text to be displayed as the condensed title.
  ///@return This Item so additional setters can be called.
  MenuItem setTitleCondensed(jni.JniObject title) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTitleCondensed,
          jni.JniType.objectType,
          [title.reference]).object);

  static final _id_getTitleCondensed = jniAccessors.getMethodIDOf(
      _classRef, "getTitleCondensed", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getTitleCondensed()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current condensed title of the item. If a condensed
  /// title was never set, it will return the normal title.
  ///@return The condensed title, if it exists.
  ///         Otherwise the normal title.
  jni.JniObject getTitleCondensed() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitleCondensed, jni.JniType.objectType, []).object);

  static final _id_setIcon = jniAccessors.getMethodIDOf(_classRef, "setIcon",
      "(Landroid/graphics/drawable/Drawable;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setIcon(android.graphics.drawable.Drawable icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the icon associated with this item. This icon will not always be
  /// shown, so the title should be sufficient in describing this item. See
  /// Menu for the menu types that support icons.
  ///@param icon The new icon (as a Drawable) to be displayed.
  ///@return This Item so additional setters can be called.
  MenuItem setIcon(drawable_.Drawable icon) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(reference, _id_setIcon,
          jni.JniType.objectType, [icon.reference]).object);

  static final _id_setIcon1 = jniAccessors.getMethodIDOf(
      _classRef, "setIcon", "(I)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setIcon(int iconRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the icon associated with this item. This icon will not always be
  /// shown, so the title should be sufficient in describing this item. See
  /// Menu for the menu types that support icons.
  ///
  /// This method will set the resource ID of the icon which will be used to
  /// lazily get the Drawable when this item is being shown.
  ///@param iconRes The new icon (as a resource ID) to be displayed.
  ///@return This Item so additional setters can be called.
  MenuItem setIcon1(int iconRes) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setIcon1, jni.JniType.objectType, [iconRes]).object);

  static final _id_getIcon = jniAccessors.getMethodIDOf(
      _classRef, "getIcon", "()Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the icon for this item as a Drawable (getting it from resources if it hasn't been
  /// loaded before). Note that if you call \#setIconTintList(ColorStateList) or
  /// \#setIconTintMode(PorterDuff.Mode) on this item, and you use a custom menu presenter
  /// in your application, you have to apply the tinting explicitly on the Drawable
  /// returned by this method.
  ///@return The icon as a Drawable.
  drawable_.Drawable getIcon() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIcon, jni.JniType.objectType, []).object);

  static final _id_setIconTintList = jniAccessors.getMethodIDOf(
      _classRef,
      "setIconTintList",
      "(Landroid/content/res/ColorStateList;)Landroid/view/MenuItem;");

  /// from: default public android.view.MenuItem setIconTintList(android.content.res.ColorStateList tint)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Applies a tint to this item's icon. Does not modify the
  /// current tint mode, which is PorterDuff.Mode\#SRC_IN by default.
  ///
  /// Subsequent calls to \#setIcon(Drawable) or \#setIcon(int) will
  /// automatically mutate the icon and apply the specified tint and
  /// tint mode using
  /// Drawable\#setTintList(ColorStateList).
  ///@param tint the tint to apply, may be {@code null} to clear tint
  ///
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#MenuItem_iconTint
  ///@see \#getIconTintList()
  ///@see Drawable\#setTintList(ColorStateList)
  MenuItem setIconTintList(colorstatelist_.ColorStateList tint) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setIconTintList,
          jni.JniType.objectType,
          [tint.reference]).object);

  static final _id_getIconTintList = jniAccessors.getMethodIDOf(
      _classRef, "getIconTintList", "()Landroid/content/res/ColorStateList;");

  /// from: default public android.content.res.ColorStateList getIconTintList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the tint applied to this item's icon
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#MenuItem_iconTint
  ///@see \#setIconTintList(ColorStateList)
  colorstatelist_.ColorStateList getIconTintList() =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIconTintList, jni.JniType.objectType, []).object);

  static final _id_setIconTintMode = jniAccessors.getMethodIDOf(
      _classRef,
      "setIconTintMode",
      "(Landroid/graphics/PorterDuff\$Mode;)Landroid/view/MenuItem;");

  /// from: default public android.view.MenuItem setIconTintMode(android.graphics.PorterDuff.Mode tintMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies the blending mode used to apply the tint specified by
  /// \#setIconTintList(ColorStateList) to this item's icon. The default mode is
  /// PorterDuff.Mode\#SRC_IN.
  ///@param tintMode the blending mode used to apply the tint, may be
  ///                 {@code null} to clear tint
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#MenuItem_iconTintMode
  ///@see \#setIconTintList(ColorStateList)
  ///@see Drawable\#setTintMode(PorterDuff.Mode)
  MenuItem setIconTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setIconTintMode,
          jni.JniType.objectType,
          [tintMode.reference]).object);

  static final _id_getIconTintMode = jniAccessors.getMethodIDOf(
      _classRef, "getIconTintMode", "()Landroid/graphics/PorterDuff\$Mode;");

  /// from: default public android.graphics.PorterDuff.Mode getIconTintMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the blending mode used to apply the tint to this item's icon, if specified.
  ///@return the blending mode used to apply the tint to this item's icon
  /// This value may be {@code null}.
  ///@attr ref android.R.styleable\#MenuItem_iconTintMode
  ///@see \#setIconTintMode(PorterDuff.Mode)
  porterduff_.PorterDuff_Mode getIconTintMode() =>
      porterduff_.PorterDuff_Mode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIconTintMode, jni.JniType.objectType, []).object);

  static final _id_setIntent = jniAccessors.getMethodIDOf(_classRef,
      "setIntent", "(Landroid/content/Intent;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setIntent(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the Intent associated with this item.  By default there is no
  /// Intent associated with a menu item.  If you set one, and nothing
  /// else handles the item, then the default behavior will be to call
  /// android.content.Context\#startActivity with the given Intent.
  ///
  /// Note that setIntent() can not be used with the versions of
  /// Menu\#add that take a Runnable, because Runnable\#run
  /// does not return a value so there is no way to tell if it handled the
  /// item.  In this case it is assumed that the Runnable always handles
  /// the item, and the intent will never be started.
  ///@see \#getIntent
  ///@param intent The Intent to associated with the item.  This Intent
  ///               object is _not_ copied, so be careful not to
  ///               modify it later.
  ///@return This Item so additional setters can be called.
  MenuItem setIntent(intent_.Intent intent) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(reference, _id_setIntent,
          jni.JniType.objectType, [intent.reference]).object);

  static final _id_getIntent = jniAccessors.getMethodIDOf(
      _classRef, "getIntent", "()Landroid/content/Intent;");

  /// from: public abstract android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Intent associated with this item.  This returns a
  /// reference to the Intent which you can change as desired to modify
  /// what the Item is holding.
  ///@see \#setIntent
  ///@return Returns the last value supplied to \#setIntent, or
  ///         null.
  intent_.Intent getIntent() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIntent, jni.JniType.objectType, []).object);

  static final _id_setShortcut = jniAccessors.getMethodIDOf(
      _classRef, "setShortcut", "(CC)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setShortcut(char numericChar, char alphaChar)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change both the numeric and alphabetic shortcut associated with this
  /// item. Note that the shortcut will be triggered when the key that
  /// generates the given character is pressed along with the corresponding
  /// modifier key. The default modifier is  KeyEvent\#META_CTRL_ON in
  /// case nothing is specified. Also note that case is not significant and
  /// that alphabetic shortcut characters will be handled in lower case.
  ///
  /// See Menu for the menu types that support shortcuts.
  ///@param numericChar The numeric shortcut key. This is the shortcut when
  ///        using a numeric (e.g., 12-key) keyboard.
  ///@param alphaChar The alphabetic shortcut key. This is the shortcut when
  ///        using a keyboard with alphabetic keys.
  ///@return This Item so additional setters can be called.
  MenuItem setShortcut(int numericChar, int alphaChar) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setShortcut,
          jni.JniType.objectType,
          [numericChar, alphaChar]).object);

  static final _id_setShortcut1 = jniAccessors.getMethodIDOf(
      _classRef, "setShortcut", "(CCII)Landroid/view/MenuItem;");

  /// from: default public android.view.MenuItem setShortcut(char numericChar, char alphaChar, int numericModifiers, int alphaModifiers)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change both the numeric and alphabetic shortcut associated with this
  /// item. Note that the shortcut will be triggered when the key that
  /// generates the given character is pressed along with the corresponding
  /// modifier key. Also note that case is not significant and that alphabetic
  /// shortcut characters will be handled in lower case.
  ///
  /// See Menu for the menu types that support shortcuts.
  ///@param numericChar The numeric shortcut key. This is the shortcut when
  ///        using a numeric (e.g., 12-key) keyboard.
  ///@param numericModifiers The numeric modifier associated with the shortcut. It should
  ///        be a combination of KeyEvent\#META_META_ON, KeyEvent\#META_CTRL_ON,
  ///        KeyEvent\#META_ALT_ON, KeyEvent\#META_SHIFT_ON,
  ///        KeyEvent\#META_SYM_ON, KeyEvent\#META_FUNCTION_ON.
  ///@param alphaChar The alphabetic shortcut key. This is the shortcut when
  ///        using a keyboard with alphabetic keys.
  ///@param alphaModifiers The alphabetic modifier associated with the shortcut. It should
  ///        be a combination of KeyEvent\#META_META_ON, KeyEvent\#META_CTRL_ON,
  ///        KeyEvent\#META_ALT_ON, KeyEvent\#META_SHIFT_ON,
  ///        KeyEvent\#META_SYM_ON, KeyEvent\#META_FUNCTION_ON.
  ///@return This Item so additional setters can be called.
  MenuItem setShortcut1(int numericChar, int alphaChar, int numericModifiers,
          int alphaModifiers) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setShortcut1,
          jni.JniType.objectType,
          [numericChar, alphaChar, numericModifiers, alphaModifiers]).object);

  static final _id_setNumericShortcut = jniAccessors.getMethodIDOf(
      _classRef, "setNumericShortcut", "(C)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setNumericShortcut(char numericChar)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the numeric shortcut associated with this item.
  ///
  /// See Menu for the menu types that support shortcuts.
  ///@param numericChar The numeric shortcut key.  This is the shortcut when
  ///                 using a 12-key (numeric) keyboard.
  ///@return This Item so additional setters can be called.
  MenuItem setNumericShortcut(int numericChar) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setNumericShortcut,
          jni.JniType.objectType,
          [numericChar]).object);

  static final _id_setNumericShortcut1 = jniAccessors.getMethodIDOf(
      _classRef, "setNumericShortcut", "(CI)Landroid/view/MenuItem;");

  /// from: default public android.view.MenuItem setNumericShortcut(char numericChar, int numericModifiers)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the numeric shortcut and modifiers associated with this item.
  ///
  /// See Menu for the menu types that support shortcuts.
  ///@param numericChar The numeric shortcut key.  This is the shortcut when
  ///                 using a 12-key (numeric) keyboard.
  ///@param numericModifiers The modifier associated with the shortcut. It should
  ///        be a combination of KeyEvent\#META_META_ON, KeyEvent\#META_CTRL_ON,
  ///        KeyEvent\#META_ALT_ON, KeyEvent\#META_SHIFT_ON,
  ///        KeyEvent\#META_SYM_ON, KeyEvent\#META_FUNCTION_ON.
  ///@return This Item so additional setters can be called.
  MenuItem setNumericShortcut1(int numericChar, int numericModifiers) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setNumericShortcut1,
          jni.JniType.objectType,
          [numericChar, numericModifiers]).object);

  static final _id_getNumericShortcut =
      jniAccessors.getMethodIDOf(_classRef, "getNumericShortcut", "()C");

  /// from: public abstract char getNumericShortcut()
  ///
  /// Return the char for this menu item's numeric (12-key) shortcut.
  ///@return Numeric character to use as a shortcut.
  int getNumericShortcut() => jniAccessors.callMethodWithArgs(
      reference, _id_getNumericShortcut, jni.JniType.charType, []).char;

  static final _id_getNumericModifiers =
      jniAccessors.getMethodIDOf(_classRef, "getNumericModifiers", "()I");

  /// from: default public int getNumericModifiers()
  ///
  /// Return the modifiers for this menu item's numeric (12-key) shortcut.
  /// The modifier is a combination of KeyEvent\#META_META_ON,
  /// KeyEvent\#META_CTRL_ON, KeyEvent\#META_ALT_ON,
  /// KeyEvent\#META_SHIFT_ON, KeyEvent\#META_SYM_ON,
  /// KeyEvent\#META_FUNCTION_ON.
  /// For example, KeyEvent\#META_FUNCTION_ON|KeyEvent\#META_CTRL_ON
  ///@return Modifier associated with the numeric shortcut.
  int getNumericModifiers() => jniAccessors.callMethodWithArgs(
      reference, _id_getNumericModifiers, jni.JniType.intType, []).integer;

  static final _id_setAlphabeticShortcut = jniAccessors.getMethodIDOf(
      _classRef, "setAlphabeticShortcut", "(C)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setAlphabeticShortcut(char alphaChar)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the alphabetic shortcut associated with this item. The shortcut
  /// will be triggered when the key that generates the given character is
  /// pressed along with the corresponding modifier key. The default modifier
  /// is KeyEvent\#META_CTRL_ON in case nothing is specified. Case is
  /// not significant and shortcut characters will be displayed in lower case.
  /// Note that menu items with the characters '\b' or '\n' as shortcuts will
  /// get triggered by the Delete key or Carriage Return key, respectively.
  ///
  /// See Menu for the menu types that support shortcuts.
  ///@param alphaChar The alphabetic shortcut key. This is the shortcut when
  ///        using a keyboard with alphabetic keys.
  ///@return This Item so additional setters can be called.
  MenuItem setAlphabeticShortcut(int alphaChar) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setAlphabeticShortcut,
          jni.JniType.objectType,
          [alphaChar]).object);

  static final _id_setAlphabeticShortcut1 = jniAccessors.getMethodIDOf(
      _classRef, "setAlphabeticShortcut", "(CI)Landroid/view/MenuItem;");

  /// from: default public android.view.MenuItem setAlphabeticShortcut(char alphaChar, int alphaModifiers)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the alphabetic shortcut associated with this item. The shortcut
  /// will be triggered when the key that generates the given character is
  /// pressed along with the modifier keys. Case is not significant and shortcut
  /// characters will be displayed in lower case. Note that menu items with
  /// the characters '\b' or '\n' as shortcuts will get triggered by the
  /// Delete key or Carriage Return key, respectively.
  ///
  /// See Menu for the menu types that support shortcuts.
  ///@param alphaChar The alphabetic shortcut key. This is the shortcut when
  ///        using a keyboard with alphabetic keys.
  ///@param alphaModifiers The modifier associated with the shortcut. It should
  ///        be a combination of KeyEvent\#META_META_ON, KeyEvent\#META_CTRL_ON,
  ///        KeyEvent\#META_ALT_ON, KeyEvent\#META_SHIFT_ON,
  ///        KeyEvent\#META_SYM_ON, KeyEvent\#META_FUNCTION_ON.
  ///@return This Item so additional setters can be called.
  MenuItem setAlphabeticShortcut1(int alphaChar, int alphaModifiers) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setAlphabeticShortcut1,
          jni.JniType.objectType,
          [alphaChar, alphaModifiers]).object);

  static final _id_getAlphabeticShortcut =
      jniAccessors.getMethodIDOf(_classRef, "getAlphabeticShortcut", "()C");

  /// from: public abstract char getAlphabeticShortcut()
  ///
  /// Return the char for this menu item's alphabetic shortcut.
  ///@return Alphabetic character to use as a shortcut.
  int getAlphabeticShortcut() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlphabeticShortcut, jni.JniType.charType, []).char;

  static final _id_getAlphabeticModifiers =
      jniAccessors.getMethodIDOf(_classRef, "getAlphabeticModifiers", "()I");

  /// from: default public int getAlphabeticModifiers()
  ///
  /// Return the modifier for this menu item's alphabetic shortcut.
  /// The modifier is a combination of KeyEvent\#META_META_ON,
  /// KeyEvent\#META_CTRL_ON, KeyEvent\#META_ALT_ON,
  /// KeyEvent\#META_SHIFT_ON, KeyEvent\#META_SYM_ON,
  /// KeyEvent\#META_FUNCTION_ON.
  /// For example, KeyEvent\#META_FUNCTION_ON|KeyEvent\#META_CTRL_ON
  ///@return Modifier associated with the keyboard shortcut.
  int getAlphabeticModifiers() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlphabeticModifiers, jni.JniType.intType, []).integer;

  static final _id_setCheckable = jniAccessors.getMethodIDOf(
      _classRef, "setCheckable", "(Z)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setCheckable(boolean checkable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Control whether this item can display a check mark. Setting this does
  /// not actually display a check mark (see \#setChecked for that);
  /// rather, it ensures there is room in the item in which to display a
  /// check mark.
  ///
  /// See Menu for the menu types that support check marks.
  ///@param checkable Set to true to allow a check mark, false to
  ///            disallow. The default is false.
  ///@see \#setChecked
  ///@see \#isCheckable
  ///@see Menu\#setGroupCheckable
  ///@return This Item so additional setters can be called.
  MenuItem setCheckable(bool checkable) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setCheckable, jni.JniType.objectType, [checkable]).object);

  static final _id_isCheckable =
      jniAccessors.getMethodIDOf(_classRef, "isCheckable", "()Z");

  /// from: public abstract boolean isCheckable()
  ///
  /// Return whether the item can currently display a check mark.
  ///@return If a check mark can be displayed, returns true.
  ///@see \#setCheckable
  bool isCheckable() => jniAccessors.callMethodWithArgs(
      reference, _id_isCheckable, jni.JniType.booleanType, []).boolean;

  static final _id_setChecked = jniAccessors.getMethodIDOf(
      _classRef, "setChecked", "(Z)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setChecked(boolean checked)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Control whether this item is shown with a check mark.  Note that you
  /// must first have enabled checking with \#setCheckable or else
  /// the check mark will not appear.  If this item is a member of a group that contains
  /// mutually-exclusive items (set via Menu\#setGroupCheckable(int, boolean, boolean),
  /// the other items in the group will be unchecked.
  ///
  /// See Menu for the menu types that support check marks.
  ///@see \#setCheckable
  ///@see \#isChecked
  ///@see Menu\#setGroupCheckable
  ///@param checked Set to true to display a check mark, false to hide
  ///                it.  The default value is false.
  ///@return This Item so additional setters can be called.
  MenuItem setChecked(bool checked) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setChecked, jni.JniType.objectType, [checked]).object);

  static final _id_isChecked =
      jniAccessors.getMethodIDOf(_classRef, "isChecked", "()Z");

  /// from: public abstract boolean isChecked()
  ///
  /// Return whether the item is currently displaying a check mark.
  ///@return If a check mark is displayed, returns true.
  ///@see \#setChecked
  bool isChecked() => jniAccessors.callMethodWithArgs(
      reference, _id_isChecked, jni.JniType.booleanType, []).boolean;

  static final _id_setVisible = jniAccessors.getMethodIDOf(
      _classRef, "setVisible", "(Z)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setVisible(boolean visible)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the visibility of the menu item. Even if a menu item is not visible,
  /// it may still be invoked via its shortcut (to completely disable an item,
  /// set it to invisible and \#setEnabled(boolean) disabled).
  ///@param visible If true then the item will be visible; if false it is
  ///        hidden.
  ///@return This Item so additional setters can be called.
  MenuItem setVisible(bool visible) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setVisible, jni.JniType.objectType, [visible]).object);

  static final _id_isVisible =
      jniAccessors.getMethodIDOf(_classRef, "isVisible", "()Z");

  /// from: public abstract boolean isVisible()
  ///
  /// Return the visibility of the menu item.
  ///@return If true the item is visible; else it is hidden.
  bool isVisible() => jniAccessors.callMethodWithArgs(
      reference, _id_isVisible, jni.JniType.booleanType, []).boolean;

  static final _id_setEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setEnabled", "(Z)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setEnabled(boolean enabled)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether the menu item is enabled. Disabling a menu item will not
  /// allow it to be invoked via its shortcut. The menu item will still be
  /// visible.
  ///@param enabled If true then the item will be invokable; if false it is
  ///        won't be invokable.
  ///@return This Item so additional setters can be called.
  MenuItem setEnabled(bool enabled) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setEnabled, jni.JniType.objectType, [enabled]).object);

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public abstract boolean isEnabled()
  ///
  /// Return the enabled state of the menu item.
  ///@return If true the item is enabled and hence invokable; else it is not.
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_hasSubMenu =
      jniAccessors.getMethodIDOf(_classRef, "hasSubMenu", "()Z");

  /// from: public abstract boolean hasSubMenu()
  ///
  /// Check whether this item has an associated sub-menu.  I.e. it is a
  /// sub-menu of another menu.
  ///@return If true this item has a menu; else it is a
  ///         normal item.
  bool hasSubMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSubMenu, jni.JniType.booleanType, []).boolean;

  static final _id_getSubMenu = jniAccessors.getMethodIDOf(
      _classRef, "getSubMenu", "()Landroid/view/SubMenu;");

  /// from: public abstract android.view.SubMenu getSubMenu()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the sub-menu to be invoked when this item is selected, if it has
  /// one. See \#hasSubMenu().
  ///@return The associated menu if there is one, else null
  submenu_.SubMenu getSubMenu() =>
      submenu_.SubMenu.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSubMenu, jni.JniType.objectType, []).object);

  static final _id_setOnMenuItemClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnMenuItemClickListener",
      "(Landroid/view/MenuItem\$OnMenuItemClickListener;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setOnMenuItemClickListener(android.view.MenuItem.OnMenuItemClickListener menuItemClickListener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a custom listener for invocation of this menu item. In most
  /// situations, it is more efficient and easier to use
  /// Activity\#onOptionsItemSelected(MenuItem) or
  /// Activity\#onContextItemSelected(MenuItem).
  ///@param menuItemClickListener The object to receive invokations.
  ///@return This Item so additional setters can be called.
  ///@see Activity\#onOptionsItemSelected(MenuItem)
  ///@see Activity\#onContextItemSelected(MenuItem)
  MenuItem setOnMenuItemClickListener(
          MenuItem_OnMenuItemClickListener menuItemClickListener) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnMenuItemClickListener,
          jni.JniType.objectType,
          [menuItemClickListener.reference]).object);

  static final _id_getMenuInfo = jniAccessors.getMethodIDOf(_classRef,
      "getMenuInfo", "()Landroid/view/ContextMenu\$ContextMenuInfo;");

  /// from: public abstract android.view.ContextMenu.ContextMenuInfo getMenuInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the extra information linked to this menu item.  This extra
  /// information is set by the View that added this menu item to the
  /// menu.
  ///@see OnCreateContextMenuListener
  ///@return The extra information linked to the View that added this
  ///         menu item to the menu. This can be null.
  contextmenu_.ContextMenu_ContextMenuInfo getMenuInfo() =>
      contextmenu_.ContextMenu_ContextMenuInfo.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getMenuInfo, jni.JniType.objectType, []).object);

  static final _id_setShowAsAction =
      jniAccessors.getMethodIDOf(_classRef, "setShowAsAction", "(I)V");

  /// from: public abstract void setShowAsAction(int actionEnum)
  ///
  /// Sets how this item should display in the presence of an Action Bar.
  /// The parameter actionEnum is a flag set. One of \#SHOW_AS_ACTION_ALWAYS,
  /// \#SHOW_AS_ACTION_IF_ROOM, or \#SHOW_AS_ACTION_NEVER should
  /// be used, and you may optionally OR the value with \#SHOW_AS_ACTION_WITH_TEXT.
  /// SHOW_AS_ACTION_WITH_TEXT requests that when the item is shown as an action,
  /// it should be shown with a text label.
  ///@param actionEnum How the item should display. One of
  /// \#SHOW_AS_ACTION_ALWAYS, \#SHOW_AS_ACTION_IF_ROOM, or
  /// \#SHOW_AS_ACTION_NEVER. SHOW_AS_ACTION_NEVER is the default.
  ///@see android.app.ActionBar
  ///@see \#setActionView(View)
  void setShowAsAction(int actionEnum) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setShowAsAction,
      jni.JniType.voidType,
      [actionEnum]).check();

  static final _id_setShowAsActionFlags = jniAccessors.getMethodIDOf(
      _classRef, "setShowAsActionFlags", "(I)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setShowAsActionFlags(int actionEnum)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets how this item should display in the presence of an Action Bar.
  /// The parameter actionEnum is a flag set. One of \#SHOW_AS_ACTION_ALWAYS,
  /// \#SHOW_AS_ACTION_IF_ROOM, or \#SHOW_AS_ACTION_NEVER should
  /// be used, and you may optionally OR the value with \#SHOW_AS_ACTION_WITH_TEXT.
  /// SHOW_AS_ACTION_WITH_TEXT requests that when the item is shown as an action,
  /// it should be shown with a text label.
  ///
  /// Note: This method differs from \#setShowAsAction(int) only in that it
  /// returns the current MenuItem instance for call chaining.
  ///@param actionEnum How the item should display. One of
  /// \#SHOW_AS_ACTION_ALWAYS, \#SHOW_AS_ACTION_IF_ROOM, or
  /// \#SHOW_AS_ACTION_NEVER. SHOW_AS_ACTION_NEVER is the default.
  ///@see android.app.ActionBar
  ///@see \#setActionView(View)
  ///@return This MenuItem instance for call chaining.
  MenuItem setShowAsActionFlags(int actionEnum) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setShowAsActionFlags,
          jni.JniType.objectType,
          [actionEnum]).object);

  static final _id_setActionView = jniAccessors.getMethodIDOf(_classRef,
      "setActionView", "(Landroid/view/View;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setActionView(android.view.View view)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an action view for this menu item. An action view will be displayed in place
  /// of an automatically generated menu item element in the UI when this item is shown
  /// as an action within a parent.
  ///
  ///   <strong>Note:</strong> Setting an action view overrides the action provider
  ///           set via \#setActionProvider(ActionProvider).
  ///
  ///
  ///@param view View to use for presenting this item to the user.
  ///@return This Item so additional setters can be called.
  ///@see \#setShowAsAction(int)
  MenuItem setActionView(view_.View view) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setActionView, jni.JniType.objectType, [view.reference]).object);

  static final _id_setActionView1 = jniAccessors.getMethodIDOf(
      _classRef, "setActionView", "(I)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setActionView(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an action view for this menu item. An action view will be displayed in place
  /// of an automatically generated menu item element in the UI when this item is shown
  /// as an action within a parent.
  ///
  ///   <strong>Note:</strong> Setting an action view overrides the action provider
  ///           set via \#setActionProvider(ActionProvider).
  ///
  ///
  ///@param resId Layout resource to use for presenting this item to the user.
  ///@return This Item so additional setters can be called.
  ///@see \#setShowAsAction(int)
  MenuItem setActionView1(int resId) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setActionView1, jni.JniType.objectType, [resId]).object);

  static final _id_getActionView = jniAccessors.getMethodIDOf(
      _classRef, "getActionView", "()Landroid/view/View;");

  /// from: public abstract android.view.View getActionView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the currently set action view for this menu item.
  ///@return This item's action view
  ///@see \#setActionView(View)
  ///@see \#setShowAsAction(int)
  view_.View getActionView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActionView, jni.JniType.objectType, []).object);

  static final _id_setActionProvider = jniAccessors.getMethodIDOf(
      _classRef,
      "setActionProvider",
      "(Landroid/view/ActionProvider;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setActionProvider(android.view.ActionProvider actionProvider)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the ActionProvider responsible for creating an action view if
  /// the item is placed on the action bar. The provider also provides a default
  /// action invoked if the item is placed in the overflow menu.
  ///
  ///   <strong>Note:</strong> Setting an action provider overrides the action view
  ///           set via \#setActionView(int) or \#setActionView(View).
  ///
  ///
  ///@param actionProvider The action provider.
  ///@return This Item so additional setters can be called.
  ///@see ActionProvider
  MenuItem setActionProvider(actionprovider_.ActionProvider actionProvider) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setActionProvider,
          jni.JniType.objectType,
          [actionProvider.reference]).object);

  static final _id_getActionProvider = jniAccessors.getMethodIDOf(
      _classRef, "getActionProvider", "()Landroid/view/ActionProvider;");

  /// from: public abstract android.view.ActionProvider getActionProvider()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the ActionProvider.
  ///@return The action provider.
  ///@see ActionProvider
  ///@see \#setActionProvider(ActionProvider)
  actionprovider_.ActionProvider getActionProvider() =>
      actionprovider_.ActionProvider.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActionProvider, jni.JniType.objectType, []).object);

  static final _id_expandActionView =
      jniAccessors.getMethodIDOf(_classRef, "expandActionView", "()Z");

  /// from: public abstract boolean expandActionView()
  ///
  /// Expand the action view associated with this menu item.
  /// The menu item must have an action view set, as well as
  /// the showAsAction flag \#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW.
  /// If a listener has been set using \#setOnActionExpandListener(OnActionExpandListener)
  /// it will have its OnActionExpandListener\#onMenuItemActionExpand(MenuItem)
  /// method invoked. The listener may return false from this method to prevent expanding
  /// the action view.
  ///@return true if the action view was expanded, false otherwise.
  bool expandActionView() => jniAccessors.callMethodWithArgs(
      reference, _id_expandActionView, jni.JniType.booleanType, []).boolean;

  static final _id_collapseActionView =
      jniAccessors.getMethodIDOf(_classRef, "collapseActionView", "()Z");

  /// from: public abstract boolean collapseActionView()
  ///
  /// Collapse the action view associated with this menu item.
  /// The menu item must have an action view set, as well as the showAsAction flag
  /// \#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW. If a listener has been set using
  /// \#setOnActionExpandListener(OnActionExpandListener) it will have its
  /// OnActionExpandListener\#onMenuItemActionCollapse(MenuItem) method invoked.
  /// The listener may return false from this method to prevent collapsing the action view.
  ///@return true if the action view was collapsed, false otherwise.
  bool collapseActionView() => jniAccessors.callMethodWithArgs(
      reference, _id_collapseActionView, jni.JniType.booleanType, []).boolean;

  static final _id_isActionViewExpanded =
      jniAccessors.getMethodIDOf(_classRef, "isActionViewExpanded", "()Z");

  /// from: public abstract boolean isActionViewExpanded()
  ///
  /// Returns true if this menu item's action view has been expanded.
  ///@return true if the item's action view is expanded, false otherwise.
  ///@see \#expandActionView()
  ///@see \#collapseActionView()
  ///@see \#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW
  ///@see OnActionExpandListener
  bool isActionViewExpanded() => jniAccessors.callMethodWithArgs(
      reference, _id_isActionViewExpanded, jni.JniType.booleanType, []).boolean;

  static final _id_setOnActionExpandListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnActionExpandListener",
      "(Landroid/view/MenuItem\$OnActionExpandListener;)Landroid/view/MenuItem;");

  /// from: public abstract android.view.MenuItem setOnActionExpandListener(android.view.MenuItem.OnActionExpandListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an OnActionExpandListener on this menu item to be notified when
  /// the associated action view is expanded or collapsed. The menu item must
  /// be configured to expand or collapse its action view using the flag
  /// \#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW.
  ///@param listener Listener that will respond to expand/collapse events
  ///@return This menu item instance for call chaining
  MenuItem setOnActionExpandListener(
          MenuItem_OnActionExpandListener listener) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnActionExpandListener,
          jni.JniType.objectType,
          [listener.reference]).object);

  static final _id_setContentDescription = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentDescription",
      "(Ljava/lang/CharSequence;)Landroid/view/MenuItem;");

  /// from: default public android.view.MenuItem setContentDescription(java.lang.CharSequence contentDescription)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the content description associated with this menu item.
  ///@param contentDescription The new content description.
  MenuItem setContentDescription(jni.JniObject contentDescription) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentDescription,
          jni.JniType.objectType,
          [contentDescription.reference]).object);

  static final _id_getContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "getContentDescription", "()Ljava/lang/CharSequence;");

  /// from: default public java.lang.CharSequence getContentDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the content description associated with this menu item.
  ///@return The content description.
  jni.JniObject getContentDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getContentDescription, jni.JniType.objectType, []).object);

  static final _id_setTooltipText = jniAccessors.getMethodIDOf(_classRef,
      "setTooltipText", "(Ljava/lang/CharSequence;)Landroid/view/MenuItem;");

  /// from: default public android.view.MenuItem setTooltipText(java.lang.CharSequence tooltipText)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Change the tooltip text associated with this menu item.
  ///@param tooltipText The new tooltip text.
  MenuItem setTooltipText(jni.JniObject tooltipText) =>
      MenuItem.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTooltipText,
          jni.JniType.objectType,
          [tooltipText.reference]).object);

  static final _id_getTooltipText = jniAccessors.getMethodIDOf(
      _classRef, "getTooltipText", "()Ljava/lang/CharSequence;");

  /// from: default public java.lang.CharSequence getTooltipText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the tooltip text associated with this menu item.
  ///@return The tooltip text.
  jni.JniObject getTooltipText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTooltipText, jni.JniType.objectType, []).object);
}

/// from: android.view.MenuItem$OnMenuItemClickListener
///
/// Interface definition for a callback to be invoked when a menu item is
/// clicked.
///@see Activity\#onContextItemSelected(MenuItem)
///@see Activity\#onOptionsItemSelected(MenuItem)
class MenuItem_OnMenuItemClickListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/MenuItem\$OnMenuItemClickListener");
  MenuItem_OnMenuItemClickListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onMenuItemClick = jniAccessors.getMethodIDOf(
      _classRef, "onMenuItemClick", "(Landroid/view/MenuItem;)Z");

  /// from: public abstract boolean onMenuItemClick(android.view.MenuItem item)
  ///
  /// Called when a menu item has been invoked.  This is the first code
  /// that is executed; if it returns true, no other callbacks will be
  /// executed.
  ///@param item The menu item that was invoked.
  ///@return Return true to consume this click and prevent others from
  ///         executing.
  bool onMenuItemClick(MenuItem item) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onMenuItemClick,
      jni.JniType.booleanType,
      [item.reference]).boolean;
}

/// from: android.view.MenuItem$OnActionExpandListener
///
/// Interface definition for a callback to be invoked when a menu item
/// marked with MenuItem\#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW is
/// expanded or collapsed.
///@see MenuItem\#expandActionView()
///@see MenuItem\#collapseActionView()
///@see MenuItem\#setShowAsActionFlags(int)
class MenuItem_OnActionExpandListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/view/MenuItem\$OnActionExpandListener");
  MenuItem_OnActionExpandListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onMenuItemActionExpand = jniAccessors.getMethodIDOf(
      _classRef, "onMenuItemActionExpand", "(Landroid/view/MenuItem;)Z");

  /// from: public abstract boolean onMenuItemActionExpand(android.view.MenuItem item)
  ///
  /// Called when a menu item with MenuItem\#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW
  /// is expanded.
  ///@param item Item that was expanded
  ///@return true if the item should expand, false if expansion should be suppressed.
  bool onMenuItemActionExpand(MenuItem item) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onMenuItemActionExpand,
      jni.JniType.booleanType,
      [item.reference]).boolean;

  static final _id_onMenuItemActionCollapse = jniAccessors.getMethodIDOf(
      _classRef, "onMenuItemActionCollapse", "(Landroid/view/MenuItem;)Z");

  /// from: public abstract boolean onMenuItemActionCollapse(android.view.MenuItem item)
  ///
  /// Called when a menu item with MenuItem\#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW
  /// is collapsed.
  ///@param item Item that was collapsed
  ///@return true if the item should collapse, false if collapsing should be suppressed.
  bool onMenuItemActionCollapse(MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuItemActionCollapse,
          jni.JniType.booleanType, [item.reference]).boolean;
}
