// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.opengl.GLU
///
/// A set of GL utilities inspired by the OpenGL Utility Toolkit.
class GLU extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/opengl/GLU");
  GLU.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GLU()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_gluErrorString = jniAccessors.getStaticMethodIDOf(
      _classRef, "gluErrorString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String gluErrorString(int error)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an error string from a GL or GLU error code.
  ///@param error - a GL or GLU error code.
  ///@return the error string for the input error code, or NULL if the input
  ///         was not a valid GL or GLU error code.
  static jni.JniString gluErrorString(int error) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_gluErrorString, jni.JniType.objectType, [error]).object);

  static final _id_gluLookAt = jniAccessors.getStaticMethodIDOf(_classRef,
      "gluLookAt", "(Ljavax/microedition/khronos/opengles/GL10;FFFFFFFFF)V");

  /// from: static public void gluLookAt(javax.microedition.khronos.opengles.GL10 gl, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ)
  ///
  /// Define a viewing transformation in terms of an eye point, a center of
  /// view, and an up vector.
  ///@param gl a GL10 interface
  ///@param eyeX eye point X
  ///@param eyeY eye point Y
  ///@param eyeZ eye point Z
  ///@param centerX center of view X
  ///@param centerY center of view Y
  ///@param centerZ center of view Z
  ///@param upX up vector X
  ///@param upY up vector Y
  ///@param upZ up vector Z
  static void gluLookAt(
          jni.JniObject gl,
          double eyeX,
          double eyeY,
          double eyeZ,
          double centerX,
          double centerY,
          double centerZ,
          double upX,
          double upY,
          double upZ) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_gluLookAt, jni.JniType.voidType, [
        gl.reference,
        eyeX,
        eyeY,
        eyeZ,
        centerX,
        centerY,
        centerZ,
        upX,
        upY,
        upZ
      ]).check();

  static final _id_gluOrtho2D = jniAccessors.getStaticMethodIDOf(_classRef,
      "gluOrtho2D", "(Ljavax/microedition/khronos/opengles/GL10;FFFF)V");

  /// from: static public void gluOrtho2D(javax.microedition.khronos.opengles.GL10 gl, float left, float right, float bottom, float top)
  ///
  /// Set up a 2D orthographic projection matrix
  ///@param gl
  ///@param left
  ///@param right
  ///@param bottom
  ///@param top
  static void gluOrtho2D(jni.JniObject gl, double left, double right,
          double bottom, double top) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_gluOrtho2D,
          jni.JniType.voidType,
          [gl.reference, left, right, bottom, top]).check();

  static final _id_gluPerspective = jniAccessors.getStaticMethodIDOf(_classRef,
      "gluPerspective", "(Ljavax/microedition/khronos/opengles/GL10;FFFF)V");

  /// from: static public void gluPerspective(javax.microedition.khronos.opengles.GL10 gl, float fovy, float aspect, float zNear, float zFar)
  ///
  /// Set up a perspective projection matrix
  ///@param gl a GL10 interface
  ///@param fovy specifies the field of view angle, in degrees, in the Y
  ///        direction.
  ///@param aspect specifies the aspect ration that determins the field of
  ///        view in the x direction. The aspect ratio is the ratio of x
  ///        (width) to y (height).
  ///@param zNear specifies the distance from the viewer to the near clipping
  ///        plane (always positive).
  ///@param zFar specifies the distance from the viewer to the far clipping
  ///        plane (always positive).
  static void gluPerspective(jni.JniObject gl, double fovy, double aspect,
          double zNear, double zFar) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_gluPerspective,
          jni.JniType.voidType,
          [gl.reference, fovy, aspect, zNear, zFar]).check();

  static final _id_gluProject = jniAccessors.getStaticMethodIDOf(
      _classRef, "gluProject", "(FFF[FI[FI[II[FI)I");

  /// from: static public int gluProject(float objX, float objY, float objZ, float[] model, int modelOffset, float[] project, int projectOffset, int[] view, int viewOffset, float[] win, int winOffset)
  ///
  /// Map object coordinates into window coordinates. gluProject transforms the
  /// specified object coordinates into window coordinates using model, proj,
  /// and view. The result is stored in win.
  ///
  /// Note that you can use the OES_matrix_get extension, if present, to get
  /// the current modelView and projection matrices.
  ///@param objX object coordinates X
  ///@param objY object coordinates Y
  ///@param objZ object coordinates Z
  ///@param model the current modelview matrix
  ///@param modelOffset the offset into the model array where the modelview
  ///        maxtrix data starts.
  ///@param project the current projection matrix
  ///@param projectOffset the offset into the project array where the project
  ///        matrix data starts.
  ///@param view the current view, {x, y, width, height}
  ///@param viewOffset the offset into the view array where the view vector
  ///        data starts.
  ///@param win the output vector {winX, winY, winZ}, that returns the
  ///        computed window coordinates.
  ///@param winOffset the offset into the win array where the win vector data
  ///        starts.
  ///@return A return value of GL_TRUE indicates success, a return value of
  ///         GL_FALSE indicates failure.
  static int gluProject(
          double objX,
          double objY,
          double objZ,
          jni.JniObject model,
          int modelOffset,
          jni.JniObject project,
          int projectOffset,
          jni.JniObject view,
          int viewOffset,
          jni.JniObject win,
          int winOffset) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_gluProject, jni.JniType.intType, [
        objX,
        objY,
        objZ,
        model.reference,
        modelOffset,
        project.reference,
        projectOffset,
        view.reference,
        viewOffset,
        win.reference,
        winOffset
      ]).integer;

  static final _id_gluUnProject = jniAccessors.getStaticMethodIDOf(
      _classRef, "gluUnProject", "(FFF[FI[FI[II[FI)I");

  /// from: static public int gluUnProject(float winX, float winY, float winZ, float[] model, int modelOffset, float[] project, int projectOffset, int[] view, int viewOffset, float[] obj, int objOffset)
  ///
  /// Map window coordinates to object coordinates. gluUnProject maps the
  /// specified window coordinates into object coordinates using model, proj,
  /// and view. The result is stored in obj.
  ///
  /// Note that you can use the OES_matrix_get extension, if present, to get
  /// the current modelView and projection matrices.
  ///@param winX window coordinates X
  ///@param winY window coordinates Y
  ///@param winZ window coordinates Z
  ///@param model the current modelview matrix
  ///@param modelOffset the offset into the model array where the modelview
  ///        maxtrix data starts.
  ///@param project the current projection matrix
  ///@param projectOffset the offset into the project array where the project
  ///        matrix data starts.
  ///@param view the current view, {x, y, width, height}
  ///@param viewOffset the offset into the view array where the view vector
  ///        data starts.
  ///@param obj the output vector {objX, objY, objZ, objW}, that returns the
  ///        computed homogeneous object coordinates.
  ///@param objOffset the offset into the obj array where the obj vector data
  ///        starts.
  ///@return A return value of GL10.GL_TRUE indicates success, a return value
  ///         of GL10.GL_FALSE indicates failure.
  static int gluUnProject(
          double winX,
          double winY,
          double winZ,
          jni.JniObject model,
          int modelOffset,
          jni.JniObject project,
          int projectOffset,
          jni.JniObject view,
          int viewOffset,
          jni.JniObject obj,
          int objOffset) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_gluUnProject, jni.JniType.intType, [
        winX,
        winY,
        winZ,
        model.reference,
        modelOffset,
        project.reference,
        projectOffset,
        view.reference,
        viewOffset,
        obj.reference,
        objOffset
      ]).integer;
}
