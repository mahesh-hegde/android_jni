// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.opengl.ETC1
///
/// Methods for encoding and decoding ETC1 textures.
///
/// The standard for the ETC1 texture format can be found at
/// http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt
///
/// The PKM file format is of a 16-byte header that describes the image bounds
/// followed by the encoded ETC1 texture data.
///
///@see ETC1Util
class ETC1 extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/opengl/ETC1");
  ETC1.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DECODED_BLOCK_SIZE
  ///
  /// Size in bytes of a decoded block.
  static const DECODED_BLOCK_SIZE = 48;

  /// from: static public final int ENCODED_BLOCK_SIZE
  ///
  /// Size in bytes of an encoded block.
  static const ENCODED_BLOCK_SIZE = 8;

  /// from: static public final int ETC1_RGB8_OES
  ///
  /// Accepted by the internalformat parameter of glCompressedTexImage2D.
  static const ETC1_RGB8_OES = 36196;

  /// from: static public final int ETC_PKM_HEADER_SIZE
  ///
  /// Size of a PKM file header, in bytes.
  static const ETC_PKM_HEADER_SIZE = 16;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ETC1()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_encodeBlock = jniAccessors.getStaticMethodIDOf(
      _classRef, "encodeBlock", "(Ljava/nio/Buffer;ILjava/nio/Buffer;)V");

  /// from: static public native void encodeBlock(java.nio.Buffer in, int validPixelMask, java.nio.Buffer out)
  ///
  /// Encode a block of pixels.
  ///@param in a native order direct buffer of size DECODED_BLOCK_SIZE that represent a
  /// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
  /// value of pixel (x, y).
  ///@param validPixelMask is a 16-bit mask where bit (1 << (x + y * 4)) indicates whether
  /// the corresponding (x,y) pixel is valid. Invalid pixel color values are ignored when compressing.
  ///@param out a native order direct buffer of size ENCODED_BLOCK_SIZE that receives the
  /// ETC1 compressed version of the data.
  static void encodeBlock(
          jni.JniObject in0, int validPixelMask, jni.JniObject out) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_encodeBlock,
          jni.JniType.voidType,
          [in0.reference, validPixelMask, out.reference]).check();

  static final _id_decodeBlock = jniAccessors.getStaticMethodIDOf(
      _classRef, "decodeBlock", "(Ljava/nio/Buffer;Ljava/nio/Buffer;)V");

  /// from: static public native void decodeBlock(java.nio.Buffer in, java.nio.Buffer out)
  ///
  /// Decode a block of pixels.
  ///@param in a native order direct buffer of size ENCODED_BLOCK_SIZE that contains the
  /// ETC1 compressed version of the data.
  ///@param out a native order direct buffer of size DECODED_BLOCK_SIZE that will receive
  /// the decoded data. The data represents a
  /// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
  /// value of pixel (x, y).
  static void decodeBlock(jni.JniObject in0, jni.JniObject out) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_decodeBlock,
          jni.JniType.voidType, [in0.reference, out.reference]).check();

  static final _id_getEncodedDataSize = jniAccessors.getStaticMethodIDOf(
      _classRef, "getEncodedDataSize", "(II)I");

  /// from: static public native int getEncodedDataSize(int width, int height)
  ///
  /// Return the size of the encoded image data (does not include size of PKM header).
  static int getEncodedDataSize(int width, int height) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getEncodedDataSize,
          jni.JniType.intType, [width, height]).integer;

  static final _id_encodeImage = jniAccessors.getStaticMethodIDOf(
      _classRef, "encodeImage", "(Ljava/nio/Buffer;IIIILjava/nio/Buffer;)V");

  /// from: static public native void encodeImage(java.nio.Buffer in, int width, int height, int pixelSize, int stride, java.nio.Buffer out)
  ///
  /// Encode an entire image.
  ///@param in a native order direct buffer of the image data. Formatted such that
  ///           pixel (x,y) is at pIn + pixelSize * x + stride * y;
  ///@param out a native order direct buffer of the encoded data.
  /// Must be large enough to store entire encoded image.
  ///@param pixelSize must be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image,
  /// 3 is a GL_BYTE RGB image.
  static void encodeImage(jni.JniObject in0, int width, int height,
          int pixelSize, int stride, jni.JniObject out) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_encodeImage, jni.JniType.voidType, [
        in0.reference,
        width,
        height,
        pixelSize,
        stride,
        out.reference
      ]).check();

  static final _id_decodeImage = jniAccessors.getStaticMethodIDOf(
      _classRef, "decodeImage", "(Ljava/nio/Buffer;Ljava/nio/Buffer;IIII)V");

  /// from: static public native void decodeImage(java.nio.Buffer in, java.nio.Buffer out, int width, int height, int pixelSize, int stride)
  ///
  /// Decode an entire image.
  ///@param in native order direct buffer of the encoded data.
  ///@param out native order direct buffer of the image data. Will be written such that
  /// pixel (x,y) is at pIn + pixelSize * x + stride * y. Must be
  /// large enough to store entire image.
  ///@param pixelSize must be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image,
  /// 3 is a GL_BYTE RGB image.
  static void decodeImage(jni.JniObject in0, jni.JniObject out, int width,
          int height, int pixelSize, int stride) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_decodeImage, jni.JniType.voidType, [
        in0.reference,
        out.reference,
        width,
        height,
        pixelSize,
        stride
      ]).check();

  static final _id_formatHeader = jniAccessors.getStaticMethodIDOf(
      _classRef, "formatHeader", "(Ljava/nio/Buffer;II)V");

  /// from: static public native void formatHeader(java.nio.Buffer header, int width, int height)
  ///
  /// Format a PKM header
  ///@param header native order direct buffer of the header.
  ///@param width the width of the image in pixels.
  ///@param height the height of the image in pixels.
  static void formatHeader(jni.JniObject header, int width, int height) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_formatHeader,
          jni.JniType.voidType, [header.reference, width, height]).check();

  static final _id_isValid = jniAccessors.getStaticMethodIDOf(
      _classRef, "isValid", "(Ljava/nio/Buffer;)Z");

  /// from: static public native boolean isValid(java.nio.Buffer header)
  ///
  /// Check if a PKM header is correctly formatted.
  ///@param header native order direct buffer of the header.
  static bool isValid(jni.JniObject header) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isValid,
          jni.JniType.booleanType, [header.reference]).boolean;

  static final _id_getWidth = jniAccessors.getStaticMethodIDOf(
      _classRef, "getWidth", "(Ljava/nio/Buffer;)I");

  /// from: static public native int getWidth(java.nio.Buffer header)
  ///
  /// Read the image width from a PKM header
  ///@param header native order direct buffer of the header.
  static int getWidth(jni.JniObject header) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getWidth,
          jni.JniType.intType, [header.reference]).integer;

  static final _id_getHeight = jniAccessors.getStaticMethodIDOf(
      _classRef, "getHeight", "(Ljava/nio/Buffer;)I");

  /// from: static public native int getHeight(java.nio.Buffer header)
  ///
  /// Read the image height from a PKM header
  ///@param header native order direct buffer of the header.
  static int getHeight(jni.JniObject header) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getHeight,
          jni.JniType.intType, [header.reference]).integer;
}
