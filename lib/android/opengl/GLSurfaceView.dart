// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/SurfaceView.dart" as surfaceview_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../view/SurfaceHolder.dart" as surfaceholder_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.opengl.GLSurfaceView
///
/// An implementation of SurfaceView that uses the dedicated surface for
/// displaying OpenGL rendering.
///
/// A GLSurfaceView provides the following features:
///
/// <ul>
/// <li>Manages a surface, which is a special piece of memory that can be
/// composited into the Android view system.
/// <li>Manages an EGL display, which enables OpenGL to render into a surface.
/// <li>Accepts a user-provided Renderer object that does the actual rendering.
/// <li>Renders on a dedicated thread to decouple rendering performance from the
/// UI thread.
/// <li>Supports both on-demand and continuous rendering.
/// <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
/// </ul>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about how to use OpenGL, read the
/// <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.
///
/// </div>
///
/// <h3>Using GLSurfaceView</h3>
///
/// Typically you use GLSurfaceView by subclassing it and overriding one or more of the
/// View system input event methods. If your application does not need to override event
/// methods then GLSurfaceView can be used as-is. For the most part
/// GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
/// For example, unlike a regular View, drawing is delegated to a separate Renderer object which
/// is registered with the GLSurfaceView
/// using the \#setRenderer(Renderer) call.
///
/// <h3>Initializing GLSurfaceView</h3>
/// All you have to do to initialize a GLSurfaceView is call \#setRenderer(Renderer).
/// However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
/// more of these methods before calling setRenderer:
/// <ul>
/// <li>\#setDebugFlags(int)
/// <li>\#setEGLConfigChooser(boolean)
/// <li>\#setEGLConfigChooser(EGLConfigChooser)
/// <li>\#setEGLConfigChooser(int, int, int, int, int, int)
/// <li>\#setGLWrapper(GLWrapper)
/// </ul>
///
/// <h4>Specifying the android.view.Surface</h4>
/// By default GLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
/// surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
/// The exact format of a TRANSLUCENT surface is device dependent, but it will be
/// a 32-bit-per-pixel surface with 8 bits per component.
///
/// <h4>Choosing an EGL Configuration</h4>
/// A given Android device may support multiple EGLConfig rendering configurations.
/// The available configurations may differ in how many channels of data are present, as
/// well as how many bits are allocated to each channel. Therefore, the first thing
/// GLSurfaceView has to do when starting to render is choose what EGLConfig to use.
///
/// By default GLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
/// with at least a 16-bit depth buffer and no stencil.
///
/// If you would prefer a different EGLConfig
/// you can override the default behavior by calling one of the
/// setEGLConfigChooser methods.
///
/// <h4>Debug Behavior</h4>
/// You can optionally modify the behavior of GLSurfaceView by calling
/// one or more of the debugging methods \#setDebugFlags(int),
/// and \#setGLWrapper. These methods may be called before and/or after setRenderer, but
/// typically they are called before setRenderer so that they take effect immediately.
///
/// <h4>Setting a Renderer</h4>
/// Finally, you must call \#setRenderer to register a Renderer.
/// The renderer is
/// responsible for doing the actual OpenGL rendering.
///
/// <h3>Rendering Mode</h3>
/// Once the renderer is set, you can control whether the renderer draws
/// continuously or on-demand by calling
/// \#setRenderMode. The default is continuous rendering.
///
/// <h3>Activity Life-cycle</h3>
/// A GLSurfaceView must be notified when to pause and resume rendering. GLSurfaceView clients
/// are required to call \#onPause() when the activity stops and
/// \#onResume() when the activity starts. These calls allow GLSurfaceView to
/// pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
/// the OpenGL display.
///
/// <h3>Handling events</h3>
///
/// To handle an event you will typically subclass GLSurfaceView and override the
/// appropriate method, just as you would with any other View. However, when handling
/// the event, you may need to communicate with the Renderer object
/// that's running in the rendering thread. You can do this using any
/// standard Java cross-thread communication mechanism. In addition,
/// one relatively easy way to communicate with your renderer is
/// to call
/// \#queueEvent(Runnable). For example:
/// <pre class="prettyprint">
/// class MyGLSurfaceView extends GLSurfaceView {
///
///     private MyRenderer mMyRenderer;
///
///     public void start() {
///         mMyRenderer = ...;
///         setRenderer(mMyRenderer);
///     }
///
///     public boolean onKeyDown(int keyCode, KeyEvent event) {
///         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
///             queueEvent(new Runnable() {
///                 // This method will be called on the rendering
///                 // thread:
///                 public void run() {
///                     mMyRenderer.handleDpadCenter();
///                 }});
///             return true;
///         }
///         return super.onKeyDown(keyCode, event);
///     }
/// }
/// </pre>
class GLSurfaceView extends surfaceview_.SurfaceView {
  static final _classRef =
      jniAccessors.getClassOf("android/opengl/GLSurfaceView");
  GLSurfaceView.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DEBUG_CHECK_GL_ERROR
  ///
  /// Check glError() after every GL call and throw an exception if glError indicates
  /// that an error has occurred. This can be used to help track down which OpenGL ES call
  /// is causing an error.
  ///@see \#getDebugFlags
  ///@see \#setDebugFlags
  static const DEBUG_CHECK_GL_ERROR = 1;

  /// from: static public final int DEBUG_LOG_GL_CALLS
  ///
  /// Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
  ///@see \#getDebugFlags
  ///@see \#setDebugFlags
  static const DEBUG_LOG_GL_CALLS = 2;

  /// from: static public final int RENDERMODE_CONTINUOUSLY
  ///
  /// The renderer is called
  /// continuously to re-render the scene.
  ///@see \#getRenderMode()
  ///@see \#setRenderMode(int)
  static const RENDERMODE_CONTINUOUSLY = 1;

  /// from: static public final int RENDERMODE_WHEN_DIRTY
  ///
  /// The renderer only renders
  /// when the surface is created, or when \#requestRender is called.
  ///@see \#getRenderMode()
  ///@see \#setRenderMode(int)
  ///@see \#requestRender()
  static const RENDERMODE_WHEN_DIRTY = 0;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard View constructor. In order to render something, you
  /// must call \#setRenderer to register a renderer.
  GLSurfaceView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard View constructor. In order to render something, you
  /// must call \#setRenderer to register a renderer.
  GLSurfaceView.ctor1(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_setGLWrapper = jniAccessors.getMethodIDOf(_classRef,
      "setGLWrapper", "(Landroid/opengl/GLSurfaceView\$GLWrapper;)V");

  /// from: public void setGLWrapper(android.opengl.GLSurfaceView.GLWrapper glWrapper)
  ///
  /// Set the glWrapper. If the glWrapper is not null, its
  /// GLWrapper\#wrap(GL) method is called
  /// whenever a surface is created. A GLWrapper can be used to wrap
  /// the GL object that's passed to the renderer. Wrapping a GL
  /// object enables examining and modifying the behavior of the
  /// GL calls made by the renderer.
  ///
  /// Wrapping is typically used for debugging purposes.
  ///
  /// The default value is null.
  ///@param glWrapper the new GLWrapper
  void setGLWrapper(GLSurfaceView_GLWrapper glWrapper) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGLWrapper,
          jni.JniType.voidType, [glWrapper.reference]).check();

  static final _id_setDebugFlags =
      jniAccessors.getMethodIDOf(_classRef, "setDebugFlags", "(I)V");

  /// from: public void setDebugFlags(int debugFlags)
  ///
  /// Set the debug flags to a new value. The value is
  /// constructed by OR-together zero or more
  /// of the DEBUG_CHECK_* constants. The debug flags take effect
  /// whenever a surface is created. The default value is zero.
  ///@param debugFlags the new debug flags
  ///@see \#DEBUG_CHECK_GL_ERROR
  ///@see \#DEBUG_LOG_GL_CALLS
  void setDebugFlags(int debugFlags) => jniAccessors.callMethodWithArgs(
      reference, _id_setDebugFlags, jni.JniType.voidType, [debugFlags]).check();

  static final _id_getDebugFlags =
      jniAccessors.getMethodIDOf(_classRef, "getDebugFlags", "()I");

  /// from: public int getDebugFlags()
  ///
  /// Get the current value of the debug flags.
  ///@return the current value of the debug flags.
  int getDebugFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getDebugFlags, jni.JniType.intType, []).integer;

  static final _id_setPreserveEGLContextOnPause = jniAccessors.getMethodIDOf(
      _classRef, "setPreserveEGLContextOnPause", "(Z)V");

  /// from: public void setPreserveEGLContextOnPause(boolean preserveOnPause)
  ///
  /// Control whether the EGL context is preserved when the GLSurfaceView is paused and
  /// resumed.
  ///
  /// If set to true, then the EGL context may be preserved when the GLSurfaceView is paused.
  ///
  /// Prior to API level 11, whether the EGL context is actually preserved or not
  /// depends upon whether the Android device can support an arbitrary number of
  /// EGL contexts or not. Devices that can only support a limited number of EGL
  /// contexts must release the EGL context in order to allow multiple applications
  /// to share the GPU.
  ///
  /// If set to false, the EGL context will be released when the GLSurfaceView is paused,
  /// and recreated when the GLSurfaceView is resumed.
  ///
  ///
  /// The default is false.
  ///@param preserveOnPause preserve the EGL context when paused
  void setPreserveEGLContextOnPause(bool preserveOnPause) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPreserveEGLContextOnPause,
          jni.JniType.voidType,
          [preserveOnPause]).check();

  static final _id_getPreserveEGLContextOnPause = jniAccessors.getMethodIDOf(
      _classRef, "getPreserveEGLContextOnPause", "()Z");

  /// from: public boolean getPreserveEGLContextOnPause()
  ///
  /// @return true if the EGL context will be preserved when paused
  bool getPreserveEGLContextOnPause() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPreserveEGLContextOnPause,
      jni.JniType.booleanType, []).boolean;

  static final _id_setRenderer = jniAccessors.getMethodIDOf(
      _classRef, "setRenderer", "(Landroid/opengl/GLSurfaceView\$Renderer;)V");

  /// from: public void setRenderer(android.opengl.GLSurfaceView.Renderer renderer)
  ///
  /// Set the renderer associated with this view. Also starts the thread that
  /// will call the renderer, which in turn causes the rendering to start.
  /// This method should be called once and only once in the life-cycle of
  /// a GLSurfaceView.
  /// The following GLSurfaceView methods can only be called _before_
  /// setRenderer is called:
  /// <ul>
  /// <li>\#setEGLConfigChooser(boolean)
  /// <li>\#setEGLConfigChooser(EGLConfigChooser)
  /// <li>\#setEGLConfigChooser(int, int, int, int, int, int)
  /// </ul>
  ///
  /// The following GLSurfaceView methods can only be called _after_
  /// setRenderer is called:
  /// <ul>
  /// <li>\#getRenderMode()
  /// <li>\#onPause()
  /// <li>\#onResume()
  /// <li>\#queueEvent(Runnable)
  /// <li>\#requestRender()
  /// <li>\#setRenderMode(int)
  /// </ul>
  ///@param renderer the renderer to use to perform OpenGL drawing.
  void setRenderer(GLSurfaceView_Renderer renderer) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRenderer,
          jni.JniType.voidType, [renderer.reference]).check();

  static final _id_setEGLContextFactory = jniAccessors.getMethodIDOf(
      _classRef,
      "setEGLContextFactory",
      "(Landroid/opengl/GLSurfaceView\$EGLContextFactory;)V");

  /// from: public void setEGLContextFactory(android.opengl.GLSurfaceView.EGLContextFactory factory)
  ///
  /// Install a custom EGLContextFactory.
  /// If this method is
  /// called, it must be called before \#setRenderer(Renderer)
  /// is called.
  ///
  /// If this method is not called, then by default
  /// a context will be created with no shared context and
  /// with a null attribute list.
  void setEGLContextFactory(GLSurfaceView_EGLContextFactory factory0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEGLContextFactory,
          jni.JniType.voidType, [factory0.reference]).check();

  static final _id_setEGLWindowSurfaceFactory = jniAccessors.getMethodIDOf(
      _classRef,
      "setEGLWindowSurfaceFactory",
      "(Landroid/opengl/GLSurfaceView\$EGLWindowSurfaceFactory;)V");

  /// from: public void setEGLWindowSurfaceFactory(android.opengl.GLSurfaceView.EGLWindowSurfaceFactory factory)
  ///
  /// Install a custom EGLWindowSurfaceFactory.
  /// If this method is
  /// called, it must be called before \#setRenderer(Renderer)
  /// is called.
  ///
  /// If this method is not called, then by default
  /// a window surface will be created with a null attribute list.
  void setEGLWindowSurfaceFactory(
          GLSurfaceView_EGLWindowSurfaceFactory factory0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEGLWindowSurfaceFactory,
          jni.JniType.voidType, [factory0.reference]).check();

  static final _id_setEGLConfigChooser = jniAccessors.getMethodIDOf(
      _classRef,
      "setEGLConfigChooser",
      "(Landroid/opengl/GLSurfaceView\$EGLConfigChooser;)V");

  /// from: public void setEGLConfigChooser(android.opengl.GLSurfaceView.EGLConfigChooser configChooser)
  ///
  /// Install a custom EGLConfigChooser.
  /// If this method is
  /// called, it must be called before \#setRenderer(Renderer)
  /// is called.
  ///
  /// If no setEGLConfigChooser method is called, then by default the
  /// view will choose an EGLConfig that is compatible with the current
  /// android.view.Surface, with a depth buffer depth of
  /// at least 16 bits.
  ///@param configChooser
  void setEGLConfigChooser(GLSurfaceView_EGLConfigChooser configChooser) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEGLConfigChooser,
          jni.JniType.voidType, [configChooser.reference]).check();

  static final _id_setEGLConfigChooser1 =
      jniAccessors.getMethodIDOf(_classRef, "setEGLConfigChooser", "(Z)V");

  /// from: public void setEGLConfigChooser(boolean needDepth)
  ///
  /// Install a config chooser which will choose a config
  /// as close to 16-bit RGB as possible, with or without an optional depth
  /// buffer as close to 16-bits as possible.
  /// If this method is
  /// called, it must be called before \#setRenderer(Renderer)
  /// is called.
  ///
  /// If no setEGLConfigChooser method is called, then by default the
  /// view will choose an RGB_888 surface with a depth buffer depth of
  /// at least 16 bits.
  ///@param needDepth
  void setEGLConfigChooser1(bool needDepth) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setEGLConfigChooser1,
      jni.JniType.voidType,
      [needDepth]).check();

  static final _id_setEGLConfigChooser2 =
      jniAccessors.getMethodIDOf(_classRef, "setEGLConfigChooser", "(IIIIII)V");

  /// from: public void setEGLConfigChooser(int redSize, int greenSize, int blueSize, int alphaSize, int depthSize, int stencilSize)
  ///
  /// Install a config chooser which will choose a config
  /// with at least the specified depthSize and stencilSize,
  /// and exactly the specified redSize, greenSize, blueSize and alphaSize.
  /// If this method is
  /// called, it must be called before \#setRenderer(Renderer)
  /// is called.
  ///
  /// If no setEGLConfigChooser method is called, then by default the
  /// view will choose an RGB_888 surface with a depth buffer depth of
  /// at least 16 bits.
  void setEGLConfigChooser2(int redSize, int greenSize, int blueSize,
          int alphaSize, int depthSize, int stencilSize) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setEGLConfigChooser2, jni.JniType.voidType, [
        redSize,
        greenSize,
        blueSize,
        alphaSize,
        depthSize,
        stencilSize
      ]).check();

  static final _id_setEGLContextClientVersion = jniAccessors.getMethodIDOf(
      _classRef, "setEGLContextClientVersion", "(I)V");

  /// from: public void setEGLContextClientVersion(int version)
  ///
  /// Inform the default EGLContextFactory and default EGLConfigChooser
  /// which EGLContext client version to pick.
  /// Use this method to create an OpenGL ES 2.0-compatible context.
  /// Example:
  /// <pre class="prettyprint">
  ///     public MyView(Context context) {
  ///         super(context);
  ///         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
  ///         setRenderer(new MyRenderer());
  ///     }
  /// </pre>
  /// Note: Activities which require OpenGL ES 2.0 should indicate this by
  /// setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
  /// AndroidManifest.xml file.
  /// If this method is called, it must be called before \#setRenderer(Renderer)
  /// is called.
  /// This method only affects the behavior of the default EGLContexFactory and the
  /// default EGLConfigChooser. If
  /// \#setEGLContextFactory(EGLContextFactory) has been called, then the supplied
  /// EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
  /// If
  /// \#setEGLConfigChooser(EGLConfigChooser) has been called, then the supplied
  /// EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
  ///@param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
  void setEGLContextClientVersion(int version) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEGLContextClientVersion,
          jni.JniType.voidType, [version]).check();

  static final _id_setRenderMode =
      jniAccessors.getMethodIDOf(_classRef, "setRenderMode", "(I)V");

  /// from: public void setRenderMode(int renderMode)
  ///
  /// Set the rendering mode. When renderMode is
  /// RENDERMODE_CONTINUOUSLY, the renderer is called
  /// repeatedly to re-render the scene. When renderMode
  /// is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
  /// is created, or when \#requestRender is called. Defaults to RENDERMODE_CONTINUOUSLY.
  ///
  /// Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
  /// by allowing the GPU and CPU to idle when the view does not need to be updated.
  ///
  /// This method can only be called after \#setRenderer(Renderer)
  ///@param renderMode one of the RENDERMODE_X constants
  ///@see \#RENDERMODE_CONTINUOUSLY
  ///@see \#RENDERMODE_WHEN_DIRTY
  void setRenderMode(int renderMode) => jniAccessors.callMethodWithArgs(
      reference, _id_setRenderMode, jni.JniType.voidType, [renderMode]).check();

  static final _id_getRenderMode =
      jniAccessors.getMethodIDOf(_classRef, "getRenderMode", "()I");

  /// from: public int getRenderMode()
  ///
  /// Get the current rendering mode. May be called
  /// from any thread. Must not be called before a renderer has been set.
  ///@return the current rendering mode.
  ///@see \#RENDERMODE_CONTINUOUSLY
  ///@see \#RENDERMODE_WHEN_DIRTY
  int getRenderMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getRenderMode, jni.JniType.intType, []).integer;

  static final _id_requestRender =
      jniAccessors.getMethodIDOf(_classRef, "requestRender", "()V");

  /// from: public void requestRender()
  ///
  /// Request that the renderer render a frame.
  /// This method is typically used when the render mode has been set to
  /// \#RENDERMODE_WHEN_DIRTY, so that frames are only rendered on demand.
  /// May be called
  /// from any thread. Must not be called before a renderer has been set.
  void requestRender() => jniAccessors.callMethodWithArgs(
      reference, _id_requestRender, jni.JniType.voidType, []).check();

  static final _id_surfaceCreated = jniAccessors.getMethodIDOf(
      _classRef, "surfaceCreated", "(Landroid/view/SurfaceHolder;)V");

  /// from: public void surfaceCreated(android.view.SurfaceHolder holder)
  ///
  /// This method is part of the SurfaceHolder.Callback interface, and is
  /// not normally called or subclassed by clients of GLSurfaceView.
  void surfaceCreated(surfaceholder_.SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_surfaceCreated,
          jni.JniType.voidType, [holder.reference]).check();

  static final _id_surfaceDestroyed = jniAccessors.getMethodIDOf(
      _classRef, "surfaceDestroyed", "(Landroid/view/SurfaceHolder;)V");

  /// from: public void surfaceDestroyed(android.view.SurfaceHolder holder)
  ///
  /// This method is part of the SurfaceHolder.Callback interface, and is
  /// not normally called or subclassed by clients of GLSurfaceView.
  void surfaceDestroyed(surfaceholder_.SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_surfaceDestroyed,
          jni.JniType.voidType, [holder.reference]).check();

  static final _id_surfaceChanged = jniAccessors.getMethodIDOf(
      _classRef, "surfaceChanged", "(Landroid/view/SurfaceHolder;III)V");

  /// from: public void surfaceChanged(android.view.SurfaceHolder holder, int format, int w, int h)
  ///
  /// This method is part of the SurfaceHolder.Callback interface, and is
  /// not normally called or subclassed by clients of GLSurfaceView.
  void surfaceChanged(
          surfaceholder_.SurfaceHolder holder, int format, int w, int h) =>
      jniAccessors.callMethodWithArgs(reference, _id_surfaceChanged,
          jni.JniType.voidType, [holder.reference, format, w, h]).check();

  static final _id_surfaceRedrawNeededAsync = jniAccessors.getMethodIDOf(
      _classRef,
      "surfaceRedrawNeededAsync",
      "(Landroid/view/SurfaceHolder;Ljava/lang/Runnable;)V");

  /// from: public void surfaceRedrawNeededAsync(android.view.SurfaceHolder holder, java.lang.Runnable finishDrawing)
  ///
  /// This method is part of the SurfaceHolder.Callback2 interface, and is
  /// not normally called or subclassed by clients of GLSurfaceView.
  void surfaceRedrawNeededAsync(
          surfaceholder_.SurfaceHolder holder, jni.JniObject finishDrawing) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_surfaceRedrawNeededAsync,
          jni.JniType.voidType,
          [holder.reference, finishDrawing.reference]).check();

  static final _id_surfaceRedrawNeeded = jniAccessors.getMethodIDOf(
      _classRef, "surfaceRedrawNeeded", "(Landroid/view/SurfaceHolder;)V");

  /// from: public void surfaceRedrawNeeded(android.view.SurfaceHolder holder)
  ///
  /// This method is part of the SurfaceHolder.Callback2 interface, and is
  /// not normally called or subclassed by clients of GLSurfaceView.
  void surfaceRedrawNeeded(surfaceholder_.SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_surfaceRedrawNeeded,
          jni.JniType.voidType, [holder.reference]).check();

  static final _id_onPause =
      jniAccessors.getMethodIDOf(_classRef, "onPause", "()V");

  /// from: public void onPause()
  ///
  /// Pause the rendering thread, optionally tearing down the EGL context
  /// depending upon the value of \#setPreserveEGLContextOnPause(boolean).
  ///
  /// This method should be called when it is no longer desirable for the
  /// GLSurfaceView to continue rendering, such as in response to
  /// android.app.Activity\#onStop Activity.onStop.
  ///
  /// Must not be called before a renderer has been set.
  void onPause() => jniAccessors.callMethodWithArgs(
      reference, _id_onPause, jni.JniType.voidType, []).check();

  static final _id_onResume =
      jniAccessors.getMethodIDOf(_classRef, "onResume", "()V");

  /// from: public void onResume()
  ///
  /// Resumes the rendering thread, re-creating the OpenGL context if necessary. It
  /// is the counterpart to \#onPause().
  ///
  /// This method should typically be called in
  /// android.app.Activity\#onStart Activity.onStart.
  ///
  /// Must not be called before a renderer has been set.
  void onResume() => jniAccessors.callMethodWithArgs(
      reference, _id_onResume, jni.JniType.voidType, []).check();

  static final _id_queueEvent = jniAccessors.getMethodIDOf(
      _classRef, "queueEvent", "(Ljava/lang/Runnable;)V");

  /// from: public void queueEvent(java.lang.Runnable r)
  ///
  /// Queue a runnable to be run on the GL rendering thread. This can be used
  /// to communicate with the Renderer on the rendering thread.
  /// Must not be called before a renderer has been set.
  ///@param r the runnable to be run on the GL rendering thread.
  void queueEvent(jni.JniObject r) => jniAccessors.callMethodWithArgs(
      reference, _id_queueEvent, jni.JniType.voidType, [r.reference]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  ///
  /// This method is used as part of the View class and is not normally
  /// called or subclassed by clients of GLSurfaceView.
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();
}

/// from: android.opengl.GLSurfaceView$Renderer
///
/// A generic renderer interface.
///
/// The renderer is responsible for making OpenGL calls to render a frame.
///
/// GLSurfaceView clients typically create their own classes that implement
/// this interface, and then call GLSurfaceView\#setRenderer to
/// register the renderer with the GLSurfaceView.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about how to use OpenGL, read the
/// <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.
///
/// </div>
///
/// <h3>Threading</h3>
/// The renderer will be called on a separate thread, so that rendering
/// performance is decoupled from the UI thread. Clients typically need to
/// communicate with the renderer from the UI thread, because that's where
/// input events are received. Clients can communicate using any of the
/// standard Java techniques for cross-thread communication, or they can
/// use the GLSurfaceView\#queueEvent(Runnable) convenience method.
///
/// <h3>EGL Context Lost</h3>
/// There are situations where the EGL rendering context will be lost. This
/// typically happens when device wakes up after going to sleep. When
/// the EGL context is lost, all OpenGL resources (such as textures) that are
/// associated with that context will be automatically deleted. In order to
/// keep rendering correctly, a renderer must recreate any lost resources
/// that it still needs. The \#onSurfaceCreated(GL10, EGLConfig) method
/// is a convenient place to do this.
///@see \#setRenderer(Renderer)
class GLSurfaceView_Renderer extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/opengl/GLSurfaceView\$Renderer");
  GLSurfaceView_Renderer.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onSurfaceCreated = jniAccessors.getMethodIDOf(
      _classRef,
      "onSurfaceCreated",
      "(Ljavax/microedition/khronos/opengles/GL10;Ljavax/microedition/khronos/egl/EGLConfig;)V");

  /// from: public abstract void onSurfaceCreated(javax.microedition.khronos.opengles.GL10 gl, javax.microedition.khronos.egl.EGLConfig config)
  ///
  /// Called when the surface is created or recreated.
  ///
  /// Called when the rendering thread
  /// starts and whenever the EGL context is lost. The EGL context will typically
  /// be lost when the Android device awakes after going to sleep.
  ///
  /// Since this method is called at the beginning of rendering, as well as
  /// every time the EGL context is lost, this method is a convenient place to put
  /// code to create resources that need to be created when the rendering
  /// starts, and that need to be recreated when the EGL context is lost.
  /// Textures are an example of a resource that you might want to create
  /// here.
  ///
  /// Note that when the EGL context is lost, all OpenGL resources associated
  /// with that context will be automatically deleted. You do not need to call
  /// the corresponding "glDelete" methods such as glDeleteTextures to
  /// manually delete these lost resources.
  ///
  ///@param gl the GL interface. Use <code>instanceof</code> to
  /// test if the interface supports GL11 or higher interfaces.
  ///@param config the EGLConfig of the created surface. Can be used
  /// to create matching pbuffers.
  void onSurfaceCreated(jni.JniObject gl, jni.JniObject config) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSurfaceCreated,
          jni.JniType.voidType, [gl.reference, config.reference]).check();

  static final _id_onSurfaceChanged = jniAccessors.getMethodIDOf(_classRef,
      "onSurfaceChanged", "(Ljavax/microedition/khronos/opengles/GL10;II)V");

  /// from: public abstract void onSurfaceChanged(javax.microedition.khronos.opengles.GL10 gl, int width, int height)
  ///
  /// Called when the surface changed size.
  ///
  /// Called after the surface is created and whenever
  /// the OpenGL ES surface size changes.
  ///
  /// Typically you will set your viewport here. If your camera
  /// is fixed then you could also set your projection matrix here:
  /// <pre class="prettyprint">
  /// void onSurfaceChanged(GL10 gl, int width, int height) {
  ///     gl.glViewport(0, 0, width, height);
  ///     // for a fixed camera, set the projection too
  ///     float ratio = (float) width / height;
  ///     gl.glMatrixMode(GL10.GL_PROJECTION);
  ///     gl.glLoadIdentity();
  ///     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
  /// }
  /// </pre>
  ///@param gl the GL interface. Use <code>instanceof</code> to
  /// test if the interface supports GL11 or higher interfaces.
  ///@param width
  ///@param height
  void onSurfaceChanged(jni.JniObject gl, int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSurfaceChanged,
          jni.JniType.voidType, [gl.reference, width, height]).check();

  static final _id_onDrawFrame = jniAccessors.getMethodIDOf(_classRef,
      "onDrawFrame", "(Ljavax/microedition/khronos/opengles/GL10;)V");

  /// from: public abstract void onDrawFrame(javax.microedition.khronos.opengles.GL10 gl)
  ///
  /// Called to draw the current frame.
  ///
  /// This method is responsible for drawing the current frame.
  ///
  /// The implementation of this method typically looks like this:
  /// <pre class="prettyprint">
  /// void onDrawFrame(GL10 gl) {
  ///     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  ///     //... other gl calls to render the scene ...
  /// }
  /// </pre>
  ///@param gl the GL interface. Use <code>instanceof</code> to
  /// test if the interface supports GL11 or higher interfaces.
  void onDrawFrame(jni.JniObject gl) => jniAccessors.callMethodWithArgs(
      reference, _id_onDrawFrame, jni.JniType.voidType, [gl.reference]).check();
}

/// from: android.opengl.GLSurfaceView$GLWrapper
///
/// An interface used to wrap a GL interface.
/// Typically
/// used for implementing debugging and tracing on top of the default
/// GL interface. You would typically use this by creating your own class
/// that implemented all the GL methods by delegating to another GL instance.
/// Then you could add your own behavior before or after calling the
/// delegate. All the GLWrapper would do was instantiate and return the
/// wrapper GL instance:
/// <pre class="prettyprint">
/// class MyGLWrapper implements GLWrapper {
///     GL wrap(GL gl) {
///         return new MyGLImplementation(gl);
///     }
///     static class MyGLImplementation implements GL,GL10,GL11,... {
///         ...
///     }
/// }
/// </pre>
///@see \#setGLWrapper(GLWrapper)
class GLSurfaceView_GLWrapper extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/opengl/GLSurfaceView\$GLWrapper");
  GLSurfaceView_GLWrapper.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_wrap = jniAccessors.getMethodIDOf(_classRef, "wrap",
      "(Ljavax/microedition/khronos/opengles/GL;)Ljavax/microedition/khronos/opengles/GL;");

  /// from: public abstract javax.microedition.khronos.opengles.GL wrap(javax.microedition.khronos.opengles.GL gl)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Wraps a gl interface in another gl interface.
  ///@param gl a GL interface that is to be wrapped.
  ///@return either the input argument or another GL object that wraps the input argument.
  jni.JniObject wrap(jni.JniObject gl) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_wrap, jni.JniType.objectType, [gl.reference]).object);
}

/// from: android.opengl.GLSurfaceView$EGLWindowSurfaceFactory
///
/// An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
///
/// This interface must be implemented by clients wishing to call
/// GLSurfaceView\#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)
class GLSurfaceView_EGLWindowSurfaceFactory extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/opengl/GLSurfaceView\$EGLWindowSurfaceFactory");
  GLSurfaceView_EGLWindowSurfaceFactory.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_createWindowSurface = jniAccessors.getMethodIDOf(
      _classRef,
      "createWindowSurface",
      "(Ljavax/microedition/khronos/egl/EGL10;Ljavax/microedition/khronos/egl/EGLDisplay;Ljavax/microedition/khronos/egl/EGLConfig;Ljava/lang/Object;)Ljavax/microedition/khronos/egl/EGLSurface;");

  /// from: public abstract javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10 egl, javax.microedition.khronos.egl.EGLDisplay display, javax.microedition.khronos.egl.EGLConfig config, java.lang.Object nativeWindow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return null if the surface cannot be constructed.
  jni.JniObject createWindowSurface(jni.JniObject egl, jni.JniObject display,
          jni.JniObject config, jni.JniObject nativeWindow) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createWindowSurface, jni.JniType.objectType, [
        egl.reference,
        display.reference,
        config.reference,
        nativeWindow.reference
      ]).object);

  static final _id_destroySurface = jniAccessors.getMethodIDOf(
      _classRef,
      "destroySurface",
      "(Ljavax/microedition/khronos/egl/EGL10;Ljavax/microedition/khronos/egl/EGLDisplay;Ljavax/microedition/khronos/egl/EGLSurface;)V");

  /// from: public abstract void destroySurface(javax.microedition.khronos.egl.EGL10 egl, javax.microedition.khronos.egl.EGLDisplay display, javax.microedition.khronos.egl.EGLSurface surface)
  void destroySurface(
          jni.JniObject egl, jni.JniObject display, jni.JniObject surface) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_destroySurface,
          jni.JniType.voidType,
          [egl.reference, display.reference, surface.reference]).check();
}

/// from: android.opengl.GLSurfaceView$EGLContextFactory
///
/// An interface for customizing the eglCreateContext and eglDestroyContext calls.
///
/// This interface must be implemented by clients wishing to call
/// GLSurfaceView\#setEGLContextFactory(EGLContextFactory)
class GLSurfaceView_EGLContextFactory extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/opengl/GLSurfaceView\$EGLContextFactory");
  GLSurfaceView_EGLContextFactory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_createContext = jniAccessors.getMethodIDOf(
      _classRef,
      "createContext",
      "(Ljavax/microedition/khronos/egl/EGL10;Ljavax/microedition/khronos/egl/EGLDisplay;Ljavax/microedition/khronos/egl/EGLConfig;)Ljavax/microedition/khronos/egl/EGLContext;");

  /// from: public abstract javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10 egl, javax.microedition.khronos.egl.EGLDisplay display, javax.microedition.khronos.egl.EGLConfig eglConfig)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createContext(
          jni.JniObject egl, jni.JniObject display, jni.JniObject eglConfig) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createContext,
          jni.JniType.objectType,
          [egl.reference, display.reference, eglConfig.reference]).object);

  static final _id_destroyContext = jniAccessors.getMethodIDOf(
      _classRef,
      "destroyContext",
      "(Ljavax/microedition/khronos/egl/EGL10;Ljavax/microedition/khronos/egl/EGLDisplay;Ljavax/microedition/khronos/egl/EGLContext;)V");

  /// from: public abstract void destroyContext(javax.microedition.khronos.egl.EGL10 egl, javax.microedition.khronos.egl.EGLDisplay display, javax.microedition.khronos.egl.EGLContext context)
  void destroyContext(
          jni.JniObject egl, jni.JniObject display, jni.JniObject context) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_destroyContext,
          jni.JniType.voidType,
          [egl.reference, display.reference, context.reference]).check();
}

/// from: android.opengl.GLSurfaceView$EGLConfigChooser
///
/// An interface for choosing an EGLConfig configuration from a list of
/// potential configurations.
///
/// This interface must be implemented by clients wishing to call
/// GLSurfaceView\#setEGLConfigChooser(EGLConfigChooser)
class GLSurfaceView_EGLConfigChooser extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/opengl/GLSurfaceView\$EGLConfigChooser");
  GLSurfaceView_EGLConfigChooser.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_chooseConfig = jniAccessors.getMethodIDOf(
      _classRef,
      "chooseConfig",
      "(Ljavax/microedition/khronos/egl/EGL10;Ljavax/microedition/khronos/egl/EGLDisplay;)Ljavax/microedition/khronos/egl/EGLConfig;");

  /// from: public abstract javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10 egl, javax.microedition.khronos.egl.EGLDisplay display)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Choose a configuration from the list. Implementors typically
  /// implement this method by calling
  /// EGL10\#eglChooseConfig and iterating through the results. Please consult the
  /// EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
  ///@param egl the EGL10 for the current display.
  ///@param display the current display.
  ///@return the chosen configuration.
  jni.JniObject chooseConfig(jni.JniObject egl, jni.JniObject display) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_chooseConfig,
          jni.JniType.objectType,
          [egl.reference, display.reference]).object);
}
