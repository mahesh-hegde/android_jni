// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.location.GnssNavigationMessage
///
/// A class containing a GNSS satellite Navigation Message.
class GnssNavigationMessage extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/location/GnssNavigationMessage");
  GnssNavigationMessage.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.location.GnssNavigationMessage> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int STATUS_PARITY_PASSED
  ///
  /// The Navigation Message was received without any parity error in its navigation words.
  static const STATUS_PARITY_PASSED = 1;

  /// from: static public final int STATUS_PARITY_REBUILT
  ///
  /// The Navigation Message was received with words that failed parity check, but the receiver was
  /// able to correct those words.
  static const STATUS_PARITY_REBUILT = 2;

  /// from: static public final int STATUS_UNKNOWN
  ///
  /// The Navigation Message Status is 'unknown'.
  static const STATUS_UNKNOWN = 0;

  /// from: static public final int TYPE_BDS_D1
  ///
  /// Beidou D1 message contained in the structure.
  static const TYPE_BDS_D1 = 1281;

  /// from: static public final int TYPE_BDS_D2
  ///
  /// Beidou D2 message contained in the structure.
  static const TYPE_BDS_D2 = 1282;

  /// from: static public final int TYPE_GAL_F
  ///
  /// Galileo F/NAV message contained in the structure.
  static const TYPE_GAL_F = 1538;

  /// from: static public final int TYPE_GAL_I
  ///
  /// Galileo I/NAV message contained in the structure.
  static const TYPE_GAL_I = 1537;

  /// from: static public final int TYPE_GLO_L1CA
  ///
  /// Glonass L1 CA message contained in the structure.
  static const TYPE_GLO_L1CA = 769;

  /// from: static public final int TYPE_GPS_CNAV2
  ///
  /// GPS CNAV-2 message contained in the structure.
  static const TYPE_GPS_CNAV2 = 260;

  /// from: static public final int TYPE_GPS_L1CA
  ///
  /// GPS L1 C/A message contained in the structure.
  static const TYPE_GPS_L1CA = 257;

  /// from: static public final int TYPE_GPS_L2CNAV
  ///
  /// GPS L2-CNAV message contained in the structure.
  static const TYPE_GPS_L2CNAV = 258;

  /// from: static public final int TYPE_GPS_L5CNAV
  ///
  /// GPS L5-CNAV message contained in the structure.
  static const TYPE_GPS_L5CNAV = 259;

  /// from: static public final int TYPE_UNKNOWN
  ///
  /// Message type unknown
  static const TYPE_UNKNOWN = 0;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()I");

  /// from: public int getType()
  ///
  /// Gets the type of the navigation message contained in the object.
  ///@return Value is android.location.GnssNavigationMessage\#TYPE_UNKNOWN, android.location.GnssNavigationMessage\#TYPE_GPS_L1CA, android.location.GnssNavigationMessage\#TYPE_GPS_L2CNAV, android.location.GnssNavigationMessage\#TYPE_GPS_L5CNAV, android.location.GnssNavigationMessage\#TYPE_GPS_CNAV2, android.location.GnssNavigationMessage\#TYPE_GLO_L1CA, android.location.GnssNavigationMessage\#TYPE_BDS_D1, android.location.GnssNavigationMessage\#TYPE_BDS_D2, android.location.GnssNavigationMessage\#TYPE_GAL_I, or android.location.GnssNavigationMessage\#TYPE_GAL_F
  int getType() => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, []).integer;

  static final _id_getSvid =
      jniAccessors.getMethodIDOf(_classRef, "getSvid", "()I");

  /// from: public int getSvid()
  ///
  /// Gets the satellite ID.
  ///
  /// Range varies by constellation.  See definition at {@code GnssStatus\#getSvid(int)}
  int getSvid() => jniAccessors.callMethodWithArgs(
      reference, _id_getSvid, jni.JniType.intType, []).integer;

  static final _id_getMessageId =
      jniAccessors.getMethodIDOf(_classRef, "getMessageId", "()I");

  /// from: public int getMessageId()
  ///
  /// Gets the Message identifier.
  ///
  /// This provides an index to help with complete Navigation Message assembly. Similar
  /// identifiers within the data bits themselves often supplement this information, in ways even
  /// more specific to each message type; see the relevant satellite constellation ICDs for
  /// details.
  ///
  /// <ul>
  /// <li> For GPS L1 C/A subframe 4 and 5, this value corresponds to the 'frame id' of the
  /// navigation message, in the range of 1-25 (Subframe 1, 2, 3 does not contain a 'frame id' and
  /// this value can be set to -1.)</li>
  /// <li> For Glonass L1 C/A, this refers to the frame ID, in the range of 1-5.</li>
  /// <li> For BeiDou D1, this refers to the frame number in the range of 1-24</li>
  /// <li> For Beidou D2, this refers to the frame number, in the range of 1-120</li>
  /// <li> For Galileo F/NAV nominal frame structure, this refers to the subframe number, in the
  /// range of 1-12</li>
  /// <li> For Galileo I/NAV nominal frame structure, this refers to the subframe number in the
  /// range of 1-24</li>
  /// </ul>
  int getMessageId() => jniAccessors.callMethodWithArgs(
      reference, _id_getMessageId, jni.JniType.intType, []).integer;

  static final _id_getSubmessageId =
      jniAccessors.getMethodIDOf(_classRef, "getSubmessageId", "()I");

  /// from: public int getSubmessageId()
  ///
  /// Gets the sub-message identifier, relevant to the \#getType() of the message.
  ///
  /// <ul>
  /// <li> For GPS L1 C/A, BeiDou D1 &amp; BeiDou D2, the submessage id corresponds to the subframe
  /// number of the navigation message, in the range of 1-5.</li>
  /// <li>For Glonass L1 C/A, this refers to the String number, in the range from 1-15</li>
  /// <li>For Galileo F/NAV, this refers to the page type in the range 1-6</li>
  /// <li>For Galileo I/NAV, this refers to the word type in the range 1-10+</li>
  /// <li>For Galileo in particular, the type information embedded within the data bits may be even
  /// more useful in interpretation, than the nominal page and word types provided in this
  /// field.</li>
  /// </ul>
  int getSubmessageId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSubmessageId, jni.JniType.intType, []).integer;

  static final _id_getData =
      jniAccessors.getMethodIDOf(_classRef, "getData", "()[B");

  /// from: public byte[] getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the data of the reported GPS message.
  ///
  /// The bytes (or words) specified using big endian format (MSB first).
  ///
  /// <ul>
  /// <li>For GPS L1 C/A, Beidou D1 &amp; Beidou D2, each subframe contains 10 30-bit words. Each
  /// word (30 bits) should be fit into the last 30 bits in a 4-byte word (skip B31 and B32), with
  /// MSB first, for a total of 40 bytes, covering a time period of 6, 6, and 0.6 seconds,
  /// respectively.</li>
  /// <li>For Glonass L1 C/A, each string contains 85 data bits, including the checksum.  These
  /// bits should be fit into 11 bytes, with MSB first (skip B86-B88), covering a time period of 2
  /// seconds.</li>
  /// <li>For Galileo F/NAV, each word consists of 238-bit (sync &amp; tail symbols excluded). Each
  /// word should be fit into 30-bytes, with MSB first (skip B239, B240), covering a time period of
  /// 10 seconds.</li>
  /// <li>For Galileo I/NAV, each page contains 2 page parts, even and odd, with a total of 2x114 =
  /// 228 bits, (sync &amp; tail excluded) that should be fit into 29 bytes, with MSB first (skip
  /// B229-B232).</li>
  /// </ul>
  ///@return This value will never be {@code null}.
  jni.JniObject getData() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getData, jni.JniType.objectType, []).object);

  static final _id_getStatus =
      jniAccessors.getMethodIDOf(_classRef, "getStatus", "()I");

  /// from: public int getStatus()
  ///
  /// Gets the Status of the navigation message contained in the object.
  int getStatus() => jniAccessors.callMethodWithArgs(
      reference, _id_getStatus, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(parcel_.Parcel parcel, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [parcel.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.location.GnssNavigationMessage$Callback
///
/// Used for receiving GNSS satellite Navigation Messages from the GNSS engine.
///
/// You can implement this interface and call
/// LocationManager\#registerGnssNavigationMessageCallback.
class GnssNavigationMessage_Callback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/location/GnssNavigationMessage\$Callback");
  GnssNavigationMessage_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int STATUS_LOCATION_DISABLED
  ///
  /// GNSS provider or Location is disabled, updated will not be received until they are
  /// enabled.
  static const STATUS_LOCATION_DISABLED = 2;

  /// from: static public final int STATUS_NOT_SUPPORTED
  ///
  /// The system does not support tracking of GNSS Navigation Messages.
  ///
  /// This status will not change in the future.
  static const STATUS_NOT_SUPPORTED = 0;

  /// from: static public final int STATUS_READY
  ///
  /// GNSS Navigation Messages are successfully being tracked, it will receive updates once
  /// they are available.
  static const STATUS_READY = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GnssNavigationMessage_Callback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onGnssNavigationMessageReceived = jniAccessors.getMethodIDOf(
      _classRef,
      "onGnssNavigationMessageReceived",
      "(Landroid/location/GnssNavigationMessage;)V");

  /// from: public void onGnssNavigationMessageReceived(android.location.GnssNavigationMessage event)
  ///
  /// Returns the latest collected GNSS Navigation Message.
  void onGnssNavigationMessageReceived(GnssNavigationMessage event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onGnssNavigationMessageReceived,
          jni.JniType.voidType,
          [event.reference]).check();

  static final _id_onStatusChanged =
      jniAccessors.getMethodIDOf(_classRef, "onStatusChanged", "(I)V");

  /// from: public void onStatusChanged(int status)
  ///
  /// Returns the latest status of the GNSS Navigation Messages sub-system.
  ///@param status Value is android.location.GnssNavigationMessage.Callback\#STATUS_NOT_SUPPORTED, android.location.GnssNavigationMessage.Callback\#STATUS_READY, or android.location.GnssNavigationMessage.Callback\#STATUS_LOCATION_DISABLED
  void onStatusChanged(int status) => jniAccessors.callMethodWithArgs(
      reference, _id_onStatusChanged, jni.JniType.voidType, [status]).check();
}
