// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "LocationProvider.dart" as locationprovider_;

import "Criteria.dart" as criteria_;

import "LocationListener.dart" as locationlistener_;

import "../os/Looper.dart" as looper_;

import "../app/PendingIntent.dart" as pendingintent_;

import "Location.dart" as location_;

import "../os/Bundle.dart" as bundle_;

import "GpsStatus.dart" as gpsstatus_;

import "GnssStatus.dart" as gnssstatus_;

import "../os/Handler.dart" as handler_;

import "OnNmeaMessageListener.dart" as onnmeamessagelistener_;

import "GnssMeasurementsEvent.dart" as gnssmeasurementsevent_;

import "GnssNavigationMessage.dart" as gnssnavigationmessage_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.location.LocationManager
///
/// This class provides access to the system location services.  These
/// services allow applications to obtain periodic updates of the
/// device's geographical location, or to fire an application-specified
/// Intent when the device enters the proximity of a given
/// geographical location.
///
/// <p class="note">Unless noted, all Location API methods require
/// the android.Manifest.permission\#ACCESS_COARSE_LOCATION or
/// android.Manifest.permission\#ACCESS_FINE_LOCATION permissions.
/// If your application only has the coarse permission then it will not have
/// access to the GPS or passive location providers. Other providers will still
/// return location results, but the update rate will be throttled and the exact
/// location will be obfuscated to a coarse level of accuracy.
///
/// Requires the android.content.pm.PackageManager\#FEATURE_LOCATION PackageManager\#FEATURE_LOCATION feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
class LocationManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/location/LocationManager");
  LocationManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String GPS_PROVIDER
  ///
  /// Name of the GPS location provider.
  ///
  /// This provider determines location using
  /// satellites. Depending on conditions, this provider may take a while to return
  /// a location fix. Requires the permission
  /// android.Manifest.permission\#ACCESS_FINE_LOCATION.
  ///
  ///  The extras Bundle for the GPS location provider can contain the
  /// following key/value pairs:
  /// <ul>
  /// <li> satellites - the number of satellites used to derive the fix
  /// </ul>
  static const GPS_PROVIDER = "gps";

  /// from: static public final java.lang.String KEY_LOCATION_CHANGED
  ///
  /// Key used for a Bundle extra holding a Location value
  /// when a location change is broadcast using a PendingIntent.
  static const KEY_LOCATION_CHANGED = "location";

  /// from: static public final java.lang.String KEY_PROVIDER_ENABLED
  ///
  /// Key used for a Bundle extra holding an Boolean status value
  /// when a provider enabled/disabled event is broadcast using a PendingIntent.
  static const KEY_PROVIDER_ENABLED = "providerEnabled";

  /// from: static public final java.lang.String KEY_PROXIMITY_ENTERING
  ///
  /// Key used for the Bundle extra holding a boolean indicating whether
  /// a proximity alert is entering (true) or exiting (false)..
  static const KEY_PROXIMITY_ENTERING = "entering";

  /// from: static public final java.lang.String KEY_STATUS_CHANGED
  ///
  /// Key used for a Bundle extra holding an Integer status value
  /// when a status change is broadcast using a PendingIntent.
  static const KEY_STATUS_CHANGED = "status";

  /// from: static public final java.lang.String MODE_CHANGED_ACTION
  ///
  /// Broadcast intent action when android.provider.Settings.Secure\#LOCATION_MODE changes.
  /// For use with the android.provider.Settings.Secure\#LOCATION_MODE API.
  /// If you're interacting with \#isProviderEnabled(String), use
  /// \#PROVIDERS_CHANGED_ACTION instead.
  ///
  /// In the future, there may be mode changes that do not result in
  /// \#PROVIDERS_CHANGED_ACTION broadcasts.
  static const MODE_CHANGED_ACTION = "android.location.MODE_CHANGED";

  /// from: static public final java.lang.String NETWORK_PROVIDER
  ///
  /// Name of the network location provider.
  /// This provider determines location based on
  /// availability of cell tower and WiFi access points. Results are retrieved
  /// by means of a network lookup.
  static const NETWORK_PROVIDER = "network";

  /// from: static public final java.lang.String PASSIVE_PROVIDER
  ///
  /// A special location provider for receiving locations without actually initiating
  /// a location fix.
  ///
  /// This provider can be used to passively receive location updates
  /// when other applications or services request them without actually requesting
  /// the locations yourself.  This provider will return locations generated by other
  /// providers.  You can query the Location\#getProvider() method to determine
  /// the origin of the location update. Requires the permission
  /// android.Manifest.permission\#ACCESS_FINE_LOCATION, although if the GPS is
  /// not enabled this provider might only return coarse fixes.
  static const PASSIVE_PROVIDER = "passive";

  /// from: static public final java.lang.String PROVIDERS_CHANGED_ACTION
  ///
  /// Broadcast intent action when the configured location providers
  /// change. For use with \#isProviderEnabled(String). If you're interacting with the
  /// android.provider.Settings.Secure\#LOCATION_MODE API, use \#MODE_CHANGED_ACTION
  /// instead.
  static const PROVIDERS_CHANGED_ACTION = "android.location.PROVIDERS_CHANGED";

  static final _id_getAllProviders = jniAccessors.getMethodIDOf(
      _classRef, "getAllProviders", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getAllProviders()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of the names of all known location providers.
  /// All providers are returned, including ones that are not permitted to
  /// be accessed by the calling activity or are currently disabled.
  ///@return list of Strings containing names of the provider
  jni.JniObject getAllProviders() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllProviders, jni.JniType.objectType, []).object);

  static final _id_getProviders = jniAccessors.getMethodIDOf(
      _classRef, "getProviders", "(Z)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getProviders(boolean enabledOnly)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of the names of location providers.
  ///@param enabledOnly if true then only the providers which are currently
  /// enabled are returned.
  ///@return list of Strings containing names of the providers
  jni.JniObject getProviders(bool enabledOnly) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getProviders, jni.JniType.objectType, [enabledOnly]).object);

  static final _id_getProvider = jniAccessors.getMethodIDOf(_classRef,
      "getProvider", "(Ljava/lang/String;)Landroid/location/LocationProvider;");

  /// from: public android.location.LocationProvider getProvider(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the information associated with the location provider of the
  /// given name, or null if no provider exists by that name.
  ///@param name the provider name
  ///@return a LocationProvider, or null
  ///@throws IllegalArgumentException if name is null or does not exist
  ///@throws SecurityException if the caller is not permitted to access the
  /// given provider.
  locationprovider_.LocationProvider getProvider(jni.JniString name) =>
      locationprovider_.LocationProvider.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getProvider,
              jni.JniType.objectType, [name.reference]).object);

  static final _id_getProviders1 = jniAccessors.getMethodIDOf(_classRef,
      "getProviders", "(Landroid/location/Criteria;Z)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getProviders(android.location.Criteria criteria, boolean enabledOnly)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of the names of LocationProviders that satisfy the given
  /// criteria, or null if none do.  Only providers that are permitted to be
  /// accessed by the calling activity will be returned.
  ///@param criteria the criteria that the returned providers must match
  ///@param enabledOnly if true then only the providers which are currently
  /// enabled are returned.
  ///@return list of Strings containing names of the providers
  jni.JniObject getProviders1(criteria_.Criteria criteria, bool enabledOnly) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getProviders1,
          jni.JniType.objectType,
          [criteria.reference, enabledOnly]).object);

  static final _id_getBestProvider = jniAccessors.getMethodIDOf(_classRef,
      "getBestProvider", "(Landroid/location/Criteria;Z)Ljava/lang/String;");

  /// from: public java.lang.String getBestProvider(android.location.Criteria criteria, boolean enabledOnly)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of the provider that best meets the given criteria. Only providers
  /// that are permitted to be accessed by the calling activity will be
  /// returned.  If several providers meet the criteria, the one with the best
  /// accuracy is returned.  If no provider meets the criteria,
  /// the criteria are loosened in the following sequence:
  ///
  /// <ul>
  /// <li> power requirement
  /// <li> accuracy
  /// <li> bearing
  /// <li> speed
  /// <li> altitude
  /// </ul>
  ///
  ///  Note that the requirement on monetary cost is not removed
  /// in this process.
  ///@param criteria the criteria that need to be matched
  ///@param enabledOnly if true then only a provider that is currently enabled is returned
  ///@return name of the provider that best matches the requirements
  jni.JniString getBestProvider(
          criteria_.Criteria criteria, bool enabledOnly) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBestProvider,
          jni.JniType.objectType,
          [criteria.reference, enabledOnly]).object);

  static final _id_requestLocationUpdates = jniAccessors.getMethodIDOf(
      _classRef,
      "requestLocationUpdates",
      "(Ljava/lang/String;JFLandroid/location/LocationListener;)V");

  /// from: public void requestLocationUpdates(java.lang.String provider, long minTime, float minDistance, android.location.LocationListener listener)
  ///
  /// Register for location updates using the named provider, and a
  /// pending intent.
  ///
  /// See \#requestLocationUpdates(long, float, Criteria, PendingIntent)
  /// for more detail on how to use this method.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param provider the name of the provider with which to register
  ///@param minTime minimum time interval between location updates, in milliseconds
  ///@param minDistance minimum distance between location updates, in meters
  ///@param listener a LocationListener whose
  /// LocationListener\#onLocationChanged method will be called for
  /// each location update
  ///@throws IllegalArgumentException if provider is null or doesn't exist
  /// on this device
  ///@throws IllegalArgumentException if listener is null
  ///@throws RuntimeException if the calling thread has no Looper
  ///@throws SecurityException if no suitable permission is present
  void requestLocationUpdates(jni.JniString provider, int minTime,
          double minDistance, locationlistener_.LocationListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_requestLocationUpdates, jni.JniType.voidType, [
        provider.reference,
        minTime,
        minDistance,
        listener.reference
      ]).check();

  static final _id_requestLocationUpdates1 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestLocationUpdates",
      "(Ljava/lang/String;JFLandroid/location/LocationListener;Landroid/os/Looper;)V");

  /// from: public void requestLocationUpdates(java.lang.String provider, long minTime, float minDistance, android.location.LocationListener listener, android.os.Looper looper)
  ///
  /// Register for location updates using the named provider, and a callback on
  /// the specified looper thread.
  ///
  /// See \#requestLocationUpdates(long, float, Criteria, PendingIntent)
  /// for more detail on how to use this method.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param provider the name of the provider with which to register
  ///@param minTime minimum time interval between location updates, in milliseconds
  ///@param minDistance minimum distance between location updates, in meters
  ///@param listener a LocationListener whose
  /// LocationListener\#onLocationChanged method will be called for
  /// each location update
  ///@param looper a Looper object whose message queue will be used to
  /// implement the callback mechanism, or null to make callbacks on the calling
  /// thread
  ///@throws IllegalArgumentException if provider is null or doesn't exist
  ///@throws IllegalArgumentException if listener is null
  ///@throws SecurityException if no suitable permission is present
  void requestLocationUpdates1(
          jni.JniString provider,
          int minTime,
          double minDistance,
          locationlistener_.LocationListener listener,
          looper_.Looper looper) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_requestLocationUpdates1, jni.JniType.voidType, [
        provider.reference,
        minTime,
        minDistance,
        listener.reference,
        looper.reference
      ]).check();

  static final _id_requestLocationUpdates2 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestLocationUpdates",
      "(JFLandroid/location/Criteria;Landroid/location/LocationListener;Landroid/os/Looper;)V");

  /// from: public void requestLocationUpdates(long minTime, float minDistance, android.location.Criteria criteria, android.location.LocationListener listener, android.os.Looper looper)
  ///
  /// Register for location updates using a Criteria, and a callback
  /// on the specified looper thread.
  ///
  /// See \#requestLocationUpdates(long, float, Criteria, PendingIntent)
  /// for more detail on how to use this method.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param minTime minimum time interval between location updates, in milliseconds
  ///@param minDistance minimum distance between location updates, in meters
  ///@param criteria contains parameters for the location manager to choose the
  /// appropriate provider and parameters to compute the location
  ///@param listener a LocationListener whose
  /// LocationListener\#onLocationChanged method will be called for
  /// each location update
  ///@param looper a Looper object whose message queue will be used to
  /// implement the callback mechanism, or null to make callbacks on the calling
  /// thread
  ///@throws IllegalArgumentException if criteria is null
  ///@throws IllegalArgumentException if listener is null
  ///@throws SecurityException if no suitable permission is present
  void requestLocationUpdates2(
          int minTime,
          double minDistance,
          criteria_.Criteria criteria,
          locationlistener_.LocationListener listener,
          looper_.Looper looper) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_requestLocationUpdates2, jni.JniType.voidType, [
        minTime,
        minDistance,
        criteria.reference,
        listener.reference,
        looper.reference
      ]).check();

  static final _id_requestLocationUpdates3 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestLocationUpdates",
      "(Ljava/lang/String;JFLandroid/app/PendingIntent;)V");

  /// from: public void requestLocationUpdates(java.lang.String provider, long minTime, float minDistance, android.app.PendingIntent intent)
  ///
  /// Register for location updates using the named provider, and a
  /// pending intent.
  ///
  /// See \#requestLocationUpdates(long, float, Criteria, PendingIntent)
  /// for more detail on how to use this method.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param provider the name of the provider with which to register
  ///@param minTime minimum time interval between location updates, in milliseconds
  ///@param minDistance minimum distance between location updates, in meters
  ///@param intent a PendingIntent to be sent for each location update
  ///@throws IllegalArgumentException if provider is null or doesn't exist
  /// on this device
  ///@throws IllegalArgumentException if intent is null
  ///@throws SecurityException if no suitable permission is present
  void requestLocationUpdates3(jni.JniString provider, int minTime,
          double minDistance, pendingintent_.PendingIntent intent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestLocationUpdates3,
          jni.JniType.voidType,
          [provider.reference, minTime, minDistance, intent.reference]).check();

  static final _id_requestLocationUpdates4 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestLocationUpdates",
      "(JFLandroid/location/Criteria;Landroid/app/PendingIntent;)V");

  /// from: public void requestLocationUpdates(long minTime, float minDistance, android.location.Criteria criteria, android.app.PendingIntent intent)
  ///
  /// Register for location updates using a Criteria and pending intent.
  ///
  /// The <code>requestLocationUpdates()</code> and
  /// <code>requestSingleUpdate()</code> register the current activity to be
  /// updated periodically by the named provider, or by the provider matching
  /// the specified Criteria, with location and status updates.
  ///
  ///  It may take a while to receive the first location update. If
  /// an immediate location is required, applications may use the
  /// \#getLastKnownLocation(String) method.
  ///
  ///  Location updates are received either by LocationListener
  /// callbacks, or by broadcast intents to a supplied PendingIntent.
  ///
  ///  If the caller supplied a pending intent, then location updates
  /// are sent with a key of \#KEY_LOCATION_CHANGED and a
  /// android.location.Location value.
  ///
  ///  The location update interval can be controlled using the minTime parameter.
  /// The elapsed time between location updates will never be less than
  /// minTime, although it can be more depending on the Location Provider
  /// implementation and the update interval requested by other applications.
  ///
  ///  Choosing a sensible value for minTime is important to conserve
  /// battery life. Each location update requires power from
  /// GPS, WIFI, Cell and other radios. Select a minTime value as high as
  /// possible while still providing a reasonable user experience.
  /// If your application is not in the foreground and showing
  /// location to the user then your application should avoid using an active
  /// provider (such as \#NETWORK_PROVIDER or \#GPS_PROVIDER),
  /// but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes)
  /// or greater. If your application is in the foreground and showing
  /// location to the user then it is appropriate to select a faster
  /// update interval.
  ///
  ///  The minDistance parameter can also be used to control the
  /// frequency of location updates. If it is greater than 0 then the
  /// location provider will only send your application an update when
  /// the location has changed by at least minDistance meters, AND
  /// at least minTime milliseconds have passed. However it is more
  /// difficult for location providers to save power using the minDistance
  /// parameter, so minTime should be the primary tool to conserving battery
  /// life.
  ///
  ///  If your application wants to passively observe location
  /// updates triggered by other applications, but not consume
  /// any additional power otherwise, then use the \#PASSIVE_PROVIDER
  /// This provider does not actively turn on or modify active location
  /// providers, so you do not need to be as careful about minTime and
  /// minDistance. However if your application performs heavy work
  /// on a location update (such as network activity) then you should
  /// select non-zero values for minTime and/or minDistance to rate-limit
  /// your update frequency in the case another application enables a
  /// location provider with extremely fast updates.
  ///
  /// In case the provider is disabled by the user, updates will stop,
  /// and a provider availability update will be sent.
  /// As soon as the provider is enabled again,
  /// location updates will immediately resume and a provider availability
  /// update sent. Providers can also send status updates, at any time,
  /// with extra's specific to the provider. If a callback was supplied
  /// then status and availability updates are via
  /// LocationListener\#onProviderDisabled,
  /// LocationListener\#onProviderEnabled or
  /// LocationListener\#onStatusChanged. Alternately, if a
  /// pending intent was supplied then status and availability updates
  /// are broadcast intents with extra keys of
  /// \#KEY_PROVIDER_ENABLED or \#KEY_STATUS_CHANGED.
  ///
  ///  If a LocationListener is used but with no Looper specified
  /// then the calling thread must already
  /// be a android.os.Looper thread such as the main thread of the
  /// calling Activity. If a Looper is specified with a LocationListener
  /// then callbacks are made on the supplied Looper thread.
  ///
  /// <p class="note"> Prior to Jellybean, the minTime parameter was
  /// only a hint, and some location provider implementations ignored it.
  /// From Jellybean and onwards it is mandatory for Android compatible
  /// devices to observe both the minTime and minDistance parameters.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param minTime minimum time interval between location updates, in milliseconds
  ///@param minDistance minimum distance between location updates, in meters
  ///@param criteria contains parameters for the location manager to choose the
  /// appropriate provider and parameters to compute the location
  ///@param intent a PendingIntent to be sent for each location update
  ///@throws IllegalArgumentException if criteria is null
  ///@throws IllegalArgumentException if intent is null
  ///@throws SecurityException if no suitable permission is present
  void requestLocationUpdates4(int minTime, double minDistance,
          criteria_.Criteria criteria, pendingintent_.PendingIntent intent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestLocationUpdates4,
          jni.JniType.voidType,
          [minTime, minDistance, criteria.reference, intent.reference]).check();

  static final _id_requestSingleUpdate = jniAccessors.getMethodIDOf(
      _classRef,
      "requestSingleUpdate",
      "(Ljava/lang/String;Landroid/location/LocationListener;Landroid/os/Looper;)V");

  /// from: public void requestSingleUpdate(java.lang.String provider, android.location.LocationListener listener, android.os.Looper looper)
  ///
  /// Register for a single location update using the named provider and
  /// a callback.
  ///
  /// See \#requestLocationUpdates(long, float, Criteria, PendingIntent)
  /// for more detail on how to use this method.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param provider the name of the provider with which to register
  ///@param listener a LocationListener whose
  /// LocationListener\#onLocationChanged method will be called when
  /// the location update is available
  ///@param looper a Looper object whose message queue will be used to
  /// implement the callback mechanism, or null to make callbacks on the calling
  /// thread
  ///@throws IllegalArgumentException if provider is null or doesn't exist
  ///@throws IllegalArgumentException if listener is null
  ///@throws SecurityException if no suitable permission is present
  void requestSingleUpdate(jni.JniString provider,
          locationlistener_.LocationListener listener, looper_.Looper looper) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestSingleUpdate,
          jni.JniType.voidType,
          [provider.reference, listener.reference, looper.reference]).check();

  static final _id_requestSingleUpdate1 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestSingleUpdate",
      "(Landroid/location/Criteria;Landroid/location/LocationListener;Landroid/os/Looper;)V");

  /// from: public void requestSingleUpdate(android.location.Criteria criteria, android.location.LocationListener listener, android.os.Looper looper)
  ///
  /// Register for a single location update using a Criteria and
  /// a callback.
  ///
  /// See \#requestLocationUpdates(long, float, Criteria, PendingIntent)
  /// for more detail on how to use this method.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param criteria contains parameters for the location manager to choose the
  /// appropriate provider and parameters to compute the location
  ///@param listener a LocationListener whose
  /// LocationListener\#onLocationChanged method will be called when
  /// the location update is available
  ///@param looper a Looper object whose message queue will be used to
  /// implement the callback mechanism, or null to make callbacks on the calling
  /// thread
  ///@throws IllegalArgumentException if criteria is null
  ///@throws IllegalArgumentException if listener is null
  ///@throws SecurityException if no suitable permission is present
  void requestSingleUpdate1(criteria_.Criteria criteria,
          locationlistener_.LocationListener listener, looper_.Looper looper) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestSingleUpdate1,
          jni.JniType.voidType,
          [criteria.reference, listener.reference, looper.reference]).check();

  static final _id_requestSingleUpdate2 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestSingleUpdate",
      "(Ljava/lang/String;Landroid/app/PendingIntent;)V");

  /// from: public void requestSingleUpdate(java.lang.String provider, android.app.PendingIntent intent)
  ///
  /// Register for a single location update using a named provider and pending intent.
  ///
  /// See \#requestLocationUpdates(long, float, Criteria, PendingIntent)
  /// for more detail on how to use this method.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param provider the name of the provider with which to register
  ///@param intent a PendingIntent to be sent for the location update
  ///@throws IllegalArgumentException if provider is null or doesn't exist
  ///@throws IllegalArgumentException if intent is null
  ///@throws SecurityException if no suitable permission is present
  void requestSingleUpdate2(
          jni.JniString provider, pendingintent_.PendingIntent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestSingleUpdate2,
          jni.JniType.voidType, [provider.reference, intent.reference]).check();

  static final _id_requestSingleUpdate3 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestSingleUpdate",
      "(Landroid/location/Criteria;Landroid/app/PendingIntent;)V");

  /// from: public void requestSingleUpdate(android.location.Criteria criteria, android.app.PendingIntent intent)
  ///
  /// Register for a single location update using a Criteria and pending intent.
  ///
  /// See \#requestLocationUpdates(long, float, Criteria, PendingIntent)
  /// for more detail on how to use this method.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param criteria contains parameters for the location manager to choose the
  /// appropriate provider and parameters to compute the location
  ///@param intent a PendingIntent to be sent for the location update
  ///@throws IllegalArgumentException if provider is null or doesn't exist
  ///@throws IllegalArgumentException if intent is null
  ///@throws SecurityException if no suitable permission is present
  void requestSingleUpdate3(
          criteria_.Criteria criteria, pendingintent_.PendingIntent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestSingleUpdate3,
          jni.JniType.voidType, [criteria.reference, intent.reference]).check();

  static final _id_removeUpdates = jniAccessors.getMethodIDOf(
      _classRef, "removeUpdates", "(Landroid/location/LocationListener;)V");

  /// from: public void removeUpdates(android.location.LocationListener listener)
  ///
  /// Removes all location updates for the specified LocationListener.
  ///
  /// Following this call, updates will no longer
  /// occur for this listener.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param listener listener object that no longer needs location updates
  ///@throws IllegalArgumentException if listener is null
  void removeUpdates(locationlistener_.LocationListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeUpdates,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_removeUpdates1 = jniAccessors.getMethodIDOf(
      _classRef, "removeUpdates", "(Landroid/app/PendingIntent;)V");

  /// from: public void removeUpdates(android.app.PendingIntent intent)
  ///
  /// Removes all location updates for the specified pending intent.
  ///
  /// Following this call, updates will no longer for this pending intent.
  ///@param intent pending intent object that no longer needs location updates
  ///@throws IllegalArgumentException if intent is null
  void removeUpdates1(pendingintent_.PendingIntent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeUpdates1,
          jni.JniType.voidType, [intent.reference]).check();

  static final _id_addProximityAlert = jniAccessors.getMethodIDOf(
      _classRef, "addProximityAlert", "(DDFJLandroid/app/PendingIntent;)V");

  /// from: public void addProximityAlert(double latitude, double longitude, float radius, long expiration, android.app.PendingIntent intent)
  ///
  /// Set a proximity alert for the location given by the position
  /// (latitude, longitude) and the given radius.
  ///
  ///  When the device
  /// detects that it has entered or exited the area surrounding the
  /// location, the given PendingIntent will be used to create an Intent
  /// to be fired.
  ///
  ///  The fired Intent will have a boolean extra added with key
  /// \#KEY_PROXIMITY_ENTERING. If the value is true, the device is
  /// entering the proximity region; if false, it is exiting.
  ///
  ///  Due to the approximate nature of position estimation, if the
  /// device passes through the given area briefly, it is possible
  /// that no Intent will be fired.  Similarly, an Intent could be
  /// fired if the device passes very close to the given area but
  /// does not actually enter it.
  ///
  ///  After the number of milliseconds given by the expiration
  /// parameter, the location manager will delete this proximity
  /// alert and no longer monitor it.  A value of -1 indicates that
  /// there should be no expiration time.
  ///
  ///  Internally, this method uses both \#NETWORK_PROVIDER
  /// and \#GPS_PROVIDER.
  ///
  /// Before API version 17, this method could be used with
  /// android.Manifest.permission\#ACCESS_FINE_LOCATION or
  /// android.Manifest.permission\#ACCESS_COARSE_LOCATION.
  /// From API version 17 and onwards, this method requires
  /// android.Manifest.permission\#ACCESS_FINE_LOCATION permission.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param latitude the latitude of the central point of the
  /// alert region
  ///@param longitude the longitude of the central point of the
  /// alert region
  ///@param radius the radius of the central point of the
  /// alert region, in meters
  ///@param expiration time for this proximity alert, in milliseconds,
  /// or -1 to indicate no expiration
  ///@param intent a PendingIntent that will be used to generate an Intent to
  /// fire when entry to or exit from the alert region is detected
  ///@throws SecurityException if android.Manifest.permission\#ACCESS_FINE_LOCATION
  /// permission is not present
  void addProximityAlert(double latitude, double longitude, double radius,
          int expiration, pendingintent_.PendingIntent intent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addProximityAlert,
          jni.JniType.voidType,
          [latitude, longitude, radius, expiration, intent.reference]).check();

  static final _id_removeProximityAlert = jniAccessors.getMethodIDOf(
      _classRef, "removeProximityAlert", "(Landroid/app/PendingIntent;)V");

  /// from: public void removeProximityAlert(android.app.PendingIntent intent)
  ///
  /// Removes the proximity alert with the given PendingIntent.
  ///
  /// Before API version 17, this method could be used with
  /// android.Manifest.permission\#ACCESS_FINE_LOCATION or
  /// android.Manifest.permission\#ACCESS_COARSE_LOCATION.
  /// From API version 17 and onwards, this method requires
  /// android.Manifest.permission\#ACCESS_FINE_LOCATION permission.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param intent the PendingIntent that no longer needs to be notified of
  /// proximity alerts
  ///@throws IllegalArgumentException if intent is null
  ///@throws SecurityException if android.Manifest.permission\#ACCESS_FINE_LOCATION
  /// permission is not present
  void removeProximityAlert(pendingintent_.PendingIntent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeProximityAlert,
          jni.JniType.voidType, [intent.reference]).check();

  static final _id_isLocationEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isLocationEnabled", "()Z");

  /// from: public boolean isLocationEnabled()
  ///
  /// Returns the current enabled/disabled status of location
  ///@return true if location is enabled. false if location is disabled.
  bool isLocationEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isLocationEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_isProviderEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isProviderEnabled", "(Ljava/lang/String;)Z");

  /// from: public boolean isProviderEnabled(java.lang.String provider)
  ///
  /// Returns the current enabled/disabled status of the given provider.
  ///
  /// If the user has enabled this provider in the Settings menu, true
  /// is returned otherwise false is returned
  ///
  /// Callers should instead use \#isLocationEnabled()
  /// unless they depend on provider-specific APIs such as
  /// \#requestLocationUpdates(String, long, float, LocationListener).
  ///
  ///
  /// Before API version android.os.Build.VERSION_CODES\#LOLLIPOP, this
  /// method would throw SecurityException if the location permissions
  /// were not sufficient to use the specified provider.
  ///@param provider the name of the provider
  ///@return true if the provider exists and is enabled
  ///@throws IllegalArgumentException if provider is null
  bool isProviderEnabled(jni.JniString provider) =>
      jniAccessors.callMethodWithArgs(reference, _id_isProviderEnabled,
          jni.JniType.booleanType, [provider.reference]).boolean;

  static final _id_getLastKnownLocation = jniAccessors.getMethodIDOf(
      _classRef,
      "getLastKnownLocation",
      "(Ljava/lang/String;)Landroid/location/Location;");

  /// from: public android.location.Location getLastKnownLocation(java.lang.String provider)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Location indicating the data from the last known
  /// location fix obtained from the given provider.
  ///
  ///  This can be done
  /// without starting the provider.  Note that this location could
  /// be out-of-date, for example if the device was turned off and
  /// moved to another location.
  ///
  ///  If the provider is currently disabled, null is returned.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param provider the name of the provider
  ///@return the last known location for the provider, or null
  ///@throws SecurityException if no suitable permission is present
  ///@throws IllegalArgumentException if provider is null or doesn't exist
  location_.Location getLastKnownLocation(jni.JniString provider) =>
      location_.Location.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLastKnownLocation,
          jni.JniType.objectType,
          [provider.reference]).object);

  static final _id_addTestProvider = jniAccessors.getMethodIDOf(
      _classRef, "addTestProvider", "(Ljava/lang/String;ZZZZZZZII)V");

  /// from: public void addTestProvider(java.lang.String name, boolean requiresNetwork, boolean requiresSatellite, boolean requiresCell, boolean hasMonetaryCost, boolean supportsAltitude, boolean supportsSpeed, boolean supportsBearing, int powerRequirement, int accuracy)
  ///
  /// Creates a mock location provider and adds it to the set of active providers.
  ///@param name the provider name
  ///@throws SecurityException if android.app.AppOpsManager\#OPSTR_MOCK_LOCATION mock location app op is not set to android.app.AppOpsManager\#MODE_ALLOWED allowed for your app.
  ///@throws IllegalArgumentException if a provider with the given name already exists
  void addTestProvider(
          jni.JniString name,
          bool requiresNetwork,
          bool requiresSatellite,
          bool requiresCell,
          bool hasMonetaryCost,
          bool supportsAltitude,
          bool supportsSpeed,
          bool supportsBearing,
          int powerRequirement,
          int accuracy) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_addTestProvider, jni.JniType.voidType, [
        name.reference,
        requiresNetwork,
        requiresSatellite,
        requiresCell,
        hasMonetaryCost,
        supportsAltitude,
        supportsSpeed,
        supportsBearing,
        powerRequirement,
        accuracy
      ]).check();

  static final _id_removeTestProvider = jniAccessors.getMethodIDOf(
      _classRef, "removeTestProvider", "(Ljava/lang/String;)V");

  /// from: public void removeTestProvider(java.lang.String provider)
  ///
  /// Removes the mock location provider with the given name.
  ///@param provider the provider name
  ///@throws SecurityException if android.app.AppOpsManager\#OPSTR_MOCK_LOCATION mock location app op is not set to android.app.AppOpsManager\#MODE_ALLOWED allowed for your app.
  ///@throws IllegalArgumentException if no provider with the given name exists
  void removeTestProvider(jni.JniString provider) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeTestProvider,
          jni.JniType.voidType, [provider.reference]).check();

  static final _id_setTestProviderLocation = jniAccessors.getMethodIDOf(
      _classRef,
      "setTestProviderLocation",
      "(Ljava/lang/String;Landroid/location/Location;)V");

  /// from: public void setTestProviderLocation(java.lang.String provider, android.location.Location loc)
  ///
  /// Sets a mock location for the given provider.
  /// This location will be used in place of any actual location from the provider.
  /// The location object must have a minimum number of fields set to be
  /// considered a valid LocationProvider Location, as per documentation
  /// on Location class.
  ///@param provider the provider name
  ///@param loc the mock location
  ///@throws SecurityException if android.app.AppOpsManager\#OPSTR_MOCK_LOCATION mock location app op is not set to android.app.AppOpsManager\#MODE_ALLOWED allowed for your app.
  ///@throws IllegalArgumentException if no provider with the given name exists
  ///@throws IllegalArgumentException if the location is incomplete
  void setTestProviderLocation(
          jni.JniString provider, location_.Location loc) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTestProviderLocation,
          jni.JniType.voidType, [provider.reference, loc.reference]).check();

  static final _id_clearTestProviderLocation = jniAccessors.getMethodIDOf(
      _classRef, "clearTestProviderLocation", "(Ljava/lang/String;)V");

  /// from: public void clearTestProviderLocation(java.lang.String provider)
  ///
  /// Removes any mock location associated with the given provider.
  ///@param provider the provider name
  ///@throws SecurityException if android.app.AppOpsManager\#OPSTR_MOCK_LOCATION mock location app op is not set to android.app.AppOpsManager\#MODE_ALLOWED allowed for your app.
  ///@throws IllegalArgumentException if no provider with the given name exists
  void clearTestProviderLocation(jni.JniString provider) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearTestProviderLocation,
          jni.JniType.voidType, [provider.reference]).check();

  static final _id_setTestProviderEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setTestProviderEnabled", "(Ljava/lang/String;Z)V");

  /// from: public void setTestProviderEnabled(java.lang.String provider, boolean enabled)
  ///
  /// Sets a mock enabled value for the given provider.  This value will be used in place
  /// of any actual value from the provider.
  ///@param provider the provider name
  ///@param enabled the mock enabled value
  ///@throws SecurityException if android.app.AppOpsManager\#OPSTR_MOCK_LOCATION mock location app op is not set to android.app.AppOpsManager\#MODE_ALLOWED allowed for your app.
  ///@throws IllegalArgumentException if no provider with the given name exists
  void setTestProviderEnabled(jni.JniString provider, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTestProviderEnabled,
          jni.JniType.voidType, [provider.reference, enabled]).check();

  static final _id_clearTestProviderEnabled = jniAccessors.getMethodIDOf(
      _classRef, "clearTestProviderEnabled", "(Ljava/lang/String;)V");

  /// from: public void clearTestProviderEnabled(java.lang.String provider)
  ///
  /// Removes any mock enabled value associated with the given provider.
  ///@param provider the provider name
  ///@throws SecurityException if android.app.AppOpsManager\#OPSTR_MOCK_LOCATION mock location app op is not set to android.app.AppOpsManager\#MODE_ALLOWED allowed for your app.
  ///@throws IllegalArgumentException if no provider with the given name exists
  void clearTestProviderEnabled(jni.JniString provider) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearTestProviderEnabled,
          jni.JniType.voidType, [provider.reference]).check();

  static final _id_setTestProviderStatus = jniAccessors.getMethodIDOf(_classRef,
      "setTestProviderStatus", "(Ljava/lang/String;ILandroid/os/Bundle;J)V");

  /// from: public void setTestProviderStatus(java.lang.String provider, int status, android.os.Bundle extras, long updateTime)
  ///
  /// Sets mock status values for the given provider.  These values will be used in place
  /// of any actual values from the provider.
  ///@param provider the provider name
  ///@param status the mock status
  ///@param extras a Bundle containing mock extras
  ///@param updateTime the mock update time
  ///@throws SecurityException if android.app.AppOpsManager\#OPSTR_MOCK_LOCATION mock location app op is not set to android.app.AppOpsManager\#MODE_ALLOWED allowed for your app.
  ///@throws IllegalArgumentException if no provider with the given name exists
  void setTestProviderStatus(jni.JniString provider, int status,
          bundle_.Bundle extras, int updateTime) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTestProviderStatus,
          jni.JniType.voidType,
          [provider.reference, status, extras.reference, updateTime]).check();

  static final _id_clearTestProviderStatus = jniAccessors.getMethodIDOf(
      _classRef, "clearTestProviderStatus", "(Ljava/lang/String;)V");

  /// from: public void clearTestProviderStatus(java.lang.String provider)
  ///
  /// Removes any mock status values associated with the given provider.
  ///@param provider the provider name
  ///@throws SecurityException if android.app.AppOpsManager\#OPSTR_MOCK_LOCATION mock location app op is not set to android.app.AppOpsManager\#MODE_ALLOWED allowed for your app.
  ///@throws IllegalArgumentException if no provider with the given name exists
  void clearTestProviderStatus(jni.JniString provider) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearTestProviderStatus,
          jni.JniType.voidType, [provider.reference]).check();

  static final _id_addGpsStatusListener = jniAccessors.getMethodIDOf(_classRef,
      "addGpsStatusListener", "(Landroid/location/GpsStatus\$Listener;)Z");

  /// from: public boolean addGpsStatusListener(android.location.GpsStatus.Listener listener)
  ///
  /// Adds a GPS status listener.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param listener GPS status listener object to register
  ///@return true if the listener was successfully added
  ///@throws SecurityException if the ACCESS_FINE_LOCATION permission is not present
  ///@deprecated use \#registerGnssStatusCallback(GnssStatus.Callback) instead.
  bool addGpsStatusListener(gpsstatus_.GpsStatus_Listener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addGpsStatusListener,
          jni.JniType.booleanType, [listener.reference]).boolean;

  static final _id_removeGpsStatusListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeGpsStatusListener",
      "(Landroid/location/GpsStatus\$Listener;)V");

  /// from: public void removeGpsStatusListener(android.location.GpsStatus.Listener listener)
  ///
  /// Removes a GPS status listener.
  ///@param listener GPS status listener object to remove
  ///@deprecated use \#unregisterGnssStatusCallback(GnssStatus.Callback) instead.
  void removeGpsStatusListener(gpsstatus_.GpsStatus_Listener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeGpsStatusListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_registerGnssStatusCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerGnssStatusCallback",
      "(Landroid/location/GnssStatus\$Callback;)Z");

  /// from: public boolean registerGnssStatusCallback(android.location.GnssStatus.Callback callback)
  ///
  /// Registers a GNSS status callback.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param callback GNSS status callback object to register
  ///@return true if the listener was successfully added
  ///@throws SecurityException if the ACCESS_FINE_LOCATION permission is not present
  bool registerGnssStatusCallback(gnssstatus_.GnssStatus_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerGnssStatusCallback,
          jni.JniType.booleanType, [callback.reference]).boolean;

  static final _id_registerGnssStatusCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerGnssStatusCallback",
      "(Landroid/location/GnssStatus\$Callback;Landroid/os/Handler;)Z");

  /// from: public boolean registerGnssStatusCallback(android.location.GnssStatus.Callback callback, android.os.Handler handler)
  ///
  /// Registers a GNSS status callback.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param callback GNSS status callback object to register
  ///@param handler the handler that the callback runs on.
  ///@return true if the listener was successfully added
  ///@throws SecurityException if the ACCESS_FINE_LOCATION permission is not present
  bool registerGnssStatusCallback1(
          gnssstatus_.GnssStatus_Callback callback, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerGnssStatusCallback1,
          jni.JniType.booleanType,
          [callback.reference, handler.reference]).boolean;

  static final _id_unregisterGnssStatusCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterGnssStatusCallback",
      "(Landroid/location/GnssStatus\$Callback;)V");

  /// from: public void unregisterGnssStatusCallback(android.location.GnssStatus.Callback callback)
  ///
  /// Removes a GNSS status callback.
  ///@param callback GNSS status callback object to remove
  void unregisterGnssStatusCallback(gnssstatus_.GnssStatus_Callback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterGnssStatusCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_addNmeaListener = jniAccessors.getMethodIDOf(_classRef,
      "addNmeaListener", "(Landroid/location/GpsStatus\$NmeaListener;)Z");

  /// from: public boolean addNmeaListener(android.location.GpsStatus.NmeaListener listener)
  ///
  /// Adds an NMEA listener.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param listener a GpsStatus.NmeaListener object to register
  ///@return true if the listener was successfully added
  ///@throws SecurityException if the ACCESS_FINE_LOCATION permission is not present
  ///@deprecated use \#addNmeaListener(OnNmeaMessageListener) instead.
  bool addNmeaListener(gpsstatus_.GpsStatus_NmeaListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addNmeaListener,
          jni.JniType.booleanType, [listener.reference]).boolean;

  static final _id_removeNmeaListener = jniAccessors.getMethodIDOf(_classRef,
      "removeNmeaListener", "(Landroid/location/GpsStatus\$NmeaListener;)V");

  /// from: public void removeNmeaListener(android.location.GpsStatus.NmeaListener listener)
  ///
  /// Removes an NMEA listener.
  ///@param listener a GpsStatus.NmeaListener object to remove
  ///@deprecated use \#removeNmeaListener(OnNmeaMessageListener) instead.
  void removeNmeaListener(gpsstatus_.GpsStatus_NmeaListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeNmeaListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_addNmeaListener1 = jniAccessors.getMethodIDOf(_classRef,
      "addNmeaListener", "(Landroid/location/OnNmeaMessageListener;)Z");

  /// from: public boolean addNmeaListener(android.location.OnNmeaMessageListener listener)
  ///
  /// Adds an NMEA listener.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param listener a OnNmeaMessageListener object to register
  ///@return true if the listener was successfully added
  ///@throws SecurityException if the ACCESS_FINE_LOCATION permission is not present
  bool addNmeaListener1(
          onnmeamessagelistener_.OnNmeaMessageListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addNmeaListener1,
          jni.JniType.booleanType, [listener.reference]).boolean;

  static final _id_addNmeaListener2 = jniAccessors.getMethodIDOf(
      _classRef,
      "addNmeaListener",
      "(Landroid/location/OnNmeaMessageListener;Landroid/os/Handler;)Z");

  /// from: public boolean addNmeaListener(android.location.OnNmeaMessageListener listener, android.os.Handler handler)
  ///
  /// Adds an NMEA listener.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param listener a OnNmeaMessageListener object to register
  ///@param handler the handler that the listener runs on.
  ///@return true if the listener was successfully added
  ///@throws SecurityException if the ACCESS_FINE_LOCATION permission is not present
  bool addNmeaListener2(onnmeamessagelistener_.OnNmeaMessageListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addNmeaListener2,
          jni.JniType.booleanType,
          [listener.reference, handler.reference]).boolean;

  static final _id_removeNmeaListener1 = jniAccessors.getMethodIDOf(_classRef,
      "removeNmeaListener", "(Landroid/location/OnNmeaMessageListener;)V");

  /// from: public void removeNmeaListener(android.location.OnNmeaMessageListener listener)
  ///
  /// Removes an NMEA listener.
  ///@param listener a OnNmeaMessageListener object to remove
  void removeNmeaListener1(
          onnmeamessagelistener_.OnNmeaMessageListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeNmeaListener1,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_registerGnssMeasurementsCallback =
      jniAccessors.getMethodIDOf(_classRef, "registerGnssMeasurementsCallback",
          "(Landroid/location/GnssMeasurementsEvent\$Callback;)Z");

  /// from: public boolean registerGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback callback)
  ///
  /// Registers a GPS Measurement callback.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param callback a GnssMeasurementsEvent.Callback object to register.
  ///@return {@code true} if the callback was added successfully, {@code false} otherwise.
  bool registerGnssMeasurementsCallback(
          gnssmeasurementsevent_.GnssMeasurementsEvent_Callback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerGnssMeasurementsCallback,
          jni.JniType.booleanType,
          [callback.reference]).boolean;

  static final _id_registerGnssMeasurementsCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerGnssMeasurementsCallback",
      "(Landroid/location/GnssMeasurementsEvent\$Callback;Landroid/os/Handler;)Z");

  /// from: public boolean registerGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback callback, android.os.Handler handler)
  ///
  /// Registers a GPS Measurement callback.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param callback a GnssMeasurementsEvent.Callback object to register.
  ///@param handler the handler that the callback runs on.
  ///@return {@code true} if the callback was added successfully, {@code false} otherwise.
  bool registerGnssMeasurementsCallback1(
          gnssmeasurementsevent_.GnssMeasurementsEvent_Callback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerGnssMeasurementsCallback1,
          jni.JniType.booleanType,
          [callback.reference, handler.reference]).boolean;

  static final _id_unregisterGnssMeasurementsCallback =
      jniAccessors.getMethodIDOf(
          _classRef,
          "unregisterGnssMeasurementsCallback",
          "(Landroid/location/GnssMeasurementsEvent\$Callback;)V");

  /// from: public void unregisterGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback callback)
  ///
  /// Unregisters a GPS Measurement callback.
  ///@param callback a GnssMeasurementsEvent.Callback object to remove.
  void unregisterGnssMeasurementsCallback(
          gnssmeasurementsevent_.GnssMeasurementsEvent_Callback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterGnssMeasurementsCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_registerGnssNavigationMessageCallback =
      jniAccessors.getMethodIDOf(
          _classRef,
          "registerGnssNavigationMessageCallback",
          "(Landroid/location/GnssNavigationMessage\$Callback;)Z");

  /// from: public boolean registerGnssNavigationMessageCallback(android.location.GnssNavigationMessage.Callback callback)
  ///
  /// Registers a GNSS Navigation Message callback.
  ///@param callback a GnssNavigationMessage.Callback object to register.
  ///@return {@code true} if the callback was added successfully, {@code false} otherwise.
  bool registerGnssNavigationMessageCallback(
          gnssnavigationmessage_.GnssNavigationMessage_Callback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerGnssNavigationMessageCallback,
          jni.JniType.booleanType,
          [callback.reference]).boolean;

  static final _id_registerGnssNavigationMessageCallback1 =
      jniAccessors.getMethodIDOf(
          _classRef,
          "registerGnssNavigationMessageCallback",
          "(Landroid/location/GnssNavigationMessage\$Callback;Landroid/os/Handler;)Z");

  /// from: public boolean registerGnssNavigationMessageCallback(android.location.GnssNavigationMessage.Callback callback, android.os.Handler handler)
  ///
  /// Registers a GNSS Navigation Message callback.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param callback a GnssNavigationMessage.Callback object to register.
  ///@param handler the handler that the callback runs on.
  ///@return {@code true} if the callback was added successfully, {@code false} otherwise.
  bool registerGnssNavigationMessageCallback1(
          gnssnavigationmessage_.GnssNavigationMessage_Callback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerGnssNavigationMessageCallback1,
          jni.JniType.booleanType,
          [callback.reference, handler.reference]).boolean;

  static final _id_unregisterGnssNavigationMessageCallback =
      jniAccessors.getMethodIDOf(
          _classRef,
          "unregisterGnssNavigationMessageCallback",
          "(Landroid/location/GnssNavigationMessage\$Callback;)V");

  /// from: public void unregisterGnssNavigationMessageCallback(android.location.GnssNavigationMessage.Callback callback)
  ///
  /// Unregisters a GNSS Navigation Message callback.
  ///@param callback a GnssNavigationMessage.Callback object to remove.
  void unregisterGnssNavigationMessageCallback(
          gnssnavigationmessage_.GnssNavigationMessage_Callback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterGnssNavigationMessageCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_getGpsStatus = jniAccessors.getMethodIDOf(
      _classRef,
      "getGpsStatus",
      "(Landroid/location/GpsStatus;)Landroid/location/GpsStatus;");

  /// from: public android.location.GpsStatus getGpsStatus(android.location.GpsStatus status)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves information about the current status of the GPS engine.
  /// This should only be called from the GpsStatus.Listener\#onGpsStatusChanged
  /// callback to ensure that the data is copied atomically.
  ///
  /// The caller may either pass in a GpsStatus object to set with the latest
  /// status information, or pass null to create a new GpsStatus object.
  ///
  /// Requires android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@param status object containing GPS status details, or null.
  ///@return status object containing updated GPS status.
  gpsstatus_.GpsStatus getGpsStatus(gpsstatus_.GpsStatus status) =>
      gpsstatus_.GpsStatus.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getGpsStatus, jni.JniType.objectType, [status.reference]).object);

  static final _id_getGnssYearOfHardware =
      jniAccessors.getMethodIDOf(_classRef, "getGnssYearOfHardware", "()I");

  /// from: public int getGnssYearOfHardware()
  ///
  /// Returns the model year of the GNSS hardware and software build.
  ///
  ///  More details, such as build date, may be available in \#getGnssHardwareModelName().
  ///
  ///  May return 0 if the model year is less than 2016.
  int getGnssYearOfHardware() => jniAccessors.callMethodWithArgs(
      reference, _id_getGnssYearOfHardware, jni.JniType.intType, []).integer;

  static final _id_getGnssHardwareModelName = jniAccessors.getMethodIDOf(
      _classRef, "getGnssHardwareModelName", "()Ljava/lang/String;");

  /// from: public java.lang.String getGnssHardwareModelName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Model Name (including Vendor and Hardware/Software Version) of the GNSS hardware
  /// driver.
  ///
  ///  No device-specific serial number or ID is returned from this API.
  ///
  ///  Will return null when the GNSS hardware abstraction layer does not support providing
  /// this value.
  jni.JniString getGnssHardwareModelName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getGnssHardwareModelName, jni.JniType.objectType, []).object);

  static final _id_sendExtraCommand = jniAccessors.getMethodIDOf(
      _classRef,
      "sendExtraCommand",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Z");

  /// from: public boolean sendExtraCommand(java.lang.String provider, java.lang.String command, android.os.Bundle extras)
  ///
  /// Sends additional commands to a location provider.
  /// Can be used to support provider specific extensions to the Location Manager API
  ///@param provider name of the location provider.
  ///@param command name of the command to send to the provider.
  ///@param extras optional arguments for the command (or null).
  /// The provider may optionally fill the extras Bundle with results from the command.
  ///@return true if the command succeeds.
  bool sendExtraCommand(jni.JniString provider, jni.JniString command,
          bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendExtraCommand,
          jni.JniType.booleanType,
          [provider.reference, command.reference, extras.reference]).boolean;
}
