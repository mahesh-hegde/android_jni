// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.location.GnssClock
///
/// A class containing a GPS clock timestamp.
///
/// It represents a measurement of the GPS receiver's clock.
class GnssClock extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/location/GnssClock");
  GnssClock.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.location.GnssClock> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_hasLeapSecond =
      jniAccessors.getMethodIDOf(_classRef, "hasLeapSecond", "()Z");

  /// from: public boolean hasLeapSecond()
  ///
  /// Returns {@code true} if \#getLeapSecond() is available, {@code false} otherwise.
  bool hasLeapSecond() => jniAccessors.callMethodWithArgs(
      reference, _id_hasLeapSecond, jni.JniType.booleanType, []).boolean;

  static final _id_getLeapSecond =
      jniAccessors.getMethodIDOf(_classRef, "getLeapSecond", "()I");

  /// from: public int getLeapSecond()
  ///
  /// Gets the leap second associated with the clock's time.
  ///
  /// The sign of the value is defined by the following equation:
  /// <pre>
  ///     UtcTimeNanos = TimeNanos - (FullBiasNanos + BiasNanos) - LeapSecond * 1,000,000,000</pre>
  ///
  /// The value is only available if \#hasLeapSecond() is {@code true}.
  int getLeapSecond() => jniAccessors.callMethodWithArgs(
      reference, _id_getLeapSecond, jni.JniType.intType, []).integer;

  static final _id_getTimeNanos =
      jniAccessors.getMethodIDOf(_classRef, "getTimeNanos", "()J");

  /// from: public long getTimeNanos()
  ///
  /// Gets the GNSS receiver internal hardware clock value in nanoseconds.
  ///
  /// This value is expected to be monotonically increasing while the hardware clock remains
  /// powered on. For the case of a hardware clock that is not continuously on, see the
  /// \#getHardwareClockDiscontinuityCount field. The GPS time can be derived by subtracting
  /// the sum of \#getFullBiasNanos() and \#getBiasNanos() (when they are available)
  /// from this value. Sub-nanosecond accuracy can be provided by means of \#getBiasNanos().
  ///
  /// The error estimate for this value (if applicable) is \#getTimeUncertaintyNanos().
  int getTimeNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimeNanos, jni.JniType.longType, []).long;

  static final _id_hasTimeUncertaintyNanos =
      jniAccessors.getMethodIDOf(_classRef, "hasTimeUncertaintyNanos", "()Z");

  /// from: public boolean hasTimeUncertaintyNanos()
  ///
  /// Returns {@code true} if \#getTimeUncertaintyNanos() is available, {@code false}
  /// otherwise.
  bool hasTimeUncertaintyNanos() => jniAccessors.callMethodWithArgs(reference,
      _id_hasTimeUncertaintyNanos, jni.JniType.booleanType, []).boolean;

  static final _id_getTimeUncertaintyNanos =
      jniAccessors.getMethodIDOf(_classRef, "getTimeUncertaintyNanos", "()D");

  /// from: public double getTimeUncertaintyNanos()
  ///
  /// Gets the clock's time Uncertainty (1-Sigma) in nanoseconds.
  ///
  /// The uncertainty is represented as an absolute (single sided) value.
  ///
  /// The value is only available if \#hasTimeUncertaintyNanos() is {@code true}.
  ///
  /// This value is often effectively zero (it is the reference clock by which all other times
  /// and time uncertainties are measured), and thus this field may often be 0, or not provided.
  double getTimeUncertaintyNanos() => jniAccessors.callMethodWithArgs(reference,
      _id_getTimeUncertaintyNanos, jni.JniType.doubleType, []).doubleFloat;

  static final _id_hasFullBiasNanos =
      jniAccessors.getMethodIDOf(_classRef, "hasFullBiasNanos", "()Z");

  /// from: public boolean hasFullBiasNanos()
  ///
  /// Returns {@code true} if \#getFullBiasNanos() is available, {@code false} otherwise.
  bool hasFullBiasNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFullBiasNanos, jni.JniType.booleanType, []).boolean;

  static final _id_getFullBiasNanos =
      jniAccessors.getMethodIDOf(_classRef, "getFullBiasNanos", "()J");

  /// from: public long getFullBiasNanos()
  ///
  /// Gets the difference between hardware clock (\#getTimeNanos()) inside GPS receiver and
  /// the true GPS time since 0000Z, January 6, 1980, in nanoseconds.
  ///
  /// This value is available if the receiver has estimated GPS time. If the computed time is
  /// for a non-GPS constellation, the time offset of that constellation to GPS has to be applied
  /// to fill this value. The value is only available if \#hasFullBiasNanos() is
  /// {@code true}.
  ///
  /// The error estimate for the sum of this field and \#getBiasNanos is
  /// \#getBiasUncertaintyNanos().
  ///
  /// The sign of the value is defined by the following equation:
  ///
  /// <pre>
  ///     local estimate of GPS time = TimeNanos - (FullBiasNanos + BiasNanos)</pre>
  int getFullBiasNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_getFullBiasNanos, jni.JniType.longType, []).long;

  static final _id_hasBiasNanos =
      jniAccessors.getMethodIDOf(_classRef, "hasBiasNanos", "()Z");

  /// from: public boolean hasBiasNanos()
  ///
  /// Returns {@code true} if \#getBiasNanos() is available, {@code false} otherwise.
  bool hasBiasNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_hasBiasNanos, jni.JniType.booleanType, []).boolean;

  static final _id_getBiasNanos =
      jniAccessors.getMethodIDOf(_classRef, "getBiasNanos", "()D");

  /// from: public double getBiasNanos()
  ///
  /// Gets the clock's sub-nanosecond bias.
  ///
  /// See the description of how this field is part of converting from hardware clock time, to
  /// GPS time, in \#getFullBiasNanos().
  ///
  /// The error estimate for the sum of this field and \#getFullBiasNanos is
  /// \#getBiasUncertaintyNanos().
  ///
  /// The value is only available if \#hasBiasNanos() is {@code true}.
  double getBiasNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_getBiasNanos, jni.JniType.doubleType, []).doubleFloat;

  static final _id_hasBiasUncertaintyNanos =
      jniAccessors.getMethodIDOf(_classRef, "hasBiasUncertaintyNanos", "()Z");

  /// from: public boolean hasBiasUncertaintyNanos()
  ///
  /// Returns {@code true} if \#getBiasUncertaintyNanos() is available, {@code false}
  /// otherwise.
  bool hasBiasUncertaintyNanos() => jniAccessors.callMethodWithArgs(reference,
      _id_hasBiasUncertaintyNanos, jni.JniType.booleanType, []).boolean;

  static final _id_getBiasUncertaintyNanos =
      jniAccessors.getMethodIDOf(_classRef, "getBiasUncertaintyNanos", "()D");

  /// from: public double getBiasUncertaintyNanos()
  ///
  /// Gets the clock's Bias Uncertainty (1-Sigma) in nanoseconds.
  ///
  /// See the description of how this field provides the error estimate in the conversion from
  /// hardware clock time, to GPS time, in \#getFullBiasNanos().
  ///
  /// The value is only available if \#hasBiasUncertaintyNanos() is {@code true}.
  double getBiasUncertaintyNanos() => jniAccessors.callMethodWithArgs(reference,
      _id_getBiasUncertaintyNanos, jni.JniType.doubleType, []).doubleFloat;

  static final _id_hasDriftNanosPerSecond =
      jniAccessors.getMethodIDOf(_classRef, "hasDriftNanosPerSecond", "()Z");

  /// from: public boolean hasDriftNanosPerSecond()
  ///
  /// Returns {@code true} if \#getDriftNanosPerSecond() is available, {@code false}
  /// otherwise.
  bool hasDriftNanosPerSecond() => jniAccessors.callMethodWithArgs(reference,
      _id_hasDriftNanosPerSecond, jni.JniType.booleanType, []).boolean;

  static final _id_getDriftNanosPerSecond =
      jniAccessors.getMethodIDOf(_classRef, "getDriftNanosPerSecond", "()D");

  /// from: public double getDriftNanosPerSecond()
  ///
  /// Gets the clock's Drift in nanoseconds per second.
  ///
  /// This value is the instantaneous time-derivative of the value provided by
  /// \#getBiasNanos().
  ///
  /// A positive value indicates that the frequency is higher than the nominal (e.g. GPS master
  /// clock) frequency. The error estimate for this reported drift is
  /// \#getDriftUncertaintyNanosPerSecond().
  ///
  /// The value is only available if \#hasDriftNanosPerSecond() is {@code true}.
  double getDriftNanosPerSecond() => jniAccessors.callMethodWithArgs(reference,
      _id_getDriftNanosPerSecond, jni.JniType.doubleType, []).doubleFloat;

  static final _id_hasDriftUncertaintyNanosPerSecond = jniAccessors
      .getMethodIDOf(_classRef, "hasDriftUncertaintyNanosPerSecond", "()Z");

  /// from: public boolean hasDriftUncertaintyNanosPerSecond()
  ///
  /// Returns {@code true} if \#getDriftUncertaintyNanosPerSecond() is available,
  /// {@code false} otherwise.
  bool hasDriftUncertaintyNanosPerSecond() => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasDriftUncertaintyNanosPerSecond,
      jni.JniType.booleanType, []).boolean;

  static final _id_getDriftUncertaintyNanosPerSecond = jniAccessors
      .getMethodIDOf(_classRef, "getDriftUncertaintyNanosPerSecond", "()D");

  /// from: public double getDriftUncertaintyNanosPerSecond()
  ///
  /// Gets the clock's Drift Uncertainty (1-Sigma) in nanoseconds per second.
  ///
  /// The value is only available if \#hasDriftUncertaintyNanosPerSecond() is
  /// {@code true}.
  double getDriftUncertaintyNanosPerSecond() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDriftUncertaintyNanosPerSecond,
      jni.JniType.doubleType, []).doubleFloat;

  static final _id_getHardwareClockDiscontinuityCount = jniAccessors
      .getMethodIDOf(_classRef, "getHardwareClockDiscontinuityCount", "()I");

  /// from: public int getHardwareClockDiscontinuityCount()
  ///
  /// Gets count of hardware clock discontinuities.
  ///
  /// When this value stays the same, vs. a value in a previously reported GnssClock, it
  /// can be safely assumed that the {@code TimeNanos} value has been derived from a clock that has
  /// been running continuously - e.g. a single continuously powered crystal oscillator, and thus
  /// the {@code (FullBiasNanos + BiasNanos)} offset can be modelled with traditional clock bias
  /// &amp; drift models.
  ///
  /// Each time this value changes, vs. the value in a previously reported GnssClock,
  /// that suggests the hardware clock may have experienced a discontinuity (e.g. a power cycle or
  /// other anomaly), so that any assumptions about modelling a smoothly changing
  /// {@code (FullBiasNanos + BiasNanos)} offset, and a smoothly growing {@code (TimeNanos)}
  /// between this and the previously reported {@code GnssClock}, should be reset.
  int getHardwareClockDiscontinuityCount() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHardwareClockDiscontinuityCount,
      jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(parcel_.Parcel parcel, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [parcel.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
