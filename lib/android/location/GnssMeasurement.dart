// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.location.GnssMeasurement
///
/// A class representing a GNSS satellite measurement, containing raw and computed information.
class GnssMeasurement extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/location/GnssMeasurement");
  GnssMeasurement.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ADR_STATE_CYCLE_SLIP
  ///
  /// The state of the \#getAccumulatedDeltaRangeMeters() has a cycle slip detected.
  static const ADR_STATE_CYCLE_SLIP = 4;

  /// from: static public final int ADR_STATE_HALF_CYCLE_REPORTED
  ///
  /// Reports whether the flag \#ADR_STATE_HALF_CYCLE_RESOLVED has been reported by the
  /// GNSS hardware.
  ///
  ///  When this bit is set, the value of \#getAccumulatedDeltaRangeUncertaintyMeters()
  /// can be low (centimeter level) whether or not the half cycle ambiguity is resolved.
  ///
  ///  When this bit is unset, the value of \#getAccumulatedDeltaRangeUncertaintyMeters()
  /// is larger, to cover the potential error due to half cycle ambiguity being unresolved.
  static const ADR_STATE_HALF_CYCLE_REPORTED = 16;

  /// from: static public final int ADR_STATE_HALF_CYCLE_RESOLVED
  ///
  /// Reports whether the value \#getAccumulatedDeltaRangeMeters() has resolved the half
  /// cycle ambiguity.
  ///
  ///  When this bit is set, the \#getAccumulatedDeltaRangeMeters() corresponds to the
  /// carrier phase measurement plus an accumulated integer number of carrier full cycles.
  ///
  ///  When this bit is unset, the \#getAccumulatedDeltaRangeMeters() corresponds to the
  /// carrier phase measurement plus an accumulated integer number of carrier half cycles.
  static const ADR_STATE_HALF_CYCLE_RESOLVED = 8;

  /// from: static public final int ADR_STATE_RESET
  ///
  /// The state of the \#getAccumulatedDeltaRangeMeters() has detected a reset.
  static const ADR_STATE_RESET = 2;

  /// from: static public final int ADR_STATE_UNKNOWN
  ///
  /// The state of the value \#getAccumulatedDeltaRangeMeters() is invalid or unknown.
  static const ADR_STATE_UNKNOWN = 0;

  /// from: static public final int ADR_STATE_VALID
  ///
  /// The state of the \#getAccumulatedDeltaRangeMeters() is valid.
  static const ADR_STATE_VALID = 1;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.location.GnssMeasurement> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int MULTIPATH_INDICATOR_DETECTED
  ///
  /// The measurement shows signs of multi-path.
  static const MULTIPATH_INDICATOR_DETECTED = 1;

  /// from: static public final int MULTIPATH_INDICATOR_NOT_DETECTED
  ///
  /// The measurement shows no signs of multi-path.
  static const MULTIPATH_INDICATOR_NOT_DETECTED = 2;

  /// from: static public final int MULTIPATH_INDICATOR_UNKNOWN
  ///
  /// The indicator is not available or the presence or absence of multipath is unknown.
  static const MULTIPATH_INDICATOR_UNKNOWN = 0;

  /// from: static public final int STATE_BDS_D2_BIT_SYNC
  ///
  /// This Beidou measurement's tracking state has D2 bit sync.
  static const STATE_BDS_D2_BIT_SYNC = 256;

  /// from: static public final int STATE_BDS_D2_SUBFRAME_SYNC
  ///
  /// This Beidou measurement's tracking state has D2 sub-frame sync.
  static const STATE_BDS_D2_SUBFRAME_SYNC = 512;

  /// from: static public final int STATE_BIT_SYNC
  ///
  /// This GNSS measurement's tracking state has bit sync.
  static const STATE_BIT_SYNC = 2;

  /// from: static public final int STATE_CODE_LOCK
  ///
  /// This GNSS measurement's tracking state has code lock.
  static const STATE_CODE_LOCK = 1;

  /// from: static public final int STATE_GAL_E1BC_CODE_LOCK
  ///
  /// This Galileo measurement's tracking state has E1B/C code lock.
  static const STATE_GAL_E1BC_CODE_LOCK = 1024;

  /// from: static public final int STATE_GAL_E1B_PAGE_SYNC
  ///
  /// This Galileo measurement's tracking state has E1B page sync.
  static const STATE_GAL_E1B_PAGE_SYNC = 4096;

  /// from: static public final int STATE_GAL_E1C_2ND_CODE_LOCK
  ///
  /// This Galileo measurement's tracking state has E1C secondary code lock.
  static const STATE_GAL_E1C_2ND_CODE_LOCK = 2048;

  /// from: static public final int STATE_GLO_STRING_SYNC
  ///
  /// This Glonass measurement's tracking state has string sync.
  static const STATE_GLO_STRING_SYNC = 64;

  /// from: static public final int STATE_GLO_TOD_DECODED
  ///
  /// This Glonass measurement's tracking state has time-of-day decoded.
  static const STATE_GLO_TOD_DECODED = 128;

  /// from: static public final int STATE_GLO_TOD_KNOWN
  ///
  /// This Glonass measurement's tracking state has time-of-day known, possibly not decoded
  /// over the air but has been determined from other sources. If TOD decoded is set then TOD Known
  /// will also be set.
  static const STATE_GLO_TOD_KNOWN = 32768;

  /// from: static public final int STATE_MSEC_AMBIGUOUS
  ///
  /// This GNSS measurement's tracking state contains millisecond ambiguity.
  static const STATE_MSEC_AMBIGUOUS = 16;

  /// from: static public final int STATE_SBAS_SYNC
  ///
  /// This SBAS measurement's tracking state has whole second level sync.
  static const STATE_SBAS_SYNC = 8192;

  /// from: static public final int STATE_SUBFRAME_SYNC
  ///
  /// This GNSS measurement's tracking state has sub-frame sync.
  static const STATE_SUBFRAME_SYNC = 4;

  /// from: static public final int STATE_SYMBOL_SYNC
  ///
  /// This GNSS measurement's tracking state has symbol sync.
  static const STATE_SYMBOL_SYNC = 32;

  /// from: static public final int STATE_TOW_DECODED
  ///
  /// This GNSS measurement's tracking state has time-of-week decoded.
  static const STATE_TOW_DECODED = 8;

  /// from: static public final int STATE_TOW_KNOWN
  ///
  /// This GNSS measurement's tracking state has time-of-week known, possibly not decoded
  /// over the air but has been determined from other sources. If TOW decoded is set then TOW Known
  /// will also be set.
  static const STATE_TOW_KNOWN = 16384;

  /// from: static public final int STATE_UNKNOWN
  ///
  /// This GNSS measurement's tracking state is invalid or unknown.
  static const STATE_UNKNOWN = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  GnssMeasurement()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getSvid =
      jniAccessors.getMethodIDOf(_classRef, "getSvid", "()I");

  /// from: public int getSvid()
  ///
  /// Gets the satellite ID.
  ///
  /// Interpretation depends on \#getConstellationType().
  /// See GnssStatus\#getSvid(int).
  int getSvid() => jniAccessors.callMethodWithArgs(
      reference, _id_getSvid, jni.JniType.intType, []).integer;

  static final _id_getConstellationType =
      jniAccessors.getMethodIDOf(_classRef, "getConstellationType", "()I");

  /// from: public int getConstellationType()
  ///
  /// Gets the constellation type.
  ///
  /// The return value is one of those constants with {@code CONSTELLATION_} prefix in
  /// GnssStatus.
  ///@return Value is android.location.GnssStatus\#CONSTELLATION_UNKNOWN, android.location.GnssStatus\#CONSTELLATION_GPS, android.location.GnssStatus\#CONSTELLATION_SBAS, android.location.GnssStatus\#CONSTELLATION_GLONASS, android.location.GnssStatus\#CONSTELLATION_QZSS, android.location.GnssStatus\#CONSTELLATION_BEIDOU, or android.location.GnssStatus\#CONSTELLATION_GALILEO
  int getConstellationType() => jniAccessors.callMethodWithArgs(
      reference, _id_getConstellationType, jni.JniType.intType, []).integer;

  static final _id_getTimeOffsetNanos =
      jniAccessors.getMethodIDOf(_classRef, "getTimeOffsetNanos", "()D");

  /// from: public double getTimeOffsetNanos()
  ///
  /// Gets the time offset at which the measurement was taken in nanoseconds.
  ///
  /// The reference receiver's time from which this is offset is specified by
  /// GnssClock\#getTimeNanos().
  ///
  /// The sign of this value is given by the following equation:
  /// <pre>
  ///      measurement time = TimeNanos + TimeOffsetNanos</pre>
  ///
  /// The value provides an individual time-stamp for the measurement, and allows sub-nanosecond
  /// accuracy.
  double getTimeOffsetNanos() => jniAccessors.callMethodWithArgs(reference,
      _id_getTimeOffsetNanos, jni.JniType.doubleType, []).doubleFloat;

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public int getState()
  ///
  /// Gets per-satellite sync state.
  ///
  /// It represents the current sync state for the associated satellite.
  ///
  /// This value helps interpret \#getReceivedSvTimeNanos().
  ///@return Value is either <code>0</code> or a combination of android.location.GnssMeasurement\#STATE_CODE_LOCK, android.location.GnssMeasurement\#STATE_BIT_SYNC, android.location.GnssMeasurement\#STATE_SUBFRAME_SYNC, android.location.GnssMeasurement\#STATE_TOW_DECODED, android.location.GnssMeasurement\#STATE_MSEC_AMBIGUOUS, android.location.GnssMeasurement\#STATE_SYMBOL_SYNC, android.location.GnssMeasurement\#STATE_GLO_STRING_SYNC, android.location.GnssMeasurement\#STATE_GLO_TOD_DECODED, android.location.GnssMeasurement\#STATE_BDS_D2_BIT_SYNC, android.location.GnssMeasurement\#STATE_BDS_D2_SUBFRAME_SYNC, android.location.GnssMeasurement\#STATE_GAL_E1BC_CODE_LOCK, android.location.GnssMeasurement\#STATE_GAL_E1C_2ND_CODE_LOCK, android.location.GnssMeasurement\#STATE_GAL_E1B_PAGE_SYNC, android.location.GnssMeasurement\#STATE_SBAS_SYNC, android.location.GnssMeasurement\#STATE_TOW_KNOWN, and android.location.GnssMeasurement\#STATE_GLO_TOD_KNOWN
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_getReceivedSvTimeNanos =
      jniAccessors.getMethodIDOf(_classRef, "getReceivedSvTimeNanos", "()J");

  /// from: public long getReceivedSvTimeNanos()
  ///
  /// Gets the received GNSS satellite time, at the measurement time, in nanoseconds.
  ///
  /// For GPS &amp; QZSS, this is:
  /// <ul>
  /// <li>Received GPS Time-of-Week at the measurement time, in nanoseconds.</li>
  /// <li>The value is relative to the beginning of the current GPS week.</li>
  /// </ul>
  ///
  /// Given the highest sync state that can be achieved, per each satellite, valid range
  /// for this field can be:
  /// <pre>
  ///     Searching       : [ 0       ]   : STATE_UNKNOWN
  ///     C/A code lock   : [ 0   1ms ]   : STATE_CODE_LOCK is set
  ///     Bit sync        : [ 0  20ms ]   : STATE_BIT_SYNC is set
  ///     Subframe sync   : [ 0    6s ]   : STATE_SUBFRAME_SYNC is set
  ///     TOW decoded     : [ 0 1week ]   : STATE_TOW_DECODED is set
  ///     TOW Known       : [ 0 1week ]   : STATE_TOW_KNOWN set</pre>
  ///
  /// Note: TOW Known refers to the case where TOW is possibly not decoded over the air but has
  /// been determined from other sources. If TOW decoded is set then TOW Known must also be set.
  ///
  /// Note well: if there is any ambiguity in integer millisecond, {@code STATE_MSEC_AMBIGUOUS}
  /// must be set accordingly, in the 'state' field.
  ///
  /// This value must be populated if 'state' != {@code STATE_UNKNOWN}.
  ///
  /// For Glonass, this is:
  /// <ul>
  /// <li>Received Glonass time of day, at the measurement time in nanoseconds.</li>
  /// </ul>
  ///
  /// Given the highest sync state that can be achieved, per each satellite, valid range for
  /// this field can be:
  /// <pre>
  ///     Searching           : [ 0       ]   : STATE_UNKNOWN
  ///     C/A code lock       : [ 0   1ms ]   : STATE_CODE_LOCK is set
  ///     Symbol sync         : [ 0  10ms ]   : STATE_SYMBOL_SYNC is set
  ///     Bit sync            : [ 0  20ms ]   : STATE_BIT_SYNC is set
  ///     String sync         : [ 0    2s ]   : STATE_GLO_STRING_SYNC is set
  ///     Time of day decoded : [ 0  1day ]   : STATE_GLO_TOD_DECODED is set
  ///     Time of day known   : [ 0  1day ]   : STATE_GLO_TOD_KNOWN set</pre>
  ///
  /// Note: Time of day known refers to the case where it is possibly not decoded over the air but
  /// has been determined from other sources. If Time of day decoded is set then Time of day known
  /// must also be set.
  ///
  /// For Beidou, this is:
  /// <ul>
  /// <li>Received Beidou time of week, at the measurement time in nanoseconds.</li>
  /// </ul>
  ///
  /// Given the highest sync state that can be achieved, per each satellite, valid range for
  /// this field can be:
  /// <pre>
  ///     Searching              : [ 0       ]   : STATE_UNKNOWN
  ///     C/A code lock          : [ 0   1ms ]   : STATE_CODE_LOCK is set
  ///     Bit sync (D2)          : [ 0   2ms ]   : STATE_BDS_D2_BIT_SYNC is set
  ///     Bit sync (D1)          : [ 0  20ms ]   : STATE_BIT_SYNC is set
  ///     Subframe (D2)          : [ 0  0.6s ]   : STATE_BDS_D2_SUBFRAME_SYNC is set
  ///     Subframe (D1)          : [ 0    6s ]   : STATE_SUBFRAME_SYNC is set
  ///     Time of week decoded   : [ 0 1week ]   : STATE_TOW_DECODED is set
  ///     Time of week known     : [ 0 1week ]   : STATE_TOW_KNOWN set</pre>
  ///
  /// Note: TOW Known refers to the case where TOW is possibly not decoded over the air but has
  /// been determined from other sources. If TOW decoded is set then TOW Known must also be set.
  ///
  /// For Galileo, this is:
  /// <ul>
  /// <li>Received Galileo time of week, at the measurement time in nanoseconds.</li>
  /// </ul>
  /// <pre>
  ///     E1BC code lock       : [ 0   4ms ]  : STATE_GAL_E1BC_CODE_LOCK is set
  ///     E1C 2nd code lock    : [ 0 100ms ]  : STATE_GAL_E1C_2ND_CODE_LOCK is set
  ///     E1B page             : [ 0    2s ]  : STATE_GAL_E1B_PAGE_SYNC is set
  ///     Time of week decoded : [ 0 1week ]  : STATE_TOW_DECODED is set
  ///     Time of week known   : [ 0 1week ]  : STATE_TOW_KNOWN set</pre>
  ///
  /// Note: TOW Known refers to the case where TOW is possibly not decoded over the air but has
  /// been determined from other sources. If TOW decoded is set then TOW Known must also be set.
  ///
  /// For SBAS, this is:
  /// <ul>
  /// <li>Received SBAS time, at the measurement time in nanoseconds.</li>
  /// </ul>
  ///
  /// Given the highest sync state that can be achieved, per each satellite, valid range for
  /// this field can be:
  /// <pre>
  ///     Searching       : [ 0       ]   : STATE_UNKNOWN
  ///     C/A code lock   : [ 0   1ms ]   : STATE_CODE_LOCK is set
  ///     Symbol sync     : [ 0   2ms ]   : STATE_SYMBOL_SYNC is set
  ///     Message         : [ 0    1s ]   : STATE_SBAS_SYNC is set</pre>
  int getReceivedSvTimeNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_getReceivedSvTimeNanos, jni.JniType.longType, []).long;

  static final _id_getReceivedSvTimeUncertaintyNanos = jniAccessors
      .getMethodIDOf(_classRef, "getReceivedSvTimeUncertaintyNanos", "()J");

  /// from: public long getReceivedSvTimeUncertaintyNanos()
  ///
  /// Gets the error estimate (1-sigma) for the received GNSS time, in nanoseconds.
  int getReceivedSvTimeUncertaintyNanos() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getReceivedSvTimeUncertaintyNanos,
      jni.JniType.longType, []).long;

  static final _id_getCn0DbHz =
      jniAccessors.getMethodIDOf(_classRef, "getCn0DbHz", "()D");

  /// from: public double getCn0DbHz()
  ///
  /// Gets the Carrier-to-noise density in dB-Hz.
  ///
  /// Typical range: 10-50 db-Hz.
  ///
  /// The value contains the measured C/N0 for the signal at the antenna input.
  double getCn0DbHz() => jniAccessors.callMethodWithArgs(
      reference, _id_getCn0DbHz, jni.JniType.doubleType, []).doubleFloat;

  static final _id_getPseudorangeRateMetersPerSecond = jniAccessors
      .getMethodIDOf(_classRef, "getPseudorangeRateMetersPerSecond", "()D");

  /// from: public double getPseudorangeRateMetersPerSecond()
  ///
  /// Gets the Pseudorange rate at the timestamp in m/s.
  ///
  /// The error estimate for this value is
  /// \#getPseudorangeRateUncertaintyMetersPerSecond().
  ///
  /// The value is uncorrected, i.e. corrections for receiver and satellite clock frequency
  /// errors are not included.
  ///
  /// A positive 'uncorrected' value indicates that the SV is moving away from the receiver. The
  /// sign of the 'uncorrected' 'pseudorange rate' and its relation to the sign of 'doppler shift'
  /// is given by the equation:
  ///
  /// <pre>
  ///      pseudorange rate = -k * doppler shift   (where k is a constant)</pre>
  double getPseudorangeRateMetersPerSecond() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPseudorangeRateMetersPerSecond,
      jni.JniType.doubleType, []).doubleFloat;

  static final _id_getPseudorangeRateUncertaintyMetersPerSecond =
      jniAccessors.getMethodIDOf(
          _classRef, "getPseudorangeRateUncertaintyMetersPerSecond", "()D");

  /// from: public double getPseudorangeRateUncertaintyMetersPerSecond()
  ///
  /// Gets the pseudorange's rate uncertainty (1-Sigma) in m/s.
  ///
  /// The uncertainty is represented as an absolute (single sided) value.
  double getPseudorangeRateUncertaintyMetersPerSecond() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPseudorangeRateUncertaintyMetersPerSecond,
          jni.JniType.doubleType, []).doubleFloat;

  static final _id_getAccumulatedDeltaRangeState = jniAccessors.getMethodIDOf(
      _classRef, "getAccumulatedDeltaRangeState", "()I");

  /// from: public int getAccumulatedDeltaRangeState()
  ///
  /// Gets 'Accumulated Delta Range' state.
  ///
  /// It indicates whether \#getAccumulatedDeltaRangeMeters() is reset or there is a
  /// cycle slip (indicating 'loss of lock').
  ///@return Value is either <code>0</code> or a combination of android.location.GnssMeasurement\#ADR_STATE_VALID, android.location.GnssMeasurement\#ADR_STATE_RESET, android.location.GnssMeasurement\#ADR_STATE_CYCLE_SLIP, android.location.GnssMeasurement\#ADR_STATE_HALF_CYCLE_RESOLVED, and android.location.GnssMeasurement\#ADR_STATE_HALF_CYCLE_REPORTED
  int getAccumulatedDeltaRangeState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAccumulatedDeltaRangeState,
      jni.JniType.intType, []).integer;

  static final _id_getAccumulatedDeltaRangeMeters = jniAccessors.getMethodIDOf(
      _classRef, "getAccumulatedDeltaRangeMeters", "()D");

  /// from: public double getAccumulatedDeltaRangeMeters()
  ///
  /// Gets the accumulated delta range since the last channel reset, in meters.
  ///
  /// The error estimate for this value is \#getAccumulatedDeltaRangeUncertaintyMeters().
  ///
  /// The availability of the value is represented by \#getAccumulatedDeltaRangeState().
  ///
  /// A positive value indicates that the SV is moving away from the receiver.
  /// The sign of \#getAccumulatedDeltaRangeMeters() and its relation to the sign of
  /// \#getCarrierPhase() is given by the equation:
  ///
  /// <pre>
  ///          accumulated delta range = -k * carrier phase    (where k is a constant)</pre>
  ///
  /// Similar to the concept of an RTCM "Phaserange", when the accumulated delta range is
  /// initially chosen, and whenever it is reset, it will retain the integer nature
  /// of the relative carrier phase offset between satellites observed by this receiver, such that
  /// the double difference of this value between receivers and satellites may be used, together
  /// with integer ambiguity resolution, to determine highly precise relative location between
  /// receivers.
  ///
  /// This includes ensuring that all half-cycle ambiguities are resolved before this value is
  /// reported as \#ADR_STATE_VALID.
  double getAccumulatedDeltaRangeMeters() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAccumulatedDeltaRangeMeters,
      jni.JniType.doubleType, []).doubleFloat;

  static final _id_getAccumulatedDeltaRangeUncertaintyMeters =
      jniAccessors.getMethodIDOf(
          _classRef, "getAccumulatedDeltaRangeUncertaintyMeters", "()D");

  /// from: public double getAccumulatedDeltaRangeUncertaintyMeters()
  ///
  /// Gets the accumulated delta range's uncertainty (1-Sigma) in meters.
  ///
  /// The uncertainty is represented as an absolute (single sided) value.
  ///
  /// The status of the value is represented by \#getAccumulatedDeltaRangeState().
  double getAccumulatedDeltaRangeUncertaintyMeters() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getAccumulatedDeltaRangeUncertaintyMeters,
          jni.JniType.doubleType, []).doubleFloat;

  static final _id_hasCarrierFrequencyHz =
      jniAccessors.getMethodIDOf(_classRef, "hasCarrierFrequencyHz", "()Z");

  /// from: public boolean hasCarrierFrequencyHz()
  ///
  /// Returns {@code true} if \#getCarrierFrequencyHz() is available, {@code false}
  /// otherwise.
  bool hasCarrierFrequencyHz() => jniAccessors.callMethodWithArgs(reference,
      _id_hasCarrierFrequencyHz, jni.JniType.booleanType, []).boolean;

  static final _id_getCarrierFrequencyHz =
      jniAccessors.getMethodIDOf(_classRef, "getCarrierFrequencyHz", "()F");

  /// from: public float getCarrierFrequencyHz()
  ///
  /// Gets the carrier frequency of the tracked signal.
  ///
  /// For example it can be the GPS central frequency for L1 = 1575.45 MHz, or L2 = 1227.60 MHz,
  /// L5 = 1176.45 MHz, varying GLO channels, etc. If the field is not set, it is the primary
  /// common use central frequency, e.g. L1 = 1575.45 MHz for GPS.
  ///
  ///  For an L1, L5 receiver tracking a satellite on L1 and L5 at the same time, two raw
  /// measurement objects will be reported for this same satellite, in one of the measurement
  /// objects, all the values related to L1 will be filled, and in the other all of the values
  /// related to L5 will be filled.
  ///
  /// The value is only available if \#hasCarrierFrequencyHz() is {@code true}.
  ///@return the carrier frequency of the signal tracked in Hz.
  double getCarrierFrequencyHz() => jniAccessors.callMethodWithArgs(
      reference, _id_getCarrierFrequencyHz, jni.JniType.floatType, []).float;

  static final _id_hasCarrierCycles =
      jniAccessors.getMethodIDOf(_classRef, "hasCarrierCycles", "()Z");

  /// from: public boolean hasCarrierCycles()
  ///
  /// Returns {@code true} if \#getCarrierCycles() is available, {@code false} otherwise.
  ///@deprecated use \#getAccumulatedDeltaRangeState() instead.
  bool hasCarrierCycles() => jniAccessors.callMethodWithArgs(
      reference, _id_hasCarrierCycles, jni.JniType.booleanType, []).boolean;

  static final _id_getCarrierCycles =
      jniAccessors.getMethodIDOf(_classRef, "getCarrierCycles", "()J");

  /// from: public long getCarrierCycles()
  ///
  /// The number of full carrier cycles between the satellite and the receiver.
  ///
  /// The reference frequency is given by the value of \#getCarrierFrequencyHz().
  ///
  /// The value is only available if \#hasCarrierCycles() is {@code true}.
  ///@deprecated use \#getAccumulatedDeltaRangeMeters() instead.
  int getCarrierCycles() => jniAccessors.callMethodWithArgs(
      reference, _id_getCarrierCycles, jni.JniType.longType, []).long;

  static final _id_hasCarrierPhase =
      jniAccessors.getMethodIDOf(_classRef, "hasCarrierPhase", "()Z");

  /// from: public boolean hasCarrierPhase()
  ///
  /// Returns {@code true} if \#getCarrierPhase() is available, {@code false} otherwise.
  ///@deprecated use \#getAccumulatedDeltaRangeState() instead.
  bool hasCarrierPhase() => jniAccessors.callMethodWithArgs(
      reference, _id_hasCarrierPhase, jni.JniType.booleanType, []).boolean;

  static final _id_getCarrierPhase =
      jniAccessors.getMethodIDOf(_classRef, "getCarrierPhase", "()D");

  /// from: public double getCarrierPhase()
  ///
  /// Gets the RF phase detected by the receiver.
  ///
  /// Range: [0.0, 1.0].
  ///
  /// This is the fractional part of the complete carrier phase measurement.
  ///
  /// The reference frequency is given by the value of \#getCarrierFrequencyHz().
  ///
  /// The error estimate for this value is \#getCarrierPhaseUncertainty().
  ///
  /// The value is only available if \#hasCarrierPhase() is {@code true}.
  ///@deprecated use \#getAccumulatedDeltaRangeMeters() instead.
  double getCarrierPhase() => jniAccessors.callMethodWithArgs(
      reference, _id_getCarrierPhase, jni.JniType.doubleType, []).doubleFloat;

  static final _id_hasCarrierPhaseUncertainty = jniAccessors.getMethodIDOf(
      _classRef, "hasCarrierPhaseUncertainty", "()Z");

  /// from: public boolean hasCarrierPhaseUncertainty()
  ///
  /// Returns {@code true} if \#getCarrierPhaseUncertainty() is available, {@code false}
  /// otherwise.
  ///@deprecated use \#getAccumulatedDeltaRangeState() instead.
  bool hasCarrierPhaseUncertainty() => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasCarrierPhaseUncertainty,
      jni.JniType.booleanType, []).boolean;

  static final _id_getCarrierPhaseUncertainty = jniAccessors.getMethodIDOf(
      _classRef, "getCarrierPhaseUncertainty", "()D");

  /// from: public double getCarrierPhaseUncertainty()
  ///
  /// Gets the carrier-phase's uncertainty (1-Sigma).
  ///
  /// The uncertainty is represented as an absolute (single sided) value.
  ///
  /// The value is only available if \#hasCarrierPhaseUncertainty() is {@code true}.
  ///@deprecated use \#getAccumulatedDeltaRangeUncertaintyMeters() instead.
  double getCarrierPhaseUncertainty() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCarrierPhaseUncertainty,
      jni.JniType.doubleType, []).doubleFloat;

  static final _id_getMultipathIndicator =
      jniAccessors.getMethodIDOf(_classRef, "getMultipathIndicator", "()I");

  /// from: public int getMultipathIndicator()
  ///
  /// Gets a value indicating the 'multipath' state of the event.
  ///@return Value is android.location.GnssMeasurement\#MULTIPATH_INDICATOR_UNKNOWN, android.location.GnssMeasurement\#MULTIPATH_INDICATOR_DETECTED, or android.location.GnssMeasurement\#MULTIPATH_INDICATOR_NOT_DETECTED
  int getMultipathIndicator() => jniAccessors.callMethodWithArgs(
      reference, _id_getMultipathIndicator, jni.JniType.intType, []).integer;

  static final _id_hasSnrInDb =
      jniAccessors.getMethodIDOf(_classRef, "hasSnrInDb", "()Z");

  /// from: public boolean hasSnrInDb()
  ///
  /// Returns {@code true} if \#getSnrInDb() is available, {@code false} otherwise.
  bool hasSnrInDb() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSnrInDb, jni.JniType.booleanType, []).boolean;

  static final _id_getSnrInDb =
      jniAccessors.getMethodIDOf(_classRef, "getSnrInDb", "()D");

  /// from: public double getSnrInDb()
  ///
  /// Gets the (post-correlation & integration) Signal-to-Noise ratio (SNR) in dB.
  ///
  /// The value is only available if \#hasSnrInDb() is {@code true}.
  double getSnrInDb() => jniAccessors.callMethodWithArgs(
      reference, _id_getSnrInDb, jni.JniType.doubleType, []).doubleFloat;

  static final _id_hasAutomaticGainControlLevelDb = jniAccessors.getMethodIDOf(
      _classRef, "hasAutomaticGainControlLevelDb", "()Z");

  /// from: public boolean hasAutomaticGainControlLevelDb()
  ///
  /// Returns {@code true} if \#getAutomaticGainControlLevelDb() is available,
  /// {@code false} otherwise.
  bool hasAutomaticGainControlLevelDb() => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasAutomaticGainControlLevelDb,
      jni.JniType.booleanType, []).boolean;

  static final _id_getAutomaticGainControlLevelDb = jniAccessors.getMethodIDOf(
      _classRef, "getAutomaticGainControlLevelDb", "()D");

  /// from: public double getAutomaticGainControlLevelDb()
  ///
  /// Gets the Automatic Gain Control level in dB.
  ///
  ///  AGC acts as a variable gain amplifier adjusting the power of the incoming signal. The AGC
  /// level may be used to indicate potential interference. When AGC is at a nominal level, this
  /// value must be set as 0. Higher gain (and/or lower input power) shall be output as a positive
  /// number. Hence in cases of strong jamming, in the band of this signal, this value will go more
  /// negative.
  ///
  ///  Note: Different hardware designs (e.g. antenna, pre-amplification, or other RF HW
  /// components) may also affect the typical output of of this value on any given hardware design
  /// in an open sky test - the important aspect of this output is that changes in this value are
  /// indicative of changes on input signal power in the frequency band for this measurement.
  ///
  ///  The value is only available if \#hasAutomaticGainControlLevelDb() is {@code true}
  double getAutomaticGainControlLevelDb() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAutomaticGainControlLevelDb,
      jni.JniType.doubleType, []).doubleFloat;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(parcel_.Parcel parcel, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [parcel.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
