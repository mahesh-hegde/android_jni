// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Criteria.dart" as criteria_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.location.LocationProvider
///
/// An abstract superclass for location providers.  A location provider
/// provides periodic reports on the geographical location of the
/// device.
///
///  Each provider has a set of criteria under which it may be used;
/// for example, some providers require GPS hardware and visibility to
/// a number of satellites; others require the use of the cellular
/// radio, or access to a specific carrier's network, or to the
/// internet.  They may also have different battery consumption
/// characteristics or monetary costs to the user.  The Criteria class allows providers to be selected based on
/// user-specified criteria.
class LocationProvider extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/location/LocationProvider");
  LocationProvider.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AVAILABLE
  static const AVAILABLE = 2;

  /// from: static public final int OUT_OF_SERVICE
  static const OUT_OF_SERVICE = 0;

  /// from: static public final int TEMPORARILY_UNAVAILABLE
  static const TEMPORARILY_UNAVAILABLE = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LocationProvider()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of this provider.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_meetsCriteria = jniAccessors.getMethodIDOf(
      _classRef, "meetsCriteria", "(Landroid/location/Criteria;)Z");

  /// from: public boolean meetsCriteria(android.location.Criteria criteria)
  ///
  /// Returns true if this provider meets the given criteria,
  /// false otherwise.
  bool meetsCriteria(criteria_.Criteria criteria) =>
      jniAccessors.callMethodWithArgs(reference, _id_meetsCriteria,
          jni.JniType.booleanType, [criteria.reference]).boolean;

  static final _id_requiresNetwork =
      jniAccessors.getMethodIDOf(_classRef, "requiresNetwork", "()Z");

  /// from: public boolean requiresNetwork()
  ///
  /// Returns true if the provider requires access to a
  /// data network (e.g., the Internet), false otherwise.
  bool requiresNetwork() => jniAccessors.callMethodWithArgs(
      reference, _id_requiresNetwork, jni.JniType.booleanType, []).boolean;

  static final _id_requiresSatellite =
      jniAccessors.getMethodIDOf(_classRef, "requiresSatellite", "()Z");

  /// from: public boolean requiresSatellite()
  ///
  /// Returns true if the provider requires access to a
  /// satellite-based positioning system (e.g., GPS), false
  /// otherwise.
  bool requiresSatellite() => jniAccessors.callMethodWithArgs(
      reference, _id_requiresSatellite, jni.JniType.booleanType, []).boolean;

  static final _id_requiresCell =
      jniAccessors.getMethodIDOf(_classRef, "requiresCell", "()Z");

  /// from: public boolean requiresCell()
  ///
  /// Returns true if the provider requires access to an appropriate
  /// cellular network (e.g., to make use of cell tower IDs), false
  /// otherwise.
  bool requiresCell() => jniAccessors.callMethodWithArgs(
      reference, _id_requiresCell, jni.JniType.booleanType, []).boolean;

  static final _id_hasMonetaryCost =
      jniAccessors.getMethodIDOf(_classRef, "hasMonetaryCost", "()Z");

  /// from: public boolean hasMonetaryCost()
  ///
  /// Returns true if the use of this provider may result in a
  /// monetary charge to the user, false if use is free.  It is up to
  /// each provider to give accurate information.
  bool hasMonetaryCost() => jniAccessors.callMethodWithArgs(
      reference, _id_hasMonetaryCost, jni.JniType.booleanType, []).boolean;

  static final _id_supportsAltitude =
      jniAccessors.getMethodIDOf(_classRef, "supportsAltitude", "()Z");

  /// from: public boolean supportsAltitude()
  ///
  /// Returns true if the provider is able to provide altitude
  /// information, false otherwise.  A provider that reports altitude
  /// under most circumstances but may occassionally not report it
  /// should return true.
  bool supportsAltitude() => jniAccessors.callMethodWithArgs(
      reference, _id_supportsAltitude, jni.JniType.booleanType, []).boolean;

  static final _id_supportsSpeed =
      jniAccessors.getMethodIDOf(_classRef, "supportsSpeed", "()Z");

  /// from: public boolean supportsSpeed()
  ///
  /// Returns true if the provider is able to provide speed
  /// information, false otherwise.  A provider that reports speed
  /// under most circumstances but may occassionally not report it
  /// should return true.
  bool supportsSpeed() => jniAccessors.callMethodWithArgs(
      reference, _id_supportsSpeed, jni.JniType.booleanType, []).boolean;

  static final _id_supportsBearing =
      jniAccessors.getMethodIDOf(_classRef, "supportsBearing", "()Z");

  /// from: public boolean supportsBearing()
  ///
  /// Returns true if the provider is able to provide bearing
  /// information, false otherwise.  A provider that reports bearing
  /// under most circumstances but may occassionally not report it
  /// should return true.
  bool supportsBearing() => jniAccessors.callMethodWithArgs(
      reference, _id_supportsBearing, jni.JniType.booleanType, []).boolean;

  static final _id_getPowerRequirement =
      jniAccessors.getMethodIDOf(_classRef, "getPowerRequirement", "()I");

  /// from: public int getPowerRequirement()
  ///
  /// Returns the power requirement for this provider.
  ///@return the power requirement for this provider, as one of the
  /// constants Criteria.POWER_REQUIREMENT_*.
  int getPowerRequirement() => jniAccessors.callMethodWithArgs(
      reference, _id_getPowerRequirement, jni.JniType.intType, []).integer;

  static final _id_getAccuracy =
      jniAccessors.getMethodIDOf(_classRef, "getAccuracy", "()I");

  /// from: public int getAccuracy()
  ///
  /// Returns a constant describing horizontal accuracy of this provider.
  /// If the provider returns finer grain or exact location,
  /// Criteria\#ACCURACY_FINE is returned, otherwise if the
  /// location is only approximate then Criteria\#ACCURACY_COARSE
  /// is returned.
  int getAccuracy() => jniAccessors.callMethodWithArgs(
      reference, _id_getAccuracy, jni.JniType.intType, []).integer;
}
