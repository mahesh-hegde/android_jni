// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Bundle.dart" as bundle_;

import "../util/Printer.dart" as printer_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.location.Location
///
/// A data class representing a geographic location.
///
/// A location can consist of a latitude, longitude, timestamp,
/// and other information such as bearing, altitude and velocity.
///
/// All locations generated by the LocationManager are
/// guaranteed to have a valid latitude, longitude, and timestamp
/// (both UTC time and elapsed real-time since boot), all other
/// parameters are optional.
class Location extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/location/Location");
  Location.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.location.Location> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int FORMAT_DEGREES
  ///
  /// Constant used to specify formatting of a latitude or longitude
  /// in the form "[+-]DDD.DDDDD where D indicates degrees.
  static const FORMAT_DEGREES = 0;

  /// from: static public final int FORMAT_MINUTES
  ///
  /// Constant used to specify formatting of a latitude or longitude
  /// in the form "[+-]DDD:MM.MMMMM" where D indicates degrees and
  /// M indicates minutes of arc (1 minute = 1/60th of a degree).
  static const FORMAT_MINUTES = 1;

  /// from: static public final int FORMAT_SECONDS
  ///
  /// Constant used to specify formatting of a latitude or longitude
  /// in the form "DDD:MM:SS.SSSSS" where D indicates degrees, M
  /// indicates minutes of arc, and S indicates seconds of arc (1
  /// minute = 1/60th of a degree, 1 second = 1/3600th of a degree).
  static const FORMAT_SECONDS = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String provider)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new Location with a named provider.
  ///
  /// By default time, latitude and longitude are 0, and the location
  /// has no bearing, altitude, speed, accuracy or extras.
  ///@param provider the name of the provider that generated this location
  Location(jni.JniString provider)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [provider.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/location/Location;)V");

  /// from: public void <init>(android.location.Location l)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new Location object that is copied from an existing one.
  Location.ctor1(Location l)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [l.reference]).object);

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(Landroid/location/Location;)V");

  /// from: public void set(android.location.Location l)
  ///
  /// Sets the contents of the location to the values from the given location.
  void set0(Location l) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.voidType, [l.reference]).check();

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Clears the contents of the location.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_convert = jniAccessors.getStaticMethodIDOf(
      _classRef, "convert", "(DI)Ljava/lang/String;");

  /// from: static public java.lang.String convert(double coordinate, int outputType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a coordinate to a String representation. The outputType
  /// may be one of FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS.
  /// The coordinate must be a valid double between -180.0 and 180.0.
  /// This conversion is performed in a method that is dependent on the
  /// default locale, and so is not guaranteed to round-trip with
  /// \#convert(String).
  ///@throws IllegalArgumentException if coordinate is less than
  /// -180.0, greater than 180.0, or is not a number.
  ///@throws IllegalArgumentException if outputType is not one of
  /// FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS.
  static jni.JniString convert(double coordinate, int outputType) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_convert,
          jni.JniType.objectType,
          [coordinate, outputType]).object);

  static final _id_convert1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "convert", "(Ljava/lang/String;)D");

  /// from: static public double convert(java.lang.String coordinate)
  ///
  /// Converts a String in one of the formats described by
  /// FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS into a
  /// double. This conversion is performed in a locale agnostic
  /// method, and so is not guaranteed to round-trip with
  /// \#convert(double, int).
  ///@throws NullPointerException if coordinate is null
  ///@throws IllegalArgumentException if the coordinate is not
  /// in one of the valid formats.
  static double convert1(jni.JniString coordinate) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_convert1,
          jni.JniType.doubleType, [coordinate.reference]).doubleFloat;

  static final _id_distanceBetween = jniAccessors.getStaticMethodIDOf(
      _classRef, "distanceBetween", "(DDDD[F)V");

  /// from: static public void distanceBetween(double startLatitude, double startLongitude, double endLatitude, double endLongitude, float[] results)
  ///
  /// Computes the approximate distance in meters between two
  /// locations, and optionally the initial and final bearings of the
  /// shortest path between them.  Distance and bearing are defined using the
  /// WGS84 ellipsoid.
  ///
  ///  The computed distance is stored in results[0].  If results has length
  /// 2 or greater, the initial bearing is stored in results[1]. If results has
  /// length 3 or greater, the final bearing is stored in results[2].
  ///@param startLatitude the starting latitude
  ///@param startLongitude the starting longitude
  ///@param endLatitude the ending latitude
  ///@param endLongitude the ending longitude
  ///@param results an array of floats to hold the results
  ///@throws IllegalArgumentException if results is null or has length < 1
  static void distanceBetween(double startLatitude, double startLongitude,
          double endLatitude, double endLongitude, jni.JniObject results) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_distanceBetween, jni.JniType.voidType, [
        startLatitude,
        startLongitude,
        endLatitude,
        endLongitude,
        results.reference
      ]).check();

  static final _id_distanceTo = jniAccessors.getMethodIDOf(
      _classRef, "distanceTo", "(Landroid/location/Location;)F");

  /// from: public float distanceTo(android.location.Location dest)
  ///
  /// Returns the approximate distance in meters between this
  /// location and the given location.  Distance is defined using
  /// the WGS84 ellipsoid.
  ///@param dest the destination location
  ///@return the approximate distance in meters
  double distanceTo(Location dest) => jniAccessors.callMethodWithArgs(
      reference, _id_distanceTo, jni.JniType.floatType, [dest.reference]).float;

  static final _id_bearingTo = jniAccessors.getMethodIDOf(
      _classRef, "bearingTo", "(Landroid/location/Location;)F");

  /// from: public float bearingTo(android.location.Location dest)
  ///
  /// Returns the approximate initial bearing in degrees East of true
  /// North when traveling along the shortest path between this
  /// location and the given location.  The shortest path is defined
  /// using the WGS84 ellipsoid.  Locations that are (nearly)
  /// antipodal may produce meaningless results.
  ///@param dest the destination location
  ///@return the initial bearing in degrees
  double bearingTo(Location dest) => jniAccessors.callMethodWithArgs(
      reference, _id_bearingTo, jni.JniType.floatType, [dest.reference]).float;

  static final _id_getProvider = jniAccessors.getMethodIDOf(
      _classRef, "getProvider", "()Ljava/lang/String;");

  /// from: public java.lang.String getProvider()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of the provider that generated this fix.
  ///@return the provider, or null if it has not been set
  jni.JniString getProvider() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getProvider, jni.JniType.objectType, []).object);

  static final _id_setProvider = jniAccessors.getMethodIDOf(
      _classRef, "setProvider", "(Ljava/lang/String;)V");

  /// from: public void setProvider(java.lang.String provider)
  ///
  /// Sets the name of the provider that generated this fix.
  void setProvider(jni.JniString provider) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setProvider,
      jni.JniType.voidType,
      [provider.reference]).check();

  static final _id_getTime =
      jniAccessors.getMethodIDOf(_classRef, "getTime", "()J");

  /// from: public long getTime()
  ///
  /// Return the UTC time of this fix, in milliseconds since January 1, 1970.
  ///
  /// Note that the UTC time on a device is not monotonic: it
  /// can jump forwards or backwards unpredictably. So always use
  /// \#getElapsedRealtimeNanos when calculating time deltas.
  ///
  /// On the other hand, \#getTime is useful for presenting
  /// a human readable time to the user, or for carefully comparing
  /// location fixes across reboot or across devices.
  ///
  /// All locations generated by the LocationManager
  /// are guaranteed to have a valid UTC time, however remember that
  /// the system time may have changed since the location was generated.
  ///@return time of fix, in milliseconds since January 1, 1970.
  int getTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getTime, jni.JniType.longType, []).long;

  static final _id_setTime =
      jniAccessors.getMethodIDOf(_classRef, "setTime", "(J)V");

  /// from: public void setTime(long time)
  ///
  /// Set the UTC time of this fix, in milliseconds since January 1,
  /// 1970.
  ///@param time UTC time of this fix, in milliseconds since January 1, 1970
  void setTime(int time) => jniAccessors.callMethodWithArgs(
      reference, _id_setTime, jni.JniType.voidType, [time]).check();

  static final _id_getElapsedRealtimeNanos =
      jniAccessors.getMethodIDOf(_classRef, "getElapsedRealtimeNanos", "()J");

  /// from: public long getElapsedRealtimeNanos()
  ///
  /// Return the time of this fix, in elapsed real-time since system boot.
  ///
  /// This value can be reliably compared to
  /// android.os.SystemClock\#elapsedRealtimeNanos,
  /// to calculate the age of a fix and to compare Location fixes. This
  /// is reliable because elapsed real-time is guaranteed monotonic for
  /// each system boot and continues to increment even when the system
  /// is in deep sleep (unlike \#getTime.
  ///
  /// All locations generated by the LocationManager
  /// are guaranteed to have a valid elapsed real-time.
  ///@return elapsed real-time of fix, in nanoseconds since system boot.
  int getElapsedRealtimeNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_getElapsedRealtimeNanos, jni.JniType.longType, []).long;

  static final _id_setElapsedRealtimeNanos =
      jniAccessors.getMethodIDOf(_classRef, "setElapsedRealtimeNanos", "(J)V");

  /// from: public void setElapsedRealtimeNanos(long time)
  ///
  /// Set the time of this fix, in elapsed real-time since system boot.
  ///@param time elapsed real-time of fix, in nanoseconds since system boot.
  void setElapsedRealtimeNanos(int time) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setElapsedRealtimeNanos,
      jni.JniType.voidType,
      [time]).check();

  static final _id_getLatitude =
      jniAccessors.getMethodIDOf(_classRef, "getLatitude", "()D");

  /// from: public double getLatitude()
  ///
  /// Get the latitude, in degrees.
  ///
  /// All locations generated by the LocationManager
  /// will have a valid latitude.
  double getLatitude() => jniAccessors.callMethodWithArgs(
      reference, _id_getLatitude, jni.JniType.doubleType, []).doubleFloat;

  static final _id_setLatitude =
      jniAccessors.getMethodIDOf(_classRef, "setLatitude", "(D)V");

  /// from: public void setLatitude(double latitude)
  ///
  /// Set the latitude, in degrees.
  void setLatitude(double latitude) => jniAccessors.callMethodWithArgs(
      reference, _id_setLatitude, jni.JniType.voidType, [latitude]).check();

  static final _id_getLongitude =
      jniAccessors.getMethodIDOf(_classRef, "getLongitude", "()D");

  /// from: public double getLongitude()
  ///
  /// Get the longitude, in degrees.
  ///
  /// All locations generated by the LocationManager
  /// will have a valid longitude.
  double getLongitude() => jniAccessors.callMethodWithArgs(
      reference, _id_getLongitude, jni.JniType.doubleType, []).doubleFloat;

  static final _id_setLongitude =
      jniAccessors.getMethodIDOf(_classRef, "setLongitude", "(D)V");

  /// from: public void setLongitude(double longitude)
  ///
  /// Set the longitude, in degrees.
  void setLongitude(double longitude) => jniAccessors.callMethodWithArgs(
      reference, _id_setLongitude, jni.JniType.voidType, [longitude]).check();

  static final _id_hasAltitude =
      jniAccessors.getMethodIDOf(_classRef, "hasAltitude", "()Z");

  /// from: public boolean hasAltitude()
  ///
  /// True if this location has an altitude.
  bool hasAltitude() => jniAccessors.callMethodWithArgs(
      reference, _id_hasAltitude, jni.JniType.booleanType, []).boolean;

  static final _id_getAltitude =
      jniAccessors.getMethodIDOf(_classRef, "getAltitude", "()D");

  /// from: public double getAltitude()
  ///
  /// Get the altitude if available, in meters above the WGS 84 reference
  /// ellipsoid.
  ///
  /// If this location does not have an altitude then 0.0 is returned.
  double getAltitude() => jniAccessors.callMethodWithArgs(
      reference, _id_getAltitude, jni.JniType.doubleType, []).doubleFloat;

  static final _id_setAltitude =
      jniAccessors.getMethodIDOf(_classRef, "setAltitude", "(D)V");

  /// from: public void setAltitude(double altitude)
  ///
  /// Set the altitude, in meters above the WGS 84 reference ellipsoid.
  ///
  /// Following this call \#hasAltitude will return true.
  void setAltitude(double altitude) => jniAccessors.callMethodWithArgs(
      reference, _id_setAltitude, jni.JniType.voidType, [altitude]).check();

  static final _id_removeAltitude =
      jniAccessors.getMethodIDOf(_classRef, "removeAltitude", "()V");

  /// from: public void removeAltitude()
  ///
  /// Remove the altitude from this location.
  ///
  /// Following this call \#hasAltitude will return false,
  /// and \#getAltitude will return 0.0.
  ///@deprecated use a new Location object for location updates.
  void removeAltitude() => jniAccessors.callMethodWithArgs(
      reference, _id_removeAltitude, jni.JniType.voidType, []).check();

  static final _id_hasSpeed =
      jniAccessors.getMethodIDOf(_classRef, "hasSpeed", "()Z");

  /// from: public boolean hasSpeed()
  ///
  /// True if this location has a speed.
  bool hasSpeed() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSpeed, jni.JniType.booleanType, []).boolean;

  static final _id_getSpeed =
      jniAccessors.getMethodIDOf(_classRef, "getSpeed", "()F");

  /// from: public float getSpeed()
  ///
  /// Get the speed if it is available, in meters/second over ground.
  ///
  /// If this location does not have a speed then 0.0 is returned.
  double getSpeed() => jniAccessors.callMethodWithArgs(
      reference, _id_getSpeed, jni.JniType.floatType, []).float;

  static final _id_setSpeed =
      jniAccessors.getMethodIDOf(_classRef, "setSpeed", "(F)V");

  /// from: public void setSpeed(float speed)
  ///
  /// Set the speed, in meters/second over ground.
  ///
  /// Following this call \#hasSpeed will return true.
  void setSpeed(double speed) => jniAccessors.callMethodWithArgs(
      reference, _id_setSpeed, jni.JniType.voidType, [speed]).check();

  static final _id_removeSpeed =
      jniAccessors.getMethodIDOf(_classRef, "removeSpeed", "()V");

  /// from: public void removeSpeed()
  ///
  /// Remove the speed from this location.
  ///
  /// Following this call \#hasSpeed will return false,
  /// and \#getSpeed will return 0.0.
  ///@deprecated use a new Location object for location updates.
  void removeSpeed() => jniAccessors.callMethodWithArgs(
      reference, _id_removeSpeed, jni.JniType.voidType, []).check();

  static final _id_hasBearing =
      jniAccessors.getMethodIDOf(_classRef, "hasBearing", "()Z");

  /// from: public boolean hasBearing()
  ///
  /// True if this location has a bearing.
  bool hasBearing() => jniAccessors.callMethodWithArgs(
      reference, _id_hasBearing, jni.JniType.booleanType, []).boolean;

  static final _id_getBearing =
      jniAccessors.getMethodIDOf(_classRef, "getBearing", "()F");

  /// from: public float getBearing()
  ///
  /// Get the bearing, in degrees.
  ///
  /// Bearing is the horizontal direction of travel of this device,
  /// and is not related to the device orientation. It is guaranteed to
  /// be in the range (0.0, 360.0] if the device has a bearing.
  ///
  /// If this location does not have a bearing then 0.0 is returned.
  double getBearing() => jniAccessors.callMethodWithArgs(
      reference, _id_getBearing, jni.JniType.floatType, []).float;

  static final _id_setBearing =
      jniAccessors.getMethodIDOf(_classRef, "setBearing", "(F)V");

  /// from: public void setBearing(float bearing)
  ///
  /// Set the bearing, in degrees.
  ///
  /// Bearing is the horizontal direction of travel of this device,
  /// and is not related to the device orientation.
  ///
  /// The input will be wrapped into the range (0.0, 360.0].
  void setBearing(double bearing) => jniAccessors.callMethodWithArgs(
      reference, _id_setBearing, jni.JniType.voidType, [bearing]).check();

  static final _id_removeBearing =
      jniAccessors.getMethodIDOf(_classRef, "removeBearing", "()V");

  /// from: public void removeBearing()
  ///
  /// Remove the bearing from this location.
  ///
  /// Following this call \#hasBearing will return false,
  /// and \#getBearing will return 0.0.
  ///@deprecated use a new Location object for location updates.
  void removeBearing() => jniAccessors.callMethodWithArgs(
      reference, _id_removeBearing, jni.JniType.voidType, []).check();

  static final _id_hasAccuracy =
      jniAccessors.getMethodIDOf(_classRef, "hasAccuracy", "()Z");

  /// from: public boolean hasAccuracy()
  ///
  /// True if this location has a horizontal accuracy.
  ///
  /// All locations generated by the LocationManager have an horizontal accuracy.
  bool hasAccuracy() => jniAccessors.callMethodWithArgs(
      reference, _id_hasAccuracy, jni.JniType.booleanType, []).boolean;

  static final _id_getAccuracy =
      jniAccessors.getMethodIDOf(_classRef, "getAccuracy", "()F");

  /// from: public float getAccuracy()
  ///
  /// Get the estimated horizontal accuracy of this location, radial, in meters.
  ///
  /// We define horizontal accuracy as the radius of 68% confidence. In other
  /// words, if you draw a circle centered at this location's
  /// latitude and longitude, and with a radius equal to the accuracy,
  /// then there is a 68% probability that the true location is inside
  /// the circle.
  ///
  /// This accuracy estimation is only concerned with horizontal
  /// accuracy, and does not indicate the accuracy of bearing,
  /// velocity or altitude if those are included in this Location.
  ///
  /// If this location does not have a horizontal accuracy, then 0.0 is returned.
  /// All locations generated by the LocationManager include horizontal accuracy.
  double getAccuracy() => jniAccessors.callMethodWithArgs(
      reference, _id_getAccuracy, jni.JniType.floatType, []).float;

  static final _id_setAccuracy =
      jniAccessors.getMethodIDOf(_classRef, "setAccuracy", "(F)V");

  /// from: public void setAccuracy(float horizontalAccuracy)
  ///
  /// Set the estimated horizontal accuracy of this location, meters.
  ///
  /// See \#getAccuracy for the definition of horizontal accuracy.
  ///
  /// Following this call \#hasAccuracy will return true.
  void setAccuracy(double horizontalAccuracy) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAccuracy,
          jni.JniType.voidType, [horizontalAccuracy]).check();

  static final _id_removeAccuracy =
      jniAccessors.getMethodIDOf(_classRef, "removeAccuracy", "()V");

  /// from: public void removeAccuracy()
  ///
  /// Remove the horizontal accuracy from this location.
  ///
  /// Following this call \#hasAccuracy will return false, and
  /// \#getAccuracy will return 0.0.
  ///@deprecated use a new Location object for location updates.
  void removeAccuracy() => jniAccessors.callMethodWithArgs(
      reference, _id_removeAccuracy, jni.JniType.voidType, []).check();

  static final _id_hasVerticalAccuracy =
      jniAccessors.getMethodIDOf(_classRef, "hasVerticalAccuracy", "()Z");

  /// from: public boolean hasVerticalAccuracy()
  ///
  /// True if this location has a vertical accuracy.
  bool hasVerticalAccuracy() => jniAccessors.callMethodWithArgs(
      reference, _id_hasVerticalAccuracy, jni.JniType.booleanType, []).boolean;

  static final _id_getVerticalAccuracyMeters =
      jniAccessors.getMethodIDOf(_classRef, "getVerticalAccuracyMeters", "()F");

  /// from: public float getVerticalAccuracyMeters()
  ///
  /// Get the estimated vertical accuracy of this location, in meters.
  ///
  /// We define vertical accuracy at 68% confidence.  Specifically, as 1-side of the
  /// 2-sided range above and below the estimated altitude reported by \#getAltitude(),
  /// within which there is a 68% probability of finding the true altitude.
  ///
  /// In the case where the underlying distribution is assumed Gaussian normal, this would be
  /// considered 1 standard deviation.
  ///
  /// For example, if \#getAltitude() returns 150, and
  /// \#getVerticalAccuracyMeters() returns 20 then there is a 68% probability
  /// of the true altitude being between 130 and 170 meters.
  ///
  /// If this location does not have a vertical accuracy, then 0.0 is returned.
  double getVerticalAccuracyMeters() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getVerticalAccuracyMeters,
      jni.JniType.floatType, []).float;

  static final _id_setVerticalAccuracyMeters = jniAccessors.getMethodIDOf(
      _classRef, "setVerticalAccuracyMeters", "(F)V");

  /// from: public void setVerticalAccuracyMeters(float verticalAccuracyMeters)
  ///
  /// Set the estimated vertical accuracy of this location, meters.
  ///
  /// See \#getVerticalAccuracyMeters for the definition of vertical accuracy.
  ///
  /// Following this call \#hasVerticalAccuracy will return true.
  void setVerticalAccuracyMeters(double verticalAccuracyMeters) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVerticalAccuracyMeters,
          jni.JniType.voidType, [verticalAccuracyMeters]).check();

  static final _id_hasSpeedAccuracy =
      jniAccessors.getMethodIDOf(_classRef, "hasSpeedAccuracy", "()Z");

  /// from: public boolean hasSpeedAccuracy()
  ///
  /// True if this location has a speed accuracy.
  bool hasSpeedAccuracy() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSpeedAccuracy, jni.JniType.booleanType, []).boolean;

  static final _id_getSpeedAccuracyMetersPerSecond = jniAccessors.getMethodIDOf(
      _classRef, "getSpeedAccuracyMetersPerSecond", "()F");

  /// from: public float getSpeedAccuracyMetersPerSecond()
  ///
  /// Get the estimated speed accuracy of this location, in meters per second.
  ///
  /// We define speed accuracy at 68% confidence.  Specifically, as 1-side of the
  /// 2-sided range above and below the estimated speed reported by \#getSpeed(),
  /// within which there is a 68% probability of finding the true speed.
  ///
  /// In the case where the underlying
  /// distribution is assumed Gaussian normal, this would be considered 1 standard deviation.
  ///
  /// For example, if \#getSpeed() returns 5, and
  /// \#getSpeedAccuracyMetersPerSecond() returns 1, then there is a 68% probability of
  /// the true speed being between 4 and 6 meters per second.
  ///
  /// Note that the speed and speed accuracy is often better than would be obtained simply from
  /// differencing sequential positions, such as when the Doppler measurements from GNSS satellites
  /// are used.
  ///
  /// If this location does not have a speed accuracy, then 0.0 is returned.
  double getSpeedAccuracyMetersPerSecond() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getSpeedAccuracyMetersPerSecond,
      jni.JniType.floatType, []).float;

  static final _id_setSpeedAccuracyMetersPerSecond = jniAccessors.getMethodIDOf(
      _classRef, "setSpeedAccuracyMetersPerSecond", "(F)V");

  /// from: public void setSpeedAccuracyMetersPerSecond(float speedAccuracyMeterPerSecond)
  ///
  /// Set the estimated speed accuracy of this location, meters per second.
  ///
  /// See \#getSpeedAccuracyMetersPerSecond for the definition of speed accuracy.
  ///
  /// Following this call \#hasSpeedAccuracy will return true.
  void setSpeedAccuracyMetersPerSecond(double speedAccuracyMeterPerSecond) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSpeedAccuracyMetersPerSecond,
          jni.JniType.voidType,
          [speedAccuracyMeterPerSecond]).check();

  static final _id_hasBearingAccuracy =
      jniAccessors.getMethodIDOf(_classRef, "hasBearingAccuracy", "()Z");

  /// from: public boolean hasBearingAccuracy()
  ///
  /// True if this location has a bearing accuracy.
  bool hasBearingAccuracy() => jniAccessors.callMethodWithArgs(
      reference, _id_hasBearingAccuracy, jni.JniType.booleanType, []).boolean;

  static final _id_getBearingAccuracyDegrees =
      jniAccessors.getMethodIDOf(_classRef, "getBearingAccuracyDegrees", "()F");

  /// from: public float getBearingAccuracyDegrees()
  ///
  /// Get the estimated bearing accuracy of this location, in degrees.
  ///
  /// We define bearing accuracy at 68% confidence.  Specifically, as 1-side of the
  /// 2-sided range on each side of the estimated bearing reported by \#getBearing(),
  /// within which there is a 68% probability of finding the true bearing.
  ///
  /// In the case where the underlying distribution is assumed Gaussian normal, this would be
  /// considered 1 standard deviation.
  ///
  /// For example, if \#getBearing() returns 60, and
  /// \#getBearingAccuracyDegrees() returns 10, then there is a 68% probability of the
  /// true bearing being between 50 and 70 degrees.
  ///
  /// If this location does not have a bearing accuracy, then 0.0 is returned.
  double getBearingAccuracyDegrees() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getBearingAccuracyDegrees,
      jni.JniType.floatType, []).float;

  static final _id_setBearingAccuracyDegrees = jniAccessors.getMethodIDOf(
      _classRef, "setBearingAccuracyDegrees", "(F)V");

  /// from: public void setBearingAccuracyDegrees(float bearingAccuracyDegrees)
  ///
  /// Set the estimated bearing accuracy of this location, degrees.
  ///
  /// See \#getBearingAccuracyDegrees for the definition of bearing accuracy.
  ///
  /// Following this call \#hasBearingAccuracy will return true.
  void setBearingAccuracyDegrees(double bearingAccuracyDegrees) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBearingAccuracyDegrees,
          jni.JniType.voidType, [bearingAccuracyDegrees]).check();

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns additional provider-specific information about the
  /// location fix as a Bundle.  The keys and values are determined
  /// by the provider.  If no additional information is available,
  /// null is returned.
  ///
  ///  A number of common key/value pairs are listed
  /// below. Providers that use any of the keys on this list must
  /// provide the corresponding value as described below.
  ///
  /// <ul>
  /// <li> satellites - the number of satellites used to derive the fix
  /// </ul>
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_setExtras = jniAccessors.getMethodIDOf(
      _classRef, "setExtras", "(Landroid/os/Bundle;)V");

  /// from: public void setExtras(android.os.Bundle extras)
  ///
  /// Sets the extra information associated with this fix to the
  /// given Bundle.
  void setExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Landroid/util/Printer;Ljava/lang/String;)V");

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(printer_.Printer pw, jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [pw.reference, prefix.reference]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(parcel_.Parcel parcel, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [parcel.reference, flags]).check();

  static final _id_isFromMockProvider =
      jniAccessors.getMethodIDOf(_classRef, "isFromMockProvider", "()Z");

  /// from: public boolean isFromMockProvider()
  ///
  /// Returns true if the Location came from a mock provider.
  ///@return true if this Location came from a mock provider, false otherwise
  bool isFromMockProvider() => jniAccessors.callMethodWithArgs(
      reference, _id_isFromMockProvider, jni.JniType.booleanType, []).boolean;
}
