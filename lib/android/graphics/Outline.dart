// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Rect.dart" as rect_;

import "Path.dart" as path_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Outline
///
/// Defines a simple shape, used for bounding graphical regions.
///
/// Can be computed for a View, or computed by a Drawable, to drive the shape of
/// shadows cast by a View, or to clip the contents of the View.
///@see android.view.ViewOutlineProvider
///@see android.view.View\#setOutlineProvider(android.view.ViewOutlineProvider)
///@see Drawable\#getOutline(Outline)
class Outline extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Outline");
  Outline.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs an empty Outline. Call one of the setter methods to make
  /// the outline valid for use with a View.
  Outline()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Outline;)V");

  /// from: public void <init>(android.graphics.Outline src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs an Outline with a copy of the data in src.
  ///@param src This value must never be {@code null}.
  Outline.ctor1(Outline src)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [src.reference]).object);

  static final _id_setEmpty =
      jniAccessors.getMethodIDOf(_classRef, "setEmpty", "()V");

  /// from: public void setEmpty()
  ///
  /// Sets the outline to be empty.
  ///@see \#isEmpty()
  void setEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_setEmpty, jni.JniType.voidType, []).check();

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public boolean isEmpty()
  ///
  /// Returns whether the Outline is empty.
  ///
  /// Outlines are empty when constructed, or if \#setEmpty() is called,
  /// until a setter method is called
  ///@see \#setEmpty()
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniType.booleanType, []).boolean;

  static final _id_canClip =
      jniAccessors.getMethodIDOf(_classRef, "canClip", "()Z");

  /// from: public boolean canClip()
  ///
  /// Returns whether the outline can be used to clip a View.
  ///
  /// Currently, only Outlines that can be represented as a rectangle, circle,
  /// or round rect support clipping.
  ///@see android.view.View\#setClipToOutline(boolean)
  bool canClip() => jniAccessors.callMethodWithArgs(
      reference, _id_canClip, jni.JniType.booleanType, []).boolean;

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(F)V");

  /// from: public void setAlpha(float alpha)
  ///
  /// Sets the alpha represented by the Outline - the degree to which the
  /// producer is guaranteed to be opaque over the Outline's shape.
  ///
  /// An alpha value of <code>0.0f</code> either represents completely
  /// transparent content, or content that isn't guaranteed to fill the shape
  /// it publishes.
  ///
  /// Content producing a fully opaque (alpha = <code>1.0f</code>) outline is
  /// assumed by the drawing system to fully cover content beneath it,
  /// meaning content beneath may be optimized away.
  ///@param alpha Value is between 0.0 and 1.0 inclusive
  void setAlpha(double alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()F");

  /// from: public float getAlpha()
  ///
  /// Returns the alpha represented by the Outline.
  double getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.floatType, []).float;

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(Landroid/graphics/Outline;)V");

  /// from: public void set(android.graphics.Outline src)
  ///
  /// Replace the contents of this Outline with the contents of src.
  ///@param src Source outline to copy from.
  ///
  /// This value must never be {@code null}.
  void set0(Outline src) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.voidType, [src.reference]).check();

  static final _id_setRect =
      jniAccessors.getMethodIDOf(_classRef, "setRect", "(IIII)V");

  /// from: public void setRect(int left, int top, int right, int bottom)
  ///
  /// Sets the Outline to the rounded rect defined by the input rect, and
  /// corner radius.
  void setRect(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRect,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_setRect1 = jniAccessors.getMethodIDOf(
      _classRef, "setRect", "(Landroid/graphics/Rect;)V");

  /// from: public void setRect(android.graphics.Rect rect)
  ///
  /// Convenience for \#setRect(int, int, int, int)
  ///@param rect This value must never be {@code null}.
  void setRect1(rect_.Rect rect) => jniAccessors.callMethodWithArgs(
      reference, _id_setRect1, jni.JniType.voidType, [rect.reference]).check();

  static final _id_setRoundRect =
      jniAccessors.getMethodIDOf(_classRef, "setRoundRect", "(IIIIF)V");

  /// from: public void setRoundRect(int left, int top, int right, int bottom, float radius)
  ///
  /// Sets the Outline to the rounded rect defined by the input rect, and corner radius.
  ///
  /// Passing a zero radius is equivalent to calling \#setRect(int, int, int, int)
  void setRoundRect(int left, int top, int right, int bottom, double radius) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRoundRect,
          jni.JniType.voidType, [left, top, right, bottom, radius]).check();

  static final _id_setRoundRect1 = jniAccessors.getMethodIDOf(
      _classRef, "setRoundRect", "(Landroid/graphics/Rect;F)V");

  /// from: public void setRoundRect(android.graphics.Rect rect, float radius)
  ///
  /// Convenience for \#setRoundRect(int, int, int, int, float)
  ///@param rect This value must never be {@code null}.
  void setRoundRect1(rect_.Rect rect, double radius) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRoundRect1,
          jni.JniType.voidType, [rect.reference, radius]).check();

  static final _id_getRect = jniAccessors.getMethodIDOf(
      _classRef, "getRect", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean getRect(android.graphics.Rect outRect)
  ///
  /// Populates {@code outBounds} with the outline bounds, if set, and returns
  /// {@code true}. If no outline bounds are set, or if a path has been set
  /// via \#setConvexPath(Path), returns {@code false}.
  ///@param outRect the rect to populate with the outline bounds, if set
  /// This value must never be {@code null}.
  ///@return {@code true} if {@code outBounds} was populated with outline
  ///         bounds, or {@code false} if no outline bounds are set
  bool getRect(rect_.Rect outRect) => jniAccessors.callMethodWithArgs(reference,
      _id_getRect, jni.JniType.booleanType, [outRect.reference]).boolean;

  static final _id_getRadius =
      jniAccessors.getMethodIDOf(_classRef, "getRadius", "()F");

  /// from: public float getRadius()
  ///
  /// Returns the rounded rect radius, if set, or a value less than 0 if a path has
  /// been set via \#setConvexPath(Path). A return value of {@code 0}
  /// indicates a non-rounded rect.
  ///@return the rounded rect radius, or value < 0
  double getRadius() => jniAccessors.callMethodWithArgs(
      reference, _id_getRadius, jni.JniType.floatType, []).float;

  static final _id_setOval =
      jniAccessors.getMethodIDOf(_classRef, "setOval", "(IIII)V");

  /// from: public void setOval(int left, int top, int right, int bottom)
  ///
  /// Sets the outline to the oval defined by input rect.
  void setOval(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOval,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_setOval1 = jniAccessors.getMethodIDOf(
      _classRef, "setOval", "(Landroid/graphics/Rect;)V");

  /// from: public void setOval(android.graphics.Rect rect)
  ///
  /// Convenience for \#setOval(int, int, int, int)
  ///@param rect This value must never be {@code null}.
  void setOval1(rect_.Rect rect) => jniAccessors.callMethodWithArgs(
      reference, _id_setOval1, jni.JniType.voidType, [rect.reference]).check();

  static final _id_setConvexPath = jniAccessors.getMethodIDOf(
      _classRef, "setConvexPath", "(Landroid/graphics/Path;)V");

  /// from: public void setConvexPath(android.graphics.Path convexPath)
  ///
  /// Sets the Constructs an Outline from a
  /// android.graphics.Path\#isConvex() convex path.
  ///@param convexPath This value must never be {@code null}.
  void setConvexPath(path_.Path convexPath) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setConvexPath,
      jni.JniType.voidType,
      [convexPath.reference]).check();

  static final _id_offset =
      jniAccessors.getMethodIDOf(_classRef, "offset", "(II)V");

  /// from: public void offset(int dx, int dy)
  ///
  /// Offsets the Outline by (dx,dy)
  void offset(int dx, int dy) => jniAccessors.callMethodWithArgs(
      reference, _id_offset, jni.JniType.voidType, [dx, dy]).check();
}
