// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ColorSpace.dart" as colorspace_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Color
///
/// {@usesMathJax }
///
/// The <code>Color</code> class provides methods for creating, converting and
/// manipulating colors. Colors have three different representations:
///
/// <ul>
///     <li>Color ints, the most common representation</li>
///     <li>Color longs</li>
///     <li><code>Color</code> instances</li>
/// </ul>
/// The section below describe each representation in detail.
///
///
/// <h3>Color ints</h3>
/// Color ints are the most common representation of colors on Android and
/// have been used since android.os.Build.VERSION_CODES\#BASE API level 1.
///
///
/// A color int always defines a color in the ColorSpace.Named\#SRGB sRGB
/// color space using 4 components packed in a single 32 bit integer value:
///
///
/// <table summary="Color int definition">
///     <tr>
///         <th>Component</th><th>Name</th><th>Size</th><th>Range</th>
///     </tr>
///     <tr><td>A</td><td>Alpha</td><td>8 bits</td><td>\([0..255]\)</td></tr>
///     <tr><td>R</td><td>Red</td><td>8 bits</td><td>\([0..255]\)</td></tr>
///     <tr><td>G</td><td>Green</td><td>8 bits</td><td>\([0..255]\)</td></tr>
///     <tr><td>B</td><td>Blue</td><td>8 bits</td><td>\([0..255]\)</td></tr>
/// </table>
///
/// The components in this table are listed in encoding order (see below),
/// which is why color ints are called ARGB colors.
///
///
/// <h4>Usage in code</h4>
/// To avoid confusing color ints with arbitrary integer values, it is a
/// good practice to annotate them with the <code>@ColorInt</code> annotation
/// found in the Android Support Library.
///
///
/// <h4>Encoding</h4>
/// The four components of a color int are encoded in the following way:
///
/// <pre class="prettyprint">
/// int color = (A & 0xff) << 24 | (R & 0xff) << 16 | (G & 0xff) << 8 | (B & 0xff);
/// </pre>
///
/// Because of this encoding, color ints can easily be described as an integer
/// constant in source. For instance, opaque blue is <code>0xff0000ff</code>
/// and yellow is <code>0xffffff00</code>.
///
///
/// To easily encode color ints, it is recommended to use the static methods
/// \#argb(int, int, int, int) and \#rgb(int, int, int). The second
/// method omits the alpha component and assumes the color is opaque (alpha is 255).
/// As a convenience this class also offers methods to encode color ints from components
/// defined in the \([0..1]\) range: \#argb(float, float, float, float) and
/// \#rgb(float, float, float).
///
///
/// Color longs (defined below) can be easily converted to color ints by invoking
/// the \#toArgb(long) method. This method performs a color space conversion
/// if needed.
///
///
/// It is also possible to create a color int by invoking the method \#toArgb()
/// on a color instance.
///
///
/// <h4>Decoding</h4>
/// The four ARGB components can be individually extracted from a color int
/// using the following expressions:
///
/// <pre class="prettyprint">
/// int A = (color >> 24) & 0xff; // or color >>> 24
/// int R = (color >> 16) & 0xff;
/// int G = (color >>  8) & 0xff;
/// int B = (color      ) & 0xff;
/// </pre>
///
/// This class offers convenience methods to easily extract these components:
///
/// <ul>
///     <li>\#alpha(int) to extract the alpha component</li>
///     <li>\#red(int) to extract the red component</li>
///     <li>\#green(int) to extract the green component</li>
///     <li>\#blue(int) to extract the blue component</li>
/// </ul>
///
/// <h3>Color longs</h3>
/// Color longs are a representation introduced in
/// android.os.Build.VERSION_CODES\#O Android O to store colors in different
/// ColorSpace color spaces, with more precision than color ints.
///
///
/// A color long always defines a color using 4 components packed in a single
/// 64 bit long value. One of these components is always alpha while the other
/// three components depend on the color space's ColorSpace.Model color model.
/// The most common color model is the ColorSpace.Model\#RGB RGB model in
/// which the components represent red, green and blue values.
///
///
/// <p class="note">__Component ranges:__ the ranges defined in the tables
/// below indicate the ranges that can be encoded in a color long. They do not
/// represent the actual ranges as they may differ per color space. For instance,
/// the RGB components of a color in the ColorSpace.Named\#DISPLAY_P3 Display P3
/// color space use the \([0..1]\) range. Please refer to the documentation of the
/// various ColorSpace.Named color spaces to find their respective ranges.
///
///
/// <p class="note">__Alpha range:__ while alpha is encoded in a color long using
/// a 10 bit integer (thus using a range of \([0..1023]\)), it is converted to and
/// from \([0..1]\) float values when decoding and encoding color longs.
///
///
/// <p class="note">__sRGB color space:__ for compatibility reasons and ease of
/// use, color longs encoding ColorSpace.Named\#SRGB sRGB colors do not
/// use the same encoding as other color longs.
///
///
/// <table summary="Color long definition">
///     <tr>
///         <th>Component</th><th>Name</th><th>Size</th><th>Range</th>
///     </tr>
///     <tr><td colspan="4">ColorSpace.Model\#RGB RGB color model</td></tr>
///     <tr><td>R</td><td>Red</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>G</td><td>Green</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>B</td><td>Blue</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>A</td><td>Alpha</td><td>10 bits</td><td>\([0..1023]\)</td></tr>
///     <tr><td></td><td>Color space</td><td>6 bits</td><td>\([0..63]\)</td></tr>
///     <tr><td colspan="4">ColorSpace.Named\#SRGB sRGB color space</td></tr>
///     <tr><td>A</td><td>Alpha</td><td>8 bits</td><td>\([0..255]\)</td></tr>
///     <tr><td>R</td><td>Red</td><td>8 bits</td><td>\([0..255]\)</td></tr>
///     <tr><td>G</td><td>Green</td><td>8 bits</td><td>\([0..255]\)</td></tr>
///     <tr><td>B</td><td>Blue</td><td>8 bits</td><td>\([0..255]\)</td></tr>
///     <tr><td>X</td><td>Unused</td><td>32 bits</td><td>\(0\)</td></tr>
///     <tr><td colspan="4">ColorSpace.Model\#XYZ XYZ color model</td></tr>
///     <tr><td>X</td><td>X</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>Y</td><td>Y</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>Z</td><td>Z</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>A</td><td>Alpha</td><td>10 bits</td><td>\([0..1023]\)</td></tr>
///     <tr><td></td><td>Color space</td><td>6 bits</td><td>\([0..63]\)</td></tr>
///     <tr><td colspan="4">ColorSpace.Model\#XYZ Lab color model</td></tr>
///     <tr><td>L</td><td>L</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>a</td><td>a</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>b</td><td>b</td><td>16 bits</td><td>\([-65504.0, 65504.0]\)</td></tr>
///     <tr><td>A</td><td>Alpha</td><td>10 bits</td><td>\([0..1023]\)</td></tr>
///     <tr><td></td><td>Color space</td><td>6 bits</td><td>\([0..63]\)</td></tr>
///     <tr><td colspan="4">ColorSpace.Model\#CMYK CMYK color model</td></tr>
///     <tr><td colspan="4">Unsupported</td></tr>
/// </table>
///
/// The components in this table are listed in encoding order (see below),
/// which is why color longs in the RGB model are called RGBA colors (even if
/// this doesn't quite hold for the special case of sRGB colors).
///
///
/// The color long encoding relies on half-precision float values (fp16). If you
/// wish to know more about the limitations of half-precision float values, please
/// refer to the documentation of the Half class.
///
///
/// <h4>Usage in code</h4>
/// To avoid confusing color longs with arbitrary long values, it is a
/// good practice to annotate them with the <code>@ColorLong</code> annotation
/// found in the Android Support Library.
///
///
/// <h4>Encoding</h4>
///
/// Given the complex nature of color longs, it is strongly encouraged to use
/// the various methods provided by this class to encode them.
///
///
/// The most flexible way to encode a color long is to use the method
/// \#pack(float, float, float, float, ColorSpace). This method allows you
/// to specify three color components (typically RGB), an alpha component and a
/// color space. To encode sRGB colors, use \#pack(float, float, float)
/// and \#pack(float, float, float, float) which are the
/// equivalent of \#rgb(int, int, int) and \#argb(int, int, int, int)
/// for color ints. If you simply need to convert a color int into a color long,
/// use \#pack(int).
///
///
/// It is also possible to create a color long value by invoking the method
/// \#pack() on a color instance.
///
///
/// <h4>Decoding</h4>
///
/// This class offers convenience methods to easily extract the components
/// of a color long:
///
/// <ul>
///     <li>\#alpha(long) to extract the alpha component</li>
///     <li>\#red(long) to extract the red/X/L component</li>
///     <li>\#green(long) to extract the green/Y/a component</li>
///     <li>\#blue(long) to extract the blue/Z/b component</li>
/// </ul>
///
/// The values returned by these methods depend on the color space encoded
/// in the color long. The values are however typically in the \([0..1]\) range
/// for RGB colors. Please refer to the documentation of the various
/// ColorSpace.Named color spaces for the exact ranges.
///
///
/// <h3>Color instances</h3>
/// Color instances are a representation introduced in
/// android.os.Build.VERSION_CODES\#O Android O to store colors in different
/// ColorSpace color spaces, with more precision than both color ints and
/// color longs. Color instances also offer the ability to store more than 4
/// components if necessary.
///
///
/// Colors instances are immutable and can be created using one of the various
/// <code>valueOf</code> methods. For instance:
///
/// <pre class="prettyprint">
/// // sRGB
/// Color opaqueRed = Color.valueOf(0xffff0000); // from a color int
/// Color translucentRed = Color.valueOf(1.0f, 0.0f, 0.0f, 0.5f);
///
/// // Wide gamut color
/// {@literal @}ColorLong long p3 = pack(1.0f, 1.0f, 0.0f, 1.0f, colorSpaceP3);
/// Color opaqueYellow = Color.valueOf(p3); // from a color long
///
/// // CIE L*a*b* color space
/// ColorSpace lab = ColorSpace.get(ColorSpace.Named.LAB);
/// Color green = Color.valueOf(100.0f, -128.0f, 128.0f, 1.0f, lab);
/// </pre>
///
/// Color instances can be converted to color ints (\#toArgb()) or
/// color longs (\#pack()). They also offer easy access to their various
/// components using the following methods:
///
/// <ul>
///     <li>\#alpha(), returns the alpha component value</li>
///     <li>\#red(), returns the red component value (or first
///     component value in non-RGB models)</li>
///     <li>\#green(), returns the green component value (or second
///     component value in non-RGB models)</li>
///     <li>\#blue(), returns the blue component value (or third
///     component value in non-RGB models)</li>
///     <li>\#getComponent(int), returns a specific component value</li>
///     <li>\#getComponents(), returns all component values as an array</li>
/// </ul>
///
/// <h3>Color space conversions</h3>
/// You can convert colors from one color space to another using
/// ColorSpace\#connect(ColorSpace, ColorSpace) and its variants. However,
/// the <code>Color</code> class provides a few convenience methods to simplify
/// the process. Here is a brief description of some of them:
///
/// <ul>
///     <li>\#convert(ColorSpace) to convert a color instance in a color
///     space to a new color instance in a different color space</li>
///     <li>\#convert(float, float, float, float, ColorSpace, ColorSpace) to
///     convert a color from a source color space to a destination color space</li>
///     <li>\#convert(long, ColorSpace) to convert a color long from its
///     built-in color space to a destination color space</li>
///     <li>\#convert(int, ColorSpace) to convert a color int from sRGB
///     to a destination color space</li>
/// </ul>
///
/// Please refere to the ColorSpace documentation for more
/// information.
///
///
/// <h3>Alpha and transparency</h3>
/// The alpha component of a color defines the level of transparency of a
/// color. When the alpha component is 0, the color is completely transparent.
/// When the alpha is component is 1 (in the \([0..1]\) range) or 255 (in the
/// \([0..255]\) range), the color is completely opaque.
///
///
/// The color representations described above do not use pre-multiplied
/// color components (a pre-multiplied color component is a color component
/// that has been multiplied by the value of the alpha component).
/// For instance, the color int representation of opaque red is
/// <code>0xffff0000</code>. For semi-transparent (50%) red, the
/// representation becomes <code>0x80ff0000</code>. The equivalent color
/// instance representations would be <code>(1.0, 0.0, 0.0, 1.0)</code>
/// and <code>(1.0, 0.0, 0.0, 0.5)</code>.
///
class Color extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Color");
  Color.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BLACK
  static const BLACK = -16777216;

  /// from: static public final int BLUE
  static const BLUE = -16776961;

  /// from: static public final int CYAN
  static const CYAN = -16711681;

  /// from: static public final int DKGRAY
  static const DKGRAY = -12303292;

  /// from: static public final int GRAY
  static const GRAY = -7829368;

  /// from: static public final int GREEN
  static const GREEN = -16711936;

  /// from: static public final int LTGRAY
  static const LTGRAY = -3355444;

  /// from: static public final int MAGENTA
  static const MAGENTA = -65281;

  /// from: static public final int RED
  static const RED = -65536;

  /// from: static public final int TRANSPARENT
  static const TRANSPARENT = 0;

  /// from: static public final int WHITE
  static const WHITE = -1;

  /// from: static public final int YELLOW
  static const YELLOW = -256;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new color instance set to opaque black in the
  /// ColorSpace.Named\#SRGB sRGB color space.
  ///@see \#valueOf(float, float, float)
  ///@see \#valueOf(float, float, float, float)
  ///@see \#valueOf(float, float, float, float, ColorSpace)
  ///@see \#valueOf(float[], ColorSpace)
  ///@see \#valueOf(int)
  ///@see \#valueOf(long)
  Color()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getColorSpace = jniAccessors.getMethodIDOf(
      _classRef, "getColorSpace", "()Landroid/graphics/ColorSpace;");

  /// from: public android.graphics.ColorSpace getColorSpace()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns this color's color space.
  ///@return A non-null instance of ColorSpace
  colorspace_.ColorSpace getColorSpace() =>
      colorspace_.ColorSpace.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorSpace, jni.JniType.objectType, []).object);

  static final _id_getModel = jniAccessors.getMethodIDOf(
      _classRef, "getModel", "()Landroid/graphics/ColorSpace\$Model;");

  /// from: public android.graphics.ColorSpace.Model getModel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the color model of this color.
  ///@return A non-null ColorSpace.Model
  colorspace_.ColorSpace_Model getModel() =>
      colorspace_.ColorSpace_Model.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getModel, jni.JniType.objectType, []).object);

  static final _id_isWideGamut =
      jniAccessors.getMethodIDOf(_classRef, "isWideGamut", "()Z");

  /// from: public boolean isWideGamut()
  ///
  /// Indicates whether this color color is in a wide-gamut color space.
  /// See ColorSpace\#isWideGamut() for a definition of a wide-gamut
  /// color space.
  ///@return True if this color is in a wide-gamut color space, false otherwise
  ///@see \#isSrgb()
  ///@see ColorSpace\#isWideGamut()
  bool isWideGamut() => jniAccessors.callMethodWithArgs(
      reference, _id_isWideGamut, jni.JniType.booleanType, []).boolean;

  static final _id_isSrgb =
      jniAccessors.getMethodIDOf(_classRef, "isSrgb", "()Z");

  /// from: public boolean isSrgb()
  ///
  /// Indicates whether this color is in the ColorSpace.Named\#SRGB sRGB
  /// color space.
  ///@return True if this color is in the sRGB color space, false otherwise
  ///@see \#isWideGamut()
  bool isSrgb() => jniAccessors.callMethodWithArgs(
      reference, _id_isSrgb, jni.JniType.booleanType, []).boolean;

  static final _id_getComponentCount =
      jniAccessors.getMethodIDOf(_classRef, "getComponentCount", "()I");

  /// from: public int getComponentCount()
  ///
  /// Returns the number of components that form a color value according
  /// to this color space's color model, plus one extra component for
  /// alpha.
  ///@return The integer 4 or 5
  ///
  /// Value is between 4 and 5 inclusive
  int getComponentCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getComponentCount, jni.JniType.intType, []).integer;

  static final _id_pack = jniAccessors.getMethodIDOf(_classRef, "pack", "()J");

  /// from: public long pack()
  ///
  /// Packs this color into a color long. See the documentation of this class
  /// for a description of the color long format.
  ///@return A color long
  ///@throws IllegalArgumentException If this color's color space has the id
  /// ColorSpace\#MIN_ID or if this color has more than 4 components
  int pack() => jniAccessors
      .callMethodWithArgs(reference, _id_pack, jni.JniType.longType, []).long;

  static final _id_convert = jniAccessors.getMethodIDOf(_classRef, "convert",
      "(Landroid/graphics/ColorSpace;)Landroid/graphics/Color;");

  /// from: public android.graphics.Color convert(android.graphics.ColorSpace colorSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts this color from its color space to the specified color space.
  /// The conversion is done using the default rendering intent as specified
  /// by ColorSpace\#connect(ColorSpace, ColorSpace).
  ///@param colorSpace The destination color space, cannot be null
  ///
  /// This value must never be {@code null}.
  ///@return A non-null color instance in the specified color space
  Color convert(colorspace_.ColorSpace colorSpace) =>
      Color.fromRef(jniAccessors.callMethodWithArgs(reference, _id_convert,
          jni.JniType.objectType, [colorSpace.reference]).object);

  static final _id_toArgb =
      jniAccessors.getMethodIDOf(_classRef, "toArgb", "()I");

  /// from: public int toArgb()
  ///
  /// Converts this color to an ARGB color int. A color int is always in
  /// the ColorSpace.Named\#SRGB sRGB color space. This implies
  /// a color space conversion is applied if needed.
  ///@return An ARGB color in the sRGB color space
  int toArgb() => jniAccessors.callMethodWithArgs(
      reference, _id_toArgb, jni.JniType.intType, []).integer;

  static final _id_red = jniAccessors.getMethodIDOf(_classRef, "red", "()F");

  /// from: public float red()
  ///
  /// Returns the value of the red component in the range defined by this
  /// color's color space (see ColorSpace\#getMinValue(int) and
  /// ColorSpace\#getMaxValue(int)).
  ///
  ///
  /// If this color's color model is not ColorSpace.Model\#RGB RGB,
  /// calling this method is equivalent to <code>getComponent(0)</code>.
  ///
  ///@see \#alpha()
  ///@see \#red()
  ///@see \#green
  ///@see \#getComponents()
  double red() => jniAccessors
      .callMethodWithArgs(reference, _id_red, jni.JniType.floatType, []).float;

  static final _id_green =
      jniAccessors.getMethodIDOf(_classRef, "green", "()F");

  /// from: public float green()
  ///
  /// Returns the value of the green component in the range defined by this
  /// color's color space (see ColorSpace\#getMinValue(int) and
  /// ColorSpace\#getMaxValue(int)).
  ///
  ///
  /// If this color's color model is not ColorSpace.Model\#RGB RGB,
  /// calling this method is equivalent to <code>getComponent(1)</code>.
  ///
  ///@see \#alpha()
  ///@see \#red()
  ///@see \#green
  ///@see \#getComponents()
  double green() => jniAccessors.callMethodWithArgs(
      reference, _id_green, jni.JniType.floatType, []).float;

  static final _id_blue = jniAccessors.getMethodIDOf(_classRef, "blue", "()F");

  /// from: public float blue()
  ///
  /// Returns the value of the blue component in the range defined by this
  /// color's color space (see ColorSpace\#getMinValue(int) and
  /// ColorSpace\#getMaxValue(int)).
  ///
  ///
  /// If this color's color model is not ColorSpace.Model\#RGB RGB,
  /// calling this method is equivalent to <code>getComponent(2)</code>.
  ///
  ///@see \#alpha()
  ///@see \#red()
  ///@see \#green
  ///@see \#getComponents()
  double blue() => jniAccessors
      .callMethodWithArgs(reference, _id_blue, jni.JniType.floatType, []).float;

  static final _id_alpha =
      jniAccessors.getMethodIDOf(_classRef, "alpha", "()F");

  /// from: public float alpha()
  ///
  /// Returns the value of the alpha component in the range \([0..1]\).
  /// Calling this method is equivalent to
  /// <code>getComponent(getComponentCount() - 1)</code>.
  ///@see \#red()
  ///@see \#green()
  ///@see \#blue()
  ///@see \#getComponents()
  ///@see \#getComponent(int)
  double alpha() => jniAccessors.callMethodWithArgs(
      reference, _id_alpha, jni.JniType.floatType, []).float;

  static final _id_getComponents =
      jniAccessors.getMethodIDOf(_classRef, "getComponents", "()[F");

  /// from: public float[] getComponents()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns this color's components as a new array. The last element of the
  /// array is always the alpha component.
  ///@return A new, non-null array whose size is equal to \#getComponentCount()
  ///@see \#getComponent(int)
  jni.JniObject getComponents() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getComponents, jni.JniType.objectType, []).object);

  static final _id_getComponents1 =
      jniAccessors.getMethodIDOf(_classRef, "getComponents", "([F)[F");

  /// from: public float[] getComponents(float[] components)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copies this color's components in the supplied array. The last element of the
  /// array is always the alpha component.
  ///@param components An array of floats whose size must be at least
  ///                  \#getComponentCount(), can be null
  /// This value may be {@code null}.
  ///@return The array passed as a parameter if not null, or a new array of length
  ///         \#getComponentCount()
  ///@see \#getComponent(int)
  ///@throws IllegalArgumentException If the specified array's length is less than
  /// \#getComponentCount()
  jni.JniObject getComponents1(jni.JniObject components) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getComponents1,
          jni.JniType.objectType,
          [components.reference]).object);

  static final _id_getComponent =
      jniAccessors.getMethodIDOf(_classRef, "getComponent", "(I)F");

  /// from: public float getComponent(int component)
  ///
  /// Returns the value of the specified component in the range defined by
  /// this color's color space (see ColorSpace\#getMinValue(int) and
  /// ColorSpace\#getMaxValue(int)).
  ///
  ///
  /// If the requested component index is \#getComponentCount(),
  /// this method returns the alpha component, always in the range
  /// \([0..1]\).
  ///
  ///@see \#getComponents()
  ///@throws ArrayIndexOutOfBoundsException If the specified component index
  /// is < 0 or >= \#getComponentCount()
  ///@param component Value is between 0 and 4 inclusive
  double getComponent(int component) => jniAccessors.callMethodWithArgs(
      reference, _id_getComponent, jni.JniType.floatType, [component]).float;

  static final _id_luminance =
      jniAccessors.getMethodIDOf(_classRef, "luminance", "()F");

  /// from: public float luminance()
  ///
  /// Returns the relative luminance of this color.
  ///
  ///
  /// Based on the formula for relative luminance defined in WCAG 2.0,
  /// W3C Recommendation 11 December 2008.
  ///
  ///@return A value between 0 (darkest black) and 1 (lightest white)
  ///@throws IllegalArgumentException If the this color's color space
  /// does not use the ColorSpace.Model\#RGB RGB color model
  double luminance() => jniAccessors.callMethodWithArgs(
      reference, _id_luminance, jni.JniType.floatType, []).float;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string representation of the object. This method returns
  /// a string equal to the value of:
  ///
  ///
  /// <pre class="prettyprint">
  /// "Color(" + r + ", " + g + ", " + b + ", " + a +
  ///         ", " + getColorSpace().getName + ')'
  /// </pre>
  ///
  /// For instance, the string representation of opaque black in the sRGB
  /// color space is equal to the following value:
  ///
  ///
  /// <pre>
  /// Color(0.0, 0.0, 0.0, 1.0, sRGB IEC61966-2.1)
  /// </pre>
  ///@return A non-null string representation of the object
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_colorSpace = jniAccessors.getStaticMethodIDOf(
      _classRef, "colorSpace", "(J)Landroid/graphics/ColorSpace;");

  /// from: static public android.graphics.ColorSpace colorSpace(long color)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the color space encoded in the specified color long.
  ///@param color The color long whose color space to extract
  ///@return A non-null color space instance
  ///@throws IllegalArgumentException If the encoded color space is invalid or unknown
  ///@see \#red(long)
  ///@see \#green(long)
  ///@see \#blue(long)
  ///@see \#alpha(long)
  static colorspace_.ColorSpace colorSpace(int color) =>
      colorspace_.ColorSpace.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_colorSpace, jni.JniType.objectType, [color]).object);

  static final _id_red1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "red", "(J)F");

  /// from: static public float red(long color)
  ///
  /// Returns the red component encoded in the specified color long.
  /// The range of the returned value depends on the color space
  /// associated with the specified color. The color space can be
  /// queried by calling \#colorSpace(long).
  ///@param color The color long whose red channel to extract
  ///@return A float value with a range defined by the specified color's
  /// color space
  ///@see \#colorSpace(long)
  ///@see \#green(long)
  ///@see \#blue(long)
  ///@see \#alpha(long)
  static double red1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_red1, jni.JniType.floatType, [color]).float;

  static final _id_green1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "green", "(J)F");

  /// from: static public float green(long color)
  ///
  /// Returns the green component encoded in the specified color long.
  /// The range of the returned value depends on the color space
  /// associated with the specified color. The color space can be
  /// queried by calling \#colorSpace(long).
  ///@param color The color long whose green channel to extract
  ///@return A float value with a range defined by the specified color's
  /// color space
  ///@see \#colorSpace(long)
  ///@see \#red(long)
  ///@see \#blue(long)
  ///@see \#alpha(long)
  static double green1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_green1, jni.JniType.floatType, [color]).float;

  static final _id_blue1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "blue", "(J)F");

  /// from: static public float blue(long color)
  ///
  /// Returns the blue component encoded in the specified color long.
  /// The range of the returned value depends on the color space
  /// associated with the specified color. The color space can be
  /// queried by calling \#colorSpace(long).
  ///@param color The color long whose blue channel to extract
  ///@return A float value with a range defined by the specified color's
  /// color space
  ///@see \#colorSpace(long)
  ///@see \#red(long)
  ///@see \#green(long)
  ///@see \#alpha(long)
  static double blue1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_blue1, jni.JniType.floatType, [color]).float;

  static final _id_alpha1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "alpha", "(J)F");

  /// from: static public float alpha(long color)
  ///
  /// Returns the alpha component encoded in the specified color long.
  /// The returned value is always in the range \([0..1]\).
  ///@param color The color long whose blue channel to extract
  ///@return A float value in the range \([0..1]\)
  ///@see \#colorSpace(long)
  ///@see \#red(long)
  ///@see \#green(long)
  ///@see \#blue(long)
  static double alpha1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_alpha1, jni.JniType.floatType, [color]).float;

  static final _id_isSrgb1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "isSrgb", "(J)Z");

  /// from: static public boolean isSrgb(long color)
  ///
  /// Indicates whether the specified color is in the
  /// ColorSpace.Named\#SRGB sRGB color space.
  ///@param color The color to test
  ///@return True if the color is in the sRGB color space, false otherwise
  ///@throws IllegalArgumentException If the encoded color space is invalid or unknown
  ///@see \#isInColorSpace(long, ColorSpace)
  ///@see \#isWideGamut(long)
  static bool isSrgb1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isSrgb1, jni.JniType.booleanType, [color]).boolean;

  static final _id_isWideGamut1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "isWideGamut", "(J)Z");

  /// from: static public boolean isWideGamut(long color)
  ///
  /// Indicates whether the specified color is in a wide-gamut color space.
  /// See ColorSpace\#isWideGamut() for a definition of a wide-gamut
  /// color space.
  ///@param color The color to test
  ///@return True if the color is in a wide-gamut color space, false otherwise
  ///@throws IllegalArgumentException If the encoded color space is invalid or unknown
  ///@see \#isInColorSpace(long, ColorSpace)
  ///@see \#isSrgb(long)
  ///@see ColorSpace\#isWideGamut()
  static bool isWideGamut1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isWideGamut1, jni.JniType.booleanType, [color]).boolean;

  static final _id_isInColorSpace = jniAccessors.getStaticMethodIDOf(
      _classRef, "isInColorSpace", "(JLandroid/graphics/ColorSpace;)Z");

  /// from: static public boolean isInColorSpace(long color, android.graphics.ColorSpace colorSpace)
  ///
  /// Indicates whether the specified color is in the specified color space.
  ///@param color The color to test
  ///@param colorSpace The color space to test against
  /// This value must never be {@code null}.
  ///@return True if the color is in the specified color space, false otherwise
  ///@see \#isSrgb(long)
  ///@see \#isWideGamut(long)
  static bool isInColorSpace(int color, colorspace_.ColorSpace colorSpace) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isInColorSpace,
          jni.JniType.booleanType, [color, colorSpace.reference]).boolean;

  static final _id_toArgb1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "toArgb", "(J)I");

  /// from: static public int toArgb(long color)
  ///
  /// Converts the specified color long to an ARGB color int. A color int is
  /// always in the ColorSpace.Named\#SRGB sRGB color space. This implies
  /// a color space conversion is applied if needed.
  ///@return An ARGB color in the sRGB color space
  ///@throws IllegalArgumentException If the encoded color space is invalid or unknown
  static int toArgb1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_toArgb1, jni.JniType.intType, [color]).integer;

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(I)Landroid/graphics/Color;");

  /// from: static public android.graphics.Color valueOf(int color)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new <code>Color</code> instance from an ARGB color int.
  /// The resulting color is in the ColorSpace.Named\#SRGB sRGB
  /// color space.
  ///@param color The ARGB color int to create a <code>Color</code> from
  ///@return A non-null instance of Color
  static Color valueOf(int color) =>
      Color.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_valueOf, jni.JniType.objectType, [color]).object);

  static final _id_valueOf1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(J)Landroid/graphics/Color;");

  /// from: static public android.graphics.Color valueOf(long color)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new <code>Color</code> instance from a color long.
  /// The resulting color is in the same color space as the specified color long.
  ///@param color The color long to create a <code>Color</code> from
  ///@return A non-null instance of Color
  ///@throws IllegalArgumentException If the encoded color space is invalid or unknown
  static Color valueOf1(int color) =>
      Color.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_valueOf1, jni.JniType.objectType, [color]).object);

  static final _id_valueOf2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(FFF)Landroid/graphics/Color;");

  /// from: static public android.graphics.Color valueOf(float r, float g, float b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new opaque <code>Color</code> in the ColorSpace.Named\#SRGB sRGB
  /// color space with the specified red, green and blue component values. The component
  /// values must be in the range \([0..1]\).
  ///@param r The red component of the opaque sRGB color to create, in \([0..1]\)
  ///@param g The green component of the opaque sRGB color to create, in \([0..1]\)
  ///@param b The blue component of the opaque sRGB color to create, in \([0..1]\)
  ///@return A non-null instance of Color
  static Color valueOf2(double r, double g, double b) =>
      Color.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_valueOf2, jni.JniType.objectType, [r, g, b]).object);

  static final _id_valueOf3 = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(FFFF)Landroid/graphics/Color;");

  /// from: static public android.graphics.Color valueOf(float r, float g, float b, float a)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new <code>Color</code> in the ColorSpace.Named\#SRGB sRGB
  /// color space with the specified red, green, blue and alpha component values.
  /// The component values must be in the range \([0..1]\).
  ///@param r The red component of the sRGB color to create, in \([0..1]\)
  ///@param g The green component of the sRGB color to create, in \([0..1]\)
  ///@param b The blue component of the sRGB color to create, in \([0..1]\)
  ///@param a The alpha component of the sRGB color to create, in \([0..1]\)
  ///@return A non-null instance of Color
  static Color valueOf3(double r, double g, double b, double a) =>
      Color.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf3, jni.JniType.objectType, [r, g, b, a]).object);

  static final _id_valueOf4 = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(FFFFLandroid/graphics/ColorSpace;)Landroid/graphics/Color;");

  /// from: static public android.graphics.Color valueOf(float r, float g, float b, float a, android.graphics.ColorSpace colorSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new <code>Color</code> in the specified color space with the
  /// specified red, green, blue and alpha component values. The range of the
  /// components is defined by ColorSpace\#getMinValue(int) and
  /// ColorSpace\#getMaxValue(int). The values passed to this method
  /// must be in the proper range.
  ///@param r The red component of the color to create
  ///@param g The green component of the color to create
  ///@param b The blue component of the color to create
  ///@param a The alpha component of the color to create, in \([0..1]\)
  ///@param colorSpace The color space of the color to create
  /// This value must never be {@code null}.
  ///@return A non-null instance of Color
  ///@throws IllegalArgumentException If the specified color space uses a
  /// color model with more than 3 components
  static Color valueOf4(double r, double g, double b, double a,
          colorspace_.ColorSpace colorSpace) =>
      Color.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf4,
          jni.JniType.objectType,
          [r, g, b, a, colorSpace.reference]).object);

  static final _id_valueOf5 = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "([FLandroid/graphics/ColorSpace;)Landroid/graphics/Color;");

  /// from: static public android.graphics.Color valueOf(float[] components, android.graphics.ColorSpace colorSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new <code>Color</code> in the specified color space with the
  /// specified component values. The range of the components is defined by
  /// ColorSpace\#getMinValue(int) and ColorSpace\#getMaxValue(int).
  /// The values passed to this method must be in the proper range. The alpha
  /// component is always in the range \([0..1]\).
  ///
  ///
  /// The length of the array of components must be at least
  /// <code>ColorSpace\#getComponentCount() + 1</code>. The component at index
  /// ColorSpace\#getComponentCount() is always alpha.
  ///
  ///@param components The components of the color to create, with alpha as the last component
  /// This value must never be {@code null}.
  ///@param colorSpace The color space of the color to create
  /// This value must never be {@code null}.
  ///@return A non-null instance of Color
  ///@throws IllegalArgumentException If the array of components is smaller than
  /// required by the color space
  static Color valueOf5(
          jni.JniObject components, colorspace_.ColorSpace colorSpace) =>
      Color.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf5,
          jni.JniType.objectType,
          [components.reference, colorSpace.reference]).object);

  static final _id_pack1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "pack", "(I)J");

  /// from: static public long pack(int color)
  ///
  /// Converts the specified ARGB color int to an RGBA color long in the sRGB
  /// color space. See the documentation of this class for a description of
  /// the color long format.
  ///@param color The ARGB color int to convert to an RGBA color long in sRGB
  ///@return A color long
  static int pack1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_pack1, jni.JniType.longType, [color]).long;

  static final _id_pack2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "pack", "(FFF)J");

  /// from: static public long pack(float red, float green, float blue)
  ///
  /// Packs the sRGB color defined by the specified red, green and blue component
  /// values into an RGBA color long in the sRGB color space. The alpha component
  /// is set to 1.0. See the documentation of this class for a description of the
  /// color long format.
  ///@param red The red component of the sRGB color to create, in \([0..1]\)
  ///@param green The green component of the sRGB color to create, in \([0..1]\)
  ///@param blue The blue component of the sRGB color to create, in \([0..1]\)
  ///@return A color long
  static int pack2(double red, double green, double blue) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_pack2, jni.JniType.longType, [red, green, blue]).long;

  static final _id_pack3 =
      jniAccessors.getStaticMethodIDOf(_classRef, "pack", "(FFFF)J");

  /// from: static public long pack(float red, float green, float blue, float alpha)
  ///
  /// Packs the sRGB color defined by the specified red, green, blue and alpha
  /// component values into an RGBA color long in the sRGB color space. See the
  /// documentation of this class for a description of the color long format.
  ///@param red The red component of the sRGB color to create, in \([0..1]\)
  ///@param green The green component of the sRGB color to create, in \([0..1]\)
  ///@param blue The blue component of the sRGB color to create, in \([0..1]\)
  ///@param alpha The alpha component of the sRGB color to create, in \([0..1]\)
  ///@return A color long
  static int pack3(double red, double green, double blue, double alpha) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_pack3,
          jni.JniType.longType, [red, green, blue, alpha]).long;

  static final _id_pack4 = jniAccessors.getStaticMethodIDOf(
      _classRef, "pack", "(FFFFLandroid/graphics/ColorSpace;)J");

  /// from: static public long pack(float red, float green, float blue, float alpha, android.graphics.ColorSpace colorSpace)
  ///
  /// Packs the 3 component color defined by the specified red, green, blue and
  /// alpha component values into a color long in the specified color space. See the
  /// documentation of this class for a description of the color long format.
  ///
  ///
  /// The red, green and blue components must be in the range defined by the
  /// specified color space. See ColorSpace\#getMinValue(int) and
  /// ColorSpace\#getMaxValue(int).
  ///
  ///@param red The red component of the color to create
  ///@param green The green component of the color to create
  ///@param blue The blue component of the color to create
  ///@param alpha The alpha component of the color to create, in \([0..1]\)
  ///@param colorSpace This value must never be {@code null}.
  ///@return A color long
  ///@throws IllegalArgumentException If the color space's id is ColorSpace\#MIN_ID
  /// or if the color space's color model has more than 3 components
  static int pack4(double red, double green, double blue, double alpha,
          colorspace_.ColorSpace colorSpace) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_pack4,
          jni.JniType.longType,
          [red, green, blue, alpha, colorSpace.reference]).long;

  static final _id_convert1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "convert", "(ILandroid/graphics/ColorSpace;)J");

  /// from: static public long convert(int color, android.graphics.ColorSpace colorSpace)
  ///
  /// Converts the specified ARGB color int from the ColorSpace.Named\#SRGB sRGB
  /// color space into the specified destination color space. The resulting color is
  /// returned as a color long. See the documentation of this class for a description
  /// of the color long format.
  ///@param color The sRGB color int to convert
  ///@param colorSpace The destination color space
  /// This value must never be {@code null}.
  ///@return A color long in the destination color space
  static int convert1(int color, colorspace_.ColorSpace colorSpace) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_convert1,
          jni.JniType.longType, [color, colorSpace.reference]).long;

  static final _id_convert2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "convert", "(JLandroid/graphics/ColorSpace;)J");

  /// from: static public long convert(long color, android.graphics.ColorSpace colorSpace)
  ///
  /// Converts the specified color long from its color space into the specified
  /// destination color space. The resulting color is returned as a color long. See
  /// the documentation of this class for a description of the color long format.
  ///
  ///
  /// When converting several colors in a row, it is recommended to use
  /// \#convert(long, ColorSpace.Connector) instead to
  /// avoid the creation of a ColorSpace.Connector on every invocation.
  ///
  ///@param color The color long to convert
  ///@param colorSpace The destination color space
  /// This value must never be {@code null}.
  ///@return A color long in the destination color space
  ///@throws IllegalArgumentException If the encoded color space is invalid or unknown
  static int convert2(int color, colorspace_.ColorSpace colorSpace) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_convert2,
          jni.JniType.longType, [color, colorSpace.reference]).long;

  static final _id_convert3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "convert",
      "(FFFFLandroid/graphics/ColorSpace;Landroid/graphics/ColorSpace;)J");

  /// from: static public long convert(float r, float g, float b, float a, android.graphics.ColorSpace source, android.graphics.ColorSpace destination)
  ///
  /// Converts the specified 3 component color from the source color space to the
  /// destination color space. The resulting color is returned as a color long. See
  /// the documentation of this class for a description of the color long format.
  ///
  ///
  /// When converting multiple colors in a row, it is recommended to use
  /// \#convert(float, float, float, float, ColorSpace.Connector) instead to
  /// avoid the creation of a ColorSpace.Connector on every invocation.
  ///
  ///
  /// The red, green and blue components must be in the range defined by the
  /// specified color space. See ColorSpace\#getMinValue(int) and
  /// ColorSpace\#getMaxValue(int).
  ///
  ///@param r The red component of the color to convert
  ///@param g The green component of the color to convert
  ///@param b The blue component of the color to convert
  ///@param a The alpha component of the color to convert, in \([0..1]\)
  ///@param source The source color space, cannot be null
  /// This value must never be {@code null}.
  ///@param destination The destination color space, cannot be null
  /// This value must never be {@code null}.
  ///@return A color long in the destination color space
  ///@see \#convert(float, float, float, float, ColorSpace.Connector)
  static int convert3(double r, double g, double b, double a,
          colorspace_.ColorSpace source, colorspace_.ColorSpace destination) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_convert3,
          jni.JniType.longType,
          [r, g, b, a, source.reference, destination.reference]).long;

  static final _id_convert4 = jniAccessors.getStaticMethodIDOf(
      _classRef, "convert", "(JLandroid/graphics/ColorSpace\$Connector;)J");

  /// from: static public long convert(long color, android.graphics.ColorSpace.Connector connector)
  ///
  /// Converts the specified color long from a color space to another using the
  /// specified color space ColorSpace.Connector connector. The resulting
  /// color is returned as a color long. See the documentation of this class for a
  /// description of the color long format.
  ///
  ///
  /// When converting several colors in a row, this method is preferable to
  /// \#convert(long, ColorSpace) as it prevents a new connector from being
  /// created on every invocation.
  ///
  ///
  /// <p class="note">The connector's source color space should match the color long's
  /// color space.
  ///
  ///@param color The color long to convert
  ///@param connector A color space connector, cannot be null
  /// This value must never be {@code null}.
  ///@return A color long in the destination color space of the connector
  static int convert4(int color, colorspace_.ColorSpace_Connector connector) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_convert4,
          jni.JniType.longType, [color, connector.reference]).long;

  static final _id_convert5 = jniAccessors.getStaticMethodIDOf(
      _classRef, "convert", "(FFFFLandroid/graphics/ColorSpace\$Connector;)J");

  /// from: static public long convert(float r, float g, float b, float a, android.graphics.ColorSpace.Connector connector)
  ///
  /// Converts the specified 3 component color from a color space to another using
  /// the specified color space ColorSpace.Connector connector. The resulting
  /// color is returned as a color long. See the documentation of this class for a
  /// description of the color long format.
  ///
  ///
  /// When converting several colors in a row, this method is preferable to
  /// \#convert(float, float, float, float, ColorSpace, ColorSpace) as
  /// it prevents a new connector from being created on every invocation.
  ///
  ///
  /// The red, green and blue components must be in the range defined by the
  /// source color space of the connector. See ColorSpace\#getMinValue(int)
  /// and ColorSpace\#getMaxValue(int).
  ///
  ///@param r The red component of the color to convert
  ///@param g The green component of the color to convert
  ///@param b The blue component of the color to convert
  ///@param a The alpha component of the color to convert, in \([0..1]\)
  ///@param connector A color space connector, cannot be null
  /// This value must never be {@code null}.
  ///@return A color long in the destination color space of the connector
  ///@see \#convert(float, float, float, float, ColorSpace, ColorSpace)
  static int convert5(double r, double g, double b, double a,
          colorspace_.ColorSpace_Connector connector) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_convert5,
          jni.JniType.longType, [r, g, b, a, connector.reference]).long;

  static final _id_luminance1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "luminance", "(J)F");

  /// from: static public float luminance(long color)
  ///
  /// Returns the relative luminance of a color.
  ///
  ///
  /// Based on the formula for relative luminance defined in WCAG 2.0,
  /// W3C Recommendation 11 December 2008.
  ///
  ///@return A value between 0 (darkest black) and 1 (lightest white)
  ///@throws IllegalArgumentException If the specified color's color space
  /// is unknown or does not use the ColorSpace.Model\#RGB RGB color model
  static double luminance1(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_luminance1, jni.JniType.floatType, [color]).float;

  static final _id_alpha2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "alpha", "(I)I");

  /// from: static public int alpha(int color)
  ///
  /// Return the alpha component of a color int. This is the same as saying
  /// color >>> 24
  ///@return Value is between 0 and 255 inclusive
  static int alpha2(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_alpha2, jni.JniType.intType, [color]).integer;

  static final _id_red2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "red", "(I)I");

  /// from: static public int red(int color)
  ///
  /// Return the red component of a color int. This is the same as saying
  /// (color >> 16) & 0xFF
  ///@return Value is between 0 and 255 inclusive
  static int red2(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_red2, jni.JniType.intType, [color]).integer;

  static final _id_green2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "green", "(I)I");

  /// from: static public int green(int color)
  ///
  /// Return the green component of a color int. This is the same as saying
  /// (color >> 8) & 0xFF
  ///@return Value is between 0 and 255 inclusive
  static int green2(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_green2, jni.JniType.intType, [color]).integer;

  static final _id_blue2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "blue", "(I)I");

  /// from: static public int blue(int color)
  ///
  /// Return the blue component of a color int. This is the same as saying
  /// color & 0xFF
  ///@return Value is between 0 and 255 inclusive
  static int blue2(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_blue2, jni.JniType.intType, [color]).integer;

  static final _id_rgb =
      jniAccessors.getStaticMethodIDOf(_classRef, "rgb", "(III)I");

  /// from: static public int rgb(int red, int green, int blue)
  ///
  /// Return a color-int from red, green, blue components.
  /// The alpha component is implicitly 255 (fully opaque).
  /// These component values should be \([0..255]\), but there is no
  /// range check performed, so if they are out of range, the
  /// returned color is undefined.
  ///@param red Red component \([0..255]\) of the color
  /// Value is between 0 and 255 inclusive
  ///@param green Green component \([0..255]\) of the color
  /// Value is between 0 and 255 inclusive
  ///@param blue Blue component \([0..255]\) of the color
  ///
  /// Value is between 0 and 255 inclusive
  static int rgb(int red, int green, int blue) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_rgb, jni.JniType.intType, [red, green, blue]).integer;

  static final _id_rgb1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "rgb", "(FFF)I");

  /// from: static public int rgb(float red, float green, float blue)
  ///
  /// Return a color-int from red, green, blue float components
  /// in the range \([0..1]\). The alpha component is implicitly
  /// 1.0 (fully opaque). If the components are out of range, the
  /// returned color is undefined.
  ///@param red Red component \([0..1]\) of the color
  ///@param green Green component \([0..1]\) of the color
  ///@param blue Blue component \([0..1]\) of the color
  static int rgb1(double red, double green, double blue) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_rgb1, jni.JniType.intType, [red, green, blue]).integer;

  static final _id_argb =
      jniAccessors.getStaticMethodIDOf(_classRef, "argb", "(IIII)I");

  /// from: static public int argb(int alpha, int red, int green, int blue)
  ///
  /// Return a color-int from alpha, red, green, blue components.
  /// These component values should be \([0..255]\), but there is no
  /// range check performed, so if they are out of range, the
  /// returned color is undefined.
  ///@param alpha Alpha component \([0..255]\) of the color
  /// Value is between 0 and 255 inclusive
  ///@param red Red component \([0..255]\) of the color
  /// Value is between 0 and 255 inclusive
  ///@param green Green component \([0..255]\) of the color
  /// Value is between 0 and 255 inclusive
  ///@param blue Blue component \([0..255]\) of the color
  ///
  /// Value is between 0 and 255 inclusive
  static int argb(int alpha, int red, int green, int blue) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_argb,
          jni.JniType.intType, [alpha, red, green, blue]).integer;

  static final _id_argb1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "argb", "(FFFF)I");

  /// from: static public int argb(float alpha, float red, float green, float blue)
  ///
  /// Return a color-int from alpha, red, green, blue float components
  /// in the range \([0..1]\). If the components are out of range, the
  /// returned color is undefined.
  ///@param alpha Alpha component \([0..1]\) of the color
  ///@param red Red component \([0..1]\) of the color
  ///@param green Green component \([0..1]\) of the color
  ///@param blue Blue component \([0..1]\) of the color
  static int argb1(double alpha, double red, double green, double blue) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_argb1,
          jni.JniType.intType, [alpha, red, green, blue]).integer;

  static final _id_luminance2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "luminance", "(I)F");

  /// from: static public float luminance(int color)
  ///
  /// Returns the relative luminance of a color.
  ///
  /// Assumes sRGB encoding. Based on the formula for relative luminance
  /// defined in WCAG 2.0, W3C Recommendation 11 December 2008.
  ///@return a value between 0 (darkest black) and 1 (lightest white)
  static double luminance2(int color) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_luminance2, jni.JniType.floatType, [color]).float;

  static final _id_parseColor = jniAccessors.getStaticMethodIDOf(
      _classRef, "parseColor", "(Ljava/lang/String;)I");

  /// from: static public int parseColor(java.lang.String colorString)
  ///
  ///
  ///Parse the color string, and return the corresponding color-int.
  /// If the string cannot be parsed, throws an IllegalArgumentException
  /// exception. Supported formats are:
  ///
  ///
  /// <ul>
  ///   <li><code>\#RRGGBB</code></li>
  ///   <li><code>\#AARRGGBB</code></li>
  /// </ul>
  ///
  /// The following names are also accepted: <code>red</code>, <code>blue</code>,
  /// <code>green</code>, <code>black</code>, <code>white</code>, <code>gray</code>,
  /// <code>cyan</code>, <code>magenta</code>, <code>yellow</code>, <code>lightgray</code>,
  /// <code>darkgray</code>, <code>grey</code>, <code>lightgrey</code>, <code>darkgrey</code>,
  /// <code>aqua</code>, <code>fuchsia</code>, <code>lime</code>, <code>maroon</code>,
  /// <code>navy</code>, <code>olive</code>, <code>purple</code>, <code>silver</code>,
  /// and <code>teal</code>.
  ///
  static int parseColor(jni.JniString colorString) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_parseColor,
          jni.JniType.intType, [colorString.reference]).integer;

  static final _id_RGBToHSV =
      jniAccessors.getStaticMethodIDOf(_classRef, "RGBToHSV", "(III[F)V");

  /// from: static public void RGBToHSV(int red, int green, int blue, float[] hsv)
  ///
  /// Convert RGB components to HSV.
  /// <ul>
  ///   <li><code>hsv[0]</code> is Hue \([0..360[\)</li>
  ///   <li><code>hsv[1]</code> is Saturation \([0...1]\)</li>
  ///   <li><code>hsv[2]</code> is Value \([0...1]\)</li>
  /// </ul>
  ///@param red red component value \([0..255]\)
  /// Value is between 0 and 255 inclusive
  ///@param green green component value \([0..255]\)
  /// Value is between 0 and 255 inclusive
  ///@param blue blue component value \([0..255]\)
  /// Value is between 0 and 255 inclusive
  ///@param hsv 3 element array which holds the resulting HSV components.
  static void RGBToHSV(int red, int green, int blue, jni.JniObject hsv) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_RGBToHSV,
          jni.JniType.voidType, [red, green, blue, hsv.reference]).check();

  static final _id_colorToHSV =
      jniAccessors.getStaticMethodIDOf(_classRef, "colorToHSV", "(I[F)V");

  /// from: static public void colorToHSV(int color, float[] hsv)
  ///
  /// Convert the ARGB color to its HSV components.
  /// <ul>
  ///   <li><code>hsv[0]</code> is Hue \([0..360[\)</li>
  ///   <li><code>hsv[1]</code> is Saturation \([0...1]\)</li>
  ///   <li><code>hsv[2]</code> is Value \([0...1]\)</li>
  /// </ul>
  ///@param color the argb color to convert. The alpha component is ignored.
  ///@param hsv 3 element array which holds the resulting HSV components.
  static void colorToHSV(int color, jni.JniObject hsv) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_colorToHSV,
          jni.JniType.voidType, [color, hsv.reference]).check();

  static final _id_HSVToColor =
      jniAccessors.getStaticMethodIDOf(_classRef, "HSVToColor", "([F)I");

  /// from: static public int HSVToColor(float[] hsv)
  ///
  /// Convert HSV components to an ARGB color. Alpha set to 0xFF.
  /// <ul>
  ///   <li><code>hsv[0]</code> is Hue \([0..360[\)</li>
  ///   <li><code>hsv[1]</code> is Saturation \([0...1]\)</li>
  ///   <li><code>hsv[2]</code> is Value \([0...1]\)</li>
  /// </ul>
  /// If hsv values are out of range, they are pinned.
  ///@param hsv 3 element array which holds the input HSV components.
  ///@return the resulting argb color
  static int HSVToColor(jni.JniObject hsv) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_HSVToColor,
          jni.JniType.intType, [hsv.reference]).integer;

  static final _id_HSVToColor1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "HSVToColor", "(I[F)I");

  /// from: static public int HSVToColor(int alpha, float[] hsv)
  ///
  /// Convert HSV components to an ARGB color. The alpha component is passed
  /// through unchanged.
  /// <ul>
  ///   <li><code>hsv[0]</code> is Hue \([0..360[\)</li>
  ///   <li><code>hsv[1]</code> is Saturation \([0...1]\)</li>
  ///   <li><code>hsv[2]</code> is Value \([0...1]\)</li>
  /// </ul>
  /// If hsv values are out of range, they are pinned.
  ///@param alpha the alpha component of the returned argb color.
  /// Value is between 0 and 255 inclusive
  ///@param hsv 3 element array which holds the input HSV components.
  ///@return the resulting argb color
  static int HSVToColor1(int alpha, jni.JniObject hsv) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_HSVToColor1,
          jni.JniType.intType, [alpha, hsv.reference]).integer;
}
