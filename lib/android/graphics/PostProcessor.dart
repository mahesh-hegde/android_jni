// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Canvas.dart" as canvas_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.PostProcessor
///
/// Helper interface for adding custom processing to an image.
///
///  The image being processed may be a Drawable, a Bitmap, or
///  a frame of an AnimatedImageDrawable produced by ImageDecoder.
///  This is called before the requested object is returned.
///
///
///  This custom processing can even be applied to images that will be returned
///  as immutable objects, such as a Bitmap with {@code Config}
///  Bitmap.Config\#HARDWARE returned by ImageDecoder.
///
///
///  On an AnimatedImageDrawable, the callback will only be called once,
///  but the drawing commands will be applied to each frame, as if the Canvas
///  had been returned by Picture\#beginRecording Picture.beginRecording.
///
///  Supplied to ImageDecoder via ImageDecoder\#setPostProcessor setPostProcessor.
///
class PostProcessor extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/PostProcessor");
  PostProcessor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onPostProcess = jniAccessors.getMethodIDOf(
      _classRef, "onPostProcess", "(Landroid/graphics/Canvas;)I");

  /// from: public abstract int onPostProcess(android.graphics.Canvas canvas)
  ///
  /// Do any processing after (for example) decoding.
  ///
  ///  Drawing to the Canvas will behave as if the initial processing
  ///  (e.g. decoding) already exists in the Canvas. An implementation can draw
  ///  effects on top of this, or it can even draw behind it using
  ///  PorterDuff.Mode\#DST_OVER PorterDuff.Mode.DST_OVER. A common
  ///  effect is to add transparency to the corners to achieve rounded corners.
  ///  That can be done with the following code:
  ///
  ///
  ///  <pre class="prettyprint">
  ///  Path path = new Path();
  ///  path.setFillType(Path.FillType.INVERSE_EVEN_ODD);
  ///  int width = canvas.getWidth();
  ///  int height = canvas.getHeight();
  ///  path.addRoundRect(0, 0, width, height, 20, 20, Path.Direction.CW);
  ///  Paint paint = new Paint();
  ///  paint.setAntiAlias(true);
  ///  paint.setColor(Color.TRANSPARENT);
  ///  paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
  ///  canvas.drawPath(path, paint);
  ///  return PixelFormat.TRANSLUCENT;
  ///  </pre>
  ///@param canvas The Canvas to draw to.
  ///
  /// This value must never be {@code null}.
  ///@return Opacity of the result after drawing.
  ///      PixelFormat\#UNKNOWN PixelFormat.UNKNOWN means that the
  ///      implementation did not change whether the image has alpha. Return
  ///      this unless you added transparency (e.g. with the code above, in
  ///      which case you should return
  ///      PixelFormat\#TRANSLUCENT PixelFormat.TRANSLUCENT) or you
  ///      forced the image to be opaque (e.g. by drawing everywhere with an
  ///      opaque color and PorterDuff.Mode\#DST_OVER PorterDuff.Mode.DST_OVER,
  ///      in which case you should return PixelFormat\#OPAQUE PixelFormat.OPAQUE).
  ///      PixelFormat\#TRANSLUCENT PixelFormat.TRANSLUCENT means that
  ///      the implementation added transparency. This is safe to return even
  ///      if the image already had transparency. This is also safe to return
  ///      if the result is opaque, though it may draw more slowly.
  ///      PixelFormat\#OPAQUE PixelFormat.OPAQUE means that the
  ///      implementation forced the image to be opaque. This is safe to return
  ///      even if the image was already opaque.
  ///      PixelFormat\#TRANSPARENT PixelFormat.TRANSPARENT (or any other
  ///      integer) is not allowed, and will result in throwing an
  ///      java.lang.IllegalArgumentException.
  ///
  /// Value is android.graphics.PixelFormat\#UNKNOWN, android.graphics.PixelFormat\#TRANSLUCENT, android.graphics.PixelFormat\#TRANSPARENT, or android.graphics.PixelFormat\#OPAQUE
  int onPostProcess(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onPostProcess,
      jni.JniType.intType,
      [canvas.reference]).integer;
}
