// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Bitmap.dart" as bitmap_;

import "RectF.dart" as rectf_;

import "Paint.dart" as paint_;

import "Matrix.dart" as matrix_;

import "Region.dart" as region_;

import "Rect.dart" as rect_;

import "Path.dart" as path_;

import "DrawFilter.dart" as drawfilter_;

import "Picture.dart" as picture_;

import "PorterDuff.dart" as porterduff_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Canvas
///
/// The Canvas class holds the "draw" calls. To draw something, you need
/// 4 basic components: A Bitmap to hold the pixels, a Canvas to host
/// the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect,
/// Path, text, Bitmap), and a paint (to describe the colors and styles for the
/// drawing).
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about how to use Canvas, read the
/// <a href="{@docRoot}guide/topics/graphics/2d-graphics.html">
/// Canvas and Drawables</a> developer guide.
///</div>
class Canvas extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Canvas");
  Canvas.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ALL_SAVE_FLAG
  ///
  /// Restore everything when restore() is called (standard save flags).
  /// <p class="note"><strong>Note:</strong> for performance reasons, it is
  /// strongly recommended to pass this - the complete set of flags - to any
  /// call to <code>saveLayer()</code> and <code>saveLayerAlpha()</code>
  /// variants.
  ///
  /// <p class="note"><strong>Note:</strong> all methods that accept this flag
  /// have flagless versions that are equivalent to passing this flag.
  static const ALL_SAVE_FLAG = 31;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct an empty raster canvas. Use setBitmap() to specify a bitmap to
  /// draw into.  The initial target density is Bitmap\#DENSITY_NONE;
  /// this will typically be replaced when a target bitmap is set for the
  /// canvas.
  Canvas()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Bitmap;)V");

  /// from: public void <init>(android.graphics.Bitmap bitmap)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a canvas with the specified bitmap to draw into. The bitmap
  /// must be mutable.
  ///
  /// The initial target density of the canvas is the same as the given
  /// bitmap's density.
  ///@param bitmap Specifies a mutable bitmap for the canvas to draw into.
  ///
  /// This value must never be {@code null}.
  Canvas.ctor1(bitmap_.Bitmap bitmap)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [bitmap.reference]).object);

  static final _id_isHardwareAccelerated =
      jniAccessors.getMethodIDOf(_classRef, "isHardwareAccelerated", "()Z");

  /// from: public boolean isHardwareAccelerated()
  ///
  /// Indicates whether this Canvas uses hardware acceleration.
  ///
  /// Note that this method does not define what type of hardware acceleration
  /// may or may not be used.
  ///@return True if drawing operations are hardware accelerated,
  ///         false otherwise.
  bool isHardwareAccelerated() => jniAccessors.callMethodWithArgs(reference,
      _id_isHardwareAccelerated, jni.JniType.booleanType, []).boolean;

  static final _id_setBitmap = jniAccessors.getMethodIDOf(
      _classRef, "setBitmap", "(Landroid/graphics/Bitmap;)V");

  /// from: public void setBitmap(android.graphics.Bitmap bitmap)
  ///
  /// Specify a bitmap for the canvas to draw into. All canvas state such as
  /// layers, filters, and the save/restore stack are reset. Additionally,
  /// the canvas' target density is updated to match that of the bitmap.
  ///
  /// Prior to API level {@value Build.VERSION_CODES\#O} the current matrix and
  /// clip stack were preserved.
  ///@param bitmap Specifies a mutable bitmap for the canvas to draw into.
  /// This value may be {@code null}.
  ///@see \#setDensity(int)
  ///@see \#getDensity()
  void setBitmap(bitmap_.Bitmap bitmap) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBitmap,
      jni.JniType.voidType,
      [bitmap.reference]).check();

  static final _id_isOpaque =
      jniAccessors.getMethodIDOf(_classRef, "isOpaque", "()Z");

  /// from: public boolean isOpaque()
  ///
  /// Return true if the device that the current layer draws into is opaque
  /// (i.e. does not support per-pixel alpha).
  ///@return true if the device that the current layer draws into is opaque
  bool isOpaque() => jniAccessors.callMethodWithArgs(
      reference, _id_isOpaque, jni.JniType.booleanType, []).boolean;

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Returns the width of the current drawing layer
  ///@return the width of the current drawing layer
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Returns the height of the current drawing layer
  ///@return the height of the current drawing layer
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getDensity =
      jniAccessors.getMethodIDOf(_classRef, "getDensity", "()I");

  /// from: public int getDensity()
  ///
  /// Returns the target density of the canvas.  The default density is
  /// derived from the density of its backing bitmap, or
  /// Bitmap\#DENSITY_NONE if there is not one.
  ///
  ///@return Returns the current target density of the canvas, which is used
  /// to determine the scaling factor when drawing a bitmap into it.
  ///@see \#setDensity(int)
  ///@see Bitmap\#getDensity()
  int getDensity() => jniAccessors.callMethodWithArgs(
      reference, _id_getDensity, jni.JniType.intType, []).integer;

  static final _id_setDensity =
      jniAccessors.getMethodIDOf(_classRef, "setDensity", "(I)V");

  /// from: public void setDensity(int density)
  ///
  /// Specifies the density for this Canvas' backing bitmap.  This modifies
  /// the target density of the canvas itself, as well as the density of its
  /// backing bitmap via Bitmap\#setDensity(int) Bitmap.setDensity(int).
  ///@param density The new target density of the canvas, which is used
  /// to determine the scaling factor when drawing a bitmap into it.  Use
  /// Bitmap\#DENSITY_NONE to disable bitmap scaling.
  ///@see \#getDensity()
  ///@see Bitmap\#setDensity(int)
  void setDensity(int density) => jniAccessors.callMethodWithArgs(
      reference, _id_setDensity, jni.JniType.voidType, [density]).check();

  static final _id_getMaximumBitmapWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMaximumBitmapWidth", "()I");

  /// from: public int getMaximumBitmapWidth()
  ///
  /// Returns the maximum allowed width for bitmaps drawn with this canvas.
  /// Attempting to draw with a bitmap wider than this value will result
  /// in an error.
  ///@see \#getMaximumBitmapHeight()
  int getMaximumBitmapWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaximumBitmapWidth, jni.JniType.intType, []).integer;

  static final _id_getMaximumBitmapHeight =
      jniAccessors.getMethodIDOf(_classRef, "getMaximumBitmapHeight", "()I");

  /// from: public int getMaximumBitmapHeight()
  ///
  /// Returns the maximum allowed height for bitmaps drawn with this canvas.
  /// Attempting to draw with a bitmap taller than this value will result
  /// in an error.
  ///@see \#getMaximumBitmapWidth()
  int getMaximumBitmapHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaximumBitmapHeight, jni.JniType.intType, []).integer;

  static final _id_save = jniAccessors.getMethodIDOf(_classRef, "save", "()I");

  /// from: public int save()
  ///
  /// Saves the current matrix and clip onto a private stack.
  ///
  /// Subsequent calls to translate,scale,rotate,skew,concat or clipRect,
  /// clipPath will all operate as usual, but when the balancing call to
  /// restore() is made, those calls will be forgotten, and the settings that
  /// existed before the save() will be reinstated.
  ///@return The value to pass to restoreToCount() to balance this save()
  int save() => jniAccessors
      .callMethodWithArgs(reference, _id_save, jni.JniType.intType, []).integer;

  static final _id_saveLayer = jniAccessors.getMethodIDOf(_classRef,
      "saveLayer", "(Landroid/graphics/RectF;Landroid/graphics/Paint;I)I");

  /// from: public int saveLayer(android.graphics.RectF bounds, android.graphics.Paint paint, int saveFlags)
  ///
  /// This behaves the same as save(), but in addition it allocates and
  /// redirects drawing to an offscreen bitmap.
  /// <p class="note"><strong>Note:</strong> this method is very expensive,
  /// incurring more than double rendering cost for contained content. Avoid
  /// using this method, especially if the bounds provided are large. It is
  /// recommended to use a android.view.View\#LAYER_TYPE_HARDWARE hardware layer on a View
  /// to apply an xfermode, color filter, or alpha, as it will perform much
  /// better than this method.
  ///
  /// All drawing calls are directed to a newly allocated offscreen bitmap.
  /// Only when the balancing call to restore() is made, is that offscreen
  /// buffer drawn back to the current target of the Canvas (either the
  /// screen, it's target Bitmap, or the previous layer).
  ///
  /// Attributes of the Paint - Paint\#getAlpha() alpha,
  /// Paint\#getXfermode() Xfermode, and
  /// Paint\#getColorFilter() ColorFilter are applied when the
  /// offscreen bitmap is drawn back when restore() is called.
  ///
  /// As of API Level API level {@value Build.VERSION_CODES\#P} the only valid
  /// {@code saveFlags} is \#ALL_SAVE_FLAG.  All other flags are ignored.
  ///@deprecated Use \#saveLayer(RectF, Paint) instead.
  ///@param bounds May be null. The maximum size the offscreen bitmap
  ///               needs to be (in local coordinates)
  /// This value may be {@code null}.
  ///@param paint This is copied, and is applied to the offscreen when
  ///               restore() is called.
  /// This value may be {@code null}.
  ///@param saveFlags see _SAVE_FLAG constants, generally \#ALL_SAVE_FLAG is recommended
  ///               for performance reasons.
  /// Value is either <code>0</code> or android.graphics.Canvas\#ALL_SAVE_FLAG
  ///@return value to pass to restoreToCount() to balance this save()
  int saveLayer(rectf_.RectF bounds, paint_.Paint paint, int saveFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_saveLayer,
          jni.JniType.intType,
          [bounds.reference, paint.reference, saveFlags]).integer;

  static final _id_saveLayer1 = jniAccessors.getMethodIDOf(_classRef,
      "saveLayer", "(Landroid/graphics/RectF;Landroid/graphics/Paint;)I");

  /// from: public int saveLayer(android.graphics.RectF bounds, android.graphics.Paint paint)
  ///
  /// This behaves the same as save(), but in addition it allocates and
  /// redirects drawing to an offscreen rendering target.
  /// <p class="note"><strong>Note:</strong> this method is very expensive,
  /// incurring more than double rendering cost for contained content. Avoid
  /// using this method when possible and instead use a
  /// android.view.View\#LAYER_TYPE_HARDWARE hardware layer on a View
  /// to apply an xfermode, color filter, or alpha, as it will perform much
  /// better than this method.
  ///
  /// All drawing calls are directed to a newly allocated offscreen rendering target.
  /// Only when the balancing call to restore() is made, is that offscreen
  /// buffer drawn back to the current target of the Canvas (which can potentially be a previous
  /// layer if these calls are nested).
  ///
  /// Attributes of the Paint - Paint\#getAlpha() alpha,
  /// Paint\#getXfermode() Xfermode, and
  /// Paint\#getColorFilter() ColorFilter are applied when the
  /// offscreen rendering target is drawn back when restore() is called.
  ///@param bounds May be null. The maximum size the offscreen render target
  ///               needs to be (in local coordinates)
  /// This value may be {@code null}.
  ///@param paint This is copied, and is applied to the offscreen when
  ///               restore() is called.
  /// This value may be {@code null}.
  ///@return value to pass to restoreToCount() to balance this save()
  int saveLayer1(rectf_.RectF bounds, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_saveLayer1,
          jni.JniType.intType, [bounds.reference, paint.reference]).integer;

  static final _id_saveLayer2 = jniAccessors.getMethodIDOf(
      _classRef, "saveLayer", "(FFFFLandroid/graphics/Paint;I)I");

  /// from: public int saveLayer(float left, float top, float right, float bottom, android.graphics.Paint paint, int saveFlags)
  ///
  /// Helper version of saveLayer() that takes 4 values rather than a RectF.
  ///
  /// As of API Level API level {@value Build.VERSION_CODES\#P} the only valid
  /// {@code saveFlags} is \#ALL_SAVE_FLAG.  All other flags are ignored.
  ///@deprecated Use \#saveLayer(float, float, float, float, Paint) instead.
  ///@param paint This value may be {@code null}.
  ///@param saveFlags Value is either <code>0</code> or android.graphics.Canvas\#ALL_SAVE_FLAG
  int saveLayer2(double left, double top, double right, double bottom,
          paint_.Paint paint, int saveFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_saveLayer2,
          jni.JniType.intType,
          [left, top, right, bottom, paint.reference, saveFlags]).integer;

  static final _id_saveLayer3 = jniAccessors.getMethodIDOf(
      _classRef, "saveLayer", "(FFFFLandroid/graphics/Paint;)I");

  /// from: public int saveLayer(float left, float top, float right, float bottom, android.graphics.Paint paint)
  ///
  /// Convenience for \#saveLayer(RectF, Paint) that takes the four float coordinates of the
  /// bounds rectangle.
  ///@param paint This value may be {@code null}.
  int saveLayer3(double left, double top, double right, double bottom,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_saveLayer3,
          jni.JniType.intType,
          [left, top, right, bottom, paint.reference]).integer;

  static final _id_saveLayerAlpha = jniAccessors.getMethodIDOf(
      _classRef, "saveLayerAlpha", "(Landroid/graphics/RectF;II)I");

  /// from: public int saveLayerAlpha(android.graphics.RectF bounds, int alpha, int saveFlags)
  ///
  /// This behaves the same as save(), but in addition it allocates and
  /// redirects drawing to an offscreen bitmap.
  /// <p class="note"><strong>Note:</strong> this method is very expensive,
  /// incurring more than double rendering cost for contained content. Avoid
  /// using this method, especially if the bounds provided are large. It is
  /// recommended to use a android.view.View\#LAYER_TYPE_HARDWARE hardware layer on a View
  /// to apply an xfermode, color filter, or alpha, as it will perform much
  /// better than this method.
  ///
  /// All drawing calls are directed to a newly allocated offscreen bitmap.
  /// Only when the balancing call to restore() is made, is that offscreen
  /// buffer drawn back to the current target of the Canvas (either the
  /// screen, it's target Bitmap, or the previous layer).
  ///
  /// The {@code alpha} parameter is applied when the offscreen bitmap is
  /// drawn back when restore() is called.
  ///
  /// As of API Level API level {@value Build.VERSION_CODES\#P} the only valid
  /// {@code saveFlags} is \#ALL_SAVE_FLAG.  All other flags are ignored.
  ///@deprecated Use \#saveLayerAlpha(RectF, int) instead.
  ///@param bounds The maximum size the offscreen bitmap needs to be
  ///                  (in local coordinates)
  /// This value may be {@code null}.
  ///@param alpha The alpha to apply to the offscreen when it is
  ///                 drawn during restore()
  ///@param saveFlags see _SAVE_FLAG constants, generally \#ALL_SAVE_FLAG is recommended
  ///                  for performance reasons.
  /// Value is either <code>0</code> or android.graphics.Canvas\#ALL_SAVE_FLAG
  ///@return value to pass to restoreToCount() to balance this call
  int saveLayerAlpha(rectf_.RectF bounds, int alpha, int saveFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_saveLayerAlpha,
          jni.JniType.intType, [bounds.reference, alpha, saveFlags]).integer;

  static final _id_saveLayerAlpha1 = jniAccessors.getMethodIDOf(
      _classRef, "saveLayerAlpha", "(Landroid/graphics/RectF;I)I");

  /// from: public int saveLayerAlpha(android.graphics.RectF bounds, int alpha)
  ///
  /// Convenience for \#saveLayer(RectF, Paint) but instead of taking a entire Paint object
  /// it takes only the {@code alpha} parameter.
  ///@param bounds The maximum size the offscreen bitmap needs to be
  ///                  (in local coordinates)
  /// This value may be {@code null}.
  ///@param alpha The alpha to apply to the offscreen when it is
  ///                  drawn during restore()
  int saveLayerAlpha1(rectf_.RectF bounds, int alpha) =>
      jniAccessors.callMethodWithArgs(reference, _id_saveLayerAlpha1,
          jni.JniType.intType, [bounds.reference, alpha]).integer;

  static final _id_saveLayerAlpha2 =
      jniAccessors.getMethodIDOf(_classRef, "saveLayerAlpha", "(FFFFII)I");

  /// from: public int saveLayerAlpha(float left, float top, float right, float bottom, int alpha, int saveFlags)
  ///
  /// Helper for saveLayerAlpha() that takes 4 values instead of a RectF.
  ///
  /// As of API Level API level {@value Build.VERSION_CODES\#P} the only valid
  /// {@code saveFlags} is \#ALL_SAVE_FLAG.  All other flags are ignored.
  ///@deprecated Use \#saveLayerAlpha(float, float, float, float, int) instead.
  ///@param saveFlags Value is either <code>0</code> or android.graphics.Canvas\#ALL_SAVE_FLAG
  int saveLayerAlpha2(double left, double top, double right, double bottom,
          int alpha, int saveFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_saveLayerAlpha2,
          jni.JniType.intType,
          [left, top, right, bottom, alpha, saveFlags]).integer;

  static final _id_saveLayerAlpha3 =
      jniAccessors.getMethodIDOf(_classRef, "saveLayerAlpha", "(FFFFI)I");

  /// from: public int saveLayerAlpha(float left, float top, float right, float bottom, int alpha)
  ///
  /// Convenience for \#saveLayerAlpha(RectF, int) that takes the four float coordinates of
  /// the bounds rectangle.
  int saveLayerAlpha3(
          double left, double top, double right, double bottom, int alpha) =>
      jniAccessors.callMethodWithArgs(reference, _id_saveLayerAlpha3,
          jni.JniType.intType, [left, top, right, bottom, alpha]).integer;

  static final _id_restore =
      jniAccessors.getMethodIDOf(_classRef, "restore", "()V");

  /// from: public void restore()
  ///
  /// This call balances a previous call to save(), and is used to remove all
  /// modifications to the matrix/clip state since the last save call. It is
  /// an error to call restore() more times than save() was called.
  void restore() => jniAccessors.callMethodWithArgs(
      reference, _id_restore, jni.JniType.voidType, []).check();

  static final _id_getSaveCount =
      jniAccessors.getMethodIDOf(_classRef, "getSaveCount", "()I");

  /// from: public int getSaveCount()
  ///
  /// Returns the number of matrix/clip states on the Canvas' private stack.
  /// This will equal \# save() calls - \# restore() calls.
  int getSaveCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getSaveCount, jni.JniType.intType, []).integer;

  static final _id_restoreToCount =
      jniAccessors.getMethodIDOf(_classRef, "restoreToCount", "(I)V");

  /// from: public void restoreToCount(int saveCount)
  ///
  /// Efficient way to pop any calls to save() that happened after the save
  /// count reached saveCount. It is an error for saveCount to be less than 1.
  ///
  /// Example:
  ///    int count = canvas.save();
  ///    ... // more calls potentially to save()
  ///    canvas.restoreToCount(count);
  ///    // now the canvas is back in the same state it was before the initial
  ///    // call to save().
  ///@param saveCount The save level to restore to.
  void restoreToCount(int saveCount) => jniAccessors.callMethodWithArgs(
      reference, _id_restoreToCount, jni.JniType.voidType, [saveCount]).check();

  static final _id_translate =
      jniAccessors.getMethodIDOf(_classRef, "translate", "(FF)V");

  /// from: public void translate(float dx, float dy)
  ///
  /// Preconcat the current matrix with the specified translation
  ///@param dx The distance to translate in X
  ///@param dy The distance to translate in Y
  void translate(double dx, double dy) => jniAccessors.callMethodWithArgs(
      reference, _id_translate, jni.JniType.voidType, [dx, dy]).check();

  static final _id_scale =
      jniAccessors.getMethodIDOf(_classRef, "scale", "(FF)V");

  /// from: public void scale(float sx, float sy)
  ///
  /// Preconcat the current matrix with the specified scale.
  ///@param sx The amount to scale in X
  ///@param sy The amount to scale in Y
  void scale(double sx, double sy) => jniAccessors.callMethodWithArgs(
      reference, _id_scale, jni.JniType.voidType, [sx, sy]).check();

  static final _id_scale1 =
      jniAccessors.getMethodIDOf(_classRef, "scale", "(FFFF)V");

  /// from: public final void scale(float sx, float sy, float px, float py)
  ///
  /// Preconcat the current matrix with the specified scale.
  ///@param sx The amount to scale in X
  ///@param sy The amount to scale in Y
  ///@param px The x-coord for the pivot point (unchanged by the scale)
  ///@param py The y-coord for the pivot point (unchanged by the scale)
  void scale1(double sx, double sy, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_scale1,
          jni.JniType.voidType, [sx, sy, px, py]).check();

  static final _id_rotate =
      jniAccessors.getMethodIDOf(_classRef, "rotate", "(F)V");

  /// from: public void rotate(float degrees)
  ///
  /// Preconcat the current matrix with the specified rotation.
  ///@param degrees The amount to rotate, in degrees
  void rotate(double degrees) => jniAccessors.callMethodWithArgs(
      reference, _id_rotate, jni.JniType.voidType, [degrees]).check();

  static final _id_rotate1 =
      jniAccessors.getMethodIDOf(_classRef, "rotate", "(FFF)V");

  /// from: public final void rotate(float degrees, float px, float py)
  ///
  /// Preconcat the current matrix with the specified rotation.
  ///@param degrees The amount to rotate, in degrees
  ///@param px The x-coord for the pivot point (unchanged by the rotation)
  ///@param py The y-coord for the pivot point (unchanged by the rotation)
  void rotate1(double degrees, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_rotate1,
          jni.JniType.voidType, [degrees, px, py]).check();

  static final _id_skew =
      jniAccessors.getMethodIDOf(_classRef, "skew", "(FF)V");

  /// from: public void skew(float sx, float sy)
  ///
  /// Preconcat the current matrix with the specified skew.
  ///@param sx The amount to skew in X
  ///@param sy The amount to skew in Y
  void skew(double sx, double sy) => jniAccessors.callMethodWithArgs(
      reference, _id_skew, jni.JniType.voidType, [sx, sy]).check();

  static final _id_concat = jniAccessors.getMethodIDOf(
      _classRef, "concat", "(Landroid/graphics/Matrix;)V");

  /// from: public void concat(android.graphics.Matrix matrix)
  ///
  /// Preconcat the current matrix with the specified matrix. If the specified
  /// matrix is null, this method does nothing.
  ///@param matrix The matrix to preconcatenate with the current matrix
  ///
  /// This value may be {@code null}.
  void concat(matrix_.Matrix matrix) => jniAccessors.callMethodWithArgs(
      reference, _id_concat, jni.JniType.voidType, [matrix.reference]).check();

  static final _id_setMatrix = jniAccessors.getMethodIDOf(
      _classRef, "setMatrix", "(Landroid/graphics/Matrix;)V");

  /// from: public void setMatrix(android.graphics.Matrix matrix)
  ///
  /// Completely replace the current matrix with the specified matrix. If the
  /// matrix parameter is null, then the current matrix is reset to identity.
  ///
  /// <strong>Note:</strong> it is recommended to use \#concat(Matrix),
  /// \#scale(float, float), \#translate(float, float) and
  /// \#rotate(float) instead of this method.
  ///@param matrix The matrix to replace the current matrix with. If it is
  ///               null, set the current matrix to identity.
  ///
  /// This value may be {@code null}.
  ///@see \#concat(Matrix)
  void setMatrix(matrix_.Matrix matrix) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMatrix,
      jni.JniType.voidType,
      [matrix.reference]).check();

  static final _id_getMatrix = jniAccessors.getMethodIDOf(
      _classRef, "getMatrix", "(Landroid/graphics/Matrix;)V");

  /// from: public void getMatrix(android.graphics.Matrix ctm)
  ///
  /// Return, in ctm, the current transformation matrix. This does not alter
  /// the matrix in the canvas, but just returns a copy of it.
  ///@deprecated \#isHardwareAccelerated() Hardware accelerated canvases may have any
  /// matrix when passed to a View or Drawable, as it is implementation defined where in the
  /// hierarchy such canvases are created. It is recommended in such cases to either draw contents
  /// irrespective of the current matrix, or to track relevant transform state outside of the
  /// canvas.
  ///@param ctm This value must never be {@code null}.
  void getMatrix(matrix_.Matrix ctm) => jniAccessors.callMethodWithArgs(
      reference, _id_getMatrix, jni.JniType.voidType, [ctm.reference]).check();

  static final _id_getMatrix1 = jniAccessors.getMethodIDOf(
      _classRef, "getMatrix", "()Landroid/graphics/Matrix;");

  /// from: public final android.graphics.Matrix getMatrix()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new matrix with a copy of the canvas' current transformation
  /// matrix.
  ///@deprecated \#isHardwareAccelerated() Hardware accelerated canvases may have any
  /// matrix when passed to a View or Drawable, as it is implementation defined where in the
  /// hierarchy such canvases are created. It is recommended in such cases to either draw contents
  /// irrespective of the current matrix, or to track relevant transform state outside of the
  /// canvas.
  ///@return This value will never be {@code null}.
  matrix_.Matrix getMatrix1() =>
      matrix_.Matrix.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMatrix1, jni.JniType.objectType, []).object);

  static final _id_clipRect = jniAccessors.getMethodIDOf(_classRef, "clipRect",
      "(Landroid/graphics/RectF;Landroid/graphics/Region\$Op;)Z");

  /// from: public boolean clipRect(android.graphics.RectF rect, android.graphics.Region.Op op)
  ///
  /// Modify the current clip with the specified rectangle.
  ///@param rect The rect to intersect with the current clip
  /// This value must never be {@code null}.
  ///@param op How the clip is modified
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  ///@deprecated Region.Op values other than Region.Op\#INTERSECT and
  /// Region.Op\#DIFFERENCE have the ability to expand the clip. The canvas clipping APIs
  /// are intended to only expand the clip as a result of a restore operation. This enables a view
  /// parent to clip a canvas to clearly define the maximal drawing area of its children. The
  /// recommended alternative calls are \#clipRect(RectF) and \#clipOutRect(RectF);
  ///
  /// As of API Level API level {@value Build.VERSION_CODES\#P} only Region.Op\#INTERSECT and
  /// Region.Op\#DIFFERENCE are valid Region.Op parameters.
  bool clipRect(rectf_.RectF rect, region_.Region_Op op) =>
      jniAccessors.callMethodWithArgs(reference, _id_clipRect,
          jni.JniType.booleanType, [rect.reference, op.reference]).boolean;

  static final _id_clipRect1 = jniAccessors.getMethodIDOf(_classRef, "clipRect",
      "(Landroid/graphics/Rect;Landroid/graphics/Region\$Op;)Z");

  /// from: public boolean clipRect(android.graphics.Rect rect, android.graphics.Region.Op op)
  ///
  /// Modify the current clip with the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param rect The rectangle to intersect with the current clip.
  /// This value must never be {@code null}.
  ///@param op How the clip is modified
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  ///@deprecated Region.Op values other than Region.Op\#INTERSECT and
  /// Region.Op\#DIFFERENCE have the ability to expand the clip. The canvas clipping APIs
  /// are intended to only expand the clip as a result of a restore operation. This enables a view
  /// parent to clip a canvas to clearly define the maximal drawing area of its children. The
  /// recommended alternative calls are \#clipRect(Rect) and \#clipOutRect(Rect);
  ///
  /// As of API Level API level {@value Build.VERSION_CODES\#P} only Region.Op\#INTERSECT and
  /// Region.Op\#DIFFERENCE are valid Region.Op parameters.
  bool clipRect1(rect_.Rect rect, region_.Region_Op op) =>
      jniAccessors.callMethodWithArgs(reference, _id_clipRect1,
          jni.JniType.booleanType, [rect.reference, op.reference]).boolean;

  static final _id_clipRect2 = jniAccessors.getMethodIDOf(
      _classRef, "clipRect", "(Landroid/graphics/RectF;)Z");

  /// from: public boolean clipRect(android.graphics.RectF rect)
  ///
  /// Intersect the current clip with the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param rect The rectangle to intersect with the current clip.
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  bool clipRect2(rectf_.RectF rect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_clipRect2,
      jni.JniType.booleanType,
      [rect.reference]).boolean;

  static final _id_clipOutRect = jniAccessors.getMethodIDOf(
      _classRef, "clipOutRect", "(Landroid/graphics/RectF;)Z");

  /// from: public boolean clipOutRect(android.graphics.RectF rect)
  ///
  /// Set the clip to the difference of the current clip and the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param rect The rectangle to perform a difference op with the current clip.
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  bool clipOutRect(rectf_.RectF rect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_clipOutRect,
      jni.JniType.booleanType,
      [rect.reference]).boolean;

  static final _id_clipRect3 = jniAccessors.getMethodIDOf(
      _classRef, "clipRect", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean clipRect(android.graphics.Rect rect)
  ///
  /// Intersect the current clip with the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param rect The rectangle to intersect with the current clip.
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  bool clipRect3(rect_.Rect rect) => jniAccessors.callMethodWithArgs(reference,
      _id_clipRect3, jni.JniType.booleanType, [rect.reference]).boolean;

  static final _id_clipOutRect1 = jniAccessors.getMethodIDOf(
      _classRef, "clipOutRect", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean clipOutRect(android.graphics.Rect rect)
  ///
  /// Set the clip to the difference of the current clip and the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param rect The rectangle to perform a difference op with the current clip.
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  bool clipOutRect1(rect_.Rect rect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_clipOutRect1,
      jni.JniType.booleanType,
      [rect.reference]).boolean;

  static final _id_clipRect4 = jniAccessors.getMethodIDOf(
      _classRef, "clipRect", "(FFFFLandroid/graphics/Region\$Op;)Z");

  /// from: public boolean clipRect(float left, float top, float right, float bottom, android.graphics.Region.Op op)
  ///
  /// Modify the current clip with the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param left The left side of the rectangle to intersect with the
  ///               current clip
  ///@param top The top of the rectangle to intersect with the current
  ///               clip
  ///@param right The right side of the rectangle to intersect with the
  ///               current clip
  ///@param bottom The bottom of the rectangle to intersect with the current
  ///               clip
  ///@param op How the clip is modified
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  ///@deprecated Region.Op values other than Region.Op\#INTERSECT and
  /// Region.Op\#DIFFERENCE have the ability to expand the clip. The canvas clipping APIs
  /// are intended to only expand the clip as a result of a restore operation. This enables a view
  /// parent to clip a canvas to clearly define the maximal drawing area of its children. The
  /// recommended alternative calls are \#clipRect(float,float,float,float) and
  /// \#clipOutRect(float,float,float,float);
  ///
  /// As of API Level API level {@value Build.VERSION_CODES\#P} only Region.Op\#INTERSECT and
  /// Region.Op\#DIFFERENCE are valid Region.Op parameters.
  bool clipRect4(double left, double top, double right, double bottom,
          region_.Region_Op op) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_clipRect4,
          jni.JniType.booleanType,
          [left, top, right, bottom, op.reference]).boolean;

  static final _id_clipRect5 =
      jniAccessors.getMethodIDOf(_classRef, "clipRect", "(FFFF)Z");

  /// from: public boolean clipRect(float left, float top, float right, float bottom)
  ///
  /// Intersect the current clip with the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param left The left side of the rectangle to intersect with the
  ///               current clip
  ///@param top The top of the rectangle to intersect with the current clip
  ///@param right The right side of the rectangle to intersect with the
  ///               current clip
  ///@param bottom The bottom of the rectangle to intersect with the current
  ///               clip
  ///@return true if the resulting clip is non-empty
  bool clipRect5(double left, double top, double right, double bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_clipRect5,
          jni.JniType.booleanType, [left, top, right, bottom]).boolean;

  static final _id_clipOutRect2 =
      jniAccessors.getMethodIDOf(_classRef, "clipOutRect", "(FFFF)Z");

  /// from: public boolean clipOutRect(float left, float top, float right, float bottom)
  ///
  /// Set the clip to the difference of the current clip and the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param left The left side of the rectangle used in the difference operation
  ///@param top The top of the rectangle used in the difference operation
  ///@param right The right side of the rectangle used in the difference operation
  ///@param bottom The bottom of the rectangle used in the difference operation
  ///@return true if the resulting clip is non-empty
  bool clipOutRect2(double left, double top, double right, double bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_clipOutRect2,
          jni.JniType.booleanType, [left, top, right, bottom]).boolean;

  static final _id_clipRect6 =
      jniAccessors.getMethodIDOf(_classRef, "clipRect", "(IIII)Z");

  /// from: public boolean clipRect(int left, int top, int right, int bottom)
  ///
  /// Intersect the current clip with the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param left The left side of the rectangle to intersect with the
  ///               current clip
  ///@param top The top of the rectangle to intersect with the current clip
  ///@param right The right side of the rectangle to intersect with the
  ///               current clip
  ///@param bottom The bottom of the rectangle to intersect with the current
  ///               clip
  ///@return true if the resulting clip is non-empty
  bool clipRect6(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_clipRect6,
          jni.JniType.booleanType, [left, top, right, bottom]).boolean;

  static final _id_clipOutRect3 =
      jniAccessors.getMethodIDOf(_classRef, "clipOutRect", "(IIII)Z");

  /// from: public boolean clipOutRect(int left, int top, int right, int bottom)
  ///
  /// Set the clip to the difference of the current clip and the specified rectangle, which is
  /// expressed in local coordinates.
  ///@param left The left side of the rectangle used in the difference operation
  ///@param top The top of the rectangle used in the difference operation
  ///@param right The right side of the rectangle used in the difference operation
  ///@param bottom The bottom of the rectangle used in the difference operation
  ///@return true if the resulting clip is non-empty
  bool clipOutRect3(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_clipOutRect3,
          jni.JniType.booleanType, [left, top, right, bottom]).boolean;

  static final _id_clipPath = jniAccessors.getMethodIDOf(_classRef, "clipPath",
      "(Landroid/graphics/Path;Landroid/graphics/Region\$Op;)Z");

  /// from: public boolean clipPath(android.graphics.Path path, android.graphics.Region.Op op)
  ///
  /// Modify the current clip with the specified path.
  ///@param path The path to operate on the current clip
  /// This value must never be {@code null}.
  ///@param op How the clip is modified
  /// This value must never be {@code null}.
  ///@return true if the resulting is non-empty
  ///@deprecated Region.Op values other than Region.Op\#INTERSECT and
  /// Region.Op\#DIFFERENCE have the ability to expand the clip. The canvas clipping APIs
  /// are intended to only expand the clip as a result of a restore operation. This enables a view
  /// parent to clip a canvas to clearly define the maximal drawing area of its children. The
  /// recommended alternative calls are \#clipPath(Path) and
  /// \#clipOutPath(Path);
  ///
  /// As of API Level API level {@value Build.VERSION_CODES\#P} only Region.Op\#INTERSECT and
  /// Region.Op\#DIFFERENCE are valid Region.Op parameters.
  bool clipPath(path_.Path path, region_.Region_Op op) =>
      jniAccessors.callMethodWithArgs(reference, _id_clipPath,
          jni.JniType.booleanType, [path.reference, op.reference]).boolean;

  static final _id_clipPath1 = jniAccessors.getMethodIDOf(
      _classRef, "clipPath", "(Landroid/graphics/Path;)Z");

  /// from: public boolean clipPath(android.graphics.Path path)
  ///
  /// Intersect the current clip with the specified path.
  ///@param path The path to intersect with the current clip
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  bool clipPath1(path_.Path path) => jniAccessors.callMethodWithArgs(reference,
      _id_clipPath1, jni.JniType.booleanType, [path.reference]).boolean;

  static final _id_clipOutPath = jniAccessors.getMethodIDOf(
      _classRef, "clipOutPath", "(Landroid/graphics/Path;)Z");

  /// from: public boolean clipOutPath(android.graphics.Path path)
  ///
  /// Set the clip to the difference of the current clip and the specified path.
  ///@param path The path used in the difference operation
  /// This value must never be {@code null}.
  ///@return true if the resulting clip is non-empty
  bool clipOutPath(path_.Path path) => jniAccessors.callMethodWithArgs(
      reference,
      _id_clipOutPath,
      jni.JniType.booleanType,
      [path.reference]).boolean;

  static final _id_getDrawFilter = jniAccessors.getMethodIDOf(
      _classRef, "getDrawFilter", "()Landroid/graphics/DrawFilter;");

  /// from: public android.graphics.DrawFilter getDrawFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This value may be {@code null}.
  drawfilter_.DrawFilter getDrawFilter() =>
      drawfilter_.DrawFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrawFilter, jni.JniType.objectType, []).object);

  static final _id_setDrawFilter = jniAccessors.getMethodIDOf(
      _classRef, "setDrawFilter", "(Landroid/graphics/DrawFilter;)V");

  /// from: public void setDrawFilter(android.graphics.DrawFilter filter)
  ///
  /// @param filter This value may be {@code null}.
  void setDrawFilter(drawfilter_.DrawFilter filter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDrawFilter,
          jni.JniType.voidType, [filter.reference]).check();

  static final _id_quickReject = jniAccessors.getMethodIDOf(
      _classRef,
      "quickReject",
      "(Landroid/graphics/RectF;Landroid/graphics/Canvas\$EdgeType;)Z");

  /// from: public boolean quickReject(android.graphics.RectF rect, android.graphics.Canvas.EdgeType type)
  ///
  /// Return true if the specified rectangle, after being transformed by the
  /// current matrix, would lie completely outside of the current clip. Call
  /// this to check if an area you intend to draw into is clipped out (and
  /// therefore you can skip making the draw calls).
  ///@param rect the rect to compare with the current clip
  /// This value must never be {@code null}.
  ///@param type Canvas.EdgeType\#AA if the path should be considered antialiased,
  ///              since that means it may affect a larger area (more pixels) than
  ///              non-antialiased (Canvas.EdgeType\#BW).
  /// This value must never be {@code null}.
  ///@return true if the rect (transformed by the canvas' matrix)
  ///              does not intersect with the canvas' clip
  bool quickReject(rectf_.RectF rect, Canvas_EdgeType type) =>
      jniAccessors.callMethodWithArgs(reference, _id_quickReject,
          jni.JniType.booleanType, [rect.reference, type.reference]).boolean;

  static final _id_quickReject1 = jniAccessors.getMethodIDOf(
      _classRef,
      "quickReject",
      "(Landroid/graphics/Path;Landroid/graphics/Canvas\$EdgeType;)Z");

  /// from: public boolean quickReject(android.graphics.Path path, android.graphics.Canvas.EdgeType type)
  ///
  /// Return true if the specified path, after being transformed by the
  /// current matrix, would lie completely outside of the current clip. Call
  /// this to check if an area you intend to draw into is clipped out (and
  /// therefore you can skip making the draw calls). Note: for speed it may
  /// return false even if the path itself might not intersect the clip
  /// (i.e. the bounds of the path intersects, but the path does not).
  ///@param path The path to compare with the current clip
  /// This value must never be {@code null}.
  ///@param type Canvas.EdgeType\#AA if the path should be considered antialiased,
  ///                    since that means it may affect a larger area (more pixels) than
  ///                    non-antialiased (Canvas.EdgeType\#BW).
  /// This value must never be {@code null}.
  ///@return true if the path (transformed by the canvas' matrix)
  ///                    does not intersect with the canvas' clip
  bool quickReject1(path_.Path path, Canvas_EdgeType type) =>
      jniAccessors.callMethodWithArgs(reference, _id_quickReject1,
          jni.JniType.booleanType, [path.reference, type.reference]).boolean;

  static final _id_quickReject2 = jniAccessors.getMethodIDOf(
      _classRef, "quickReject", "(FFFFLandroid/graphics/Canvas\$EdgeType;)Z");

  /// from: public boolean quickReject(float left, float top, float right, float bottom, android.graphics.Canvas.EdgeType type)
  ///
  /// Return true if the specified rectangle, after being transformed by the
  /// current matrix, would lie completely outside of the current clip. Call
  /// this to check if an area you intend to draw into is clipped out (and
  /// therefore you can skip making the draw calls).
  ///@param left The left side of the rectangle to compare with the
  ///                    current clip
  ///@param top The top of the rectangle to compare with the current
  ///                    clip
  ///@param right The right side of the rectangle to compare with the
  ///                    current clip
  ///@param bottom The bottom of the rectangle to compare with the
  ///                    current clip
  ///@param type Canvas.EdgeType\#AA if the path should be considered antialiased,
  ///                    since that means it may affect a larger area (more pixels) than
  ///                    non-antialiased (Canvas.EdgeType\#BW).
  /// This value must never be {@code null}.
  ///@return true if the rect (transformed by the canvas' matrix)
  ///                    does not intersect with the canvas' clip
  bool quickReject2(double left, double top, double right, double bottom,
          Canvas_EdgeType type) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_quickReject2,
          jni.JniType.booleanType,
          [left, top, right, bottom, type.reference]).boolean;

  static final _id_getClipBounds = jniAccessors.getMethodIDOf(
      _classRef, "getClipBounds", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean getClipBounds(android.graphics.Rect bounds)
  ///
  /// Return the bounds of the current clip (in local coordinates) in the
  /// bounds parameter, and return true if it is non-empty. This can be useful
  /// in a way similar to quickReject, in that it tells you that drawing
  /// outside of these bounds will be clipped out.
  ///@param bounds Return the clip bounds here. If it is null, ignore it but
  ///               still return true if the current clip is non-empty.
  /// This value may be {@code null}.
  ///@return true if the current clip is non-empty.
  bool getClipBounds(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getClipBounds,
      jni.JniType.booleanType,
      [bounds.reference]).boolean;

  static final _id_getClipBounds1 = jniAccessors.getMethodIDOf(
      _classRef, "getClipBounds", "()Landroid/graphics/Rect;");

  /// from: public final android.graphics.Rect getClipBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the bounds of the current clip (in local coordinates).
  ///@return the clip bounds, or [0, 0, 0, 0] if the clip is empty.
  ///
  /// This value will never be {@code null}.
  rect_.Rect getClipBounds1() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClipBounds1, jni.JniType.objectType, []).object);

  static final _id_drawPicture = jniAccessors.getMethodIDOf(
      _classRef, "drawPicture", "(Landroid/graphics/Picture;)V");

  /// from: public void drawPicture(android.graphics.Picture picture)
  ///
  /// Save the canvas state, draw the picture, and restore the canvas state.
  /// This differs from picture.draw(canvas), which does not perform any
  /// save/restore.
  ///
  ///
  /// <strong>Note:</strong> This forces the picture to internally call
  /// Picture\#endRecording in order to prepare for playback.
  ///@param picture The picture to be drawn
  ///
  /// This value must never be {@code null}.
  void drawPicture(picture_.Picture picture) => jniAccessors.callMethodWithArgs(
      reference,
      _id_drawPicture,
      jni.JniType.voidType,
      [picture.reference]).check();

  static final _id_drawPicture1 = jniAccessors.getMethodIDOf(_classRef,
      "drawPicture", "(Landroid/graphics/Picture;Landroid/graphics/RectF;)V");

  /// from: public void drawPicture(android.graphics.Picture picture, android.graphics.RectF dst)
  ///
  /// Draw the picture, stretched to fit into the dst rectangle.
  ///@param picture This value must never be {@code null}.
  ///@param dst This value must never be {@code null}.
  void drawPicture1(picture_.Picture picture, rectf_.RectF dst) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawPicture1,
          jni.JniType.voidType, [picture.reference, dst.reference]).check();

  static final _id_drawPicture2 = jniAccessors.getMethodIDOf(_classRef,
      "drawPicture", "(Landroid/graphics/Picture;Landroid/graphics/Rect;)V");

  /// from: public void drawPicture(android.graphics.Picture picture, android.graphics.Rect dst)
  ///
  /// Draw the picture, stretched to fit into the dst rectangle.
  ///@param picture This value must never be {@code null}.
  ///@param dst This value must never be {@code null}.
  void drawPicture2(picture_.Picture picture, rect_.Rect dst) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawPicture2,
          jni.JniType.voidType, [picture.reference, dst.reference]).check();

  static final _id_drawArc = jniAccessors.getMethodIDOf(_classRef, "drawArc",
      "(Landroid/graphics/RectF;FFZLandroid/graphics/Paint;)V");

  /// from: public void drawArc(android.graphics.RectF oval, float startAngle, float sweepAngle, boolean useCenter, android.graphics.Paint paint)
  ///
  ///
  /// Draw the specified arc, which will be scaled to fit inside the specified oval.
  ///
  ///
  ///
  /// If the start angle is negative or >= 360, the start angle is treated as start angle modulo
  /// 360.
  ///
  ///
  ///
  /// If the sweep angle is >= 360, then the oval is drawn completely. Note that this differs
  /// slightly from SkPath::arcTo, which treats the sweep angle modulo 360. If the sweep angle is
  /// negative, the sweep angle is treated as sweep angle modulo 360
  ///
  ///
  ///
  /// The arc is drawn clockwise. An angle of 0 degrees correspond to the geometric angle of 0
  /// degrees (3 o'clock on a watch.)
  ///
  ///
  ///@param oval The bounds of oval used to define the shape and size of the arc
  /// This value must never be {@code null}.
  ///@param startAngle Starting angle (in degrees) where the arc begins
  ///@param sweepAngle Sweep angle (in degrees) measured clockwise
  ///@param useCenter If true, include the center of the oval in the arc, and close it if it is
  ///            being stroked. This will draw a wedge
  ///@param paint The paint used to draw the arc
  ///
  /// This value must never be {@code null}.
  void drawArc(rectf_.RectF oval, double startAngle, double sweepAngle,
          bool useCenter, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawArc, jni.JniType.voidType, [
        oval.reference,
        startAngle,
        sweepAngle,
        useCenter,
        paint.reference
      ]).check();

  static final _id_drawArc1 = jniAccessors.getMethodIDOf(
      _classRef, "drawArc", "(FFFFFFZLandroid/graphics/Paint;)V");

  /// from: public void drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, android.graphics.Paint paint)
  ///
  ///
  /// Draw the specified arc, which will be scaled to fit inside the specified oval.
  ///
  ///
  ///
  /// If the start angle is negative or >= 360, the start angle is treated as start angle modulo
  /// 360.
  ///
  ///
  ///
  /// If the sweep angle is >= 360, then the oval is drawn completely. Note that this differs
  /// slightly from SkPath::arcTo, which treats the sweep angle modulo 360. If the sweep angle is
  /// negative, the sweep angle is treated as sweep angle modulo 360
  ///
  ///
  ///
  /// The arc is drawn clockwise. An angle of 0 degrees correspond to the geometric angle of 0
  /// degrees (3 o'clock on a watch.)
  ///
  ///
  ///@param startAngle Starting angle (in degrees) where the arc begins
  ///@param sweepAngle Sweep angle (in degrees) measured clockwise
  ///@param useCenter If true, include the center of the oval in the arc, and close it if it is
  ///            being stroked. This will draw a wedge
  ///@param paint The paint used to draw the arc
  ///
  /// This value must never be {@code null}.
  void drawArc1(
          double left,
          double top,
          double right,
          double bottom,
          double startAngle,
          double sweepAngle,
          bool useCenter,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawArc1, jni.JniType.voidType, [
        left,
        top,
        right,
        bottom,
        startAngle,
        sweepAngle,
        useCenter,
        paint.reference
      ]).check();

  static final _id_drawARGB =
      jniAccessors.getMethodIDOf(_classRef, "drawARGB", "(IIII)V");

  /// from: public void drawARGB(int a, int r, int g, int b)
  ///
  /// Fill the entire canvas' bitmap (restricted to the current clip) with the specified ARGB
  /// color, using srcover porterduff mode.
  ///@param a alpha component (0..255) of the color to draw onto the canvas
  ///@param r red component (0..255) of the color to draw onto the canvas
  ///@param g green component (0..255) of the color to draw onto the canvas
  ///@param b blue component (0..255) of the color to draw onto the canvas
  void drawARGB(int a, int r, int g, int b) => jniAccessors.callMethodWithArgs(
      reference, _id_drawARGB, jni.JniType.voidType, [a, r, g, b]).check();

  static final _id_drawBitmap = jniAccessors.getMethodIDOf(_classRef,
      "drawBitmap", "(Landroid/graphics/Bitmap;FFLandroid/graphics/Paint;)V");

  /// from: public void drawBitmap(android.graphics.Bitmap bitmap, float left, float top, android.graphics.Paint paint)
  ///
  /// Draw the specified bitmap, with its top/left corner at (x,y), using the specified paint,
  /// transformed by the current matrix.
  ///
  /// Note: if the paint contains a maskfilter that generates a mask which extends beyond the
  /// bitmap's original width/height (e.g. BlurMaskFilter), then the bitmap will be drawn as if it
  /// were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be
  /// the edge color replicated.
  ///
  /// If the bitmap and canvas have different densities, this function will take care of
  /// automatically scaling the bitmap to draw at the same density as the canvas.
  ///@param bitmap The bitmap to be drawn
  /// This value must never be {@code null}.
  ///@param left The position of the left side of the bitmap being drawn
  ///@param top The position of the top side of the bitmap being drawn
  ///@param paint The paint used to draw the bitmap (may be null)
  ///
  /// This value may be {@code null}.
  void drawBitmap(
          bitmap_.Bitmap bitmap, double left, double top, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawBitmap,
          jni.JniType.voidType,
          [bitmap.reference, left, top, paint.reference]).check();

  static final _id_drawBitmap1 = jniAccessors.getMethodIDOf(
      _classRef,
      "drawBitmap",
      "(Landroid/graphics/Bitmap;Landroid/graphics/Rect;Landroid/graphics/RectF;Landroid/graphics/Paint;)V");

  /// from: public void drawBitmap(android.graphics.Bitmap bitmap, android.graphics.Rect src, android.graphics.RectF dst, android.graphics.Paint paint)
  ///
  /// Draw the specified bitmap, scaling/translating automatically to fill the destination
  /// rectangle. If the source rectangle is not null, it specifies the subset of the bitmap to
  /// draw.
  ///
  /// Note: if the paint contains a maskfilter that generates a mask which extends beyond the
  /// bitmap's original width/height (e.g. BlurMaskFilter), then the bitmap will be drawn as if it
  /// were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be
  /// the edge color replicated.
  ///
  /// This function _ignores the density associated with the bitmap_. This is because the
  /// source and destination rectangle coordinate spaces are in their respective densities, so must
  /// already have the appropriate scaling factor applied.
  ///@param bitmap The bitmap to be drawn
  /// This value must never be {@code null}.
  ///@param src May be null. The subset of the bitmap to be drawn
  /// This value may be {@code null}.
  ///@param dst The rectangle that the bitmap will be scaled/translated to fit into
  /// This value must never be {@code null}.
  ///@param paint May be null. The paint used to draw the bitmap
  ///
  /// This value may be {@code null}.
  void drawBitmap1(bitmap_.Bitmap bitmap, rect_.Rect src, rectf_.RectF dst,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawBitmap1, jni.JniType.voidType, [
        bitmap.reference,
        src.reference,
        dst.reference,
        paint.reference
      ]).check();

  static final _id_drawBitmap2 = jniAccessors.getMethodIDOf(
      _classRef,
      "drawBitmap",
      "(Landroid/graphics/Bitmap;Landroid/graphics/Rect;Landroid/graphics/Rect;Landroid/graphics/Paint;)V");

  /// from: public void drawBitmap(android.graphics.Bitmap bitmap, android.graphics.Rect src, android.graphics.Rect dst, android.graphics.Paint paint)
  ///
  /// Draw the specified bitmap, scaling/translating automatically to fill the destination
  /// rectangle. If the source rectangle is not null, it specifies the subset of the bitmap to
  /// draw.
  ///
  /// Note: if the paint contains a maskfilter that generates a mask which extends beyond the
  /// bitmap's original width/height (e.g. BlurMaskFilter), then the bitmap will be drawn as if it
  /// were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be
  /// the edge color replicated.
  ///
  /// This function _ignores the density associated with the bitmap_. This is because the
  /// source and destination rectangle coordinate spaces are in their respective densities, so must
  /// already have the appropriate scaling factor applied.
  ///@param bitmap The bitmap to be drawn
  /// This value must never be {@code null}.
  ///@param src May be null. The subset of the bitmap to be drawn
  /// This value may be {@code null}.
  ///@param dst The rectangle that the bitmap will be scaled/translated to fit into
  /// This value must never be {@code null}.
  ///@param paint May be null. The paint used to draw the bitmap
  ///
  /// This value may be {@code null}.
  void drawBitmap2(bitmap_.Bitmap bitmap, rect_.Rect src, rect_.Rect dst,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawBitmap2, jni.JniType.voidType, [
        bitmap.reference,
        src.reference,
        dst.reference,
        paint.reference
      ]).check();

  static final _id_drawBitmap3 = jniAccessors.getMethodIDOf(
      _classRef, "drawBitmap", "([IIIFFIIZLandroid/graphics/Paint;)V");

  /// from: public void drawBitmap(int[] colors, int offset, int stride, float x, float y, int width, int height, boolean hasAlpha, android.graphics.Paint paint)
  ///
  /// Treat the specified array of colors as a bitmap, and draw it. This gives the same result as
  /// first creating a bitmap from the array, and then drawing it, but this method avoids
  /// explicitly creating a bitmap object which can be more efficient if the colors are changing
  /// often.
  ///@param colors Array of colors representing the pixels of the bitmap
  /// This value must never be {@code null}.
  ///@param offset Offset into the array of colors for the first pixel
  ///@param stride The number of colors in the array between rows (must be >= width or <= -width).
  ///@param x The X coordinate for where to draw the bitmap
  ///@param y The Y coordinate for where to draw the bitmap
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param hasAlpha True if the alpha channel of the colors contains valid values. If false, the
  ///            alpha byte is ignored (assumed to be 0xFF for every pixel).
  ///@param paint May be null. The paint used to draw the bitmap
  /// This value may be {@code null}.
  ///@deprecated Usage with a \#isHardwareAccelerated() hardware accelerated canvas
  ///             requires an internal copy of color buffer contents every time this method is
  ///             called. Using a Bitmap avoids this copy, and allows the application to more
  ///             explicitly control the lifetime and copies of pixel data.
  void drawBitmap3(jni.JniObject colors, int offset, int stride, double x,
          double y, int width, int height, bool hasAlpha, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawBitmap3, jni.JniType.voidType, [
        colors.reference,
        offset,
        stride,
        x,
        y,
        width,
        height,
        hasAlpha,
        paint.reference
      ]).check();

  static final _id_drawBitmap4 = jniAccessors.getMethodIDOf(
      _classRef, "drawBitmap", "([IIIIIIIZLandroid/graphics/Paint;)V");

  /// from: public void drawBitmap(int[] colors, int offset, int stride, int x, int y, int width, int height, boolean hasAlpha, android.graphics.Paint paint)
  ///
  /// Legacy version of drawBitmap(int[] colors, ...) that took ints for x,y
  ///@deprecated Usage with a \#isHardwareAccelerated() hardware accelerated canvas
  ///             requires an internal copy of color buffer contents every time this method is
  ///             called. Using a Bitmap avoids this copy, and allows the application to more
  ///             explicitly control the lifetime and copies of pixel data.
  ///@param colors This value must never be {@code null}.
  ///@param paint This value may be {@code null}.
  void drawBitmap4(jni.JniObject colors, int offset, int stride, int x, int y,
          int width, int height, bool hasAlpha, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawBitmap4, jni.JniType.voidType, [
        colors.reference,
        offset,
        stride,
        x,
        y,
        width,
        height,
        hasAlpha,
        paint.reference
      ]).check();

  static final _id_drawBitmap5 = jniAccessors.getMethodIDOf(
      _classRef,
      "drawBitmap",
      "(Landroid/graphics/Bitmap;Landroid/graphics/Matrix;Landroid/graphics/Paint;)V");

  /// from: public void drawBitmap(android.graphics.Bitmap bitmap, android.graphics.Matrix matrix, android.graphics.Paint paint)
  ///
  /// Draw the bitmap using the specified matrix.
  ///@param bitmap The bitmap to draw
  /// This value must never be {@code null}.
  ///@param matrix The matrix used to transform the bitmap when it is drawn
  /// This value must never be {@code null}.
  ///@param paint May be null. The paint used to draw the bitmap
  ///
  /// This value may be {@code null}.
  void drawBitmap5(
          bitmap_.Bitmap bitmap, matrix_.Matrix matrix, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawBitmap5,
          jni.JniType.voidType,
          [bitmap.reference, matrix.reference, paint.reference]).check();

  static final _id_drawBitmapMesh = jniAccessors.getMethodIDOf(
      _classRef,
      "drawBitmapMesh",
      "(Landroid/graphics/Bitmap;II[FI[IILandroid/graphics/Paint;)V");

  /// from: public void drawBitmapMesh(android.graphics.Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, android.graphics.Paint paint)
  ///
  /// Draw the bitmap through the mesh, where mesh vertices are evenly distributed across the
  /// bitmap. There are meshWidth+1 vertices across, and meshHeight+1 vertices down. The verts
  /// array is accessed in row-major order, so that the first meshWidth+1 vertices are distributed
  /// across the top of the bitmap from left to right. A more general version of this method is
  /// drawVertices().
  ///
  /// Prior to API level {@value Build.VERSION_CODES\#P} vertOffset and colorOffset were ignored,
  /// effectively treating them as zeros. In API level {@value Build.VERSION_CODES\#P} and above
  /// these parameters will be respected.
  ///@param bitmap The bitmap to draw using the mesh
  /// This value must never be {@code null}.
  ///@param meshWidth The number of columns in the mesh. Nothing is drawn if this is 0
  ///@param meshHeight The number of rows in the mesh. Nothing is drawn if this is 0
  ///@param verts Array of x,y pairs, specifying where the mesh should be drawn. There must be at
  ///            least (meshWidth+1) * (meshHeight+1) * 2 + vertOffset values in the array
  /// This value must never be {@code null}.
  ///@param vertOffset Number of verts elements to skip before drawing
  ///@param colors May be null. Specifies a color at each vertex, which is interpolated across the
  ///            cell, and whose values are multiplied by the corresponding bitmap colors. If not
  ///            null, there must be at least (meshWidth+1) * (meshHeight+1) + colorOffset values
  ///            in the array.
  /// This value may be {@code null}.
  ///@param colorOffset Number of color elements to skip before drawing
  ///@param paint May be null. The paint used to draw the bitmap
  ///
  /// This value may be {@code null}.
  void drawBitmapMesh(
          bitmap_.Bitmap bitmap,
          int meshWidth,
          int meshHeight,
          jni.JniObject verts,
          int vertOffset,
          jni.JniObject colors,
          int colorOffset,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawBitmapMesh, jni.JniType.voidType, [
        bitmap.reference,
        meshWidth,
        meshHeight,
        verts.reference,
        vertOffset,
        colors.reference,
        colorOffset,
        paint.reference
      ]).check();

  static final _id_drawCircle = jniAccessors.getMethodIDOf(
      _classRef, "drawCircle", "(FFFLandroid/graphics/Paint;)V");

  /// from: public void drawCircle(float cx, float cy, float radius, android.graphics.Paint paint)
  ///
  /// Draw the specified circle using the specified paint. If radius is <= 0, then nothing will be
  /// drawn. The circle will be filled or framed based on the Style in the paint.
  ///@param cx The x-coordinate of the center of the cirle to be drawn
  ///@param cy The y-coordinate of the center of the cirle to be drawn
  ///@param radius The radius of the cirle to be drawn
  ///@param paint The paint used to draw the circle
  ///
  /// This value must never be {@code null}.
  void drawCircle(double cx, double cy, double radius, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawCircle,
          jni.JniType.voidType, [cx, cy, radius, paint.reference]).check();

  static final _id_drawColor =
      jniAccessors.getMethodIDOf(_classRef, "drawColor", "(I)V");

  /// from: public void drawColor(int color)
  ///
  /// Fill the entire canvas' bitmap (restricted to the current clip) with the specified color,
  /// using srcover porterduff mode.
  ///@param color the color to draw onto the canvas
  void drawColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_drawColor, jni.JniType.voidType, [color]).check();

  static final _id_drawColor1 = jniAccessors.getMethodIDOf(
      _classRef, "drawColor", "(ILandroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void drawColor(int color, android.graphics.PorterDuff.Mode mode)
  ///
  /// Fill the entire canvas' bitmap (restricted to the current clip) with the specified color and
  /// porter-duff xfermode.
  ///@param color the color to draw with
  ///@param mode the porter-duff mode to apply to the color
  ///
  /// This value must never be {@code null}.
  void drawColor1(int color, porterduff_.PorterDuff_Mode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawColor1,
          jni.JniType.voidType, [color, mode.reference]).check();

  static final _id_drawLine = jniAccessors.getMethodIDOf(
      _classRef, "drawLine", "(FFFFLandroid/graphics/Paint;)V");

  /// from: public void drawLine(float startX, float startY, float stopX, float stopY, android.graphics.Paint paint)
  ///
  /// Draw a line segment with the specified start and stop x,y coordinates, using the specified
  /// paint.
  ///
  /// Note that since a line is always "framed", the Style is ignored in the paint.
  ///
  ///
  ///
  /// Degenerate lines (length is 0) will not be drawn.
  ///
  ///
  ///@param startX The x-coordinate of the start point of the line
  ///@param startY The y-coordinate of the start point of the line
  ///@param paint The paint used to draw the line
  ///
  /// This value must never be {@code null}.
  void drawLine(double startX, double startY, double stopX, double stopY,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawLine,
          jni.JniType.voidType,
          [startX, startY, stopX, stopY, paint.reference]).check();

  static final _id_drawLines = jniAccessors.getMethodIDOf(
      _classRef, "drawLines", "([FIILandroid/graphics/Paint;)V");

  /// from: public void drawLines(float[] pts, int offset, int count, android.graphics.Paint paint)
  ///
  /// Draw a series of lines. Each line is taken from 4 consecutive values in the pts array. Thus
  /// to draw 1 line, the array must contain at least 4 values. This is logically the same as
  /// drawing the array as follows: drawLine(pts[0], pts[1], pts[2], pts[3]) followed by
  /// drawLine(pts[4], pts[5], pts[6], pts[7]) and so on.
  ///@param pts Array of points to draw [x0 y0 x1 y1 x2 y2 ...]
  /// This value must never be {@code null}.
  ///@param offset Number of values in the array to skip before drawing.
  ///@param count The number of values in the array to process, after skipping "offset" of them.
  ///            Since each line uses 4 values, the number of "lines" that are drawn is really
  ///            (count >> 2).
  ///@param paint The paint used to draw the points
  ///
  /// This value must never be {@code null}.
  void drawLines(
          jni.JniObject pts, int offset, int count, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawLines,
          jni.JniType.voidType,
          [pts.reference, offset, count, paint.reference]).check();

  static final _id_drawLines1 = jniAccessors.getMethodIDOf(
      _classRef, "drawLines", "([FLandroid/graphics/Paint;)V");

  /// from: public void drawLines(float[] pts, android.graphics.Paint paint)
  ///
  /// @param pts This value must never be {@code null}.
  ///@param paint This value must never be {@code null}.
  void drawLines1(jni.JniObject pts, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawLines1,
          jni.JniType.voidType, [pts.reference, paint.reference]).check();

  static final _id_drawOval = jniAccessors.getMethodIDOf(_classRef, "drawOval",
      "(Landroid/graphics/RectF;Landroid/graphics/Paint;)V");

  /// from: public void drawOval(android.graphics.RectF oval, android.graphics.Paint paint)
  ///
  /// Draw the specified oval using the specified paint. The oval will be filled or framed based on
  /// the Style in the paint.
  ///@param oval The rectangle bounds of the oval to be drawn
  ///
  /// This value must never be {@code null}.
  ///@param paint This value must never be {@code null}.
  void drawOval(rectf_.RectF oval, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawOval,
          jni.JniType.voidType, [oval.reference, paint.reference]).check();

  static final _id_drawOval1 = jniAccessors.getMethodIDOf(
      _classRef, "drawOval", "(FFFFLandroid/graphics/Paint;)V");

  /// from: public void drawOval(float left, float top, float right, float bottom, android.graphics.Paint paint)
  ///
  /// Draw the specified oval using the specified paint. The oval will be filled or framed based on
  /// the Style in the paint.
  ///@param paint This value must never be {@code null}.
  void drawOval1(double left, double top, double right, double bottom,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawOval1,
          jni.JniType.voidType,
          [left, top, right, bottom, paint.reference]).check();

  static final _id_drawPaint = jniAccessors.getMethodIDOf(
      _classRef, "drawPaint", "(Landroid/graphics/Paint;)V");

  /// from: public void drawPaint(android.graphics.Paint paint)
  ///
  /// Fill the entire canvas' bitmap (restricted to the current clip) with the specified paint.
  /// This is equivalent (but faster) to drawing an infinitely large rectangle with the specified
  /// paint.
  ///@param paint The paint used to draw onto the canvas
  ///
  /// This value must never be {@code null}.
  void drawPaint(paint_.Paint paint) => jniAccessors.callMethodWithArgs(
      reference,
      _id_drawPaint,
      jni.JniType.voidType,
      [paint.reference]).check();

  static final _id_drawPath = jniAccessors.getMethodIDOf(_classRef, "drawPath",
      "(Landroid/graphics/Path;Landroid/graphics/Paint;)V");

  /// from: public void drawPath(android.graphics.Path path, android.graphics.Paint paint)
  ///
  /// Draw the specified path using the specified paint. The path will be filled or framed based on
  /// the Style in the paint.
  ///@param path The path to be drawn
  /// This value must never be {@code null}.
  ///@param paint The paint used to draw the path
  ///
  /// This value must never be {@code null}.
  void drawPath(path_.Path path, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawPath,
          jni.JniType.voidType, [path.reference, paint.reference]).check();

  static final _id_drawPoint = jniAccessors.getMethodIDOf(
      _classRef, "drawPoint", "(FFLandroid/graphics/Paint;)V");

  /// from: public void drawPoint(float x, float y, android.graphics.Paint paint)
  ///
  /// Helper for drawPoints() for drawing a single point.
  ///@param paint This value must never be {@code null}.
  void drawPoint(double x, double y, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawPoint,
          jni.JniType.voidType, [x, y, paint.reference]).check();

  static final _id_drawPoints = jniAccessors.getMethodIDOf(
      _classRef, "drawPoints", "([FIILandroid/graphics/Paint;)V");

  /// from: public void drawPoints(float[] pts, int offset, int count, android.graphics.Paint paint)
  ///
  /// Draw a series of points. Each point is centered at the coordinate specified by pts[], and its
  /// diameter is specified by the paint's stroke width (as transformed by the canvas' CTM), with
  /// special treatment for a stroke width of 0, which always draws exactly 1 pixel (or at most 4
  /// if antialiasing is enabled). The shape of the point is controlled by the paint's Cap type.
  /// The shape is a square, unless the cap type is Round, in which case the shape is a circle.
  ///@param pts Array of points to draw [x0 y0 x1 y1 x2 y2 ...]
  ///@param offset Number of values to skip before starting to draw.
  ///@param count The number of values to process, after skipping offset of them. Since one point
  ///            uses two values, the number of "points" that are drawn is really (count >> 1).
  ///@param paint The paint used to draw the points
  ///
  /// This value must never be {@code null}.
  void drawPoints(
          jni.JniObject pts, int offset, int count, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawPoints,
          jni.JniType.voidType,
          [pts.reference, offset, count, paint.reference]).check();

  static final _id_drawPoints1 = jniAccessors.getMethodIDOf(
      _classRef, "drawPoints", "([FLandroid/graphics/Paint;)V");

  /// from: public void drawPoints(float[] pts, android.graphics.Paint paint)
  ///
  /// Helper for drawPoints() that assumes you want to draw the entire array
  ///@param pts This value must never be {@code null}.
  ///@param paint This value must never be {@code null}.
  void drawPoints1(jni.JniObject pts, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawPoints1,
          jni.JniType.voidType, [pts.reference, paint.reference]).check();

  static final _id_drawPosText = jniAccessors.getMethodIDOf(
      _classRef, "drawPosText", "([CII[FLandroid/graphics/Paint;)V");

  /// from: public void drawPosText(char[] text, int index, int count, float[] pos, android.graphics.Paint paint)
  ///
  /// Draw the text in the array, with each character's origin specified by the pos array.
  ///@param text The text to be drawn
  /// This value must never be {@code null}.
  ///@param index The index of the first character to draw
  ///@param count The number of characters to draw, starting from index.
  ///@param pos Array of [x,y] positions, used to position each character
  /// This value must never be {@code null}.
  ///@param paint The paint used for the text (e.g. color, size, style)
  /// This value must never be {@code null}.
  ///@deprecated This method does not support glyph composition and decomposition and should
  ///             therefore not be used to render complex scripts. It also doesn't handle
  ///             supplementary characters (eg emoji).
  void drawPosText(jni.JniObject text, int index, int count, jni.JniObject pos,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawPosText, jni.JniType.voidType, [
        text.reference,
        index,
        count,
        pos.reference,
        paint.reference
      ]).check();

  static final _id_drawPosText1 = jniAccessors.getMethodIDOf(_classRef,
      "drawPosText", "(Ljava/lang/String;[FLandroid/graphics/Paint;)V");

  /// from: public void drawPosText(java.lang.String text, float[] pos, android.graphics.Paint paint)
  ///
  /// Draw the text in the array, with each character's origin specified by the pos array.
  ///@param text The text to be drawn
  /// This value must never be {@code null}.
  ///@param pos Array of [x,y] positions, used to position each character
  /// This value must never be {@code null}.
  ///@param paint The paint used for the text (e.g. color, size, style)
  /// This value must never be {@code null}.
  ///@deprecated This method does not support glyph composition and decomposition and should
  ///             therefore not be used to render complex scripts. It also doesn't handle
  ///             supplementary characters (eg emoji).
  void drawPosText1(
          jni.JniString text, jni.JniObject pos, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawPosText1,
          jni.JniType.voidType,
          [text.reference, pos.reference, paint.reference]).check();

  static final _id_drawRect = jniAccessors.getMethodIDOf(_classRef, "drawRect",
      "(Landroid/graphics/RectF;Landroid/graphics/Paint;)V");

  /// from: public void drawRect(android.graphics.RectF rect, android.graphics.Paint paint)
  ///
  /// Draw the specified Rect using the specified paint. The rectangle will be filled or framed
  /// based on the Style in the paint.
  ///@param rect The rect to be drawn
  /// This value must never be {@code null}.
  ///@param paint The paint used to draw the rect
  ///
  /// This value must never be {@code null}.
  void drawRect(rectf_.RectF rect, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawRect,
          jni.JniType.voidType, [rect.reference, paint.reference]).check();

  static final _id_drawRect1 = jniAccessors.getMethodIDOf(_classRef, "drawRect",
      "(Landroid/graphics/Rect;Landroid/graphics/Paint;)V");

  /// from: public void drawRect(android.graphics.Rect r, android.graphics.Paint paint)
  ///
  /// Draw the specified Rect using the specified Paint. The rectangle will be filled or framed
  /// based on the Style in the paint.
  ///@param r The rectangle to be drawn.
  /// This value must never be {@code null}.
  ///@param paint The paint used to draw the rectangle
  ///
  /// This value must never be {@code null}.
  void drawRect1(rect_.Rect r, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_drawRect1,
          jni.JniType.voidType, [r.reference, paint.reference]).check();

  static final _id_drawRect2 = jniAccessors.getMethodIDOf(
      _classRef, "drawRect", "(FFFFLandroid/graphics/Paint;)V");

  /// from: public void drawRect(float left, float top, float right, float bottom, android.graphics.Paint paint)
  ///
  /// Draw the specified Rect using the specified paint. The rectangle will be filled or framed
  /// based on the Style in the paint.
  ///@param left The left side of the rectangle to be drawn
  ///@param top The top side of the rectangle to be drawn
  ///@param right The right side of the rectangle to be drawn
  ///@param bottom The bottom side of the rectangle to be drawn
  ///@param paint The paint used to draw the rect
  ///
  /// This value must never be {@code null}.
  void drawRect2(double left, double top, double right, double bottom,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawRect2,
          jni.JniType.voidType,
          [left, top, right, bottom, paint.reference]).check();

  static final _id_drawRGB =
      jniAccessors.getMethodIDOf(_classRef, "drawRGB", "(III)V");

  /// from: public void drawRGB(int r, int g, int b)
  ///
  /// Fill the entire canvas' bitmap (restricted to the current clip) with the specified RGB color,
  /// using srcover porterduff mode.
  ///@param r red component (0..255) of the color to draw onto the canvas
  ///@param g green component (0..255) of the color to draw onto the canvas
  ///@param b blue component (0..255) of the color to draw onto the canvas
  void drawRGB(int r, int g, int b) => jniAccessors.callMethodWithArgs(
      reference, _id_drawRGB, jni.JniType.voidType, [r, g, b]).check();

  static final _id_drawRoundRect = jniAccessors.getMethodIDOf(_classRef,
      "drawRoundRect", "(Landroid/graphics/RectF;FFLandroid/graphics/Paint;)V");

  /// from: public void drawRoundRect(android.graphics.RectF rect, float rx, float ry, android.graphics.Paint paint)
  ///
  /// Draw the specified round-rect using the specified paint. The roundrect will be filled or
  /// framed based on the Style in the paint.
  ///@param rect The rectangular bounds of the roundRect to be drawn
  /// This value must never be {@code null}.
  ///@param rx The x-radius of the oval used to round the corners
  ///@param ry The y-radius of the oval used to round the corners
  ///@param paint The paint used to draw the roundRect
  ///
  /// This value must never be {@code null}.
  void drawRoundRect(
          rectf_.RectF rect, double rx, double ry, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawRoundRect,
          jni.JniType.voidType,
          [rect.reference, rx, ry, paint.reference]).check();

  static final _id_drawRoundRect1 = jniAccessors.getMethodIDOf(
      _classRef, "drawRoundRect", "(FFFFFFLandroid/graphics/Paint;)V");

  /// from: public void drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, android.graphics.Paint paint)
  ///
  /// Draw the specified round-rect using the specified paint. The roundrect will be filled or
  /// framed based on the Style in the paint.
  ///@param rx The x-radius of the oval used to round the corners
  ///@param ry The y-radius of the oval used to round the corners
  ///@param paint The paint used to draw the roundRect
  ///
  /// This value must never be {@code null}.
  void drawRoundRect1(double left, double top, double right, double bottom,
          double rx, double ry, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawRoundRect1,
          jni.JniType.voidType,
          [left, top, right, bottom, rx, ry, paint.reference]).check();

  static final _id_drawText = jniAccessors.getMethodIDOf(
      _classRef, "drawText", "([CIIFFLandroid/graphics/Paint;)V");

  /// from: public void drawText(char[] text, int index, int count, float x, float y, android.graphics.Paint paint)
  ///
  /// Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted
  /// based on the Align setting in the paint.
  ///@param text The text to be drawn
  /// This value must never be {@code null}.
  ///@param x The x-coordinate of the origin of the text being drawn
  ///@param y The y-coordinate of the baseline of the text being drawn
  ///@param paint The paint used for the text (e.g. color, size, style)
  ///
  /// This value must never be {@code null}.
  void drawText(jni.JniObject text, int index, int count, double x, double y,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawText,
          jni.JniType.voidType,
          [text.reference, index, count, x, y, paint.reference]).check();

  static final _id_drawText1 = jniAccessors.getMethodIDOf(
      _classRef, "drawText", "(Ljava/lang/String;FFLandroid/graphics/Paint;)V");

  /// from: public void drawText(java.lang.String text, float x, float y, android.graphics.Paint paint)
  ///
  /// Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted
  /// based on the Align setting in the paint.
  ///@param text The text to be drawn
  /// This value must never be {@code null}.
  ///@param x The x-coordinate of the origin of the text being drawn
  ///@param y The y-coordinate of the baseline of the text being drawn
  ///@param paint The paint used for the text (e.g. color, size, style)
  ///
  /// This value must never be {@code null}.
  void drawText1(jni.JniString text, double x, double y, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawText1,
          jni.JniType.voidType,
          [text.reference, x, y, paint.reference]).check();

  static final _id_drawText2 = jniAccessors.getMethodIDOf(_classRef, "drawText",
      "(Ljava/lang/String;IIFFLandroid/graphics/Paint;)V");

  /// from: public void drawText(java.lang.String text, int start, int end, float x, float y, android.graphics.Paint paint)
  ///
  /// Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted
  /// based on the Align setting in the paint.
  ///@param text The text to be drawn
  /// This value must never be {@code null}.
  ///@param start The index of the first character in text to draw
  ///@param end (end - 1) is the index of the last character in text to draw
  ///@param x The x-coordinate of the origin of the text being drawn
  ///@param y The y-coordinate of the baseline of the text being drawn
  ///@param paint The paint used for the text (e.g. color, size, style)
  ///
  /// This value must never be {@code null}.
  void drawText2(jni.JniString text, int start, int end, double x, double y,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawText2,
          jni.JniType.voidType,
          [text.reference, start, end, x, y, paint.reference]).check();

  static final _id_drawText3 = jniAccessors.getMethodIDOf(_classRef, "drawText",
      "(Ljava/lang/CharSequence;IIFFLandroid/graphics/Paint;)V");

  /// from: public void drawText(java.lang.CharSequence text, int start, int end, float x, float y, android.graphics.Paint paint)
  ///
  /// Draw the specified range of text, specified by start/end, with its origin at (x,y), in the
  /// specified Paint. The origin is interpreted based on the Align setting in the Paint.
  ///@param text The text to be drawn
  /// This value must never be {@code null}.
  ///@param start The index of the first character in text to draw
  ///@param end (end - 1) is the index of the last character in text to draw
  ///@param x The x-coordinate of origin for where to draw the text
  ///@param y The y-coordinate of origin for where to draw the text
  ///@param paint The paint used for the text (e.g. color, size, style)
  ///
  /// This value must never be {@code null}.
  void drawText3(jni.JniObject text, int start, int end, double x, double y,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_drawText3,
          jni.JniType.voidType,
          [text.reference, start, end, x, y, paint.reference]).check();

  static final _id_drawTextOnPath = jniAccessors.getMethodIDOf(
      _classRef,
      "drawTextOnPath",
      "([CIILandroid/graphics/Path;FFLandroid/graphics/Paint;)V");

  /// from: public void drawTextOnPath(char[] text, int index, int count, android.graphics.Path path, float hOffset, float vOffset, android.graphics.Paint paint)
  ///
  /// Draw the text, with origin at (x,y), using the specified paint, along the specified path. The
  /// paint's Align setting determins where along the path to start the text.
  ///@param text The text to be drawn
  /// This value must never be {@code null}.
  ///@param path The path the text should follow for its baseline
  /// This value must never be {@code null}.
  ///@param hOffset The distance along the path to add to the text's starting position
  ///@param vOffset The distance above(-) or below(+) the path to position the text
  ///@param paint The paint used for the text (e.g. color, size, style)
  ///
  /// This value must never be {@code null}.
  void drawTextOnPath(jni.JniObject text, int index, int count, path_.Path path,
          double hOffset, double vOffset, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawTextOnPath, jni.JniType.voidType, [
        text.reference,
        index,
        count,
        path.reference,
        hOffset,
        vOffset,
        paint.reference
      ]).check();

  static final _id_drawTextOnPath1 = jniAccessors.getMethodIDOf(
      _classRef,
      "drawTextOnPath",
      "(Ljava/lang/String;Landroid/graphics/Path;FFLandroid/graphics/Paint;)V");

  /// from: public void drawTextOnPath(java.lang.String text, android.graphics.Path path, float hOffset, float vOffset, android.graphics.Paint paint)
  ///
  /// Draw the text, with origin at (x,y), using the specified paint, along the specified path. The
  /// paint's Align setting determins where along the path to start the text.
  ///@param text The text to be drawn
  /// This value must never be {@code null}.
  ///@param path The path the text should follow for its baseline
  /// This value must never be {@code null}.
  ///@param hOffset The distance along the path to add to the text's starting position
  ///@param vOffset The distance above(-) or below(+) the path to position the text
  ///@param paint The paint used for the text (e.g. color, size, style)
  ///
  /// This value must never be {@code null}.
  void drawTextOnPath1(jni.JniString text, path_.Path path, double hOffset,
          double vOffset, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawTextOnPath1, jni.JniType.voidType, [
        text.reference,
        path.reference,
        hOffset,
        vOffset,
        paint.reference
      ]).check();

  static final _id_drawTextRun = jniAccessors.getMethodIDOf(
      _classRef, "drawTextRun", "([CIIIIFFZLandroid/graphics/Paint;)V");

  /// from: public void drawTextRun(char[] text, int index, int count, int contextIndex, int contextCount, float x, float y, boolean isRtl, android.graphics.Paint paint)
  ///
  /// Draw a run of text, all in a single direction, with optional context for complex text
  /// shaping.
  ///
  /// See \#drawTextRun(CharSequence, int, int, int, int, float, float, boolean, Paint) for
  /// more details. This method uses a character array rather than CharSequence to represent the
  /// string. Also, to be consistent with the pattern established in \#drawText, in this
  /// method {@code count} and {@code contextCount} are used rather than offsets of the end
  /// position; {@code count = end - start, contextCount = contextEnd -
  /// contextStart}.
  ///@param text the text to render
  /// This value must never be {@code null}.
  ///@param index the start of the text to render
  ///@param count the count of chars to render
  ///@param contextIndex the start of the context for shaping. Must be no greater than index.
  ///@param contextCount the number of characters in the context for shaping. contexIndex +
  ///            contextCount must be no less than index + count.
  ///@param x the x position at which to draw the text
  ///@param y the y position at which to draw the text
  ///@param isRtl whether the run is in RTL direction
  ///@param paint the paint
  ///
  /// This value must never be {@code null}.
  void drawTextRun(
          jni.JniObject text,
          int index,
          int count,
          int contextIndex,
          int contextCount,
          double x,
          double y,
          bool isRtl,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawTextRun, jni.JniType.voidType, [
        text.reference,
        index,
        count,
        contextIndex,
        contextCount,
        x,
        y,
        isRtl,
        paint.reference
      ]).check();

  static final _id_drawTextRun1 = jniAccessors.getMethodIDOf(
      _classRef,
      "drawTextRun",
      "(Ljava/lang/CharSequence;IIIIFFZLandroid/graphics/Paint;)V");

  /// from: public void drawTextRun(java.lang.CharSequence text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, android.graphics.Paint paint)
  ///
  /// Draw a run of text, all in a single direction, with optional context for complex text
  /// shaping.
  ///
  /// The run of text includes the characters from {@code start} to {@code end} in the text. In
  /// addition, the range {@code contextStart} to {@code contextEnd} is used as context for the
  /// purpose of complex text shaping, such as Arabic text potentially shaped differently based on
  /// the text next to it.
  ///
  /// All text outside the range {@code contextStart..contextEnd} is ignored. The text between
  /// {@code start} and {@code end} will be laid out and drawn.
  ///
  /// The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is
  /// suitable only for runs of a single direction. Alignment of the text is as determined by the
  /// Paint's TextAlign value. Further, {@code 0 <= contextStart <= start <= end <= contextEnd
  /// <= text.length} must hold on entry.
  ///
  /// Also see android.graphics.Paint\#getRunAdvance for a corresponding method to measure
  /// the text; the advance width of the text drawn matches the value obtained from that method.
  ///@param text the text to render
  /// This value must never be {@code null}.
  ///@param start the start of the text to render. Data before this position can be used for
  ///            shaping context.
  ///@param end the end of the text to render. Data at or after this position can be used for
  ///            shaping context.
  ///@param contextStart the index of the start of the shaping context
  ///@param contextEnd the index of the end of the shaping context
  ///@param x the x position at which to draw the text
  ///@param y the y position at which to draw the text
  ///@param isRtl whether the run is in RTL direction
  ///@param paint the paint
  /// This value must never be {@code null}.
  ///@see \#drawTextRun(char[], int, int, int, int, float, float, boolean, Paint)
  void drawTextRun1(jni.JniObject text, int start, int end, int contextStart,
          int contextEnd, double x, double y, bool isRtl, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawTextRun1, jni.JniType.voidType, [
        text.reference,
        start,
        end,
        contextStart,
        contextEnd,
        x,
        y,
        isRtl,
        paint.reference
      ]).check();

  static final _id_drawVertices = jniAccessors.getMethodIDOf(
      _classRef,
      "drawVertices",
      "(Landroid/graphics/Canvas\$VertexMode;I[FI[FI[II[SIILandroid/graphics/Paint;)V");

  /// from: public void drawVertices(android.graphics.Canvas.VertexMode mode, int vertexCount, float[] verts, int vertOffset, float[] texs, int texOffset, int[] colors, int colorOffset, short[] indices, int indexOffset, int indexCount, android.graphics.Paint paint)
  ///
  /// Draw the array of vertices, interpreted as triangles (based on mode). The verts array is
  /// required, and specifies the x,y pairs for each vertex. If texs is non-null, then it is used
  /// to specify the coordinate in shader coordinates to use at each vertex (the paint must have a
  /// shader in this case). If there is no texs array, but there is a color array, then each color
  /// is interpolated across its corresponding triangle in a gradient. If both texs and colors
  /// arrays are present, then they behave as before, but the resulting color at each pixels is the
  /// result of multiplying the colors from the shader and the color-gradient together. The indices
  /// array is optional, but if it is present, then it is used to specify the index of each
  /// triangle, rather than just walking through the arrays in order.
  ///@param mode How to interpret the array of vertices
  /// This value must never be {@code null}.
  ///@param vertexCount The number of values in the vertices array (and corresponding texs and
  ///            colors arrays if non-null). Each logical vertex is two values (x, y), vertexCount
  ///            must be a multiple of 2.
  ///@param verts Array of vertices for the mesh
  /// This value must never be {@code null}.
  ///@param vertOffset Number of values in the verts to skip before drawing.
  ///@param texs May be null. If not null, specifies the coordinates to sample into the current
  ///            shader (e.g. bitmap tile or gradient)
  /// This value may be {@code null}.
  ///@param texOffset Number of values in texs to skip before drawing.
  ///@param colors May be null. If not null, specifies a color for each vertex, to be interpolated
  ///            across the triangle.
  /// This value may be {@code null}.
  ///@param colorOffset Number of values in colors to skip before drawing.
  ///@param indices If not null, array of indices to reference into the vertex (texs, colors)
  ///            array.
  /// This value may be {@code null}.
  ///@param indexCount number of entries in the indices array (if not null).
  ///@param paint Specifies the shader to use if the texs array is non-null.
  ///
  /// This value must never be {@code null}.
  void drawVertices(
          Canvas_VertexMode mode,
          int vertexCount,
          jni.JniObject verts,
          int vertOffset,
          jni.JniObject texs,
          int texOffset,
          jni.JniObject colors,
          int colorOffset,
          jni.JniObject indices,
          int indexOffset,
          int indexCount,
          paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawVertices, jni.JniType.voidType, [
        mode.reference,
        vertexCount,
        verts.reference,
        vertOffset,
        texs.reference,
        texOffset,
        colors.reference,
        colorOffset,
        indices.reference,
        indexOffset,
        indexCount,
        paint.reference
      ]).check();
}

/// from: android.graphics.Canvas$VertexMode
class Canvas_VertexMode extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Canvas\$VertexMode");
  Canvas_VertexMode.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Canvas\$VertexMode;");

  /// from: static public android.graphics.Canvas.VertexMode[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Canvas\$VertexMode;");

  /// from: static public android.graphics.Canvas.VertexMode valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Canvas_VertexMode valueOf(jni.JniString name) =>
      Canvas_VertexMode.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Canvas_VertexMode()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.graphics.Canvas$EdgeType
///
/// Constant values used as parameters to {@code quickReject()} calls. These values
/// specify how much space around the shape should be accounted for, depending on whether
/// the shaped area is antialiased or not.
///@see \#quickReject(float, float, float, float, EdgeType)
///@see \#quickReject(Path, EdgeType)
///@see \#quickReject(RectF, EdgeType)
class Canvas_EdgeType extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Canvas\$EdgeType");
  Canvas_EdgeType.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Canvas\$EdgeType;");

  /// from: static public android.graphics.Canvas.EdgeType[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Canvas\$EdgeType;");

  /// from: static public android.graphics.Canvas.EdgeType valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Canvas_EdgeType valueOf(jni.JniString name) =>
      Canvas_EdgeType.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Canvas_EdgeType()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
