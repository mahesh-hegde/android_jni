// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Bitmap.dart" as bitmap_;

import "Paint.dart" as paint_;

import "Canvas.dart" as canvas_;

import "RectF.dart" as rectf_;

import "Rect.dart" as rect_;

import "Region.dart" as region_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.NinePatch
///
/// The NinePatch class permits drawing a bitmap in nine or more sections.
/// Essentially, it allows the creation of custom graphics that will scale the
/// way that you define, when content added within the image exceeds the normal
/// bounds of the graphic. For a thorough explanation of a NinePatch image,
/// read the discussion in the
/// <a href="{@docRoot}guide/topics/graphics/2d-graphics.html\#nine-patch">2D
/// Graphics</a> document.
///
/// The <a href="{@docRoot}guide/developing/tools/draw9patch.html">Draw 9-Patch</a>
/// tool offers an extremely handy way to create your NinePatch images,
/// using a WYSIWYG graphics editor.
///
///
class NinePatch extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/NinePatch");
  NinePatch.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Bitmap;[B)V");

  /// from: public void <init>(android.graphics.Bitmap bitmap, byte[] chunk)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable projection from a bitmap to nine patches.
  ///@param bitmap The bitmap describing the patches.
  ///@param chunk The 9-patch data chunk describing how the underlying bitmap
  ///              is split apart and drawn.
  NinePatch(bitmap_.Bitmap bitmap, jni.JniObject chunk)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [bitmap.reference, chunk.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Bitmap;[BLjava/lang/String;)V");

  /// from: public void <init>(android.graphics.Bitmap bitmap, byte[] chunk, java.lang.String srcName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable projection from a bitmap to nine patches.
  ///@param bitmap The bitmap describing the patches.
  ///@param chunk The 9-patch data chunk describing how the underlying
  ///              bitmap is split apart and drawn.
  ///@param srcName The name of the source for the bitmap. Might be null.
  NinePatch.ctor1(
      bitmap_.Bitmap bitmap, jni.JniObject chunk, jni.JniString srcName)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [bitmap.reference, chunk.reference, srcName.reference]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of this NinePatch object if one was specified
  /// when calling the constructor.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_getPaint = jniAccessors.getMethodIDOf(
      _classRef, "getPaint", "()Landroid/graphics/Paint;");

  /// from: public android.graphics.Paint getPaint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the paint used to draw this NinePatch. The paint can be null.
  ///@see \#setPaint(Paint)
  ///@see \#draw(Canvas, Rect)
  ///@see \#draw(Canvas, RectF)
  paint_.Paint getPaint() =>
      paint_.Paint.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPaint, jni.JniType.objectType, []).object);

  static final _id_setPaint = jniAccessors.getMethodIDOf(
      _classRef, "setPaint", "(Landroid/graphics/Paint;)V");

  /// from: public void setPaint(android.graphics.Paint p)
  ///
  /// Sets the paint to use when drawing the NinePatch.
  ///@param p The paint that will be used to draw this NinePatch.
  ///@see \#getPaint()
  ///@see \#draw(Canvas, Rect)
  ///@see \#draw(Canvas, RectF)
  void setPaint(paint_.Paint p) => jniAccessors.callMethodWithArgs(
      reference, _id_setPaint, jni.JniType.voidType, [p.reference]).check();

  static final _id_getBitmap = jniAccessors.getMethodIDOf(
      _classRef, "getBitmap", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getBitmap()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the bitmap used to draw this NinePatch.
  bitmap_.Bitmap getBitmap() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBitmap, jni.JniType.objectType, []).object);

  static final _id_draw = jniAccessors.getMethodIDOf(_classRef, "draw",
      "(Landroid/graphics/Canvas;Landroid/graphics/RectF;)V");

  /// from: public void draw(android.graphics.Canvas canvas, android.graphics.RectF location)
  ///
  /// Draws the NinePatch. This method will use the paint returned by \#getPaint().
  ///@param canvas A container for the current matrix and clip used to draw the NinePatch.
  ///@param location Where to draw the NinePatch.
  void draw(canvas_.Canvas canvas, rectf_.RectF location) =>
      jniAccessors.callMethodWithArgs(reference, _id_draw, jni.JniType.voidType,
          [canvas.reference, location.reference]).check();

  static final _id_draw1 = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;Landroid/graphics/Rect;)V");

  /// from: public void draw(android.graphics.Canvas canvas, android.graphics.Rect location)
  ///
  /// Draws the NinePatch. This method will use the paint returned by \#getPaint().
  ///@param canvas A container for the current matrix and clip used to draw the NinePatch.
  ///@param location Where to draw the NinePatch.
  void draw1(canvas_.Canvas canvas, rect_.Rect location) =>
      jniAccessors.callMethodWithArgs(reference, _id_draw1,
          jni.JniType.voidType, [canvas.reference, location.reference]).check();

  static final _id_draw2 = jniAccessors.getMethodIDOf(_classRef, "draw",
      "(Landroid/graphics/Canvas;Landroid/graphics/Rect;Landroid/graphics/Paint;)V");

  /// from: public void draw(android.graphics.Canvas canvas, android.graphics.Rect location, android.graphics.Paint paint)
  ///
  /// Draws the NinePatch. This method will ignore the paint returned
  /// by \#getPaint() and use the specified paint instead.
  ///@param canvas A container for the current matrix and clip used to draw the NinePatch.
  ///@param location Where to draw the NinePatch.
  ///@param paint The Paint to draw through.
  void draw2(canvas_.Canvas canvas, rect_.Rect location, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_draw2,
          jni.JniType.voidType,
          [canvas.reference, location.reference, paint.reference]).check();

  static final _id_getDensity =
      jniAccessors.getMethodIDOf(_classRef, "getDensity", "()I");

  /// from: public int getDensity()
  ///
  /// Return the underlying bitmap's density, as per
  /// Bitmap\#getDensity() Bitmap.getDensity().
  int getDensity() => jniAccessors.callMethodWithArgs(
      reference, _id_getDensity, jni.JniType.intType, []).integer;

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Returns the intrinsic width, in pixels, of this NinePatch. This is equivalent
  /// to querying the width of the underlying bitmap returned by \#getBitmap().
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Returns the intrinsic height, in pixels, of this NinePatch. This is equivalent
  /// to querying the height of the underlying bitmap returned by \#getBitmap().
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_hasAlpha =
      jniAccessors.getMethodIDOf(_classRef, "hasAlpha", "()Z");

  /// from: public final boolean hasAlpha()
  ///
  /// Indicates whether this NinePatch contains transparent or translucent pixels.
  /// This is equivalent to calling <code>getBitmap().hasAlpha()</code> on this
  /// NinePatch.
  bool hasAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_hasAlpha, jni.JniType.booleanType, []).boolean;

  static final _id_getTransparentRegion = jniAccessors.getMethodIDOf(
      _classRef,
      "getTransparentRegion",
      "(Landroid/graphics/Rect;)Landroid/graphics/Region;");

  /// from: public final android.graphics.Region getTransparentRegion(android.graphics.Rect bounds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Region representing the parts of the NinePatch that are
  /// completely transparent.
  ///@param bounds The location and size of the NinePatch.
  ///@return null if the NinePatch has no transparent region to
  /// report, else a Region holding the parts of the specified bounds
  /// that are transparent.
  region_.Region getTransparentRegion(rect_.Rect bounds) =>
      region_.Region.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTransparentRegion,
          jni.JniType.objectType,
          [bounds.reference]).object);

  static final _id_isNinePatchChunk =
      jniAccessors.getStaticMethodIDOf(_classRef, "isNinePatchChunk", "([B)Z");

  /// from: static public native boolean isNinePatchChunk(byte[] chunk)
  ///
  /// Verifies that the specified byte array is a valid 9-patch data chunk.
  ///@param chunk A byte array representing a 9-patch data chunk.
  ///@return True if the specified byte array represents a 9-patch data chunk,
  ///         false otherwise.
  static bool isNinePatchChunk(jni.JniObject chunk) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isNinePatchChunk,
          jni.JniType.booleanType, [chunk.reference]).boolean;
}
