// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Canvas.dart" as canvas_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Picture
///
/// A Picture records drawing calls (via the canvas returned by beginRecording)
/// and can then play them back into Canvas (via Picture\#draw(Canvas) or
/// Canvas\#drawPicture(Picture)).For most content (e.g. text, lines, rectangles),
/// drawing a sequence from a picture can be faster than the equivalent API
/// calls, since the picture performs its playback without incurring any
/// method-call overhead.
///
/// <p class="note"><strong>Note:</strong> Prior to API level 23 a picture cannot
/// be replayed on a hardware accelerated canvas.
///
class Picture extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Picture");
  Picture.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an empty picture that is ready to record.
  Picture()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Picture;)V");

  /// from: public void <init>(android.graphics.Picture src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a picture by making a copy of what has already been recorded in
  /// src. The contents of src are unchanged, and if src changes later, those
  /// changes will not be reflected in this picture.
  Picture.ctor1(Picture src)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [src.reference]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_beginRecording = jniAccessors.getMethodIDOf(
      _classRef, "beginRecording", "(II)Landroid/graphics/Canvas;");

  /// from: public android.graphics.Canvas beginRecording(int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// To record a picture, call beginRecording() and then draw into the Canvas
  /// that is returned. Nothing we appear on screen, but all of the draw
  /// commands (e.g. Canvas\#drawRect(Rect, Paint)) will be recorded.
  /// To stop recording, call endRecording(). After endRecording() the Canvas
  /// that was returned must no longer be used, and nothing should be drawn
  /// into it.
  canvas_.Canvas beginRecording(int width, int height) =>
      canvas_.Canvas.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_beginRecording, jni.JniType.objectType, [width, height]).object);

  static final _id_endRecording =
      jniAccessors.getMethodIDOf(_classRef, "endRecording", "()V");

  /// from: public void endRecording()
  ///
  /// Call endRecording when the picture is built. After this call, the picture
  /// may be drawn, but the canvas that was returned by beginRecording must not
  /// be used anymore. This is automatically called if Picture\#draw
  /// or Canvas\#drawPicture(Picture) is called.
  void endRecording() => jniAccessors.callMethodWithArgs(
      reference, _id_endRecording, jni.JniType.voidType, []).check();

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Get the width of the picture as passed to beginRecording. This
  /// does not reflect (per se) the content of the picture.
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Get the height of the picture as passed to beginRecording. This
  /// does not reflect (per se) the content of the picture.
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_requiresHardwareAcceleration = jniAccessors.getMethodIDOf(
      _classRef, "requiresHardwareAcceleration", "()Z");

  /// from: public boolean requiresHardwareAcceleration()
  ///
  /// Indicates whether or not this Picture contains recorded commands that only work when
  /// drawn to a hardware-accelerated canvas. If this returns true then this Picture can only
  /// be drawn to another Picture or to a Canvas where canvas.isHardwareAccelerated() is true.
  ///
  /// Note this value is only updated after recording has finished by a call to
  /// \#endRecording(). Prior to that it will be the default value of false.
  ///@return true if the Picture can only be drawn to a hardware-accelerated canvas,
  ///         false otherwise.
  bool requiresHardwareAcceleration() => jniAccessors.callMethodWithArgs(
      reference,
      _id_requiresHardwareAcceleration,
      jni.JniType.booleanType, []).boolean;

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  ///
  /// Draw this picture on the canvas.
  ///
  /// Prior to android.os.Build.VERSION_CODES\#LOLLIPOP, this call could
  /// have the side effect of changing the matrix and clip of the canvas
  /// if this picture had imbalanced saves/restores.
  ///
  ///
  /// <strong>Note:</strong> This forces the picture to internally call
  /// Picture\#endRecording() in order to prepare for playback.
  ///@param canvas The picture is drawn to this canvas
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_createFromStream = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromStream",
      "(Ljava/io/InputStream;)Landroid/graphics/Picture;");

  /// from: static public android.graphics.Picture createFromStream(java.io.InputStream stream)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new picture (already recorded) from the data in the stream. This
  /// data was generated by a previous call to writeToStream(). Pictures that
  /// have been persisted across device restarts are not guaranteed to decode
  /// properly and are highly discouraged.
  ///@see \#writeToStream(java.io.OutputStream)
  ///@deprecated The recommended alternative is to not use writeToStream and
  /// instead draw the picture into a Bitmap from which you can persist it as
  /// raw or compressed pixels.
  static Picture createFromStream(jni.JniObject stream) =>
      Picture.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromStream,
          jni.JniType.objectType,
          [stream.reference]).object);

  static final _id_writeToStream = jniAccessors.getMethodIDOf(
      _classRef, "writeToStream", "(Ljava/io/OutputStream;)V");

  /// from: public void writeToStream(java.io.OutputStream stream)
  ///
  /// Write the picture contents to a stream. The data can be used to recreate
  /// the picture in this or another process by calling createFromStream(...)
  /// The resulting stream is NOT to be persisted across device restarts as
  /// there is no guarantee that the Picture can be successfully reconstructed.
  ///@see \#createFromStream(java.io.InputStream)
  ///@deprecated The recommended alternative is to draw the picture into a
  /// Bitmap from which you can persist it as raw or compressed pixels.
  void writeToStream(jni.JniObject stream) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeToStream,
      jni.JniType.voidType,
      [stream.reference]).check();
}
