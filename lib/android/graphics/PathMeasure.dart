// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Path.dart" as path_;

import "Matrix.dart" as matrix_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.PathMeasure
class PathMeasure extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/PathMeasure");
  PathMeasure.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int POSITION_MATRIX_FLAG
  static const POSITION_MATRIX_FLAG = 1;

  /// from: static public final int TANGENT_MATRIX_FLAG
  static const TANGENT_MATRIX_FLAG = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty PathMeasure object. To uses this to measure the length
  /// of a path, and/or to find the position and tangent along it, call
  /// setPath.
  ///
  /// Note that once a path is associated with the measure object, it is
  /// undefined if the path is subsequently modified and the the measure object
  /// is used. If the path is modified, you must call setPath with the path.
  PathMeasure()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Path;Z)V");

  /// from: public void <init>(android.graphics.Path path, boolean forceClosed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a PathMeasure object associated with the specified path object
  /// (already created and specified). The measure object can now return the
  /// path's length, and the position and tangent of any position along the
  /// path.
  ///
  /// Note that once a path is associated with the measure object, it is
  /// undefined if the path is subsequently modified and the the measure object
  /// is used. If the path is modified, you must call setPath with the path.
  ///@param path The path that will be measured by this object
  ///@param forceClosed If true, then the path will be considered as "closed"
  ///        even if its contour was not explicitly closed.
  PathMeasure.ctor1(path_.Path path, bool forceClosed)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [path.reference, forceClosed]).object);

  static final _id_setPath = jniAccessors.getMethodIDOf(
      _classRef, "setPath", "(Landroid/graphics/Path;Z)V");

  /// from: public void setPath(android.graphics.Path path, boolean forceClosed)
  ///
  /// Assign a new path, or null to have none.
  void setPath(path_.Path path, bool forceClosed) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPath,
          jni.JniType.voidType, [path.reference, forceClosed]).check();

  static final _id_getLength =
      jniAccessors.getMethodIDOf(_classRef, "getLength", "()F");

  /// from: public float getLength()
  ///
  /// Return the total length of the current contour, or 0 if no path is
  /// associated with this measure object.
  double getLength() => jniAccessors.callMethodWithArgs(
      reference, _id_getLength, jni.JniType.floatType, []).float;

  static final _id_getPosTan =
      jniAccessors.getMethodIDOf(_classRef, "getPosTan", "(F[F[F)Z");

  /// from: public boolean getPosTan(float distance, float[] pos, float[] tan)
  ///
  /// Pins distance to 0 <= distance <= getLength(), and then computes the
  /// corresponding position and tangent. Returns false if there is no path,
  /// or a zero-length path was specified, in which case position and tangent
  /// are unchanged.
  ///@param distance The distance along the current contour to sample
  ///@param pos If not null, returns the sampled position (x==[0], y==[1])
  ///@param tan If not null, returns the sampled tangent (x==[0], y==[1])
  ///@return false if there was no path associated with this measure object
  bool getPosTan(double distance, jni.JniObject pos, jni.JniObject tan) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPosTan,
          jni.JniType.booleanType,
          [distance, pos.reference, tan.reference]).boolean;

  static final _id_getMatrix = jniAccessors.getMethodIDOf(
      _classRef, "getMatrix", "(FLandroid/graphics/Matrix;I)Z");

  /// from: public boolean getMatrix(float distance, android.graphics.Matrix matrix, int flags)
  ///
  /// Pins distance to 0 <= distance <= getLength(), and then computes the
  /// corresponding matrix. Returns false if there is no path, or a zero-length
  /// path was specified, in which case matrix is unchanged.
  ///@param distance The distance along the associated path
  ///@param matrix Allocated by the caller, this is set to the transformation
  ///        associated with the position and tangent at the specified distance
  ///@param flags Specified what aspects should be returned in the matrix.
  bool getMatrix(double distance, matrix_.Matrix matrix, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_getMatrix,
          jni.JniType.booleanType, [distance, matrix.reference, flags]).boolean;

  static final _id_getSegment = jniAccessors.getMethodIDOf(
      _classRef, "getSegment", "(FFLandroid/graphics/Path;Z)Z");

  /// from: public boolean getSegment(float startD, float stopD, android.graphics.Path dst, boolean startWithMoveTo)
  ///
  /// Given a start and stop distance, return in dst the intervening
  /// segment(s). If the segment is zero-length, return false, else return
  /// true. startD and stopD are pinned to legal values (0..getLength()).
  /// If startD >= stopD then return false (and leave dst untouched).
  /// Begin the segment with a moveTo if startWithMoveTo is true.
  ///
  /// On android.os.Build.VERSION_CODES\#KITKAT and earlier
  /// releases, the resulting path may not display on a hardware-accelerated
  /// Canvas. A simple workaround is to add a single operation to this path,
  /// such as <code>dst.rLineTo(0, 0)</code>.
  ///
  bool getSegment(
          double startD, double stopD, path_.Path dst, bool startWithMoveTo) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getSegment,
          jni.JniType.booleanType,
          [startD, stopD, dst.reference, startWithMoveTo]).boolean;

  static final _id_isClosed =
      jniAccessors.getMethodIDOf(_classRef, "isClosed", "()Z");

  /// from: public boolean isClosed()
  ///
  /// Return true if the current contour is closed()
  bool isClosed() => jniAccessors.callMethodWithArgs(
      reference, _id_isClosed, jni.JniType.booleanType, []).boolean;

  static final _id_nextContour =
      jniAccessors.getMethodIDOf(_classRef, "nextContour", "()Z");

  /// from: public boolean nextContour()
  ///
  /// Move to the next contour in the path. Return true if one exists, or
  /// false if we're done with the path.
  bool nextContour() => jniAccessors.callMethodWithArgs(
      reference, _id_nextContour, jni.JniType.booleanType, []).boolean;

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
