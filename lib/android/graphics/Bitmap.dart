// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "Matrix.dart" as matrix_;

import "../util/DisplayMetrics.dart" as displaymetrics_;

import "ColorSpace.dart" as colorspace_;

import "Picture.dart" as picture_;

import "Canvas.dart" as canvas_;

import "../os/Parcel.dart" as parcel_;

import "Paint.dart" as paint_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Bitmap
class Bitmap extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Bitmap");
  Bitmap.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.graphics.Bitmap> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int DENSITY_NONE
  ///
  /// Indicates that the bitmap was created for an unknown pixel density.
  ///@see Bitmap\#getDensity()
  ///@see Bitmap\#setDensity(int)
  static const DENSITY_NONE = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Bitmap()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getDensity =
      jniAccessors.getMethodIDOf(_classRef, "getDensity", "()I");

  /// from: public int getDensity()
  ///
  /// Returns the density for this bitmap.
  ///
  ///
  /// The default density is the same density as the current display,
  /// unless the current application does not support different screen
  /// densities in which case it is
  /// android.util.DisplayMetrics\#DENSITY_DEFAULT.  Note that
  /// compatibility mode is determined by the application that was initially
  /// loaded into a process -- applications that share the same process should
  /// all have the same compatibility, or ensure they explicitly set the
  /// density of their bitmaps appropriately.
  ///
  ///@return A scaling factor of the default density or \#DENSITY_NONE
  ///         if the scaling factor is unknown.
  ///@see \#setDensity(int)
  ///@see android.util.DisplayMetrics\#DENSITY_DEFAULT
  ///@see android.util.DisplayMetrics\#densityDpi
  ///@see \#DENSITY_NONE
  int getDensity() => jniAccessors.callMethodWithArgs(
      reference, _id_getDensity, jni.JniType.intType, []).integer;

  static final _id_setDensity =
      jniAccessors.getMethodIDOf(_classRef, "setDensity", "(I)V");

  /// from: public void setDensity(int density)
  ///
  /// Specifies the density for this bitmap.  When the bitmap is
  /// drawn to a Canvas that also has a density, it will be scaled
  /// appropriately.
  ///
  ///@param density The density scaling factor to use with this bitmap or
  ///        \#DENSITY_NONE if the density is unknown.
  ///@see \#getDensity()
  ///@see android.util.DisplayMetrics\#DENSITY_DEFAULT
  ///@see android.util.DisplayMetrics\#densityDpi
  ///@see \#DENSITY_NONE
  void setDensity(int density) => jniAccessors.callMethodWithArgs(
      reference, _id_setDensity, jni.JniType.voidType, [density]).check();

  static final _id_reconfigure = jniAccessors.getMethodIDOf(
      _classRef, "reconfigure", "(IILandroid/graphics/Bitmap\$Config;)V");

  /// from: public void reconfigure(int width, int height, android.graphics.Bitmap.Config config)
  ///
  /// Modifies the bitmap to have a specified width, height, and Config, without affecting the underlying allocation backing the bitmap.
  /// Bitmap pixel data is not re-initialized for the new configuration.
  ///
  ///
  /// This method can be used to avoid allocating a new bitmap, instead
  /// reusing an existing bitmap's allocation for a new configuration of equal
  /// or lesser size. If the Bitmap's allocation isn't large enough to support
  /// the new configuration, an IllegalArgumentException will be thrown and the
  /// bitmap will not be modified.
  ///
  ///
  /// The result of \#getByteCount() will reflect the new configuration,
  /// while \#getAllocationByteCount() will reflect that of the initial
  /// configuration.
  ///
  ///
  /// Note: This may change this result of hasAlpha(). When converting to 565,
  /// the new bitmap will always be considered opaque. When converting from 565,
  /// the new bitmap will be considered non-opaque, and will respect the value
  /// set by setPremultiplied().
  ///
  ///
  /// WARNING: This method should NOT be called on a bitmap currently in use
  /// by the view system, Canvas, or the AndroidBitmap NDK API. It does not
  /// make guarantees about how the underlying pixel buffer is remapped to the
  /// new config, just that the allocation is reused. Additionally, the view
  /// system does not account for bitmap properties being modifying during use,
  /// e.g. while attached to drawables.
  ///
  ///
  /// In order to safely ensure that a Bitmap is no longer in use by the
  /// View system it is necessary to wait for a draw pass to occur after
  /// invalidate()'ing any view that had previously drawn the Bitmap in the last
  /// draw pass due to hardware acceleration's caching of draw commands. As
  /// an example, here is how this can be done for an ImageView:
  /// <pre class="prettyprint">
  ///      ImageView myImageView = ...;
  ///      final Bitmap myBitmap = ...;
  ///      myImageView.setImageDrawable(null);
  ///      myImageView.post(new Runnable() {
  ///          public void run() {
  ///              // myBitmap is now no longer in use by the ImageView
  ///              // and can be safely reconfigured.
  ///              myBitmap.reconfigure(...);
  ///          }
  ///      });
  /// </pre>
  ///
  ///@see \#setWidth(int)
  ///@see \#setHeight(int)
  ///@see \#setConfig(Config)
  void reconfigure(int width, int height, Bitmap_Config config) =>
      jniAccessors.callMethodWithArgs(reference, _id_reconfigure,
          jni.JniType.voidType, [width, height, config.reference]).check();

  static final _id_setWidth =
      jniAccessors.getMethodIDOf(_classRef, "setWidth", "(I)V");

  /// from: public void setWidth(int width)
  ///
  /// Convenience method for calling \#reconfigure(int, int, Config)
  /// with the current height and config.
  ///
  ///
  /// WARNING: this method should not be used on bitmaps currently used by
  /// the view system, see \#reconfigure(int, int, Config) for more
  /// details.
  ///
  ///@see \#reconfigure(int, int, Config)
  ///@see \#setHeight(int)
  ///@see \#setConfig(Config)
  void setWidth(int width) => jniAccessors.callMethodWithArgs(
      reference, _id_setWidth, jni.JniType.voidType, [width]).check();

  static final _id_setHeight =
      jniAccessors.getMethodIDOf(_classRef, "setHeight", "(I)V");

  /// from: public void setHeight(int height)
  ///
  /// Convenience method for calling \#reconfigure(int, int, Config)
  /// with the current width and config.
  ///
  ///
  /// WARNING: this method should not be used on bitmaps currently used by
  /// the view system, see \#reconfigure(int, int, Config) for more
  /// details.
  ///
  ///@see \#reconfigure(int, int, Config)
  ///@see \#setWidth(int)
  ///@see \#setConfig(Config)
  void setHeight(int height) => jniAccessors.callMethodWithArgs(
      reference, _id_setHeight, jni.JniType.voidType, [height]).check();

  static final _id_setConfig = jniAccessors.getMethodIDOf(
      _classRef, "setConfig", "(Landroid/graphics/Bitmap\$Config;)V");

  /// from: public void setConfig(android.graphics.Bitmap.Config config)
  ///
  /// Convenience method for calling \#reconfigure(int, int, Config)
  /// with the current height and width.
  ///
  ///
  /// WARNING: this method should not be used on bitmaps currently used by
  /// the view system, see \#reconfigure(int, int, Config) for more
  /// details.
  ///
  ///@see \#reconfigure(int, int, Config)
  ///@see \#setWidth(int)
  ///@see \#setHeight(int)
  void setConfig(Bitmap_Config config) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setConfig,
      jni.JniType.voidType,
      [config.reference]).check();

  static final _id_recycle =
      jniAccessors.getMethodIDOf(_classRef, "recycle", "()V");

  /// from: public void recycle()
  ///
  /// Free the native object associated with this bitmap, and clear the
  /// reference to the pixel data. This will not free the pixel data synchronously;
  /// it simply allows it to be garbage collected if there are no other references.
  /// The bitmap is marked as "dead", meaning it will throw an exception if
  /// getPixels() or setPixels() is called, and will draw nothing. This operation
  /// cannot be reversed, so it should only be called if you are sure there are no
  /// further uses for the bitmap. This is an advanced call, and normally need
  /// not be called, since the normal GC process will free up this memory when
  /// there are no more references to this bitmap.
  void recycle() => jniAccessors.callMethodWithArgs(
      reference, _id_recycle, jni.JniType.voidType, []).check();

  static final _id_isRecycled =
      jniAccessors.getMethodIDOf(_classRef, "isRecycled", "()Z");

  /// from: public boolean isRecycled()
  ///
  /// Returns true if this bitmap has been recycled. If so, then it is an error
  /// to try to access its pixels, and the bitmap will not draw.
  ///@return true if the bitmap has been recycled
  bool isRecycled() => jniAccessors.callMethodWithArgs(
      reference, _id_isRecycled, jni.JniType.booleanType, []).boolean;

  static final _id_getGenerationId =
      jniAccessors.getMethodIDOf(_classRef, "getGenerationId", "()I");

  /// from: public int getGenerationId()
  ///
  /// Returns the generation ID of this bitmap. The generation ID changes
  /// whenever the bitmap is modified. This can be used as an efficient way to
  /// check if a bitmap has changed.
  ///@return The current generation ID for this bitmap.
  int getGenerationId() => jniAccessors.callMethodWithArgs(
      reference, _id_getGenerationId, jni.JniType.intType, []).integer;

  static final _id_copyPixelsToBuffer = jniAccessors.getMethodIDOf(
      _classRef, "copyPixelsToBuffer", "(Ljava/nio/Buffer;)V");

  /// from: public void copyPixelsToBuffer(java.nio.Buffer dst)
  ///
  /// Copy the bitmap's pixels into the specified buffer (allocated by the
  /// caller). An exception is thrown if the buffer is not large enough to
  /// hold all of the pixels (taking into account the number of bytes per
  /// pixel) or if the Buffer subclass is not one of the support types
  /// (ByteBuffer, ShortBuffer, IntBuffer).
  ///
  /// The content of the bitmap is copied into the buffer as-is. This means
  /// that if this bitmap stores its pixels pre-multiplied
  /// (see \#isPremultiplied(), the values in the buffer will also be
  /// pre-multiplied. The pixels remain in the color space of the bitmap.
  ///
  /// After this method returns, the current position of the buffer is
  /// updated: the position is incremented by the number of elements written
  /// in the buffer.
  ///
  ///@throws IllegalStateException if the bitmap's config is Config\#HARDWARE
  void copyPixelsToBuffer(jni.JniObject dst) => jniAccessors.callMethodWithArgs(
      reference,
      _id_copyPixelsToBuffer,
      jni.JniType.voidType,
      [dst.reference]).check();

  static final _id_copyPixelsFromBuffer = jniAccessors.getMethodIDOf(
      _classRef, "copyPixelsFromBuffer", "(Ljava/nio/Buffer;)V");

  /// from: public void copyPixelsFromBuffer(java.nio.Buffer src)
  ///
  /// Copy the pixels from the buffer, beginning at the current position,
  /// overwriting the bitmap's pixels. The data in the buffer is not changed
  /// in any way (unlike setPixels(), which converts from unpremultipled 32bit
  /// to whatever the bitmap's native format is. The pixels in the source
  /// buffer are assumed to be in the bitmap's color space.
  ///
  /// After this method returns, the current position of the buffer is
  /// updated: the position is incremented by the number of elements read from
  /// the buffer. If you need to read the bitmap from the buffer again you must
  /// first rewind the buffer.
  ///
  ///@throws IllegalStateException if the bitmap's config is Config\#HARDWARE
  void copyPixelsFromBuffer(jni.JniObject src) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyPixelsFromBuffer,
          jni.JniType.voidType, [src.reference]).check();

  static final _id_copy = jniAccessors.getMethodIDOf(_classRef, "copy",
      "(Landroid/graphics/Bitmap\$Config;Z)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap copy(android.graphics.Bitmap.Config config, boolean isMutable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Tries to make a new bitmap based on the dimensions of this bitmap,
  /// setting the new bitmap's config to the one specified, and then copying
  /// this bitmap's pixels into the new bitmap. If the conversion is not
  /// supported, or the allocator fails, then this returns NULL.  The returned
  /// bitmap has the same density and color space as the original.
  ///@param config The desired config for the resulting bitmap
  ///@param isMutable True if the resulting bitmap should be mutable (i.e.
  ///                  its pixels can be modified)
  ///@return the new bitmap, or null if the copy could not be made.
  ///@throws IllegalArgumentException if config is Config\#HARDWARE and isMutable is true
  Bitmap copy(Bitmap_Config config, bool isMutable) =>
      Bitmap.fromRef(jniAccessors.callMethodWithArgs(reference, _id_copy,
          jni.JniType.objectType, [config.reference, isMutable]).object);

  static final _id_createScaledBitmap = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createScaledBitmap",
      "(Landroid/graphics/Bitmap;IIZ)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createScaledBitmap(android.graphics.Bitmap src, int dstWidth, int dstHeight, boolean filter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new bitmap, scaled from an existing bitmap, when possible. If the
  /// specified width and height are the same as the current width and height of
  /// the source bitmap, the source bitmap is returned and no new bitmap is
  /// created.
  ///@param src The source bitmap.
  /// This value must never be {@code null}.
  ///@param dstWidth The new bitmap's desired width.
  ///@param dstHeight The new bitmap's desired height.
  ///@param filter true if the source should be filtered.
  ///@return The new scaled bitmap or the source bitmap if no scaling is required.
  ///@throws IllegalArgumentException if width is <= 0, or height is <= 0
  static Bitmap createScaledBitmap(
          Bitmap src, int dstWidth, int dstHeight, bool filter) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createScaledBitmap,
          jni.JniType.objectType,
          [src.reference, dstWidth, dstHeight, filter]).object);

  static final _id_createBitmap = jniAccessors.getStaticMethodIDOf(_classRef,
      "createBitmap", "(Landroid/graphics/Bitmap;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an immutable bitmap from the source bitmap. The new bitmap may
  /// be the same object as source, or a copy may have been made.  It is
  /// initialized with the same density and color space as the original bitmap.
  ///@param src This value must never be {@code null}.
  static Bitmap createBitmap(Bitmap src) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_createBitmap, jni.JniType.objectType, [src.reference]).object);

  static final _id_createBitmap1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(Landroid/graphics/Bitmap;IIII)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap source, int x, int y, int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an immutable bitmap from the specified subset of the source
  /// bitmap. The new bitmap may be the same object as source, or a copy may
  /// have been made. It is initialized with the same density and color space
  /// as the original bitmap.
  ///@param source The bitmap we are subsetting
  /// This value must never be {@code null}.
  ///@param x The x coordinate of the first pixel in source
  ///@param y The y coordinate of the first pixel in source
  ///@param width The number of pixels in each row
  ///@param height The number of rows
  ///@return A copy of a subset of the source bitmap or the source bitmap itself.
  ///@throws IllegalArgumentException if the x, y, width, height values are
  ///         outside of the dimensions of the source bitmap, or width is <= 0,
  ///         or height is <= 0
  static Bitmap createBitmap1(
          Bitmap source, int x, int y, int width, int height) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createBitmap1,
          jni.JniType.objectType,
          [source.reference, x, y, width, height]).object);

  static final _id_createBitmap2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(Landroid/graphics/Bitmap;IIIILandroid/graphics/Matrix;Z)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap source, int x, int y, int width, int height, android.graphics.Matrix m, boolean filter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an immutable bitmap from subset of the source bitmap,
  /// transformed by the optional matrix. The new bitmap may be the
  /// same object as source, or a copy may have been made. It is
  /// initialized with the same density and color space as the original
  /// bitmap.
  ///
  /// If the source bitmap is immutable and the requested subset is the
  /// same as the source bitmap itself, then the source bitmap is
  /// returned and no new bitmap is created.
  ///@param source The bitmap we are subsetting
  /// This value must never be {@code null}.
  ///@param x The x coordinate of the first pixel in source
  ///@param y The y coordinate of the first pixel in source
  ///@param width The number of pixels in each row
  ///@param height The number of rows
  ///@param m Optional matrix to be applied to the pixels
  /// This value may be {@code null}.
  ///@param filter true if the source should be filtered.
  ///                   Only applies if the matrix contains more than just
  ///                   translation.
  ///@return A bitmap that represents the specified subset of source
  ///@throws IllegalArgumentException if the x, y, width, height values are
  ///         outside of the dimensions of the source bitmap, or width is <= 0,
  ///         or height is <= 0
  static Bitmap createBitmap2(Bitmap source, int x, int y, int width,
          int height, matrix_.Matrix m, bool filter) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createBitmap2,
          jni.JniType.objectType,
          [source.reference, x, y, width, height, m.reference, filter]).object);

  static final _id_createBitmap3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(IILandroid/graphics/Bitmap\$Config;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(int width, int height, android.graphics.Bitmap.Config config)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a mutable bitmap with the specified width and height.  Its
  /// initial density is as per \#getDensity. The newly created
  /// bitmap is in the ColorSpace.Named\#SRGB sRGB color space.
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create.
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the width or height are <= 0, or if
  ///         Config is Config.HARDWARE, because hardware bitmaps are always immutable
  static Bitmap createBitmap3(int width, int height, Bitmap_Config config) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createBitmap3,
          jni.JniType.objectType,
          [width, height, config.reference]).object);

  static final _id_createBitmap4 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap\$Config;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics display, int width, int height, android.graphics.Bitmap.Config config)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a mutable bitmap with the specified width and height.  Its
  /// initial density is determined from the given DisplayMetrics.
  /// The newly created bitmap is in the ColorSpace.Named\#SRGB sRGB
  /// color space.
  ///@param display Display metrics for the display this bitmap will be
  ///                 drawn on.
  /// This value may be {@code null}.
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create.
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the width or height are <= 0, or if
  ///         Config is Config.HARDWARE, because hardware bitmaps are always immutable
  static Bitmap createBitmap4(displaymetrics_.DisplayMetrics display, int width,
          int height, Bitmap_Config config) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createBitmap4,
          jni.JniType.objectType,
          [display.reference, width, height, config.reference]).object);

  static final _id_createBitmap5 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(IILandroid/graphics/Bitmap\$Config;Z)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(int width, int height, android.graphics.Bitmap.Config config, boolean hasAlpha)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a mutable bitmap with the specified width and height.  Its
  /// initial density is as per \#getDensity. The newly created
  /// bitmap is in the ColorSpace.Named\#SRGB sRGB color space.
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create.
  /// This value must never be {@code null}.
  ///@param hasAlpha If the bitmap is ARGB_8888 or RGBA_16F this flag can be used to
  ///                 mark the bitmap as opaque. Doing so will clear the bitmap in black
  ///                 instead of transparent.
  ///@throws IllegalArgumentException if the width or height are <= 0, or if
  ///         Config is Config.HARDWARE, because hardware bitmaps are always immutable
  static Bitmap createBitmap5(
          int width, int height, Bitmap_Config config, bool hasAlpha) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createBitmap5,
          jni.JniType.objectType,
          [width, height, config.reference, hasAlpha]).object);

  static final _id_createBitmap6 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(IILandroid/graphics/Bitmap\$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(int width, int height, android.graphics.Bitmap.Config config, boolean hasAlpha, android.graphics.ColorSpace colorSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a mutable bitmap with the specified width and height.  Its
  /// initial density is as per \#getDensity.
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create.
  /// This value must never be {@code null}.
  ///@param hasAlpha If the bitmap is ARGB_8888 or RGBA_16F this flag can be used to
  ///                 mark the bitmap as opaque. Doing so will clear the bitmap in black
  ///                 instead of transparent.
  ///@param colorSpace The color space of the bitmap. If the config is Config\#RGBA_F16,
  ///                   ColorSpace.Named\#EXTENDED_SRGB scRGB is assumed, and if the
  ///                   config is not Config\#ARGB_8888, ColorSpace.Named\#SRGB sRGB
  ///                   is assumed.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the width or height are <= 0, if
  ///         Config is Config.HARDWARE (because hardware bitmaps are always
  ///         immutable), if the specified color space is not ColorSpace.Model\#RGB RGB,
  ///         if the specified color space's transfer function is not an
  ///         ColorSpace.Rgb.TransferParameters ICC parametric curve, or if
  ///         the color space is null
  static Bitmap createBitmap6(int width, int height, Bitmap_Config config,
          bool hasAlpha, colorspace_.ColorSpace colorSpace) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createBitmap6, jni.JniType.objectType, [
        width,
        height,
        config.reference,
        hasAlpha,
        colorSpace.reference
      ]).object);

  static final _id_createBitmap7 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap\$Config;Z)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics display, int width, int height, android.graphics.Bitmap.Config config, boolean hasAlpha)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a mutable bitmap with the specified width and height.  Its
  /// initial density is determined from the given DisplayMetrics.
  /// The newly created bitmap is in the ColorSpace.Named\#SRGB sRGB
  /// color space.
  ///@param display Display metrics for the display this bitmap will be
  ///                 drawn on.
  /// This value may be {@code null}.
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create.
  /// This value must never be {@code null}.
  ///@param hasAlpha If the bitmap is ARGB_8888 or RGBA_16F this flag can be used to
  ///                 mark the bitmap as opaque. Doing so will clear the bitmap in black
  ///                 instead of transparent.
  ///@throws IllegalArgumentException if the width or height are <= 0, or if
  ///         Config is Config.HARDWARE, because hardware bitmaps are always immutable
  static Bitmap createBitmap7(displaymetrics_.DisplayMetrics display, int width,
          int height, Bitmap_Config config, bool hasAlpha) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createBitmap7, jni.JniType.objectType, [
        display.reference,
        width,
        height,
        config.reference,
        hasAlpha
      ]).object);

  static final _id_createBitmap8 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap\$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics display, int width, int height, android.graphics.Bitmap.Config config, boolean hasAlpha, android.graphics.ColorSpace colorSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a mutable bitmap with the specified width and height.  Its
  /// initial density is determined from the given DisplayMetrics.
  /// The newly created bitmap is in the ColorSpace.Named\#SRGB sRGB
  /// color space.
  ///@param display Display metrics for the display this bitmap will be
  ///                 drawn on.
  /// This value may be {@code null}.
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create.
  /// This value must never be {@code null}.
  ///@param hasAlpha If the bitmap is ARGB_8888 or RGBA_16F this flag can be used to
  ///                 mark the bitmap as opaque. Doing so will clear the bitmap in black
  ///                 instead of transparent.
  ///@param colorSpace The color space of the bitmap. If the config is Config\#RGBA_F16,
  ///                   ColorSpace.Named\#EXTENDED_SRGB scRGB is assumed, and if the
  ///                   config is not Config\#ARGB_8888, ColorSpace.Named\#SRGB sRGB
  ///                   is assumed.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the width or height are <= 0, if
  ///         Config is Config.HARDWARE (because hardware bitmaps are always
  ///         immutable), if the specified color space is not ColorSpace.Model\#RGB RGB,
  ///         if the specified color space's transfer function is not an
  ///         ColorSpace.Rgb.TransferParameters ICC parametric curve, or if
  ///         the color space is null
  static Bitmap createBitmap8(
          displaymetrics_.DisplayMetrics display,
          int width,
          int height,
          Bitmap_Config config,
          bool hasAlpha,
          colorspace_.ColorSpace colorSpace) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createBitmap8, jni.JniType.objectType, [
        display.reference,
        width,
        height,
        config.reference,
        hasAlpha,
        colorSpace.reference
      ]).object);

  static final _id_createBitmap9 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "([IIIIILandroid/graphics/Bitmap\$Config;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(int[] colors, int offset, int stride, int width, int height, android.graphics.Bitmap.Config config)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a immutable bitmap with the specified width and height, with each
  /// pixel value set to the corresponding value in the colors array.  Its
  /// initial density is as per \#getDensity. The newly created
  /// bitmap is in the ColorSpace.Named\#SRGB sRGB color space.
  ///@param colors Array of sRGB Color colors used to initialize the pixels.
  /// This value must never be {@code null}.
  ///@param offset Number of values to skip before the first color in the
  ///                 array of colors.
  ///@param stride Number of colors in the array between rows (must be >=
  ///                 width or <= -width).
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create. If the config does not
  ///                 support per-pixel alpha (e.g. RGB_565), then the alpha
  ///                 bytes in the colors[] will be ignored (assumed to be FF)
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the width or height are <= 0, or if
  ///         the color array's length is less than the number of pixels.
  static Bitmap createBitmap9(jni.JniObject colors, int offset, int stride,
          int width, int height, Bitmap_Config config) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createBitmap9, jni.JniType.objectType, [
        colors.reference,
        offset,
        stride,
        width,
        height,
        config.reference
      ]).object);

  static final _id_createBitmap10 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(Landroid/util/DisplayMetrics;[IIIIILandroid/graphics/Bitmap\$Config;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics display, int[] colors, int offset, int stride, int width, int height, android.graphics.Bitmap.Config config)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a immutable bitmap with the specified width and height, with each
  /// pixel value set to the corresponding value in the colors array.  Its
  /// initial density is determined from the given DisplayMetrics.
  /// The newly created bitmap is in the ColorSpace.Named\#SRGB sRGB
  /// color space.
  ///@param display Display metrics for the display this bitmap will be
  ///                 drawn on.
  /// This value must never be {@code null}.
  ///@param colors Array of sRGB Color colors used to initialize the pixels.
  /// This value must never be {@code null}.
  ///@param offset Number of values to skip before the first color in the
  ///                 array of colors.
  ///@param stride Number of colors in the array between rows (must be >=
  ///                 width or <= -width).
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create. If the config does not
  ///                 support per-pixel alpha (e.g. RGB_565), then the alpha
  ///                 bytes in the colors[] will be ignored (assumed to be FF)
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the width or height are <= 0, or if
  ///         the color array's length is less than the number of pixels.
  static Bitmap createBitmap10(
          displaymetrics_.DisplayMetrics display,
          jni.JniObject colors,
          int offset,
          int stride,
          int width,
          int height,
          Bitmap_Config config) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createBitmap10, jni.JniType.objectType, [
        display.reference,
        colors.reference,
        offset,
        stride,
        width,
        height,
        config.reference
      ]).object);

  static final _id_createBitmap11 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "([IIILandroid/graphics/Bitmap\$Config;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(int[] colors, int width, int height, android.graphics.Bitmap.Config config)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a immutable bitmap with the specified width and height, with each
  /// pixel value set to the corresponding value in the colors array.  Its
  /// initial density is as per \#getDensity. The newly created
  /// bitmap is in the ColorSpace.Named\#SRGB sRGB color space.
  ///@param colors Array of sRGB Color colors used to initialize the pixels.
  ///                 This array must be at least as large as width * height.
  /// This value must never be {@code null}.
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create. If the config does not
  ///                 support per-pixel alpha (e.g. RGB_565), then the alpha
  ///                 bytes in the colors[] will be ignored (assumed to be FF)
  ///@throws IllegalArgumentException if the width or height are <= 0, or if
  ///         the color array's length is less than the number of pixels.
  static Bitmap createBitmap11(
          jni.JniObject colors, int width, int height, Bitmap_Config config) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createBitmap11,
          jni.JniType.objectType,
          [colors.reference, width, height, config.reference]).object);

  static final _id_createBitmap12 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(Landroid/util/DisplayMetrics;[IIILandroid/graphics/Bitmap\$Config;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics display, int[] colors, int width, int height, android.graphics.Bitmap.Config config)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a immutable bitmap with the specified width and height, with each
  /// pixel value set to the corresponding value in the colors array.  Its
  /// initial density is determined from the given DisplayMetrics.
  /// The newly created bitmap is in the ColorSpace.Named\#SRGB sRGB
  /// color space.
  ///@param display Display metrics for the display this bitmap will be
  ///                 drawn on.
  /// This value may be {@code null}.
  ///@param colors Array of sRGB Color colors used to initialize the pixels.
  ///                 This array must be at least as large as width * height.
  /// This value must never be {@code null}.
  ///@param width The width of the bitmap
  ///@param height The height of the bitmap
  ///@param config The bitmap config to create. If the config does not
  ///                 support per-pixel alpha (e.g. RGB_565), then the alpha
  ///                 bytes in the colors[] will be ignored (assumed to be FF)
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the width or height are <= 0, or if
  ///         the color array's length is less than the number of pixels.
  static Bitmap createBitmap12(displaymetrics_.DisplayMetrics display,
          jni.JniObject colors, int width, int height, Bitmap_Config config) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createBitmap12, jni.JniType.objectType, [
        display.reference,
        colors.reference,
        width,
        height,
        config.reference
      ]).object);

  static final _id_createBitmap13 = jniAccessors.getStaticMethodIDOf(_classRef,
      "createBitmap", "(Landroid/graphics/Picture;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Picture source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a Bitmap from the given Picture source of recorded drawing commands.
  ///
  /// Equivalent to calling \#createBitmap(Picture, int, int, Config) with
  /// width and height the same as the Picture's width and height and a Config.HARDWARE
  /// config.
  ///@param source The recorded Picture of drawing commands that will be
  ///               drawn into the returned Bitmap.
  /// This value must never be {@code null}.
  ///@return An immutable bitmap with a HARDWARE config whose contents are created
  /// from the recorded drawing commands in the Picture source.
  ///
  /// This value will never be {@code null}.
  static Bitmap createBitmap13(picture_.Picture source) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createBitmap13,
          jni.JniType.objectType,
          [source.reference]).object);

  static final _id_createBitmap14 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createBitmap",
      "(Landroid/graphics/Picture;IILandroid/graphics/Bitmap\$Config;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Picture source, int width, int height, android.graphics.Bitmap.Config config)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a Bitmap from the given Picture source of recorded drawing commands.
  ///
  /// The bitmap will be immutable with the given width and height. If the width and height
  /// are not the same as the Picture's width & height, the Picture will be scaled to
  /// fit the given width and height.
  ///@param source The recorded Picture of drawing commands that will be
  ///               drawn into the returned Bitmap.
  /// This value must never be {@code null}.
  ///@param width The width of the bitmap to create. The picture's width will be
  ///              scaled to match if necessary.
  ///@param height The height of the bitmap to create. The picture's height will be
  ///              scaled to match if necessary.
  ///@param config The Config of the created bitmap. If this is null then
  ///               the bitmap will be Config\#HARDWARE.
  ///
  /// This value must never be {@code null}.
  ///@return An immutable bitmap with a HARDWARE config whose contents are created
  /// from the recorded drawing commands in the Picture source.
  static Bitmap createBitmap14(picture_.Picture source, int width, int height,
          Bitmap_Config config) =>
      Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createBitmap14,
          jni.JniType.objectType,
          [source.reference, width, height, config.reference]).object);

  static final _id_getNinePatchChunk =
      jniAccessors.getMethodIDOf(_classRef, "getNinePatchChunk", "()[B");

  /// from: public byte[] getNinePatchChunk()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an optional array of private data, used by the UI system for
  /// some bitmaps. Not intended to be called by applications.
  jni.JniObject getNinePatchChunk() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNinePatchChunk, jni.JniType.objectType, []).object);

  static final _id_compress = jniAccessors.getMethodIDOf(_classRef, "compress",
      "(Landroid/graphics/Bitmap\$CompressFormat;ILjava/io/OutputStream;)Z");

  /// from: public boolean compress(android.graphics.Bitmap.CompressFormat format, int quality, java.io.OutputStream stream)
  ///
  /// Write a compressed version of the bitmap to the specified outputstream.
  /// If this returns true, the bitmap can be reconstructed by passing a
  /// corresponding inputstream to BitmapFactory.decodeStream(). Note: not
  /// all Formats support all bitmap configs directly, so it is possible that
  /// the returned bitmap from BitmapFactory could be in a different bitdepth,
  /// and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque
  /// pixels).
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param format The format of the compressed image
  ///@param quality Hint to the compressor, 0-100. 0 meaning compress for
  ///                 small size, 100 meaning compress for max quality. Some
  ///                 formats, like PNG which is lossless, will ignore the
  ///                 quality setting
  ///@param stream The outputstream to write the compressed data.
  ///@return true if successfully compressed to the specified stream.
  bool compress(
          Bitmap_CompressFormat format, int quality, jni.JniObject stream) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_compress,
          jni.JniType.booleanType,
          [format.reference, quality, stream.reference]).boolean;

  static final _id_isMutable =
      jniAccessors.getMethodIDOf(_classRef, "isMutable", "()Z");

  /// from: public boolean isMutable()
  ///
  /// Returns true if the bitmap is marked as mutable (i.e.&nbsp;can be drawn into)
  bool isMutable() => jniAccessors.callMethodWithArgs(
      reference, _id_isMutable, jni.JniType.booleanType, []).boolean;

  static final _id_isPremultiplied =
      jniAccessors.getMethodIDOf(_classRef, "isPremultiplied", "()Z");

  /// from: public boolean isPremultiplied()
  ///
  /// Indicates whether pixels stored in this bitmaps are stored pre-multiplied.
  /// When a pixel is pre-multiplied, the RGB components have been multiplied by
  /// the alpha component. For instance, if the original color is a 50%
  /// translucent red <code>(128, 255, 0, 0)</code>, the pre-multiplied form is
  /// <code>(128, 128, 0, 0)</code>.
  ///
  ///
  /// This method always returns false if \#getConfig() is
  /// Bitmap.Config\#RGB_565.
  ///
  ///
  /// The return value is undefined if \#getConfig() is
  /// Bitmap.Config\#ALPHA_8.
  ///
  ///
  /// This method only returns true if \#hasAlpha() returns true.
  /// A bitmap with no alpha channel can be used both as a pre-multiplied and
  /// as a non pre-multiplied bitmap.
  ///
  ///
  /// Only pre-multiplied bitmaps may be drawn by the view system or
  /// Canvas. If a non-pre-multiplied bitmap with an alpha channel is
  /// drawn to a Canvas, a RuntimeException will be thrown.
  ///
  ///@return true if the underlying pixels have been pre-multiplied, false
  ///         otherwise
  ///@see Bitmap\#setPremultiplied(boolean)
  ///@see BitmapFactory.Options\#inPremultiplied
  bool isPremultiplied() => jniAccessors.callMethodWithArgs(
      reference, _id_isPremultiplied, jni.JniType.booleanType, []).boolean;

  static final _id_setPremultiplied =
      jniAccessors.getMethodIDOf(_classRef, "setPremultiplied", "(Z)V");

  /// from: public void setPremultiplied(boolean premultiplied)
  ///
  /// Sets whether the bitmap should treat its data as pre-multiplied.
  ///
  /// Bitmaps are always treated as pre-multiplied by the view system and
  /// Canvas for performance reasons. Storing un-pre-multiplied data in
  /// a Bitmap (through \#setPixel, \#setPixels, or BitmapFactory.Options\#inPremultiplied BitmapFactory.Options.inPremultiplied)
  /// can lead to incorrect blending if drawn by the framework.
  ///
  ///
  /// This method will not affect the behavior of a bitmap without an alpha
  /// channel, or if \#hasAlpha() returns false.
  ///
  ///
  /// Calling \#createBitmap or \#createScaledBitmap with a source
  /// Bitmap whose colors are not pre-multiplied may result in a RuntimeException,
  /// since those functions require drawing the source, which is not supported for
  /// un-pre-multiplied Bitmaps.
  ///
  ///@see Bitmap\#isPremultiplied()
  ///@see BitmapFactory.Options\#inPremultiplied
  void setPremultiplied(bool premultiplied) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPremultiplied,
      jni.JniType.voidType,
      [premultiplied]).check();

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Returns the bitmap's width
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Returns the bitmap's height
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getScaledWidth = jniAccessors.getMethodIDOf(
      _classRef, "getScaledWidth", "(Landroid/graphics/Canvas;)I");

  /// from: public int getScaledWidth(android.graphics.Canvas canvas)
  ///
  /// Convenience for calling \#getScaledWidth(int) with the target
  /// density of the given Canvas.
  int getScaledWidth(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledWidth,
      jni.JniType.intType,
      [canvas.reference]).integer;

  static final _id_getScaledHeight = jniAccessors.getMethodIDOf(
      _classRef, "getScaledHeight", "(Landroid/graphics/Canvas;)I");

  /// from: public int getScaledHeight(android.graphics.Canvas canvas)
  ///
  /// Convenience for calling \#getScaledHeight(int) with the target
  /// density of the given Canvas.
  int getScaledHeight(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledHeight,
      jni.JniType.intType,
      [canvas.reference]).integer;

  static final _id_getScaledWidth1 = jniAccessors.getMethodIDOf(
      _classRef, "getScaledWidth", "(Landroid/util/DisplayMetrics;)I");

  /// from: public int getScaledWidth(android.util.DisplayMetrics metrics)
  ///
  /// Convenience for calling \#getScaledWidth(int) with the target
  /// density of the given DisplayMetrics.
  int getScaledWidth1(displaymetrics_.DisplayMetrics metrics) =>
      jniAccessors.callMethodWithArgs(reference, _id_getScaledWidth1,
          jni.JniType.intType, [metrics.reference]).integer;

  static final _id_getScaledHeight1 = jniAccessors.getMethodIDOf(
      _classRef, "getScaledHeight", "(Landroid/util/DisplayMetrics;)I");

  /// from: public int getScaledHeight(android.util.DisplayMetrics metrics)
  ///
  /// Convenience for calling \#getScaledHeight(int) with the target
  /// density of the given DisplayMetrics.
  int getScaledHeight1(displaymetrics_.DisplayMetrics metrics) =>
      jniAccessors.callMethodWithArgs(reference, _id_getScaledHeight1,
          jni.JniType.intType, [metrics.reference]).integer;

  static final _id_getScaledWidth2 =
      jniAccessors.getMethodIDOf(_classRef, "getScaledWidth", "(I)I");

  /// from: public int getScaledWidth(int targetDensity)
  ///
  /// Convenience method that returns the width of this bitmap divided
  /// by the density scale factor.
  ///@param targetDensity The density of the target canvas of the bitmap.
  ///@return The scaled width of this bitmap, according to the density scale factor.
  int getScaledWidth2(int targetDensity) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledWidth2,
      jni.JniType.intType,
      [targetDensity]).integer;

  static final _id_getScaledHeight2 =
      jniAccessors.getMethodIDOf(_classRef, "getScaledHeight", "(I)I");

  /// from: public int getScaledHeight(int targetDensity)
  ///
  /// Convenience method that returns the height of this bitmap divided
  /// by the density scale factor.
  ///@param targetDensity The density of the target canvas of the bitmap.
  ///@return The scaled height of this bitmap, according to the density scale factor.
  int getScaledHeight2(int targetDensity) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getScaledHeight2,
      jni.JniType.intType,
      [targetDensity]).integer;

  static final _id_getRowBytes =
      jniAccessors.getMethodIDOf(_classRef, "getRowBytes", "()I");

  /// from: public int getRowBytes()
  ///
  /// Return the number of bytes between rows in the bitmap's pixels. Note that
  /// this refers to the pixels as stored natively by the bitmap. If you call
  /// getPixels() or setPixels(), then the pixels are uniformly treated as
  /// 32bit values, packed according to the Color class.
  ///
  /// As of android.os.Build.VERSION_CODES\#KITKAT, this method
  /// should not be used to calculate the memory usage of the bitmap. Instead,
  /// see \#getAllocationByteCount().
  ///@return number of bytes between rows of the native bitmap pixels.
  int getRowBytes() => jniAccessors.callMethodWithArgs(
      reference, _id_getRowBytes, jni.JniType.intType, []).integer;

  static final _id_getByteCount =
      jniAccessors.getMethodIDOf(_classRef, "getByteCount", "()I");

  /// from: public int getByteCount()
  ///
  /// Returns the minimum number of bytes that can be used to store this bitmap's pixels.
  ///
  /// As of android.os.Build.VERSION_CODES\#KITKAT, the result of this method can
  /// no longer be used to determine memory usage of a bitmap. See \#getAllocationByteCount().
  ///
  int getByteCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getByteCount, jni.JniType.intType, []).integer;

  static final _id_getAllocationByteCount =
      jniAccessors.getMethodIDOf(_classRef, "getAllocationByteCount", "()I");

  /// from: public int getAllocationByteCount()
  ///
  /// Returns the size of the allocated memory used to store this bitmap's pixels.
  ///
  /// This can be larger than the result of \#getByteCount() if a bitmap is reused to
  /// decode other bitmaps of smaller size, or by manual reconfiguration. See \#reconfigure(int, int, Config), \#setWidth(int), \#setHeight(int), \#setConfig(Bitmap.Config), and BitmapFactory.Options\#inBitmap BitmapFactory.Options.inBitmap. If a bitmap is not modified in this way, this value will be
  /// the same as that returned by \#getByteCount().
  ///
  ///
  /// This value will not change over the lifetime of a Bitmap.
  ///
  ///@see \#reconfigure(int, int, Config)
  int getAllocationByteCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getAllocationByteCount, jni.JniType.intType, []).integer;

  static final _id_getConfig = jniAccessors.getMethodIDOf(
      _classRef, "getConfig", "()Landroid/graphics/Bitmap\$Config;");

  /// from: public android.graphics.Bitmap.Config getConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the bitmap's internal config is in one of the public formats, return
  /// that config, otherwise return null.
  Bitmap_Config getConfig() =>
      Bitmap_Config.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConfig, jni.JniType.objectType, []).object);

  static final _id_hasAlpha =
      jniAccessors.getMethodIDOf(_classRef, "hasAlpha", "()Z");

  /// from: public boolean hasAlpha()
  ///
  /// Returns true if the bitmap's config supports per-pixel alpha, and
  /// if the pixels may contain non-opaque alpha values. For some configs,
  /// this is always false (e.g. RGB_565), since they do not support per-pixel
  /// alpha. However, for configs that do, the bitmap may be flagged to be
  /// known that all of its pixels are opaque. In this case hasAlpha() will
  /// also return false. If a config such as ARGB_8888 is not so flagged,
  /// it will return true by default.
  bool hasAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_hasAlpha, jni.JniType.booleanType, []).boolean;

  static final _id_setHasAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setHasAlpha", "(Z)V");

  /// from: public void setHasAlpha(boolean hasAlpha)
  ///
  /// Tell the bitmap if all of the pixels are known to be opaque (false)
  /// or if some of the pixels may contain non-opaque alpha values (true).
  /// Note, for some configs (e.g. RGB_565) this call is ignored, since it
  /// does not support per-pixel alpha values.
  ///
  /// This is meant as a drawing hint, as in some cases a bitmap that is known
  /// to be opaque can take a faster drawing case than one that may have
  /// non-opaque per-pixel alpha values.
  void setHasAlpha(bool hasAlpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setHasAlpha, jni.JniType.voidType, [hasAlpha]).check();

  static final _id_hasMipMap =
      jniAccessors.getMethodIDOf(_classRef, "hasMipMap", "()Z");

  /// from: public boolean hasMipMap()
  ///
  /// Indicates whether the renderer responsible for drawing this
  /// bitmap should attempt to use mipmaps when this bitmap is drawn
  /// scaled down.
  ///
  /// If you know that you are going to draw this bitmap at less than
  /// 50% of its original size, you may be able to obtain a higher
  /// quality
  ///
  /// This property is only a suggestion that can be ignored by the
  /// renderer. It is not guaranteed to have any effect.
  ///@return true if the renderer should attempt to use mipmaps,
  ///         false otherwise
  ///@see \#setHasMipMap(boolean)
  bool hasMipMap() => jniAccessors.callMethodWithArgs(
      reference, _id_hasMipMap, jni.JniType.booleanType, []).boolean;

  static final _id_setHasMipMap =
      jniAccessors.getMethodIDOf(_classRef, "setHasMipMap", "(Z)V");

  /// from: public void setHasMipMap(boolean hasMipMap)
  ///
  /// Set a hint for the renderer responsible for drawing this bitmap
  /// indicating that it should attempt to use mipmaps when this bitmap
  /// is drawn scaled down.
  ///
  /// If you know that you are going to draw this bitmap at less than
  /// 50% of its original size, you may be able to obtain a higher
  /// quality by turning this property on.
  ///
  /// Note that if the renderer respects this hint it might have to
  /// allocate extra memory to hold the mipmap levels for this bitmap.
  ///
  /// This property is only a suggestion that can be ignored by the
  /// renderer. It is not guaranteed to have any effect.
  ///@param hasMipMap indicates whether the renderer should attempt
  ///                  to use mipmaps
  ///@see \#hasMipMap()
  void setHasMipMap(bool hasMipMap) => jniAccessors.callMethodWithArgs(
      reference, _id_setHasMipMap, jni.JniType.voidType, [hasMipMap]).check();

  static final _id_getColorSpace = jniAccessors.getMethodIDOf(
      _classRef, "getColorSpace", "()Landroid/graphics/ColorSpace;");

  /// from: public android.graphics.ColorSpace getColorSpace()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the color space associated with this bitmap. If the color
  /// space is unknown, this method returns null.
  colorspace_.ColorSpace getColorSpace() =>
      colorspace_.ColorSpace.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorSpace, jni.JniType.objectType, []).object);

  static final _id_eraseColor =
      jniAccessors.getMethodIDOf(_classRef, "eraseColor", "(I)V");

  /// from: public void eraseColor(int c)
  ///
  /// Fills the bitmap's pixels with the specified Color.
  ///@throws IllegalStateException if the bitmap is not mutable.
  void eraseColor(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_eraseColor, jni.JniType.voidType, [c]).check();

  static final _id_getPixel =
      jniAccessors.getMethodIDOf(_classRef, "getPixel", "(II)I");

  /// from: public int getPixel(int x, int y)
  ///
  /// Returns the Color at the specified location. Throws an exception
  /// if x or y are out of bounds (negative or >= to the width or height
  /// respectively). The returned color is a non-premultiplied ARGB value in
  /// the ColorSpace.Named\#SRGB sRGB color space.
  ///@param x The x coordinate (0...width-1) of the pixel to return
  ///@param y The y coordinate (0...height-1) of the pixel to return
  ///@return The argb Color at the specified coordinate
  ///@throws IllegalArgumentException if x, y exceed the bitmap's bounds
  ///@throws IllegalStateException if the bitmap's config is Config\#HARDWARE
  int getPixel(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_getPixel, jni.JniType.intType, [x, y]).integer;

  static final _id_getPixels =
      jniAccessors.getMethodIDOf(_classRef, "getPixels", "([IIIIIII)V");

  /// from: public void getPixels(int[] pixels, int offset, int stride, int x, int y, int width, int height)
  ///
  /// Returns in pixels[] a copy of the data in the bitmap. Each value is
  /// a packed int representing a Color. The stride parameter allows
  /// the caller to allow for gaps in the returned pixels array between
  /// rows. For normal packed results, just pass width for the stride value.
  /// The returned colors are non-premultiplied ARGB values in the
  /// ColorSpace.Named\#SRGB sRGB color space.
  ///@param pixels The array to receive the bitmap's colors
  ///@param offset The first index to write into pixels[]
  ///@param stride The number of entries in pixels[] to skip between
  ///                 rows (must be >= bitmap's width). Can be negative.
  ///@param x The x coordinate of the first pixel to read from
  ///                 the bitmap
  ///@param y The y coordinate of the first pixel to read from
  ///                 the bitmap
  ///@param width The number of pixels to read from each row
  ///@param height The number of rows to read
  ///@throws IllegalArgumentException if x, y, width, height exceed the
  ///         bounds of the bitmap, or if abs(stride) < width.
  ///@throws ArrayIndexOutOfBoundsException if the pixels array is too small
  ///         to receive the specified number of pixels.
  ///@throws IllegalStateException if the bitmap's config is Config\#HARDWARE
  void getPixels(jni.JniObject pixels, int offset, int stride, int x, int y,
          int width, int height) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPixels,
          jni.JniType.voidType,
          [pixels.reference, offset, stride, x, y, width, height]).check();

  static final _id_setPixel =
      jniAccessors.getMethodIDOf(_classRef, "setPixel", "(III)V");

  /// from: public void setPixel(int x, int y, int color)
  ///
  /// Write the specified Color into the bitmap (assuming it is
  /// mutable) at the x,y coordinate. The color must be a
  /// non-premultiplied ARGB value in the ColorSpace.Named\#SRGB sRGB
  /// color space.
  ///
  ///@param x The x coordinate of the pixel to replace (0...width-1)
  ///@param y The y coordinate of the pixel to replace (0...height-1)
  ///@param color The ARGB color to write into the bitmap
  ///@throws IllegalStateException if the bitmap is not mutable
  ///@throws IllegalArgumentException if x, y are outside of the bitmap's
  ///         bounds.
  void setPixel(int x, int y, int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setPixel, jni.JniType.voidType, [x, y, color]).check();

  static final _id_setPixels =
      jniAccessors.getMethodIDOf(_classRef, "setPixels", "([IIIIIII)V");

  /// from: public void setPixels(int[] pixels, int offset, int stride, int x, int y, int width, int height)
  ///
  /// Replace pixels in the bitmap with the colors in the array. Each element
  /// in the array is a packed int representing a non-premultiplied ARGB
  /// Color in the ColorSpace.Named\#SRGB sRGB color space.
  ///
  ///@param pixels The colors to write to the bitmap
  ///@param offset The index of the first color to read from pixels[]
  ///@param stride The number of colors in pixels[] to skip between rows.
  ///                 Normally this value will be the same as the width of
  ///                 the bitmap, but it can be larger (or negative).
  ///@param x The x coordinate of the first pixel to write to in
  ///                 the bitmap.
  ///@param y The y coordinate of the first pixel to write to in
  ///                 the bitmap.
  ///@param width The number of colors to copy from pixels[] per row
  ///@param height The number of rows to write to the bitmap
  ///@throws IllegalStateException if the bitmap is not mutable
  ///@throws IllegalArgumentException if x, y, width, height are outside of
  ///         the bitmap's bounds.
  ///@throws ArrayIndexOutOfBoundsException if the pixels array is too small
  ///         to receive the specified number of pixels.
  void setPixels(jni.JniObject pixels, int offset, int stride, int x, int y,
          int width, int height) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPixels,
          jni.JniType.voidType,
          [pixels.reference, offset, stride, x, y, width, height]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  ///
  /// No special parcel contents.
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel p, int flags)
  ///
  /// Write the bitmap and its pixels to the parcel. The bitmap can be
  /// rebuilt from the parcel by calling CREATOR.createFromParcel().
  ///
  /// If this bitmap is Config\#HARDWARE, it may be unparceled with a different pixel
  /// format (e.g. 565, 8888), but the content will be preserved to the best quality permitted
  /// by the final pixel format
  ///@param p Parcel object to write the bitmap data into
  void writeToParcel(parcel_.Parcel p, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [p.reference, flags]).check();

  static final _id_extractAlpha = jniAccessors.getMethodIDOf(
      _classRef, "extractAlpha", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap extractAlpha()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new bitmap that captures the alpha values of the original.
  /// This may be drawn with Canvas.drawBitmap(), where the color(s) will be
  /// taken from the paint that is passed to the draw call.
  ///@return new bitmap containing the alpha channel of the original bitmap.
  Bitmap extractAlpha() => Bitmap.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_extractAlpha, jni.JniType.objectType, []).object);

  static final _id_extractAlpha1 = jniAccessors.getMethodIDOf(_classRef,
      "extractAlpha", "(Landroid/graphics/Paint;[I)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap extractAlpha(android.graphics.Paint paint, int[] offsetXY)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new bitmap that captures the alpha values of the original.
  /// These values may be affected by the optional Paint parameter, which
  /// can contain its own alpha, and may also contain a MaskFilter which
  /// could change the actual dimensions of the resulting bitmap (e.g.
  /// a blur maskfilter might enlarge the resulting bitmap). If offsetXY
  /// is not null, it returns the amount to offset the returned bitmap so
  /// that it will logically align with the original. For example, if the
  /// paint contains a blur of radius 2, then offsetXY[] would contains
  /// -2, -2, so that drawing the alpha bitmap offset by (-2, -2) and then
  /// drawing the original would result in the blur visually aligning with
  /// the original.
  ///
  /// The initial density of the returned bitmap is the same as the original's.
  ///@param paint Optional paint used to modify the alpha values in the
  ///              resulting bitmap. Pass null for default behavior.
  ///@param offsetXY Optional array that returns the X (index 0) and Y
  ///                 (index 1) offset needed to position the returned bitmap
  ///                 so that it visually lines up with the original.
  ///@return new bitmap containing the (optionally modified by paint) alpha
  ///         channel of the original bitmap. This may be drawn with
  ///         Canvas.drawBitmap(), where the color(s) will be taken from the
  ///         paint that is passed to the draw call.
  Bitmap extractAlpha1(paint_.Paint paint, jni.JniObject offsetXY) =>
      Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_extractAlpha1,
          jni.JniType.objectType,
          [paint.reference, offsetXY.reference]).object);

  static final _id_sameAs = jniAccessors.getMethodIDOf(
      _classRef, "sameAs", "(Landroid/graphics/Bitmap;)Z");

  /// from: public boolean sameAs(android.graphics.Bitmap other)
  ///
  /// Given another bitmap, return true if it has the same dimensions, config,
  ///  and pixel data as this bitmap. If any of those differ, return false.
  ///  If other is null, return false.
  bool sameAs(Bitmap other) => jniAccessors.callMethodWithArgs(reference,
      _id_sameAs, jni.JniType.booleanType, [other.reference]).boolean;

  static final _id_prepareToDraw =
      jniAccessors.getMethodIDOf(_classRef, "prepareToDraw", "()V");

  /// from: public void prepareToDraw()
  ///
  /// Builds caches associated with the bitmap that are used for drawing it.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#N, this call initiates an asynchronous
  /// upload to the GPU on RenderThread, if the Bitmap is not already uploaded. With Hardware
  /// Acceleration, Bitmaps must be uploaded to the GPU in order to be rendered. This is done by
  /// default the first time a Bitmap is drawn, but the process can take several milliseconds,
  /// depending on the size of the Bitmap. Each time a Bitmap is modified and drawn again, it must
  /// be re-uploaded.
  ///
  ///
  /// Calling this method in advance can save time in the first frame it's used. For example, it
  /// is recommended to call this on an image decoding worker thread when a decoded Bitmap is about
  /// to be displayed. It is recommended to make any pre-draw modifications to the Bitmap before
  /// calling this method, so the cached, uploaded copy may be reused without re-uploading.
  ///
  ///
  /// In android.os.Build.VERSION_CODES\#KITKAT and below, for purgeable bitmaps, this call
  /// would attempt to ensure that the pixels have been decoded.
  void prepareToDraw() => jniAccessors.callMethodWithArgs(
      reference, _id_prepareToDraw, jni.JniType.voidType, []).check();
}

/// from: android.graphics.Bitmap$Config
///
/// Possible bitmap configurations. A bitmap configuration describes
/// how pixels are stored. This affects the quality (color depth) as
/// well as the ability to display transparent/translucent colors.
class Bitmap_Config extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Bitmap\$Config");
  Bitmap_Config.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Bitmap\$Config;");

  /// from: static public android.graphics.Bitmap.Config[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Bitmap\$Config;");

  /// from: static public android.graphics.Bitmap.Config valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Bitmap_Config valueOf(jni.JniString name) =>
      Bitmap_Config.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Bitmap_Config()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.graphics.Bitmap$CompressFormat
///
/// Specifies the known formats a bitmap can be compressed into
class Bitmap_CompressFormat extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Bitmap\$CompressFormat");
  Bitmap_CompressFormat.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Bitmap\$CompressFormat;");

  /// from: static public android.graphics.Bitmap.CompressFormat[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/graphics/Bitmap\$CompressFormat;");

  /// from: static public android.graphics.Bitmap.CompressFormat valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Bitmap_CompressFormat valueOf(jni.JniString name) =>
      Bitmap_CompressFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Bitmap_CompressFormat()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
