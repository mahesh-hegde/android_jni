// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "RectF.dart" as rectf_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Matrix
///
/// The Matrix class holds a 3x3 matrix for transforming coordinates.
class Matrix extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Matrix");
  Matrix.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MPERSP_0
  static const MPERSP_0 = 6;

  /// from: static public final int MPERSP_1
  static const MPERSP_1 = 7;

  /// from: static public final int MPERSP_2
  static const MPERSP_2 = 8;

  /// from: static public final int MSCALE_X
  static const MSCALE_X = 0;

  /// from: static public final int MSCALE_Y
  static const MSCALE_Y = 4;

  /// from: static public final int MSKEW_X
  static const MSKEW_X = 1;

  /// from: static public final int MSKEW_Y
  static const MSKEW_Y = 3;

  /// from: static public final int MTRANS_X
  static const MTRANS_X = 2;

  /// from: static public final int MTRANS_Y
  static const MTRANS_Y = 5;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an identity matrix
  Matrix()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Matrix;)V");

  /// from: public void <init>(android.graphics.Matrix src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a matrix that is a (deep) copy of src
  ///@param src The matrix to copy into this matrix
  Matrix.ctor1(Matrix src)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [src.reference]).object);

  static final _id_isIdentity =
      jniAccessors.getMethodIDOf(_classRef, "isIdentity", "()Z");

  /// from: public boolean isIdentity()
  ///
  /// Returns true if the matrix is identity. This maybe faster than testing if (getType() == 0)
  bool isIdentity() => jniAccessors.callMethodWithArgs(
      reference, _id_isIdentity, jni.JniType.booleanType, []).boolean;

  static final _id_isAffine =
      jniAccessors.getMethodIDOf(_classRef, "isAffine", "()Z");

  /// from: public boolean isAffine()
  ///
  /// Gets whether this matrix is affine. An affine matrix preserves straight lines and has no
  /// perspective.
  ///@return Whether the matrix is affine.
  bool isAffine() => jniAccessors.callMethodWithArgs(
      reference, _id_isAffine, jni.JniType.booleanType, []).boolean;

  static final _id_rectStaysRect =
      jniAccessors.getMethodIDOf(_classRef, "rectStaysRect", "()Z");

  /// from: public boolean rectStaysRect()
  ///
  /// Returns true if will map a rectangle to another rectangle. This can be true if the matrix is
  /// identity, scale-only, or rotates a multiple of 90 degrees.
  bool rectStaysRect() => jniAccessors.callMethodWithArgs(
      reference, _id_rectStaysRect, jni.JniType.booleanType, []).boolean;

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(Landroid/graphics/Matrix;)V");

  /// from: public void set(android.graphics.Matrix src)
  ///
  /// (deep) copy the src matrix into this matrix. If src is null, reset this matrix to the
  /// identity matrix.
  void set0(Matrix src) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.voidType, [src.reference]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Returns true iff obj is a Matrix and its values equal our values.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Set the matrix to identity
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_setTranslate =
      jniAccessors.getMethodIDOf(_classRef, "setTranslate", "(FF)V");

  /// from: public void setTranslate(float dx, float dy)
  ///
  /// Set the matrix to translate by (dx, dy).
  void setTranslate(double dx, double dy) => jniAccessors.callMethodWithArgs(
      reference, _id_setTranslate, jni.JniType.voidType, [dx, dy]).check();

  static final _id_setScale =
      jniAccessors.getMethodIDOf(_classRef, "setScale", "(FFFF)V");

  /// from: public void setScale(float sx, float sy, float px, float py)
  ///
  /// Set the matrix to scale by sx and sy, with a pivot point at (px, py). The pivot point is the
  /// coordinate that should remain unchanged by the specified transformation.
  void setScale(double sx, double sy, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScale,
          jni.JniType.voidType, [sx, sy, px, py]).check();

  static final _id_setScale1 =
      jniAccessors.getMethodIDOf(_classRef, "setScale", "(FF)V");

  /// from: public void setScale(float sx, float sy)
  ///
  /// Set the matrix to scale by sx and sy.
  void setScale1(double sx, double sy) => jniAccessors.callMethodWithArgs(
      reference, _id_setScale1, jni.JniType.voidType, [sx, sy]).check();

  static final _id_setRotate =
      jniAccessors.getMethodIDOf(_classRef, "setRotate", "(FFF)V");

  /// from: public void setRotate(float degrees, float px, float py)
  ///
  /// Set the matrix to rotate by the specified number of degrees, with a pivot point at (px, py).
  /// The pivot point is the coordinate that should remain unchanged by the specified
  /// transformation.
  void setRotate(double degrees, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRotate,
          jni.JniType.voidType, [degrees, px, py]).check();

  static final _id_setRotate1 =
      jniAccessors.getMethodIDOf(_classRef, "setRotate", "(F)V");

  /// from: public void setRotate(float degrees)
  ///
  /// Set the matrix to rotate about (0,0) by the specified number of degrees.
  void setRotate1(double degrees) => jniAccessors.callMethodWithArgs(
      reference, _id_setRotate1, jni.JniType.voidType, [degrees]).check();

  static final _id_setSinCos =
      jniAccessors.getMethodIDOf(_classRef, "setSinCos", "(FFFF)V");

  /// from: public void setSinCos(float sinValue, float cosValue, float px, float py)
  ///
  /// Set the matrix to rotate by the specified sine and cosine values, with a pivot point at (px,
  /// py). The pivot point is the coordinate that should remain unchanged by the specified
  /// transformation.
  void setSinCos(double sinValue, double cosValue, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSinCos,
          jni.JniType.voidType, [sinValue, cosValue, px, py]).check();

  static final _id_setSinCos1 =
      jniAccessors.getMethodIDOf(_classRef, "setSinCos", "(FF)V");

  /// from: public void setSinCos(float sinValue, float cosValue)
  ///
  /// Set the matrix to rotate by the specified sine and cosine values.
  void setSinCos1(double sinValue, double cosValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSinCos1,
          jni.JniType.voidType, [sinValue, cosValue]).check();

  static final _id_setSkew =
      jniAccessors.getMethodIDOf(_classRef, "setSkew", "(FFFF)V");

  /// from: public void setSkew(float kx, float ky, float px, float py)
  ///
  /// Set the matrix to skew by sx and sy, with a pivot point at (px, py). The pivot point is the
  /// coordinate that should remain unchanged by the specified transformation.
  void setSkew(double kx, double ky, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSkew,
          jni.JniType.voidType, [kx, ky, px, py]).check();

  static final _id_setSkew1 =
      jniAccessors.getMethodIDOf(_classRef, "setSkew", "(FF)V");

  /// from: public void setSkew(float kx, float ky)
  ///
  /// Set the matrix to skew by sx and sy.
  void setSkew1(double kx, double ky) => jniAccessors.callMethodWithArgs(
      reference, _id_setSkew1, jni.JniType.voidType, [kx, ky]).check();

  static final _id_setConcat = jniAccessors.getMethodIDOf(_classRef,
      "setConcat", "(Landroid/graphics/Matrix;Landroid/graphics/Matrix;)Z");

  /// from: public boolean setConcat(android.graphics.Matrix a, android.graphics.Matrix b)
  ///
  /// Set the matrix to the concatenation of the two specified matrices and return true.
  ///
  /// Either of the two matrices may also be the target matrix, that is
  /// <code>matrixA.setConcat(matrixA, matrixB);</code> is valid.
  ///
  ///
  /// <p class="note">
  /// In android.os.Build.VERSION_CODES\#GINGERBREAD_MR1 and below, this function returns
  /// true only if the result can be represented. In
  /// android.os.Build.VERSION_CODES\#HONEYCOMB and above, it always returns true.
  ///
  ///
  bool setConcat(Matrix a, Matrix b) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setConcat,
      jni.JniType.booleanType,
      [a.reference, b.reference]).boolean;

  static final _id_preTranslate =
      jniAccessors.getMethodIDOf(_classRef, "preTranslate", "(FF)Z");

  /// from: public boolean preTranslate(float dx, float dy)
  ///
  /// Preconcats the matrix with the specified translation. M' = M * T(dx, dy)
  bool preTranslate(double dx, double dy) => jniAccessors.callMethodWithArgs(
      reference, _id_preTranslate, jni.JniType.booleanType, [dx, dy]).boolean;

  static final _id_preScale =
      jniAccessors.getMethodIDOf(_classRef, "preScale", "(FFFF)Z");

  /// from: public boolean preScale(float sx, float sy, float px, float py)
  ///
  /// Preconcats the matrix with the specified scale. M' = M * S(sx, sy, px, py)
  bool preScale(double sx, double sy, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_preScale,
          jni.JniType.booleanType, [sx, sy, px, py]).boolean;

  static final _id_preScale1 =
      jniAccessors.getMethodIDOf(_classRef, "preScale", "(FF)Z");

  /// from: public boolean preScale(float sx, float sy)
  ///
  /// Preconcats the matrix with the specified scale. M' = M * S(sx, sy)
  bool preScale1(double sx, double sy) => jniAccessors.callMethodWithArgs(
      reference, _id_preScale1, jni.JniType.booleanType, [sx, sy]).boolean;

  static final _id_preRotate =
      jniAccessors.getMethodIDOf(_classRef, "preRotate", "(FFF)Z");

  /// from: public boolean preRotate(float degrees, float px, float py)
  ///
  /// Preconcats the matrix with the specified rotation. M' = M * R(degrees, px, py)
  bool preRotate(double degrees, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_preRotate,
          jni.JniType.booleanType, [degrees, px, py]).boolean;

  static final _id_preRotate1 =
      jniAccessors.getMethodIDOf(_classRef, "preRotate", "(F)Z");

  /// from: public boolean preRotate(float degrees)
  ///
  /// Preconcats the matrix with the specified rotation. M' = M * R(degrees)
  bool preRotate1(double degrees) => jniAccessors.callMethodWithArgs(
      reference, _id_preRotate1, jni.JniType.booleanType, [degrees]).boolean;

  static final _id_preSkew =
      jniAccessors.getMethodIDOf(_classRef, "preSkew", "(FFFF)Z");

  /// from: public boolean preSkew(float kx, float ky, float px, float py)
  ///
  /// Preconcats the matrix with the specified skew. M' = M * K(kx, ky, px, py)
  bool preSkew(double kx, double ky, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_preSkew,
          jni.JniType.booleanType, [kx, ky, px, py]).boolean;

  static final _id_preSkew1 =
      jniAccessors.getMethodIDOf(_classRef, "preSkew", "(FF)Z");

  /// from: public boolean preSkew(float kx, float ky)
  ///
  /// Preconcats the matrix with the specified skew. M' = M * K(kx, ky)
  bool preSkew1(double kx, double ky) => jniAccessors.callMethodWithArgs(
      reference, _id_preSkew1, jni.JniType.booleanType, [kx, ky]).boolean;

  static final _id_preConcat = jniAccessors.getMethodIDOf(
      _classRef, "preConcat", "(Landroid/graphics/Matrix;)Z");

  /// from: public boolean preConcat(android.graphics.Matrix other)
  ///
  /// Preconcats the matrix with the specified matrix. M' = M * other
  bool preConcat(Matrix other) => jniAccessors.callMethodWithArgs(reference,
      _id_preConcat, jni.JniType.booleanType, [other.reference]).boolean;

  static final _id_postTranslate =
      jniAccessors.getMethodIDOf(_classRef, "postTranslate", "(FF)Z");

  /// from: public boolean postTranslate(float dx, float dy)
  ///
  /// Postconcats the matrix with the specified translation. M' = T(dx, dy) * M
  bool postTranslate(double dx, double dy) => jniAccessors.callMethodWithArgs(
      reference, _id_postTranslate, jni.JniType.booleanType, [dx, dy]).boolean;

  static final _id_postScale =
      jniAccessors.getMethodIDOf(_classRef, "postScale", "(FFFF)Z");

  /// from: public boolean postScale(float sx, float sy, float px, float py)
  ///
  /// Postconcats the matrix with the specified scale. M' = S(sx, sy, px, py) * M
  bool postScale(double sx, double sy, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_postScale,
          jni.JniType.booleanType, [sx, sy, px, py]).boolean;

  static final _id_postScale1 =
      jniAccessors.getMethodIDOf(_classRef, "postScale", "(FF)Z");

  /// from: public boolean postScale(float sx, float sy)
  ///
  /// Postconcats the matrix with the specified scale. M' = S(sx, sy) * M
  bool postScale1(double sx, double sy) => jniAccessors.callMethodWithArgs(
      reference, _id_postScale1, jni.JniType.booleanType, [sx, sy]).boolean;

  static final _id_postRotate =
      jniAccessors.getMethodIDOf(_classRef, "postRotate", "(FFF)Z");

  /// from: public boolean postRotate(float degrees, float px, float py)
  ///
  /// Postconcats the matrix with the specified rotation. M' = R(degrees, px, py) * M
  bool postRotate(double degrees, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_postRotate,
          jni.JniType.booleanType, [degrees, px, py]).boolean;

  static final _id_postRotate1 =
      jniAccessors.getMethodIDOf(_classRef, "postRotate", "(F)Z");

  /// from: public boolean postRotate(float degrees)
  ///
  /// Postconcats the matrix with the specified rotation. M' = R(degrees) * M
  bool postRotate1(double degrees) => jniAccessors.callMethodWithArgs(
      reference, _id_postRotate1, jni.JniType.booleanType, [degrees]).boolean;

  static final _id_postSkew =
      jniAccessors.getMethodIDOf(_classRef, "postSkew", "(FFFF)Z");

  /// from: public boolean postSkew(float kx, float ky, float px, float py)
  ///
  /// Postconcats the matrix with the specified skew. M' = K(kx, ky, px, py) * M
  bool postSkew(double kx, double ky, double px, double py) =>
      jniAccessors.callMethodWithArgs(reference, _id_postSkew,
          jni.JniType.booleanType, [kx, ky, px, py]).boolean;

  static final _id_postSkew1 =
      jniAccessors.getMethodIDOf(_classRef, "postSkew", "(FF)Z");

  /// from: public boolean postSkew(float kx, float ky)
  ///
  /// Postconcats the matrix with the specified skew. M' = K(kx, ky) * M
  bool postSkew1(double kx, double ky) => jniAccessors.callMethodWithArgs(
      reference, _id_postSkew1, jni.JniType.booleanType, [kx, ky]).boolean;

  static final _id_postConcat = jniAccessors.getMethodIDOf(
      _classRef, "postConcat", "(Landroid/graphics/Matrix;)Z");

  /// from: public boolean postConcat(android.graphics.Matrix other)
  ///
  /// Postconcats the matrix with the specified matrix. M' = other * M
  bool postConcat(Matrix other) => jniAccessors.callMethodWithArgs(reference,
      _id_postConcat, jni.JniType.booleanType, [other.reference]).boolean;

  static final _id_setRectToRect = jniAccessors.getMethodIDOf(
      _classRef,
      "setRectToRect",
      "(Landroid/graphics/RectF;Landroid/graphics/RectF;Landroid/graphics/Matrix\$ScaleToFit;)Z");

  /// from: public boolean setRectToRect(android.graphics.RectF src, android.graphics.RectF dst, android.graphics.Matrix.ScaleToFit stf)
  ///
  /// Set the matrix to the scale and translate values that map the source rectangle to the
  /// destination rectangle, returning true if the the result can be represented.
  ///@param src the source rectangle to map from.
  ///@param dst the destination rectangle to map to.
  ///@param stf the ScaleToFit option
  ///@return true if the matrix can be represented by the rectangle mapping.
  bool setRectToRect(
          rectf_.RectF src, rectf_.RectF dst, Matrix_ScaleToFit stf) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRectToRect,
          jni.JniType.booleanType,
          [src.reference, dst.reference, stf.reference]).boolean;

  static final _id_setPolyToPoly =
      jniAccessors.getMethodIDOf(_classRef, "setPolyToPoly", "([FI[FII)Z");

  /// from: public boolean setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex, int pointCount)
  ///
  /// Set the matrix such that the specified src points would map to the specified dst points. The
  /// "points" are represented as an array of floats, order [x0, y0, x1, y1, ...], where each
  /// "point" is 2 float values.
  ///@param src The array of src [x,y] pairs (points)
  ///@param srcIndex Index of the first pair of src values
  ///@param dst The array of dst [x,y] pairs (points)
  ///@param dstIndex Index of the first pair of dst values
  ///@param pointCount The number of pairs/points to be used. Must be [0..4]
  ///@return true if the matrix was set to the specified transformation
  bool setPolyToPoly(jni.JniObject src, int srcIndex, jni.JniObject dst,
          int dstIndex, int pointCount) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setPolyToPoly, jni.JniType.booleanType, [
        src.reference,
        srcIndex,
        dst.reference,
        dstIndex,
        pointCount
      ]).boolean;

  static final _id_invert = jniAccessors.getMethodIDOf(
      _classRef, "invert", "(Landroid/graphics/Matrix;)Z");

  /// from: public boolean invert(android.graphics.Matrix inverse)
  ///
  /// If this matrix can be inverted, return true and if inverse is not null, set inverse to be the
  /// inverse of this matrix. If this matrix cannot be inverted, ignore inverse and return false.
  bool invert(Matrix inverse) => jniAccessors.callMethodWithArgs(reference,
      _id_invert, jni.JniType.booleanType, [inverse.reference]).boolean;

  static final _id_mapPoints =
      jniAccessors.getMethodIDOf(_classRef, "mapPoints", "([FI[FII)V");

  /// from: public void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex, int pointCount)
  ///
  /// Apply this matrix to the array of 2D points specified by src, and write the transformed
  /// points into the array of points specified by dst. The two arrays represent their "points" as
  /// pairs of floats [x, y].
  ///@param dst The array of dst points (x,y pairs)
  ///@param dstIndex The index of the first [x,y] pair of dst floats
  ///@param src The array of src points (x,y pairs)
  ///@param srcIndex The index of the first [x,y] pair of src floats
  ///@param pointCount The number of points (x,y pairs) to transform
  void mapPoints(jni.JniObject dst, int dstIndex, jni.JniObject src,
          int srcIndex, int pointCount) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_mapPoints, jni.JniType.voidType, [
        dst.reference,
        dstIndex,
        src.reference,
        srcIndex,
        pointCount
      ]).check();

  static final _id_mapVectors =
      jniAccessors.getMethodIDOf(_classRef, "mapVectors", "([FI[FII)V");

  /// from: public void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex, int vectorCount)
  ///
  /// Apply this matrix to the array of 2D vectors specified by src, and write the transformed
  /// vectors into the array of vectors specified by dst. The two arrays represent their "vectors"
  /// as pairs of floats [x, y]. Note: this method does not apply the translation associated with
  /// the matrix. Use Matrix\#mapPoints(float[], int, float[], int, int) if you want the
  /// translation to be applied.
  ///@param dst The array of dst vectors (x,y pairs)
  ///@param dstIndex The index of the first [x,y] pair of dst floats
  ///@param src The array of src vectors (x,y pairs)
  ///@param srcIndex The index of the first [x,y] pair of src floats
  ///@param vectorCount The number of vectors (x,y pairs) to transform
  void mapVectors(jni.JniObject dst, int dstIndex, jni.JniObject src,
          int srcIndex, int vectorCount) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_mapVectors, jni.JniType.voidType, [
        dst.reference,
        dstIndex,
        src.reference,
        srcIndex,
        vectorCount
      ]).check();

  static final _id_mapPoints1 =
      jniAccessors.getMethodIDOf(_classRef, "mapPoints", "([F[F)V");

  /// from: public void mapPoints(float[] dst, float[] src)
  ///
  /// Apply this matrix to the array of 2D points specified by src, and write the transformed
  /// points into the array of points specified by dst. The two arrays represent their "points" as
  /// pairs of floats [x, y].
  ///@param dst The array of dst points (x,y pairs)
  ///@param src The array of src points (x,y pairs)
  void mapPoints1(jni.JniObject dst, jni.JniObject src) =>
      jniAccessors.callMethodWithArgs(reference, _id_mapPoints1,
          jni.JniType.voidType, [dst.reference, src.reference]).check();

  static final _id_mapVectors1 =
      jniAccessors.getMethodIDOf(_classRef, "mapVectors", "([F[F)V");

  /// from: public void mapVectors(float[] dst, float[] src)
  ///
  /// Apply this matrix to the array of 2D vectors specified by src, and write the transformed
  /// vectors into the array of vectors specified by dst. The two arrays represent their "vectors"
  /// as pairs of floats [x, y]. Note: this method does not apply the translation associated with
  /// the matrix. Use Matrix\#mapPoints(float[], float[]) if you want the translation to be
  /// applied.
  ///@param dst The array of dst vectors (x,y pairs)
  ///@param src The array of src vectors (x,y pairs)
  void mapVectors1(jni.JniObject dst, jni.JniObject src) =>
      jniAccessors.callMethodWithArgs(reference, _id_mapVectors1,
          jni.JniType.voidType, [dst.reference, src.reference]).check();

  static final _id_mapPoints2 =
      jniAccessors.getMethodIDOf(_classRef, "mapPoints", "([F)V");

  /// from: public void mapPoints(float[] pts)
  ///
  /// Apply this matrix to the array of 2D points, and write the transformed points back into the
  /// array
  ///@param pts The array [x0, y0, x1, y1, ...] of points to transform.
  void mapPoints2(jni.JniObject pts) => jniAccessors.callMethodWithArgs(
      reference, _id_mapPoints2, jni.JniType.voidType, [pts.reference]).check();

  static final _id_mapVectors2 =
      jniAccessors.getMethodIDOf(_classRef, "mapVectors", "([F)V");

  /// from: public void mapVectors(float[] vecs)
  ///
  /// Apply this matrix to the array of 2D vectors, and write the transformed vectors back into the
  /// array. Note: this method does not apply the translation associated with the matrix. Use
  /// Matrix\#mapPoints(float[]) if you want the translation to be applied.
  ///@param vecs The array [x0, y0, x1, y1, ...] of vectors to transform.
  void mapVectors2(jni.JniObject vecs) => jniAccessors.callMethodWithArgs(
      reference,
      _id_mapVectors2,
      jni.JniType.voidType,
      [vecs.reference]).check();

  static final _id_mapRect = jniAccessors.getMethodIDOf(_classRef, "mapRect",
      "(Landroid/graphics/RectF;Landroid/graphics/RectF;)Z");

  /// from: public boolean mapRect(android.graphics.RectF dst, android.graphics.RectF src)
  ///
  /// Apply this matrix to the src rectangle, and write the transformed rectangle into dst. This is
  /// accomplished by transforming the 4 corners of src, and then setting dst to the bounds of
  /// those points.
  ///@param dst Where the transformed rectangle is written.
  ///@param src The original rectangle to be transformed.
  ///@return the result of calling rectStaysRect()
  bool mapRect(rectf_.RectF dst, rectf_.RectF src) =>
      jniAccessors.callMethodWithArgs(reference, _id_mapRect,
          jni.JniType.booleanType, [dst.reference, src.reference]).boolean;

  static final _id_mapRect1 = jniAccessors.getMethodIDOf(
      _classRef, "mapRect", "(Landroid/graphics/RectF;)Z");

  /// from: public boolean mapRect(android.graphics.RectF rect)
  ///
  /// Apply this matrix to the rectangle, and write the transformed rectangle back into it. This is
  /// accomplished by transforming the 4 corners of rect, and then setting it to the bounds of
  /// those points
  ///@param rect The rectangle to transform.
  ///@return the result of calling rectStaysRect()
  bool mapRect1(rectf_.RectF rect) => jniAccessors.callMethodWithArgs(reference,
      _id_mapRect1, jni.JniType.booleanType, [rect.reference]).boolean;

  static final _id_mapRadius =
      jniAccessors.getMethodIDOf(_classRef, "mapRadius", "(F)F");

  /// from: public float mapRadius(float radius)
  ///
  /// Return the mean radius of a circle after it has been mapped by this matrix. NOTE: in
  /// perspective this value assumes the circle has its center at the origin.
  double mapRadius(double radius) => jniAccessors.callMethodWithArgs(
      reference, _id_mapRadius, jni.JniType.floatType, [radius]).float;

  static final _id_getValues =
      jniAccessors.getMethodIDOf(_classRef, "getValues", "([F)V");

  /// from: public void getValues(float[] values)
  ///
  /// Copy 9 values from the matrix into the array.
  void getValues(jni.JniObject values) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getValues,
      jni.JniType.voidType,
      [values.reference]).check();

  static final _id_setValues =
      jniAccessors.getMethodIDOf(_classRef, "setValues", "([F)V");

  /// from: public void setValues(float[] values)
  ///
  /// Copy 9 values from the array into the matrix. Depending on the implementation of Matrix,
  /// these may be transformed into 16.16 integers in the Matrix, such that a subsequent call to
  /// getValues() will not yield exactly the same values.
  void setValues(jni.JniObject values) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setValues,
      jni.JniType.voidType,
      [values.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_toShortString = jniAccessors.getMethodIDOf(
      _classRef, "toShortString", "()Ljava/lang/String;");

  /// from: public java.lang.String toShortString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toShortString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toShortString, jni.JniType.objectType, []).object);
}

/// from: android.graphics.Matrix$ScaleToFit
///
/// Controlls how the src rect should align into the dst rect for setRectToRect().
class Matrix_ScaleToFit extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Matrix\$ScaleToFit");
  Matrix_ScaleToFit.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Matrix\$ScaleToFit;");

  /// from: static public android.graphics.Matrix.ScaleToFit[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Matrix\$ScaleToFit;");

  /// from: static public android.graphics.Matrix.ScaleToFit valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Matrix_ScaleToFit valueOf(jni.JniString name) =>
      Matrix_ScaleToFit.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Matrix_ScaleToFit()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
