// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.ColorSpace
///
/// {@usesMathJax }
///
/// A ColorSpace is used to identify a specific organization of colors.
/// Each color space is characterized by a Model color model that defines
/// how a color value is represented (for instance the Model\#RGB RGB color
/// model defines a color value as a triplet of numbers).
///
///
/// Each component of a color must fall within a valid range, specific to each
/// color space, defined by \#getMinValue(int) and \#getMaxValue(int)
/// This range is commonly \([0..1]\). While it is recommended to use values in the
/// valid range, a color space always clamps input and output values when performing
/// operations such as converting to a different color space.
///
///
/// <h3>Using color spaces</h3>
///
/// This implementation provides a pre-defined set of common color spaces
/// described in the Named enum. To obtain an instance of one of the
/// pre-defined color spaces, simply invoke \#get(Named):
///
///
/// <pre class="prettyprint">
/// ColorSpace sRgb = ColorSpace.get(ColorSpace.Named.SRGB);
/// </pre>
///
/// The \#get(Named) method always returns the same instance for a given
/// name. Color spaces with an Model\#RGB RGB color model can be safely
/// cast to Rgb. Doing so gives you access to more APIs to query various
/// properties of RGB color models: color gamut primaries, transfer functions,
/// conversions to and from linear space, etc. Please refer to Rgb for
/// more information.
///
///
/// The documentation of Named provides a detailed description of the
/// various characteristics of each available color space.
///
///
/// <h3>Color space conversions</h3>
///
/// To allow conversion between color spaces, this implementation uses the CIE
/// XYZ profile connection space (PCS). Color values can be converted to and from
/// this PCS using \#toXyz(float[]) and \#fromXyz(float[]).
///
///
/// For color space with a non-RGB color model, the white point of the PCS
/// _must be_ the CIE standard illuminant D50. RGB color spaces use their
/// native white point (D65 for Named\#SRGB sRGB for instance and must
/// undergo Adaptation chromatic adaptation as necessary.
///
///
/// Since the white point of the PCS is not defined for RGB color space, it is
/// highly recommended to use the variants of the \#connect(ColorSpace, ColorSpace)
/// method to perform conversions between color spaces. A color space can be
/// manually adapted to a specific white point using \#adapt(ColorSpace, float[]).
/// Please refer to the documentation of Rgb RGB color spaces for more
/// information. Several common CIE standard illuminants are provided in this
/// class as reference (see \#ILLUMINANT_D65 or \#ILLUMINANT_D50
/// for instance).
///
///
/// Here is an example of how to convert from a color space to another:
///
///
/// <pre class="prettyprint">
/// // Convert from DCI-P3 to Rec.2020
/// ColorSpace.Connector connector = ColorSpace.connect(
///         ColorSpace.get(ColorSpace.Named.DCI_P3),
///         ColorSpace.get(ColorSpace.Named.BT2020));
///
/// float[] bt2020 = connector.transform(p3r, p3g, p3b);
/// </pre>
///
/// You can easily convert to Named\#SRGB sRGB by omitting the second
/// parameter:
///
///
/// <pre class="prettyprint">
/// // Convert from DCI-P3 to sRGB
/// ColorSpace.Connector connector = ColorSpace.connect(ColorSpace.get(ColorSpace.Named.DCI_P3));
///
/// float[] sRGB = connector.transform(p3r, p3g, p3b);
/// </pre>
///
/// Conversions also work between color spaces with different color models:
///
///
/// <pre class="prettyprint">
/// // Convert from CIE L*a*b* (color model Lab) to Rec.709 (color model RGB)
/// ColorSpace.Connector connector = ColorSpace.connect(
///         ColorSpace.get(ColorSpace.Named.CIE_LAB),
///         ColorSpace.get(ColorSpace.Named.BT709));
/// </pre>
///
/// <h3>Color spaces and multi-threading</h3>
///
/// Color spaces and other related classes (Connector for instance)
/// are immutable and stateless. They can be safely used from multiple concurrent
/// threads.
///
///
/// Public static methods provided by this class, such as \#get(Named)
/// and \#connect(ColorSpace, ColorSpace), are also guaranteed to be
/// thread-safe.
///
///@see \#get(Named)
///@see Named
///@see Model
///@see Connector
///@see Adaptation
class ColorSpace extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ColorSpace");
  ColorSpace.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ILLUMINANT_A =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_A", "[F");

  /// from: static public final float[] ILLUMINANT_A
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant A, encoded in xyY.
  /// This illuminant has a color temperature of 2856K.
  static jni.JniObject get ILLUMINANT_A => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_A, jni.JniType.objectType)
      .object);

  static final _id_ILLUMINANT_B =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_B", "[F");

  /// from: static public final float[] ILLUMINANT_B
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant B, encoded in xyY.
  /// This illuminant has a color temperature of 4874K.
  static jni.JniObject get ILLUMINANT_B => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_B, jni.JniType.objectType)
      .object);

  static final _id_ILLUMINANT_C =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_C", "[F");

  /// from: static public final float[] ILLUMINANT_C
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant C, encoded in xyY.
  /// This illuminant has a color temperature of 6774K.
  static jni.JniObject get ILLUMINANT_C => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_C, jni.JniType.objectType)
      .object);

  static final _id_ILLUMINANT_D50 =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_D50", "[F");

  /// from: static public final float[] ILLUMINANT_D50
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant D50, encoded in xyY.
  /// This illuminant has a color temperature of 5003K. This illuminant
  /// is used by the profile connection space in ICC profiles.
  static jni.JniObject get ILLUMINANT_D50 => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_D50, jni.JniType.objectType)
      .object);

  static final _id_ILLUMINANT_D55 =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_D55", "[F");

  /// from: static public final float[] ILLUMINANT_D55
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant D55, encoded in xyY.
  /// This illuminant has a color temperature of 5503K.
  static jni.JniObject get ILLUMINANT_D55 => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_D55, jni.JniType.objectType)
      .object);

  static final _id_ILLUMINANT_D60 =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_D60", "[F");

  /// from: static public final float[] ILLUMINANT_D60
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant D60, encoded in xyY.
  /// This illuminant has a color temperature of 6004K.
  static jni.JniObject get ILLUMINANT_D60 => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_D60, jni.JniType.objectType)
      .object);

  static final _id_ILLUMINANT_D65 =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_D65", "[F");

  /// from: static public final float[] ILLUMINANT_D65
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant D65, encoded in xyY.
  /// This illuminant has a color temperature of 6504K. This illuminant
  /// is commonly used in RGB color spaces such as sRGB, BT.209, etc.
  static jni.JniObject get ILLUMINANT_D65 => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_D65, jni.JniType.objectType)
      .object);

  static final _id_ILLUMINANT_D75 =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_D75", "[F");

  /// from: static public final float[] ILLUMINANT_D75
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant D75, encoded in xyY.
  /// This illuminant has a color temperature of 7504K.
  static jni.JniObject get ILLUMINANT_D75 => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_D75, jni.JniType.objectType)
      .object);

  static final _id_ILLUMINANT_E =
      jniAccessors.getStaticFieldIDOf(_classRef, "ILLUMINANT_E", "[F");

  /// from: static public final float[] ILLUMINANT_E
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard CIE 1931 2° illuminant E, encoded in xyY.
  /// This illuminant has a color temperature of 5454K.
  static jni.JniObject get ILLUMINANT_E => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ILLUMINANT_E, jni.JniType.objectType)
      .object);

  /// from: static public final int MAX_ID
  ///
  /// The maximum ID value a color space can have.
  ///@see \#getId()
  static const MAX_ID = 63;

  /// from: static public final int MIN_ID
  ///
  /// The minimum ID value a color space can have.
  ///@see \#getId()
  static const MIN_ID = -1;

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Landroid/graphics/ColorSpace\$Model;I)V");

  /// from: void <init>(java.lang.String name, android.graphics.ColorSpace.Model model, int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ColorSpace(jni.JniString name, ColorSpace_Model model, int id)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [name.reference, model.reference, id]).object);

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of this color space. The name is never null
  /// and contains always at least 1 character.
  ///
  ///
  /// Color space names are recommended to be unique but are not
  /// guaranteed to be. There is no defined format but the name usually
  /// falls in one of the following categories:
  ///
  /// <ul>
  ///     <li>Generic names used to identify color spaces in non-RGB
  ///     color models. For instance: Named\#CIE_LAB Generic L*a*b*.</li>
  ///     <li>Names tied to a particular specification. For instance:
  ///     Named\#SRGB sRGB IEC61966-2.1 or
  ///     Named\#ACES SMPTE ST 2065-1:2012 ACES.</li>
  ///     <li>Ad-hoc names, often generated procedurally or by the user
  ///     during a calibration workflow. These names often contain the
  ///     make and model of the display.</li>
  /// </ul>
  ///
  /// Because the format of color space names is not defined, it is
  /// not recommended to programmatically identify a color space by its
  /// name alone. Names can be used as a first approximation.
  ///
  ///
  /// It is however perfectly acceptable to display color space names to
  /// users in a UI, or in debuggers and logs. When displaying a color space
  /// name to the user, it is recommended to add extra information to avoid
  /// ambiguities: color model, a representation of the color space's gamut,
  /// white point, etc.
  ///
  ///@return A non-null String of length >= 1
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// Returns the ID of this color space. Positive IDs match the color
  /// spaces enumerated in Named. A negative ID indicates a
  /// color space created by calling one of the public constructors.
  ///@return An integer between \#MIN_ID and \#MAX_ID
  ///
  /// Value is between MIN_ID and MAX_ID inclusive
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getModel = jniAccessors.getMethodIDOf(
      _classRef, "getModel", "()Landroid/graphics/ColorSpace\$Model;");

  /// from: public android.graphics.ColorSpace.Model getModel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the color model of this color space.
  ///@return A non-null Model
  ///@see Model
  ///@see \#getComponentCount()
  ColorSpace_Model getModel() =>
      ColorSpace_Model.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getModel, jni.JniType.objectType, []).object);

  static final _id_getComponentCount =
      jniAccessors.getMethodIDOf(_classRef, "getComponentCount", "()I");

  /// from: public int getComponentCount()
  ///
  /// Returns the number of components that form a color value according
  /// to this color space's color model.
  ///@return An integer between 1 and 4
  ///
  /// Value is between 1 and 4 inclusive
  ///@see Model
  ///@see \#getModel()
  int getComponentCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getComponentCount, jni.JniType.intType, []).integer;

  static final _id_isWideGamut =
      jniAccessors.getMethodIDOf(_classRef, "isWideGamut", "()Z");

  /// from: public abstract boolean isWideGamut()
  ///
  /// Returns whether this color space is a wide-gamut color space.
  /// An RGB color space is wide-gamut if its gamut entirely contains
  /// the Named\#SRGB sRGB gamut and if the area of its gamut is
  /// 90% of greater than the area of the Named\#NTSC_1953 NTSC
  /// gamut.
  ///@return True if this color space is a wide-gamut color space,
  ///         false otherwise
  bool isWideGamut() => jniAccessors.callMethodWithArgs(
      reference, _id_isWideGamut, jni.JniType.booleanType, []).boolean;

  static final _id_isSrgb =
      jniAccessors.getMethodIDOf(_classRef, "isSrgb", "()Z");

  /// from: public boolean isSrgb()
  ///
  /// Indicates whether this color space is the sRGB color space or
  /// equivalent to the sRGB color space.
  ///
  /// A color space is considered sRGB if it meets all the following
  /// conditions:
  ///
  /// <ul>
  ///     <li>Its color model is Model\#RGB.</li>
  ///     <li>
  ///         Its primaries are within 1e-3 of the true
  ///         Named\#SRGB sRGB primaries.
  ///     </li>
  ///     <li>
  ///         Its white point is withing 1e-3 of the CIE standard
  ///         illuminant \#ILLUMINANT_D65 D65.
  ///     </li>
  ///     <li>Its opto-electronic transfer function is not linear.</li>
  ///     <li>Its electro-optical transfer function is not linear.</li>
  ///     <li>Its range is \([0..1]\).</li>
  /// </ul>
  /// This method always returns true for Named\#SRGB.
  ///
  ///@return True if this color space is the sRGB color space (or a
  ///         close approximation), false otherwise
  bool isSrgb() => jniAccessors.callMethodWithArgs(
      reference, _id_isSrgb, jni.JniType.booleanType, []).boolean;

  static final _id_getMinValue =
      jniAccessors.getMethodIDOf(_classRef, "getMinValue", "(I)F");

  /// from: public abstract float getMinValue(int component)
  ///
  /// Returns the minimum valid value for the specified component of this
  /// color space's color model.
  ///@param component The index of the component
  /// Value is between 0 and 3 inclusive
  ///@return A floating point value less than \#getMaxValue(int)
  ///@see \#getMaxValue(int)
  ///@see Model\#getComponentCount()
  double getMinValue(int component) => jniAccessors.callMethodWithArgs(
      reference, _id_getMinValue, jni.JniType.floatType, [component]).float;

  static final _id_getMaxValue =
      jniAccessors.getMethodIDOf(_classRef, "getMaxValue", "(I)F");

  /// from: public abstract float getMaxValue(int component)
  ///
  /// Returns the maximum valid value for the specified component of this
  /// color space's color model.
  ///@param component The index of the component
  /// Value is between 0 and 3 inclusive
  ///@return A floating point value greater than \#getMinValue(int)
  ///@see \#getMinValue(int)
  ///@see Model\#getComponentCount()
  double getMaxValue(int component) => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxValue, jni.JniType.floatType, [component]).float;

  static final _id_toXyz =
      jniAccessors.getMethodIDOf(_classRef, "toXyz", "(FFF)[F");

  /// from: public float[] toXyz(float r, float g, float b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a color value from this color space's model to
  /// tristimulus CIE XYZ values. If the color model of this color
  /// space is not Model\#RGB RGB, it is assumed that the
  /// target CIE XYZ space uses a \#ILLUMINANT_D50 D50
  /// standard illuminant.
  ///
  ///
  /// This method is a convenience for color spaces with a model
  /// of 3 components (Model\#RGB RGB or Model\#LAB
  /// for instance). With color spaces using fewer or more components,
  /// use \#toXyz(float[]) instead
  ///.
  ///@param r The first component of the value to convert from (typically R in RGB)
  ///@param g The second component of the value to convert from (typically G in RGB)
  ///@param b The third component of the value to convert from (typically B in RGB)
  ///@return A new array of 3 floats, containing tristimulus XYZ values
  ///
  /// This value will never be {@code null}.
  ///@see \#toXyz(float[])
  ///@see \#fromXyz(float, float, float)
  jni.JniObject toXyz(double r, double g, double b) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toXyz, jni.JniType.objectType, [r, g, b]).object);

  static final _id_toXyz1 =
      jniAccessors.getMethodIDOf(_classRef, "toXyz", "([F)[F");

  /// from: public abstract float[] toXyz(float[] v)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a color value from this color space's model to
  /// tristimulus CIE XYZ values. If the color model of this color
  /// space is not Model\#RGB RGB, it is assumed that the
  /// target CIE XYZ space uses a \#ILLUMINANT_D50 D50
  /// standard illuminant.
  ///
  ///
  /// <p class="note">The specified array's length  must be at least
  /// equal to to the number of color components as returned by
  /// Model\#getComponentCount().
  ///
  ///@param v An array of color components containing the color space's
  ///          color value to convert to XYZ, and large enough to hold
  ///          the resulting tristimulus XYZ values
  /// This value must never be {@code null}.
  ///@return The array passed in parameter
  ///
  /// This value will never be {@code null}.
  ///@see \#toXyz(float, float, float)
  ///@see \#fromXyz(float[])
  jni.JniObject toXyz1(jni.JniObject v) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toXyz1, jni.JniType.objectType, [v.reference]).object);

  static final _id_fromXyz =
      jniAccessors.getMethodIDOf(_classRef, "fromXyz", "(FFF)[F");

  /// from: public float[] fromXyz(float x, float y, float z)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts tristimulus values from the CIE XYZ space to this
  /// color space's color model.
  ///
  ///@param x The X component of the color value
  ///@param y The Y component of the color value
  ///@param z The Z component of the color value
  ///@return A new array whose size is equal to the number of color
  ///         components as returned by Model\#getComponentCount()
  ///
  /// This value will never be {@code null}.
  ///@see \#fromXyz(float[])
  ///@see \#toXyz(float, float, float)
  jni.JniObject fromXyz(double x, double y, double z) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_fromXyz, jni.JniType.objectType, [x, y, z]).object);

  static final _id_fromXyz1 =
      jniAccessors.getMethodIDOf(_classRef, "fromXyz", "([F)[F");

  /// from: public abstract float[] fromXyz(float[] v)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts tristimulus values from the CIE XYZ space to this color
  /// space's color model. The resulting value is passed back in the specified
  /// array.
  ///
  ///
  /// <p class="note">The specified array's length  must be at least equal to
  /// to the number of color components as returned by
  /// Model\#getComponentCount(), and its first 3 values must
  /// be the XYZ components to convert from.
  ///
  ///@param v An array of color components containing the XYZ values
  ///          to convert from, and large enough to hold the number
  ///          of components of this color space's model
  /// This value must never be {@code null}.
  ///@return The array passed in parameter
  ///
  /// This value will never be {@code null}.
  ///@see \#fromXyz(float, float, float)
  ///@see \#toXyz(float[])
  jni.JniObject fromXyz1(jni.JniObject v) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_fromXyz1, jni.JniType.objectType, [v.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string representation of the object. This method returns
  /// a string equal to the value of:
  ///
  ///
  /// <pre class="prettyprint">
  /// getName() + "(id=" + getId() + ", model=" + getModel() + ")"
  /// </pre>
  ///
  /// For instance, the string representation of the Named\#SRGB sRGB
  /// color space is equal to the following value:
  ///
  ///
  /// <pre>
  /// sRGB IEC61966-2.1 (id=0, model=RGB)
  /// </pre>
  ///@return A string representation of the object
  ///
  /// This value will never be {@code null}.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_connect = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "connect",
      "(Landroid/graphics/ColorSpace;Landroid/graphics/ColorSpace;)Landroid/graphics/ColorSpace\$Connector;");

  /// from: static public android.graphics.ColorSpace.Connector connect(android.graphics.ColorSpace source, android.graphics.ColorSpace destination)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Connects two color spaces to allow conversion from the source color
  /// space to the destination color space. If the source and destination
  /// color spaces do not have the same profile connection space (CIE XYZ
  /// with the same white point), they are chromatically adapted to use the
  /// CIE standard illuminant \#ILLUMINANT_D50 D50 as needed.
  ///
  ///
  /// If the source and destination are the same, an optimized connector
  /// is returned to avoid unnecessary computations and loss of precision.
  ///
  ///
  /// Colors are mapped from the source color space to the destination color
  /// space using the RenderIntent\#PERCEPTUAL perceptual render intent.
  ///
  ///@param source The color space to convert colors from
  /// This value must never be {@code null}.
  ///@param destination The color space to convert colors to
  /// This value must never be {@code null}.
  ///@return A non-null connector between the two specified color spaces
  ///@see \#connect(ColorSpace)
  ///@see \#connect(ColorSpace, RenderIntent)
  ///@see \#connect(ColorSpace, ColorSpace, RenderIntent)
  static ColorSpace_Connector connect(
          ColorSpace source, ColorSpace destination) =>
      ColorSpace_Connector.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_connect,
          jni.JniType.objectType,
          [source.reference, destination.reference]).object);

  static final _id_connect1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "connect",
      "(Landroid/graphics/ColorSpace;Landroid/graphics/ColorSpace;Landroid/graphics/ColorSpace\$RenderIntent;)Landroid/graphics/ColorSpace\$Connector;");

  /// from: static public android.graphics.ColorSpace.Connector connect(android.graphics.ColorSpace source, android.graphics.ColorSpace destination, android.graphics.ColorSpace.RenderIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Connects two color spaces to allow conversion from the source color
  /// space to the destination color space. If the source and destination
  /// color spaces do not have the same profile connection space (CIE XYZ
  /// with the same white point), they are chromatically adapted to use the
  /// CIE standard illuminant \#ILLUMINANT_D50 D50 as needed.
  ///
  ///
  /// If the source and destination are the same, an optimized connector
  /// is returned to avoid unnecessary computations and loss of precision.
  ///
  ///@param source The color space to convert colors from
  /// This value must never be {@code null}.
  ///@param destination The color space to convert colors to
  /// This value must never be {@code null}.
  ///@param intent The render intent to map colors from the source to the destination
  /// This value must never be {@code null}.
  ///@return A non-null connector between the two specified color spaces
  ///@see \#connect(ColorSpace)
  ///@see \#connect(ColorSpace, RenderIntent)
  ///@see \#connect(ColorSpace, ColorSpace)
  static ColorSpace_Connector connect1(ColorSpace source,
          ColorSpace destination, ColorSpace_RenderIntent intent) =>
      ColorSpace_Connector.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_connect1,
          jni.JniType.objectType,
          [source.reference, destination.reference, intent.reference]).object);

  static final _id_connect2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "connect",
      "(Landroid/graphics/ColorSpace;)Landroid/graphics/ColorSpace\$Connector;");

  /// from: static public android.graphics.ColorSpace.Connector connect(android.graphics.ColorSpace source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Connects the specified color spaces to sRGB.
  /// If the source color space does not use CIE XYZ D65 as its profile
  /// connection space, the two spaces are chromatically adapted to use the
  /// CIE standard illuminant \#ILLUMINANT_D50 D50 as needed.
  ///
  ///
  /// If the source is the sRGB color space, an optimized connector
  /// is returned to avoid unnecessary computations and loss of precision.
  ///
  ///
  /// Colors are mapped from the source color space to the destination color
  /// space using the RenderIntent\#PERCEPTUAL perceptual render intent.
  ///
  ///@param source The color space to convert colors from
  /// This value must never be {@code null}.
  ///@return A non-null connector between the specified color space and sRGB
  ///@see \#connect(ColorSpace, RenderIntent)
  ///@see \#connect(ColorSpace, ColorSpace)
  ///@see \#connect(ColorSpace, ColorSpace, RenderIntent)
  static ColorSpace_Connector connect2(ColorSpace source) =>
      ColorSpace_Connector.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_connect2,
          jni.JniType.objectType,
          [source.reference]).object);

  static final _id_connect3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "connect",
      "(Landroid/graphics/ColorSpace;Landroid/graphics/ColorSpace\$RenderIntent;)Landroid/graphics/ColorSpace\$Connector;");

  /// from: static public android.graphics.ColorSpace.Connector connect(android.graphics.ColorSpace source, android.graphics.ColorSpace.RenderIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Connects the specified color spaces to sRGB.
  /// If the source color space does not use CIE XYZ D65 as its profile
  /// connection space, the two spaces are chromatically adapted to use the
  /// CIE standard illuminant \#ILLUMINANT_D50 D50 as needed.
  ///
  ///
  /// If the source is the sRGB color space, an optimized connector
  /// is returned to avoid unnecessary computations and loss of precision.
  ///
  ///@param source The color space to convert colors from
  /// This value must never be {@code null}.
  ///@param intent The render intent to map colors from the source to the destination
  /// This value must never be {@code null}.
  ///@return A non-null connector between the specified color space and sRGB
  ///@see \#connect(ColorSpace)
  ///@see \#connect(ColorSpace, ColorSpace)
  ///@see \#connect(ColorSpace, ColorSpace, RenderIntent)
  static ColorSpace_Connector connect3(
          ColorSpace source, ColorSpace_RenderIntent intent) =>
      ColorSpace_Connector.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_connect3,
          jni.JniType.objectType,
          [source.reference, intent.reference]).object);

  static final _id_adapt = jniAccessors.getStaticMethodIDOf(_classRef, "adapt",
      "(Landroid/graphics/ColorSpace;[F)Landroid/graphics/ColorSpace;");

  /// from: static public android.graphics.ColorSpace adapt(android.graphics.ColorSpace colorSpace, float[] whitePoint)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Performs the chromatic adaptation of a color space from its native
  /// white point to the specified white point.
  ///
  ///
  /// The chromatic adaptation is performed using the
  /// Adaptation\#BRADFORD matrix.
  ///
  ///
  /// <p class="note">The color space returned by this method always has
  /// an ID of \#MIN_ID.
  ///
  ///@param colorSpace The color space to chromatically adapt
  /// This value must never be {@code null}.
  ///@param whitePoint The new white point
  /// This value must never be {@code null}.
  ///@return A ColorSpace instance with the same name, primaries,
  ///         transfer functions and range as the specified color space
  ///
  /// This value will never be {@code null}.
  ///@see Adaptation
  ///@see \#adapt(ColorSpace, float[], Adaptation)
  static ColorSpace adapt(ColorSpace colorSpace, jni.JniObject whitePoint) =>
      ColorSpace.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_adapt,
          jni.JniType.objectType,
          [colorSpace.reference, whitePoint.reference]).object);

  static final _id_adapt1 = jniAccessors.getStaticMethodIDOf(_classRef, "adapt",
      "(Landroid/graphics/ColorSpace;[FLandroid/graphics/ColorSpace\$Adaptation;)Landroid/graphics/ColorSpace;");

  /// from: static public android.graphics.ColorSpace adapt(android.graphics.ColorSpace colorSpace, float[] whitePoint, android.graphics.ColorSpace.Adaptation adaptation)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Performs the chromatic adaptation of a color space from its native
  /// white point to the specified white point. If the specified color space
  /// does not have an Model\#RGB RGB color model, or if the color
  /// space already has the target white point, the color space is returned
  /// unmodified.
  ///
  ///
  /// The chromatic adaptation is performed using the von Kries method
  /// described in the documentation of Adaptation.
  ///
  ///
  /// <p class="note">The color space returned by this method always has
  /// an ID of \#MIN_ID.
  ///
  ///@param colorSpace The color space to chromatically adapt
  /// This value must never be {@code null}.
  ///@param whitePoint The new white point
  /// This value must never be {@code null}.
  ///@param adaptation The adaptation matrix
  /// This value must never be {@code null}.
  ///@return A new color space if the specified color space has an RGB
  ///         model and a white point different from the specified white
  ///         point; the specified color space otherwise
  ///
  /// This value will never be {@code null}.
  ///@see Adaptation
  ///@see \#adapt(ColorSpace, float[])
  static ColorSpace adapt1(ColorSpace colorSpace, jni.JniObject whitePoint,
          ColorSpace_Adaptation adaptation) =>
      ColorSpace.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_adapt1, jni.JniType.objectType, [
        colorSpace.reference,
        whitePoint.reference,
        adaptation.reference
      ]).object);

  static final _id_get0 = jniAccessors.getStaticMethodIDOf(_classRef, "get",
      "(Landroid/graphics/ColorSpace\$Named;)Landroid/graphics/ColorSpace;");

  /// from: static public android.graphics.ColorSpace get(android.graphics.ColorSpace.Named name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an instance of ColorSpace identified by the specified
  /// name. The list of names provided in the Named enum gives access
  /// to a variety of common RGB color spaces.
  ///
  ///
  /// This method always returns the same instance for a given name.
  ///
  ///
  /// This method is thread-safe.
  ///
  ///@param name The name of the color space to get an instance of
  /// This value must never be {@code null}.
  ///@return A non-null ColorSpace instance
  static ColorSpace get0(ColorSpace_Named name) =>
      ColorSpace.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_get0, jni.JniType.objectType, [name.reference]).object);

  static final _id_match = jniAccessors.getStaticMethodIDOf(_classRef, "match",
      "([FLandroid/graphics/ColorSpace\$Rgb\$TransferParameters;)Landroid/graphics/ColorSpace;");

  /// from: static public android.graphics.ColorSpace match(float[] toXYZD50, android.graphics.ColorSpace.Rgb.TransferParameters function)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Named instance of ColorSpace that matches
  /// the specified RGB to CIE XYZ transform and transfer functions. If no
  /// instance can be found, this method returns null.
  ///
  ///
  /// The color transform matrix is assumed to target the CIE XYZ space
  /// a \#ILLUMINANT_D50 D50 standard illuminant.
  ///
  ///@param toXYZD50 3x3 column-major transform matrix from RGB to the profile
  ///                 connection space CIE XYZ as an array of 9 floats, cannot be null
  /// This value must never be {@code null}.
  ///@param function Parameters for the transfer functions
  /// This value must never be {@code null}.
  ///@return A non-null ColorSpace if a match is found, null otherwise
  static ColorSpace match(
          jni.JniObject toXYZD50, ColorSpace_Rgb_TransferParameters function) =>
      ColorSpace.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_match,
          jni.JniType.objectType,
          [toXYZD50.reference, function.reference]).object);
}

/// from: android.graphics.ColorSpace$Rgb
///
/// {@usesMathJax }
///
/// An RGB color space is an additive color space using the
/// Model\#RGB RGB color model (a color is therefore represented
/// by a tuple of 3 numbers).
///
///
/// A specific RGB color space is defined by the following properties:
///
/// <ul>
///     <li>Three chromaticities of the red, green and blue primaries, which
///     define the gamut of the color space.</li>
///     <li>A white point chromaticity that defines the stimulus to which
///     color space values are normalized (also just called "white").</li>
///     <li>An opto-electronic transfer function, also called opto-electronic
///     conversion function or often, and approximately, gamma function.</li>
///     <li>An electro-optical transfer function, also called electo-optical
///     conversion function or often, and approximately, gamma function.</li>
///     <li>A range of valid RGB values (most commonly \([0..1]\)).</li>
/// </ul>
///
/// The most commonly used RGB color space is Named\#SRGB sRGB.
///
///
/// <h3>Primaries and white point chromaticities</h3>
/// In this implementation, the chromaticity of the primaries and the white
/// point of an RGB color space is defined in the CIE xyY color space. This
/// color space separates the chromaticity of a color, the x and y components,
/// and its luminance, the Y component. Since the primaries and the white
/// point have full brightness, the Y component is assumed to be 1 and only
/// the x and y components are needed to encode them.
///
/// For convenience, this implementation also allows to define the
/// primaries and white point in the CIE XYZ space. The tristimulus XYZ values
/// are internally converted to xyY.
///
///
///
///     <img style="display: block; margin: 0 auto;"src="{@docRoot}reference/android/images/graphics/colorspace_srgb.png"/>
///     <figcaption style="text-align: center;">sRGB primaries and white point</figcaption>
///
///
///
/// <h3>Transfer functions</h3>
/// A transfer function is a color component conversion function, defined as
/// a single variable, monotonic mathematical function. It is applied to each
/// individual component of a color. They are used to perform the mapping
/// between linear tristimulus values and non-linear electronic signal value.
///
/// The _opto-electronic transfer function_ (OETF or OECF) encodes
/// tristimulus values in a scene to a non-linear electronic signal value.
/// An OETF is often expressed as a power function with an exponent between
/// 0.38 and 0.55 (the reciprocal of 1.8 to 2.6).
///
/// The _electro-optical transfer function_ (EOTF or EOCF) decodes
/// a non-linear electronic signal value to a tristimulus value at the display.
/// An EOTF is often expressed as a power function with an exponent between
/// 1.8 and 2.6.
///
/// Transfer functions are used as a compression scheme. For instance,
/// linear sRGB values would normally require 11 to 12 bits of precision to
/// store all values that can be perceived by the human eye. When encoding
/// sRGB values using the appropriate OETF (see Named\#SRGB sRGB for
/// an exact mathematical description of that OETF), the values can be
/// compressed to only 8 bits precision.
///
/// When manipulating RGB values, particularly sRGB values, it is safe
/// to assume that these values have been encoded with the appropriate
/// OETF (unless noted otherwise). Encoded values are often said to be in
/// "gamma space". They are therefore defined in a non-linear space. This
/// in turns means that any linear operation applied to these values is
/// going to yield mathematically incorrect results (any linear interpolation
/// such as gradient generation for instance, most image processing functions
/// such as blurs, etc.).
///
/// To properly process encoded RGB values you must first apply the
/// EOTF to decode the value into linear space. After processing, the RGB
/// value must be encoded back to non-linear ("gamma") space. Here is a
/// formal description of the process, where \(f\) is the processing
/// function to apply:
///
///
/// $$RGB_{out} = OETF(f(EOTF(RGB_{in})))$$
///
/// If the transfer functions of the color space can be expressed as an
/// ICC parametric curve as defined in ICC.1:2004-10, the numeric parameters
/// can be retrieved by calling \#getTransferParameters(). This can
/// be useful to match color spaces for instance.
///
///
/// <p class="note">Some RGB color spaces, such as Named\#ACES and
/// Named\#LINEAR_EXTENDED_SRGB scRGB, are said to be linear because
/// their transfer functions are the identity function: \(f(x) = x\).
/// If the source and/or destination are known to be linear, it is not
/// necessary to invoke the transfer functions.
///
///
/// <h3>Range</h3>
/// Most RGB color spaces allow RGB values in the range \([0..1]\). There
/// are however a few RGB color spaces that allow much larger ranges. For
/// instance, Named\#EXTENDED_SRGB scRGB is used to manipulate the
/// range \([-0.5..7.5]\) while Named\#ACES ACES can be used throughout
/// the range \([-65504, 65504]\).
///
///
///
///     <img style="display: block; margin: 0 auto;"src="{@docRoot}reference/android/images/graphics/colorspace_scrgb.png"/>
///     <figcaption style="text-align: center;">Extended sRGB and its large range</figcaption>
///
///
///
/// <h3>Converting between RGB color spaces</h3>
/// Conversion between two color spaces is achieved by using an intermediate
/// color space called the profile connection space (PCS). The PCS used by
/// this implementation is CIE XYZ. The conversion operation is defined
/// as such:
///
///
/// $$RGB_{out} = OETF(T_{dst}^{-1} \cdot T_{src} \cdot EOTF(RGB_{in}))$$
///
/// Where \(T_{src}\) is the \#getTransform() RGB to XYZ transform
/// of the source color space and \(T_{dst}^{-1}\) the \#getInverseTransform() XYZ to RGB transform of the destination color space.
///
/// Many RGB color spaces commonly used with electronic devices use the
/// standard illuminant \#ILLUMINANT_D65 D65. Care must be take however
/// when converting between two RGB color spaces if their white points do not
/// match. This can be achieved by either calling
/// \#adapt(ColorSpace, float[]) to adapt one or both color spaces to
/// a single common white point. This can be achieved automatically by calling
/// ColorSpace\#connect(ColorSpace, ColorSpace), which also handles
/// non-RGB color spaces.
///
/// To learn more about the white point adaptation process, refer to the
/// documentation of Adaptation.
///
class ColorSpace_Rgb extends ColorSpace {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ColorSpace\$Rgb");
  ColorSpace_Rgb.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;[FLjava/util/function/DoubleUnaryOperator;Ljava/util/function/DoubleUnaryOperator;)V");

  /// from: public void <init>(java.lang.String name, float[] toXYZ, java.util.function.DoubleUnaryOperator oetf, java.util.function.DoubleUnaryOperator eotf)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new RGB color space using a 3x3 column-major transform matrix.
  /// The transform matrix must convert from the RGB space to the profile connection
  /// space CIE XYZ.
  ///
  ///
  /// <p class="note">The range of the color space is imposed to be \([0..1]\).
  ///
  ///@param name Name of the color space, cannot be null, its length must be >= 1
  /// This value must never be {@code null}.
  ///@param toXYZ 3x3 column-major transform matrix from RGB to the profile
  ///              connection space CIE XYZ as an array of 9 floats, cannot be null
  /// This value must never be {@code null}.
  ///@param oetf Opto-electronic transfer function, cannot be null
  /// This value must never be {@code null}.
  ///@param eotf Electro-optical transfer function, cannot be null
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException If any of the following conditions is met:
  /// <ul>
  ///     <li>The name is null or has a length of 0.</li>
  ///     <li>The OETF is null or the EOTF is null.</li>
  ///     <li>The minimum valid value is >= the maximum valid value.</li>
  /// </ul>
  ///@see \#get(Named)
  ColorSpace_Rgb.ctor1(jni.JniString name, jni.JniObject toXYZ,
      jni.JniObject oetf, jni.JniObject eotf)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          name.reference,
          toXYZ.reference,
          oetf.reference,
          eotf.reference
        ]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;[F[FLjava/util/function/DoubleUnaryOperator;Ljava/util/function/DoubleUnaryOperator;FF)V");

  /// from: public void <init>(java.lang.String name, float[] primaries, float[] whitePoint, java.util.function.DoubleUnaryOperator oetf, java.util.function.DoubleUnaryOperator eotf, float min, float max)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new RGB color space using a specified set of primaries
  /// and a specified white point.
  ///
  ///
  /// The primaries and white point can be specified in the CIE xyY space
  /// or in CIE XYZ. The length of the arrays depends on the chosen space:
  ///
  ///
  /// <table summary="Parameters length">
  ///     <tr><th>Space</th><th>Primaries length</th><th>White point length</th></tr>
  ///     <tr><td>xyY</td><td>6</td><td>2</td></tr>
  ///     <tr><td>XYZ</td><td>9</td><td>3</td></tr>
  /// </table>
  ///
  /// When the primaries and/or white point are specified in xyY, the Y component
  /// does not need to be specified and is assumed to be 1.0. Only the xy components
  /// are required.
  ///
  ///
  /// <p class="note">The ID, areturned by \#getId(), of an object created by
  /// this constructor is always \#MIN_ID.
  ///
  ///@param name Name of the color space, cannot be null, its length must be >= 1
  /// This value must never be {@code null}.
  ///@param primaries RGB primaries as an array of 6 (xy) or 9 (XYZ) floats
  /// This value must never be {@code null}.
  ///@param whitePoint Reference white as an array of 2 (xy) or 3 (XYZ) floats
  /// This value must never be {@code null}.
  ///@param oetf Opto-electronic transfer function, cannot be null
  /// This value must never be {@code null}.
  ///@param eotf Electro-optical transfer function, cannot be null
  /// This value must never be {@code null}.
  ///@param min The minimum valid value in this color space's RGB range
  ///@param max The maximum valid value in this color space's RGB range
  ///@throws IllegalArgumentException If any of the following conditions is met:
  ///
  /// <ul>
  ///     <li>The name is null or has a length of 0.</li>
  ///     <li>The primaries array is null or has a length that is neither 6 or 9.</li>
  ///     <li>The white point array is null or has a length that is neither 2 or 3.</li>
  ///     <li>The OETF is null or the EOTF is null.</li>
  ///     <li>The minimum valid value is >= the maximum valid value.</li>
  /// </ul>
  ///@see \#get(Named)
  ColorSpace_Rgb.ctor2(
      jni.JniString name,
      jni.JniObject primaries,
      jni.JniObject whitePoint,
      jni.JniObject oetf,
      jni.JniObject eotf,
      double min,
      double max)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, [
          name.reference,
          primaries.reference,
          whitePoint.reference,
          oetf.reference,
          eotf.reference,
          min,
          max
        ]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;[FLandroid/graphics/ColorSpace\$Rgb\$TransferParameters;)V");

  /// from: public void <init>(java.lang.String name, float[] toXYZ, android.graphics.ColorSpace.Rgb.TransferParameters function)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new RGB color space using a 3x3 column-major transform matrix.
  /// The transform matrix must convert from the RGB space to the profile connection
  /// space CIE XYZ.
  ///
  ///
  /// <p class="note">The range of the color space is imposed to be \([0..1]\).
  ///
  ///@param name Name of the color space, cannot be null, its length must be >= 1
  /// This value must never be {@code null}.
  ///@param toXYZ 3x3 column-major transform matrix from RGB to the profile
  ///              connection space CIE XYZ as an array of 9 floats, cannot be null
  /// This value must never be {@code null}.
  ///@param function Parameters for the transfer functions
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException If any of the following conditions is met:
  /// <ul>
  ///     <li>The name is null or has a length of 0.</li>
  ///     <li>Gamma is negative.</li>
  /// </ul>
  ///@see \#get(Named)
  ColorSpace_Rgb.ctor3(jni.JniString name, jni.JniObject toXYZ,
      ColorSpace_Rgb_TransferParameters function)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3,
            [name.reference, toXYZ.reference, function.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;[F[FLandroid/graphics/ColorSpace\$Rgb\$TransferParameters;)V");

  /// from: public void <init>(java.lang.String name, float[] primaries, float[] whitePoint, android.graphics.ColorSpace.Rgb.TransferParameters function)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new RGB color space using a specified set of primaries
  /// and a specified white point.
  ///
  ///
  /// The primaries and white point can be specified in the CIE xyY space
  /// or in CIE XYZ. The length of the arrays depends on the chosen space:
  ///
  ///
  /// <table summary="Parameters length">
  ///     <tr><th>Space</th><th>Primaries length</th><th>White point length</th></tr>
  ///     <tr><td>xyY</td><td>6</td><td>2</td></tr>
  ///     <tr><td>XYZ</td><td>9</td><td>3</td></tr>
  /// </table>
  ///
  /// When the primaries and/or white point are specified in xyY, the Y component
  /// does not need to be specified and is assumed to be 1.0. Only the xy components
  /// are required.
  ///
  ///@param name Name of the color space, cannot be null, its length must be >= 1
  /// This value must never be {@code null}.
  ///@param primaries RGB primaries as an array of 6 (xy) or 9 (XYZ) floats
  /// This value must never be {@code null}.
  ///@param whitePoint Reference white as an array of 2 (xy) or 3 (XYZ) floats
  /// This value must never be {@code null}.
  ///@param function Parameters for the transfer functions
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException If any of the following conditions is met:
  /// <ul>
  ///     <li>The name is null or has a length of 0.</li>
  ///     <li>The primaries array is null or has a length that is neither 6 or 9.</li>
  ///     <li>The white point array is null or has a length that is neither 2 or 3.</li>
  ///     <li>The transfer parameters are invalid.</li>
  /// </ul>
  ///@see \#get(Named)
  ColorSpace_Rgb.ctor4(jni.JniString name, jni.JniObject primaries,
      jni.JniObject whitePoint, ColorSpace_Rgb_TransferParameters function)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor4, [
          name.reference,
          primaries.reference,
          whitePoint.reference,
          function.reference
        ]).object);

  static final _id_ctor5 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;[FD)V");

  /// from: public void <init>(java.lang.String name, float[] toXYZ, double gamma)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new RGB color space using a 3x3 column-major transform matrix.
  /// The transform matrix must convert from the RGB space to the profile connection
  /// space CIE XYZ.
  ///
  ///
  /// <p class="note">The range of the color space is imposed to be \([0..1]\).
  ///
  ///@param name Name of the color space, cannot be null, its length must be >= 1
  /// This value must never be {@code null}.
  ///@param toXYZ 3x3 column-major transform matrix from RGB to the profile
  ///              connection space CIE XYZ as an array of 9 floats, cannot be null
  /// This value must never be {@code null}.
  ///@param gamma Gamma to use as the transfer function
  ///@throws IllegalArgumentException If any of the following conditions is met:
  /// <ul>
  ///     <li>The name is null or has a length of 0.</li>
  ///     <li>Gamma is negative.</li>
  /// </ul>
  ///@see \#get(Named)
  ColorSpace_Rgb.ctor5(jni.JniString name, jni.JniObject toXYZ, double gamma)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor5,
            [name.reference, toXYZ.reference, gamma]).object);

  static final _id_ctor6 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;[F[FD)V");

  /// from: public void <init>(java.lang.String name, float[] primaries, float[] whitePoint, double gamma)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new RGB color space using a specified set of primaries
  /// and a specified white point.
  ///
  ///
  /// The primaries and white point can be specified in the CIE xyY space
  /// or in CIE XYZ. The length of the arrays depends on the chosen space:
  ///
  ///
  /// <table summary="Parameters length">
  ///     <tr><th>Space</th><th>Primaries length</th><th>White point length</th></tr>
  ///     <tr><td>xyY</td><td>6</td><td>2</td></tr>
  ///     <tr><td>XYZ</td><td>9</td><td>3</td></tr>
  /// </table>
  ///
  /// When the primaries and/or white point are specified in xyY, the Y component
  /// does not need to be specified and is assumed to be 1.0. Only the xy components
  /// are required.
  ///
  ///@param name Name of the color space, cannot be null, its length must be >= 1
  /// This value must never be {@code null}.
  ///@param primaries RGB primaries as an array of 6 (xy) or 9 (XYZ) floats
  /// This value must never be {@code null}.
  ///@param whitePoint Reference white as an array of 2 (xy) or 3 (XYZ) floats
  /// This value must never be {@code null}.
  ///@param gamma Gamma to use as the transfer function
  ///@throws IllegalArgumentException If any of the following conditions is met:
  /// <ul>
  ///     <li>The name is null or has a length of 0.</li>
  ///     <li>The primaries array is null or has a length that is neither 6 or 9.</li>
  ///     <li>The white point array is null or has a length that is neither 2 or 3.</li>
  ///     <li>Gamma is negative.</li>
  /// </ul>
  ///@see \#get(Named)
  ColorSpace_Rgb.ctor6(jni.JniString name, jni.JniObject primaries,
      jni.JniObject whitePoint, double gamma)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor6, [
          name.reference,
          primaries.reference,
          whitePoint.reference,
          gamma
        ]).object);

  static final _id_getWhitePoint =
      jniAccessors.getMethodIDOf(_classRef, "getWhitePoint", "([F)[F");

  /// from: public float[] getWhitePoint(float[] whitePoint)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copies the non-adapted CIE xyY white point of this color space in
  /// specified array. The Y component is assumed to be 1 and is therefore
  /// not copied into the destination. The x and y components are written
  /// in the array at positions 0 and 1 respectively.
  ///@param whitePoint The destination array, cannot be null, its length
  ///                   must be >= 2
  ///
  /// This value must never be {@code null}.
  ///@return The destination array passed as a parameter
  ///@see \#getWhitePoint(float[])
  jni.JniObject getWhitePoint(jni.JniObject whitePoint) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getWhitePoint,
          jni.JniType.objectType,
          [whitePoint.reference]).object);

  static final _id_getWhitePoint1 =
      jniAccessors.getMethodIDOf(_classRef, "getWhitePoint", "()[F");

  /// from: public float[] getWhitePoint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the non-adapted CIE xyY white point of this color space as
  /// a new array of 2 floats. The Y component is assumed to be 1 and is
  /// therefore not copied into the destination. The x and y components
  /// are written in the array at positions 0 and 1 respectively.
  ///@return A new non-null array of 2 floats
  ///@see \#getWhitePoint()
  jni.JniObject getWhitePoint1() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWhitePoint1, jni.JniType.objectType, []).object);

  static final _id_getPrimaries =
      jniAccessors.getMethodIDOf(_classRef, "getPrimaries", "([F)[F");

  /// from: public float[] getPrimaries(float[] primaries)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copies the primaries of this color space in specified array. The Y
  /// component is assumed to be 1 and is therefore not copied into the
  /// destination. The x and y components of the first primary are written
  /// in the array at positions 0 and 1 respectively.
  ///@param primaries The destination array, cannot be null, its length
  ///                  must be >= 6
  ///
  /// This value must never be {@code null}.
  ///@return The destination array passed as a parameter
  ///@see \#getPrimaries(float[])
  jni.JniObject getPrimaries(jni.JniObject primaries) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPrimaries,
          jni.JniType.objectType,
          [primaries.reference]).object);

  static final _id_getPrimaries1 =
      jniAccessors.getMethodIDOf(_classRef, "getPrimaries", "()[F");

  /// from: public float[] getPrimaries()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the primaries of this color space as a new array of 6 floats.
  /// The Y component is assumed to be 1 and is therefore not copied into
  /// the destination. The x and y components of the first primary are
  /// written in the array at positions 0 and 1 respectively.
  ///@return A new non-null array of 2 floats
  ///@see \#getWhitePoint()
  jni.JniObject getPrimaries1() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPrimaries1, jni.JniType.objectType, []).object);

  static final _id_getTransform =
      jniAccessors.getMethodIDOf(_classRef, "getTransform", "([F)[F");

  /// from: public float[] getTransform(float[] transform)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copies the transform of this color space in specified array. The
  /// transform is used to convert from RGB to XYZ (with the same white
  /// point as this color space). To connect color spaces, you must first
  /// ColorSpace\#adapt(ColorSpace, float[]) adapt them to the
  /// same white point.
  ///
  /// It is recommended to use ColorSpace\#connect(ColorSpace, ColorSpace)
  /// to convert between color spaces.
  ///
  ///@param transform The destination array, cannot be null, its length
  ///                  must be >= 9
  ///
  /// This value must never be {@code null}.
  ///@return The destination array passed as a parameter
  ///@see \#getInverseTransform()
  jni.JniObject getTransform(jni.JniObject transform) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTransform,
          jni.JniType.objectType,
          [transform.reference]).object);

  static final _id_getTransform1 =
      jniAccessors.getMethodIDOf(_classRef, "getTransform", "()[F");

  /// from: public float[] getTransform()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the transform of this color space as a new array. The
  /// transform is used to convert from RGB to XYZ (with the same white
  /// point as this color space). To connect color spaces, you must first
  /// ColorSpace\#adapt(ColorSpace, float[]) adapt them to the
  /// same white point.
  ///
  /// It is recommended to use ColorSpace\#connect(ColorSpace, ColorSpace)
  /// to convert between color spaces.
  ///
  ///@return A new array of 9 floats
  ///
  /// This value will never be {@code null}.
  ///@see \#getInverseTransform(float[])
  jni.JniObject getTransform1() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTransform1, jni.JniType.objectType, []).object);

  static final _id_getInverseTransform =
      jniAccessors.getMethodIDOf(_classRef, "getInverseTransform", "([F)[F");

  /// from: public float[] getInverseTransform(float[] inverseTransform)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copies the inverse transform of this color space in specified array.
  /// The inverse transform is used to convert from XYZ to RGB (with the
  /// same white point as this color space). To connect color spaces, you
  /// must first ColorSpace\#adapt(ColorSpace, float[]) adapt them
  /// to the same white point.
  ///
  /// It is recommended to use ColorSpace\#connect(ColorSpace, ColorSpace)
  /// to convert between color spaces.
  ///
  ///@param inverseTransform The destination array, cannot be null, its length
  ///                  must be >= 9
  ///
  /// This value must never be {@code null}.
  ///@return The destination array passed as a parameter
  ///@see \#getTransform()
  jni.JniObject getInverseTransform(jni.JniObject inverseTransform) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getInverseTransform,
          jni.JniType.objectType,
          [inverseTransform.reference]).object);

  static final _id_getInverseTransform1 =
      jniAccessors.getMethodIDOf(_classRef, "getInverseTransform", "()[F");

  /// from: public float[] getInverseTransform()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the inverse transform of this color space as a new array.
  /// The inverse transform is used to convert from XYZ to RGB (with the
  /// same white point as this color space). To connect color spaces, you
  /// must first ColorSpace\#adapt(ColorSpace, float[]) adapt them
  /// to the same white point.
  ///
  /// It is recommended to use ColorSpace\#connect(ColorSpace, ColorSpace)
  /// to convert between color spaces.
  ///
  ///@return A new array of 9 floats
  ///
  /// This value will never be {@code null}.
  ///@see \#getTransform(float[])
  jni.JniObject getInverseTransform1() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInverseTransform1, jni.JniType.objectType, []).object);

  static final _id_getOetf = jniAccessors.getMethodIDOf(
      _classRef, "getOetf", "()Ljava/util/function/DoubleUnaryOperator;");

  /// from: public java.util.function.DoubleUnaryOperator getOetf()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the opto-electronic transfer function (OETF) of this color space.
  /// The inverse function is the electro-optical transfer function (EOTF) returned
  /// by \#getEotf(). These functions are defined to satisfy the following
  /// equality for \(x \in [0..1]\):
  ///
  ///
  /// $$OETF(EOTF(x)) = EOTF(OETF(x)) = x$$
  ///
  /// For RGB colors, this function can be used to convert from linear space
  /// to "gamma space" (gamma encoded). The terms gamma space and gamma encoded
  /// are frequently used because many OETFs can be closely approximated using
  /// a simple power function of the form \(x^{\frac{1}{\gamma}}\) (the
  /// approximation of the Named\#SRGB sRGB OETF uses \(\gamma=2.2\)
  /// for instance).
  ///
  ///@return A transfer function that converts from linear space to "gamma space"
  ///
  /// This value will never be {@code null}.
  ///@see \#getEotf()
  ///@see \#getTransferParameters()
  jni.JniObject getOetf() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOetf, jni.JniType.objectType, []).object);

  static final _id_getEotf = jniAccessors.getMethodIDOf(
      _classRef, "getEotf", "()Ljava/util/function/DoubleUnaryOperator;");

  /// from: public java.util.function.DoubleUnaryOperator getEotf()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the electro-optical transfer function (EOTF) of this color space.
  /// The inverse function is the opto-electronic transfer function (OETF)
  /// returned by \#getOetf(). These functions are defined to satisfy the
  /// following equality for \(x \in [0..1]\):
  ///
  ///
  /// $$OETF(EOTF(x)) = EOTF(OETF(x)) = x$$
  ///
  /// For RGB colors, this function can be used to convert from "gamma space"
  /// (gamma encoded) to linear space. The terms gamma space and gamma encoded
  /// are frequently used because many EOTFs can be closely approximated using
  /// a simple power function of the form \(x^\gamma\) (the approximation of the
  /// Named\#SRGB sRGB EOTF uses \(\gamma=2.2\) for instance).
  ///
  ///@return A transfer function that converts from "gamma space" to linear space
  ///
  /// This value will never be {@code null}.
  ///@see \#getOetf()
  ///@see \#getTransferParameters()
  jni.JniObject getEotf() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getEotf, jni.JniType.objectType, []).object);

  static final _id_getTransferParameters = jniAccessors.getMethodIDOf(
      _classRef,
      "getTransferParameters",
      "()Landroid/graphics/ColorSpace\$Rgb\$TransferParameters;");

  /// from: public android.graphics.ColorSpace.Rgb.TransferParameters getTransferParameters()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the parameters used by the \#getEotf() electro-optical
  /// and \#getOetf() opto-electronic transfer functions. If the transfer
  /// functions do not match the ICC parametric curves defined in ICC.1:2004-10
  /// (section 10.15), this method returns null.
  ///
  ///
  /// See TransferParameters for a full description of the transfer
  /// functions.
  ///
  ///@return An instance of TransferParameters or null if this color
  ///         space's transfer functions do not match the equation defined in
  ///         TransferParameters
  ColorSpace_Rgb_TransferParameters getTransferParameters() =>
      ColorSpace_Rgb_TransferParameters.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTransferParameters,
          jni.JniType.objectType, []).object);

  static final _id_isSrgb =
      jniAccessors.getMethodIDOf(_classRef, "isSrgb", "()Z");

  /// from: public boolean isSrgb()
  bool isSrgb() => jniAccessors.callMethodWithArgs(
      reference, _id_isSrgb, jni.JniType.booleanType, []).boolean;

  static final _id_isWideGamut =
      jniAccessors.getMethodIDOf(_classRef, "isWideGamut", "()Z");

  /// from: public boolean isWideGamut()
  bool isWideGamut() => jniAccessors.callMethodWithArgs(
      reference, _id_isWideGamut, jni.JniType.booleanType, []).boolean;

  static final _id_getMinValue =
      jniAccessors.getMethodIDOf(_classRef, "getMinValue", "(I)F");

  /// from: public float getMinValue(int component)
  double getMinValue(int component) => jniAccessors.callMethodWithArgs(
      reference, _id_getMinValue, jni.JniType.floatType, [component]).float;

  static final _id_getMaxValue =
      jniAccessors.getMethodIDOf(_classRef, "getMaxValue", "(I)F");

  /// from: public float getMaxValue(int component)
  double getMaxValue(int component) => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxValue, jni.JniType.floatType, [component]).float;

  static final _id_toLinear =
      jniAccessors.getMethodIDOf(_classRef, "toLinear", "(FFF)[F");

  /// from: public float[] toLinear(float r, float g, float b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decodes an RGB value to linear space. This is achieved by
  /// applying this color space's electro-optical transfer function
  /// to the supplied values.
  ///
  ///
  /// Refer to the documentation of ColorSpace.Rgb for
  /// more information about transfer functions and their use for
  /// encoding and decoding RGB values.
  ///
  ///@param r The red component to decode to linear space
  ///@param g The green component to decode to linear space
  ///@param b The blue component to decode to linear space
  ///@return A new array of 3 floats containing linear RGB values
  ///
  /// This value will never be {@code null}.
  ///@see \#toLinear(float[])
  ///@see \#fromLinear(float, float, float)
  jni.JniObject toLinear(double r, double g, double b) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toLinear, jni.JniType.objectType, [r, g, b]).object);

  static final _id_toLinear1 =
      jniAccessors.getMethodIDOf(_classRef, "toLinear", "([F)[F");

  /// from: public float[] toLinear(float[] v)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decodes an RGB value to linear space. This is achieved by
  /// applying this color space's electro-optical transfer function
  /// to the first 3 values of the supplied array. The result is
  /// stored back in the input array.
  ///
  ///
  /// Refer to the documentation of ColorSpace.Rgb for
  /// more information about transfer functions and their use for
  /// encoding and decoding RGB values.
  ///
  ///@param v A non-null array of non-linear RGB values, its length
  ///          must be at least 3
  /// This value must never be {@code null}.
  ///@return The specified array
  ///@see \#toLinear(float, float, float)
  ///@see \#fromLinear(float[])
  jni.JniObject toLinear1(jni.JniObject v) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_toLinear1, jni.JniType.objectType, [v.reference]).object);

  static final _id_fromLinear =
      jniAccessors.getMethodIDOf(_classRef, "fromLinear", "(FFF)[F");

  /// from: public float[] fromLinear(float r, float g, float b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes an RGB value from linear space to this color space's
  /// "gamma space". This is achieved by applying this color space's
  /// opto-electronic transfer function to the supplied values.
  ///
  ///
  /// Refer to the documentation of ColorSpace.Rgb for
  /// more information about transfer functions and their use for
  /// encoding and decoding RGB values.
  ///
  ///@param r The red component to encode from linear space
  ///@param g The green component to encode from linear space
  ///@param b The blue component to encode from linear space
  ///@return A new array of 3 floats containing non-linear RGB values
  ///
  /// This value will never be {@code null}.
  ///@see \#fromLinear(float[])
  ///@see \#toLinear(float, float, float)
  jni.JniObject fromLinear(double r, double g, double b) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_fromLinear, jni.JniType.objectType, [r, g, b]).object);

  static final _id_fromLinear1 =
      jniAccessors.getMethodIDOf(_classRef, "fromLinear", "([F)[F");

  /// from: public float[] fromLinear(float[] v)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encodes an RGB value from linear space to this color space's
  /// "gamma space". This is achieved by applying this color space's
  /// opto-electronic transfer function to the first 3 values of the
  /// supplied array. The result is stored back in the input array.
  ///
  ///
  /// Refer to the documentation of ColorSpace.Rgb for
  /// more information about transfer functions and their use for
  /// encoding and decoding RGB values.
  ///
  ///@param v A non-null array of linear RGB values, its length
  ///          must be at least 3
  /// This value must never be {@code null}.
  ///@return A new array of 3 floats containing non-linear RGB values
  ///@see \#fromLinear(float[])
  ///@see \#toLinear(float, float, float)
  jni.JniObject fromLinear1(jni.JniObject v) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_fromLinear1, jni.JniType.objectType, [v.reference]).object);

  static final _id_toXyz1 =
      jniAccessors.getMethodIDOf(_classRef, "toXyz", "([F)[F");

  /// from: public float[] toXyz(float[] v)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param v This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject toXyz1(jni.JniObject v) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toXyz1, jni.JniType.objectType, [v.reference]).object);

  static final _id_fromXyz1 =
      jniAccessors.getMethodIDOf(_classRef, "fromXyz", "([F)[F");

  /// from: public float[] fromXyz(float[] v)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param v This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject fromXyz1(jni.JniObject v) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_fromXyz1, jni.JniType.objectType, [v.reference]).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}

/// from: android.graphics.ColorSpace$Rgb$TransferParameters
///
/// {@usesMathJax }
///
/// Defines the parameters for the ICC parametric curve type 4, as
/// defined in ICC.1:2004-10, section 10.15.
///
///
/// The EOTF is of the form:
///
///
/// \(\begin{equation}
/// Y = \begin{cases}c X + f & X \lt d \\
/// \left( a X + b \right) ^{g} + e & X \ge d \end{cases}
/// \end{equation}\)
///
/// The corresponding OETF is simply the inverse function.
///
///
/// The parameters defined by this class form a valid transfer
/// function only if all the following conditions are met:
///
/// <ul>
///     <li>No parameter is a Double\#isNaN(double) Not-a-Number</li>
///     <li>\(d\) is in the range \([0..1]\)</li>
///     <li>The function is not constant</li>
///     <li>The function is positive and increasing</li>
/// </ul>
class ColorSpace_Rgb_TransferParameters extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/graphics/ColorSpace\$Rgb\$TransferParameters");
  ColorSpace_Rgb_TransferParameters.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_a = jniAccessors.getFieldIDOf(_classRef, "a", "D");

  /// from: public final double a
  ///
  /// Variable \(a\) in the equation of the EOTF described above.
  double get a => jniAccessors
      .getField(reference, _id_a, jni.JniType.doubleType)
      .doubleFloat;

  static final _id_b = jniAccessors.getFieldIDOf(_classRef, "b", "D");

  /// from: public final double b
  ///
  /// Variable \(b\) in the equation of the EOTF described above.
  double get b => jniAccessors
      .getField(reference, _id_b, jni.JniType.doubleType)
      .doubleFloat;

  static final _id_c = jniAccessors.getFieldIDOf(_classRef, "c", "D");

  /// from: public final double c
  ///
  /// Variable \(c\) in the equation of the EOTF described above.
  double get c => jniAccessors
      .getField(reference, _id_c, jni.JniType.doubleType)
      .doubleFloat;

  static final _id_d = jniAccessors.getFieldIDOf(_classRef, "d", "D");

  /// from: public final double d
  ///
  /// Variable \(d\) in the equation of the EOTF described above.
  double get d => jniAccessors
      .getField(reference, _id_d, jni.JniType.doubleType)
      .doubleFloat;

  static final _id_e = jniAccessors.getFieldIDOf(_classRef, "e", "D");

  /// from: public final double e
  ///
  /// Variable \(e\) in the equation of the EOTF described above.
  double get e => jniAccessors
      .getField(reference, _id_e, jni.JniType.doubleType)
      .doubleFloat;

  static final _id_f = jniAccessors.getFieldIDOf(_classRef, "f", "D");

  /// from: public final double f
  ///
  /// Variable \(f\) in the equation of the EOTF described above.
  double get f => jniAccessors
      .getField(reference, _id_f, jni.JniType.doubleType)
      .doubleFloat;

  static final _id_g = jniAccessors.getFieldIDOf(_classRef, "g", "D");

  /// from: public final double g
  ///
  /// Variable \(g\) in the equation of the EOTF described above.
  double get g => jniAccessors
      .getField(reference, _id_g, jni.JniType.doubleType)
      .doubleFloat;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(DDDDD)V");

  /// from: public void <init>(double a, double b, double c, double d, double g)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Defines the parameters for the ICC parametric curve type 3, as
  /// defined in ICC.1:2004-10, section 10.15.
  ///
  ///
  /// The EOTF is of the form:
  ///
  ///
  /// \(\begin{equation}
  /// Y = \begin{cases}c X & X \lt d \\
  /// \left( a X + b \right) ^{g} & X \ge d \end{cases}
  /// \end{equation}\)
  ///
  /// This constructor is equivalent to setting  \(e\) and \(f\) to 0.
  ///
  ///@param a The value of \(a\) in the equation of the EOTF described above
  ///@param b The value of \(b\) in the equation of the EOTF described above
  ///@param c The value of \(c\) in the equation of the EOTF described above
  ///@param d The value of \(d\) in the equation of the EOTF described above
  ///@param g The value of \(g\) in the equation of the EOTF described above
  ///@throws IllegalArgumentException If the parameters form an invalid transfer function
  ColorSpace_Rgb_TransferParameters(
      double a, double b, double c, double d, double g)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [a, b, c, d, g]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(DDDDDDD)V");

  /// from: public void <init>(double a, double b, double c, double d, double e, double f, double g)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Defines the parameters for the ICC parametric curve type 4, as
  /// defined in ICC.1:2004-10, section 10.15.
  ///
  ///@param a The value of \(a\) in the equation of the EOTF described above
  ///@param b The value of \(b\) in the equation of the EOTF described above
  ///@param c The value of \(c\) in the equation of the EOTF described above
  ///@param d The value of \(d\) in the equation of the EOTF described above
  ///@param e The value of \(e\) in the equation of the EOTF described above
  ///@param f The value of \(f\) in the equation of the EOTF described above
  ///@param g The value of \(g\) in the equation of the EOTF described above
  ///@throws IllegalArgumentException If the parameters form an invalid transfer function
  ColorSpace_Rgb_TransferParameters.ctor1(
      double a, double b, double c, double d, double e, double f, double g)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [a, b, c, d, e, f, g]).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}

/// from: android.graphics.ColorSpace$RenderIntent
///
/// A render intent determines how a ColorSpace.Connector connector
/// maps colors from one color space to another. The choice of mapping is
/// important when the source color space has a larger color gamut than the
/// destination color space.
///
///@see ColorSpace\#connect(ColorSpace, ColorSpace, RenderIntent)
class ColorSpace_RenderIntent extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ColorSpace\$RenderIntent");
  ColorSpace_RenderIntent.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/ColorSpace\$RenderIntent;");

  /// from: static public android.graphics.ColorSpace.RenderIntent[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/graphics/ColorSpace\$RenderIntent;");

  /// from: static public android.graphics.ColorSpace.RenderIntent valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ColorSpace_RenderIntent valueOf(jni.JniString name) =>
      ColorSpace_RenderIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ColorSpace_RenderIntent()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.graphics.ColorSpace$Named
///
/// {@usesMathJax }
///
/// List of common, named color spaces. A corresponding instance of
/// ColorSpace can be obtained by calling ColorSpace\#get(Named):
///
///
/// <pre class="prettyprint">
/// ColorSpace cs = ColorSpace.get(ColorSpace.Named.DCI_P3);
/// </pre>
///
/// The properties of each color space are described below (see \#SRGB sRGB
/// for instance). When applicable, the color gamut of each color space is compared
/// to the color gamut of sRGB using a CIE 1931 xy chromaticity diagram. This diagram
/// shows the location of the color space's primaries and white point.
///
///@see ColorSpace\#get(Named)
class ColorSpace_Named extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ColorSpace\$Named");
  ColorSpace_Named.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/ColorSpace\$Named;");

  /// from: static public android.graphics.ColorSpace.Named[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/ColorSpace\$Named;");

  /// from: static public android.graphics.ColorSpace.Named valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ColorSpace_Named valueOf(jni.JniString name) =>
      ColorSpace_Named.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ColorSpace_Named()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.graphics.ColorSpace$Model
///
/// A color model is required by a ColorSpace to describe the
/// way colors can be represented as tuples of numbers. A common color
/// model is the \#RGB RGB color model which defines a color
/// as represented by a tuple of 3 numbers (red, green and blue).
class ColorSpace_Model extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ColorSpace\$Model");
  ColorSpace_Model.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/ColorSpace\$Model;");

  /// from: static public android.graphics.ColorSpace.Model[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/ColorSpace\$Model;");

  /// from: static public android.graphics.ColorSpace.Model valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ColorSpace_Model valueOf(jni.JniString name) =>
      ColorSpace_Model.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ColorSpace_Model()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getComponentCount =
      jniAccessors.getMethodIDOf(_classRef, "getComponentCount", "()I");

  /// from: public int getComponentCount()
  ///
  /// Returns the number of components for this color model.
  ///@return An integer between 1 and 4
  ///
  /// Value is between 1 and 4 inclusive
  int getComponentCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getComponentCount, jni.JniType.intType, []).integer;
}

/// from: android.graphics.ColorSpace$Connector
///
/// {@usesMathJax }
///
/// A connector transforms colors from a source color space to a destination
/// color space.
///
///
/// A source color space is connected to a destination color space using the
/// color transform \(C\) computed from their respective transforms noted
/// \(T_{src}\) and \(T_{dst}\) in the following equation:
///
///
/// $$C = T^{-1}_{dst} . T_{src}$$
///
/// The transform \(C\) shown above is only valid when the source and
/// destination color spaces have the same profile connection space (PCS).
/// We know that instances of ColorSpace always use CIE XYZ as their
/// PCS but their white points might differ. When they do, we must perform
/// a chromatic adaptation of the color spaces' transforms. To do so, we
/// use the von Kries method described in the documentation of Adaptation,
/// using the CIE standard illuminant ColorSpace\#ILLUMINANT_D50 D50
/// as the target white point.
///
///
/// Example of conversion from Named\#SRGB sRGB to
/// Named\#DCI_P3 DCI-P3:
///
///
/// <pre class="prettyprint">
/// ColorSpace.Connector connector = ColorSpace.connect(
///         ColorSpace.get(ColorSpace.Named.SRGB),
///         ColorSpace.get(ColorSpace.Named.DCI_P3));
/// float[] p3 = connector.transform(1.0f, 0.0f, 0.0f);
/// // p3 contains { 0.9473, 0.2740, 0.2076 }
/// </pre>
///@see Adaptation
///@see ColorSpace\#adapt(ColorSpace, float[], Adaptation)
///@see ColorSpace\#adapt(ColorSpace, float[])
///@see ColorSpace\#connect(ColorSpace, ColorSpace, RenderIntent)
///@see ColorSpace\#connect(ColorSpace, ColorSpace)
///@see ColorSpace\#connect(ColorSpace, RenderIntent)
///@see ColorSpace\#connect(ColorSpace)
class ColorSpace_Connector extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ColorSpace\$Connector");
  ColorSpace_Connector.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/graphics/ColorSpace;Landroid/graphics/ColorSpace;Landroid/graphics/ColorSpace\$RenderIntent;)V");

  /// from: void <init>(android.graphics.ColorSpace source, android.graphics.ColorSpace destination, android.graphics.ColorSpace.RenderIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new connector between a source and a destination color space.
  ///@param source The source color space, cannot be null
  ///@param destination The destination color space, cannot be null
  ///@param intent The render intent to use when compressing gamuts
  ColorSpace_Connector(
      ColorSpace source, ColorSpace destination, ColorSpace_RenderIntent intent)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          source.reference,
          destination.reference,
          intent.reference
        ]).object);

  static final _id_getSource = jniAccessors.getMethodIDOf(
      _classRef, "getSource", "()Landroid/graphics/ColorSpace;");

  /// from: public android.graphics.ColorSpace getSource()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the source color space this connector will convert from.
  ///@return A non-null instance of ColorSpace
  ///@see \#getDestination()
  ColorSpace getSource() => ColorSpace.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getSource, jni.JniType.objectType, []).object);

  static final _id_getDestination = jniAccessors.getMethodIDOf(
      _classRef, "getDestination", "()Landroid/graphics/ColorSpace;");

  /// from: public android.graphics.ColorSpace getDestination()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the destination color space this connector will convert to.
  ///@return A non-null instance of ColorSpace
  ///@see \#getSource()
  ColorSpace getDestination() =>
      ColorSpace.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDestination, jni.JniType.objectType, []).object);

  static final _id_getRenderIntent = jniAccessors.getMethodIDOf(_classRef,
      "getRenderIntent", "()Landroid/graphics/ColorSpace\$RenderIntent;");

  /// from: public android.graphics.ColorSpace.RenderIntent getRenderIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the render intent this connector will use when mapping the
  /// source color space to the destination color space.
  ///@return A non-null RenderIntent
  ///@see RenderIntent
  ColorSpace_RenderIntent getRenderIntent() =>
      ColorSpace_RenderIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRenderIntent, jni.JniType.objectType, []).object);

  static final _id_transform =
      jniAccessors.getMethodIDOf(_classRef, "transform", "(FFF)[F");

  /// from: public float[] transform(float r, float g, float b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Transforms the specified color from the source color space
  /// to a color in the destination color space. This convenience
  /// method assumes a source color model with 3 components
  /// (typically RGB). To transform from color models with more than
  /// 3 components, such as Model\#CMYK CMYK, use
  /// \#transform(float[]) instead.
  ///
  ///@param r The red component of the color to transform
  ///@param g The green component of the color to transform
  ///@param b The blue component of the color to transform
  ///@return A new array of 3 floats containing the specified color
  ///         transformed from the source space to the destination space
  ///
  /// This value will never be {@code null}.
  ///@see \#transform(float[])
  jni.JniObject transform(double r, double g, double b) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_transform, jni.JniType.objectType, [r, g, b]).object);

  static final _id_transform1 =
      jniAccessors.getMethodIDOf(_classRef, "transform", "([F)[F");

  /// from: public float[] transform(float[] v)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Transforms the specified color from the source color space
  /// to a color in the destination color space.
  ///
  ///@param v A non-null array of 3 floats containing the value to transform
  ///            and that will hold the result of the transform
  /// This value must never be {@code null}.
  ///@return The v array passed as a parameter, containing the specified color
  ///         transformed from the source space to the destination space
  ///@see \#transform(float, float, float)
  jni.JniObject transform1(jni.JniObject v) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_transform1, jni.JniType.objectType, [v.reference]).object);
}

/// from: android.graphics.ColorSpace$Adaptation
///
/// {@usesMathJax }
///
/// List of adaptation matrices that can be used for chromatic adaptation
/// using the von Kries transform. These matrices are used to convert values
/// in the CIE XYZ space to values in the LMS space (Long Medium Short).
///
///
/// Given an adaptation matrix \(A\), the conversion from XYZ to
/// LMS is straightforward:
///
///
/// $$\left[ \begin{array}{c} L\\ M\\ S \end{array} \right] =
/// A \left[ \begin{array}{c} X\\ Y\\ Z \end{array} \right]$$
///
/// The complete von Kries transform \(T\) uses a diagonal matrix
/// noted \(D\) to perform the adaptation in LMS space. In addition
/// to \(A\) and \(D\), the source white point \(W1\) and the destination
/// white point \(W2\) must be specified:
///
///
/// $$\begin{align*}
/// \left[ \begin{array}{c} L_1\\ M_1\\ S_1 \end{array} \right] &=
///      A \left[ \begin{array}{c} W1_X\\ W1_Y\\ W1_Z \end{array} \right] \\
/// \left[ \begin{array}{c} L_2\\ M_2\\ S_2 \end{array} \right] &=
///      A \left[ \begin{array}{c} W2_X\\ W2_Y\\ W2_Z \end{array} \right] \\
/// D &= \left[ \begin{matrix} \frac{L_2}{L_1} & 0 & 0 \\
///      0 & \frac{M_2}{M_1} & 0 \\
///      0 & 0 & \frac{S_2}{S_1} \end{matrix} \right] \\
/// T &= A^{-1}.D.A
/// \end{align*}$$
///
/// As an example, the resulting matrix \(T\) can then be used to
/// perform the chromatic adaptation of sRGB XYZ transform from D65
/// to D50:
///
///
/// $$sRGB_{D50} = T.sRGB_{D65}$$
///@see ColorSpace.Connector
///@see ColorSpace\#connect(ColorSpace, ColorSpace)
class ColorSpace_Adaptation extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ColorSpace\$Adaptation");
  ColorSpace_Adaptation.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/ColorSpace\$Adaptation;");

  /// from: static public android.graphics.ColorSpace.Adaptation[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/graphics/ColorSpace\$Adaptation;");

  /// from: static public android.graphics.ColorSpace.Adaptation valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ColorSpace_Adaptation valueOf(jni.JniString name) =>
      ColorSpace_Adaptation.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ColorSpace_Adaptation()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
