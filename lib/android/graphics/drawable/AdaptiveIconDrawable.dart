// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Drawable.dart" as drawable_;

import "../../content/res/Resources.dart" as resources_;

import "../../util/AttributeSet.dart" as attributeset_;

import "../Path.dart" as path_;

import "../Rect.dart" as rect_;

import "../Canvas.dart" as canvas_;

import "../Outline.dart" as outline_;

import "../Region.dart" as region_;

import "../ColorFilter.dart" as colorfilter_;

import "../../content/res/ColorStateList.dart" as colorstatelist_;

import "../PorterDuff.dart" as porterduff_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.drawable.AdaptiveIconDrawable
///
/// This class can also be created via XML inflation using <code>&lt;adaptive-icon></code> tag
/// in addition to dynamic creation.
///
/// This drawable supports two drawable layers: foreground and background. The layers are clipped
/// when rendering using the mask defined in the device configuration.
///
/// <ul>
/// <li>Both foreground and background layers should be sized at 108 x 108 dp.</li>
/// <li>The inner 72 x 72 dp  of the icon appears within the masked viewport.</li>
/// <li>The outer 18 dp on each of the 4 sides of the layers is reserved for use by the system UI
/// surfaces to create interesting visual effects, such as parallax or pulsing.</li>
/// </ul>
///
/// Such motion effect is achieved by internally setting the bounds of the foreground and
/// background layer as following:
/// <pre>
/// Rect(getBounds().left - getBounds().getWidth() * \#getExtraInsetFraction(),
///      getBounds().top - getBounds().getHeight() * \#getExtraInsetFraction(),
///      getBounds().right + getBounds().getWidth() * \#getExtraInsetFraction(),
///      getBounds().bottom + getBounds().getHeight() * \#getExtraInsetFraction())
/// </pre>
class AdaptiveIconDrawable extends drawable_.Drawable {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/drawable/AdaptiveIconDrawable");
  AdaptiveIconDrawable.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/graphics/drawable/Drawable;Landroid/graphics/drawable/Drawable;)V");

  /// from: public void <init>(android.graphics.drawable.Drawable backgroundDrawable, android.graphics.drawable.Drawable foregroundDrawable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor used to dynamically create this drawable.
  ///@param backgroundDrawable drawable that should be rendered in the background
  ///@param foregroundDrawable drawable that should be rendered in the foreground
  AdaptiveIconDrawable.ctor1(drawable_.Drawable backgroundDrawable,
      drawable_.Drawable foregroundDrawable)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          backgroundDrawable.reference,
          foregroundDrawable.reference
        ]).object);

  static final _id_inflate1 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;Landroid/content/res/Resources\$Theme;)V");

  /// from: public void inflate(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs, android.content.res.Resources.Theme theme)
  ///
  /// @param r This value must never be {@code null}.
  ///@param parser This value must never be {@code null}.
  ///@param attrs This value must never be {@code null}.
  ///@param theme This value may be {@code null}.
  void inflate1(resources_.Resources r, jni.JniObject parser,
          attributeset_.AttributeSet attrs, resources_.Resources_Theme theme) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_inflate1, jni.JniType.voidType, [
        r.reference,
        parser.reference,
        attrs.reference,
        theme.reference
      ]).check();

  static final _id_getExtraInsetFraction = jniAccessors.getStaticMethodIDOf(
      _classRef, "getExtraInsetFraction", "()F");

  /// from: static public float getExtraInsetFraction()
  ///
  /// All four sides of the layers are padded with extra inset so as to provide
  /// extra content to reveal within the clip path when performing affine transformations on the
  /// layers.
  ///@see \#getForeground() and \#getBackground() for more info on how this value is used
  static double getExtraInsetFraction() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getExtraInsetFraction, jni.JniType.floatType, []).float;

  static final _id_getIconMask = jniAccessors.getMethodIDOf(
      _classRef, "getIconMask", "()Landroid/graphics/Path;");

  /// from: public android.graphics.Path getIconMask()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// When called before the bound is set, the returned path is identical to
  /// R.string.config_icon_mask. After the bound is set, the
  /// returned path's computed bound is same as the \#getBounds().
  ///@return the mask path object used to clip the drawable
  path_.Path getIconMask() =>
      path_.Path.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIconMask, jni.JniType.objectType, []).object);

  static final _id_getForeground = jniAccessors.getMethodIDOf(
      _classRef, "getForeground", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getForeground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the foreground drawable managed by this class. The bound of this drawable is
  /// extended by \#getExtraInsetFraction() * getBounds().width on left/right sides and by
  /// \#getExtraInsetFraction() * getBounds().height on top/bottom sides.
  ///@return the foreground drawable managed by this drawable
  drawable_.Drawable getForeground() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getForeground, jni.JniType.objectType, []).object);

  static final _id_getBackground = jniAccessors.getMethodIDOf(
      _classRef, "getBackground", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getBackground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the foreground drawable managed by this class. The bound of this drawable is
  /// extended by \#getExtraInsetFraction() * getBounds().width on left/right sides and by
  /// \#getExtraInsetFraction() * getBounds().height on top/bottom sides.
  ///@return the background drawable managed by this drawable
  drawable_.Drawable getBackground() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBackground, jni.JniType.objectType, []).object);

  static final _id_onBoundsChange = jniAccessors.getMethodIDOf(
      _classRef, "onBoundsChange", "(Landroid/graphics/Rect;)V");

  /// from: protected void onBoundsChange(android.graphics.Rect bounds)
  void onBoundsChange(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBoundsChange,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_invalidateSelf =
      jniAccessors.getMethodIDOf(_classRef, "invalidateSelf", "()V");

  /// from: public void invalidateSelf()
  void invalidateSelf() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidateSelf, jni.JniType.voidType, []).check();

  static final _id_getOutline = jniAccessors.getMethodIDOf(
      _classRef, "getOutline", "(Landroid/graphics/Outline;)V");

  /// from: public void getOutline(android.graphics.Outline outline)
  ///
  /// @param outline This value must never be {@code null}.
  void getOutline(outline_.Outline outline) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getOutline,
      jni.JniType.voidType,
      [outline.reference]).check();

  static final _id_getTransparentRegion = jniAccessors.getMethodIDOf(
      _classRef, "getTransparentRegion", "()Landroid/graphics/Region;");

  /// from: public android.graphics.Region getTransparentRegion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This value may be {@code null}.
  region_.Region getTransparentRegion() =>
      region_.Region.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTransparentRegion, jni.JniType.objectType, []).object);

  static final _id_applyTheme = jniAccessors.getMethodIDOf(
      _classRef, "applyTheme", "(Landroid/content/res/Resources\$Theme;)V");

  /// from: public void applyTheme(android.content.res.Resources.Theme t)
  ///
  /// @param t This value must never be {@code null}.
  void applyTheme(resources_.Resources_Theme t) =>
      jniAccessors.callMethodWithArgs(reference, _id_applyTheme,
          jni.JniType.voidType, [t.reference]).check();

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;

  static final _id_invalidateDrawable = jniAccessors.getMethodIDOf(_classRef,
      "invalidateDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable who)
  ///
  /// @param who This value must never be {@code null}.
  void invalidateDrawable(drawable_.Drawable who) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateDrawable,
          jni.JniType.voidType, [who.reference]).check();

  static final _id_scheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "scheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;J)V");

  /// from: public void scheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what, long when)
  ///
  /// @param who This value must never be {@code null}.
  ///@param what This value must never be {@code null}.
  void scheduleDrawable(drawable_.Drawable who, jni.JniObject what, int when) =>
      jniAccessors.callMethodWithArgs(reference, _id_scheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference, when]).check();

  static final _id_unscheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "unscheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;)V");

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what)
  ///
  /// @param who This value must never be {@code null}.
  ///@param what This value must never be {@code null}.
  void unscheduleDrawable(drawable_.Drawable who, jni.JniObject what) =>
      jniAccessors.callMethodWithArgs(reference, _id_unscheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference]).check();

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// @return Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_setHotspot =
      jniAccessors.getMethodIDOf(_classRef, "setHotspot", "(FF)V");

  /// from: public void setHotspot(float x, float y)
  void setHotspot(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_setHotspot, jni.JniType.voidType, [x, y]).check();

  static final _id_setHotspotBounds =
      jniAccessors.getMethodIDOf(_classRef, "setHotspotBounds", "(IIII)V");

  /// from: public void setHotspotBounds(int left, int top, int right, int bottom)
  void setHotspotBounds(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHotspotBounds,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_getHotspotBounds = jniAccessors.getMethodIDOf(
      _classRef, "getHotspotBounds", "(Landroid/graphics/Rect;)V");

  /// from: public void getHotspotBounds(android.graphics.Rect outRect)
  void getHotspotBounds(rect_.Rect outRect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHotspotBounds,
      jni.JniType.voidType,
      [outRect.reference]).check();

  static final _id_setVisible =
      jniAccessors.getMethodIDOf(_classRef, "setVisible", "(ZZ)Z");

  /// from: public boolean setVisible(boolean visible, boolean restart)
  bool setVisible(bool visible, bool restart) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVisible,
          jni.JniType.booleanType, [visible, restart]).boolean;

  static final _id_setDither =
      jniAccessors.getMethodIDOf(_classRef, "setDither", "(Z)V");

  /// from: public void setDither(boolean dither)
  void setDither(bool dither) => jniAccessors.callMethodWithArgs(
      reference, _id_setDither, jni.JniType.voidType, [dither]).check();

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int alpha)
  void setAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public void setColorFilter(android.graphics.ColorFilter colorFilter)
  void setColorFilter(colorfilter_.ColorFilter colorFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [colorFilter.reference]).check();

  static final _id_setTintList = jniAccessors.getMethodIDOf(
      _classRef, "setTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTintList(android.content.res.ColorStateList tint)
  void setTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_setTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setTintMode(android.graphics.PorterDuff.Mode tintMode)
  void setTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_setOpacity =
      jniAccessors.getMethodIDOf(_classRef, "setOpacity", "(I)V");

  /// from: public void setOpacity(int opacity)
  void setOpacity(int opacity) => jniAccessors.callMethodWithArgs(
      reference, _id_setOpacity, jni.JniType.voidType, [opacity]).check();

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public int getOpacity()
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_setAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "setAutoMirrored", "(Z)V");

  /// from: public void setAutoMirrored(boolean mirrored)
  void setAutoMirrored(bool mirrored) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutoMirrored, jni.JniType.voidType, [mirrored]).check();

  static final _id_isAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "isAutoMirrored", "()Z");

  /// from: public boolean isAutoMirrored()
  bool isAutoMirrored() => jniAccessors.callMethodWithArgs(
      reference, _id_isAutoMirrored, jni.JniType.booleanType, []).boolean;

  static final _id_jumpToCurrentState =
      jniAccessors.getMethodIDOf(_classRef, "jumpToCurrentState", "()V");

  /// from: public void jumpToCurrentState()
  void jumpToCurrentState() => jniAccessors.callMethodWithArgs(
      reference, _id_jumpToCurrentState, jni.JniType.voidType, []).check();

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public boolean isStateful()
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_onStateChange =
      jniAccessors.getMethodIDOf(_classRef, "onStateChange", "([I)Z");

  /// from: protected boolean onStateChange(int[] state)
  bool onStateChange(jni.JniObject state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStateChange,
      jni.JniType.booleanType,
      [state.reference]).boolean;

  static final _id_onLevelChange =
      jniAccessors.getMethodIDOf(_classRef, "onLevelChange", "(I)Z");

  /// from: protected boolean onLevelChange(int level)
  bool onLevelChange(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onLevelChange, jni.JniType.booleanType, [level]).boolean;

  static final _id_getIntrinsicWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicWidth", "()I");

  /// from: public int getIntrinsicWidth()
  int getIntrinsicWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicWidth, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicHeight", "()I");

  /// from: public int getIntrinsicHeight()
  int getIntrinsicHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicHeight, jni.JniType.intType, []).integer;

  static final _id_getConstantState = jniAccessors.getMethodIDOf(
      _classRef,
      "getConstantState",
      "()Landroid/graphics/drawable/Drawable\$ConstantState;");

  /// from: public android.graphics.drawable.Drawable.ConstantState getConstantState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable_ConstantState getConstantState() =>
      drawable_.Drawable_ConstantState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConstantState, jni.JniType.objectType, []).object);

  static final _id_mutate = jniAccessors.getMethodIDOf(
      _classRef, "mutate", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable mutate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable mutate() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_mutate, jni.JniType.objectType, []).object);
}
