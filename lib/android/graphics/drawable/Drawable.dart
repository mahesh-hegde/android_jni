// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Canvas.dart" as canvas_;

import "../Rect.dart" as rect_;

import "../ColorFilter.dart" as colorfilter_;

import "../PorterDuff.dart" as porterduff_;

import "../../content/res/ColorStateList.dart" as colorstatelist_;

import "../../content/res/Resources.dart" as resources_;

import "../Region.dart" as region_;

import "../Outline.dart" as outline_;

import "../../util/TypedValue.dart" as typedvalue_;

import "../BitmapFactory.dart" as bitmapfactory_;

import "../../util/AttributeSet.dart" as attributeset_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.drawable.Drawable
///
/// A Drawable is a general abstraction for "something that can be drawn."  Most
/// often you will deal with Drawable as the type of resource retrieved for
/// drawing things to the screen; the Drawable class provides a generic API for
/// dealing with an underlying visual resource that may take a variety of forms.
/// Unlike a android.view.View, a Drawable does not have any facility to
/// receive events or otherwise interact with the user.
///
/// In addition to simple drawing, Drawable provides a number of generic
/// mechanisms for its client to interact with what is being drawn:
///
/// <ul>
///     <li> The \#setBounds method <var>must</var> be called to tell the
///     Drawable where it is drawn and how large it should be.  All Drawables
///     should respect the requested size, often simply by scaling their
///     imagery.  A client can find the preferred size for some Drawables with
///     the \#getIntrinsicHeight and \#getIntrinsicWidth methods.
///
///     <li> The \#getPadding method can return from some Drawables
///     information about how to frame content that is placed inside of them.
///     For example, a Drawable that is intended to be the frame for a button
///     widget would need to return padding that correctly places the label
///     inside of itself.
///
///     <li> The \#setState method allows the client to tell the Drawable
///     in which state it is to be drawn, such as "focused", "selected", etc.
///     Some drawables may modify their imagery based on the selected state.
///
///     <li> The \#setLevel method allows the client to supply a single
///     continuous controller that can modify the Drawable is displayed, such as
///     a battery level or progress level.  Some drawables may modify their
///     imagery based on the current level.
///
///     <li> A Drawable can perform animations by calling back to its client
///     through the Callback interface.  All clients should support this
///     interface (via \#setCallback) so that animations will work.  A
///     simple way to do this is through the system facilities such as
///     android.view.View\#setBackground(Drawable) and
///     android.widget.ImageView.
/// </ul>
///
/// Though usually not visible to the application, Drawables may take a variety
/// of forms:
///
/// <ul>
///     <li> __Bitmap__: the simplest Drawable, a PNG or JPEG image.
///     <li> __Nine Patch__: an extension to the PNG format allows it to
///     specify information about how to stretch it and place things inside of
///     it.
///     <li>__Vector__: a drawable defined in an XML file as a set of points,
///     lines, and curves along with its associated color information. This type
///     of drawable can be scaled without loss of display quality.
///     <li> __Shape__: contains simple drawing commands instead of a raw
///     bitmap, allowing it to resize better in some cases.
///     <li> __Layers__: a compound drawable, which draws multiple underlying
///     drawables on top of each other.
///     <li> __States__: a compound drawable that selects one of a set of
///     drawables based on its state.
///     <li> __Levels__: a compound drawable that selects one of a set of
///     drawables based on its level.
///     <li> __Scale__: a compound drawable with a single child drawable,
///     whose overall size is modified based on the current level.
/// </ul>
///
/// <a name="Custom"></a>
/// <h3>Custom drawables</h3>
///
///
/// All versions of Android allow the Drawable class to be extended and used at
/// run time in place of framework-provided drawable classes. Starting in
/// android.os.Build.VERSION_CODES\#N API 24, custom drawables classes
/// may also be used in XML.
///
/// <strong>Note:</strong> Custom drawable classes are only accessible from
/// within your application package. Other applications will not be able to load
/// them.
///
/// At a minimum, custom drawable classes must implement the abstract methods on
/// Drawable and should override the Drawable\#draw(Canvas) method to
/// draw content.
///
/// Custom drawables classes may be used in XML in multiple ways:
/// <ul>
///     <li>
///         Using the fully-qualified class name as the XML element name. For
///         this method, the custom drawable class must be a public top-level
///         class.
/// <pre>
/// &lt;com.myapp.MyCustomDrawable xmlns:android="http://schemas.android.com/apk/res/android"
///     android:color="\#ffff0000" /&gt;
/// </pre>
///     </li>
///     <li>
///         Using _drawable_ as the XML element name and specifying the
///         fully-qualified class name from the _class_ attribute. This
///         method may be used for both public top-level classes and public
///         static inner classes.
/// <pre>
/// &lt;drawable xmlns:android="http://schemas.android.com/apk/res/android"
///     class="com.myapp.MyTopLevelClass$InnerCustomDrawable"
///     android:color="\#ffff0000" /&gt;
/// </pre>
///     </li>
/// </ul>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about how to use drawables, read the
/// <a href="{@docRoot}guide/topics/graphics/2d-graphics.html">Canvas and Drawables</a> developer
/// guide. For information and examples of creating drawable resources (XML or bitmap files that
/// can be loaded in code), read the
/// <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>
/// document.
///</div>
class Drawable extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/drawable/Drawable");
  Drawable.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Drawable()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public abstract void draw(android.graphics.Canvas canvas)
  ///
  /// Draw in its bounds (set via setBounds) respecting optional effects such
  /// as alpha (set via setAlpha) and color filter (set via setColorFilter).
  ///@param canvas The canvas to draw into
  ///
  /// This value must never be {@code null}.
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_setBounds =
      jniAccessors.getMethodIDOf(_classRef, "setBounds", "(IIII)V");

  /// from: public void setBounds(int left, int top, int right, int bottom)
  ///
  /// Specify a bounding rectangle for the Drawable. This is where the drawable
  /// will draw when its draw() method is called.
  void setBounds(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBounds,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_setBounds1 = jniAccessors.getMethodIDOf(
      _classRef, "setBounds", "(Landroid/graphics/Rect;)V");

  /// from: public void setBounds(android.graphics.Rect bounds)
  ///
  /// Specify a bounding rectangle for the Drawable. This is where the drawable
  /// will draw when its draw() method is called.
  ///@param bounds This value must never be {@code null}.
  void setBounds1(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBounds1,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_copyBounds = jniAccessors.getMethodIDOf(
      _classRef, "copyBounds", "(Landroid/graphics/Rect;)V");

  /// from: public final void copyBounds(android.graphics.Rect bounds)
  ///
  /// Return a copy of the drawable's bounds in the specified Rect (allocated
  /// by the caller). The bounds specify where this will draw when its draw()
  /// method is called.
  ///@param bounds Rect to receive the drawable's bounds (allocated by the
  ///               caller).
  ///
  /// This value must never be {@code null}.
  void copyBounds(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_copyBounds,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_copyBounds1 = jniAccessors.getMethodIDOf(
      _classRef, "copyBounds", "()Landroid/graphics/Rect;");

  /// from: public final android.graphics.Rect copyBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a copy of the drawable's bounds in a new Rect. This returns the
  /// same values as getBounds(), but the returned object is guaranteed to not
  /// be changed later by the drawable (i.e. it retains no reference to this
  /// rect). If the caller already has a Rect allocated, call copyBounds(rect).
  ///@return A copy of the drawable's bounds
  ///
  /// This value will never be {@code null}.
  rect_.Rect copyBounds1() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_copyBounds1, jni.JniType.objectType, []).object);

  static final _id_getBounds = jniAccessors.getMethodIDOf(
      _classRef, "getBounds", "()Landroid/graphics/Rect;");

  /// from: public final android.graphics.Rect getBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the drawable's bounds Rect. Note: for efficiency, the returned
  /// object may be the same object stored in the drawable (though this is not
  /// guaranteed), so if a persistent copy of the bounds is needed, call
  /// copyBounds(rect) instead.
  /// You should also not change the object returned by this method as it may
  /// be the same object stored in the drawable.
  ///@return The bounds of the drawable (which may change later, so caller
  ///         beware). DO NOT ALTER the returned object as it may change the
  ///         stored bounds of this drawable.
  ///
  /// This value will never be {@code null}.
  ///@see \#copyBounds()
  ///@see \#copyBounds(android.graphics.Rect)
  rect_.Rect getBounds() => rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getBounds, jni.JniType.objectType, []).object);

  static final _id_getDirtyBounds = jniAccessors.getMethodIDOf(
      _classRef, "getDirtyBounds", "()Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect getDirtyBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the drawable's dirty bounds Rect. Note: for efficiency, the
  /// returned object may be the same object stored in the drawable (though
  /// this is not guaranteed).
  ///
  /// By default, this returns the full drawable bounds. Custom drawables may
  /// override this method to perform more precise invalidation.
  ///@return The dirty bounds of this drawable
  ///
  /// This value will never be {@code null}.
  rect_.Rect getDirtyBounds() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDirtyBounds, jni.JniType.objectType, []).object);

  static final _id_setChangingConfigurations = jniAccessors.getMethodIDOf(
      _classRef, "setChangingConfigurations", "(I)V");

  /// from: public void setChangingConfigurations(int configs)
  ///
  /// Set a mask of the configuration parameters for which this drawable
  /// may change, requiring that it be re-created.
  ///@param configs A mask of the changing configuration parameters, as
  /// defined by android.content.pm.ActivityInfo.
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see android.content.pm.ActivityInfo
  void setChangingConfigurations(int configs) =>
      jniAccessors.callMethodWithArgs(reference, _id_setChangingConfigurations,
          jni.JniType.voidType, [configs]).check();

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// Return a mask of the configuration parameters for which this drawable
  /// may change, requiring that it be re-created.  The default implementation
  /// returns whatever was provided through
  /// \#setChangingConfigurations(int) or 0 by default.  Subclasses
  /// may extend this to or in the changing configurations of any other
  /// drawables they hold.
  ///@return Returns a mask of the changing configuration parameters, as
  /// defined by android.content.pm.ActivityInfo.
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see android.content.pm.ActivityInfo
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_setDither =
      jniAccessors.getMethodIDOf(_classRef, "setDither", "(Z)V");

  /// from: public void setDither(boolean dither)
  ///
  /// Set to true to have the drawable dither its colors when drawn to a
  /// device with fewer than 8-bits per color component.
  ///@see android.graphics.Paint\#setDither(boolean);
  ///@deprecated This property is ignored.
  void setDither(bool dither) => jniAccessors.callMethodWithArgs(
      reference, _id_setDither, jni.JniType.voidType, [dither]).check();

  static final _id_setFilterBitmap =
      jniAccessors.getMethodIDOf(_classRef, "setFilterBitmap", "(Z)V");

  /// from: public void setFilterBitmap(boolean filter)
  ///
  /// Set to true to have the drawable filter its bitmaps with bilinear
  /// sampling when they are scaled or rotated.
  ///
  /// This can improve appearance when bitmaps are rotated. If the drawable
  /// does not use bitmaps, this call is ignored.
  ///
  ///@see \#isFilterBitmap()
  ///@see android.graphics.Paint\#setFilterBitmap(boolean);
  void setFilterBitmap(bool filter) => jniAccessors.callMethodWithArgs(
      reference, _id_setFilterBitmap, jni.JniType.voidType, [filter]).check();

  static final _id_isFilterBitmap =
      jniAccessors.getMethodIDOf(_classRef, "isFilterBitmap", "()Z");

  /// from: public boolean isFilterBitmap()
  ///
  /// @return whether this drawable filters its bitmaps
  ///@see \#setFilterBitmap(boolean)
  bool isFilterBitmap() => jniAccessors.callMethodWithArgs(
      reference, _id_isFilterBitmap, jni.JniType.booleanType, []).boolean;

  static final _id_setCallback = jniAccessors.getMethodIDOf(_classRef,
      "setCallback", "(Landroid/graphics/drawable/Drawable\$Callback;)V");

  /// from: public final void setCallback(android.graphics.drawable.Drawable.Callback cb)
  ///
  /// Bind a Callback object to this Drawable.  Required for clients
  /// that want to support animated drawables.
  ///@param cb The client's Callback implementation.
  ///
  /// This value may be {@code null}.
  ///@see \#getCallback()
  void setCallback(Drawable_Callback cb) => jniAccessors.callMethodWithArgs(
      reference, _id_setCallback, jni.JniType.voidType, [cb.reference]).check();

  static final _id_getCallback = jniAccessors.getMethodIDOf(_classRef,
      "getCallback", "()Landroid/graphics/drawable/Drawable\$Callback;");

  /// from: public android.graphics.drawable.Drawable.Callback getCallback()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current Callback implementation attached to this
  /// Drawable.
  ///@return A Callback instance or null if no callback was set.
  ///@see \#setCallback(android.graphics.drawable.Drawable.Callback)
  Drawable_Callback getCallback() =>
      Drawable_Callback.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallback, jni.JniType.objectType, []).object);

  static final _id_invalidateSelf =
      jniAccessors.getMethodIDOf(_classRef, "invalidateSelf", "()V");

  /// from: public void invalidateSelf()
  ///
  /// Use the current Callback implementation to have this Drawable
  /// redrawn.  Does nothing if there is no Callback attached to the
  /// Drawable.
  ///@see Callback\#invalidateDrawable
  ///@see \#getCallback()
  ///@see \#setCallback(android.graphics.drawable.Drawable.Callback)
  void invalidateSelf() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidateSelf, jni.JniType.voidType, []).check();

  static final _id_scheduleSelf = jniAccessors.getMethodIDOf(
      _classRef, "scheduleSelf", "(Ljava/lang/Runnable;J)V");

  /// from: public void scheduleSelf(java.lang.Runnable what, long when)
  ///
  /// Use the current Callback implementation to have this Drawable
  /// scheduled.  Does nothing if there is no Callback attached to the
  /// Drawable.
  ///@param what The action being scheduled.
  /// This value must never be {@code null}.
  ///@param when The time (in milliseconds) to run.
  ///@see Callback\#scheduleDrawable
  void scheduleSelf(jni.JniObject what, int when) =>
      jniAccessors.callMethodWithArgs(reference, _id_scheduleSelf,
          jni.JniType.voidType, [what.reference, when]).check();

  static final _id_unscheduleSelf = jniAccessors.getMethodIDOf(
      _classRef, "unscheduleSelf", "(Ljava/lang/Runnable;)V");

  /// from: public void unscheduleSelf(java.lang.Runnable what)
  ///
  /// Use the current Callback implementation to have this Drawable
  /// unscheduled.  Does nothing if there is no Callback attached to the
  /// Drawable.
  ///@param what The runnable that you no longer want called.
  ///
  /// This value must never be {@code null}.
  ///@see Callback\#unscheduleDrawable
  void unscheduleSelf(jni.JniObject what) => jniAccessors.callMethodWithArgs(
      reference,
      _id_unscheduleSelf,
      jni.JniType.voidType,
      [what.reference]).check();

  static final _id_getLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "getLayoutDirection", "()I");

  /// from: public int getLayoutDirection()
  ///
  /// Returns the resolved layout direction for this Drawable.
  ///@return One of android.view.View\#LAYOUT_DIRECTION_LTR,
  ///         android.view.View\#LAYOUT_DIRECTION_RTL
  /// Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  ///@see \#setLayoutDirection(int)
  int getLayoutDirection() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayoutDirection, jni.JniType.intType, []).integer;

  static final _id_setLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "setLayoutDirection", "(I)Z");

  /// from: public final boolean setLayoutDirection(int layoutDirection)
  ///
  /// Set the layout direction for this drawable. Should be a resolved
  /// layout direction, as the Drawable has no capacity to do the resolution on
  /// its own.
  ///@param layoutDirection the resolved layout direction for the drawable,
  ///                        either android.view.View\#LAYOUT_DIRECTION_LTR
  ///                        or android.view.View\#LAYOUT_DIRECTION_RTL
  /// Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  ///@return {@code true} if the layout direction change has caused the
  ///         appearance of the drawable to change such that it needs to be
  ///         re-drawn, {@code false} otherwise
  ///@see \#getLayoutDirection()
  bool setLayoutDirection(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutDirection,
          jni.JniType.booleanType, [layoutDirection]).boolean;

  static final _id_onLayoutDirectionChanged =
      jniAccessors.getMethodIDOf(_classRef, "onLayoutDirectionChanged", "(I)Z");

  /// from: public boolean onLayoutDirectionChanged(int layoutDirection)
  ///
  /// Called when the drawable's resolved layout direction changes.
  ///@param layoutDirection the new resolved layout direction
  /// Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  ///@return {@code true} if the layout direction change has caused the
  ///         appearance of the drawable to change such that it needs to be
  ///         re-drawn, {@code false} otherwise
  ///@see \#setLayoutDirection(int)
  bool onLayoutDirectionChanged(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayoutDirectionChanged,
          jni.JniType.booleanType, [layoutDirection]).boolean;

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public abstract void setAlpha(int alpha)
  ///
  /// Specify an alpha value for the drawable. 0 means fully transparent, and
  /// 255 means fully opaque.
  ///@param alpha Value is between 0 and 255 inclusive
  void setAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  ///
  /// Gets the current alpha value for the drawable. 0 means fully transparent,
  /// 255 means fully opaque. This method is implemented by
  /// Drawable subclasses and the value returned is specific to how that class treats alpha.
  /// The default return value is 255 if the class does not override this method to return a value
  /// specific to its use of alpha.
  ///@return Value is between 0 and 255 inclusive
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public abstract void setColorFilter(android.graphics.ColorFilter colorFilter)
  ///
  /// Specify an optional color filter for the drawable.
  ///
  /// If a Drawable has a ColorFilter, each output pixel of the Drawable's
  /// drawing contents will be modified by the color filter before it is
  /// blended onto the render target of a Canvas.
  ///
  ///
  ///
  /// Pass {@code null} to remove any existing color filter.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Setting a non-{@code null} color
  /// filter disables \#setTintList(ColorStateList) tint.
  ///
  ///
  ///@param colorFilter The color filter to apply, or {@code null} to remove the
  ///            existing color filter
  ///
  /// This value may be {@code null}.
  void setColorFilter(colorfilter_.ColorFilter colorFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [colorFilter.reference]).check();

  static final _id_setColorFilter1 = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(ILandroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setColorFilter(int color, android.graphics.PorterDuff.Mode mode)
  ///
  /// Specify a color and Porter-Duff mode to be the color filter for this
  /// drawable.
  ///
  /// Convenience for \#setColorFilter(ColorFilter) which constructs a
  /// PorterDuffColorFilter.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Setting a color filter disables
  /// \#setTintList(ColorStateList) tint.
  ///
  ///
  ///@param mode This value must never be {@code null}.
  void setColorFilter1(int color, porterduff_.PorterDuff_Mode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter1,
          jni.JniType.voidType, [color, mode.reference]).check();

  static final _id_setTint =
      jniAccessors.getMethodIDOf(_classRef, "setTint", "(I)V");

  /// from: public void setTint(int tintColor)
  ///
  /// Specifies tint color for this drawable.
  ///
  /// A Drawable's drawing content will be blended together with its tint
  /// before it is drawn to the screen. This functions similarly to
  /// \#setColorFilter(int, PorterDuff.Mode).
  ///
  ///
  ///
  /// To clear the tint, pass {@code null} to
  /// \#setTintList(ColorStateList).
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Setting a color filter via
  /// \#setColorFilter(ColorFilter) or
  /// \#setColorFilter(int, PorterDuff.Mode) overrides tint.
  ///
  ///
  ///@param tintColor Color to use for tinting this drawable
  ///@see \#setTintList(ColorStateList)
  ///@see \#setTintMode(PorterDuff.Mode)
  void setTint(int tintColor) => jniAccessors.callMethodWithArgs(
      reference, _id_setTint, jni.JniType.voidType, [tintColor]).check();

  static final _id_setTintList = jniAccessors.getMethodIDOf(
      _classRef, "setTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTintList(android.content.res.ColorStateList tint)
  ///
  /// Specifies tint color for this drawable as a color state list.
  ///
  /// A Drawable's drawing content will be blended together with its tint
  /// before it is drawn to the screen. This functions similarly to
  /// \#setColorFilter(int, PorterDuff.Mode).
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Setting a color filter via
  /// \#setColorFilter(ColorFilter) or
  /// \#setColorFilter(int, PorterDuff.Mode) overrides tint.
  ///
  ///
  ///@param tint Color state list to use for tinting this drawable, or
  ///            {@code null} to clear the tint
  /// This value may be {@code null}.
  ///@see \#setTint(int)
  ///@see \#setTintMode(PorterDuff.Mode)
  void setTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_setTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setTintMode(android.graphics.PorterDuff.Mode tintMode)
  ///
  /// Specifies a tint blending mode for this drawable.
  ///
  /// Defines how this drawable's tint color should be blended into the drawable
  /// before it is drawn to screen. Default tint mode is PorterDuff.Mode\#SRC_IN.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Setting a color filter via
  /// \#setColorFilter(ColorFilter) or
  /// \#setColorFilter(int, PorterDuff.Mode) overrides tint.
  ///
  ///
  ///@param tintMode A Porter-Duff blending mode
  /// This value must never be {@code null}.
  ///@see \#setTint(int)
  ///@see \#setTintList(ColorStateList)
  void setTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_getColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "getColorFilter", "()Landroid/graphics/ColorFilter;");

  /// from: public android.graphics.ColorFilter getColorFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current color filter, or {@code null} if none set.
  ///@return the current color filter, or {@code null} if none set
  colorfilter_.ColorFilter getColorFilter() =>
      colorfilter_.ColorFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorFilter, jni.JniType.objectType, []).object);

  static final _id_clearColorFilter =
      jniAccessors.getMethodIDOf(_classRef, "clearColorFilter", "()V");

  /// from: public void clearColorFilter()
  ///
  /// Removes the color filter for this drawable.
  void clearColorFilter() => jniAccessors.callMethodWithArgs(
      reference, _id_clearColorFilter, jni.JniType.voidType, []).check();

  static final _id_setHotspot =
      jniAccessors.getMethodIDOf(_classRef, "setHotspot", "(FF)V");

  /// from: public void setHotspot(float x, float y)
  ///
  /// Specifies the hotspot's location within the drawable.
  ///@param x The X coordinate of the center of the hotspot
  ///@param y The Y coordinate of the center of the hotspot
  void setHotspot(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_setHotspot, jni.JniType.voidType, [x, y]).check();

  static final _id_setHotspotBounds =
      jniAccessors.getMethodIDOf(_classRef, "setHotspotBounds", "(IIII)V");

  /// from: public void setHotspotBounds(int left, int top, int right, int bottom)
  ///
  /// Sets the bounds to which the hotspot is constrained, if they should be
  /// different from the drawable bounds.
  ///@param left position in pixels of the left bound
  ///@param top position in pixels of the top bound
  ///@param right position in pixels of the right bound
  ///@param bottom position in pixels of the bottom bound
  ///@see \#getHotspotBounds(android.graphics.Rect)
  void setHotspotBounds(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHotspotBounds,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_getHotspotBounds = jniAccessors.getMethodIDOf(
      _classRef, "getHotspotBounds", "(Landroid/graphics/Rect;)V");

  /// from: public void getHotspotBounds(android.graphics.Rect outRect)
  ///
  /// Populates {@code outRect} with the hotspot bounds.
  ///@param outRect the rect to populate with the hotspot bounds
  /// This value must never be {@code null}.
  ///@see \#setHotspotBounds(int, int, int, int)
  void getHotspotBounds(rect_.Rect outRect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHotspotBounds,
      jni.JniType.voidType,
      [outRect.reference]).check();

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public boolean isStateful()
  ///
  /// Indicates whether this drawable will change its appearance based on
  /// state. Clients can use this to determine whether it is necessary to
  /// calculate their state and call setState.
  ///@return True if this drawable changes its appearance based on state,
  ///         false otherwise.
  ///@see \#setState(int[])
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_setState =
      jniAccessors.getMethodIDOf(_classRef, "setState", "([I)Z");

  /// from: public boolean setState(int[] stateSet)
  ///
  /// Specify a set of states for the drawable. These are use-case specific,
  /// so see the relevant documentation. As an example, the background for
  /// widgets like Button understand the following states:
  /// [android.R.attr\#state_focused,
  ///  android.R.attr\#state_pressed].
  ///
  /// If the new state you are supplying causes the appearance of the
  /// Drawable to change, then it is responsible for calling
  /// \#invalidateSelf in order to have itself redrawn, _and_
  /// true will be returned from this function.
  ///
  /// Note: The Drawable holds a reference on to <var>stateSet</var>
  /// until a new state array is given to it, so you must not modify this
  /// array during that time.
  ///
  ///@param stateSet The new set of states to be displayed.
  ///
  /// This value must never be {@code null}.
  ///@return Returns true if this change in state has caused the appearance
  /// of the Drawable to change (hence requiring an invalidate), otherwise
  /// returns false.
  bool setState(jni.JniObject stateSet) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setState,
      jni.JniType.booleanType,
      [stateSet.reference]).boolean;

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()[I");

  /// from: public int[] getState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Describes the current state, as a union of primitve states, such as
  /// android.R.attr\#state_focused,
  /// android.R.attr\#state_selected, etc.
  /// Some drawables may modify their imagery based on the selected state.
  ///@return An array of resource Ids describing the current state.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getState() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getState, jni.JniType.objectType, []).object);

  static final _id_jumpToCurrentState =
      jniAccessors.getMethodIDOf(_classRef, "jumpToCurrentState", "()V");

  /// from: public void jumpToCurrentState()
  ///
  /// If this Drawable does transition animations between states, ask that
  /// it immediately jump to the current state and skip any active animations.
  void jumpToCurrentState() => jniAccessors.callMethodWithArgs(
      reference, _id_jumpToCurrentState, jni.JniType.voidType, []).check();

  static final _id_getCurrent = jniAccessors.getMethodIDOf(
      _classRef, "getCurrent", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getCurrent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The current drawable that will be used by this drawable. For simple drawables, this
  ///         is just the drawable itself. For drawables that change state like
  ///         StateListDrawable and LevelListDrawable this will be the child drawable
  ///         currently in use.
  ///
  /// This value will never be {@code null}.
  Drawable getCurrent() => Drawable.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getCurrent, jni.JniType.objectType, []).object);

  static final _id_setLevel =
      jniAccessors.getMethodIDOf(_classRef, "setLevel", "(I)Z");

  /// from: public final boolean setLevel(int level)
  ///
  /// Specify the level for the drawable.  This allows a drawable to vary its
  /// imagery based on a continuous controller, for example to show progress
  /// or volume level.
  ///
  /// If the new level you are supplying causes the appearance of the
  /// Drawable to change, then it is responsible for calling
  /// \#invalidateSelf in order to have itself redrawn, _and_
  /// true will be returned from this function.
  ///@param level The new level, from 0 (minimum) to 10000 (maximum).
  ///
  /// Value is between 0 and 10000 inclusive
  ///@return Returns true if this change in level has caused the appearance
  /// of the Drawable to change (hence requiring an invalidate), otherwise
  /// returns false.
  bool setLevel(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_setLevel, jni.JniType.booleanType, [level]).boolean;

  static final _id_getLevel =
      jniAccessors.getMethodIDOf(_classRef, "getLevel", "()I");

  /// from: public final int getLevel()
  ///
  /// Retrieve the current level.
  ///@return int Current level, from 0 (minimum) to 10000 (maximum).
  ///
  /// Value is between 0 and 10000 inclusive
  int getLevel() => jniAccessors.callMethodWithArgs(
      reference, _id_getLevel, jni.JniType.intType, []).integer;

  static final _id_setVisible =
      jniAccessors.getMethodIDOf(_classRef, "setVisible", "(ZZ)Z");

  /// from: public boolean setVisible(boolean visible, boolean restart)
  ///
  /// Set whether this Drawable is visible.  This generally does not impact
  /// the Drawable's behavior, but is a hint that can be used by some
  /// Drawables, for example, to decide whether run animations.
  ///@param visible Set to true if visible, false if not.
  ///@param restart You can supply true here to force the drawable to behave
  ///                as if it has just become visible, even if it had last
  ///                been set visible.  Used for example to force animations
  ///                to restart.
  ///@return boolean Returns true if the new visibility is different than
  ///         its previous state.
  bool setVisible(bool visible, bool restart) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVisible,
          jni.JniType.booleanType, [visible, restart]).boolean;

  static final _id_isVisible =
      jniAccessors.getMethodIDOf(_classRef, "isVisible", "()Z");

  /// from: public final boolean isVisible()
  bool isVisible() => jniAccessors.callMethodWithArgs(
      reference, _id_isVisible, jni.JniType.booleanType, []).boolean;

  static final _id_setAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "setAutoMirrored", "(Z)V");

  /// from: public void setAutoMirrored(boolean mirrored)
  ///
  /// Set whether this Drawable is automatically mirrored when its layout direction is RTL
  /// (right-to left). See android.util.LayoutDirection.
  ///@param mirrored Set to true if the Drawable should be mirrored, false if not.
  void setAutoMirrored(bool mirrored) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutoMirrored, jni.JniType.voidType, [mirrored]).check();

  static final _id_isAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "isAutoMirrored", "()Z");

  /// from: public boolean isAutoMirrored()
  ///
  /// Tells if this Drawable will be automatically mirrored  when its layout direction is RTL
  /// right-to-left. See android.util.LayoutDirection.
  ///@return boolean Returns true if this Drawable will be automatically mirrored.
  bool isAutoMirrored() => jniAccessors.callMethodWithArgs(
      reference, _id_isAutoMirrored, jni.JniType.booleanType, []).boolean;

  static final _id_applyTheme = jniAccessors.getMethodIDOf(
      _classRef, "applyTheme", "(Landroid/content/res/Resources\$Theme;)V");

  /// from: public void applyTheme(android.content.res.Resources.Theme t)
  ///
  /// Applies the specified theme to this Drawable and its children.
  ///@param t the theme to apply
  ///
  /// This value must never be {@code null}.
  void applyTheme(resources_.Resources_Theme t) =>
      jniAccessors.callMethodWithArgs(reference, _id_applyTheme,
          jni.JniType.voidType, [t.reference]).check();

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public abstract int getOpacity()
  ///
  /// Return the opacity/transparency of this Drawable.  The returned value is
  /// one of the abstract format constants in
  /// android.graphics.PixelFormat:
  /// android.graphics.PixelFormat\#UNKNOWN,
  /// android.graphics.PixelFormat\#TRANSLUCENT,
  /// android.graphics.PixelFormat\#TRANSPARENT, or
  /// android.graphics.PixelFormat\#OPAQUE.
  ///
  /// An OPAQUE drawable is one that draws all all content within its bounds, completely
  /// covering anything behind the drawable. A TRANSPARENT drawable is one that draws nothing
  /// within its bounds, allowing everything behind it to show through. A TRANSLUCENT drawable
  /// is a drawable in any other state, where the drawable will draw some, but not all,
  /// of the content within its bounds and at least some content behind the drawable will
  /// be visible. If the visibility of the drawable's contents cannot be determined, the
  /// safest/best return value is TRANSLUCENT.
  ///
  /// Generally a Drawable should be as conservative as possible with the
  /// value it returns.  For example, if it contains multiple child drawables
  /// and only shows one of them at a time, if only one of the children is
  /// TRANSLUCENT and the others are OPAQUE then TRANSLUCENT should be
  /// returned.  You can use the method \#resolveOpacity to perform a
  /// standard reduction of two opacities to the appropriate single output.
  ///
  /// Note that the returned value does not necessarily take into account a
  /// custom alpha or color filter that has been applied by the client through
  /// the \#setAlpha or \#setColorFilter methods. Some subclasses,
  /// such as BitmapDrawable, ColorDrawable, and GradientDrawable,
  /// do account for the value of \#setAlpha, but the general behavior is dependent
  /// upon the implementation of the subclass.
  ///@return int The opacity class of the Drawable.
  ///
  /// Value is android.graphics.PixelFormat\#UNKNOWN, android.graphics.PixelFormat\#TRANSLUCENT, android.graphics.PixelFormat\#TRANSPARENT, or android.graphics.PixelFormat\#OPAQUE
  ///@see android.graphics.PixelFormat
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_resolveOpacity =
      jniAccessors.getStaticMethodIDOf(_classRef, "resolveOpacity", "(II)I");

  /// from: static public int resolveOpacity(int op1, int op2)
  ///
  /// Return the appropriate opacity value for two source opacities.  If
  /// either is UNKNOWN, that is returned; else, if either is TRANSLUCENT,
  /// that is returned; else, if either is TRANSPARENT, that is returned;
  /// else, OPAQUE is returned.
  ///
  /// This is to help in implementing \#getOpacity.
  ///@param op1 One opacity value.
  /// Value is android.graphics.PixelFormat\#UNKNOWN, android.graphics.PixelFormat\#TRANSLUCENT, android.graphics.PixelFormat\#TRANSPARENT, or android.graphics.PixelFormat\#OPAQUE
  ///@param op2 Another opacity value.
  ///
  /// Value is android.graphics.PixelFormat\#UNKNOWN, android.graphics.PixelFormat\#TRANSLUCENT, android.graphics.PixelFormat\#TRANSPARENT, or android.graphics.PixelFormat\#OPAQUE
  ///@return int The combined opacity value.
  ///
  /// Value is android.graphics.PixelFormat\#UNKNOWN, android.graphics.PixelFormat\#TRANSLUCENT, android.graphics.PixelFormat\#TRANSPARENT, or android.graphics.PixelFormat\#OPAQUE
  ///@see \#getOpacity
  static int resolveOpacity(int op1, int op2) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_resolveOpacity,
          jni.JniType.intType, [op1, op2]).integer;

  static final _id_getTransparentRegion = jniAccessors.getMethodIDOf(
      _classRef, "getTransparentRegion", "()Landroid/graphics/Region;");

  /// from: public android.graphics.Region getTransparentRegion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Region representing the part of the Drawable that is completely
  /// transparent.  This can be used to perform drawing operations, identifying
  /// which parts of the target will not change when rendering the Drawable.
  /// The default implementation returns null, indicating no transparent
  /// region; subclasses can optionally override this to return an actual
  /// Region if they want to supply this optimization information, but it is
  /// not required that they do so.
  ///@return Returns null if the Drawables has no transparent region to
  /// report, else a Region holding the parts of the Drawable's bounds that
  /// are transparent.
  region_.Region getTransparentRegion() =>
      region_.Region.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTransparentRegion, jni.JniType.objectType, []).object);

  static final _id_onStateChange =
      jniAccessors.getMethodIDOf(_classRef, "onStateChange", "([I)Z");

  /// from: protected boolean onStateChange(int[] state)
  ///
  /// Override this in your subclass to change appearance if you recognize the
  /// specified state.
  ///@return Returns true if the state change has caused the appearance of
  /// the Drawable to change (that is, it needs to be drawn), else false
  /// if it looks the same and there is no need to redraw it since its
  /// last state.
  bool onStateChange(jni.JniObject state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStateChange,
      jni.JniType.booleanType,
      [state.reference]).boolean;

  static final _id_onLevelChange =
      jniAccessors.getMethodIDOf(_classRef, "onLevelChange", "(I)Z");

  /// from: protected boolean onLevelChange(int level)
  ///
  /// Override this in your subclass to change appearance if you vary based
  ///  on level.
  ///@return Returns true if the level change has caused the appearance of
  /// the Drawable to change (that is, it needs to be drawn), else false
  /// if it looks the same and there is no need to redraw it since its
  /// last level.
  bool onLevelChange(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onLevelChange, jni.JniType.booleanType, [level]).boolean;

  static final _id_onBoundsChange = jniAccessors.getMethodIDOf(
      _classRef, "onBoundsChange", "(Landroid/graphics/Rect;)V");

  /// from: protected void onBoundsChange(android.graphics.Rect bounds)
  ///
  /// Override this in your subclass to change appearance if you vary based on
  /// the bounds.
  void onBoundsChange(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBoundsChange,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_getIntrinsicWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicWidth", "()I");

  /// from: public int getIntrinsicWidth()
  ///
  /// Returns the drawable's intrinsic width.
  ///
  /// Intrinsic width is the width at which the drawable would like to be laid
  /// out, including any inherent padding. If the drawable has no intrinsic
  /// width, such as a solid color, this method returns -1.
  ///@return the intrinsic width, or -1 if no intrinsic width
  int getIntrinsicWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicWidth, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicHeight", "()I");

  /// from: public int getIntrinsicHeight()
  ///
  /// Returns the drawable's intrinsic height.
  ///
  /// Intrinsic height is the height at which the drawable would like to be
  /// laid out, including any inherent padding. If the drawable has no
  /// intrinsic height, such as a solid color, this method returns -1.
  ///@return the intrinsic height, or -1 if no intrinsic height
  int getIntrinsicHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicHeight, jni.JniType.intType, []).integer;

  static final _id_getMinimumWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumWidth", "()I");

  /// from: public int getMinimumWidth()
  ///
  /// Returns the minimum width suggested by this Drawable. If a View uses this
  /// Drawable as a background, it is suggested that the View use at least this
  /// value for its width. (There will be some scenarios where this will not be
  /// possible.) This value should INCLUDE any padding.
  ///@return The minimum width suggested by this Drawable. If this Drawable
  ///         doesn't have a suggested minimum width, 0 is returned.
  int getMinimumWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumWidth, jni.JniType.intType, []).integer;

  static final _id_getMinimumHeight =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumHeight", "()I");

  /// from: public int getMinimumHeight()
  ///
  /// Returns the minimum height suggested by this Drawable. If a View uses this
  /// Drawable as a background, it is suggested that the View use at least this
  /// value for its height. (There will be some scenarios where this will not be
  /// possible.) This value should INCLUDE any padding.
  ///@return The minimum height suggested by this Drawable. If this Drawable
  ///         doesn't have a suggested minimum height, 0 is returned.
  int getMinimumHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumHeight, jni.JniType.intType, []).integer;

  static final _id_getPadding = jniAccessors.getMethodIDOf(
      _classRef, "getPadding", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean getPadding(android.graphics.Rect padding)
  ///
  /// Return in padding the insets suggested by this Drawable for placing
  /// content inside the drawable's bounds. Positive values move toward the
  /// center of the Drawable (set Rect.inset).
  ///@param padding This value must never be {@code null}.
  ///@return true if this drawable actually has a padding, else false. When false is returned,
  /// the padding is always set to 0.
  bool getPadding(rect_.Rect padding) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPadding,
      jni.JniType.booleanType,
      [padding.reference]).boolean;

  static final _id_getOutline = jniAccessors.getMethodIDOf(
      _classRef, "getOutline", "(Landroid/graphics/Outline;)V");

  /// from: public void getOutline(android.graphics.Outline outline)
  ///
  /// Called to get the drawable to populate the Outline that defines its drawing area.
  ///
  /// This method is called by the default android.view.ViewOutlineProvider to define
  /// the outline of the View.
  ///
  /// The default behavior defines the outline to be the bounding rectangle of 0 alpha.
  /// Subclasses that wish to convey a different shape or alpha value must override this method.
  ///@see android.view.View\#setOutlineProvider(android.view.ViewOutlineProvider)
  ///@param outline This value must never be {@code null}.
  void getOutline(outline_.Outline outline) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getOutline,
      jni.JniType.voidType,
      [outline.reference]).check();

  static final _id_mutate = jniAccessors.getMethodIDOf(
      _classRef, "mutate", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable mutate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make this drawable mutable. This operation cannot be reversed. A mutable
  /// drawable is guaranteed to not share its state with any other drawable.
  /// This is especially useful when you need to modify properties of drawables
  /// loaded from resources. By default, all drawables instances loaded from
  /// the same resource share a common state; if you modify the state of one
  /// instance, all the other instances will receive the same modification.
  ///
  /// Calling this method on a mutable Drawable will have no effect.
  ///@return This drawable.
  /// This value will never be {@code null}.
  ///@see ConstantState
  ///@see \#getConstantState()
  Drawable mutate() => Drawable.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_mutate, jni.JniType.objectType, []).object);

  static final _id_createFromStream = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromStream",
      "(Ljava/io/InputStream;Ljava/lang/String;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable createFromStream(java.io.InputStream is, java.lang.String srcName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable from an inputstream
  static Drawable createFromStream(jni.JniObject is0, jni.JniString srcName) =>
      Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromStream,
          jni.JniType.objectType,
          [is0.reference, srcName.reference]).object);

  static final _id_createFromResourceStream = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromResourceStream",
      "(Landroid/content/res/Resources;Landroid/util/TypedValue;Ljava/io/InputStream;Ljava/lang/String;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable createFromResourceStream(android.content.res.Resources res, android.util.TypedValue value, java.io.InputStream is, java.lang.String srcName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable from an inputstream, using the given resources and
  /// value to determine density information.
  static Drawable createFromResourceStream(
          resources_.Resources res,
          typedvalue_.TypedValue value,
          jni.JniObject is0,
          jni.JniString srcName) =>
      Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createFromResourceStream, jni.JniType.objectType, [
        res.reference,
        value.reference,
        is0.reference,
        srcName.reference
      ]).object);

  static final _id_createFromResourceStream1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromResourceStream",
      "(Landroid/content/res/Resources;Landroid/util/TypedValue;Ljava/io/InputStream;Ljava/lang/String;Landroid/graphics/BitmapFactory\$Options;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable createFromResourceStream(android.content.res.Resources res, android.util.TypedValue value, java.io.InputStream is, java.lang.String srcName, android.graphics.BitmapFactory.Options opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable from an inputstream, using the given resources and
  /// value to determine density information.
  ///@deprecated Prefer the version without an Options object.
  ///@param res This value may be {@code null}.
  ///@param value This value may be {@code null}.
  ///@param is This value may be {@code null}.
  ///@param srcName This value may be {@code null}.
  ///@param opts This value may be {@code null}.
  ///@return This value may be {@code null}.
  static Drawable createFromResourceStream1(
          resources_.Resources res,
          typedvalue_.TypedValue value,
          jni.JniObject is0,
          jni.JniString srcName,
          bitmapfactory_.BitmapFactory_Options opts) =>
      Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createFromResourceStream1, jni.JniType.objectType, [
        res.reference,
        value.reference,
        is0.reference,
        srcName.reference,
        opts.reference
      ]).object);

  static final _id_createFromXml = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromXml",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable createFromXml(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable from an XML document. For more information on how to
  /// create resources in XML, see
  /// <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>.
  ///@param r This value must never be {@code null}.
  ///@param parser This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  static Drawable createFromXml(resources_.Resources r, jni.JniObject parser) =>
      Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromXml,
          jni.JniType.objectType,
          [r.reference, parser.reference]).object);

  static final _id_createFromXml1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromXml",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/content/res/Resources\$Theme;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable createFromXml(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.content.res.Resources.Theme theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable from an XML document using an optional Theme.
  /// For more information on how to create resources in XML, see
  /// <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>.
  ///@param r This value must never be {@code null}.
  ///@param parser This value must never be {@code null}.
  ///@param theme This value may be {@code null}.
  ///@return This value will never be {@code null}.
  static Drawable createFromXml1(resources_.Resources r, jni.JniObject parser,
          resources_.Resources_Theme theme) =>
      Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromXml1,
          jni.JniType.objectType,
          [r.reference, parser.reference, theme.reference]).object);

  static final _id_createFromXmlInner = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromXmlInner",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable createFromXmlInner(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create from inside an XML document.  Called on a parser positioned at
  /// a tag in an XML document, tries to create a Drawable from that tag.
  /// Returns null if the tag is not a valid drawable.
  ///@param r This value must never be {@code null}.
  ///@param parser This value must never be {@code null}.
  ///@param attrs This value must never be {@code null}.
  static Drawable createFromXmlInner(resources_.Resources r,
          jni.JniObject parser, attributeset_.AttributeSet attrs) =>
      Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromXmlInner,
          jni.JniType.objectType,
          [r.reference, parser.reference, attrs.reference]).object);

  static final _id_createFromXmlInner1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromXmlInner",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;Landroid/content/res/Resources\$Theme;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable createFromXmlInner(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs, android.content.res.Resources.Theme theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable from inside an XML document using an optional
  /// Theme. Called on a parser positioned at a tag in an XML
  /// document, tries to create a Drawable from that tag. Returns {@code null}
  /// if the tag is not a valid drawable.
  ///@param r This value must never be {@code null}.
  ///@param parser This value must never be {@code null}.
  ///@param attrs This value must never be {@code null}.
  ///@param theme This value may be {@code null}.
  static Drawable createFromXmlInner1(
          resources_.Resources r,
          jni.JniObject parser,
          attributeset_.AttributeSet attrs,
          resources_.Resources_Theme theme) =>
      Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createFromXmlInner1, jni.JniType.objectType, [
        r.reference,
        parser.reference,
        attrs.reference,
        theme.reference
      ]).object);

  static final _id_createFromPath = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromPath",
      "(Ljava/lang/String;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable createFromPath(java.lang.String pathName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable from file path name.
  ///@return This value may be {@code null}.
  static Drawable createFromPath(jni.JniString pathName) =>
      Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromPath,
          jni.JniType.objectType,
          [pathName.reference]).object);

  static final _id_inflate = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;)V");

  /// from: public void inflate(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs)
  ///
  /// Inflate this Drawable from an XML resource. Does not apply a theme.
  ///@see \#inflate(Resources, XmlPullParser, AttributeSet, Theme)
  ///@param r This value must never be {@code null}.
  ///@param parser This value must never be {@code null}.
  ///@param attrs This value must never be {@code null}.
  void inflate(resources_.Resources r, jni.JniObject parser,
          attributeset_.AttributeSet attrs) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_inflate,
          jni.JniType.voidType,
          [r.reference, parser.reference, attrs.reference]).check();

  static final _id_inflate1 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;Landroid/content/res/Resources\$Theme;)V");

  /// from: public void inflate(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs, android.content.res.Resources.Theme theme)
  ///
  /// Inflate this Drawable from an XML resource optionally styled by a theme.
  /// This can't be called more than once for each Drawable. Note that framework may have called
  /// this once to create the Drawable instance from XML resource.
  ///@param r Resources used to resolve attribute values
  /// This value must never be {@code null}.
  ///@param parser XML parser from which to inflate this Drawable
  /// This value must never be {@code null}.
  ///@param attrs Base set of attribute values
  /// This value must never be {@code null}.
  ///@param theme Theme to apply, may be null
  /// This value may be {@code null}.
  ///@throws XmlPullParserException
  ///@throws IOException
  void inflate1(resources_.Resources r, jni.JniObject parser,
          attributeset_.AttributeSet attrs, resources_.Resources_Theme theme) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_inflate1, jni.JniType.voidType, [
        r.reference,
        parser.reference,
        attrs.reference,
        theme.reference
      ]).check();

  static final _id_getConstantState = jniAccessors.getMethodIDOf(
      _classRef,
      "getConstantState",
      "()Landroid/graphics/drawable/Drawable\$ConstantState;");

  /// from: public android.graphics.drawable.Drawable.ConstantState getConstantState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a ConstantState instance that holds the shared state of this Drawable.
  ///@return The ConstantState associated to that Drawable.
  /// This value may be {@code null}.
  ///@see ConstantState
  ///@see Drawable\#mutate()
  Drawable_ConstantState getConstantState() =>
      Drawable_ConstantState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConstantState, jni.JniType.objectType, []).object);
}

/// from: android.graphics.drawable.Drawable$ConstantState
///
/// This abstract class is used by Drawables to store shared constant state and data
/// between Drawables. BitmapDrawables created from the same resource will for instance
/// share a unique bitmap stored in their ConstantState.
///
///
/// \#newDrawable(Resources) can be used as a factory to create new Drawable instances
/// from this ConstantState.
///
///
///
/// Use Drawable\#getConstantState() to retrieve the ConstantState of a Drawable. Calling
/// Drawable\#mutate() on a Drawable should typically create a new ConstantState for that
/// Drawable.
class Drawable_ConstantState extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/graphics/drawable/Drawable\$ConstantState");
  Drawable_ConstantState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Drawable_ConstantState()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_newDrawable = jniAccessors.getMethodIDOf(
      _classRef, "newDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable newDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new Drawable instance from its constant state.
  ///
  /// <strong>Note:</strong> Using this method means density-dependent
  /// properties, such as pixel dimensions or bitmap images, will not be
  /// updated to match the density of the target display. To ensure
  /// correct scaling, use \#newDrawable(Resources) instead to
  /// provide an appropriate Resources object.
  ///@return a new drawable object based on this constant state
  /// This value will never be {@code null}.
  ///@see \#newDrawable(Resources)
  Drawable newDrawable() => Drawable.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_newDrawable, jni.JniType.objectType, []).object);

  static final _id_newDrawable1 = jniAccessors.getMethodIDOf(
      _classRef,
      "newDrawable",
      "(Landroid/content/res/Resources;)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable newDrawable(android.content.res.Resources res)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new Drawable instance from its constant state using the
  /// specified resources. This method should be implemented for drawables
  /// that have density-dependent properties.
  ///
  /// The default implementation for this method calls through to
  /// \#newDrawable().
  ///@param res the resources of the context in which the drawable will
  ///            be displayed
  /// This value may be {@code null}.
  ///@return a new drawable object based on this constant state
  ///
  /// This value will never be {@code null}.
  Drawable newDrawable1(resources_.Resources res) =>
      Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_newDrawable1, jni.JniType.objectType, [res.reference]).object);

  static final _id_newDrawable2 = jniAccessors.getMethodIDOf(
      _classRef,
      "newDrawable",
      "(Landroid/content/res/Resources;Landroid/content/res/Resources\$Theme;)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable newDrawable(android.content.res.Resources res, android.content.res.Resources.Theme theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new Drawable instance from its constant state using the
  /// specified resources and theme. This method should be implemented for
  /// drawables that have theme-dependent properties.
  ///
  /// The default implementation for this method calls through to
  /// \#newDrawable(Resources).
  ///@param res the resources of the context in which the drawable will
  ///            be displayed
  /// This value may be {@code null}.
  ///@param theme the theme of the context in which the drawable will be
  ///              displayed
  /// This value may be {@code null}.
  ///@return a new drawable object based on this constant state
  ///
  /// This value will never be {@code null}.
  Drawable newDrawable2(
          resources_.Resources res, resources_.Resources_Theme theme) =>
      Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_newDrawable2,
          jni.JniType.objectType,
          [res.reference, theme.reference]).object);

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public abstract int getChangingConfigurations()
  ///
  /// Return a bit mask of configuration changes that will impact
  /// this drawable (and thus require completely reloading it).
  ///@return Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  ///
  /// Return whether this constant state can have a theme applied.
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;
}

/// from: android.graphics.drawable.Drawable$Callback
///
/// Implement this interface if you want to create an animated drawable that
/// extends android.graphics.drawable.Drawable Drawable.
/// Upon retrieving a drawable, use
/// Drawable\#setCallback(android.graphics.drawable.Drawable.Callback)
/// to supply your implementation of the interface to the drawable; it uses
/// this interface to schedule and execute animation changes.
class Drawable_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/drawable/Drawable\$Callback");
  Drawable_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_invalidateDrawable = jniAccessors.getMethodIDOf(_classRef,
      "invalidateDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public abstract void invalidateDrawable(android.graphics.drawable.Drawable who)
  ///
  /// Called when the drawable needs to be redrawn.  A view at this point
  /// should invalidate itself (or at least the part of itself where the
  /// drawable appears).
  ///@param who The drawable that is requesting the update.
  ///
  /// This value must never be {@code null}.
  void invalidateDrawable(Drawable who) => jniAccessors.callMethodWithArgs(
      reference,
      _id_invalidateDrawable,
      jni.JniType.voidType,
      [who.reference]).check();

  static final _id_scheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "scheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;J)V");

  /// from: public abstract void scheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what, long when)
  ///
  /// A Drawable can call this to schedule the next frame of its
  /// animation.  An implementation can generally simply call
  /// android.os.Handler\#postAtTime(Runnable, Object, long) with
  /// the parameters <var>(what, who, when)</var> to perform the
  /// scheduling.
  ///@param who The drawable being scheduled.
  /// This value must never be {@code null}.
  ///@param what The action to execute.
  /// This value must never be {@code null}.
  ///@param when The time (in milliseconds) to run.  The timebase is
  ///             android.os.SystemClock\#uptimeMillis
  void scheduleDrawable(Drawable who, jni.JniObject what, int when) =>
      jniAccessors.callMethodWithArgs(reference, _id_scheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference, when]).check();

  static final _id_unscheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "unscheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;)V");

  /// from: public abstract void unscheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what)
  ///
  /// A Drawable can call this to unschedule an action previously
  /// scheduled with \#scheduleDrawable.  An implementation can
  /// generally simply call
  /// android.os.Handler\#removeCallbacks(Runnable, Object) with
  /// the parameters <var>(what, who)</var> to unschedule the drawable.
  ///@param who The drawable being unscheduled.
  /// This value must never be {@code null}.
  ///@param what The action being unscheduled.
  ///
  /// This value must never be {@code null}.
  void unscheduleDrawable(Drawable who, jni.JniObject what) =>
      jniAccessors.callMethodWithArgs(reference, _id_unscheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference]).check();
}
