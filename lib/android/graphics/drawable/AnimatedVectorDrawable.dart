// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Drawable.dart" as drawable_;

import "../Canvas.dart" as canvas_;

import "../Rect.dart" as rect_;

import "../ColorFilter.dart" as colorfilter_;

import "../../content/res/ColorStateList.dart" as colorstatelist_;

import "../PorterDuff.dart" as porterduff_;

import "../Outline.dart" as outline_;

import "../../content/res/Resources.dart" as resources_;

import "../../util/AttributeSet.dart" as attributeset_;

import "Animatable2.dart" as animatable2_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.drawable.AnimatedVectorDrawable
///
/// This class animates properties of a android.graphics.drawable.VectorDrawable with
/// animations defined using android.animation.ObjectAnimator or
/// android.animation.AnimatorSet.
///
/// Starting from API 25, AnimatedVectorDrawable runs on RenderThread (as opposed to on UI thread for
/// earlier APIs). This means animations in AnimatedVectorDrawable can remain smooth even when there
/// is heavy workload on the UI thread. Note: If the UI thread is unresponsive, RenderThread may
/// continue animating until the UI thread is capable of pushing another frame. Therefore, it is not
/// possible to precisely coordinate a RenderThread-enabled AnimatedVectorDrawable with UI thread
/// animations. Additionally,
/// android.graphics.drawable.Animatable2.AnimationCallback\#onAnimationEnd(Drawable) will be
/// called the frame after the AnimatedVectorDrawable finishes on the RenderThread.
///
///
///
/// AnimatedVectorDrawable can be defined in either <a href="\#ThreeXML">three separate XML files</a>,
/// or <a href="\#OneXML">one XML</a>.
///
///
/// <a name="ThreeXML"></a>
/// <h3>Define an AnimatedVectorDrawable in three separate XML files</h3>
/// <ul>
/// <a name="VDExample"></a>
/// <li><h4>XML for the VectorDrawable containing properties to be animated</h4>
///
/// Animations can be performed on the animatable attributes in
/// android.graphics.drawable.VectorDrawable. These attributes will be animated by
/// android.animation.ObjectAnimator. The ObjectAnimator's target can be the root element,
/// a group element or a path element. The targeted elements need to be named uniquely within
/// the same VectorDrawable. Elements without animation do not need to be named.
///
///
///
/// Here are all the animatable attributes in android.graphics.drawable.VectorDrawable:
/// <table border="2"align="center"cellpadding="5">
///     <thead>
///         <tr>
///             <th>Element Name</th>
///             <th>Animatable attribute name</th>
///         </tr>
///     </thead>
///     <tr>
///         <td>&lt;vector&gt;</td>
///         <td>alpha</td>
///     </tr>
///     <tr>
///         <td rowspan="7">&lt;group&gt;</td>
///         <td>rotation</td>
///     </tr>
///     <tr>
///         <td>pivotX</td>
///     </tr>
///     <tr>
///         <td>pivotY</td>
///     </tr>
///     <tr>
///         <td>scaleX</td>
///     </tr>
///     <tr>
///         <td>scaleY</td>
///     </tr>
///     <tr>
///         <td>translateX</td>
///     </tr>
///     <tr>
///         <td>translateY</td>
///     </tr>
///     <tr>
///         <td rowspan="9">&lt;path&gt;</td>
///         <td>pathData</td>
///     </tr>
///     <tr>
///         <td>fillColor</td>
///     </tr>
///     <tr>
///         <td>strokeColor</td>
///     </tr>
///     <tr>
///         <td>strokeWidth</td>
///     </tr>
///     <tr>
///         <td>strokeAlpha</td>
///     </tr>
///     <tr>
///         <td>fillAlpha</td>
///     </tr>
///     <tr>
///         <td>trimPathStart</td>
///     </tr>
///     <tr>
///         <td>trimPathEnd</td>
///     </tr>
///     <tr>
///         <td>trimPathOffset</td>
///     </tr>
///     <tr>
///         <td>&lt;clip-path&gt;</td>
///         <td>pathData</td>
///     </tr>
/// </table>
///
///
/// Below is an example of a VectorDrawable defined in vectordrawable.xml. This VectorDrawable is
/// referred to by its file name (not including file suffix) in the
/// <a href="\#AVDExample">AnimatedVectorDrawable XML example</a>.
/// <pre>
/// &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
///     android:height=&quot;64dp&quot;
///     android:width=&quot;64dp&quot;
///     android:viewportHeight=&quot;600&quot;
///     android:viewportWidth=&quot;600&quot; &gt;
///     &lt;group
///         android:name=&quot;rotationGroup&quot;
///         android:pivotX=&quot;300.0&quot;
///         android:pivotY=&quot;300.0&quot;
///         android:rotation=&quot;45.0&quot; &gt;
///         &lt;path
///             android:name=&quot;v&quot;
///             android:fillColor=&quot;\#000000&quot;
///             android:pathData=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot; /&gt;
///     &lt;/group&gt;
/// &lt;/vector&gt;
/// </pre></li>
///
/// <a name="AVDExample"></a>
/// <li><h4>XML for AnimatedVectorDrawable</h4>
///
/// An AnimatedVectorDrawable element has a VectorDrawable attribute, and one or more target
/// element(s). The target element can specify its target by android:name attribute, and link the
/// target with the proper ObjectAnimator or AnimatorSet by android:animation attribute.
///
///
/// The following code sample defines an AnimatedVectorDrawable. Note that the names refer to the
/// groups and paths in the <a href="\#VDExample">VectorDrawable XML above</a>.
/// <pre>
/// &lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
///     android:drawable=&quot;@drawable/vectordrawable&quot; &gt;
///     &lt;target
///         android:name=&quot;rotationGroup&quot;
///         android:animation=&quot;@animator/rotation&quot; /&gt;
///     &lt;target
///         android:name=&quot;v&quot;
///         android:animation=&quot;@animator/path_morph&quot; /&gt;
/// &lt;/animated-vector&gt;
/// </pre>
/// </li>
///
/// <li><h4>XML for Animations defined using ObjectAnimator or AnimatorSet</h4>
///
/// From the previous <a href="\#AVDExample">example of AnimatedVectorDrawable</a>, two animations
/// were used: rotation.xml and path_morph.xml.
///
///
/// rotation.xml rotates the target group from 0 degree to 360 degrees over 6000ms:
/// <pre>
/// &lt;objectAnimator
///     android:duration=&quot;6000&quot;
///     android:propertyName=&quot;rotation&quot;
///     android:valueFrom=&quot;0&quot;
///     android:valueTo=&quot;360&quot; /&gt;
/// </pre>
///
/// path_morph.xml morphs the path from one shape into the other. Note that the paths must be
/// compatible for morphing. Specifically, the paths must have the same commands, in the same order,
/// and must have the same number of parameters for each command. It is recommended to store path
/// strings as string resources for reuse.
/// <pre>
/// &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
///     &lt;objectAnimator
///         android:duration=&quot;3000&quot;
///         android:propertyName=&quot;pathData&quot;
///         android:valueFrom=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot;
///         android:valueTo=&quot;M300,70 l 0,-70 70,0  0,140 -70,0 z&quot;
///         android:valueType=&quot;pathType&quot;/&gt;
/// &lt;/set&gt;
/// </pre>
/// </ul>
/// <a name="OneXML"></a>
/// <h3>Define an AnimatedVectorDrawable all in one XML file</h3>
///
/// Since the AAPT tool supports a new format that bundles several related XML files together, we can
/// merge the XML files from the previous examples into one XML file:
///
///
/// <pre>
/// &lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
///                  xmlns:aapt=&quothttp://schemas.android.com/aapt&quot; &gt;
///     &lt;aapt:attr name="android:drawable"&gt;
///         &lt;vector
///             android:height=&quot;64dp&quot;
///             android:width=&quot;64dp&quot;
///             android:viewportHeight=&quot;600&quot;
///             android:viewportWidth=&quot;600&quot; &gt;
///             &lt;group
///                 android:name=&quot;rotationGroup&quot;
///                 android:pivotX=&quot;300.0&quot;
///                 android:pivotY=&quot;300.0&quot;
///                 android:rotation=&quot;45.0&quot; &gt;
///                 &lt;path
///                     android:name=&quot;v&quot;
///                     android:fillColor=&quot;\#000000&quot;
///                     android:pathData=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot; /&gt;
///             &lt;/group&gt;
///         &lt;/vector&gt;
///     &lt;/aapt:attr&gt;
///
///     &lt;target android:name=&quot;rotationGroup&quot;&gt; *
///         &lt;aapt:attr name="android:animation"&gt;
///             &lt;objectAnimator
///             android:duration=&quot;6000&quot;
///             android:propertyName=&quot;rotation&quot;
///             android:valueFrom=&quot;0&quot;
///             android:valueTo=&quot;360&quot; /&gt;
///         &lt;/aapt:attr&gt;
///     &lt;/target&gt;
///
///     &lt;target android:name=&quot;v&quot; &gt;
///         &lt;aapt:attr name="android:animation"&gt;
///             &lt;set&gt;
///                 &lt;objectAnimator
///                     android:duration=&quot;3000&quot;
///                     android:propertyName=&quot;pathData&quot;
///                     android:valueFrom=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot;
///                     android:valueTo=&quot;M300,70 l 0,-70 70,0  0,140 -70,0 z&quot;
///                     android:valueType=&quot;pathType&quot;/&gt;
///             &lt;/set&gt;
///         &lt;/aapt:attr&gt;
///      &lt;/target&gt;
/// &lt;/animated-vector&gt;
/// </pre>
///@attr ref android.R.styleable\#AnimatedVectorDrawable_drawable
///@attr ref android.R.styleable\#AnimatedVectorDrawableTarget_name
///@attr ref android.R.styleable\#AnimatedVectorDrawableTarget_animation
class AnimatedVectorDrawable extends drawable_.Drawable {
  static final _classRef = jniAccessors
      .getClassOf("android/graphics/drawable/AnimatedVectorDrawable");
  AnimatedVectorDrawable.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AnimatedVectorDrawable()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_mutate = jniAccessors.getMethodIDOf(
      _classRef, "mutate", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable mutate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable mutate() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_mutate, jni.JniType.objectType, []).object);

  static final _id_getConstantState = jniAccessors.getMethodIDOf(
      _classRef,
      "getConstantState",
      "()Landroid/graphics/drawable/Drawable\$ConstantState;");

  /// from: public android.graphics.drawable.Drawable.ConstantState getConstantState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable_ConstantState getConstantState() =>
      drawable_.Drawable_ConstantState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConstantState, jni.JniType.objectType, []).object);

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// @return Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  ///
  /// Draws the AnimatedVectorDrawable into the given canvas.
  ///
  /// <strong>Note:</strong> Calling this method with a software canvas when the
  /// AnimatedVectorDrawable is being animated on RenderThread (for API 25 and later) may yield
  /// outdated result, as the UI thread is not guaranteed to be in sync with RenderThread on
  /// VectorDrawable's property changes during RenderThread animations.
  ///
  ///
  ///@param canvas The canvas to draw into
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_onBoundsChange = jniAccessors.getMethodIDOf(
      _classRef, "onBoundsChange", "(Landroid/graphics/Rect;)V");

  /// from: protected void onBoundsChange(android.graphics.Rect bounds)
  void onBoundsChange(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBoundsChange,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_onStateChange =
      jniAccessors.getMethodIDOf(_classRef, "onStateChange", "([I)Z");

  /// from: protected boolean onStateChange(int[] state)
  bool onStateChange(jni.JniObject state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStateChange,
      jni.JniType.booleanType,
      [state.reference]).boolean;

  static final _id_onLevelChange =
      jniAccessors.getMethodIDOf(_classRef, "onLevelChange", "(I)Z");

  /// from: protected boolean onLevelChange(int level)
  bool onLevelChange(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onLevelChange, jni.JniType.booleanType, [level]).boolean;

  static final _id_onLayoutDirectionChanged =
      jniAccessors.getMethodIDOf(_classRef, "onLayoutDirectionChanged", "(I)Z");

  /// from: public boolean onLayoutDirectionChanged(int layoutDirection)
  ///
  /// @param layoutDirection Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  bool onLayoutDirectionChanged(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayoutDirectionChanged,
          jni.JniType.booleanType, [layoutDirection]).boolean;

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  ///
  /// For API 25 and later, AnimatedVectorDrawable runs on RenderThread. Therefore, when the
  /// root alpha is being animated, this getter does not guarantee to return an up-to-date alpha
  /// value.
  ///@return the containing vector drawable's root alpha value.
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int alpha)
  void setAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public void setColorFilter(android.graphics.ColorFilter colorFilter)
  void setColorFilter(colorfilter_.ColorFilter colorFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [colorFilter.reference]).check();

  static final _id_getColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "getColorFilter", "()Landroid/graphics/ColorFilter;");

  /// from: public android.graphics.ColorFilter getColorFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  colorfilter_.ColorFilter getColorFilter() =>
      colorfilter_.ColorFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorFilter, jni.JniType.objectType, []).object);

  static final _id_setTintList = jniAccessors.getMethodIDOf(
      _classRef, "setTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTintList(android.content.res.ColorStateList tint)
  void setTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_setHotspot =
      jniAccessors.getMethodIDOf(_classRef, "setHotspot", "(FF)V");

  /// from: public void setHotspot(float x, float y)
  void setHotspot(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_setHotspot, jni.JniType.voidType, [x, y]).check();

  static final _id_setHotspotBounds =
      jniAccessors.getMethodIDOf(_classRef, "setHotspotBounds", "(IIII)V");

  /// from: public void setHotspotBounds(int left, int top, int right, int bottom)
  void setHotspotBounds(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHotspotBounds,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_setTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setTintMode(android.graphics.PorterDuff.Mode tintMode)
  void setTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_setVisible =
      jniAccessors.getMethodIDOf(_classRef, "setVisible", "(ZZ)Z");

  /// from: public boolean setVisible(boolean visible, boolean restart)
  bool setVisible(bool visible, bool restart) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVisible,
          jni.JniType.booleanType, [visible, restart]).boolean;

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public boolean isStateful()
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public int getOpacity()
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicWidth", "()I");

  /// from: public int getIntrinsicWidth()
  int getIntrinsicWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicWidth, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicHeight", "()I");

  /// from: public int getIntrinsicHeight()
  int getIntrinsicHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicHeight, jni.JniType.intType, []).integer;

  static final _id_getOutline = jniAccessors.getMethodIDOf(
      _classRef, "getOutline", "(Landroid/graphics/Outline;)V");

  /// from: public void getOutline(android.graphics.Outline outline)
  ///
  /// @param outline This value must never be {@code null}.
  void getOutline(outline_.Outline outline) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getOutline,
      jni.JniType.voidType,
      [outline.reference]).check();

  static final _id_inflate1 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;Landroid/content/res/Resources\$Theme;)V");

  /// from: public void inflate(android.content.res.Resources res, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs, android.content.res.Resources.Theme theme)
  void inflate1(resources_.Resources res, jni.JniObject parser,
          attributeset_.AttributeSet attrs, resources_.Resources_Theme theme) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_inflate1, jni.JniType.voidType, [
        res.reference,
        parser.reference,
        attrs.reference,
        theme.reference
      ]).check();

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;

  static final _id_applyTheme = jniAccessors.getMethodIDOf(
      _classRef, "applyTheme", "(Landroid/content/res/Resources\$Theme;)V");

  /// from: public void applyTheme(android.content.res.Resources.Theme t)
  void applyTheme(resources_.Resources_Theme t) =>
      jniAccessors.callMethodWithArgs(reference, _id_applyTheme,
          jni.JniType.voidType, [t.reference]).check();

  static final _id_isRunning =
      jniAccessors.getMethodIDOf(_classRef, "isRunning", "()Z");

  /// from: public boolean isRunning()
  bool isRunning() => jniAccessors.callMethodWithArgs(
      reference, _id_isRunning, jni.JniType.booleanType, []).boolean;

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Resets the AnimatedVectorDrawable to the start state as specified in the animators.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "()V");

  /// from: public void start()
  void start() => jniAccessors.callMethodWithArgs(
      reference, _id_start, jni.JniType.voidType, []).check();

  static final _id_stop = jniAccessors.getMethodIDOf(_classRef, "stop", "()V");

  /// from: public void stop()
  void stop() => jniAccessors.callMethodWithArgs(
      reference, _id_stop, jni.JniType.voidType, []).check();

  static final _id_registerAnimationCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerAnimationCallback",
      "(Landroid/graphics/drawable/Animatable2\$AnimationCallback;)V");

  /// from: public void registerAnimationCallback(android.graphics.drawable.Animatable2.AnimationCallback callback)
  ///
  /// @param callback This value must never be {@code null}.
  void registerAnimationCallback(
          animatable2_.Animatable2_AnimationCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerAnimationCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_unregisterAnimationCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterAnimationCallback",
      "(Landroid/graphics/drawable/Animatable2\$AnimationCallback;)Z");

  /// from: public boolean unregisterAnimationCallback(android.graphics.drawable.Animatable2.AnimationCallback callback)
  ///
  /// @param callback This value must never be {@code null}.
  bool unregisterAnimationCallback(
          animatable2_.Animatable2_AnimationCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterAnimationCallback,
          jni.JniType.booleanType,
          [callback.reference]).boolean;

  static final _id_clearAnimationCallbacks =
      jniAccessors.getMethodIDOf(_classRef, "clearAnimationCallbacks", "()V");

  /// from: public void clearAnimationCallbacks()
  void clearAnimationCallbacks() => jniAccessors.callMethodWithArgs(
      reference, _id_clearAnimationCallbacks, jni.JniType.voidType, []).check();
}
