// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Drawable.dart" as drawable_;

import "../../content/res/Resources.dart" as resources_;

import "../Bitmap.dart" as bitmap_;

import "../Paint.dart" as paint_;

import "../Canvas.dart" as canvas_;

import "../../util/DisplayMetrics.dart" as displaymetrics_;

import "../Shader.dart" as shader_;

import "../Rect.dart" as rect_;

import "../Outline.dart" as outline_;

import "../ColorFilter.dart" as colorfilter_;

import "../../content/res/ColorStateList.dart" as colorstatelist_;

import "../PorterDuff.dart" as porterduff_;

import "../../util/AttributeSet.dart" as attributeset_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.drawable.BitmapDrawable
///
/// A Drawable that wraps a bitmap and can be tiled, stretched, or aligned. You can create a
/// BitmapDrawable from a file path, an input stream, through XML inflation, or from
/// a android.graphics.Bitmap object.
/// It can be defined in an XML file with the <code>&lt;bitmap></code> element.  For more
/// information, see the guide to <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>.
///
///
/// Also see the android.graphics.Bitmap class, which handles the management and
/// transformation of raw bitmap graphics, and should be used when drawing to a
/// android.graphics.Canvas.
///
///
///@attr ref android.R.styleable\#BitmapDrawable_src
///@attr ref android.R.styleable\#BitmapDrawable_antialias
///@attr ref android.R.styleable\#BitmapDrawable_filter
///@attr ref android.R.styleable\#BitmapDrawable_dither
///@attr ref android.R.styleable\#BitmapDrawable_gravity
///@attr ref android.R.styleable\#BitmapDrawable_mipMap
///@attr ref android.R.styleable\#BitmapDrawable_tileMode
class BitmapDrawable extends drawable_.Drawable {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/drawable/BitmapDrawable");
  BitmapDrawable.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty drawable, not dealing with density.
  ///@deprecated Use \#BitmapDrawable(android.content.res.Resources, android.graphics.Bitmap)
  /// instead to specify a bitmap to draw with and ensure the correct density is set.
  BitmapDrawable()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/res/Resources;)V");

  /// from: public void <init>(android.content.res.Resources res)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty drawable, setting initial target density based on
  /// the display metrics of the resources.
  ///@deprecated Use \#BitmapDrawable(android.content.res.Resources, android.graphics.Bitmap)
  /// instead to specify a bitmap to draw with.
  BitmapDrawable.ctor1(resources_.Resources res)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [res.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Bitmap;)V");

  /// from: public void <init>(android.graphics.Bitmap bitmap)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create drawable from a bitmap, not dealing with density.
  ///@deprecated Use \#BitmapDrawable(Resources, Bitmap) to ensure
  /// that the drawable has correctly set its target density.
  BitmapDrawable.ctor2(bitmap_.Bitmap bitmap)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [bitmap.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/res/Resources;Landroid/graphics/Bitmap;)V");

  /// from: public void <init>(android.content.res.Resources res, android.graphics.Bitmap bitmap)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create drawable from a bitmap, setting initial target density based on
  /// the display metrics of the resources.
  BitmapDrawable.ctor3(resources_.Resources res, bitmap_.Bitmap bitmap)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [res.reference, bitmap.reference]).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String filepath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable by opening a given file path and decoding the bitmap.
  ///@deprecated Use \#BitmapDrawable(Resources, String) to ensure
  /// that the drawable has correctly set its target density.
  BitmapDrawable.ctor4(jni.JniString filepath)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [filepath.reference]).object);

  static final _id_ctor5 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/res/Resources;Ljava/lang/String;)V");

  /// from: public void <init>(android.content.res.Resources res, java.lang.String filepath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable by opening a given file path and decoding the bitmap.
  BitmapDrawable.ctor5(resources_.Resources res, jni.JniString filepath)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor5, [res.reference, filepath.reference]).object);

  static final _id_ctor6 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/io/InputStream;)V");

  /// from: public void <init>(java.io.InputStream is)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable by decoding a bitmap from the given input stream.
  ///@deprecated Use \#BitmapDrawable(Resources, java.io.InputStream) to ensure
  /// that the drawable has correctly set its target density.
  BitmapDrawable.ctor6(jni.JniObject is0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor6, [is0.reference]).object);

  static final _id_ctor7 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/res/Resources;Ljava/io/InputStream;)V");

  /// from: public void <init>(android.content.res.Resources res, java.io.InputStream is)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a drawable by decoding a bitmap from the given input stream.
  BitmapDrawable.ctor7(resources_.Resources res, jni.JniObject is0)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor7, [res.reference, is0.reference]).object);

  static final _id_getPaint = jniAccessors.getMethodIDOf(
      _classRef, "getPaint", "()Landroid/graphics/Paint;");

  /// from: public final android.graphics.Paint getPaint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the paint used to render this drawable.
  paint_.Paint getPaint() =>
      paint_.Paint.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPaint, jni.JniType.objectType, []).object);

  static final _id_getBitmap = jniAccessors.getMethodIDOf(
      _classRef, "getBitmap", "()Landroid/graphics/Bitmap;");

  /// from: public final android.graphics.Bitmap getBitmap()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the bitmap used by this drawable to render. May be null.
  bitmap_.Bitmap getBitmap() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBitmap, jni.JniType.objectType, []).object);

  static final _id_setTargetDensity = jniAccessors.getMethodIDOf(
      _classRef, "setTargetDensity", "(Landroid/graphics/Canvas;)V");

  /// from: public void setTargetDensity(android.graphics.Canvas canvas)
  ///
  /// Set the density scale at which this drawable will be rendered. This
  /// method assumes the drawable will be rendered at the same density as the
  /// specified canvas.
  ///@param canvas The Canvas from which the density scale must be obtained.
  ///@see android.graphics.Bitmap\#setDensity(int)
  ///@see android.graphics.Bitmap\#getDensity()
  void setTargetDensity(canvas_.Canvas canvas) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTargetDensity,
          jni.JniType.voidType, [canvas.reference]).check();

  static final _id_setTargetDensity1 = jniAccessors.getMethodIDOf(
      _classRef, "setTargetDensity", "(Landroid/util/DisplayMetrics;)V");

  /// from: public void setTargetDensity(android.util.DisplayMetrics metrics)
  ///
  /// Set the density scale at which this drawable will be rendered.
  ///@param metrics The DisplayMetrics indicating the density scale for this drawable.
  ///@see android.graphics.Bitmap\#setDensity(int)
  ///@see android.graphics.Bitmap\#getDensity()
  void setTargetDensity1(displaymetrics_.DisplayMetrics metrics) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTargetDensity1,
          jni.JniType.voidType, [metrics.reference]).check();

  static final _id_setTargetDensity2 =
      jniAccessors.getMethodIDOf(_classRef, "setTargetDensity", "(I)V");

  /// from: public void setTargetDensity(int density)
  ///
  /// Set the density at which this drawable will be rendered.
  ///@param density The density scale for this drawable.
  ///@see android.graphics.Bitmap\#setDensity(int)
  ///@see android.graphics.Bitmap\#getDensity()
  void setTargetDensity2(int density) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTargetDensity2,
      jni.JniType.voidType,
      [density]).check();

  static final _id_getGravity =
      jniAccessors.getMethodIDOf(_classRef, "getGravity", "()I");

  /// from: public int getGravity()
  ///
  /// Get the gravity used to position/stretch the bitmap within its bounds.
  /// See android.view.Gravity
  ///@return the gravity applied to the bitmap
  int getGravity() => jniAccessors.callMethodWithArgs(
      reference, _id_getGravity, jni.JniType.intType, []).integer;

  static final _id_setGravity =
      jniAccessors.getMethodIDOf(_classRef, "setGravity", "(I)V");

  /// from: public void setGravity(int gravity)
  ///
  /// Set the gravity used to position/stretch the bitmap within its bounds.
  ///   See android.view.Gravity
  ///@param gravity the gravity
  void setGravity(int gravity) => jniAccessors.callMethodWithArgs(
      reference, _id_setGravity, jni.JniType.voidType, [gravity]).check();

  static final _id_setMipMap =
      jniAccessors.getMethodIDOf(_classRef, "setMipMap", "(Z)V");

  /// from: public void setMipMap(boolean mipMap)
  ///
  /// Enables or disables the mipmap hint for this drawable's bitmap.
  /// See Bitmap\#setHasMipMap(boolean) for more information.
  ///
  /// If the bitmap is null calling this method has no effect.
  ///@param mipMap True if the bitmap should use mipmaps, false otherwise.
  ///@see \#hasMipMap()
  void setMipMap(bool mipMap) => jniAccessors.callMethodWithArgs(
      reference, _id_setMipMap, jni.JniType.voidType, [mipMap]).check();

  static final _id_hasMipMap =
      jniAccessors.getMethodIDOf(_classRef, "hasMipMap", "()Z");

  /// from: public boolean hasMipMap()
  ///
  /// Indicates whether the mipmap hint is enabled on this drawable's bitmap.
  ///@return True if the mipmap hint is set, false otherwise. If the bitmap
  ///         is null, this method always returns false.
  ///@see \#setMipMap(boolean)
  ///@attr ref android.R.styleable\#BitmapDrawable_mipMap
  bool hasMipMap() => jniAccessors.callMethodWithArgs(
      reference, _id_hasMipMap, jni.JniType.booleanType, []).boolean;

  static final _id_setAntiAlias =
      jniAccessors.getMethodIDOf(_classRef, "setAntiAlias", "(Z)V");

  /// from: public void setAntiAlias(boolean aa)
  ///
  /// Enables or disables anti-aliasing for this drawable. Anti-aliasing affects
  /// the edges of the bitmap only so it applies only when the drawable is rotated.
  ///@param aa True if the bitmap should be anti-aliased, false otherwise.
  ///@see \#hasAntiAlias()
  void setAntiAlias(bool aa) => jniAccessors.callMethodWithArgs(
      reference, _id_setAntiAlias, jni.JniType.voidType, [aa]).check();

  static final _id_hasAntiAlias =
      jniAccessors.getMethodIDOf(_classRef, "hasAntiAlias", "()Z");

  /// from: public boolean hasAntiAlias()
  ///
  /// Indicates whether anti-aliasing is enabled for this drawable.
  ///@return True if anti-aliasing is enabled, false otherwise.
  ///@see \#setAntiAlias(boolean)
  bool hasAntiAlias() => jniAccessors.callMethodWithArgs(
      reference, _id_hasAntiAlias, jni.JniType.booleanType, []).boolean;

  static final _id_setFilterBitmap =
      jniAccessors.getMethodIDOf(_classRef, "setFilterBitmap", "(Z)V");

  /// from: public void setFilterBitmap(boolean filter)
  void setFilterBitmap(bool filter) => jniAccessors.callMethodWithArgs(
      reference, _id_setFilterBitmap, jni.JniType.voidType, [filter]).check();

  static final _id_isFilterBitmap =
      jniAccessors.getMethodIDOf(_classRef, "isFilterBitmap", "()Z");

  /// from: public boolean isFilterBitmap()
  bool isFilterBitmap() => jniAccessors.callMethodWithArgs(
      reference, _id_isFilterBitmap, jni.JniType.booleanType, []).boolean;

  static final _id_setDither =
      jniAccessors.getMethodIDOf(_classRef, "setDither", "(Z)V");

  /// from: public void setDither(boolean dither)
  void setDither(bool dither) => jniAccessors.callMethodWithArgs(
      reference, _id_setDither, jni.JniType.voidType, [dither]).check();

  static final _id_getTileModeX = jniAccessors.getMethodIDOf(
      _classRef, "getTileModeX", "()Landroid/graphics/Shader\$TileMode;");

  /// from: public android.graphics.Shader.TileMode getTileModeX()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the repeat behavior of this drawable on the X axis.
  ///@return android.graphics.Shader.TileMode\#CLAMP if the bitmap does not repeat,
  ///         android.graphics.Shader.TileMode\#REPEAT or
  ///         android.graphics.Shader.TileMode\#MIRROR otherwise.
  shader_.Shader_TileMode getTileModeX() =>
      shader_.Shader_TileMode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTileModeX, jni.JniType.objectType, []).object);

  static final _id_getTileModeY = jniAccessors.getMethodIDOf(
      _classRef, "getTileModeY", "()Landroid/graphics/Shader\$TileMode;");

  /// from: public android.graphics.Shader.TileMode getTileModeY()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the repeat behavior of this drawable on the Y axis.
  ///@return android.graphics.Shader.TileMode\#CLAMP if the bitmap does not repeat,
  ///         android.graphics.Shader.TileMode\#REPEAT or
  ///         android.graphics.Shader.TileMode\#MIRROR otherwise.
  shader_.Shader_TileMode getTileModeY() =>
      shader_.Shader_TileMode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTileModeY, jni.JniType.objectType, []).object);

  static final _id_setTileModeX = jniAccessors.getMethodIDOf(
      _classRef, "setTileModeX", "(Landroid/graphics/Shader\$TileMode;)V");

  /// from: public void setTileModeX(android.graphics.Shader.TileMode mode)
  ///
  /// Sets the repeat behavior of this drawable on the X axis. By default, the drawable
  /// does not repeat its bitmap. Using android.graphics.Shader.TileMode\#REPEAT or
  /// android.graphics.Shader.TileMode\#MIRROR the bitmap can be repeated (or tiled)
  /// if the bitmap is smaller than this drawable.
  ///@param mode The repeat mode for this drawable.
  ///@see \#setTileModeY(android.graphics.Shader.TileMode)
  ///@see \#setTileModeXY(android.graphics.Shader.TileMode, android.graphics.Shader.TileMode)
  ///@attr ref android.R.styleable\#BitmapDrawable_tileModeX
  void setTileModeX(shader_.Shader_TileMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTileModeX,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_setTileModeY = jniAccessors.getMethodIDOf(
      _classRef, "setTileModeY", "(Landroid/graphics/Shader\$TileMode;)V");

  /// from: public final void setTileModeY(android.graphics.Shader.TileMode mode)
  ///
  /// Sets the repeat behavior of this drawable on the Y axis. By default, the drawable
  /// does not repeat its bitmap. Using android.graphics.Shader.TileMode\#REPEAT or
  /// android.graphics.Shader.TileMode\#MIRROR the bitmap can be repeated (or tiled)
  /// if the bitmap is smaller than this drawable.
  ///@param mode The repeat mode for this drawable.
  ///@see \#setTileModeX(android.graphics.Shader.TileMode)
  ///@see \#setTileModeXY(android.graphics.Shader.TileMode, android.graphics.Shader.TileMode)
  ///@attr ref android.R.styleable\#BitmapDrawable_tileModeY
  void setTileModeY(shader_.Shader_TileMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTileModeY,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_setTileModeXY = jniAccessors.getMethodIDOf(
      _classRef,
      "setTileModeXY",
      "(Landroid/graphics/Shader\$TileMode;Landroid/graphics/Shader\$TileMode;)V");

  /// from: public void setTileModeXY(android.graphics.Shader.TileMode xmode, android.graphics.Shader.TileMode ymode)
  ///
  /// Sets the repeat behavior of this drawable on both axis. By default, the drawable
  /// does not repeat its bitmap. Using android.graphics.Shader.TileMode\#REPEAT or
  /// android.graphics.Shader.TileMode\#MIRROR the bitmap can be repeated (or tiled)
  /// if the bitmap is smaller than this drawable.
  ///@param xmode The X repeat mode for this drawable.
  ///@param ymode The Y repeat mode for this drawable.
  ///@see \#setTileModeX(android.graphics.Shader.TileMode)
  ///@see \#setTileModeY(android.graphics.Shader.TileMode)
  void setTileModeXY(
          shader_.Shader_TileMode xmode, shader_.Shader_TileMode ymode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTileModeXY,
          jni.JniType.voidType, [xmode.reference, ymode.reference]).check();

  static final _id_setAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "setAutoMirrored", "(Z)V");

  /// from: public void setAutoMirrored(boolean mirrored)
  void setAutoMirrored(bool mirrored) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutoMirrored, jni.JniType.voidType, [mirrored]).check();

  static final _id_isAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "isAutoMirrored", "()Z");

  /// from: public final boolean isAutoMirrored()
  bool isAutoMirrored() => jniAccessors.callMethodWithArgs(
      reference, _id_isAutoMirrored, jni.JniType.booleanType, []).boolean;

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// @return Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_onBoundsChange = jniAccessors.getMethodIDOf(
      _classRef, "onBoundsChange", "(Landroid/graphics/Rect;)V");

  /// from: protected void onBoundsChange(android.graphics.Rect bounds)
  void onBoundsChange(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBoundsChange,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getOutline = jniAccessors.getMethodIDOf(
      _classRef, "getOutline", "(Landroid/graphics/Outline;)V");

  /// from: public void getOutline(android.graphics.Outline outline)
  ///
  /// @param outline This value must never be {@code null}.
  void getOutline(outline_.Outline outline) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getOutline,
      jni.JniType.voidType,
      [outline.reference]).check();

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int alpha)
  void setAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public void setColorFilter(android.graphics.ColorFilter colorFilter)
  void setColorFilter(colorfilter_.ColorFilter colorFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [colorFilter.reference]).check();

  static final _id_getColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "getColorFilter", "()Landroid/graphics/ColorFilter;");

  /// from: public android.graphics.ColorFilter getColorFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  colorfilter_.ColorFilter getColorFilter() =>
      colorfilter_.ColorFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorFilter, jni.JniType.objectType, []).object);

  static final _id_setTintList = jniAccessors.getMethodIDOf(
      _classRef, "setTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTintList(android.content.res.ColorStateList tint)
  void setTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_setTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setTintMode(android.graphics.PorterDuff.Mode tintMode)
  void setTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_mutate = jniAccessors.getMethodIDOf(
      _classRef, "mutate", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable mutate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A mutable BitmapDrawable still shares its Bitmap with any other Drawable
  /// that comes from the same resource.
  ///@return This drawable.
  drawable_.Drawable mutate() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_mutate, jni.JniType.objectType, []).object);

  static final _id_onStateChange =
      jniAccessors.getMethodIDOf(_classRef, "onStateChange", "([I)Z");

  /// from: protected boolean onStateChange(int[] stateSet)
  bool onStateChange(jni.JniObject stateSet) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStateChange,
      jni.JniType.booleanType,
      [stateSet.reference]).boolean;

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public boolean isStateful()
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_inflate1 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;Landroid/content/res/Resources\$Theme;)V");

  /// from: public void inflate(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs, android.content.res.Resources.Theme theme)
  void inflate1(resources_.Resources r, jni.JniObject parser,
          attributeset_.AttributeSet attrs, resources_.Resources_Theme theme) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_inflate1, jni.JniType.voidType, [
        r.reference,
        parser.reference,
        attrs.reference,
        theme.reference
      ]).check();

  static final _id_applyTheme = jniAccessors.getMethodIDOf(
      _classRef, "applyTheme", "(Landroid/content/res/Resources\$Theme;)V");

  /// from: public void applyTheme(android.content.res.Resources.Theme t)
  void applyTheme(resources_.Resources_Theme t) =>
      jniAccessors.callMethodWithArgs(reference, _id_applyTheme,
          jni.JniType.voidType, [t.reference]).check();

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;

  static final _id_getIntrinsicWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicWidth", "()I");

  /// from: public int getIntrinsicWidth()
  int getIntrinsicWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicWidth, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicHeight", "()I");

  /// from: public int getIntrinsicHeight()
  int getIntrinsicHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicHeight, jni.JniType.intType, []).integer;

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public int getOpacity()
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_getConstantState = jniAccessors.getMethodIDOf(
      _classRef,
      "getConstantState",
      "()Landroid/graphics/drawable/Drawable\$ConstantState;");

  /// from: public final android.graphics.drawable.Drawable.ConstantState getConstantState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable_ConstantState getConstantState() =>
      drawable_.Drawable_ConstantState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConstantState, jni.JniType.objectType, []).object);
}
