// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Drawable.dart" as drawable_;

import "../Canvas.dart" as canvas_;

import "../ColorFilter.dart" as colorfilter_;

import "../../content/res/ColorStateList.dart" as colorstatelist_;

import "../PorterDuff.dart" as porterduff_;

import "../../content/res/Resources.dart" as resources_;

import "../../util/AttributeSet.dart" as attributeset_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.drawable.VectorDrawable
///
/// This lets you create a drawable based on an XML vector graphic.
/// <p/>
/// <strong>Note:</strong> To optimize for the re-drawing performance, one bitmap cache is created
/// for each VectorDrawable. Therefore, referring to the same VectorDrawable means sharing the same
/// bitmap cache. If these references don't agree upon on the same size, the bitmap will be recreated
/// and redrawn every time size is changed. In other words, if a VectorDrawable is used for
/// different sizes, it is more efficient to create multiple VectorDrawables, one for each size.
/// <p/>
/// VectorDrawable can be defined in an XML file with the <code>&lt;vector></code> element.
/// <p/>
/// The vector drawable has the following elements:
/// <p/>
/// <dt><code>&lt;vector></code></dt>
/// <dl>
/// <dd>Used to define a vector drawable
/// <dl>
/// <dt><code>android:name</code></dt>
/// <dd>Defines the name of this vector drawable.</dd>
/// <dt><code>android:width</code></dt>
/// <dd>Used to define the intrinsic width of the drawable.
/// This support all the dimension units, normally specified with dp.</dd>
/// <dt><code>android:height</code></dt>
/// <dd>Used to define the intrinsic height the drawable.
/// This support all the dimension units, normally specified with dp.</dd>
/// <dt><code>android:viewportWidth</code></dt>
/// <dd>Used to define the width of the viewport space. Viewport is basically
/// the virtual canvas where the paths are drawn on.</dd>
/// <dt><code>android:viewportHeight</code></dt>
/// <dd>Used to define the height of the viewport space. Viewport is basically
/// the virtual canvas where the paths are drawn on.</dd>
/// <dt><code>android:tint</code></dt>
/// <dd>The color to apply to the drawable as a tint. By default, no tint is applied.</dd>
/// <dt><code>android:tintMode</code></dt>
/// <dd>The Porter-Duff blending mode for the tint color. Default is src_in.</dd>
/// <dt><code>android:autoMirrored</code></dt>
/// <dd>Indicates if the drawable needs to be mirrored when its layout direction is
/// RTL (right-to-left). Default is false.</dd>
/// <dt><code>android:alpha</code></dt>
/// <dd>The opacity of this drawable. Default is 1.0.</dd>
/// </dl></dd>
/// </dl>
///
/// <dl>
/// <dt><code>&lt;group></code></dt>
/// <dd>Defines a group of paths or subgroups, plus transformation information.
/// The transformations are defined in the same coordinates as the viewport.
/// And the transformations are applied in the order of scale, rotate then translate.
/// <dl>
/// <dt><code>android:name</code></dt>
/// <dd>Defines the name of the group.</dd>
/// <dt><code>android:rotation</code></dt>
/// <dd>The degrees of rotation of the group. Default is 0.</dd>
/// <dt><code>android:pivotX</code></dt>
/// <dd>The X coordinate of the pivot for the scale and rotation of the group.
/// This is defined in the viewport space. Default is 0.</dd>
/// <dt><code>android:pivotY</code></dt>
/// <dd>The Y coordinate of the pivot for the scale and rotation of the group.
/// This is defined in the viewport space. Default is 0.</dd>
/// <dt><code>android:scaleX</code></dt>
/// <dd>The amount of scale on the X Coordinate. Default is 1.</dd>
/// <dt><code>android:scaleY</code></dt>
/// <dd>The amount of scale on the Y coordinate. Default is 1.</dd>
/// <dt><code>android:translateX</code></dt>
/// <dd>The amount of translation on the X coordinate.
/// This is defined in the viewport space. Default is 0.</dd>
/// <dt><code>android:translateY</code></dt>
/// <dd>The amount of translation on the Y coordinate.
/// This is defined in the viewport space. Default is 0.</dd>
/// </dl></dd>
/// </dl>
///
/// <dl>
/// <dt><code>&lt;path></code></dt>
/// <dd>Defines paths to be drawn.
/// <dl>
/// <dt><code>android:name</code></dt>
/// <dd>Defines the name of the path.</dd>
/// <dt><code>android:pathData</code></dt>
/// <dd>Defines path data using exactly same format as "d" attribute
/// in the SVG's path data. This is defined in the viewport space.</dd>
/// <dt><code>android:fillColor</code></dt>
/// <dd>Specifies the color used to fill the path. May be a color or, for SDK 24+, a color state list
/// or a gradient color (See android.R.styleable\#GradientColor
/// and android.R.styleable\#GradientColorItem).
/// If this property is animated, any value set by the animation will override the original value.
/// No path fill is drawn if this property is not specified.</dd>
/// <dt><code>android:strokeColor</code></dt>
/// <dd>Specifies the color used to draw the path outline. May be a color or, for SDK 24+, a color
/// state list or a gradient color (See android.R.styleable\#GradientColor
/// and android.R.styleable\#GradientColorItem).
/// If this property is animated, any value set by the animation will override the original value.
/// No path outline is drawn if this property is not specified.</dd>
/// <dt><code>android:strokeWidth</code></dt>
/// <dd>The width a path stroke. Default is 0.</dd>
/// <dt><code>android:strokeAlpha</code></dt>
/// <dd>The opacity of a path stroke. Default is 1.</dd>
/// <dt><code>android:fillAlpha</code></dt>
/// <dd>The opacity to fill the path with. Default is 1.</dd>
/// <dt><code>android:trimPathStart</code></dt>
/// <dd>The fraction of the path to trim from the start, in the range from 0 to 1. Default is 0.</dd>
/// <dt><code>android:trimPathEnd</code></dt>
/// <dd>The fraction of the path to trim from the end, in the range from 0 to 1. Default is 1.</dd>
/// <dt><code>android:trimPathOffset</code></dt>
/// <dd>Shift trim region (allows showed region to include the start and end), in the range
/// from 0 to 1. Default is 0.</dd>
/// <dt><code>android:strokeLineCap</code></dt>
/// <dd>Sets the linecap for a stroked path: butt, round, square. Default is butt.</dd>
/// <dt><code>android:strokeLineJoin</code></dt>
/// <dd>Sets the lineJoin for a stroked path: miter,round,bevel. Default is miter.</dd>
/// <dt><code>android:strokeMiterLimit</code></dt>
/// <dd>Sets the Miter limit for a stroked path. Default is 4.</dd>
/// <dt><code>android:fillType</code></dt>
/// <dd>For SDK 24+, sets the fillType for a path. The types can be either "evenOdd" or "nonZero". They behave the
/// same as SVG's "fill-rule" properties. Default is nonZero. For more details, see
/// <a href="https://www.w3.org/TR/SVG/painting.html\#FillRuleProperty">FillRuleProperty</a></dd>
/// </dl></dd>
///
/// </dl>
///
/// <dl>
/// <dt><code>&lt;clip-path></code></dt>
/// <dd>Defines path to be the current clip. Note that the clip path only apply to
/// the current group and its children.
/// <dl>
/// <dt><code>android:name</code></dt>
/// <dd>Defines the name of the clip path.</dd>
/// <dd>Animatable : No.</dd>
/// <dt><code>android:pathData</code></dt>
/// <dd>Defines clip path using the same format as "d" attribute
/// in the SVG's path data.</dd>
/// <dd>Animatable : Yes.</dd>
/// </dl></dd>
/// </dl>
/// <li>Here is a simple VectorDrawable in this vectordrawable.xml file.
/// <pre>
/// &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
///     android:height=&quot;64dp&quot;
///     android:width=&quot;64dp&quot;
///     android:viewportHeight=&quot;600&quot;
///     android:viewportWidth=&quot;600&quot; &gt;
///     &lt;group
///         android:name=&quot;rotationGroup&quot;
///         android:pivotX=&quot;300.0&quot;
///         android:pivotY=&quot;300.0&quot;
///         android:rotation=&quot;45.0&quot; &gt;
///         &lt;path
///             android:name=&quot;v&quot;
///             android:fillColor=&quot;\#000000&quot;
///             android:pathData=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot; /&gt;
///     &lt;/group&gt;
/// &lt;/vector&gt;
/// </pre>
/// </li>
/// <h4>Gradient support</h4>
/// We support 3 types of gradients: android.graphics.LinearGradient,
/// android.graphics.RadialGradient, or android.graphics.SweepGradient.
/// <p/>
/// And we support all of 3 types of tile modes android.graphics.Shader.TileMode:
/// CLAMP, REPEAT, MIRROR.
/// <p/>
/// All of the attributes are listed in android.R.styleable\#GradientColor.
/// Note that different attributes are relevant for different types of gradient.
/// <table border="2"align="center"cellpadding="5">
///     <thead>
///         <tr>
///             <th>LinearGradient</th>
///             <th>RadialGradient</th>
///             <th>SweepGradient</th>
///         </tr>
///     </thead>
///     <tr>
///         <td>startColor </td>
///         <td>startColor</td>
///         <td>startColor</td>
///     </tr>
///     <tr>
///         <td>centerColor</td>
///         <td>centerColor</td>
///         <td>centerColor</td>
///     </tr>
///     <tr>
///         <td>endColor</td>
///         <td>endColor</td>
///         <td>endColor</td>
///     </tr>
///     <tr>
///         <td>type</td>
///         <td>type</td>
///         <td>type</td>
///     </tr>
///     <tr>
///         <td>tileMode</td>
///         <td>tileMode</td>
///         <td>tileMode</td>
///     </tr>
///     <tr>
///         <td>startX</td>
///         <td>centerX</td>
///         <td>centerX</td>
///     </tr>
///     <tr>
///         <td>startY</td>
///         <td>centerY</td>
///         <td>centerY</td>
///     </tr>
///     <tr>
///         <td>endX</td>
///         <td>gradientRadius</td>
///         <td></td>
///     </tr>
///     <tr>
///         <td>endY</td>
///         <td></td>
///         <td></td>
///     </tr>
/// </table>
/// <p/>
/// Also note that if any color item android.R.styleable\#GradientColorItem is defined, then
/// startColor, centerColor and endColor will be ignored.
/// <p/>
/// See more details in android.R.styleable\#GradientColor and
/// android.R.styleable\#GradientColorItem.
/// <p/>
/// Here is a simple example that defines a linear gradient.
/// <pre>
/// &lt;gradient xmlns:android="http://schemas.android.com/apk/res/android"
///     android:startColor="?android:attr/colorPrimary"
///     android:endColor="?android:attr/colorControlActivated"
///     android:centerColor="\#f00"
///     android:startX="0"
///     android:startY="0"
///     android:endX="100"
///     android:endY="100"
///     android:type="linear"&gt;
/// &lt;/gradient&gt;
/// </pre>
/// And here is a simple example that defines a radial gradient using color items.
/// <pre>
/// &lt;gradient xmlns:android="http://schemas.android.com/apk/res/android"
///     android:centerX="300"
///     android:centerY="300"
///     android:gradientRadius="100"
///     android:type="radial"&gt;
///     &lt;item android:offset="0.1" android:color="\#0ff"/&gt;
///     &lt;item android:offset="0.4" android:color="\#fff"/&gt;
///     &lt;item android:offset="0.9" android:color="\#ff0"/&gt;
/// &lt;/gradient&gt;
/// </pre>
class VectorDrawable extends drawable_.Drawable {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/drawable/VectorDrawable");
  VectorDrawable.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VectorDrawable()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_mutate = jniAccessors.getMethodIDOf(
      _classRef, "mutate", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable mutate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable mutate() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_mutate, jni.JniType.objectType, []).object);

  static final _id_getConstantState = jniAccessors.getMethodIDOf(
      _classRef,
      "getConstantState",
      "()Landroid/graphics/drawable/Drawable\$ConstantState;");

  /// from: public android.graphics.drawable.Drawable.ConstantState getConstantState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable_ConstantState getConstantState() =>
      drawable_.Drawable_ConstantState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConstantState, jni.JniType.objectType, []).object);

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int alpha)
  void setAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public void setColorFilter(android.graphics.ColorFilter colorFilter)
  void setColorFilter(colorfilter_.ColorFilter colorFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [colorFilter.reference]).check();

  static final _id_getColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "getColorFilter", "()Landroid/graphics/ColorFilter;");

  /// from: public android.graphics.ColorFilter getColorFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  colorfilter_.ColorFilter getColorFilter() =>
      colorfilter_.ColorFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorFilter, jni.JniType.objectType, []).object);

  static final _id_setTintList = jniAccessors.getMethodIDOf(
      _classRef, "setTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTintList(android.content.res.ColorStateList tint)
  void setTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_setTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setTintMode(android.graphics.PorterDuff.Mode tintMode)
  void setTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public boolean isStateful()
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_onStateChange =
      jniAccessors.getMethodIDOf(_classRef, "onStateChange", "([I)Z");

  /// from: protected boolean onStateChange(int[] stateSet)
  bool onStateChange(jni.JniObject stateSet) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStateChange,
      jni.JniType.booleanType,
      [stateSet.reference]).boolean;

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public int getOpacity()
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicWidth", "()I");

  /// from: public int getIntrinsicWidth()
  int getIntrinsicWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicWidth, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicHeight", "()I");

  /// from: public int getIntrinsicHeight()
  int getIntrinsicHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicHeight, jni.JniType.intType, []).integer;

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;

  static final _id_applyTheme = jniAccessors.getMethodIDOf(
      _classRef, "applyTheme", "(Landroid/content/res/Resources\$Theme;)V");

  /// from: public void applyTheme(android.content.res.Resources.Theme t)
  void applyTheme(resources_.Resources_Theme t) =>
      jniAccessors.callMethodWithArgs(reference, _id_applyTheme,
          jni.JniType.voidType, [t.reference]).check();

  static final _id_inflate1 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;Landroid/content/res/Resources\$Theme;)V");

  /// from: public void inflate(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs, android.content.res.Resources.Theme theme)
  ///
  /// @param r This value must never be {@code null}.
  ///@param parser This value must never be {@code null}.
  ///@param attrs This value must never be {@code null}.
  ///@param theme This value may be {@code null}.
  void inflate1(resources_.Resources r, jni.JniObject parser,
          attributeset_.AttributeSet attrs, resources_.Resources_Theme theme) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_inflate1, jni.JniType.voidType, [
        r.reference,
        parser.reference,
        attrs.reference,
        theme.reference
      ]).check();

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// @return Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_setAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "setAutoMirrored", "(Z)V");

  /// from: public void setAutoMirrored(boolean mirrored)
  void setAutoMirrored(bool mirrored) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutoMirrored, jni.JniType.voidType, [mirrored]).check();

  static final _id_isAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "isAutoMirrored", "()Z");

  /// from: public boolean isAutoMirrored()
  bool isAutoMirrored() => jniAccessors.callMethodWithArgs(
      reference, _id_isAutoMirrored, jni.JniType.booleanType, []).boolean;
}
