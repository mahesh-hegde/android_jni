// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Drawable.dart" as drawable_;

import "../../content/res/Resources.dart" as resources_;

import "../../util/AttributeSet.dart" as attributeset_;

import "../Canvas.dart" as canvas_;

import "../ColorFilter.dart" as colorfilter_;

import "Animatable2.dart" as animatable2_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.drawable.AnimatedImageDrawable
///
/// Drawable for drawing animated images (like GIF).
///
/// The framework handles decoding subsequent frames in another thread and
/// updating when necessary. The drawable will only animate while it is being
/// displayed.
///
///
/// Created by ImageDecoder\#decodeDrawable. A user needs to call
/// \#start to start the animation.
///
///
/// It can also be defined in XML using the <code>&lt;animated-image></code>
/// element.
///
///@attr ref android.R.styleable\#AnimatedImageDrawable_src
///@attr ref android.R.styleable\#AnimatedImageDrawable_autoStart
///@attr ref android.R.styleable\#AnimatedImageDrawable_repeatCount
///@attr ref android.R.styleable\#AnimatedImageDrawable_autoMirrored
class AnimatedImageDrawable extends drawable_.Drawable {
  static final _classRef = jniAccessors
      .getClassOf("android/graphics/drawable/AnimatedImageDrawable");
  AnimatedImageDrawable.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int REPEAT_INFINITE
  ///
  /// Pass this to \#setRepeatCount to repeat infinitely.
  ///
  ///  Animatable2.AnimationCallback\#onAnimationEnd will never be
  ///  called unless there is an error.
  ///
  static const REPEAT_INFINITE = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty AnimatedImageDrawable.
  AnimatedImageDrawable()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setRepeatCount =
      jniAccessors.getMethodIDOf(_classRef, "setRepeatCount", "(I)V");

  /// from: public void setRepeatCount(int repeatCount)
  ///
  /// Specify the number of times to repeat the animation.
  ///
  ///  By default, the repeat count in the encoded data is respected. If set
  ///  to \#REPEAT_INFINITE, the animation will repeat as long as it is
  ///  displayed. If the value is {@code 0}, the animation will play once.
  ///
  ///
  ///  This call replaces the current repeat count. If the encoded data
  ///  specified a repeat count of {@code 2} (meaning that
  ///  \#getRepeatCount() returns {@code 2}, the animation will play
  ///  three times. Calling {@code setRepeatCount(1)} will result in playing only
  ///  twice and \#getRepeatCount() returning {@code 1}.
  ///
  ///
  ///  If the animation is already playing, the iterations that have already
  ///  occurred count towards the new count. If the animation has already
  ///  repeated the appropriate number of times (or more), it will finish its
  ///  current iteration and then stop.
  ///
  ///@param repeatCount Value is REPEAT_INFINITE or greater
  void setRepeatCount(int repeatCount) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRepeatCount,
      jni.JniType.voidType,
      [repeatCount]).check();

  static final _id_getRepeatCount =
      jniAccessors.getMethodIDOf(_classRef, "getRepeatCount", "()I");

  /// from: public int getRepeatCount()
  ///
  /// Retrieve the number of times the animation will repeat.
  ///
  ///  By default, the repeat count in the encoded data is respected. If the
  ///  value is \#REPEAT_INFINITE, the animation will repeat as long as
  ///  it is displayed. If the value is {@code 0}, it will play once.
  ///
  ///
  ///  Calling \#setRepeatCount will make future calls to this method
  ///  return the value passed to \#setRepeatCount.
  ///
  int getRepeatCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRepeatCount, jni.JniType.intType, []).integer;

  static final _id_inflate1 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;Landroid/content/res/Resources\$Theme;)V");

  /// from: public void inflate(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs, android.content.res.Resources.Theme theme)
  void inflate1(resources_.Resources r, jni.JniObject parser,
          attributeset_.AttributeSet attrs, resources_.Resources_Theme theme) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_inflate1, jni.JniType.voidType, [
        r.reference,
        parser.reference,
        attrs.reference,
        theme.reference
      ]).check();

  static final _id_getIntrinsicWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicWidth", "()I");

  /// from: public int getIntrinsicWidth()
  int getIntrinsicWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicWidth, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicHeight", "()I");

  /// from: public int getIntrinsicHeight()
  int getIntrinsicHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicHeight, jni.JniType.intType, []).integer;

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  ///
  /// @param canvas This value must never be {@code null}.
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int alpha)
  ///
  /// @param alpha Value is between 0 and 255 inclusive
  void setAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public void setColorFilter(android.graphics.ColorFilter colorFilter)
  ///
  /// @param colorFilter This value may be {@code null}.
  void setColorFilter(colorfilter_.ColorFilter colorFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [colorFilter.reference]).check();

  static final _id_getColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "getColorFilter", "()Landroid/graphics/ColorFilter;");

  /// from: public android.graphics.ColorFilter getColorFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This value may be {@code null}.
  colorfilter_.ColorFilter getColorFilter() =>
      colorfilter_.ColorFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorFilter, jni.JniType.objectType, []).object);

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public int getOpacity()
  ///
  /// @return Value is android.graphics.PixelFormat\#UNKNOWN, android.graphics.PixelFormat\#TRANSLUCENT, android.graphics.PixelFormat\#TRANSPARENT, or android.graphics.PixelFormat\#OPAQUE
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_setAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "setAutoMirrored", "(Z)V");

  /// from: public void setAutoMirrored(boolean mirrored)
  void setAutoMirrored(bool mirrored) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutoMirrored, jni.JniType.voidType, [mirrored]).check();

  static final _id_onLayoutDirectionChanged =
      jniAccessors.getMethodIDOf(_classRef, "onLayoutDirectionChanged", "(I)Z");

  /// from: public boolean onLayoutDirectionChanged(int layoutDirection)
  bool onLayoutDirectionChanged(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayoutDirectionChanged,
          jni.JniType.booleanType, [layoutDirection]).boolean;

  static final _id_isAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "isAutoMirrored", "()Z");

  /// from: public final boolean isAutoMirrored()
  bool isAutoMirrored() => jniAccessors.callMethodWithArgs(
      reference, _id_isAutoMirrored, jni.JniType.booleanType, []).boolean;

  static final _id_isRunning =
      jniAccessors.getMethodIDOf(_classRef, "isRunning", "()Z");

  /// from: public boolean isRunning()
  ///
  /// Return whether the animation is currently running.
  ///
  ///  When this drawable is created, this will return {@code false}. A client
  ///  needs to call \#start to start the animation.
  ///
  bool isRunning() => jniAccessors.callMethodWithArgs(
      reference, _id_isRunning, jni.JniType.booleanType, []).boolean;

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "()V");

  /// from: public void start()
  ///
  /// Start the animation.
  ///
  ///  Does nothing if the animation is already running. If the animation is stopped,
  ///  this will reset it.
  ///
  ///
  ///  When the drawable is drawn, starting the animation,
  ///  Animatable2.AnimationCallback\#onAnimationStart will be called.
  ///
  void start() => jniAccessors.callMethodWithArgs(
      reference, _id_start, jni.JniType.voidType, []).check();

  static final _id_stop = jniAccessors.getMethodIDOf(_classRef, "stop", "()V");

  /// from: public void stop()
  ///
  /// Stop the animation.
  ///
  ///  If the animation is stopped, it will continue to display the frame
  ///  it was displaying when stopped.
  ///
  void stop() => jniAccessors.callMethodWithArgs(
      reference, _id_stop, jni.JniType.voidType, []).check();

  static final _id_registerAnimationCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerAnimationCallback",
      "(Landroid/graphics/drawable/Animatable2\$AnimationCallback;)V");

  /// from: public void registerAnimationCallback(android.graphics.drawable.Animatable2.AnimationCallback callback)
  ///
  /// @param callback This value must never be {@code null}.
  void registerAnimationCallback(
          animatable2_.Animatable2_AnimationCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerAnimationCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_unregisterAnimationCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterAnimationCallback",
      "(Landroid/graphics/drawable/Animatable2\$AnimationCallback;)Z");

  /// from: public boolean unregisterAnimationCallback(android.graphics.drawable.Animatable2.AnimationCallback callback)
  ///
  /// @param callback This value must never be {@code null}.
  bool unregisterAnimationCallback(
          animatable2_.Animatable2_AnimationCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterAnimationCallback,
          jni.JniType.booleanType,
          [callback.reference]).boolean;

  static final _id_clearAnimationCallbacks =
      jniAccessors.getMethodIDOf(_classRef, "clearAnimationCallbacks", "()V");

  /// from: public void clearAnimationCallbacks()
  void clearAnimationCallbacks() => jniAccessors.callMethodWithArgs(
      reference, _id_clearAnimationCallbacks, jni.JniType.voidType, []).check();
}
