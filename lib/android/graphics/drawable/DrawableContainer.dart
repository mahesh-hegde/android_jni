// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Drawable.dart" as drawable_;

import "../Canvas.dart" as canvas_;

import "../Rect.dart" as rect_;

import "../Outline.dart" as outline_;

import "../ColorFilter.dart" as colorfilter_;

import "../../content/res/ColorStateList.dart" as colorstatelist_;

import "../PorterDuff.dart" as porterduff_;

import "../../content/res/Resources.dart" as resources_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.drawable.DrawableContainer
///
/// A helper class that contains several Drawables and selects which one to use.
///
/// You can subclass it to create your own DrawableContainers or directly use one its child classes.
class DrawableContainer extends drawable_.Drawable {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/drawable/DrawableContainer");
  DrawableContainer.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DrawableContainer()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// @return Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_getPadding = jniAccessors.getMethodIDOf(
      _classRef, "getPadding", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean getPadding(android.graphics.Rect padding)
  bool getPadding(rect_.Rect padding) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPadding,
      jni.JniType.booleanType,
      [padding.reference]).boolean;

  static final _id_getOutline = jniAccessors.getMethodIDOf(
      _classRef, "getOutline", "(Landroid/graphics/Outline;)V");

  /// from: public void getOutline(android.graphics.Outline outline)
  ///
  /// @param outline This value must never be {@code null}.
  void getOutline(outline_.Outline outline) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getOutline,
      jni.JniType.voidType,
      [outline.reference]).check();

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int alpha)
  void setAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setDither =
      jniAccessors.getMethodIDOf(_classRef, "setDither", "(Z)V");

  /// from: public void setDither(boolean dither)
  void setDither(bool dither) => jniAccessors.callMethodWithArgs(
      reference, _id_setDither, jni.JniType.voidType, [dither]).check();

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public void setColorFilter(android.graphics.ColorFilter colorFilter)
  void setColorFilter(colorfilter_.ColorFilter colorFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [colorFilter.reference]).check();

  static final _id_setTintList = jniAccessors.getMethodIDOf(
      _classRef, "setTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTintList(android.content.res.ColorStateList tint)
  void setTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_setTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setTintMode(android.graphics.PorterDuff.Mode tintMode)
  void setTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_setEnterFadeDuration =
      jniAccessors.getMethodIDOf(_classRef, "setEnterFadeDuration", "(I)V");

  /// from: public void setEnterFadeDuration(int ms)
  ///
  /// Change the global fade duration when a new drawable is entering
  /// the scene.
  ///@param ms The amount of time to fade in milliseconds.
  void setEnterFadeDuration(int ms) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnterFadeDuration, jni.JniType.voidType, [ms]).check();

  static final _id_setExitFadeDuration =
      jniAccessors.getMethodIDOf(_classRef, "setExitFadeDuration", "(I)V");

  /// from: public void setExitFadeDuration(int ms)
  ///
  /// Change the global fade duration when a new drawable is leaving
  /// the scene.
  ///@param ms The amount of time to fade in milliseconds.
  void setExitFadeDuration(int ms) => jniAccessors.callMethodWithArgs(
      reference, _id_setExitFadeDuration, jni.JniType.voidType, [ms]).check();

  static final _id_onBoundsChange = jniAccessors.getMethodIDOf(
      _classRef, "onBoundsChange", "(Landroid/graphics/Rect;)V");

  /// from: protected void onBoundsChange(android.graphics.Rect bounds)
  void onBoundsChange(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBoundsChange,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public boolean isStateful()
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_setAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "setAutoMirrored", "(Z)V");

  /// from: public void setAutoMirrored(boolean mirrored)
  void setAutoMirrored(bool mirrored) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutoMirrored, jni.JniType.voidType, [mirrored]).check();

  static final _id_isAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "isAutoMirrored", "()Z");

  /// from: public boolean isAutoMirrored()
  bool isAutoMirrored() => jniAccessors.callMethodWithArgs(
      reference, _id_isAutoMirrored, jni.JniType.booleanType, []).boolean;

  static final _id_jumpToCurrentState =
      jniAccessors.getMethodIDOf(_classRef, "jumpToCurrentState", "()V");

  /// from: public void jumpToCurrentState()
  void jumpToCurrentState() => jniAccessors.callMethodWithArgs(
      reference, _id_jumpToCurrentState, jni.JniType.voidType, []).check();

  static final _id_setHotspot =
      jniAccessors.getMethodIDOf(_classRef, "setHotspot", "(FF)V");

  /// from: public void setHotspot(float x, float y)
  void setHotspot(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_setHotspot, jni.JniType.voidType, [x, y]).check();

  static final _id_setHotspotBounds =
      jniAccessors.getMethodIDOf(_classRef, "setHotspotBounds", "(IIII)V");

  /// from: public void setHotspotBounds(int left, int top, int right, int bottom)
  void setHotspotBounds(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHotspotBounds,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_getHotspotBounds = jniAccessors.getMethodIDOf(
      _classRef, "getHotspotBounds", "(Landroid/graphics/Rect;)V");

  /// from: public void getHotspotBounds(android.graphics.Rect outRect)
  void getHotspotBounds(rect_.Rect outRect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHotspotBounds,
      jni.JniType.voidType,
      [outRect.reference]).check();

  static final _id_onStateChange =
      jniAccessors.getMethodIDOf(_classRef, "onStateChange", "([I)Z");

  /// from: protected boolean onStateChange(int[] state)
  bool onStateChange(jni.JniObject state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStateChange,
      jni.JniType.booleanType,
      [state.reference]).boolean;

  static final _id_onLevelChange =
      jniAccessors.getMethodIDOf(_classRef, "onLevelChange", "(I)Z");

  /// from: protected boolean onLevelChange(int level)
  bool onLevelChange(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onLevelChange, jni.JniType.booleanType, [level]).boolean;

  static final _id_onLayoutDirectionChanged =
      jniAccessors.getMethodIDOf(_classRef, "onLayoutDirectionChanged", "(I)Z");

  /// from: public boolean onLayoutDirectionChanged(int layoutDirection)
  ///
  /// @param layoutDirection Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  bool onLayoutDirectionChanged(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayoutDirectionChanged,
          jni.JniType.booleanType, [layoutDirection]).boolean;

  static final _id_getIntrinsicWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicWidth", "()I");

  /// from: public int getIntrinsicWidth()
  int getIntrinsicWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicWidth, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicHeight", "()I");

  /// from: public int getIntrinsicHeight()
  int getIntrinsicHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicHeight, jni.JniType.intType, []).integer;

  static final _id_getMinimumWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumWidth", "()I");

  /// from: public int getMinimumWidth()
  int getMinimumWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumWidth, jni.JniType.intType, []).integer;

  static final _id_getMinimumHeight =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumHeight", "()I");

  /// from: public int getMinimumHeight()
  int getMinimumHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumHeight, jni.JniType.intType, []).integer;

  static final _id_invalidateDrawable = jniAccessors.getMethodIDOf(_classRef,
      "invalidateDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable who)
  ///
  /// @param who This value must never be {@code null}.
  void invalidateDrawable(drawable_.Drawable who) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateDrawable,
          jni.JniType.voidType, [who.reference]).check();

  static final _id_scheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "scheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;J)V");

  /// from: public void scheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what, long when)
  ///
  /// @param who This value must never be {@code null}.
  ///@param what This value must never be {@code null}.
  void scheduleDrawable(drawable_.Drawable who, jni.JniObject what, int when) =>
      jniAccessors.callMethodWithArgs(reference, _id_scheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference, when]).check();

  static final _id_unscheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "unscheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;)V");

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what)
  ///
  /// @param who This value must never be {@code null}.
  ///@param what This value must never be {@code null}.
  void unscheduleDrawable(drawable_.Drawable who, jni.JniObject what) =>
      jniAccessors.callMethodWithArgs(reference, _id_unscheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference]).check();

  static final _id_setVisible =
      jniAccessors.getMethodIDOf(_classRef, "setVisible", "(ZZ)Z");

  /// from: public boolean setVisible(boolean visible, boolean restart)
  bool setVisible(bool visible, bool restart) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVisible,
          jni.JniType.booleanType, [visible, restart]).boolean;

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public int getOpacity()
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_selectDrawable =
      jniAccessors.getMethodIDOf(_classRef, "selectDrawable", "(I)Z");

  /// from: public boolean selectDrawable(int index)
  ///
  /// Sets the currently displayed drawable by index.
  ///
  /// If an invalid index is specified, the current drawable will be set to
  /// {@code null} and the index will be set to {@code -1}.
  ///@param index the index of the drawable to display
  ///@return {@code true} if the drawable changed, {@code false} otherwise
  bool selectDrawable(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_selectDrawable, jni.JniType.booleanType, [index]).boolean;

  static final _id_getCurrent = jniAccessors.getMethodIDOf(
      _classRef, "getCurrent", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getCurrent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable getCurrent() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCurrent, jni.JniType.objectType, []).object);

  static final _id_applyTheme = jniAccessors.getMethodIDOf(
      _classRef, "applyTheme", "(Landroid/content/res/Resources\$Theme;)V");

  /// from: public void applyTheme(android.content.res.Resources.Theme theme)
  void applyTheme(resources_.Resources_Theme theme) =>
      jniAccessors.callMethodWithArgs(reference, _id_applyTheme,
          jni.JniType.voidType, [theme.reference]).check();

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;

  static final _id_getConstantState = jniAccessors.getMethodIDOf(
      _classRef,
      "getConstantState",
      "()Landroid/graphics/drawable/Drawable\$ConstantState;");

  /// from: public android.graphics.drawable.Drawable.ConstantState getConstantState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable_ConstantState getConstantState() =>
      drawable_.Drawable_ConstantState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConstantState, jni.JniType.objectType, []).object);

  static final _id_mutate = jniAccessors.getMethodIDOf(
      _classRef, "mutate", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable mutate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable mutate() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_mutate, jni.JniType.objectType, []).object);

  static final _id_setConstantState = jniAccessors.getMethodIDOf(
      _classRef,
      "setConstantState",
      "(Landroid/graphics/drawable/DrawableContainer\$DrawableContainerState;)V");

  /// from: protected void setConstantState(android.graphics.drawable.DrawableContainer.DrawableContainerState state)
  void setConstantState(DrawableContainer_DrawableContainerState state) =>
      jniAccessors.callMethodWithArgs(reference, _id_setConstantState,
          jni.JniType.voidType, [state.reference]).check();
}

/// from: android.graphics.drawable.DrawableContainer$DrawableContainerState
///
/// A ConstantState that can contain several Drawables.
///
/// This class was made public to enable testing, and its visibility may change in a future
/// release.
class DrawableContainer_DrawableContainerState
    extends drawable_.Drawable_ConstantState {
  static final _classRef = jniAccessors.getClassOf(
      "android/graphics/drawable/DrawableContainer\$DrawableContainerState");
  DrawableContainer_DrawableContainerState.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// @return Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_addChild = jniAccessors.getMethodIDOf(
      _classRef, "addChild", "(Landroid/graphics/drawable/Drawable;)I");

  /// from: public final int addChild(android.graphics.drawable.Drawable dr)
  ///
  /// Adds the drawable to the end of the list of contained drawables.
  ///@param dr the drawable to add
  ///@return the position of the drawable within the container
  int addChild(drawable_.Drawable dr) => jniAccessors.callMethodWithArgs(
      reference, _id_addChild, jni.JniType.intType, [dr.reference]).integer;

  static final _id_getChildCount =
      jniAccessors.getMethodIDOf(_classRef, "getChildCount", "()I");

  /// from: public final int getChildCount()
  int getChildCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getChildCount, jni.JniType.intType, []).integer;

  static final _id_getChildren = jniAccessors.getMethodIDOf(
      _classRef, "getChildren", "()[Landroid/graphics/drawable/Drawable;");

  /// from: public final android.graphics.drawable.Drawable[] getChildren()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getChildren() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChildren, jni.JniType.objectType, []).object);

  static final _id_getChild = jniAccessors.getMethodIDOf(
      _classRef, "getChild", "(I)Landroid/graphics/drawable/Drawable;");

  /// from: public final android.graphics.drawable.Drawable getChild(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable getChild(int index) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChild, jni.JniType.objectType, [index]).object);

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;

  static final _id_setVariablePadding =
      jniAccessors.getMethodIDOf(_classRef, "setVariablePadding", "(Z)V");

  /// from: public final void setVariablePadding(boolean variable)
  ///
  /// A boolean value indicating whether to use the maximum padding value
  /// of all frames in the set (false), or to use the padding value of the
  /// frame being shown (true). Default value is false.
  void setVariablePadding(bool variable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVariablePadding,
      jni.JniType.voidType,
      [variable]).check();

  static final _id_getConstantPadding = jniAccessors.getMethodIDOf(
      _classRef, "getConstantPadding", "()Landroid/graphics/Rect;");

  /// from: public final android.graphics.Rect getConstantPadding()
  /// The returned object must be deleted after use, by calling the `delete` method.
  rect_.Rect getConstantPadding() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConstantPadding, jni.JniType.objectType, []).object);

  static final _id_setConstantSize =
      jniAccessors.getMethodIDOf(_classRef, "setConstantSize", "(Z)V");

  /// from: public final void setConstantSize(boolean constant)
  void setConstantSize(bool constant) => jniAccessors.callMethodWithArgs(
      reference, _id_setConstantSize, jni.JniType.voidType, [constant]).check();

  static final _id_isConstantSize =
      jniAccessors.getMethodIDOf(_classRef, "isConstantSize", "()Z");

  /// from: public final boolean isConstantSize()
  bool isConstantSize() => jniAccessors.callMethodWithArgs(
      reference, _id_isConstantSize, jni.JniType.booleanType, []).boolean;

  static final _id_getConstantWidth =
      jniAccessors.getMethodIDOf(_classRef, "getConstantWidth", "()I");

  /// from: public final int getConstantWidth()
  int getConstantWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getConstantWidth, jni.JniType.intType, []).integer;

  static final _id_getConstantHeight =
      jniAccessors.getMethodIDOf(_classRef, "getConstantHeight", "()I");

  /// from: public final int getConstantHeight()
  int getConstantHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getConstantHeight, jni.JniType.intType, []).integer;

  static final _id_getConstantMinimumWidth =
      jniAccessors.getMethodIDOf(_classRef, "getConstantMinimumWidth", "()I");

  /// from: public final int getConstantMinimumWidth()
  int getConstantMinimumWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getConstantMinimumWidth, jni.JniType.intType, []).integer;

  static final _id_getConstantMinimumHeight =
      jniAccessors.getMethodIDOf(_classRef, "getConstantMinimumHeight", "()I");

  /// from: public final int getConstantMinimumHeight()
  int getConstantMinimumHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getConstantMinimumHeight, jni.JniType.intType, []).integer;

  static final _id_computeConstantSize =
      jniAccessors.getMethodIDOf(_classRef, "computeConstantSize", "()V");

  /// from: protected void computeConstantSize()
  void computeConstantSize() => jniAccessors.callMethodWithArgs(
      reference, _id_computeConstantSize, jni.JniType.voidType, []).check();

  static final _id_setEnterFadeDuration =
      jniAccessors.getMethodIDOf(_classRef, "setEnterFadeDuration", "(I)V");

  /// from: public final void setEnterFadeDuration(int duration)
  void setEnterFadeDuration(int duration) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setEnterFadeDuration,
      jni.JniType.voidType,
      [duration]).check();

  static final _id_getEnterFadeDuration =
      jniAccessors.getMethodIDOf(_classRef, "getEnterFadeDuration", "()I");

  /// from: public final int getEnterFadeDuration()
  int getEnterFadeDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getEnterFadeDuration, jni.JniType.intType, []).integer;

  static final _id_setExitFadeDuration =
      jniAccessors.getMethodIDOf(_classRef, "setExitFadeDuration", "(I)V");

  /// from: public final void setExitFadeDuration(int duration)
  void setExitFadeDuration(int duration) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExitFadeDuration,
      jni.JniType.voidType,
      [duration]).check();

  static final _id_getExitFadeDuration =
      jniAccessors.getMethodIDOf(_classRef, "getExitFadeDuration", "()I");

  /// from: public final int getExitFadeDuration()
  int getExitFadeDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getExitFadeDuration, jni.JniType.intType, []).integer;

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public final int getOpacity()
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public final boolean isStateful()
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_growArray =
      jniAccessors.getMethodIDOf(_classRef, "growArray", "(II)V");

  /// from: public void growArray(int oldSize, int newSize)
  void growArray(int oldSize, int newSize) => jniAccessors.callMethodWithArgs(
      reference,
      _id_growArray,
      jni.JniType.voidType,
      [oldSize, newSize]).check();

  static final _id_canConstantState =
      jniAccessors.getMethodIDOf(_classRef, "canConstantState", "()Z");

  /// from: synchronized public boolean canConstantState()
  bool canConstantState() => jniAccessors.callMethodWithArgs(
      reference, _id_canConstantState, jni.JniType.booleanType, []).boolean;
}
