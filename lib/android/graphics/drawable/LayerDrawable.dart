// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Drawable.dart" as drawable_;

import "../../content/res/Resources.dart" as resources_;

import "../../util/AttributeSet.dart" as attributeset_;

import "../Canvas.dart" as canvas_;

import "../Rect.dart" as rect_;

import "../Outline.dart" as outline_;

import "../ColorFilter.dart" as colorfilter_;

import "../../content/res/ColorStateList.dart" as colorstatelist_;

import "../PorterDuff.dart" as porterduff_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.drawable.LayerDrawable
///
/// A Drawable that manages an array of other Drawables. These are drawn in array
/// order, so the element with the largest index will be drawn on top.
///
/// It can be defined in an XML file with the <code>&lt;layer-list></code> element.
/// Each Drawable in the layer is defined in a nested <code>&lt;item></code>.
///
/// For more information, see the guide to
/// <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>.
///@attr ref android.R.styleable\#LayerDrawable_paddingMode
///@attr ref android.R.styleable\#LayerDrawableItem_left
///@attr ref android.R.styleable\#LayerDrawableItem_top
///@attr ref android.R.styleable\#LayerDrawableItem_right
///@attr ref android.R.styleable\#LayerDrawableItem_bottom
///@attr ref android.R.styleable\#LayerDrawableItem_start
///@attr ref android.R.styleable\#LayerDrawableItem_end
///@attr ref android.R.styleable\#LayerDrawableItem_width
///@attr ref android.R.styleable\#LayerDrawableItem_height
///@attr ref android.R.styleable\#LayerDrawableItem_gravity
///@attr ref android.R.styleable\#LayerDrawableItem_drawable
///@attr ref android.R.styleable\#LayerDrawableItem_id
class LayerDrawable extends drawable_.Drawable {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/drawable/LayerDrawable");
  LayerDrawable.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int INSET_UNDEFINED
  ///
  /// Value used for undefined start and end insets.
  ///@see \#getLayerInsetStart(int)
  ///@see \#getLayerInsetEnd(int)
  static const INSET_UNDEFINED = -2147483648;

  /// from: static public final int PADDING_MODE_NEST
  ///
  /// Padding mode used to nest each layer inside the padding of the previous
  /// layer.
  ///@see \#setPaddingMode(int)
  static const PADDING_MODE_NEST = 0;

  /// from: static public final int PADDING_MODE_STACK
  ///
  /// Padding mode used to stack each layer directly atop the previous layer.
  ///@see \#setPaddingMode(int)
  static const PADDING_MODE_STACK = 1;

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "([Landroid/graphics/drawable/Drawable;)V");

  /// from: public void <init>(android.graphics.drawable.Drawable[] layers)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new layer drawable with the list of specified layers.
  ///@param layers a list of drawables to use as layers in this new drawable,
  ///               must be non-null
  ///
  /// This value must never be {@code null}.
  LayerDrawable.ctor1(jni.JniObject layers)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [layers.reference]).object);

  static final _id_inflate1 = jniAccessors.getMethodIDOf(_classRef, "inflate",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;Landroid/content/res/Resources\$Theme;)V");

  /// from: public void inflate(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs, android.content.res.Resources.Theme theme)
  ///
  /// @param r This value must never be {@code null}.
  ///@param parser This value must never be {@code null}.
  ///@param attrs This value must never be {@code null}.
  ///@param theme This value may be {@code null}.
  void inflate1(resources_.Resources r, jni.JniObject parser,
          attributeset_.AttributeSet attrs, resources_.Resources_Theme theme) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_inflate1, jni.JniType.voidType, [
        r.reference,
        parser.reference,
        attrs.reference,
        theme.reference
      ]).check();

  static final _id_applyTheme = jniAccessors.getMethodIDOf(
      _classRef, "applyTheme", "(Landroid/content/res/Resources\$Theme;)V");

  /// from: public void applyTheme(android.content.res.Resources.Theme t)
  ///
  /// @param t This value must never be {@code null}.
  void applyTheme(resources_.Resources_Theme t) =>
      jniAccessors.callMethodWithArgs(reference, _id_applyTheme,
          jni.JniType.voidType, [t.reference]).check();

  static final _id_canApplyTheme =
      jniAccessors.getMethodIDOf(_classRef, "canApplyTheme", "()Z");

  /// from: public boolean canApplyTheme()
  bool canApplyTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_canApplyTheme, jni.JniType.booleanType, []).boolean;

  static final _id_addLayer = jniAccessors.getMethodIDOf(
      _classRef, "addLayer", "(Landroid/graphics/drawable/Drawable;)I");

  /// from: public int addLayer(android.graphics.drawable.Drawable dr)
  ///
  /// Adds a new layer containing the specified {@code drawable} to the end of
  /// the layer list and returns its index.
  ///@param dr The drawable to add as a new layer.
  ///@return The index of the new layer.
  int addLayer(drawable_.Drawable dr) => jniAccessors.callMethodWithArgs(
      reference, _id_addLayer, jni.JniType.intType, [dr.reference]).integer;

  static final _id_findDrawableByLayerId = jniAccessors.getMethodIDOf(_classRef,
      "findDrawableByLayerId", "(I)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable findDrawableByLayerId(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Looks for a layer with the given ID and returns its Drawable.
  ///
  /// If multiple layers are found for the given ID, returns the
  /// Drawable for the matching layer at the highest index.
  ///@param id The layer ID to search for.
  ///@return The Drawable for the highest-indexed layer that has the
  ///         given ID, or null if not found.
  drawable_.Drawable findDrawableByLayerId(int id) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_findDrawableByLayerId, jni.JniType.objectType, [id]).object);

  static final _id_setId =
      jniAccessors.getMethodIDOf(_classRef, "setId", "(II)V");

  /// from: public void setId(int index, int id)
  ///
  /// Sets the ID of a layer.
  ///@param index The index of the layer to modify, must be in the range
  ///              {@code 0...getNumberOfLayers()-1}.
  ///@param id The id to assign to the layer.
  ///@see \#getId(int)
  ///@attr ref android.R.styleable\#LayerDrawableItem_id
  void setId(int index, int id) => jniAccessors.callMethodWithArgs(
      reference, _id_setId, jni.JniType.voidType, [index, id]).check();

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "(I)I");

  /// from: public int getId(int index)
  ///
  /// Returns the ID of the specified layer.
  ///@param index The index of the layer, must be in the range
  ///              {@code 0...getNumberOfLayers()-1}.
  ///@return The id of the layer or android.view.View\#NO_ID if the
  ///         layer has no id.
  ///@see \#setId(int, int)
  ///@attr ref android.R.styleable\#LayerDrawableItem_id
  int getId(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, [index]).integer;

  static final _id_getNumberOfLayers =
      jniAccessors.getMethodIDOf(_classRef, "getNumberOfLayers", "()I");

  /// from: public int getNumberOfLayers()
  ///
  /// Returns the number of layers contained within this layer drawable.
  ///@return The number of layers.
  int getNumberOfLayers() => jniAccessors.callMethodWithArgs(
      reference, _id_getNumberOfLayers, jni.JniType.intType, []).integer;

  static final _id_setDrawableByLayerId = jniAccessors.getMethodIDOf(_classRef,
      "setDrawableByLayerId", "(ILandroid/graphics/drawable/Drawable;)Z");

  /// from: public boolean setDrawableByLayerId(int id, android.graphics.drawable.Drawable drawable)
  ///
  /// Replaces the Drawable for the layer with the given id.
  ///@param id The layer ID to search for.
  ///@param drawable The replacement Drawable.
  ///@return Whether the Drawable was replaced (could return false if
  ///         the id was not found).
  bool setDrawableByLayerId(int id, drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDrawableByLayerId,
          jni.JniType.booleanType, [id, drawable.reference]).boolean;

  static final _id_findIndexByLayerId =
      jniAccessors.getMethodIDOf(_classRef, "findIndexByLayerId", "(I)I");

  /// from: public int findIndexByLayerId(int id)
  ///
  /// Returns the layer with the specified {@code id}.
  ///
  /// If multiple layers have the same ID, returns the layer with the lowest
  /// index.
  ///@param id The ID of the layer to return.
  ///@return The index of the layer with the specified ID.
  int findIndexByLayerId(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_findIndexByLayerId, jni.JniType.intType, [id]).integer;

  static final _id_setDrawable = jniAccessors.getMethodIDOf(
      _classRef, "setDrawable", "(ILandroid/graphics/drawable/Drawable;)V");

  /// from: public void setDrawable(int index, android.graphics.drawable.Drawable drawable)
  ///
  /// Sets the drawable for the layer at the specified index.
  ///@param index The index of the layer to modify, must be in the range
  ///              {@code 0...getNumberOfLayers()-1}.
  ///@param drawable The drawable to set for the layer.
  ///@see \#getDrawable(int)
  ///@attr ref android.R.styleable\#LayerDrawableItem_drawable
  void setDrawable(int index, drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDrawable,
          jni.JniType.voidType, [index, drawable.reference]).check();

  static final _id_getDrawable = jniAccessors.getMethodIDOf(
      _classRef, "getDrawable", "(I)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getDrawable(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the drawable for the layer at the specified index.
  ///@param index The index of the layer, must be in the range
  ///              {@code 0...getNumberOfLayers()-1}.
  ///@return The Drawable at the specified layer index.
  ///@see \#setDrawable(int, Drawable)
  ///@attr ref android.R.styleable\#LayerDrawableItem_drawable
  drawable_.Drawable getDrawable(int index) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrawable, jni.JniType.objectType, [index]).object);

  static final _id_setLayerSize =
      jniAccessors.getMethodIDOf(_classRef, "setLayerSize", "(III)V");

  /// from: public void setLayerSize(int index, int w, int h)
  ///
  /// Sets an explicit size for the specified layer.
  ///
  /// <strong>Note:</strong> Setting an explicit layer size changes the
  /// default layer gravity behavior. See \#setLayerGravity(int, int)
  /// for more information.
  ///@param index the index of the layer to adjust
  ///@param w width in pixels, or -1 to use the intrinsic width
  ///@param h height in pixels, or -1 to use the intrinsic height
  ///@see \#getLayerWidth(int)
  ///@see \#getLayerHeight(int)
  ///@attr ref android.R.styleable\#LayerDrawableItem_width
  ///@attr ref android.R.styleable\#LayerDrawableItem_height
  void setLayerSize(int index, int w, int h) => jniAccessors.callMethodWithArgs(
      reference, _id_setLayerSize, jni.JniType.voidType, [index, w, h]).check();

  static final _id_setLayerWidth =
      jniAccessors.getMethodIDOf(_classRef, "setLayerWidth", "(II)V");

  /// from: public void setLayerWidth(int index, int w)
  ///
  /// @param index the index of the layer to adjust
  ///@param w width in pixels, or -1 to use the intrinsic width
  ///@attr ref android.R.styleable\#LayerDrawableItem_width
  void setLayerWidth(int index, int w) => jniAccessors.callMethodWithArgs(
      reference, _id_setLayerWidth, jni.JniType.voidType, [index, w]).check();

  static final _id_getLayerWidth =
      jniAccessors.getMethodIDOf(_classRef, "getLayerWidth", "(I)I");

  /// from: public int getLayerWidth(int index)
  ///
  /// @param index the index of the drawable to adjust
  ///@return the explicit width of the layer, or -1 if not specified
  ///@see \#setLayerSize(int, int, int)
  ///@attr ref android.R.styleable\#LayerDrawableItem_width
  int getLayerWidth(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerWidth, jni.JniType.intType, [index]).integer;

  static final _id_setLayerHeight =
      jniAccessors.getMethodIDOf(_classRef, "setLayerHeight", "(II)V");

  /// from: public void setLayerHeight(int index, int h)
  ///
  /// @param index the index of the layer to adjust
  ///@param h height in pixels, or -1 to use the intrinsic height
  ///@attr ref android.R.styleable\#LayerDrawableItem_height
  void setLayerHeight(int index, int h) => jniAccessors.callMethodWithArgs(
      reference, _id_setLayerHeight, jni.JniType.voidType, [index, h]).check();

  static final _id_getLayerHeight =
      jniAccessors.getMethodIDOf(_classRef, "getLayerHeight", "(I)I");

  /// from: public int getLayerHeight(int index)
  ///
  /// @param index the index of the drawable to adjust
  ///@return the explicit height of the layer, or -1 if not specified
  ///@see \#setLayerSize(int, int, int)
  ///@attr ref android.R.styleable\#LayerDrawableItem_height
  int getLayerHeight(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerHeight, jni.JniType.intType, [index]).integer;

  static final _id_setLayerGravity =
      jniAccessors.getMethodIDOf(_classRef, "setLayerGravity", "(II)V");

  /// from: public void setLayerGravity(int index, int gravity)
  ///
  /// Sets the gravity used to position or stretch the specified layer within
  /// its container. Gravity is applied after any layer insets (see
  /// \#setLayerInset(int, int, int, int, int)) or padding (see
  /// \#setPaddingMode(int)).
  ///
  /// If gravity is specified as Gravity\#NO_GRAVITY, the default
  /// behavior depends on whether an explicit width or height has been set
  /// (see \#setLayerSize(int, int, int)), If a dimension is not set,
  /// gravity in that direction defaults to Gravity\#FILL_HORIZONTAL or
  /// Gravity\#FILL_VERTICAL; otherwise, gravity in that direction
  /// defaults to Gravity\#LEFT or Gravity\#TOP.
  ///@param index the index of the drawable to adjust
  ///@param gravity the gravity to set for the layer
  ///@see \#getLayerGravity(int)
  ///@attr ref android.R.styleable\#LayerDrawableItem_gravity
  void setLayerGravity(int index, int gravity) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayerGravity,
          jni.JniType.voidType, [index, gravity]).check();

  static final _id_getLayerGravity =
      jniAccessors.getMethodIDOf(_classRef, "getLayerGravity", "(I)I");

  /// from: public int getLayerGravity(int index)
  ///
  /// @param index the index of the layer
  ///@return the gravity used to position or stretch the specified layer
  ///         within its container
  ///@see \#setLayerGravity(int, int)
  ///@attr ref android.R.styleable\#LayerDrawableItem_gravity
  int getLayerGravity(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerGravity, jni.JniType.intType, [index]).integer;

  static final _id_setLayerInset =
      jniAccessors.getMethodIDOf(_classRef, "setLayerInset", "(IIIII)V");

  /// from: public void setLayerInset(int index, int l, int t, int r, int b)
  ///
  /// Specifies the insets in pixels for the drawable at the specified index.
  ///@param index the index of the drawable to adjust
  ///@param l number of pixels to add to the left bound
  ///@param t number of pixels to add to the top bound
  ///@param r number of pixels to subtract from the right bound
  ///@param b number of pixels to subtract from the bottom bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_left
  ///@attr ref android.R.styleable\#LayerDrawableItem_top
  ///@attr ref android.R.styleable\#LayerDrawableItem_right
  ///@attr ref android.R.styleable\#LayerDrawableItem_bottom
  void setLayerInset(int index, int l, int t, int r, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayerInset,
          jni.JniType.voidType, [index, l, t, r, b]).check();

  static final _id_setLayerInsetRelative = jniAccessors.getMethodIDOf(
      _classRef, "setLayerInsetRelative", "(IIIII)V");

  /// from: public void setLayerInsetRelative(int index, int s, int t, int e, int b)
  ///
  /// Specifies the relative insets in pixels for the drawable at the
  /// specified index.
  ///@param index the index of the layer to adjust
  ///@param s number of pixels to inset from the start bound
  ///@param t number of pixels to inset from the top bound
  ///@param e number of pixels to inset from the end bound
  ///@param b number of pixels to inset from the bottom bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_start
  ///@attr ref android.R.styleable\#LayerDrawableItem_top
  ///@attr ref android.R.styleable\#LayerDrawableItem_end
  ///@attr ref android.R.styleable\#LayerDrawableItem_bottom
  void setLayerInsetRelative(int index, int s, int t, int e, int b) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayerInsetRelative,
          jni.JniType.voidType, [index, s, t, e, b]).check();

  static final _id_setLayerInsetLeft =
      jniAccessors.getMethodIDOf(_classRef, "setLayerInsetLeft", "(II)V");

  /// from: public void setLayerInsetLeft(int index, int l)
  ///
  /// @param index the index of the layer to adjust
  ///@param l number of pixels to inset from the left bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_left
  void setLayerInsetLeft(int index, int l) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayerInsetLeft,
      jni.JniType.voidType,
      [index, l]).check();

  static final _id_getLayerInsetLeft =
      jniAccessors.getMethodIDOf(_classRef, "getLayerInsetLeft", "(I)I");

  /// from: public int getLayerInsetLeft(int index)
  ///
  /// @param index the index of the layer
  ///@return number of pixels to inset from the left bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_left
  int getLayerInsetLeft(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerInsetLeft, jni.JniType.intType, [index]).integer;

  static final _id_setLayerInsetRight =
      jniAccessors.getMethodIDOf(_classRef, "setLayerInsetRight", "(II)V");

  /// from: public void setLayerInsetRight(int index, int r)
  ///
  /// @param index the index of the layer to adjust
  ///@param r number of pixels to inset from the right bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_right
  void setLayerInsetRight(int index, int r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayerInsetRight,
      jni.JniType.voidType,
      [index, r]).check();

  static final _id_getLayerInsetRight =
      jniAccessors.getMethodIDOf(_classRef, "getLayerInsetRight", "(I)I");

  /// from: public int getLayerInsetRight(int index)
  ///
  /// @param index the index of the layer
  ///@return number of pixels to inset from the right bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_right
  int getLayerInsetRight(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerInsetRight, jni.JniType.intType, [index]).integer;

  static final _id_setLayerInsetTop =
      jniAccessors.getMethodIDOf(_classRef, "setLayerInsetTop", "(II)V");

  /// from: public void setLayerInsetTop(int index, int t)
  ///
  /// @param index the index of the layer to adjust
  ///@param t number of pixels to inset from the top bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_top
  void setLayerInsetTop(int index, int t) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayerInsetTop,
      jni.JniType.voidType,
      [index, t]).check();

  static final _id_getLayerInsetTop =
      jniAccessors.getMethodIDOf(_classRef, "getLayerInsetTop", "(I)I");

  /// from: public int getLayerInsetTop(int index)
  ///
  /// @param index the index of the layer
  ///@return number of pixels to inset from the top bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_top
  int getLayerInsetTop(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerInsetTop, jni.JniType.intType, [index]).integer;

  static final _id_setLayerInsetBottom =
      jniAccessors.getMethodIDOf(_classRef, "setLayerInsetBottom", "(II)V");

  /// from: public void setLayerInsetBottom(int index, int b)
  ///
  /// @param index the index of the layer to adjust
  ///@param b number of pixels to inset from the bottom bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_bottom
  void setLayerInsetBottom(int index, int b) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayerInsetBottom,
      jni.JniType.voidType,
      [index, b]).check();

  static final _id_getLayerInsetBottom =
      jniAccessors.getMethodIDOf(_classRef, "getLayerInsetBottom", "(I)I");

  /// from: public int getLayerInsetBottom(int index)
  ///
  /// @param index the index of the layer
  ///@return number of pixels to inset from the bottom bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_bottom
  int getLayerInsetBottom(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerInsetBottom, jni.JniType.intType, [index]).integer;

  static final _id_setLayerInsetStart =
      jniAccessors.getMethodIDOf(_classRef, "setLayerInsetStart", "(II)V");

  /// from: public void setLayerInsetStart(int index, int s)
  ///
  /// @param index the index of the layer to adjust
  ///@param s number of pixels to inset from the start bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_start
  void setLayerInsetStart(int index, int s) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayerInsetStart,
      jni.JniType.voidType,
      [index, s]).check();

  static final _id_getLayerInsetStart =
      jniAccessors.getMethodIDOf(_classRef, "getLayerInsetStart", "(I)I");

  /// from: public int getLayerInsetStart(int index)
  ///
  /// @param index the index of the layer
  ///@return the number of pixels to inset from the start bound, or
  ///         \#INSET_UNDEFINED if not specified
  ///@attr ref android.R.styleable\#LayerDrawableItem_start
  int getLayerInsetStart(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerInsetStart, jni.JniType.intType, [index]).integer;

  static final _id_setLayerInsetEnd =
      jniAccessors.getMethodIDOf(_classRef, "setLayerInsetEnd", "(II)V");

  /// from: public void setLayerInsetEnd(int index, int e)
  ///
  /// @param index the index of the layer to adjust
  ///@param e number of pixels to inset from the end bound, or
  ///         \#INSET_UNDEFINED if not specified
  ///@attr ref android.R.styleable\#LayerDrawableItem_end
  void setLayerInsetEnd(int index, int e) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayerInsetEnd,
      jni.JniType.voidType,
      [index, e]).check();

  static final _id_getLayerInsetEnd =
      jniAccessors.getMethodIDOf(_classRef, "getLayerInsetEnd", "(I)I");

  /// from: public int getLayerInsetEnd(int index)
  ///
  /// @param index the index of the layer
  ///@return number of pixels to inset from the end bound
  ///@attr ref android.R.styleable\#LayerDrawableItem_end
  int getLayerInsetEnd(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getLayerInsetEnd, jni.JniType.intType, [index]).integer;

  static final _id_setPaddingMode =
      jniAccessors.getMethodIDOf(_classRef, "setPaddingMode", "(I)V");

  /// from: public void setPaddingMode(int mode)
  ///
  /// Specifies how layer padding should affect the bounds of subsequent
  /// layers. The default value is \#PADDING_MODE_NEST.
  ///@param mode padding mode, one of:
  ///            <ul>
  ///            <li>\#PADDING_MODE_NEST to nest each layer inside the
  ///            padding of the previous layer
  ///            <li>\#PADDING_MODE_STACK to stack each layer directly
  ///            atop the previous layer
  ///            </ul>
  ///@see \#getPaddingMode()
  ///@attr ref android.R.styleable\#LayerDrawable_paddingMode
  void setPaddingMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setPaddingMode, jni.JniType.voidType, [mode]).check();

  static final _id_getPaddingMode =
      jniAccessors.getMethodIDOf(_classRef, "getPaddingMode", "()I");

  /// from: public int getPaddingMode()
  ///
  /// @return the current padding mode
  ///@see \#setPaddingMode(int)
  ///@attr ref android.R.styleable\#LayerDrawable_paddingMode
  int getPaddingMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getPaddingMode, jni.JniType.intType, []).integer;

  static final _id_invalidateDrawable = jniAccessors.getMethodIDOf(_classRef,
      "invalidateDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void invalidateDrawable(android.graphics.drawable.Drawable who)
  ///
  /// @param who This value must never be {@code null}.
  void invalidateDrawable(drawable_.Drawable who) =>
      jniAccessors.callMethodWithArgs(reference, _id_invalidateDrawable,
          jni.JniType.voidType, [who.reference]).check();

  static final _id_scheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "scheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;J)V");

  /// from: public void scheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what, long when)
  ///
  /// @param who This value must never be {@code null}.
  ///@param what This value must never be {@code null}.
  void scheduleDrawable(drawable_.Drawable who, jni.JniObject what, int when) =>
      jniAccessors.callMethodWithArgs(reference, _id_scheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference, when]).check();

  static final _id_unscheduleDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "unscheduleDrawable",
      "(Landroid/graphics/drawable/Drawable;Ljava/lang/Runnable;)V");

  /// from: public void unscheduleDrawable(android.graphics.drawable.Drawable who, java.lang.Runnable what)
  ///
  /// @param who This value must never be {@code null}.
  ///@param what This value must never be {@code null}.
  void unscheduleDrawable(drawable_.Drawable who, jni.JniObject what) =>
      jniAccessors.callMethodWithArgs(reference, _id_unscheduleDrawable,
          jni.JniType.voidType, [who.reference, what.reference]).check();

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// @return Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_getPadding = jniAccessors.getMethodIDOf(
      _classRef, "getPadding", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean getPadding(android.graphics.Rect padding)
  bool getPadding(rect_.Rect padding) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPadding,
      jni.JniType.booleanType,
      [padding.reference]).boolean;

  static final _id_setPadding =
      jniAccessors.getMethodIDOf(_classRef, "setPadding", "(IIII)V");

  /// from: public void setPadding(int left, int top, int right, int bottom)
  ///
  /// Sets the absolute padding.
  ///
  /// If padding in a dimension is specified as {@code -1}, the resolved
  /// padding will use the value computed according to the padding mode (see
  /// \#setPaddingMode(int)).
  ///
  /// Calling this method clears any relative padding values previously set
  /// using \#setPaddingRelative(int, int, int, int).
  ///@param left the left padding in pixels, or -1 to use computed padding
  ///@param top the top padding in pixels, or -1 to use computed padding
  ///@param right the right padding in pixels, or -1 to use computed padding
  ///@param bottom the bottom padding in pixels, or -1 to use computed
  ///               padding
  ///@attr ref android.R.styleable\#LayerDrawable_paddingLeft
  ///@attr ref android.R.styleable\#LayerDrawable_paddingTop
  ///@attr ref android.R.styleable\#LayerDrawable_paddingRight
  ///@attr ref android.R.styleable\#LayerDrawable_paddingBottom
  ///@see \#setPaddingRelative(int, int, int, int)
  void setPadding(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPadding,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_setPaddingRelative =
      jniAccessors.getMethodIDOf(_classRef, "setPaddingRelative", "(IIII)V");

  /// from: public void setPaddingRelative(int start, int top, int end, int bottom)
  ///
  /// Sets the relative padding.
  ///
  /// If padding in a dimension is specified as {@code -1}, the resolved
  /// padding will use the value computed according to the padding mode (see
  /// \#setPaddingMode(int)).
  ///
  /// Calling this method clears any absolute padding values previously set
  /// using \#setPadding(int, int, int, int).
  ///@param start the start padding in pixels, or -1 to use computed padding
  ///@param top the top padding in pixels, or -1 to use computed padding
  ///@param end the end padding in pixels, or -1 to use computed padding
  ///@param bottom the bottom padding in pixels, or -1 to use computed
  ///               padding
  ///@attr ref android.R.styleable\#LayerDrawable_paddingStart
  ///@attr ref android.R.styleable\#LayerDrawable_paddingTop
  ///@attr ref android.R.styleable\#LayerDrawable_paddingEnd
  ///@attr ref android.R.styleable\#LayerDrawable_paddingBottom
  ///@see \#setPadding(int, int, int, int)
  void setPaddingRelative(int start, int top, int end, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPaddingRelative,
          jni.JniType.voidType, [start, top, end, bottom]).check();

  static final _id_getLeftPadding =
      jniAccessors.getMethodIDOf(_classRef, "getLeftPadding", "()I");

  /// from: public int getLeftPadding()
  ///
  /// Returns the left padding in pixels.
  ///
  /// A return value of {@code -1} means there is no explicit padding set for
  /// this dimension. As a result, the value for this dimension returned by
  /// \#getPadding(Rect) will be computed from the child layers
  /// according to the padding mode (see \#getPaddingMode().
  ///@return the left padding in pixels, or -1 if not explicitly specified
  ///@see \#setPadding(int, int, int, int)
  ///@see \#getPadding(Rect)
  int getLeftPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getLeftPadding, jni.JniType.intType, []).integer;

  static final _id_getRightPadding =
      jniAccessors.getMethodIDOf(_classRef, "getRightPadding", "()I");

  /// from: public int getRightPadding()
  ///
  /// Returns the right padding in pixels.
  ///
  /// A return value of {@code -1} means there is no explicit padding set for
  /// this dimension. As a result, the value for this dimension returned by
  /// \#getPadding(Rect) will be computed from the child layers
  /// according to the padding mode (see \#getPaddingMode().
  ///@return the right padding in pixels, or -1 if not explicitly specified
  ///@see \#setPadding(int, int, int, int)
  ///@see \#getPadding(Rect)
  int getRightPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getRightPadding, jni.JniType.intType, []).integer;

  static final _id_getStartPadding =
      jniAccessors.getMethodIDOf(_classRef, "getStartPadding", "()I");

  /// from: public int getStartPadding()
  ///
  /// Returns the start padding in pixels.
  ///
  /// A return value of {@code -1} means there is no explicit padding set for
  /// this dimension. As a result, the value for this dimension returned by
  /// \#getPadding(Rect) will be computed from the child layers
  /// according to the padding mode (see \#getPaddingMode().
  ///@return the start padding in pixels, or -1 if not explicitly specified
  ///@see \#setPaddingRelative(int, int, int, int)
  ///@see \#getPadding(Rect)
  int getStartPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartPadding, jni.JniType.intType, []).integer;

  static final _id_getEndPadding =
      jniAccessors.getMethodIDOf(_classRef, "getEndPadding", "()I");

  /// from: public int getEndPadding()
  ///
  /// Returns the end padding in pixels.
  ///
  /// A return value of {@code -1} means there is no explicit padding set for
  /// this dimension. As a result, the value for this dimension returned by
  /// \#getPadding(Rect) will be computed from the child layers
  /// according to the padding mode (see \#getPaddingMode().
  ///@return the end padding in pixels, or -1 if not explicitly specified
  ///@see \#setPaddingRelative(int, int, int, int)
  ///@see \#getPadding(Rect)
  int getEndPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getEndPadding, jni.JniType.intType, []).integer;

  static final _id_getTopPadding =
      jniAccessors.getMethodIDOf(_classRef, "getTopPadding", "()I");

  /// from: public int getTopPadding()
  ///
  /// Returns the top padding in pixels.
  ///
  /// A return value of {@code -1} means there is no explicit padding set for
  /// this dimension. As a result, the value for this dimension returned by
  /// \#getPadding(Rect) will be computed from the child layers
  /// according to the padding mode (see \#getPaddingMode().
  ///@return the top padding in pixels, or -1 if not explicitly specified
  ///@see \#setPadding(int, int, int, int)
  ///@see \#setPaddingRelative(int, int, int, int)
  ///@see \#getPadding(Rect)
  int getTopPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getTopPadding, jni.JniType.intType, []).integer;

  static final _id_getBottomPadding =
      jniAccessors.getMethodIDOf(_classRef, "getBottomPadding", "()I");

  /// from: public int getBottomPadding()
  ///
  /// Returns the bottom padding in pixels.
  ///
  /// A return value of {@code -1} means there is no explicit padding set for
  /// this dimension. As a result, the value for this dimension returned by
  /// \#getPadding(Rect) will be computed from the child layers
  /// according to the padding mode (see \#getPaddingMode().
  ///@return the bottom padding in pixels, or -1 if not explicitly specified
  ///@see \#setPadding(int, int, int, int)
  ///@see \#setPaddingRelative(int, int, int, int)
  ///@see \#getPadding(Rect)
  int getBottomPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getBottomPadding, jni.JniType.intType, []).integer;

  static final _id_getOutline = jniAccessors.getMethodIDOf(
      _classRef, "getOutline", "(Landroid/graphics/Outline;)V");

  /// from: public void getOutline(android.graphics.Outline outline)
  ///
  /// Populates <code>outline</code> with the first available (non-empty) layer outline.
  ///@param outline Outline in which to place the first available layer outline
  ///
  /// This value must never be {@code null}.
  void getOutline(outline_.Outline outline) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getOutline,
      jni.JniType.voidType,
      [outline.reference]).check();

  static final _id_setHotspot =
      jniAccessors.getMethodIDOf(_classRef, "setHotspot", "(FF)V");

  /// from: public void setHotspot(float x, float y)
  void setHotspot(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_setHotspot, jni.JniType.voidType, [x, y]).check();

  static final _id_setHotspotBounds =
      jniAccessors.getMethodIDOf(_classRef, "setHotspotBounds", "(IIII)V");

  /// from: public void setHotspotBounds(int left, int top, int right, int bottom)
  void setHotspotBounds(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHotspotBounds,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_getHotspotBounds = jniAccessors.getMethodIDOf(
      _classRef, "getHotspotBounds", "(Landroid/graphics/Rect;)V");

  /// from: public void getHotspotBounds(android.graphics.Rect outRect)
  void getHotspotBounds(rect_.Rect outRect) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHotspotBounds,
      jni.JniType.voidType,
      [outRect.reference]).check();

  static final _id_setVisible =
      jniAccessors.getMethodIDOf(_classRef, "setVisible", "(ZZ)Z");

  /// from: public boolean setVisible(boolean visible, boolean restart)
  bool setVisible(bool visible, bool restart) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVisible,
          jni.JniType.booleanType, [visible, restart]).boolean;

  static final _id_setDither =
      jniAccessors.getMethodIDOf(_classRef, "setDither", "(Z)V");

  /// from: public void setDither(boolean dither)
  void setDither(bool dither) => jniAccessors.callMethodWithArgs(
      reference, _id_setDither, jni.JniType.voidType, [dither]).check();

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int alpha)
  void setAlpha(int alpha) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [alpha]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "setColorFilter", "(Landroid/graphics/ColorFilter;)V");

  /// from: public void setColorFilter(android.graphics.ColorFilter colorFilter)
  void setColorFilter(colorfilter_.ColorFilter colorFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setColorFilter,
          jni.JniType.voidType, [colorFilter.reference]).check();

  static final _id_setTintList = jniAccessors.getMethodIDOf(
      _classRef, "setTintList", "(Landroid/content/res/ColorStateList;)V");

  /// from: public void setTintList(android.content.res.ColorStateList tint)
  void setTintList(colorstatelist_.ColorStateList tint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintList,
          jni.JniType.voidType, [tint.reference]).check();

  static final _id_setTintMode = jniAccessors.getMethodIDOf(
      _classRef, "setTintMode", "(Landroid/graphics/PorterDuff\$Mode;)V");

  /// from: public void setTintMode(android.graphics.PorterDuff.Mode tintMode)
  void setTintMode(porterduff_.PorterDuff_Mode tintMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTintMode,
          jni.JniType.voidType, [tintMode.reference]).check();

  static final _id_setOpacity =
      jniAccessors.getMethodIDOf(_classRef, "setOpacity", "(I)V");

  /// from: public void setOpacity(int opacity)
  ///
  /// Sets the opacity of this drawable directly instead of collecting the
  /// states from the layers.
  ///@param opacity The opacity to use, or PixelFormat\#UNKNOWN PixelFormat.UNKNOWN for the default behavior
  ///@see PixelFormat\#UNKNOWN
  ///@see PixelFormat\#TRANSLUCENT
  ///@see PixelFormat\#TRANSPARENT
  ///@see PixelFormat\#OPAQUE
  void setOpacity(int opacity) => jniAccessors.callMethodWithArgs(
      reference, _id_setOpacity, jni.JniType.voidType, [opacity]).check();

  static final _id_getOpacity =
      jniAccessors.getMethodIDOf(_classRef, "getOpacity", "()I");

  /// from: public int getOpacity()
  int getOpacity() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpacity, jni.JniType.intType, []).integer;

  static final _id_setAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "setAutoMirrored", "(Z)V");

  /// from: public void setAutoMirrored(boolean mirrored)
  void setAutoMirrored(bool mirrored) => jniAccessors.callMethodWithArgs(
      reference, _id_setAutoMirrored, jni.JniType.voidType, [mirrored]).check();

  static final _id_isAutoMirrored =
      jniAccessors.getMethodIDOf(_classRef, "isAutoMirrored", "()Z");

  /// from: public boolean isAutoMirrored()
  bool isAutoMirrored() => jniAccessors.callMethodWithArgs(
      reference, _id_isAutoMirrored, jni.JniType.booleanType, []).boolean;

  static final _id_jumpToCurrentState =
      jniAccessors.getMethodIDOf(_classRef, "jumpToCurrentState", "()V");

  /// from: public void jumpToCurrentState()
  void jumpToCurrentState() => jniAccessors.callMethodWithArgs(
      reference, _id_jumpToCurrentState, jni.JniType.voidType, []).check();

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public boolean isStateful()
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_onStateChange =
      jniAccessors.getMethodIDOf(_classRef, "onStateChange", "([I)Z");

  /// from: protected boolean onStateChange(int[] state)
  bool onStateChange(jni.JniObject state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStateChange,
      jni.JniType.booleanType,
      [state.reference]).boolean;

  static final _id_onLevelChange =
      jniAccessors.getMethodIDOf(_classRef, "onLevelChange", "(I)Z");

  /// from: protected boolean onLevelChange(int level)
  bool onLevelChange(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onLevelChange, jni.JniType.booleanType, [level]).boolean;

  static final _id_onBoundsChange = jniAccessors.getMethodIDOf(
      _classRef, "onBoundsChange", "(Landroid/graphics/Rect;)V");

  /// from: protected void onBoundsChange(android.graphics.Rect bounds)
  void onBoundsChange(rect_.Rect bounds) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBoundsChange,
      jni.JniType.voidType,
      [bounds.reference]).check();

  static final _id_getIntrinsicWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicWidth", "()I");

  /// from: public int getIntrinsicWidth()
  int getIntrinsicWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicWidth, jni.JniType.intType, []).integer;

  static final _id_getIntrinsicHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIntrinsicHeight", "()I");

  /// from: public int getIntrinsicHeight()
  int getIntrinsicHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntrinsicHeight, jni.JniType.intType, []).integer;

  static final _id_getConstantState = jniAccessors.getMethodIDOf(
      _classRef,
      "getConstantState",
      "()Landroid/graphics/drawable/Drawable\$ConstantState;");

  /// from: public android.graphics.drawable.Drawable.ConstantState getConstantState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable_ConstantState getConstantState() =>
      drawable_.Drawable_ConstantState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConstantState, jni.JniType.objectType, []).object);

  static final _id_mutate = jniAccessors.getMethodIDOf(
      _classRef, "mutate", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable mutate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  drawable_.Drawable mutate() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_mutate, jni.JniType.objectType, []).object);

  static final _id_onLayoutDirectionChanged =
      jniAccessors.getMethodIDOf(_classRef, "onLayoutDirectionChanged", "(I)Z");

  /// from: public boolean onLayoutDirectionChanged(int layoutDirection)
  ///
  /// @param layoutDirection Value is android.view.View\#LAYOUT_DIRECTION_LTR, or android.view.View\#LAYOUT_DIRECTION_RTL
  bool onLayoutDirectionChanged(int layoutDirection) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayoutDirectionChanged,
          jni.JniType.booleanType, [layoutDirection]).boolean;
}
