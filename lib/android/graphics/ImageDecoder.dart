// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/res/Resources.dart" as resources_;

import "../content/ContentResolver.dart" as contentresolver_;

import "../net/Uri.dart" as uri_;

import "../content/res/AssetManager.dart" as assetmanager_;

import "PostProcessor.dart" as postprocessor_;

import "Rect.dart" as rect_;

import "ColorSpace.dart" as colorspace_;

import "drawable/Drawable.dart" as drawable_;

import "Bitmap.dart" as bitmap_;

import "../util/Size.dart" as size_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.ImageDecoder
///
/// A class for converting encoded images (like {@code PNG}, {@code JPEG},
///  {@code WEBP}, {@code GIF}, or {@code HEIF}) into Drawable or
///  Bitmap objects.
///
///  To use it, first create a Source Source using one of the
///  {@code createSource} overloads. For example, to decode from a File, call
///  \#createSource(File) and pass the result to \#decodeDrawable(Source)
///  or \#decodeBitmap(Source):
///
///  <pre class="prettyprint">
///  File file = new File(...);
///  ImageDecoder.Source source = ImageDecoder.createSource(file);
///  Drawable drawable = ImageDecoder.decodeDrawable(source);
///  </pre>
///
///  To change the default settings, pass the Source Source and an
///  OnHeaderDecodedListener OnHeaderDecodedListener to
///  \#decodeDrawable(Source, OnHeaderDecodedListener) or
///  \#decodeBitmap(Source, OnHeaderDecodedListener). For example, to
///  create a sampled image with half the width and height of the original image,
///  call \#setTargetSampleSize setTargetSampleSize(2) inside
///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded:
///
///  <pre class="prettyprint">
///  OnHeaderDecodedListener listener = new OnHeaderDecodedListener() {
///      public void onHeaderDecoded(ImageDecoder decoder, ImageInfo info, Source source) {
///          decoder.setTargetSampleSize(2);
///      }
///  };
///  Drawable drawable = ImageDecoder.decodeDrawable(source, listener);
///  </pre>
///
///  The ImageInfo ImageInfo contains information about the encoded image, like
///  its width and height, and the Source Source can be used to match to a particular
///  Source Source if a single OnHeaderDecodedListener OnHeaderDecodedListener
///  is used with multiple Source Source objects.
///
///  The OnHeaderDecodedListener OnHeaderDecodedListener can also be implemented
///  as a lambda:
///
///  <pre class="prettyprint">
///  Drawable drawable = ImageDecoder.decodeDrawable(source, (decoder, info, src) -&gt; {
///      decoder.setTargetSampleSize(2);
///  });
///  </pre>
///
///  If the encoded image is an animated {@code GIF} or {@code WEBP},
///  \#decodeDrawable decodeDrawable will return an AnimatedImageDrawable. To
///  start its animation, call AnimatedImageDrawable\#start AnimatedImageDrawable.start():
///
///  <pre class="prettyprint">
///  Drawable drawable = ImageDecoder.decodeDrawable(source);
///  if (drawable instanceof AnimatedImageDrawable) {
///      ((AnimatedImageDrawable) drawable).start();
///  }
///  </pre>
///
///  By default, a Bitmap created by ImageDecoder (including
///  one that is inside a Drawable) will be immutable (i.e.
///  Bitmap\#isMutable Bitmap.isMutable() returns {@code false}), and it
///  will typically have {@code Config} Bitmap.Config\#HARDWARE. Although
///  these properties can be changed with \#setMutableRequired setMutableRequired(true)
///  (which is only compatible with \#decodeBitmap(Source) and
///  \#decodeBitmap(Source, OnHeaderDecodedListener)) and \#setAllocator,
///  it is also possible to apply custom effects regardless of the mutability of
///  the final returned object by passing a PostProcessor to
///  \#setPostProcessor setPostProcessor. A PostProcessor can also be a lambda:
///
///  <pre class="prettyprint">
///  Drawable drawable = ImageDecoder.decodeDrawable(source, (decoder, info, src) -&gt; {
///      decoder.setPostProcessor((canvas) -&gt; {
///              // This will create rounded corners.
///              Path path = new Path();
///              path.setFillType(Path.FillType.INVERSE_EVEN_ODD);
///              int width = canvas.getWidth();
///              int height = canvas.getHeight();
///              path.addRoundRect(0, 0, width, height, 20, 20, Path.Direction.CW);
///              Paint paint = new Paint();
///              paint.setAntiAlias(true);
///              paint.setColor(Color.TRANSPARENT);
///              paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
///              canvas.drawPath(path, paint);
///              return PixelFormat.TRANSLUCENT;
///      });
///  });
///  </pre>
///
///  If the encoded image is incomplete or contains an error, or if an
///  Exception occurs during decoding, a DecodeException DecodeException
///  will be thrown. In some cases, the ImageDecoder may have decoded part of
///  the image. In order to display the partial image, an
///  OnPartialImageListener OnPartialImageListener must be passed to
///  \#setOnPartialImageListener setOnPartialImageListener. For example:
///
///  <pre class="prettyprint">
///  Drawable drawable = ImageDecoder.decodeDrawable(source, (decoder, info, src) -&gt; {
///      decoder.setOnPartialImageListener((DecodeException e) -&gt; {
///              // Returning true indicates to create a Drawable or Bitmap even
///              // if the whole image could not be decoded. Any remaining lines
///              // will be blank.
///              return true;
///      });
///  });
///  </pre>
class ImageDecoder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ImageDecoder");
  ImageDecoder.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ALLOCATOR_DEFAULT
  ///
  /// Use the default allocation for the pixel memory.
  ///
  ///  Will typically result in a Bitmap.Config\#HARDWARE
  ///  allocation, but may be software for small images. In addition, this will
  ///  switch to software when HARDWARE is incompatible, e.g.
  ///  \#setMutableRequired setMutableRequired(true) or
  ///  \#setDecodeAsAlphaMaskEnabled setDecodeAsAlphaMaskEnabled(true).
  static const ALLOCATOR_DEFAULT = 0;

  /// from: static public final int ALLOCATOR_HARDWARE
  ///
  /// Require a Bitmap.Config\#HARDWARE Bitmap.
  ///
  ///  When this is combined with incompatible options, like
  ///  \#setMutableRequired setMutableRequired(true) or
  ///  \#setDecodeAsAlphaMaskEnabled setDecodeAsAlphaMaskEnabled(true),
  ///  \#decodeDrawable decodeDrawable or \#decodeBitmap decodeBitmap
  ///  will throw an java.lang.IllegalStateException.
  static const ALLOCATOR_HARDWARE = 3;

  /// from: static public final int ALLOCATOR_SHARED_MEMORY
  ///
  /// Use shared memory for the pixel memory.
  ///
  ///  Useful for sharing across processes.
  static const ALLOCATOR_SHARED_MEMORY = 2;

  /// from: static public final int ALLOCATOR_SOFTWARE
  ///
  /// Use a software allocation for the pixel memory.
  ///
  ///  Useful for drawing to a software Canvas or for
  ///  accessing the pixels on the final output.
  static const ALLOCATOR_SOFTWARE = 1;

  /// from: static public final int MEMORY_POLICY_DEFAULT
  ///
  /// Use the most natural Bitmap.Config for the internal Bitmap.
  ///
  /// This is the recommended default for most applications and usages. This
  /// will use the closest Bitmap.Config for the encoded source. If the
  /// encoded source does not exactly match any Bitmap.Config, the next
  /// highest quality Bitmap.Config will be used avoiding any loss in
  /// image quality.
  static const MEMORY_POLICY_DEFAULT = 1;

  /// from: static public final int MEMORY_POLICY_LOW_RAM
  ///
  /// Save memory if possible by using a denser Bitmap.Config at the
  /// cost of some image quality.
  ///
  /// For example an opaque 8-bit image may be compressed into an
  /// Bitmap.Config\#RGB_565 configuration, sacrificing image
  /// quality to save memory.
  static const MEMORY_POLICY_LOW_RAM = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(JIIZZ)V");

  /// from: void <init>(long nativePtr, int width, int height, boolean animated, boolean isNinePatch)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Private constructor called by JNI. \#close must be
  /// called after decoding to delete native resources.
  ImageDecoder(
      int nativePtr, int width, int height, bool animated, bool isNinePatch)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [nativePtr, width, height, animated, isNinePatch]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_createSource = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createSource",
      "(Landroid/content/res/Resources;I)Landroid/graphics/ImageDecoder\$Source;");

  /// from: static public android.graphics.ImageDecoder.Source createSource(android.content.res.Resources res, int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Source Source from a resource.
  ///
  /// This method is safe to call from any thread.
  ///@param res the Resources object containing the image data.
  /// This value must never be {@code null}.
  ///@param resId resource ID of the image data.
  ///@return a new Source object, which can be passed to
  ///      \#decodeDrawable decodeDrawable or
  ///      \#decodeBitmap decodeBitmap.
  ///
  /// This value will never be {@code null}.
  static ImageDecoder_Source createSource(
          resources_.Resources res, int resId) =>
      ImageDecoder_Source.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createSource,
          jni.JniType.objectType,
          [res.reference, resId]).object);

  static final _id_createSource1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createSource",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/graphics/ImageDecoder\$Source;");

  /// from: static public android.graphics.ImageDecoder.Source createSource(android.content.ContentResolver cr, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Source Source from a android.net.Uri.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (ContentResolver\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// This method is safe to call from any thread.
  ///@param cr to retrieve from.
  /// This value must never be {@code null}.
  ///@param uri of the image file.
  /// This value must never be {@code null}.
  ///@return a new Source object, which can be passed to
  ///      \#decodeDrawable decodeDrawable or
  ///      \#decodeBitmap decodeBitmap.
  ///
  /// This value will never be {@code null}.
  static ImageDecoder_Source createSource1(
          contentresolver_.ContentResolver cr, uri_.Uri uri) =>
      ImageDecoder_Source.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createSource1,
          jni.JniType.objectType,
          [cr.reference, uri.reference]).object);

  static final _id_createSource2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createSource",
      "(Landroid/content/res/AssetManager;Ljava/lang/String;)Landroid/graphics/ImageDecoder\$Source;");

  /// from: static public android.graphics.ImageDecoder.Source createSource(android.content.res.AssetManager assets, java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Source Source from a file in the "assets" directory.
  ///
  /// This method is safe to call from any thread.
  ///@param assets This value must never be {@code null}.
  ///@param fileName This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  static ImageDecoder_Source createSource2(
          assetmanager_.AssetManager assets, jni.JniString fileName) =>
      ImageDecoder_Source.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createSource2,
          jni.JniType.objectType,
          [assets.reference, fileName.reference]).object);

  static final _id_createSource3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createSource",
      "(Ljava/nio/ByteBuffer;)Landroid/graphics/ImageDecoder\$Source;");

  /// from: static public android.graphics.ImageDecoder.Source createSource(java.nio.ByteBuffer buffer)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Source Source from a java.nio.ByteBuffer.
  ///
  /// Decoding will start from java.nio.ByteBuffer\#position() buffer.position().
  /// The position of {@code buffer} will not be affected.
  ///
  ///
  /// Note: If this {@code Source} is passed to \#decodeDrawable decodeDrawable,
  /// and the encoded image is animated, the returned AnimatedImageDrawable
  /// will continue reading from the {@code buffer}, so its contents must not
  /// be modified, even after the {@code AnimatedImageDrawable} is returned.
  /// {@code buffer}'s contents should never be modified during decode.
  ///
  ///
  /// This method is safe to call from any thread.
  ///@param buffer This value must never be {@code null}.
  ///@return a new Source object, which can be passed to
  ///      \#decodeDrawable decodeDrawable or
  ///      \#decodeBitmap decodeBitmap.
  ///
  /// This value will never be {@code null}.
  static ImageDecoder_Source createSource3(jni.JniObject buffer) =>
      ImageDecoder_Source.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createSource3,
          jni.JniType.objectType,
          [buffer.reference]).object);

  static final _id_createSource4 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createSource",
      "(Ljava/io/File;)Landroid/graphics/ImageDecoder\$Source;");

  /// from: static public android.graphics.ImageDecoder.Source createSource(java.io.File file)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Source Source from a java.io.File.
  ///
  /// This method is safe to call from any thread.
  ///@param file This value must never be {@code null}.
  ///@return a new Source object, which can be passed to
  ///      \#decodeDrawable decodeDrawable or
  ///      \#decodeBitmap decodeBitmap.
  ///
  /// This value will never be {@code null}.
  static ImageDecoder_Source createSource4(jni.JniObject file) =>
      ImageDecoder_Source.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createSource4,
          jni.JniType.objectType,
          [file.reference]).object);

  static final _id_setTargetSize =
      jniAccessors.getMethodIDOf(_classRef, "setTargetSize", "(II)V");

  /// from: public void setTargetSize(int width, int height)
  ///
  /// Specify the size of the output Drawable or Bitmap.
  ///
  ///  By default, the output size will match the size of the encoded
  ///  image, which can be retrieved from the ImageInfo ImageInfo in
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///
  ///  This will sample or scale the output to an arbitrary size that may
  ///  be smaller or larger than the encoded size.
  ///
  ///
  ///  Only the last call to this or \#setTargetSampleSize is
  ///  respected.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///@param width width in pixels of the output, must be greater than 0
  ///
  /// Value is 1 or greater
  ///@param height height in pixels of the output, must be greater than 0
  ///
  /// Value is 1 or greater
  void setTargetSize(int width, int height) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTargetSize,
      jni.JniType.voidType,
      [width, height]).check();

  static final _id_setTargetSampleSize =
      jniAccessors.getMethodIDOf(_classRef, "setTargetSampleSize", "(I)V");

  /// from: public void setTargetSampleSize(int sampleSize)
  ///
  /// Set the target size with a sampleSize.
  ///
  ///  By default, the output size will match the size of the encoded
  ///  image, which can be retrieved from the ImageInfo ImageInfo in
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///
  ///  Requests the decoder to subsample the original image, returning a
  ///  smaller image to save memory. The {@code sampleSize} is the number of pixels
  ///  in either dimension that correspond to a single pixel in the output.
  ///  For example, {@code sampleSize == 4} returns an image that is 1/4 the
  ///  width/height of the original, and 1/16 the number of pixels.
  ///
  ///
  ///  Must be greater than or equal to 1.
  ///
  ///
  ///  This has the same effect as calling \#setTargetSize with
  ///  dimensions based on the {@code sampleSize}. Unlike dividing the original
  ///  width and height by the {@code sampleSize} manually, calling this method
  ///  allows {@code ImageDecoder} to round in the direction that it can do most
  ///  efficiently.
  ///
  ///
  ///  Only the last call to this or \#setTargetSize is respected.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///@param sampleSize sampling rate of the encoded image.
  ///
  /// Value is 1 or greater
  void setTargetSampleSize(int sampleSize) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTargetSampleSize,
      jni.JniType.voidType,
      [sampleSize]).check();

  static final _id_setAllocator =
      jniAccessors.getMethodIDOf(_classRef, "setAllocator", "(I)V");

  /// from: public void setAllocator(int allocator)
  ///
  /// Choose the backing for the pixel memory.
  ///
  ///  This is ignored for animated drawables.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///@param allocator Type of allocator to use.
  ///
  /// Value is android.graphics.ImageDecoder\#ALLOCATOR_DEFAULT, android.graphics.ImageDecoder\#ALLOCATOR_SOFTWARE, android.graphics.ImageDecoder\#ALLOCATOR_SHARED_MEMORY, or android.graphics.ImageDecoder\#ALLOCATOR_HARDWARE
  void setAllocator(int allocator) => jniAccessors.callMethodWithArgs(
      reference, _id_setAllocator, jni.JniType.voidType, [allocator]).check();

  static final _id_getAllocator =
      jniAccessors.getMethodIDOf(_classRef, "getAllocator", "()I");

  /// from: public int getAllocator()
  ///
  /// Return the allocator for the pixel memory.
  ///@return Value is android.graphics.ImageDecoder\#ALLOCATOR_DEFAULT, android.graphics.ImageDecoder\#ALLOCATOR_SOFTWARE, android.graphics.ImageDecoder\#ALLOCATOR_SHARED_MEMORY, or android.graphics.ImageDecoder\#ALLOCATOR_HARDWARE
  int getAllocator() => jniAccessors.callMethodWithArgs(
      reference, _id_getAllocator, jni.JniType.intType, []).integer;

  static final _id_setUnpremultipliedRequired = jniAccessors.getMethodIDOf(
      _classRef, "setUnpremultipliedRequired", "(Z)V");

  /// from: public void setUnpremultipliedRequired(boolean unpremultipliedRequired)
  ///
  /// Specify whether the Bitmap should have unpremultiplied pixels.
  ///
  ///  By default, ImageDecoder will create a Bitmap with
  ///  premultiplied pixels, which is required for drawing with the
  ///  android.view.View system (i.e. to a Canvas). Calling
  ///  this method with a value of {@code true} will result in
  ///  \#decodeBitmap returning a Bitmap with unpremultiplied
  ///  pixels. See Bitmap\#isPremultiplied Bitmap.isPremultiplied().
  ///  This is incompatible with \#decodeDrawable decodeDrawable;
  ///  attempting to decode an unpremultiplied Drawable will throw an
  ///  java.lang.IllegalStateException.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  void setUnpremultipliedRequired(bool unpremultipliedRequired) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUnpremultipliedRequired,
          jni.JniType.voidType, [unpremultipliedRequired]).check();

  static final _id_isUnpremultipliedRequired =
      jniAccessors.getMethodIDOf(_classRef, "isUnpremultipliedRequired", "()Z");

  /// from: public boolean isUnpremultipliedRequired()
  ///
  /// Return whether the Bitmap will have unpremultiplied pixels.
  bool isUnpremultipliedRequired() => jniAccessors.callMethodWithArgs(reference,
      _id_isUnpremultipliedRequired, jni.JniType.booleanType, []).boolean;

  static final _id_setPostProcessor = jniAccessors.getMethodIDOf(
      _classRef, "setPostProcessor", "(Landroid/graphics/PostProcessor;)V");

  /// from: public void setPostProcessor(android.graphics.PostProcessor postProcessor)
  ///
  /// Modify the image after decoding and scaling.
  ///
  ///  This allows adding effects prior to returning a Drawable or
  ///  Bitmap. For a {@code Drawable} or an immutable {@code Bitmap},
  ///  this is the only way to process the image after decoding.
  ///
  ///
  ///  If combined with \#setTargetSize and/or \#setCrop,
  ///  PostProcessor\#onPostProcess occurs last.
  ///
  ///
  ///  If set on a nine-patch image, the nine-patch data is ignored.
  ///
  ///
  ///  For an animated image, the drawing commands drawn on the
  ///  Canvas will be recorded immediately and then applied to each
  ///  frame.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///@param postProcessor This value may be {@code null}.
  void setPostProcessor(postprocessor_.PostProcessor postProcessor) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPostProcessor,
          jni.JniType.voidType, [postProcessor.reference]).check();

  static final _id_getPostProcessor = jniAccessors.getMethodIDOf(
      _classRef, "getPostProcessor", "()Landroid/graphics/PostProcessor;");

  /// from: public android.graphics.PostProcessor getPostProcessor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the PostProcessor currently set.
  ///@return This value may be {@code null}.
  postprocessor_.PostProcessor getPostProcessor() =>
      postprocessor_.PostProcessor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPostProcessor, jni.JniType.objectType, []).object);

  static final _id_setOnPartialImageListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnPartialImageListener",
      "(Landroid/graphics/ImageDecoder\$OnPartialImageListener;)V");

  /// from: public void setOnPartialImageListener(android.graphics.ImageDecoder.OnPartialImageListener listener)
  ///
  /// Set (replace) the OnPartialImageListener on this object.
  ///
  ///  Will be called if there is an error in the input. Without one, an
  ///  error will result in an {@code Exception} being thrown.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///@param listener This value may be {@code null}.
  void setOnPartialImageListener(
          ImageDecoder_OnPartialImageListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnPartialImageListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_getOnPartialImageListener = jniAccessors.getMethodIDOf(
      _classRef,
      "getOnPartialImageListener",
      "()Landroid/graphics/ImageDecoder\$OnPartialImageListener;");

  /// from: public android.graphics.ImageDecoder.OnPartialImageListener getOnPartialImageListener()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the OnPartialImageListener OnPartialImageListener currently set.
  ///@return This value may be {@code null}.
  ImageDecoder_OnPartialImageListener getOnPartialImageListener() =>
      ImageDecoder_OnPartialImageListener.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getOnPartialImageListener,
              jni.JniType.objectType, []).object);

  static final _id_setCrop = jniAccessors.getMethodIDOf(
      _classRef, "setCrop", "(Landroid/graphics/Rect;)V");

  /// from: public void setCrop(android.graphics.Rect subset)
  ///
  /// Crop the output to {@code subset} of the (possibly) scaled image.
  ///
  ///  {@code subset} must be contained within the size set by
  ///  \#setTargetSize or the bounds of the image if setTargetSize was
  ///  not called. Otherwise an IllegalStateException will be thrown by
  ///  \#decodeDrawable decodeDrawable/\#decodeBitmap decodeBitmap.
  ///
  ///
  ///  NOT intended as a replacement for
  ///  BitmapRegionDecoder\#decodeRegion BitmapRegionDecoder.decodeRegion().
  ///  This supports all formats, but merely crops the output.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///@param subset This value may be {@code null}.
  void setCrop(rect_.Rect subset) => jniAccessors.callMethodWithArgs(
      reference, _id_setCrop, jni.JniType.voidType, [subset.reference]).check();

  static final _id_getCrop = jniAccessors.getMethodIDOf(
      _classRef, "getCrop", "()Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect getCrop()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the cropping rectangle, if set.
  ///@return This value may be {@code null}.
  rect_.Rect getCrop() => rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getCrop, jni.JniType.objectType, []).object);

  static final _id_setMutableRequired =
      jniAccessors.getMethodIDOf(_classRef, "setMutableRequired", "(Z)V");

  /// from: public void setMutableRequired(boolean mutable)
  ///
  /// Specify whether the Bitmap should be mutable.
  ///
  ///  By default, a Bitmap created by \#decodeBitmap decodeBitmap
  ///  will be immutable i.e. Bitmap\#isMutable() Bitmap.isMutable() returns
  ///  {@code false}. This can be changed with {@code setMutableRequired(true)}.
  ///
  ///  Mutable Bitmaps are incompatible with \#ALLOCATOR_HARDWARE,
  ///  because Bitmap.Config\#HARDWARE Bitmaps cannot be mutable.
  ///  Attempting to combine them will throw an
  ///  java.lang.IllegalStateException.
  ///
  ///
  ///  Mutable Bitmaps are also incompatible with \#decodeDrawable decodeDrawable,
  ///  which would require retrieving the Bitmap from the returned Drawable in
  ///  order to modify. Attempting to decode a mutable Drawable will
  ///  throw an java.lang.IllegalStateException.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  void setMutableRequired(bool mutable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMutableRequired,
      jni.JniType.voidType,
      [mutable]).check();

  static final _id_isMutableRequired =
      jniAccessors.getMethodIDOf(_classRef, "isMutableRequired", "()Z");

  /// from: public boolean isMutableRequired()
  ///
  /// Return whether the decoded Bitmap will be mutable.
  bool isMutableRequired() => jniAccessors.callMethodWithArgs(
      reference, _id_isMutableRequired, jni.JniType.booleanType, []).boolean;

  static final _id_setMemorySizePolicy =
      jniAccessors.getMethodIDOf(_classRef, "setMemorySizePolicy", "(I)V");

  /// from: public void setMemorySizePolicy(int policy)
  ///
  /// Specify the memory policy for the decoded Bitmap.
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  ///@param policy Value is android.graphics.ImageDecoder\#MEMORY_POLICY_DEFAULT, or android.graphics.ImageDecoder\#MEMORY_POLICY_LOW_RAM
  void setMemorySizePolicy(int policy) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMemorySizePolicy,
      jni.JniType.voidType,
      [policy]).check();

  static final _id_getMemorySizePolicy =
      jniAccessors.getMethodIDOf(_classRef, "getMemorySizePolicy", "()I");

  /// from: public int getMemorySizePolicy()
  ///
  /// Retrieve the memory policy for the decoded Bitmap.
  ///@return Value is android.graphics.ImageDecoder\#MEMORY_POLICY_DEFAULT, or android.graphics.ImageDecoder\#MEMORY_POLICY_LOW_RAM
  int getMemorySizePolicy() => jniAccessors.callMethodWithArgs(
      reference, _id_getMemorySizePolicy, jni.JniType.intType, []).integer;

  static final _id_setDecodeAsAlphaMaskEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setDecodeAsAlphaMaskEnabled", "(Z)V");

  /// from: public void setDecodeAsAlphaMaskEnabled(boolean enabled)
  ///
  /// Specify whether to potentially treat the output as an alpha mask.
  ///
  ///  If this is set to {@code true} and the image is encoded in a format
  ///  with only one channel, treat that channel as alpha. Otherwise this call has
  ///  no effect.
  ///
  ///
  ///  This is incompatible with \#ALLOCATOR_HARDWARE. Trying to
  ///  combine them will result in \#decodeDrawable decodeDrawable/
  ///  \#decodeBitmap decodeBitmap throwing an
  ///  java.lang.IllegalStateException.
  ///
  ///
  ///  Like all setters on ImageDecoder, this must be called inside
  ///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  void setDecodeAsAlphaMaskEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDecodeAsAlphaMaskEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_isDecodeAsAlphaMaskEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isDecodeAsAlphaMaskEnabled", "()Z");

  /// from: public boolean isDecodeAsAlphaMaskEnabled()
  ///
  /// Return whether to treat single channel input as alpha.
  ///
  ///  This returns whether \#setDecodeAsAlphaMaskEnabled was set to
  ///  {@code true}. It may still return {@code true} even if the image has
  ///  more than one channel and therefore will not be treated as an alpha
  ///  mask.
  ///
  bool isDecodeAsAlphaMaskEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isDecodeAsAlphaMaskEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_setTargetColorSpace = jniAccessors.getMethodIDOf(
      _classRef, "setTargetColorSpace", "(Landroid/graphics/ColorSpace;)V");

  /// from: public void setTargetColorSpace(android.graphics.ColorSpace colorSpace)
  ///
  /// Specify the desired ColorSpace for the output.
  ///
  /// If non-null, the decoder will try to decode into {@code colorSpace}.
  /// If it is null, which is the default, or the request cannot be met, the
  /// decoder will pick either the color space embedded in the image or the
  /// ColorSpace best suited for the requested image configuration
  /// (for instance ColorSpace.Named\#SRGB sRGB for the
  /// Bitmap.Config\#ARGB_8888 configuration).
  ///
  ///
  /// Bitmap.Config\#RGBA_F16 always uses the
  /// ColorSpace.Named\#LINEAR_EXTENDED_SRGB scRGB color space.
  /// Bitmaps in other configurations without an embedded color space are
  /// assumed to be in the ColorSpace.Named\#SRGB sRGB color space.
  ///
  ///
  /// <p class="note">Only ColorSpace.Model\#RGB color spaces are
  /// currently supported. An <code>IllegalArgumentException</code> will
  /// be thrown by \#decodeDrawable decodeDrawable/
  /// \#decodeBitmap decodeBitmap when setting a non-RGB color space
  /// such as ColorSpace.Named\#CIE_LAB Lab.
  ///
  ///
  /// <p class="note">The specified color space's transfer function must be
  /// an ColorSpace.Rgb.TransferParameters ICC parametric curve. An
  /// <code>IllegalArgumentException</code> will be thrown by the decode methods
  /// if calling ColorSpace.Rgb\#getTransferParameters() on the
  /// specified color space returns null.
  ///
  ///
  /// Like all setters on ImageDecoder, this must be called inside
  /// OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded.
  ///
  void setTargetColorSpace(colorspace_.ColorSpace colorSpace) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTargetColorSpace,
          jni.JniType.voidType, [colorSpace.reference]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Closes this resource, relinquishing any underlying resources. This method
  /// is invoked automatically on objects managed by the try-with-resources
  /// statement.
  ///
  /// This is an implementation detail of ImageDecoder, and should
  /// never be called manually.
  ///
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_decodeDrawable = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeDrawable",
      "(Landroid/graphics/ImageDecoder\$Source;Landroid/graphics/ImageDecoder\$OnHeaderDecodedListener;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable decodeDrawable(android.graphics.ImageDecoder.Source src, android.graphics.ImageDecoder.OnHeaderDecodedListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Drawable from a {@code Source}.
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param src representing the encoded image.
  ///
  /// This value must never be {@code null}.
  ///@param listener for learning the ImageInfo ImageInfo and changing any
  ///      default settings on the {@code ImageDecoder}. This will be called on
  ///      the same thread as {@code decodeDrawable} before that method returns.
  ///      This is required in order to change any of the default settings.
  ///
  /// This value must never be {@code null}.
  ///@return Drawable for displaying the image.
  ///
  /// This value will never be {@code null}.
  ///@throws IOException if {@code src} is not found, is an unsupported
  ///      format, or cannot be decoded for any reason.
  static drawable_.Drawable decodeDrawable(ImageDecoder_Source src,
          ImageDecoder_OnHeaderDecodedListener listener) =>
      drawable_.Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeDrawable,
          jni.JniType.objectType,
          [src.reference, listener.reference]).object);

  static final _id_decodeDrawable1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeDrawable",
      "(Landroid/graphics/ImageDecoder\$Source;)Landroid/graphics/drawable/Drawable;");

  /// from: static public android.graphics.drawable.Drawable decodeDrawable(android.graphics.ImageDecoder.Source src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Drawable from a {@code Source}.
  ///
  ///  Since there is no OnHeaderDecodedListener OnHeaderDecodedListener,
  ///  the default settings will be used. In order to change any settings, call
  ///  \#decodeDrawable(Source, OnHeaderDecodedListener) instead.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param src representing the encoded image.
  ///
  /// This value must never be {@code null}.
  ///@return Drawable for displaying the image.
  ///
  /// This value will never be {@code null}.
  ///@throws IOException if {@code src} is not found, is an unsupported
  ///      format, or cannot be decoded for any reason.
  static drawable_.Drawable decodeDrawable1(ImageDecoder_Source src) =>
      drawable_.Drawable.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeDrawable1,
          jni.JniType.objectType,
          [src.reference]).object);

  static final _id_decodeBitmap = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeBitmap",
      "(Landroid/graphics/ImageDecoder\$Source;Landroid/graphics/ImageDecoder\$OnHeaderDecodedListener;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeBitmap(android.graphics.ImageDecoder.Source src, android.graphics.ImageDecoder.OnHeaderDecodedListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Bitmap from a {@code Source}.
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param src representing the encoded image.
  ///
  /// This value must never be {@code null}.
  ///@param listener for learning the ImageInfo ImageInfo and changing any
  ///      default settings on the {@code ImageDecoder}. This will be called on
  ///      the same thread as {@code decodeBitmap} before that method returns.
  ///      This is required in order to change any of the default settings.
  ///
  /// This value must never be {@code null}.
  ///@return Bitmap containing the image.
  ///
  /// This value will never be {@code null}.
  ///@throws IOException if {@code src} is not found, is an unsupported
  ///      format, or cannot be decoded for any reason.
  static bitmap_.Bitmap decodeBitmap(ImageDecoder_Source src,
          ImageDecoder_OnHeaderDecodedListener listener) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeBitmap,
          jni.JniType.objectType,
          [src.reference, listener.reference]).object);

  static final _id_decodeBitmap1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeBitmap",
      "(Landroid/graphics/ImageDecoder\$Source;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeBitmap(android.graphics.ImageDecoder.Source src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Bitmap from a {@code Source}.
  ///
  ///  Since there is no OnHeaderDecodedListener OnHeaderDecodedListener,
  ///  the default settings will be used. In order to change any settings, call
  ///  \#decodeBitmap(Source, OnHeaderDecodedListener) instead.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param src representing the encoded image.
  ///
  /// This value must never be {@code null}.
  ///@return Bitmap containing the image.
  ///
  /// This value will never be {@code null}.
  ///@throws IOException if {@code src} is not found, is an unsupported
  ///      format, or cannot be decoded for any reason.
  static bitmap_.Bitmap decodeBitmap1(ImageDecoder_Source src) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_decodeBitmap1, jni.JniType.objectType, [src.reference]).object);
}

/// from: android.graphics.ImageDecoder$Source
///
/// Source of encoded image data.
///
///  References the data that will be used to decode a Drawable
///  or Bitmap in \#decodeDrawable decodeDrawable or
///  \#decodeBitmap decodeBitmap. Constructing a {@code Source} (with
///  one of the overloads of {@code createSource}) can be done on any thread
///  because the construction simply captures values. The real work is done
///  in \#decodeDrawable decodeDrawable or \#decodeBitmap decodeBitmap.
///
///  A {@code Source} object can be reused to create multiple versions of the
///  same image. For example, to decode a full size image and its thumbnail,
///  the same {@code Source} can be used once with no
///  OnHeaderDecodedListener OnHeaderDecodedListener and once with an
///  implementation of OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded
///  that calls \#setTargetSize with smaller dimensions. One {@code Source}
///  even used simultaneously in multiple threads.
///
class ImageDecoder_Source extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ImageDecoder\$Source");
  ImageDecoder_Source.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ImageDecoder_Source()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.graphics.ImageDecoder$OnPartialImageListener
///
/// Interface for inspecting a DecodeException DecodeException
///  and potentially preventing it from being thrown.
///
///  If an instance is passed to
///  \#setOnPartialImageListener setOnPartialImageListener, a
///  DecodeException DecodeException that would otherwise have been
///  thrown can be inspected inside
///  OnPartialImageListener\#onPartialImage onPartialImage.
///  If OnPartialImageListener\#onPartialImage onPartialImage returns
///  {@code true}, a partial image will be created.
class ImageDecoder_OnPartialImageListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/graphics/ImageDecoder\$OnPartialImageListener");
  ImageDecoder_OnPartialImageListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onPartialImage = jniAccessors.getMethodIDOf(_classRef,
      "onPartialImage", "(Landroid/graphics/ImageDecoder\$DecodeException;)Z");

  /// from: public abstract boolean onPartialImage(android.graphics.ImageDecoder.DecodeException exception)
  ///
  /// Called by ImageDecoder when there is only a partial image to
  ///  display.
  ///
  ///  If decoding is interrupted after having decoded a partial image,
  ///  this method will be called. The implementation can inspect the
  ///  DecodeException DecodeException and optionally finish the
  ///  rest of the decode creation process to create a partial Drawable
  ///  or Bitmap.
  ///@param exception exception containing information about the
  ///      decode interruption.
  ///
  /// This value must never be {@code null}.
  ///@return {@code true} to create and return a Drawable or
  ///      Bitmap with partial data. {@code false} (which is the
  ///      default) to abort the decode and throw {@code e}. Any undecoded
  ///      lines in the image will be blank.
  bool onPartialImage(ImageDecoder_DecodeException exception) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPartialImage,
          jni.JniType.booleanType, [exception.reference]).boolean;
}

/// from: android.graphics.ImageDecoder$OnHeaderDecodedListener
///
/// Interface for changing the default settings of a decode.
///
///  Supply an instance to
///  \#decodeDrawable(Source, OnHeaderDecodedListener) decodeDrawable
///  or \#decodeBitmap(Source, OnHeaderDecodedListener) decodeBitmap,
///  which will call OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded
///  (in the same thread) once the size is known. The implementation of
///  OnHeaderDecodedListener\#onHeaderDecoded onHeaderDecoded can then
///  change the decode settings as desired.
class ImageDecoder_OnHeaderDecodedListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/graphics/ImageDecoder\$OnHeaderDecodedListener");
  ImageDecoder_OnHeaderDecodedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onHeaderDecoded = jniAccessors.getMethodIDOf(
      _classRef,
      "onHeaderDecoded",
      "(Landroid/graphics/ImageDecoder;Landroid/graphics/ImageDecoder\$ImageInfo;Landroid/graphics/ImageDecoder\$Source;)V");

  /// from: public abstract void onHeaderDecoded(android.graphics.ImageDecoder decoder, android.graphics.ImageDecoder.ImageInfo info, android.graphics.ImageDecoder.Source source)
  ///
  /// Called by ImageDecoder when the header has been decoded and
  ///  the image size is known.
  ///@param decoder the object performing the decode, for changing
  ///      its default settings.
  ///
  /// This value must never be {@code null}.
  ///@param info information about the encoded image.
  ///
  /// This value must never be {@code null}.
  ///@param source object that created {@code decoder}.
  ///
  /// This value must never be {@code null}.
  void onHeaderDecoded(ImageDecoder decoder, ImageDecoder_ImageInfo info,
          ImageDecoder_Source source) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onHeaderDecoded,
          jni.JniType.voidType,
          [decoder.reference, info.reference, source.reference]).check();
}

/// from: android.graphics.ImageDecoder$ImageInfo
///
/// Information about an encoded image.
class ImageDecoder_ImageInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ImageDecoder\$ImageInfo");
  ImageDecoder_ImageInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/ImageDecoder;)V");

  /// from: void <init>(android.graphics.ImageDecoder decoder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ImageDecoder_ImageInfo(ImageDecoder decoder)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [decoder.reference]).object);

  static final _id_getSize =
      jniAccessors.getMethodIDOf(_classRef, "getSize", "()Landroid/util/Size;");

  /// from: public android.util.Size getSize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Size of the image, without scaling or cropping.
  ///@return This value will never be {@code null}.
  size_.Size getSize() => size_.Size.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getSize, jni.JniType.objectType, []).object);

  static final _id_getMimeType = jniAccessors.getMethodIDOf(
      _classRef, "getMimeType", "()Ljava/lang/String;");

  /// from: public java.lang.String getMimeType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The mimeType of the image.
  ///@return This value will never be {@code null}.
  jni.JniString getMimeType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMimeType, jni.JniType.objectType, []).object);

  static final _id_isAnimated =
      jniAccessors.getMethodIDOf(_classRef, "isAnimated", "()Z");

  /// from: public boolean isAnimated()
  ///
  /// Whether the image is animated.
  ///
  /// If {@code true}, \#decodeDrawable decodeDrawable will
  /// return an AnimatedImageDrawable.
  ///
  bool isAnimated() => jniAccessors.callMethodWithArgs(
      reference, _id_isAnimated, jni.JniType.booleanType, []).boolean;

  static final _id_getColorSpace = jniAccessors.getMethodIDOf(
      _classRef, "getColorSpace", "()Landroid/graphics/ColorSpace;");

  /// from: public android.graphics.ColorSpace getColorSpace()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If known, the color space the decoded bitmap will have. Note that the
  /// output color space is not guaranteed to be the color space the bitmap
  /// is encoded with. If not known (when the config is
  /// Bitmap.Config\#ALPHA_8 for instance), or there is an error,
  /// it is set to null.
  colorspace_.ColorSpace getColorSpace() =>
      colorspace_.ColorSpace.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorSpace, jni.JniType.objectType, []).object);
}

/// from: android.graphics.ImageDecoder$DecodeException
///
/// Information about an interrupted decode.
class ImageDecoder_DecodeException extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/ImageDecoder\$DecodeException");
  ImageDecoder_DecodeException.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SOURCE_EXCEPTION
  ///
  /// An Exception was thrown reading the Source.
  static const SOURCE_EXCEPTION = 1;

  /// from: static public final int SOURCE_INCOMPLETE
  ///
  /// The encoded data was incomplete.
  static const SOURCE_INCOMPLETE = 2;

  /// from: static public final int SOURCE_MALFORMED_DATA
  ///
  /// The encoded data contained an error.
  static const SOURCE_MALFORMED_DATA = 3;

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(ILjava/lang/Throwable;Landroid/graphics/ImageDecoder\$Source;)V");

  /// from: void <init>(int error, java.lang.Throwable cause, android.graphics.ImageDecoder.Source source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ImageDecoder_DecodeException(
      int error, jni.JniObject cause, ImageDecoder_Source source)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [error, cause.reference, source.reference]).object);

  static final _id_getError =
      jniAccessors.getMethodIDOf(_classRef, "getError", "()I");

  /// from: public int getError()
  ///
  /// Retrieve the reason that decoding was interrupted.
  ///
  ///  If the error is \#SOURCE_EXCEPTION, the underlying
  ///  java.lang.Throwable can be retrieved with
  ///  java.lang.Throwable\#getCause.
  ///
  ///@return Value is android.graphics.ImageDecoder.DecodeException\#SOURCE_EXCEPTION, android.graphics.ImageDecoder.DecodeException\#SOURCE_INCOMPLETE, or android.graphics.ImageDecoder.DecodeException\#SOURCE_MALFORMED_DATA
  int getError() => jniAccessors.callMethodWithArgs(
      reference, _id_getError, jni.JniType.intType, []).integer;

  static final _id_getSource = jniAccessors.getMethodIDOf(
      _classRef, "getSource", "()Landroid/graphics/ImageDecoder\$Source;");

  /// from: public android.graphics.ImageDecoder.Source getSource()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Source Source that was interrupted.
  ///
  ///  This can be used for equality checking to find the Source which
  ///  failed to completely decode.
  ///
  ///@return This value will never be {@code null}.
  ImageDecoder_Source getSource() =>
      ImageDecoder_Source.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSource, jni.JniType.objectType, []).object);
}
