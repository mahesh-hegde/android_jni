// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Bitmap.dart" as bitmap_;

import "Rect.dart" as rect_;

import "BitmapFactory.dart" as bitmapfactory_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.BitmapRegionDecoder
///
/// BitmapRegionDecoder can be used to decode a rectangle region from an image.
/// BitmapRegionDecoder is particularly useful when an original image is large and
/// you only need parts of the image.
///
/// To create a BitmapRegionDecoder, call newInstance(...).
/// Given a BitmapRegionDecoder, users can call decodeRegion() repeatedly
/// to get a decoded Bitmap of the specified region.
class BitmapRegionDecoder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/BitmapRegionDecoder");
  BitmapRegionDecoder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(J)V");

  /// from: void <init>(long decoder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  BitmapRegionDecoder(int decoder)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [decoder]).object);

  static final _id_newInstance = jniAccessors.getStaticMethodIDOf(_classRef,
      "newInstance", "([BIIZ)Landroid/graphics/BitmapRegionDecoder;");

  /// from: static public android.graphics.BitmapRegionDecoder newInstance(byte[] data, int offset, int length, boolean isShareable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a BitmapRegionDecoder from the specified byte array.
  /// Currently only the JPEG and PNG formats are supported.
  ///@param data byte array of compressed image data.
  ///@param offset offset into data for where the decoder should begin
  ///               parsing.
  ///@param length the number of bytes, beginning at offset, to parse
  ///@param isShareable If this is true, then the BitmapRegionDecoder may keep a
  ///                    shallow reference to the input. If this is false,
  ///                    then the BitmapRegionDecoder will explicitly make a copy of the
  ///                    input data, and keep that. Even if sharing is allowed,
  ///                    the implementation may still decide to make a deep
  ///                    copy of the input data. If an image is progressively encoded,
  ///                    allowing sharing may degrade the decoding speed.
  ///@return BitmapRegionDecoder, or null if the image data could not be decoded.
  ///@throws IOException if the image format is not supported or can not be decoded.
  static BitmapRegionDecoder newInstance(
          jni.JniObject data, int offset, int length, bool isShareable) =>
      BitmapRegionDecoder.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newInstance,
          jni.JniType.objectType,
          [data.reference, offset, length, isShareable]).object);

  static final _id_newInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newInstance",
      "(Ljava/io/FileDescriptor;Z)Landroid/graphics/BitmapRegionDecoder;");

  /// from: static public android.graphics.BitmapRegionDecoder newInstance(java.io.FileDescriptor fd, boolean isShareable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a BitmapRegionDecoder from the file descriptor.
  /// The position within the descriptor will not be changed when
  /// this returns, so the descriptor can be used again as is.
  /// Currently only the JPEG and PNG formats are supported.
  ///@param fd The file descriptor containing the data to decode
  ///@param isShareable If this is true, then the BitmapRegionDecoder may keep a
  ///                    shallow reference to the input. If this is false,
  ///                    then the BitmapRegionDecoder will explicitly make a copy of the
  ///                    input data, and keep that. Even if sharing is allowed,
  ///                    the implementation may still decide to make a deep
  ///                    copy of the input data. If an image is progressively encoded,
  ///                    allowing sharing may degrade the decoding speed.
  ///@return BitmapRegionDecoder, or null if the image data could not be decoded.
  ///@throws IOException if the image format is not supported or can not be decoded.
  static BitmapRegionDecoder newInstance1(jni.JniObject fd, bool isShareable) =>
      BitmapRegionDecoder.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newInstance1,
          jni.JniType.objectType,
          [fd.reference, isShareable]).object);

  static final _id_newInstance2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newInstance",
      "(Ljava/io/InputStream;Z)Landroid/graphics/BitmapRegionDecoder;");

  /// from: static public android.graphics.BitmapRegionDecoder newInstance(java.io.InputStream is, boolean isShareable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a BitmapRegionDecoder from an input stream.
  /// The stream's position will be where ever it was after the encoded data
  /// was read.
  /// Currently only the JPEG and PNG formats are supported.
  ///@param is The input stream that holds the raw data to be decoded into a
  ///           BitmapRegionDecoder.
  ///@param isShareable If this is true, then the BitmapRegionDecoder may keep a
  ///                    shallow reference to the input. If this is false,
  ///                    then the BitmapRegionDecoder will explicitly make a copy of the
  ///                    input data, and keep that. Even if sharing is allowed,
  ///                    the implementation may still decide to make a deep
  ///                    copy of the input data. If an image is progressively encoded,
  ///                    allowing sharing may degrade the decoding speed.
  ///@return BitmapRegionDecoder, or null if the image data could not be decoded.
  ///@throws IOException if the image format is not supported or can not be decoded.
  ///
  /// <p class="note">Prior to android.os.Build.VERSION_CODES\#KITKAT,
  /// if InputStream\#markSupported is.markSupported() returns true,
  /// <code>is.mark(1024)</code> would be called. As of
  /// android.os.Build.VERSION_CODES\#KITKAT, this is no longer the case.
  ///
  static BitmapRegionDecoder newInstance2(
          jni.JniObject is0, bool isShareable) =>
      BitmapRegionDecoder.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newInstance2,
          jni.JniType.objectType,
          [is0.reference, isShareable]).object);

  static final _id_newInstance3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newInstance",
      "(Ljava/lang/String;Z)Landroid/graphics/BitmapRegionDecoder;");

  /// from: static public android.graphics.BitmapRegionDecoder newInstance(java.lang.String pathName, boolean isShareable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a BitmapRegionDecoder from a file path.
  /// Currently only the JPEG and PNG formats are supported.
  ///@param pathName complete path name for the file to be decoded.
  ///@param isShareable If this is true, then the BitmapRegionDecoder may keep a
  ///                    shallow reference to the input. If this is false,
  ///                    then the BitmapRegionDecoder will explicitly make a copy of the
  ///                    input data, and keep that. Even if sharing is allowed,
  ///                    the implementation may still decide to make a deep
  ///                    copy of the input data. If an image is progressively encoded,
  ///                    allowing sharing may degrade the decoding speed.
  ///@return BitmapRegionDecoder, or null if the image data could not be decoded.
  ///@throws IOException if the image format is not supported or can not be decoded.
  static BitmapRegionDecoder newInstance3(
          jni.JniString pathName, bool isShareable) =>
      BitmapRegionDecoder.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newInstance3,
          jni.JniType.objectType,
          [pathName.reference, isShareable]).object);

  static final _id_decodeRegion = jniAccessors.getMethodIDOf(
      _classRef,
      "decodeRegion",
      "(Landroid/graphics/Rect;Landroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap decodeRegion(android.graphics.Rect rect, android.graphics.BitmapFactory.Options options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decodes a rectangle region in the image specified by rect.
  ///@param rect The rectangle that specified the region to be decode.
  ///@param options null-ok; Options that control downsampling.
  ///             inPurgeable is not supported.
  ///@return The decoded bitmap, or null if the image data could not be
  ///         decoded.
  ///@throws IllegalArgumentException if BitmapFactory.Options\#inPreferredConfig
  ///         is android.graphics.Bitmap.Config\#HARDWARE
  ///         and BitmapFactory.Options\#inMutable is set, if the specified color space
  ///         is not ColorSpace.Model\#RGB RGB, or if the specified color space's transfer
  ///         function is not an ColorSpace.Rgb.TransferParameters ICC parametric curve
  bitmap_.Bitmap decodeRegion(
          rect_.Rect rect, bitmapfactory_.BitmapFactory_Options options) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_decodeRegion,
          jni.JniType.objectType,
          [rect.reference, options.reference]).object);

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Returns the original image's width
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Returns the original image's height
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_recycle =
      jniAccessors.getMethodIDOf(_classRef, "recycle", "()V");

  /// from: public void recycle()
  ///
  /// Frees up the memory associated with this region decoder, and mark the
  /// region decoder as "dead", meaning it will throw an exception if decodeRegion(),
  /// getWidth() or getHeight() is called.
  ///
  /// This operation cannot be reversed, so it should only be called if you are
  /// sure there are no further uses for the region decoder. This is an advanced call,
  /// and normally need not be called, since the normal GC process will free up this
  /// memory when there are no more references to this region decoder.
  void recycle() => jniAccessors.callMethodWithArgs(
      reference, _id_recycle, jni.JniType.voidType, []).check();

  static final _id_isRecycled =
      jniAccessors.getMethodIDOf(_classRef, "isRecycled", "()Z");

  /// from: public boolean isRecycled()
  ///
  /// Returns true if this region decoder has been recycled.
  /// If so, then it is an error to try use its method.
  ///@return true if the region decoder has been recycled
  bool isRecycled() => jniAccessors.callMethodWithArgs(
      reference, _id_isRecycled, jni.JniType.booleanType, []).boolean;

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
