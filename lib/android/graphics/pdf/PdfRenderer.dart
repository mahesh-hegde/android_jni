// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;

import "../Bitmap.dart" as bitmap_;

import "../Rect.dart" as rect_;

import "../Matrix.dart" as matrix_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.pdf.PdfRenderer
///
///
/// This class enables rendering a PDF document. This class is not thread safe.
///
///
///
/// If you want to render a PDF, you create a renderer and for every page you want
/// to render, you open the page, render it, and close the page. After you are done
/// with rendering, you close the renderer. After the renderer is closed it should not
/// be used anymore. Note that the pages are rendered one by one, i.e. you can have
/// only a single page opened at any given time.
///
///
///
/// A typical use of the APIs to render a PDF looks like this:
///
///
/// <pre>
/// // create a new renderer
/// PdfRenderer renderer = new PdfRenderer(getSeekableFileDescriptor());
///
/// // let us just render all pages
/// final int pageCount = renderer.getPageCount();
/// for (int i = 0; i < pageCount; i++) {
///     Page page = renderer.openPage(i);
///
///     // say we render for showing on the screen
///     page.render(mBitmap, null, null, Page.RENDER_MODE_FOR_DISPLAY);
///
///     // do stuff with the bitmap
///
///     // close the page
///     page.close();
/// }
///
/// // close the renderer
/// renderer.close();
/// </pre>
///
/// <h3>Print preview and print output</h3>
///
/// If you are using this class to rasterize a PDF for printing or show a print
/// preview, it is recommended that you respect the following contract in order
/// to provide a consistent user experience when seeing a preview and printing,
/// i.e. the user sees a preview that is the same as the printout.
///
///
/// <ul>
/// <li>
/// Respect the property whether the document would like to be scaled for printing
/// as per \#shouldScaleForPrinting().
/// </li>
/// <li>
/// When scaling a document for printing the aspect ratio should be preserved.
/// </li>
/// <li>
/// Do not inset the content with any margins from the android.print.PrintAttributes
/// as the application is responsible to render it such that the margins are respected.
/// </li>
/// <li>
/// If document page size is greater than the printed media size the content should
/// be anchored to the upper left corner of the page for left-to-right locales and
/// top right corner for right-to-left locales.
/// </li>
/// </ul>
///@see \#close()
class PdfRenderer extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/pdf/PdfRenderer");
  PdfRenderer.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/ParcelFileDescriptor;)V");

  /// from: public void <init>(android.os.ParcelFileDescriptor input)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new instance.
  ///
  /// <strong>Note:</strong> The provided file descriptor must be <strong>seekable</strong>,
  /// i.e. its data being randomly accessed, e.g. pointing to a file.
  ///
  ///
  ///
  /// <strong>Note:</strong> This class takes ownership of the passed in file descriptor
  /// and is responsible for closing it when the renderer is closed.
  ///
  ///
  ///
  /// If the file is from an untrusted source it is recommended to run the renderer in a separate,
  /// isolated process with minimal permissions to limit the impact of security exploits.
  ///
  ///
  ///@param input Seekable file descriptor to read from.
  ///
  /// This value must never be {@code null}.
  ///@throws java.io.IOException If an error occurs while reading the file.
  ///@throws java.lang.SecurityException If the file requires a password or
  ///         the security scheme is not supported.
  PdfRenderer(parcelfiledescriptor_.ParcelFileDescriptor input)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [input.reference]).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Closes this renderer. You should not use this instance
  /// after this method is called.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_getPageCount =
      jniAccessors.getMethodIDOf(_classRef, "getPageCount", "()I");

  /// from: public int getPageCount()
  ///
  /// Gets the number of pages in the document.
  ///@return The page count.
  int getPageCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getPageCount, jni.JniType.intType, []).integer;

  static final _id_shouldScaleForPrinting =
      jniAccessors.getMethodIDOf(_classRef, "shouldScaleForPrinting", "()Z");

  /// from: public boolean shouldScaleForPrinting()
  ///
  /// Gets whether the document prefers to be scaled for printing.
  /// You should take this info account if the document is rendered
  /// for printing and the target media size differs from the page
  /// size.
  ///@return If to scale the document.
  bool shouldScaleForPrinting() => jniAccessors.callMethodWithArgs(reference,
      _id_shouldScaleForPrinting, jni.JniType.booleanType, []).boolean;

  static final _id_openPage = jniAccessors.getMethodIDOf(
      _classRef, "openPage", "(I)Landroid/graphics/pdf/PdfRenderer\$Page;");

  /// from: public android.graphics.pdf.PdfRenderer.Page openPage(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a page for rendering.
  ///@param index The page index.
  ///@return A page that can be rendered.
  ///@see android.graphics.pdf.PdfRenderer.Page\#close() PdfRenderer.Page.close()
  PdfRenderer_Page openPage(int index) =>
      PdfRenderer_Page.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_openPage, jni.JniType.objectType, [index]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.graphics.pdf.PdfRenderer$Page
///
/// This class represents a PDF document page for rendering.
class PdfRenderer_Page extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/pdf/PdfRenderer\$Page");
  PdfRenderer_Page.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int RENDER_MODE_FOR_DISPLAY
  ///
  /// Mode to render the content for display on a screen.
  static const RENDER_MODE_FOR_DISPLAY = 1;

  /// from: static public final int RENDER_MODE_FOR_PRINT
  ///
  /// Mode to render the content for printing.
  static const RENDER_MODE_FOR_PRINT = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: void <init>(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  PdfRenderer_Page(int index)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [index]).object);

  static final _id_getIndex =
      jniAccessors.getMethodIDOf(_classRef, "getIndex", "()I");

  /// from: public int getIndex()
  ///
  /// Gets the page index.
  ///@return The index.
  int getIndex() => jniAccessors.callMethodWithArgs(
      reference, _id_getIndex, jni.JniType.intType, []).integer;

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Gets the page width in points (1/72").
  ///@return The width in points.
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Gets the page height in points (1/72").
  ///@return The height in points.
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_render = jniAccessors.getMethodIDOf(_classRef, "render",
      "(Landroid/graphics/Bitmap;Landroid/graphics/Rect;Landroid/graphics/Matrix;I)V");

  /// from: public void render(android.graphics.Bitmap destination, android.graphics.Rect destClip, android.graphics.Matrix transform, int renderMode)
  ///
  /// Renders a page to a bitmap.
  ///
  /// You may optionally specify a rectangular clip in the bitmap bounds. No rendering
  /// outside the clip will be performed, hence it is your responsibility to initialize
  /// the bitmap outside the clip.
  ///
  ///
  ///
  /// You may optionally specify a matrix to transform the content from page coordinates
  /// which are in points (1/72") to bitmap coordinates which are in pixels. If this
  /// matrix is not provided this method will apply a transformation that will fit the
  /// whole page to the destination clip if provided or the destination bitmap if no
  /// clip is provided.
  ///
  ///
  ///
  /// The clip and transformation are useful for implementing tile rendering where the
  /// destination bitmap contains a portion of the image, for example when zooming.
  /// Another useful application is for printing where the size of the bitmap holding
  /// the page is too large and a client can render the page in stripes.
  ///
  ///
  ///
  /// <strong>Note: </strong> The destination bitmap format must be
  /// Config\#ARGB_8888 ARGB.
  ///
  ///
  ///
  /// <strong>Note: </strong> The optional transformation matrix must be affine as per
  /// android.graphics.Matrix\#isAffine() Matrix.isAffine(). Hence, you can specify
  /// rotation, scaling, translation but not a perspective transformation.
  ///
  ///
  ///@param destination Destination bitmap to which to render.
  /// This value must never be {@code null}.
  ///@param destClip Optional clip in the bitmap bounds.
  /// This value may be {@code null}.
  ///@param transform Optional transformation to apply when rendering.
  /// This value may be {@code null}.
  ///@param renderMode The render mode.
  ///
  /// Value is android.graphics.pdf.PdfRenderer.Page\#RENDER_MODE_FOR_DISPLAY, or android.graphics.pdf.PdfRenderer.Page\#RENDER_MODE_FOR_PRINT
  ///@see \#RENDER_MODE_FOR_DISPLAY
  ///@see \#RENDER_MODE_FOR_PRINT
  void render(bitmap_.Bitmap destination, rect_.Rect destClip,
          matrix_.Matrix transform, int renderMode) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_render, jni.JniType.voidType, [
        destination.reference,
        destClip.reference,
        transform.reference,
        renderMode
      ]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Closes this page.
  ///@see android.graphics.pdf.PdfRenderer\#openPage(int)
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
