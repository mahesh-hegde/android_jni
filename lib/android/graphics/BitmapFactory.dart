// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Bitmap.dart" as bitmap_;

import "../content/res/Resources.dart" as resources_;

import "../util/TypedValue.dart" as typedvalue_;

import "Rect.dart" as rect_;

import "ColorSpace.dart" as colorspace_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.BitmapFactory
///
/// Creates Bitmap objects from various sources, including files, streams,
/// and byte-arrays.
class BitmapFactory extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/BitmapFactory");
  BitmapFactory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BitmapFactory()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_decodeFile = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeFile",
      "(Ljava/lang/String;Landroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeFile(java.lang.String pathName, android.graphics.BitmapFactory.Options opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode a file path into a bitmap. If the specified file name is null,
  /// or cannot be decoded into a bitmap, the function returns null.
  ///@param pathName complete path name for the file to be decoded.
  ///@param opts null-ok; Options that control downsampling and whether the
  ///             image should be completely decoded, or just is size returned.
  ///@return The decoded bitmap, or null if the image data could not be
  ///         decoded, or, if opts is non-null, if opts requested only the
  ///         size be returned (in opts.outWidth and opts.outHeight)
  ///@throws IllegalArgumentException if BitmapFactory.Options\#inPreferredConfig
  ///         is android.graphics.Bitmap.Config\#HARDWARE
  ///         and BitmapFactory.Options\#inMutable is set, if the specified color space
  ///         is not ColorSpace.Model\#RGB RGB, or if the specified color space's transfer
  ///         function is not an ColorSpace.Rgb.TransferParameters ICC parametric curve
  static bitmap_.Bitmap decodeFile(
          jni.JniString pathName, BitmapFactory_Options opts) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeFile,
          jni.JniType.objectType,
          [pathName.reference, opts.reference]).object);

  static final _id_decodeFile1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "decodeFile", "(Ljava/lang/String;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeFile(java.lang.String pathName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode a file path into a bitmap. If the specified file name is null,
  /// or cannot be decoded into a bitmap, the function returns null.
  ///@param pathName complete path name for the file to be decoded.
  ///@return the resulting decoded bitmap, or null if it could not be decoded.
  static bitmap_.Bitmap decodeFile1(jni.JniString pathName) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeFile1,
          jni.JniType.objectType,
          [pathName.reference]).object);

  static final _id_decodeResourceStream = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeResourceStream",
      "(Landroid/content/res/Resources;Landroid/util/TypedValue;Ljava/io/InputStream;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeResourceStream(android.content.res.Resources res, android.util.TypedValue value, java.io.InputStream is, android.graphics.Rect pad, android.graphics.BitmapFactory.Options opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode a new Bitmap from an InputStream. This InputStream was obtained from
  /// resources, which we pass to be able to scale the bitmap accordingly.
  ///@throws IllegalArgumentException if BitmapFactory.Options\#inPreferredConfig
  ///         is android.graphics.Bitmap.Config\#HARDWARE
  ///         and BitmapFactory.Options\#inMutable is set, if the specified color space
  ///         is not ColorSpace.Model\#RGB RGB, or if the specified color space's transfer
  ///         function is not an ColorSpace.Rgb.TransferParameters ICC parametric curve
  ///@param res This value may be {@code null}.
  ///@param value This value may be {@code null}.
  ///@param is This value may be {@code null}.
  ///@param pad This value may be {@code null}.
  ///@param opts This value may be {@code null}.
  ///@return This value may be {@code null}.
  static bitmap_.Bitmap decodeResourceStream(
          resources_.Resources res,
          typedvalue_.TypedValue value,
          jni.JniObject is0,
          rect_.Rect pad,
          BitmapFactory_Options opts) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_decodeResourceStream, jni.JniType.objectType, [
        res.reference,
        value.reference,
        is0.reference,
        pad.reference,
        opts.reference
      ]).object);

  static final _id_decodeResource = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeResource",
      "(Landroid/content/res/Resources;ILandroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeResource(android.content.res.Resources res, int id, android.graphics.BitmapFactory.Options opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Synonym for opening the given resource and calling
  /// \#decodeResourceStream.
  ///@param res The resources object containing the image data
  ///@param id The resource id of the image data
  ///@param opts null-ok; Options that control downsampling and whether the
  ///             image should be completely decoded, or just is size returned.
  ///@return The decoded bitmap, or null if the image data could not be
  ///         decoded, or, if opts is non-null, if opts requested only the
  ///         size be returned (in opts.outWidth and opts.outHeight)
  ///@throws IllegalArgumentException if BitmapFactory.Options\#inPreferredConfig
  ///         is android.graphics.Bitmap.Config\#HARDWARE
  ///         and BitmapFactory.Options\#inMutable is set, if the specified color space
  ///         is not ColorSpace.Model\#RGB RGB, or if the specified color space's transfer
  ///         function is not an ColorSpace.Rgb.TransferParameters ICC parametric curve
  static bitmap_.Bitmap decodeResource(
          resources_.Resources res, int id, BitmapFactory_Options opts) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeResource,
          jni.JniType.objectType,
          [res.reference, id, opts.reference]).object);

  static final _id_decodeResource1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeResource",
      "(Landroid/content/res/Resources;I)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeResource(android.content.res.Resources res, int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Synonym for \#decodeResource(Resources, int, android.graphics.BitmapFactory.Options)
  /// with null Options.
  ///@param res The resources object containing the image data
  ///@param id The resource id of the image data
  ///@return The decoded bitmap, or null if the image could not be decoded.
  static bitmap_.Bitmap decodeResource1(resources_.Resources res, int id) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeResource1,
          jni.JniType.objectType,
          [res.reference, id]).object);

  static final _id_decodeByteArray = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeByteArray",
      "([BIILandroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeByteArray(byte[] data, int offset, int length, android.graphics.BitmapFactory.Options opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode an immutable bitmap from the specified byte array.
  ///@param data byte array of compressed image data
  ///@param offset offset into imageData for where the decoder should begin
  ///               parsing.
  ///@param length the number of bytes, beginning at offset, to parse
  ///@param opts null-ok; Options that control downsampling and whether the
  ///             image should be completely decoded, or just is size returned.
  ///@return The decoded bitmap, or null if the image data could not be
  ///         decoded, or, if opts is non-null, if opts requested only the
  ///         size be returned (in opts.outWidth and opts.outHeight)
  ///@throws IllegalArgumentException if BitmapFactory.Options\#inPreferredConfig
  ///         is android.graphics.Bitmap.Config\#HARDWARE
  ///         and BitmapFactory.Options\#inMutable is set, if the specified color space
  ///         is not ColorSpace.Model\#RGB RGB, or if the specified color space's transfer
  ///         function is not an ColorSpace.Rgb.TransferParameters ICC parametric curve
  static bitmap_.Bitmap decodeByteArray(jni.JniObject data, int offset,
          int length, BitmapFactory_Options opts) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeByteArray,
          jni.JniType.objectType,
          [data.reference, offset, length, opts.reference]).object);

  static final _id_decodeByteArray1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "decodeByteArray", "([BII)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeByteArray(byte[] data, int offset, int length)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode an immutable bitmap from the specified byte array.
  ///@param data byte array of compressed image data
  ///@param offset offset into imageData for where the decoder should begin
  ///               parsing.
  ///@param length the number of bytes, beginning at offset, to parse
  ///@return The decoded bitmap, or null if the image could not be decoded.
  static bitmap_.Bitmap decodeByteArray1(
          jni.JniObject data, int offset, int length) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeByteArray1,
          jni.JniType.objectType,
          [data.reference, offset, length]).object);

  static final _id_decodeStream = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeStream",
      "(Ljava/io/InputStream;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeStream(java.io.InputStream is, android.graphics.Rect outPadding, android.graphics.BitmapFactory.Options opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode an input stream into a bitmap. If the input stream is null, or
  /// cannot be used to decode a bitmap, the function returns null.
  /// The stream's position will be where ever it was after the encoded data
  /// was read.
  ///@param is The input stream that holds the raw data to be decoded into a
  ///           bitmap.
  /// This value may be {@code null}.
  ///@param outPadding If not null, return the padding rect for the bitmap if
  ///                   it exists, otherwise set padding to [-1,-1,-1,-1]. If
  ///                   no bitmap is returned (null) then padding is
  ///                   unchanged.
  /// This value may be {@code null}.
  ///@param opts null-ok; Options that control downsampling and whether the
  ///             image should be completely decoded, or just is size returned.
  /// This value may be {@code null}.
  ///@return The decoded bitmap, or null if the image data could not be
  ///         decoded, or, if opts is non-null, if opts requested only the
  ///         size be returned (in opts.outWidth and opts.outHeight)
  ///@throws IllegalArgumentException if BitmapFactory.Options\#inPreferredConfig
  ///         is android.graphics.Bitmap.Config\#HARDWARE
  ///         and BitmapFactory.Options\#inMutable is set, if the specified color space
  ///         is not ColorSpace.Model\#RGB RGB, or if the specified color space's transfer
  ///         function is not an ColorSpace.Rgb.TransferParameters ICC parametric curve
  ///
  /// <p class="note">Prior to android.os.Build.VERSION_CODES\#KITKAT,
  /// if InputStream\#markSupported is.markSupported() returns true,
  /// <code>is.mark(1024)</code> would be called. As of
  /// android.os.Build.VERSION_CODES\#KITKAT, this is no longer the case.
  ///
  static bitmap_.Bitmap decodeStream(jni.JniObject is0, rect_.Rect outPadding,
          BitmapFactory_Options opts) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeStream,
          jni.JniType.objectType,
          [is0.reference, outPadding.reference, opts.reference]).object);

  static final _id_decodeStream1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "decodeStream", "(Ljava/io/InputStream;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeStream(java.io.InputStream is)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode an input stream into a bitmap. If the input stream is null, or
  /// cannot be used to decode a bitmap, the function returns null.
  /// The stream's position will be where ever it was after the encoded data
  /// was read.
  ///@param is The input stream that holds the raw data to be decoded into a
  ///           bitmap.
  ///@return The decoded bitmap, or null if the image data could not be decoded.
  static bitmap_.Bitmap decodeStream1(jni.JniObject is0) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_decodeStream1, jni.JniType.objectType, [is0.reference]).object);

  static final _id_decodeFileDescriptor = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeFileDescriptor",
      "(Ljava/io/FileDescriptor;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory\$Options;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fd, android.graphics.Rect outPadding, android.graphics.BitmapFactory.Options opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode a bitmap from the file descriptor. If the bitmap cannot be decoded
  /// return null. The position within the descriptor will not be changed when
  /// this returns, so the descriptor can be used again as-is.
  ///@param fd The file descriptor containing the bitmap data to decode
  ///@param outPadding If not null, return the padding rect for the bitmap if
  ///                   it exists, otherwise set padding to [-1,-1,-1,-1]. If
  ///                   no bitmap is returned (null) then padding is
  ///                   unchanged.
  ///@param opts null-ok; Options that control downsampling and whether the
  ///             image should be completely decoded, or just its size returned.
  ///@return the decoded bitmap, or null
  ///@throws IllegalArgumentException if BitmapFactory.Options\#inPreferredConfig
  ///         is android.graphics.Bitmap.Config\#HARDWARE
  ///         and BitmapFactory.Options\#inMutable is set, if the specified color space
  ///         is not ColorSpace.Model\#RGB RGB, or if the specified color space's transfer
  ///         function is not an ColorSpace.Rgb.TransferParameters ICC parametric curve
  static bitmap_.Bitmap decodeFileDescriptor(jni.JniObject fd,
          rect_.Rect outPadding, BitmapFactory_Options opts) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeFileDescriptor,
          jni.JniType.objectType,
          [fd.reference, outPadding.reference, opts.reference]).object);

  static final _id_decodeFileDescriptor1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "decodeFileDescriptor",
      "(Ljava/io/FileDescriptor;)Landroid/graphics/Bitmap;");

  /// from: static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fd)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decode a bitmap from the file descriptor. If the bitmap cannot be decoded
  /// return null. The position within the descriptor will not be changed when
  /// this returns, so the descriptor can be used again as is.
  ///@param fd The file descriptor containing the bitmap data to decode
  ///@return the decoded bitmap, or null
  static bitmap_.Bitmap decodeFileDescriptor1(jni.JniObject fd) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_decodeFileDescriptor1,
          jni.JniType.objectType,
          [fd.reference]).object);
}

/// from: android.graphics.BitmapFactory$Options
class BitmapFactory_Options extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/BitmapFactory\$Options");
  BitmapFactory_Options.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_inBitmap = jniAccessors.getFieldIDOf(
      _classRef, "inBitmap", "Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap inBitmap
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If set, decode methods that take the Options object will attempt to
  /// reuse this bitmap when loading content. If the decode operation
  /// cannot use this bitmap, the decode method will throw an
  /// java.lang.IllegalArgumentException. The
  /// current implementation necessitates that the reused bitmap be
  /// mutable, and the resulting reused bitmap will continue to remain
  /// mutable even when decoding a resource which would normally result in
  /// an immutable bitmap.
  ///
  ///
  /// You should still always use the returned Bitmap of the decode
  /// method and not assume that reusing the bitmap worked, due to the
  /// constraints outlined above and failure situations that can occur.
  /// Checking whether the return value matches the value of the inBitmap
  /// set in the Options structure will indicate if the bitmap was reused,
  /// but in all cases you should use the Bitmap returned by the decoding
  /// function to ensure that you are using the bitmap that was used as the
  /// decode destination.
  ///
  ///
  /// <h3>Usage with BitmapFactory</h3>
  ///
  /// As of android.os.Build.VERSION_CODES\#KITKAT, any
  /// mutable bitmap can be reused by BitmapFactory to decode any
  /// other bitmaps as long as the resulting Bitmap\#getByteCount() byte count of the decoded bitmap is less than or equal to the Bitmap\#getAllocationByteCount() allocated byte count of the reused
  /// bitmap. This can be because the intrinsic size is smaller, or its
  /// size post scaling (for density / sample size) is smaller.
  ///
  ///
  /// <p class="note">Prior to android.os.Build.VERSION_CODES\#KITKAT
  /// additional constraints apply: The image being decoded (whether as a
  /// resource or as a stream) must be in jpeg or png format. Only equal
  /// sized bitmaps are supported, with \#inSampleSize set to 1.
  /// Additionally, the android.graphics.Bitmap.Config configuration of the reused bitmap will override the setting of
  /// \#inPreferredConfig, if set.
  ///
  ///
  /// <h3>Usage with BitmapRegionDecoder</h3>
  ///
  /// BitmapRegionDecoder will draw its requested content into the Bitmap
  /// provided, clipping if the output content size (post scaling) is larger
  /// than the provided Bitmap. The provided Bitmap's width, height, and
  /// Bitmap.Config will not be changed.
  ///
  /// <p class="note">BitmapRegionDecoder support for \#inBitmap was
  /// introduced in android.os.Build.VERSION_CODES\#JELLY_BEAN. All
  /// formats supported by BitmapRegionDecoder support Bitmap reuse via
  /// \#inBitmap.
  ///
  ///@see Bitmap\#reconfigure(int,int, android.graphics.Bitmap.Config)
  bitmap_.Bitmap get inBitmap => bitmap_.Bitmap.fromRef(jniAccessors
      .getField(reference, _id_inBitmap, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.Bitmap inBitmap
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If set, decode methods that take the Options object will attempt to
  /// reuse this bitmap when loading content. If the decode operation
  /// cannot use this bitmap, the decode method will throw an
  /// java.lang.IllegalArgumentException. The
  /// current implementation necessitates that the reused bitmap be
  /// mutable, and the resulting reused bitmap will continue to remain
  /// mutable even when decoding a resource which would normally result in
  /// an immutable bitmap.
  ///
  ///
  /// You should still always use the returned Bitmap of the decode
  /// method and not assume that reusing the bitmap worked, due to the
  /// constraints outlined above and failure situations that can occur.
  /// Checking whether the return value matches the value of the inBitmap
  /// set in the Options structure will indicate if the bitmap was reused,
  /// but in all cases you should use the Bitmap returned by the decoding
  /// function to ensure that you are using the bitmap that was used as the
  /// decode destination.
  ///
  ///
  /// <h3>Usage with BitmapFactory</h3>
  ///
  /// As of android.os.Build.VERSION_CODES\#KITKAT, any
  /// mutable bitmap can be reused by BitmapFactory to decode any
  /// other bitmaps as long as the resulting Bitmap\#getByteCount() byte count of the decoded bitmap is less than or equal to the Bitmap\#getAllocationByteCount() allocated byte count of the reused
  /// bitmap. This can be because the intrinsic size is smaller, or its
  /// size post scaling (for density / sample size) is smaller.
  ///
  ///
  /// <p class="note">Prior to android.os.Build.VERSION_CODES\#KITKAT
  /// additional constraints apply: The image being decoded (whether as a
  /// resource or as a stream) must be in jpeg or png format. Only equal
  /// sized bitmaps are supported, with \#inSampleSize set to 1.
  /// Additionally, the android.graphics.Bitmap.Config configuration of the reused bitmap will override the setting of
  /// \#inPreferredConfig, if set.
  ///
  ///
  /// <h3>Usage with BitmapRegionDecoder</h3>
  ///
  /// BitmapRegionDecoder will draw its requested content into the Bitmap
  /// provided, clipping if the output content size (post scaling) is larger
  /// than the provided Bitmap. The provided Bitmap's width, height, and
  /// Bitmap.Config will not be changed.
  ///
  /// <p class="note">BitmapRegionDecoder support for \#inBitmap was
  /// introduced in android.os.Build.VERSION_CODES\#JELLY_BEAN. All
  /// formats supported by BitmapRegionDecoder support Bitmap reuse via
  /// \#inBitmap.
  ///
  ///@see Bitmap\#reconfigure(int,int, android.graphics.Bitmap.Config)
  set inBitmap(bitmap_.Bitmap value) =>
      jniEnv.SetObjectField(reference, _id_inBitmap, value.reference);

  static final _id_inDensity =
      jniAccessors.getFieldIDOf(_classRef, "inDensity", "I");

  /// from: public int inDensity
  ///
  /// The pixel density to use for the bitmap.  This will always result
  /// in the returned bitmap having a density set for it (see
  /// Bitmap\#setDensity(int) Bitmap.setDensity(int)).  In addition,
  /// if \#inScaled is set (which it is by default} and this
  /// density does not match \#inTargetDensity, then the bitmap
  /// will be scaled to the target density before being returned.
  ///
  /// If this is 0,
  /// BitmapFactory\#decodeResource(Resources, int),
  /// BitmapFactory\#decodeResource(Resources, int, android.graphics.BitmapFactory.Options),
  /// and BitmapFactory\#decodeResourceStream
  /// will fill in the density associated with the resource.  The other
  /// functions will leave it as-is and no density will be applied.
  ///@see \#inTargetDensity
  ///@see \#inScreenDensity
  ///@see \#inScaled
  ///@see Bitmap\#setDensity(int)
  ///@see android.util.DisplayMetrics\#densityDpi
  int get inDensity => jniAccessors
      .getField(reference, _id_inDensity, jni.JniType.intType)
      .integer;

  /// from: public int inDensity
  ///
  /// The pixel density to use for the bitmap.  This will always result
  /// in the returned bitmap having a density set for it (see
  /// Bitmap\#setDensity(int) Bitmap.setDensity(int)).  In addition,
  /// if \#inScaled is set (which it is by default} and this
  /// density does not match \#inTargetDensity, then the bitmap
  /// will be scaled to the target density before being returned.
  ///
  /// If this is 0,
  /// BitmapFactory\#decodeResource(Resources, int),
  /// BitmapFactory\#decodeResource(Resources, int, android.graphics.BitmapFactory.Options),
  /// and BitmapFactory\#decodeResourceStream
  /// will fill in the density associated with the resource.  The other
  /// functions will leave it as-is and no density will be applied.
  ///@see \#inTargetDensity
  ///@see \#inScreenDensity
  ///@see \#inScaled
  ///@see Bitmap\#setDensity(int)
  ///@see android.util.DisplayMetrics\#densityDpi
  set inDensity(int value) =>
      jniEnv.SetIntField(reference, _id_inDensity, value);

  static final _id_inDither =
      jniAccessors.getFieldIDOf(_classRef, "inDither", "Z");

  /// from: public boolean inDither
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#N, this is
  /// ignored.
  ///
  /// In android.os.Build.VERSION_CODES\#M and below, if dither is
  /// true, the decoder will attempt to dither the decoded image.
  bool get inDither => jniAccessors
      .getField(reference, _id_inDither, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean inDither
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#N, this is
  /// ignored.
  ///
  /// In android.os.Build.VERSION_CODES\#M and below, if dither is
  /// true, the decoder will attempt to dither the decoded image.
  set inDither(bool value) =>
      jniEnv.SetBooleanField(reference, _id_inDither, value ? 1 : 0);

  static final _id_inInputShareable =
      jniAccessors.getFieldIDOf(_classRef, "inInputShareable", "Z");

  /// from: public boolean inInputShareable
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this is
  /// ignored.
  ///
  /// In android.os.Build.VERSION_CODES\#KITKAT and below, this
  /// field works in conjuction with inPurgeable. If inPurgeable is false,
  /// then this field is ignored. If inPurgeable is true, then this field
  /// determines whether the bitmap can share a reference to the input
  /// data (inputstream, array, etc.) or if it must make a deep copy.
  bool get inInputShareable => jniAccessors
      .getField(reference, _id_inInputShareable, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean inInputShareable
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this is
  /// ignored.
  ///
  /// In android.os.Build.VERSION_CODES\#KITKAT and below, this
  /// field works in conjuction with inPurgeable. If inPurgeable is false,
  /// then this field is ignored. If inPurgeable is true, then this field
  /// determines whether the bitmap can share a reference to the input
  /// data (inputstream, array, etc.) or if it must make a deep copy.
  set inInputShareable(bool value) =>
      jniEnv.SetBooleanField(reference, _id_inInputShareable, value ? 1 : 0);

  static final _id_inJustDecodeBounds =
      jniAccessors.getFieldIDOf(_classRef, "inJustDecodeBounds", "Z");

  /// from: public boolean inJustDecodeBounds
  ///
  /// If set to true, the decoder will return null (no bitmap), but
  /// the <code>out...</code> fields will still be set, allowing the caller to
  /// query the bitmap without having to allocate the memory for its pixels.
  bool get inJustDecodeBounds => jniAccessors
      .getField(reference, _id_inJustDecodeBounds, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean inJustDecodeBounds
  ///
  /// If set to true, the decoder will return null (no bitmap), but
  /// the <code>out...</code> fields will still be set, allowing the caller to
  /// query the bitmap without having to allocate the memory for its pixels.
  set inJustDecodeBounds(bool value) =>
      jniEnv.SetBooleanField(reference, _id_inJustDecodeBounds, value ? 1 : 0);

  static final _id_inMutable =
      jniAccessors.getFieldIDOf(_classRef, "inMutable", "Z");

  /// from: public boolean inMutable
  ///
  /// If set, decode methods will always return a mutable Bitmap instead of
  /// an immutable one. This can be used for instance to programmatically apply
  /// effects to a Bitmap loaded through BitmapFactory.
  /// Can not be set simultaneously with inPreferredConfig =
  /// android.graphics.Bitmap.Config\#HARDWARE,
  /// because hardware bitmaps are always immutable.
  bool get inMutable => jniAccessors
      .getField(reference, _id_inMutable, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean inMutable
  ///
  /// If set, decode methods will always return a mutable Bitmap instead of
  /// an immutable one. This can be used for instance to programmatically apply
  /// effects to a Bitmap loaded through BitmapFactory.
  /// Can not be set simultaneously with inPreferredConfig =
  /// android.graphics.Bitmap.Config\#HARDWARE,
  /// because hardware bitmaps are always immutable.
  set inMutable(bool value) =>
      jniEnv.SetBooleanField(reference, _id_inMutable, value ? 1 : 0);

  static final _id_inPreferQualityOverSpeed =
      jniAccessors.getFieldIDOf(_classRef, "inPreferQualityOverSpeed", "Z");

  /// from: public boolean inPreferQualityOverSpeed
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#N, this is
  /// ignored.  The output will always be high quality.
  ///
  /// In android.os.Build.VERSION_CODES\#M and below, if
  /// inPreferQualityOverSpeed is set to true, the decoder will try to
  /// decode the reconstructed image to a higher quality even at the
  /// expense of the decoding speed. Currently the field only affects JPEG
  /// decode, in the case of which a more accurate, but slightly slower,
  /// IDCT method will be used instead.
  bool get inPreferQualityOverSpeed => jniAccessors
      .getField(
          reference, _id_inPreferQualityOverSpeed, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean inPreferQualityOverSpeed
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#N, this is
  /// ignored.  The output will always be high quality.
  ///
  /// In android.os.Build.VERSION_CODES\#M and below, if
  /// inPreferQualityOverSpeed is set to true, the decoder will try to
  /// decode the reconstructed image to a higher quality even at the
  /// expense of the decoding speed. Currently the field only affects JPEG
  /// decode, in the case of which a more accurate, but slightly slower,
  /// IDCT method will be used instead.
  set inPreferQualityOverSpeed(bool value) => jniEnv.SetBooleanField(
      reference, _id_inPreferQualityOverSpeed, value ? 1 : 0);

  static final _id_inPreferredColorSpace = jniAccessors.getFieldIDOf(
      _classRef, "inPreferredColorSpace", "Landroid/graphics/ColorSpace;");

  /// from: public android.graphics.ColorSpace inPreferredColorSpace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this is non-null, the decoder will try to decode into this
  /// color space. If it is null, or the request cannot be met,
  /// the decoder will pick either the color space embedded in the image
  /// or the color space best suited for the requested image configuration
  /// (for instance ColorSpace.Named\#SRGB sRGB for
  /// the Bitmap.Config\#ARGB_8888 configuration).
  ///
  ///
  /// Bitmap.Config\#RGBA_F16 always uses the
  /// ColorSpace.Named\#LINEAR_EXTENDED_SRGB scRGB color space).
  /// Bitmaps in other configurations without an embedded color space are
  /// assumed to be in the ColorSpace.Named\#SRGB sRGB color space.
  ///
  ///
  /// <p class="note">Only ColorSpace.Model\#RGB color spaces are
  /// currently supported. An <code>IllegalArgumentException</code> will
  /// be thrown by the decode methods when setting a non-RGB color space
  /// such as ColorSpace.Named\#CIE_LAB Lab.
  ///
  ///
  /// <p class="note">The specified color space's transfer function must be
  /// an ColorSpace.Rgb.TransferParameters ICC parametric curve. An
  /// <code>IllegalArgumentException</code> will be thrown by the decode methods
  /// if calling ColorSpace.Rgb\#getTransferParameters() on the
  /// specified color space returns null.
  ///
  ///
  /// After decode, the bitmap's color space is stored in
  /// \#outColorSpace.
  ///
  colorspace_.ColorSpace get inPreferredColorSpace =>
      colorspace_.ColorSpace.fromRef(jniAccessors
          .getField(
              reference, _id_inPreferredColorSpace, jni.JniType.objectType)
          .object);

  /// from: public android.graphics.ColorSpace inPreferredColorSpace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this is non-null, the decoder will try to decode into this
  /// color space. If it is null, or the request cannot be met,
  /// the decoder will pick either the color space embedded in the image
  /// or the color space best suited for the requested image configuration
  /// (for instance ColorSpace.Named\#SRGB sRGB for
  /// the Bitmap.Config\#ARGB_8888 configuration).
  ///
  ///
  /// Bitmap.Config\#RGBA_F16 always uses the
  /// ColorSpace.Named\#LINEAR_EXTENDED_SRGB scRGB color space).
  /// Bitmaps in other configurations without an embedded color space are
  /// assumed to be in the ColorSpace.Named\#SRGB sRGB color space.
  ///
  ///
  /// <p class="note">Only ColorSpace.Model\#RGB color spaces are
  /// currently supported. An <code>IllegalArgumentException</code> will
  /// be thrown by the decode methods when setting a non-RGB color space
  /// such as ColorSpace.Named\#CIE_LAB Lab.
  ///
  ///
  /// <p class="note">The specified color space's transfer function must be
  /// an ColorSpace.Rgb.TransferParameters ICC parametric curve. An
  /// <code>IllegalArgumentException</code> will be thrown by the decode methods
  /// if calling ColorSpace.Rgb\#getTransferParameters() on the
  /// specified color space returns null.
  ///
  ///
  /// After decode, the bitmap's color space is stored in
  /// \#outColorSpace.
  ///
  set inPreferredColorSpace(colorspace_.ColorSpace value) =>
      jniEnv.SetObjectField(
          reference, _id_inPreferredColorSpace, value.reference);

  static final _id_inPreferredConfig = jniAccessors.getFieldIDOf(
      _classRef, "inPreferredConfig", "Landroid/graphics/Bitmap\$Config;");

  /// from: public android.graphics.Bitmap.Config inPreferredConfig
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this is non-null, the decoder will try to decode into this
  /// internal configuration. If it is null, or the request cannot be met,
  /// the decoder will try to pick the best matching config based on the
  /// system's screen depth, and characteristics of the original image such
  /// as if it has per-pixel alpha (requiring a config that also does).
  ///
  /// Image are loaded with the Bitmap.Config\#ARGB_8888 config by
  /// default.
  bitmap_.Bitmap_Config get inPreferredConfig =>
      bitmap_.Bitmap_Config.fromRef(jniAccessors
          .getField(reference, _id_inPreferredConfig, jni.JniType.objectType)
          .object);

  /// from: public android.graphics.Bitmap.Config inPreferredConfig
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this is non-null, the decoder will try to decode into this
  /// internal configuration. If it is null, or the request cannot be met,
  /// the decoder will try to pick the best matching config based on the
  /// system's screen depth, and characteristics of the original image such
  /// as if it has per-pixel alpha (requiring a config that also does).
  ///
  /// Image are loaded with the Bitmap.Config\#ARGB_8888 config by
  /// default.
  set inPreferredConfig(bitmap_.Bitmap_Config value) =>
      jniEnv.SetObjectField(reference, _id_inPreferredConfig, value.reference);

  static final _id_inPremultiplied =
      jniAccessors.getFieldIDOf(_classRef, "inPremultiplied", "Z");

  /// from: public boolean inPremultiplied
  ///
  /// If true (which is the default), the resulting bitmap will have its
  /// color channels pre-multipled by the alpha channel.
  ///
  /// This should NOT be set to false for images to be directly drawn by
  /// the view system or through a Canvas. The view system and
  /// Canvas assume all drawn images are pre-multiplied to simplify
  /// draw-time blending, and will throw a RuntimeException when
  /// un-premultiplied are drawn.
  ///
  ///
  /// This is likely only useful if you want to manipulate raw encoded
  /// image data, e.g. with RenderScript or custom OpenGL.
  ///
  ///
  /// This does not affect bitmaps without an alpha channel.
  ///
  ///
  /// Setting this flag to false while setting \#inScaled to true
  /// may result in incorrect colors.
  ///
  ///@see Bitmap\#hasAlpha()
  ///@see Bitmap\#isPremultiplied()
  ///@see \#inScaled
  bool get inPremultiplied => jniAccessors
      .getField(reference, _id_inPremultiplied, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean inPremultiplied
  ///
  /// If true (which is the default), the resulting bitmap will have its
  /// color channels pre-multipled by the alpha channel.
  ///
  /// This should NOT be set to false for images to be directly drawn by
  /// the view system or through a Canvas. The view system and
  /// Canvas assume all drawn images are pre-multiplied to simplify
  /// draw-time blending, and will throw a RuntimeException when
  /// un-premultiplied are drawn.
  ///
  ///
  /// This is likely only useful if you want to manipulate raw encoded
  /// image data, e.g. with RenderScript or custom OpenGL.
  ///
  ///
  /// This does not affect bitmaps without an alpha channel.
  ///
  ///
  /// Setting this flag to false while setting \#inScaled to true
  /// may result in incorrect colors.
  ///
  ///@see Bitmap\#hasAlpha()
  ///@see Bitmap\#isPremultiplied()
  ///@see \#inScaled
  set inPremultiplied(bool value) =>
      jniEnv.SetBooleanField(reference, _id_inPremultiplied, value ? 1 : 0);

  static final _id_inPurgeable =
      jniAccessors.getFieldIDOf(_classRef, "inPurgeable", "Z");

  /// from: public boolean inPurgeable
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this is
  /// ignored.
  ///
  /// In android.os.Build.VERSION_CODES\#KITKAT and below, if this
  /// is set to true, then the resulting bitmap will allocate its
  /// pixels such that they can be purged if the system needs to reclaim
  /// memory. In that instance, when the pixels need to be accessed again
  /// (e.g. the bitmap is drawn, getPixels() is called), they will be
  /// automatically re-decoded.
  ///
  /// For the re-decode to happen, the bitmap must have access to the
  /// encoded data, either by sharing a reference to the input
  /// or by making a copy of it. This distinction is controlled by
  /// inInputShareable. If this is true, then the bitmap may keep a shallow
  /// reference to the input. If this is false, then the bitmap will
  /// explicitly make a copy of the input data, and keep that. Even if
  /// sharing is allowed, the implementation may still decide to make a
  /// deep copy of the input data.
  ///
  ///
  /// While inPurgeable can help avoid big Dalvik heap allocations (from
  /// API level 11 onward), it sacrifices performance predictability since any
  /// image that the view system tries to draw may incur a decode delay which
  /// can lead to dropped frames. Therefore, most apps should avoid using
  /// inPurgeable to allow for a fast and fluid UI. To minimize Dalvik heap
  /// allocations use the \#inBitmap flag instead.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> This flag is ignored when used
  /// with \#decodeResource(Resources, int,
  /// android.graphics.BitmapFactory.Options) or \#decodeFile(String,
  /// android.graphics.BitmapFactory.Options).
  ///
  bool get inPurgeable => jniAccessors
      .getField(reference, _id_inPurgeable, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean inPurgeable
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this is
  /// ignored.
  ///
  /// In android.os.Build.VERSION_CODES\#KITKAT and below, if this
  /// is set to true, then the resulting bitmap will allocate its
  /// pixels such that they can be purged if the system needs to reclaim
  /// memory. In that instance, when the pixels need to be accessed again
  /// (e.g. the bitmap is drawn, getPixels() is called), they will be
  /// automatically re-decoded.
  ///
  /// For the re-decode to happen, the bitmap must have access to the
  /// encoded data, either by sharing a reference to the input
  /// or by making a copy of it. This distinction is controlled by
  /// inInputShareable. If this is true, then the bitmap may keep a shallow
  /// reference to the input. If this is false, then the bitmap will
  /// explicitly make a copy of the input data, and keep that. Even if
  /// sharing is allowed, the implementation may still decide to make a
  /// deep copy of the input data.
  ///
  ///
  /// While inPurgeable can help avoid big Dalvik heap allocations (from
  /// API level 11 onward), it sacrifices performance predictability since any
  /// image that the view system tries to draw may incur a decode delay which
  /// can lead to dropped frames. Therefore, most apps should avoid using
  /// inPurgeable to allow for a fast and fluid UI. To minimize Dalvik heap
  /// allocations use the \#inBitmap flag instead.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> This flag is ignored when used
  /// with \#decodeResource(Resources, int,
  /// android.graphics.BitmapFactory.Options) or \#decodeFile(String,
  /// android.graphics.BitmapFactory.Options).
  ///
  set inPurgeable(bool value) =>
      jniEnv.SetBooleanField(reference, _id_inPurgeable, value ? 1 : 0);

  static final _id_inSampleSize =
      jniAccessors.getFieldIDOf(_classRef, "inSampleSize", "I");

  /// from: public int inSampleSize
  ///
  /// If set to a value > 1, requests the decoder to subsample the original
  /// image, returning a smaller image to save memory. The sample size is
  /// the number of pixels in either dimension that correspond to a single
  /// pixel in the decoded bitmap. For example, inSampleSize == 4 returns
  /// an image that is 1/4 the width/height of the original, and 1/16 the
  /// number of pixels. Any value <= 1 is treated the same as 1. Note: the
  /// decoder uses a final value based on powers of 2, any other value will
  /// be rounded down to the nearest power of 2.
  int get inSampleSize => jniAccessors
      .getField(reference, _id_inSampleSize, jni.JniType.intType)
      .integer;

  /// from: public int inSampleSize
  ///
  /// If set to a value > 1, requests the decoder to subsample the original
  /// image, returning a smaller image to save memory. The sample size is
  /// the number of pixels in either dimension that correspond to a single
  /// pixel in the decoded bitmap. For example, inSampleSize == 4 returns
  /// an image that is 1/4 the width/height of the original, and 1/16 the
  /// number of pixels. Any value <= 1 is treated the same as 1. Note: the
  /// decoder uses a final value based on powers of 2, any other value will
  /// be rounded down to the nearest power of 2.
  set inSampleSize(int value) =>
      jniEnv.SetIntField(reference, _id_inSampleSize, value);

  static final _id_inScaled =
      jniAccessors.getFieldIDOf(_classRef, "inScaled", "Z");

  /// from: public boolean inScaled
  ///
  /// When this flag is set, if \#inDensity and
  /// \#inTargetDensity are not 0, the
  /// bitmap will be scaled to match \#inTargetDensity when loaded,
  /// rather than relying on the graphics system scaling it each time it
  /// is drawn to a Canvas.
  ///
  /// BitmapRegionDecoder ignores this flag, and will not scale output
  /// based on density. (though \#inSampleSize is supported)
  ///
  ///
  /// This flag is turned on by default and should be turned off if you need
  /// a non-scaled version of the bitmap.  Nine-patch bitmaps ignore this
  /// flag and are always scaled.
  ///
  /// If \#inPremultiplied is set to false, and the image has alpha,
  /// setting this flag to true may result in incorrect colors.
  bool get inScaled => jniAccessors
      .getField(reference, _id_inScaled, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean inScaled
  ///
  /// When this flag is set, if \#inDensity and
  /// \#inTargetDensity are not 0, the
  /// bitmap will be scaled to match \#inTargetDensity when loaded,
  /// rather than relying on the graphics system scaling it each time it
  /// is drawn to a Canvas.
  ///
  /// BitmapRegionDecoder ignores this flag, and will not scale output
  /// based on density. (though \#inSampleSize is supported)
  ///
  ///
  /// This flag is turned on by default and should be turned off if you need
  /// a non-scaled version of the bitmap.  Nine-patch bitmaps ignore this
  /// flag and are always scaled.
  ///
  /// If \#inPremultiplied is set to false, and the image has alpha,
  /// setting this flag to true may result in incorrect colors.
  set inScaled(bool value) =>
      jniEnv.SetBooleanField(reference, _id_inScaled, value ? 1 : 0);

  static final _id_inScreenDensity =
      jniAccessors.getFieldIDOf(_classRef, "inScreenDensity", "I");

  /// from: public int inScreenDensity
  ///
  /// The pixel density of the actual screen that is being used.  This is
  /// purely for applications running in density compatibility code, where
  /// \#inTargetDensity is actually the density the application
  /// sees rather than the real screen density.
  ///
  /// By setting this, you
  /// allow the loading code to avoid scaling a bitmap that is currently
  /// in the screen density up/down to the compatibility density.  Instead,
  /// if \#inDensity is the same as \#inScreenDensity, the
  /// bitmap will be left as-is.  Anything using the resulting bitmap
  /// must also used Bitmap\#getScaledWidth(int) Bitmap.getScaledWidth and Bitmap\#getScaledHeight Bitmap.getScaledHeight to account for any different between the
  /// bitmap's density and the target's density.
  ///
  /// This is never set automatically for the caller by
  /// BitmapFactory itself.  It must be explicitly set, since the
  /// caller must deal with the resulting bitmap in a density-aware way.
  ///@see \#inDensity
  ///@see \#inTargetDensity
  ///@see \#inScaled
  ///@see android.util.DisplayMetrics\#densityDpi
  int get inScreenDensity => jniAccessors
      .getField(reference, _id_inScreenDensity, jni.JniType.intType)
      .integer;

  /// from: public int inScreenDensity
  ///
  /// The pixel density of the actual screen that is being used.  This is
  /// purely for applications running in density compatibility code, where
  /// \#inTargetDensity is actually the density the application
  /// sees rather than the real screen density.
  ///
  /// By setting this, you
  /// allow the loading code to avoid scaling a bitmap that is currently
  /// in the screen density up/down to the compatibility density.  Instead,
  /// if \#inDensity is the same as \#inScreenDensity, the
  /// bitmap will be left as-is.  Anything using the resulting bitmap
  /// must also used Bitmap\#getScaledWidth(int) Bitmap.getScaledWidth and Bitmap\#getScaledHeight Bitmap.getScaledHeight to account for any different between the
  /// bitmap's density and the target's density.
  ///
  /// This is never set automatically for the caller by
  /// BitmapFactory itself.  It must be explicitly set, since the
  /// caller must deal with the resulting bitmap in a density-aware way.
  ///@see \#inDensity
  ///@see \#inTargetDensity
  ///@see \#inScaled
  ///@see android.util.DisplayMetrics\#densityDpi
  set inScreenDensity(int value) =>
      jniEnv.SetIntField(reference, _id_inScreenDensity, value);

  static final _id_inTargetDensity =
      jniAccessors.getFieldIDOf(_classRef, "inTargetDensity", "I");

  /// from: public int inTargetDensity
  ///
  /// The pixel density of the destination this bitmap will be drawn to.
  /// This is used in conjunction with \#inDensity and
  /// \#inScaled to determine if and how to scale the bitmap before
  /// returning it.
  ///
  /// If this is 0,
  /// BitmapFactory\#decodeResource(Resources, int),
  /// BitmapFactory\#decodeResource(Resources, int, android.graphics.BitmapFactory.Options),
  /// and BitmapFactory\#decodeResourceStream
  /// will fill in the density associated the Resources object's
  /// DisplayMetrics.  The other
  /// functions will leave it as-is and no scaling for density will be
  /// performed.
  ///@see \#inDensity
  ///@see \#inScreenDensity
  ///@see \#inScaled
  ///@see android.util.DisplayMetrics\#densityDpi
  int get inTargetDensity => jniAccessors
      .getField(reference, _id_inTargetDensity, jni.JniType.intType)
      .integer;

  /// from: public int inTargetDensity
  ///
  /// The pixel density of the destination this bitmap will be drawn to.
  /// This is used in conjunction with \#inDensity and
  /// \#inScaled to determine if and how to scale the bitmap before
  /// returning it.
  ///
  /// If this is 0,
  /// BitmapFactory\#decodeResource(Resources, int),
  /// BitmapFactory\#decodeResource(Resources, int, android.graphics.BitmapFactory.Options),
  /// and BitmapFactory\#decodeResourceStream
  /// will fill in the density associated the Resources object's
  /// DisplayMetrics.  The other
  /// functions will leave it as-is and no scaling for density will be
  /// performed.
  ///@see \#inDensity
  ///@see \#inScreenDensity
  ///@see \#inScaled
  ///@see android.util.DisplayMetrics\#densityDpi
  set inTargetDensity(int value) =>
      jniEnv.SetIntField(reference, _id_inTargetDensity, value);

  static final _id_inTempStorage =
      jniAccessors.getFieldIDOf(_classRef, "inTempStorage", "[B");

  /// from: public byte[] inTempStorage
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Temp storage to use for decoding.  Suggest 16K or so.
  jni.JniObject get inTempStorage => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_inTempStorage, jni.JniType.objectType)
      .object);

  /// from: public byte[] inTempStorage
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Temp storage to use for decoding.  Suggest 16K or so.
  set inTempStorage(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_inTempStorage, value.reference);

  static final _id_mCancel =
      jniAccessors.getFieldIDOf(_classRef, "mCancel", "Z");

  /// from: public boolean mCancel
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#N, see
  /// comments on \#requestCancelDecode().
  ///
  /// Flag to indicate that cancel has been called on this object.  This
  /// is useful if there's an intermediary that wants to first decode the
  /// bounds and then decode the image.  In that case the intermediary
  /// can check, inbetween the bounds decode and the image decode, to see
  /// if the operation is canceled.
  bool get mCancel => jniAccessors
      .getField(reference, _id_mCancel, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean mCancel
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#N, see
  /// comments on \#requestCancelDecode().
  ///
  /// Flag to indicate that cancel has been called on this object.  This
  /// is useful if there's an intermediary that wants to first decode the
  /// bounds and then decode the image.  In that case the intermediary
  /// can check, inbetween the bounds decode and the image decode, to see
  /// if the operation is canceled.
  set mCancel(bool value) =>
      jniEnv.SetBooleanField(reference, _id_mCancel, value ? 1 : 0);

  static final _id_outColorSpace = jniAccessors.getFieldIDOf(
      _classRef, "outColorSpace", "Landroid/graphics/ColorSpace;");

  /// from: public android.graphics.ColorSpace outColorSpace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If known, the color space the decoded bitmap will have. Note that the
  /// output color space is not guaranteed to be the color space the bitmap
  /// is encoded with. If not known (when the config is
  /// Bitmap.Config\#ALPHA_8 for instance), or there is an error,
  /// it is set to null.
  colorspace_.ColorSpace get outColorSpace =>
      colorspace_.ColorSpace.fromRef(jniAccessors
          .getField(reference, _id_outColorSpace, jni.JniType.objectType)
          .object);

  /// from: public android.graphics.ColorSpace outColorSpace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If known, the color space the decoded bitmap will have. Note that the
  /// output color space is not guaranteed to be the color space the bitmap
  /// is encoded with. If not known (when the config is
  /// Bitmap.Config\#ALPHA_8 for instance), or there is an error,
  /// it is set to null.
  set outColorSpace(colorspace_.ColorSpace value) =>
      jniEnv.SetObjectField(reference, _id_outColorSpace, value.reference);

  static final _id_outConfig = jniAccessors.getFieldIDOf(
      _classRef, "outConfig", "Landroid/graphics/Bitmap\$Config;");

  /// from: public android.graphics.Bitmap.Config outConfig
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If known, the config the decoded bitmap will have.
  /// If not known, or there is an error, it is set to null.
  bitmap_.Bitmap_Config get outConfig =>
      bitmap_.Bitmap_Config.fromRef(jniAccessors
          .getField(reference, _id_outConfig, jni.JniType.objectType)
          .object);

  /// from: public android.graphics.Bitmap.Config outConfig
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If known, the config the decoded bitmap will have.
  /// If not known, or there is an error, it is set to null.
  set outConfig(bitmap_.Bitmap_Config value) =>
      jniEnv.SetObjectField(reference, _id_outConfig, value.reference);

  static final _id_outHeight =
      jniAccessors.getFieldIDOf(_classRef, "outHeight", "I");

  /// from: public int outHeight
  ///
  /// The resulting height of the bitmap. If \#inJustDecodeBounds is
  /// set to false, this will be height of the output bitmap after any
  /// scaling is applied. If true, it will be the height of the input image
  /// without any accounting for scaling.
  ///
  /// outHeight will be set to -1 if there is an error trying to decode.
  ///
  int get outHeight => jniAccessors
      .getField(reference, _id_outHeight, jni.JniType.intType)
      .integer;

  /// from: public int outHeight
  ///
  /// The resulting height of the bitmap. If \#inJustDecodeBounds is
  /// set to false, this will be height of the output bitmap after any
  /// scaling is applied. If true, it will be the height of the input image
  /// without any accounting for scaling.
  ///
  /// outHeight will be set to -1 if there is an error trying to decode.
  ///
  set outHeight(int value) =>
      jniEnv.SetIntField(reference, _id_outHeight, value);

  static final _id_outMimeType =
      jniAccessors.getFieldIDOf(_classRef, "outMimeType", "Ljava/lang/String;");

  /// from: public java.lang.String outMimeType
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If known, this string is set to the mimetype of the decoded image.
  /// If not known, or there is an error, it is set to null.
  jni.JniString get outMimeType => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_outMimeType, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String outMimeType
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If known, this string is set to the mimetype of the decoded image.
  /// If not known, or there is an error, it is set to null.
  set outMimeType(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_outMimeType, value.reference);

  static final _id_outWidth =
      jniAccessors.getFieldIDOf(_classRef, "outWidth", "I");

  /// from: public int outWidth
  ///
  /// The resulting width of the bitmap. If \#inJustDecodeBounds is
  /// set to false, this will be width of the output bitmap after any
  /// scaling is applied. If true, it will be the width of the input image
  /// without any accounting for scaling.
  ///
  /// outWidth will be set to -1 if there is an error trying to decode.
  ///
  int get outWidth => jniAccessors
      .getField(reference, _id_outWidth, jni.JniType.intType)
      .integer;

  /// from: public int outWidth
  ///
  /// The resulting width of the bitmap. If \#inJustDecodeBounds is
  /// set to false, this will be width of the output bitmap after any
  /// scaling is applied. If true, it will be the width of the input image
  /// without any accounting for scaling.
  ///
  /// outWidth will be set to -1 if there is an error trying to decode.
  ///
  set outWidth(int value) => jniEnv.SetIntField(reference, _id_outWidth, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a default Options object, which if left unchanged will give
  /// the same result from the decoder as if null were passed.
  BitmapFactory_Options()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_requestCancelDecode =
      jniAccessors.getMethodIDOf(_classRef, "requestCancelDecode", "()V");

  /// from: public void requestCancelDecode()
  ///
  /// @deprecated As of android.os.Build.VERSION_CODES\#N, this
  ///  will not affect the decode, though it will still set mCancel.
  ///
  ///  In android.os.Build.VERSION_CODES\#M and below, if this can
  ///  be called from another thread while this options object is inside
  ///  a decode... call. Calling this will notify the decoder that it
  ///  should cancel its operation. This is not guaranteed to cancel the
  ///  decode, but if it does, the decoder... operation will return null,
  ///  or if inJustDecodeBounds is true, will set outWidth/outHeight
  ///  to -1
  void requestCancelDecode() => jniAccessors.callMethodWithArgs(
      reference, _id_requestCancelDecode, jni.JniType.voidType, []).check();
}
