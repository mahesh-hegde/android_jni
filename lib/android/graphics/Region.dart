// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "Rect.dart" as rect_;

import "Path.dart" as path_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Region
class Region extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Region");
  Region.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.graphics.Region> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty region
  Region()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Region;)V");

  /// from: public void <init>(android.graphics.Region region)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a copy of the specified region
  Region.ctor1(Region region)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [region.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Rect;)V");

  /// from: public void <init>(android.graphics.Rect r)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a region set to the specified rectangle
  Region.ctor2(rect_.Rect r)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [r.reference]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIII)V");

  /// from: public void <init>(int left, int top, int right, int bottom)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a region set to the specified rectangle
  Region.ctor3(int left, int top, int right, int bottom)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [left, top, right, bottom]).object);

  static final _id_setEmpty =
      jniAccessors.getMethodIDOf(_classRef, "setEmpty", "()V");

  /// from: public void setEmpty()
  ///
  /// Set the region to the empty region
  void setEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_setEmpty, jni.JniType.voidType, []).check();

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(Landroid/graphics/Region;)Z");

  /// from: public boolean set(android.graphics.Region region)
  ///
  /// Set the region to the specified region.
  bool set0(Region region) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.booleanType, [region.reference]).boolean;

  static final _id_set1 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean set(android.graphics.Rect r)
  ///
  /// Set the region to the specified rectangle
  bool set1(rect_.Rect r) => jniAccessors.callMethodWithArgs(
      reference, _id_set1, jni.JniType.booleanType, [r.reference]).boolean;

  static final _id_set2 =
      jniAccessors.getMethodIDOf(_classRef, "set", "(IIII)Z");

  /// from: public boolean set(int left, int top, int right, int bottom)
  ///
  /// Set the region to the specified rectangle
  bool set2(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_set2,
          jni.JniType.booleanType, [left, top, right, bottom]).boolean;

  static final _id_setPath = jniAccessors.getMethodIDOf(_classRef, "setPath",
      "(Landroid/graphics/Path;Landroid/graphics/Region;)Z");

  /// from: public boolean setPath(android.graphics.Path path, android.graphics.Region clip)
  ///
  /// Set the region to the area described by the path and clip.
  /// Return true if the resulting region is non-empty. This produces a region
  /// that is identical to the pixels that would be drawn by the path
  /// (with no antialiasing).
  bool setPath(path_.Path path, Region clip) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPath,
      jni.JniType.booleanType,
      [path.reference, clip.reference]).boolean;

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public native boolean isEmpty()
  ///
  /// Return true if this region is empty
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniType.booleanType, []).boolean;

  static final _id_isRect =
      jniAccessors.getMethodIDOf(_classRef, "isRect", "()Z");

  /// from: public native boolean isRect()
  ///
  /// Return true if the region contains a single rectangle
  bool isRect() => jniAccessors.callMethodWithArgs(
      reference, _id_isRect, jni.JniType.booleanType, []).boolean;

  static final _id_isComplex =
      jniAccessors.getMethodIDOf(_classRef, "isComplex", "()Z");

  /// from: public native boolean isComplex()
  ///
  /// Return true if the region contains more than one rectangle
  bool isComplex() => jniAccessors.callMethodWithArgs(
      reference, _id_isComplex, jni.JniType.booleanType, []).boolean;

  static final _id_getBounds = jniAccessors.getMethodIDOf(
      _classRef, "getBounds", "()Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect getBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Rect set to the bounds of the region. If the region is
  /// empty, the Rect will be set to [0, 0, 0, 0]
  rect_.Rect getBounds() => rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getBounds, jni.JniType.objectType, []).object);

  static final _id_getBounds1 = jniAccessors.getMethodIDOf(
      _classRef, "getBounds", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean getBounds(android.graphics.Rect r)
  ///
  /// Set the Rect to the bounds of the region. If the region is empty, the
  /// Rect will be set to [0, 0, 0, 0]
  bool getBounds1(rect_.Rect r) => jniAccessors.callMethodWithArgs(reference,
      _id_getBounds1, jni.JniType.booleanType, [r.reference]).boolean;

  static final _id_getBoundaryPath = jniAccessors.getMethodIDOf(
      _classRef, "getBoundaryPath", "()Landroid/graphics/Path;");

  /// from: public android.graphics.Path getBoundaryPath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the boundary of the region as a new Path. If the region is empty,
  /// the path will also be empty.
  path_.Path getBoundaryPath() =>
      path_.Path.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBoundaryPath, jni.JniType.objectType, []).object);

  static final _id_getBoundaryPath1 = jniAccessors.getMethodIDOf(
      _classRef, "getBoundaryPath", "(Landroid/graphics/Path;)Z");

  /// from: public boolean getBoundaryPath(android.graphics.Path path)
  ///
  /// Set the path to the boundary of the region. If the region is empty, the
  /// path will also be empty.
  bool getBoundaryPath1(path_.Path path) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getBoundaryPath1,
      jni.JniType.booleanType,
      [path.reference]).boolean;

  static final _id_contains =
      jniAccessors.getMethodIDOf(_classRef, "contains", "(II)Z");

  /// from: public native boolean contains(int x, int y)
  ///
  /// Return true if the region contains the specified point
  bool contains(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_contains, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_quickContains = jniAccessors.getMethodIDOf(
      _classRef, "quickContains", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean quickContains(android.graphics.Rect r)
  ///
  /// Return true if the region is a single rectangle (not complex) and it
  /// contains the specified rectangle. Returning false is not a guarantee
  /// that the rectangle is not contained by this region, but return true is a
  /// guarantee that the rectangle is contained by this region.
  bool quickContains(rect_.Rect r) => jniAccessors.callMethodWithArgs(reference,
      _id_quickContains, jni.JniType.booleanType, [r.reference]).boolean;

  static final _id_quickContains1 =
      jniAccessors.getMethodIDOf(_classRef, "quickContains", "(IIII)Z");

  /// from: public native boolean quickContains(int left, int top, int right, int bottom)
  ///
  /// Return true if the region is a single rectangle (not complex) and it
  /// contains the specified rectangle. Returning false is not a guarantee
  /// that the rectangle is not contained by this region, but return true is a
  /// guarantee that the rectangle is contained by this region.
  bool quickContains1(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_quickContains1,
          jni.JniType.booleanType, [left, top, right, bottom]).boolean;

  static final _id_quickReject = jniAccessors.getMethodIDOf(
      _classRef, "quickReject", "(Landroid/graphics/Rect;)Z");

  /// from: public boolean quickReject(android.graphics.Rect r)
  ///
  /// Return true if the region is empty, or if the specified rectangle does
  /// not intersect the region. Returning false is not a guarantee that they
  /// intersect, but returning true is a guarantee that they do not.
  bool quickReject(rect_.Rect r) => jniAccessors.callMethodWithArgs(reference,
      _id_quickReject, jni.JniType.booleanType, [r.reference]).boolean;

  static final _id_quickReject1 =
      jniAccessors.getMethodIDOf(_classRef, "quickReject", "(IIII)Z");

  /// from: public native boolean quickReject(int left, int top, int right, int bottom)
  ///
  /// Return true if the region is empty, or if the specified rectangle does
  /// not intersect the region. Returning false is not a guarantee that they
  /// intersect, but returning true is a guarantee that they do not.
  bool quickReject1(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_quickReject1,
          jni.JniType.booleanType, [left, top, right, bottom]).boolean;

  static final _id_quickReject2 = jniAccessors.getMethodIDOf(
      _classRef, "quickReject", "(Landroid/graphics/Region;)Z");

  /// from: public native boolean quickReject(android.graphics.Region rgn)
  ///
  /// Return true if the region is empty, or if the specified region does not
  /// intersect the region. Returning false is not a guarantee that they
  /// intersect, but returning true is a guarantee that they do not.
  bool quickReject2(Region rgn) => jniAccessors.callMethodWithArgs(reference,
      _id_quickReject2, jni.JniType.booleanType, [rgn.reference]).boolean;

  static final _id_translate =
      jniAccessors.getMethodIDOf(_classRef, "translate", "(II)V");

  /// from: public void translate(int dx, int dy)
  ///
  /// Translate the region by [dx, dy]. If the region is empty, do nothing.
  void translate(int dx, int dy) => jniAccessors.callMethodWithArgs(
      reference, _id_translate, jni.JniType.voidType, [dx, dy]).check();

  static final _id_translate1 = jniAccessors.getMethodIDOf(
      _classRef, "translate", "(IILandroid/graphics/Region;)V");

  /// from: public native void translate(int dx, int dy, android.graphics.Region dst)
  ///
  /// Set the dst region to the result of translating this region by [dx, dy].
  /// If this region is empty, then dst will be set to empty.
  void translate1(int dx, int dy, Region dst) =>
      jniAccessors.callMethodWithArgs(reference, _id_translate1,
          jni.JniType.voidType, [dx, dy, dst.reference]).check();

  static final _id_union = jniAccessors.getMethodIDOf(
      _classRef, "union", "(Landroid/graphics/Rect;)Z");

  /// from: public final boolean union(android.graphics.Rect r)
  bool union(rect_.Rect r) => jniAccessors.callMethodWithArgs(
      reference, _id_union, jni.JniType.booleanType, [r.reference]).boolean;

  static final _id_op = jniAccessors.getMethodIDOf(_classRef, "op",
      "(Landroid/graphics/Rect;Landroid/graphics/Region\$Op;)Z");

  /// from: public boolean op(android.graphics.Rect r, android.graphics.Region.Op op)
  ///
  /// Perform the specified Op on this region and the specified rect. Return
  /// true if the result of the op is not empty.
  bool op(rect_.Rect r, Region_Op op) => jniAccessors.callMethodWithArgs(
      reference,
      _id_op,
      jni.JniType.booleanType,
      [r.reference, op.reference]).boolean;

  static final _id_op1 = jniAccessors.getMethodIDOf(
      _classRef, "op", "(IIIILandroid/graphics/Region\$Op;)Z");

  /// from: public boolean op(int left, int top, int right, int bottom, android.graphics.Region.Op op)
  ///
  /// Perform the specified Op on this region and the specified rect. Return
  /// true if the result of the op is not empty.
  bool op1(int left, int top, int right, int bottom, Region_Op op) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_op1,
          jni.JniType.booleanType,
          [left, top, right, bottom, op.reference]).boolean;

  static final _id_op2 = jniAccessors.getMethodIDOf(_classRef, "op",
      "(Landroid/graphics/Region;Landroid/graphics/Region\$Op;)Z");

  /// from: public boolean op(android.graphics.Region region, android.graphics.Region.Op op)
  ///
  /// Perform the specified Op on this region and the specified region. Return
  /// true if the result of the op is not empty.
  bool op2(Region region, Region_Op op) => jniAccessors.callMethodWithArgs(
      reference,
      _id_op2,
      jni.JniType.booleanType,
      [region.reference, op.reference]).boolean;

  static final _id_op3 = jniAccessors.getMethodIDOf(_classRef, "op",
      "(Landroid/graphics/Rect;Landroid/graphics/Region;Landroid/graphics/Region\$Op;)Z");

  /// from: public boolean op(android.graphics.Rect rect, android.graphics.Region region, android.graphics.Region.Op op)
  ///
  /// Set this region to the result of performing the Op on the specified rect
  /// and region. Return true if the result is not empty.
  bool op3(rect_.Rect rect, Region region, Region_Op op) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_op3,
          jni.JniType.booleanType,
          [rect.reference, region.reference, op.reference]).boolean;

  static final _id_op4 = jniAccessors.getMethodIDOf(_classRef, "op",
      "(Landroid/graphics/Region;Landroid/graphics/Region;Landroid/graphics/Region\$Op;)Z");

  /// from: public boolean op(android.graphics.Region region1, android.graphics.Region region2, android.graphics.Region.Op op)
  ///
  /// Set this region to the result of performing the Op on the specified
  /// regions. Return true if the result is not empty.
  bool op4(Region region1, Region region2, Region_Op op) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_op4,
          jni.JniType.booleanType,
          [region1.reference, region2.reference, op.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel p, int flags)
  ///
  /// Write the region and its pixels to the parcel. The region can be
  /// rebuilt from the parcel by calling CREATOR.createFromParcel().
  ///@param p Parcel object to write the region data into
  void writeToParcel(parcel_.Parcel p, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [p.reference, flags]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.graphics.Region$Op
class Region_Op extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Region\$Op");
  Region_Op.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Region\$Op;");

  /// from: static public android.graphics.Region.Op[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Region\$Op;");

  /// from: static public android.graphics.Region.Op valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Region_Op valueOf(jni.JniString name) =>
      Region_Op.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Region_Op()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
