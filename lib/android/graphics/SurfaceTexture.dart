// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Handler.dart" as handler_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.SurfaceTexture
///
/// Captures frames from an image stream as an OpenGL ES texture.
///
/// The image stream may come from either camera preview or video decode. A
/// android.view.Surface created from a SurfaceTexture can be used as an output
/// destination for the android.hardware.camera2, android.media.MediaCodec,
/// android.media.MediaPlayer, and android.renderscript.Allocation APIs.
/// When \#updateTexImage is called, the contents of the texture object specified
/// when the SurfaceTexture was created are updated to contain the most recent image from the image
/// stream.  This may cause some frames of the stream to be skipped.
///
/// A SurfaceTexture may also be used in place of a SurfaceHolder when specifying the output
/// destination of the older android.hardware.Camera API. Doing so will cause all the
/// frames from the image stream to be sent to the SurfaceTexture object rather than to the device's
/// display.
///
/// When sampling from the texture one should first transform the texture coordinates using the
/// matrix queried via \#getTransformMatrix(float[]).  The transform matrix may change each
/// time \#updateTexImage is called, so it should be re-queried each time the texture image
/// is updated.
/// This matrix transforms traditional 2D OpenGL ES texture coordinate column vectors of the form (s,
/// t, 0, 1) where s and t are on the inclusive interval [0, 1] to the proper sampling location in
/// the streamed texture.  This transform compensates for any properties of the image stream source
/// that cause it to appear different from a traditional OpenGL ES texture.  For example, sampling
/// from the bottom left corner of the image can be accomplished by transforming the column vector
/// (0, 0, 0, 1) using the queried matrix, while sampling from the top right corner of the image can
/// be done by transforming (1, 1, 0, 1).
///
/// The texture object uses the GL_TEXTURE_EXTERNAL_OES texture target, which is defined by the
/// <a href="http://www.khronos.org/registry/gles/extensions/OES/OES_EGL_image_external.txt">
/// GL_OES_EGL_image_external</a> OpenGL ES extension.  This limits how the texture may be used.
/// Each time the texture is bound it must be bound to the GL_TEXTURE_EXTERNAL_OES target rather than
/// the GL_TEXTURE_2D target.  Additionally, any OpenGL ES 2.0 shader that samples from the texture
/// must declare its use of this extension using, for example, an "\#extension
/// GL_OES_EGL_image_external : require" directive.  Such shaders must also access the texture using
/// the samplerExternalOES GLSL sampler type.
///
/// SurfaceTexture objects may be created on any thread.  \#updateTexImage may only be
/// called on the thread with the OpenGL ES context that contains the texture object.  The
/// frame-available callback is called on an arbitrary thread, so unless special care is taken \#updateTexImage should not be called directly from the callback.
class SurfaceTexture extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/SurfaceTexture");
  SurfaceTexture.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int texName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new SurfaceTexture to stream images to a given OpenGL texture.
  ///@param texName the OpenGL texture object name (e.g. generated via glGenTextures)
  ///@throws android.view.Surface.OutOfResourcesException If the SurfaceTexture cannot be created.
  SurfaceTexture(int texName)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [texName]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IZ)V");

  /// from: public void <init>(int texName, boolean singleBufferMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new SurfaceTexture to stream images to a given OpenGL texture.
  ///
  /// In single buffered mode the application is responsible for serializing access to the image
  /// content buffer. Each time the image content is to be updated, the
  /// \#releaseTexImage() method must be called before the image content producer takes
  /// ownership of the buffer. For example, when producing image content with the NDK
  /// ANativeWindow_lock and ANativeWindow_unlockAndPost functions, \#releaseTexImage()
  /// must be called before each ANativeWindow_lock, or that call will fail. When producing
  /// image content with OpenGL ES, \#releaseTexImage() must be called before the first
  /// OpenGL ES function call each frame.
  ///@param texName the OpenGL texture object name (e.g. generated via glGenTextures)
  ///@param singleBufferMode whether the SurfaceTexture will be in single buffered mode.
  ///@throws android.view.Surface.OutOfResourcesException If the SurfaceTexture cannot be created.
  SurfaceTexture.ctor1(int texName, bool singleBufferMode)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [texName, singleBufferMode]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Z)V");

  /// from: public void <init>(boolean singleBufferMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new SurfaceTexture to stream images to a given OpenGL texture.
  ///
  /// In single buffered mode the application is responsible for serializing access to the image
  /// content buffer. Each time the image content is to be updated, the
  /// \#releaseTexImage() method must be called before the image content producer takes
  /// ownership of the buffer. For example, when producing image content with the NDK
  /// ANativeWindow_lock and ANativeWindow_unlockAndPost functions, \#releaseTexImage()
  /// must be called before each ANativeWindow_lock, or that call will fail. When producing
  /// image content with OpenGL ES, \#releaseTexImage() must be called before the first
  /// OpenGL ES function call each frame.
  ///
  /// Unlike \#SurfaceTexture(int, boolean), which takes an OpenGL texture object name,
  /// this constructor creates the SurfaceTexture in detached mode. A texture name must be passed
  /// in using \#attachToGLContext before calling \#releaseTexImage() and producing
  /// image content using OpenGL ES.
  ///@param singleBufferMode whether the SurfaceTexture will be in single buffered mode.
  ///@throws android.view.Surface.OutOfResourcesException If the SurfaceTexture cannot be created.
  SurfaceTexture.ctor2(bool singleBufferMode)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [singleBufferMode]).object);

  static final _id_setOnFrameAvailableListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnFrameAvailableListener",
      "(Landroid/graphics/SurfaceTexture\$OnFrameAvailableListener;)V");

  /// from: public void setOnFrameAvailableListener(android.graphics.SurfaceTexture.OnFrameAvailableListener listener)
  ///
  /// Register a callback to be invoked when a new image frame becomes available to the
  /// SurfaceTexture.
  ///
  /// The callback may be called on an arbitrary thread, so it is not
  /// safe to call \#updateTexImage without first binding the OpenGL ES context to the
  /// thread invoking the callback.
  ///
  ///
  ///@param listener The listener to use, or null to remove the listener.
  ///
  /// This value may be {@code null}.
  void setOnFrameAvailableListener(
          SurfaceTexture_OnFrameAvailableListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnFrameAvailableListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setOnFrameAvailableListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnFrameAvailableListener",
      "(Landroid/graphics/SurfaceTexture\$OnFrameAvailableListener;Landroid/os/Handler;)V");

  /// from: public void setOnFrameAvailableListener(android.graphics.SurfaceTexture.OnFrameAvailableListener listener, android.os.Handler handler)
  ///
  /// Register a callback to be invoked when a new image frame becomes available to the
  /// SurfaceTexture.
  ///
  /// If a handler is specified, the callback will be invoked on that handler's thread.
  /// If no handler is specified, then the callback may be called on an arbitrary thread,
  /// so it is not safe to call \#updateTexImage without first binding the OpenGL ES
  /// context to the thread invoking the callback.
  ///
  ///
  ///@param listener The listener to use, or null to remove the listener.
  /// This value may be {@code null}.
  ///@param handler The handler on which the listener should be invoked, or null
  /// to use an arbitrary thread.
  ///
  /// This value may be {@code null}.
  void setOnFrameAvailableListener1(
          SurfaceTexture_OnFrameAvailableListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnFrameAvailableListener1,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_setDefaultBufferSize =
      jniAccessors.getMethodIDOf(_classRef, "setDefaultBufferSize", "(II)V");

  /// from: public void setDefaultBufferSize(int width, int height)
  ///
  /// Set the default size of the image buffers.  The image producer may override the buffer size,
  /// in which case the producer-set buffer size will be used, not the default size set by this
  /// method.  Both video and camera based image producers do override the size.  This method may
  /// be used to set the image size when producing images with android.graphics.Canvas (via
  /// android.view.Surface\#lockCanvas), or OpenGL ES (via an EGLSurface).
  ///
  /// The new default buffer size will take effect the next time the image producer requests a
  /// buffer to fill.  For android.graphics.Canvas this will be the next time android.view.Surface\#lockCanvas is called.  For OpenGL ES, the EGLSurface should be
  /// destroyed (via eglDestroySurface), made not-current (via eglMakeCurrent), and then recreated
  /// (via eglCreateWindowSurface) to ensure that the new default size has taken effect.
  ///
  /// The width and height parameters must be no greater than the minimum of
  /// GL_MAX_VIEWPORT_DIMS and GL_MAX_TEXTURE_SIZE (see
  /// javax.microedition.khronos.opengles.GL10\#glGetIntegerv glGetIntegerv).
  /// An error due to invalid dimensions might not be reported until
  /// updateTexImage() is called.
  void setDefaultBufferSize(int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDefaultBufferSize,
          jni.JniType.voidType, [width, height]).check();

  static final _id_updateTexImage =
      jniAccessors.getMethodIDOf(_classRef, "updateTexImage", "()V");

  /// from: public void updateTexImage()
  ///
  /// Update the texture image to the most recent frame from the image stream.  This may only be
  /// called while the OpenGL ES context that owns the texture is current on the calling thread.
  /// It will implicitly bind its texture to the GL_TEXTURE_EXTERNAL_OES texture target.
  void updateTexImage() => jniAccessors.callMethodWithArgs(
      reference, _id_updateTexImage, jni.JniType.voidType, []).check();

  static final _id_releaseTexImage =
      jniAccessors.getMethodIDOf(_classRef, "releaseTexImage", "()V");

  /// from: public void releaseTexImage()
  ///
  /// Releases the the texture content. This is needed in single buffered mode to allow the image
  /// content producer to take ownership of the image buffer.
  /// For more information see \#SurfaceTexture(int, boolean).
  void releaseTexImage() => jniAccessors.callMethodWithArgs(
      reference, _id_releaseTexImage, jni.JniType.voidType, []).check();

  static final _id_detachFromGLContext =
      jniAccessors.getMethodIDOf(_classRef, "detachFromGLContext", "()V");

  /// from: public void detachFromGLContext()
  ///
  /// Detach the SurfaceTexture from the OpenGL ES context that owns the OpenGL ES texture object.
  /// This call must be made with the OpenGL ES context current on the calling thread.  The OpenGL
  /// ES texture object will be deleted as a result of this call.  After calling this method all
  /// calls to \#updateTexImage will throw an java.lang.IllegalStateException until
  /// a successful call to \#attachToGLContext is made.
  ///
  /// This can be used to access the SurfaceTexture image contents from multiple OpenGL ES
  /// contexts.  Note, however, that the image contents are only accessible from one OpenGL ES
  /// context at a time.
  void detachFromGLContext() => jniAccessors.callMethodWithArgs(
      reference, _id_detachFromGLContext, jni.JniType.voidType, []).check();

  static final _id_attachToGLContext =
      jniAccessors.getMethodIDOf(_classRef, "attachToGLContext", "(I)V");

  /// from: public void attachToGLContext(int texName)
  ///
  /// Attach the SurfaceTexture to the OpenGL ES context that is current on the calling thread.  A
  /// new OpenGL ES texture object is created and populated with the SurfaceTexture image frame
  /// that was current at the time of the last call to \#detachFromGLContext.  This new
  /// texture is bound to the GL_TEXTURE_EXTERNAL_OES texture target.
  ///
  /// This can be used to access the SurfaceTexture image contents from multiple OpenGL ES
  /// contexts.  Note, however, that the image contents are only accessible from one OpenGL ES
  /// context at a time.
  ///@param texName The name of the OpenGL ES texture that will be created.  This texture name
  /// must be unusued in the OpenGL ES context that is current on the calling thread.
  void attachToGLContext(int texName) => jniAccessors.callMethodWithArgs(
      reference,
      _id_attachToGLContext,
      jni.JniType.voidType,
      [texName]).check();

  static final _id_getTransformMatrix =
      jniAccessors.getMethodIDOf(_classRef, "getTransformMatrix", "([F)V");

  /// from: public void getTransformMatrix(float[] mtx)
  ///
  /// Retrieve the 4x4 texture coordinate transform matrix associated with the texture image set by
  /// the most recent call to updateTexImage.
  ///
  /// This transform matrix maps 2D homogeneous texture coordinates of the form (s, t, 0, 1) with s
  /// and t in the inclusive range [0, 1] to the texture coordinate that should be used to sample
  /// that location from the texture.  Sampling the texture outside of the range of this transform
  /// is undefined.
  ///
  /// The matrix is stored in column-major order so that it may be passed directly to OpenGL ES via
  /// the glLoadMatrixf or glUniformMatrix4fv functions.
  ///@param mtx the array into which the 4x4 matrix will be stored.  The array must have exactly
  ///     16 elements.
  void getTransformMatrix(jni.JniObject mtx) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getTransformMatrix,
      jni.JniType.voidType,
      [mtx.reference]).check();

  static final _id_getTimestamp =
      jniAccessors.getMethodIDOf(_classRef, "getTimestamp", "()J");

  /// from: public long getTimestamp()
  ///
  /// Retrieve the timestamp associated with the texture image set by the most recent call to
  /// updateTexImage.
  ///
  /// This timestamp is in nanoseconds, and is normally monotonically increasing. The timestamp
  /// should be unaffected by time-of-day adjustments. The specific meaning and zero point of the
  /// timestamp depends on the source providing images to the SurfaceTexture. Unless otherwise
  /// specified by the image source, timestamps cannot generally be compared across SurfaceTexture
  /// instances, or across multiple program invocations. It is mostly useful for determining time
  /// offsets between subsequent frames.
  ///
  ///
  /// For camera sources, timestamps should be strictly monotonic. Timestamps from MediaPlayer
  /// sources may be reset when the playback position is set. For EGL and Vulkan producers, the
  /// timestamp is the desired present time set with the EGL_ANDROID_presentation_time or
  /// VK_GOOGLE_display_timing extensions.
  ///
  int getTimestamp() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimestamp, jni.JniType.longType, []).long;

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// release() frees all the buffers and puts the SurfaceTexture into the
  /// 'abandoned' state. Once put in this state the SurfaceTexture can never
  /// leave it. When in the 'abandoned' state, all methods of the
  /// IGraphicBufferProducer interface will fail with the NO_INIT error.
  ///
  /// Note that while calling this method causes all the buffers to be freed
  /// from the perspective of the the SurfaceTexture, if there are additional
  /// references on the buffers (e.g. if a buffer is referenced by a client or
  /// by OpenGL ES as a texture) then those buffer will remain allocated.
  ///
  /// Always call this method when you are done with SurfaceTexture. Failing
  /// to do so may delay resource deallocation for a significant amount of
  /// time.
  ///@see \#isReleased()
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_isReleased =
      jniAccessors.getMethodIDOf(_classRef, "isReleased", "()Z");

  /// from: public boolean isReleased()
  ///
  /// Returns true if the SurfaceTexture was released.
  ///@see \#release()
  bool isReleased() => jniAccessors.callMethodWithArgs(
      reference, _id_isReleased, jni.JniType.booleanType, []).boolean;

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.graphics.SurfaceTexture$OutOfResourcesException
///
/// Exception thrown when a SurfaceTexture couldn't be created or resized.
///@deprecated No longer thrown. android.view.Surface.OutOfResourcesException
/// is used instead.
class SurfaceTexture_OutOfResourcesException extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/graphics/SurfaceTexture\$OutOfResourcesException");
  SurfaceTexture_OutOfResourcesException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SurfaceTexture_OutOfResourcesException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SurfaceTexture_OutOfResourcesException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);
}

/// from: android.graphics.SurfaceTexture$OnFrameAvailableListener
///
/// Callback interface for being notified that a new stream frame is available.
class SurfaceTexture_OnFrameAvailableListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/graphics/SurfaceTexture\$OnFrameAvailableListener");
  SurfaceTexture_OnFrameAvailableListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onFrameAvailable = jniAccessors.getMethodIDOf(
      _classRef, "onFrameAvailable", "(Landroid/graphics/SurfaceTexture;)V");

  /// from: public abstract void onFrameAvailable(android.graphics.SurfaceTexture surfaceTexture)
  void onFrameAvailable(SurfaceTexture surfaceTexture) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFrameAvailable,
          jni.JniType.voidType, [surfaceTexture.reference]).check();
}
