// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Path.dart" as path_;

import "Shader.dart" as shader_;

import "ColorFilter.dart" as colorfilter_;

import "Xfermode.dart" as xfermode_;

import "PathEffect.dart" as patheffect_;

import "MaskFilter.dart" as maskfilter_;

import "Typeface.dart" as typeface_;

import "../os/LocaleList.dart" as localelist_;

import "Rect.dart" as rect_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Paint
///
/// The Paint class holds the style and color information about how to draw
/// geometries, text and bitmaps.
class Paint extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Paint");
  Paint.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ANTI_ALIAS_FLAG
  ///
  /// Paint flag that enables antialiasing when drawing.
  ///
  /// Enabling this flag will cause all draw operations that support
  /// antialiasing to use it.
  ///
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const ANTI_ALIAS_FLAG = 1;

  /// from: static public final int DEV_KERN_TEXT_FLAG
  ///
  /// Legacy Paint flag, no longer used.
  static const DEV_KERN_TEXT_FLAG = 256;

  /// from: static public final int DITHER_FLAG
  ///
  /// Paint flag that enables dithering when blitting.
  ///
  /// Enabling this flag applies a dither to any blit operation where the
  /// target's colour space is more constrained than the source.
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const DITHER_FLAG = 4;

  /// from: static public final int EMBEDDED_BITMAP_TEXT_FLAG
  ///
  /// Paint flag that enables the use of bitmap fonts when drawing text.
  ///
  /// Disabling this flag will prevent text draw operations from using
  /// embedded bitmap strikes in fonts, causing fonts with both scalable
  /// outlines and bitmap strikes to draw only the scalable outlines, and
  /// fonts with only bitmap strikes to not draw at all.
  ///
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const EMBEDDED_BITMAP_TEXT_FLAG = 1024;

  /// from: static public final int FAKE_BOLD_TEXT_FLAG
  ///
  /// Paint flag that applies a synthetic bolding effect to drawn text.
  ///
  /// Enabling this flag will cause text draw operations to apply a
  /// simulated bold effect when drawing a Typeface that is not
  /// already bold.
  ///
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const FAKE_BOLD_TEXT_FLAG = 32;

  /// from: static public final int FILTER_BITMAP_FLAG
  ///
  /// Paint flag that enables bilinear sampling on scaled bitmaps.
  ///
  /// If cleared, scaled bitmaps will be drawn with nearest neighbor
  /// sampling, likely resulting in artifacts. This should generally be on
  /// when drawing bitmaps, unless performance-bound (rendering to software
  /// canvas) or preferring pixelation artifacts to blurriness when scaling
  /// significantly.
  ///
  ///
  /// If bitmaps are scaled for device density at creation time (as
  /// resource bitmaps often are) the filtering will already have been
  /// done.
  ///
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const FILTER_BITMAP_FLAG = 2;

  /// from: static public final int HINTING_OFF
  ///
  /// Font hinter option that disables font hinting.
  ///@see \#setHinting(int)
  static const HINTING_OFF = 0;

  /// from: static public final int HINTING_ON
  ///
  /// Font hinter option that enables font hinting.
  ///@see \#setHinting(int)
  static const HINTING_ON = 1;

  /// from: static public final int LINEAR_TEXT_FLAG
  ///
  /// Paint flag that enables smooth linear scaling of text.
  ///
  /// Enabling this flag does not actually scale text, but rather adjusts
  /// text draw operations to deal gracefully with smooth adjustment of scale.
  /// When this flag is enabled, font hinting is disabled to prevent shape
  /// deformation between scale factors, and glyph caching is disabled due to
  /// the large number of glyph images that will be generated.
  ///
  ///
  /// \#SUBPIXEL_TEXT_FLAG should be used in conjunction with this
  /// flag to prevent glyph positions from snapping to whole pixel values as
  /// scale factor is adjusted.
  ///
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const LINEAR_TEXT_FLAG = 64;

  /// from: static public final int STRIKE_THRU_TEXT_FLAG
  ///
  /// Paint flag that applies a strike-through decoration to drawn text.
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const STRIKE_THRU_TEXT_FLAG = 16;

  /// from: static public final int SUBPIXEL_TEXT_FLAG
  ///
  /// Paint flag that enables subpixel positioning of text.
  ///
  /// Enabling this flag causes glyph advances to be computed with subpixel
  /// accuracy.
  ///
  ///
  /// This can be used with \#LINEAR_TEXT_FLAG to prevent text from
  /// jittering during smooth scale transitions.
  ///
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const SUBPIXEL_TEXT_FLAG = 128;

  /// from: static public final int UNDERLINE_TEXT_FLAG
  ///
  /// Paint flag that applies an underline decoration to drawn text.
  ///@see \#Paint(int)
  ///@see \#setFlags(int)
  static const UNDERLINE_TEXT_FLAG = 8;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new paint with default settings.
  Paint()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new paint with the specified flags. Use setFlags() to change
  /// these after the paint is created.
  ///@param flags initial flag bits, as if they were passed via setFlags().
  Paint.ctor1(int flags)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [flags]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Paint;)V");

  /// from: public void <init>(android.graphics.Paint paint)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new paint, initialized with the attributes in the specified
  /// paint parameter.
  ///@param paint Existing paint used to initialized the attributes of the
  ///              new paint.
  Paint.ctor2(Paint paint)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [paint.reference]).object);

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Restores the paint to its default settings.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(Landroid/graphics/Paint;)V");

  /// from: public void set(android.graphics.Paint src)
  ///
  /// Copy the fields from src into this paint. This is equivalent to calling
  /// get() on all of the src fields, and calling the corresponding set()
  /// methods on this.
  void set0(Paint src) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.voidType, [src.reference]).check();

  static final _id_getFlags =
      jniAccessors.getMethodIDOf(_classRef, "getFlags", "()I");

  /// from: public int getFlags()
  ///
  /// Return the paint's flags. Use the Flag enum to test flag values.
  ///@return the paint's flags (see enums ending in _Flag for bit masks)
  int getFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getFlags, jni.JniType.intType, []).integer;

  static final _id_setFlags =
      jniAccessors.getMethodIDOf(_classRef, "setFlags", "(I)V");

  /// from: public void setFlags(int flags)
  ///
  /// Set the paint's flags. Use the Flag enum to specific flag values.
  ///@param flags The new flag bits for the paint
  void setFlags(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_setFlags, jni.JniType.voidType, [flags]).check();

  static final _id_getHinting =
      jniAccessors.getMethodIDOf(_classRef, "getHinting", "()I");

  /// from: public int getHinting()
  ///
  /// Return the paint's hinting mode.  Returns either
  /// \#HINTING_OFF or \#HINTING_ON.
  int getHinting() => jniAccessors.callMethodWithArgs(
      reference, _id_getHinting, jni.JniType.intType, []).integer;

  static final _id_setHinting =
      jniAccessors.getMethodIDOf(_classRef, "setHinting", "(I)V");

  /// from: public void setHinting(int mode)
  ///
  /// Set the paint's hinting mode.  May be either
  /// \#HINTING_OFF or \#HINTING_ON.
  void setHinting(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setHinting, jni.JniType.voidType, [mode]).check();

  static final _id_isAntiAlias =
      jniAccessors.getMethodIDOf(_classRef, "isAntiAlias", "()Z");

  /// from: public final boolean isAntiAlias()
  ///
  /// Helper for getFlags(), returning true if ANTI_ALIAS_FLAG bit is set
  /// AntiAliasing smooths out the edges of what is being drawn, but is has
  /// no impact on the interior of the shape. See setDither() and
  /// setFilterBitmap() to affect how colors are treated.
  ///@return true if the antialias bit is set in the paint's flags.
  bool isAntiAlias() => jniAccessors.callMethodWithArgs(
      reference, _id_isAntiAlias, jni.JniType.booleanType, []).boolean;

  static final _id_setAntiAlias =
      jniAccessors.getMethodIDOf(_classRef, "setAntiAlias", "(Z)V");

  /// from: public void setAntiAlias(boolean aa)
  ///
  /// Helper for setFlags(), setting or clearing the ANTI_ALIAS_FLAG bit
  /// AntiAliasing smooths out the edges of what is being drawn, but is has
  /// no impact on the interior of the shape. See setDither() and
  /// setFilterBitmap() to affect how colors are treated.
  ///@param aa true to set the antialias bit in the flags, false to clear it
  void setAntiAlias(bool aa) => jniAccessors.callMethodWithArgs(
      reference, _id_setAntiAlias, jni.JniType.voidType, [aa]).check();

  static final _id_isDither =
      jniAccessors.getMethodIDOf(_classRef, "isDither", "()Z");

  /// from: public final boolean isDither()
  ///
  /// Helper for getFlags(), returning true if DITHER_FLAG bit is set
  /// Dithering affects how colors that are higher precision than the device
  /// are down-sampled. No dithering is generally faster, but higher precision
  /// colors are just truncated down (e.g. 8888 -> 565). Dithering tries to
  /// distribute the error inherent in this process, to reduce the visual
  /// artifacts.
  ///@return true if the dithering bit is set in the paint's flags.
  bool isDither() => jniAccessors.callMethodWithArgs(
      reference, _id_isDither, jni.JniType.booleanType, []).boolean;

  static final _id_setDither =
      jniAccessors.getMethodIDOf(_classRef, "setDither", "(Z)V");

  /// from: public void setDither(boolean dither)
  ///
  /// Helper for setFlags(), setting or clearing the DITHER_FLAG bit
  /// Dithering affects how colors that are higher precision than the device
  /// are down-sampled. No dithering is generally faster, but higher precision
  /// colors are just truncated down (e.g. 8888 -> 565). Dithering tries to
  /// distribute the error inherent in this process, to reduce the visual
  /// artifacts.
  ///@param dither true to set the dithering bit in flags, false to clear it
  void setDither(bool dither) => jniAccessors.callMethodWithArgs(
      reference, _id_setDither, jni.JniType.voidType, [dither]).check();

  static final _id_isLinearText =
      jniAccessors.getMethodIDOf(_classRef, "isLinearText", "()Z");

  /// from: public final boolean isLinearText()
  ///
  /// Helper for getFlags(), returning true if LINEAR_TEXT_FLAG bit is set
  ///@return true if the lineartext bit is set in the paint's flags
  bool isLinearText() => jniAccessors.callMethodWithArgs(
      reference, _id_isLinearText, jni.JniType.booleanType, []).boolean;

  static final _id_setLinearText =
      jniAccessors.getMethodIDOf(_classRef, "setLinearText", "(Z)V");

  /// from: public void setLinearText(boolean linearText)
  ///
  /// Helper for setFlags(), setting or clearing the LINEAR_TEXT_FLAG bit
  ///@param linearText true to set the linearText bit in the paint's flags,
  ///                   false to clear it.
  void setLinearText(bool linearText) => jniAccessors.callMethodWithArgs(
      reference, _id_setLinearText, jni.JniType.voidType, [linearText]).check();

  static final _id_isSubpixelText =
      jniAccessors.getMethodIDOf(_classRef, "isSubpixelText", "()Z");

  /// from: public final boolean isSubpixelText()
  ///
  /// Helper for getFlags(), returning true if SUBPIXEL_TEXT_FLAG bit is set
  ///@return true if the subpixel bit is set in the paint's flags
  bool isSubpixelText() => jniAccessors.callMethodWithArgs(
      reference, _id_isSubpixelText, jni.JniType.booleanType, []).boolean;

  static final _id_setSubpixelText =
      jniAccessors.getMethodIDOf(_classRef, "setSubpixelText", "(Z)V");

  /// from: public void setSubpixelText(boolean subpixelText)
  ///
  /// Helper for setFlags(), setting or clearing the SUBPIXEL_TEXT_FLAG bit
  ///@param subpixelText true to set the subpixelText bit in the paint's
  ///                     flags, false to clear it.
  void setSubpixelText(bool subpixelText) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSubpixelText,
      jni.JniType.voidType,
      [subpixelText]).check();

  static final _id_isUnderlineText =
      jniAccessors.getMethodIDOf(_classRef, "isUnderlineText", "()Z");

  /// from: public final boolean isUnderlineText()
  ///
  /// Helper for getFlags(), returning true if UNDERLINE_TEXT_FLAG bit is set
  ///@return true if the underlineText bit is set in the paint's flags.
  bool isUnderlineText() => jniAccessors.callMethodWithArgs(
      reference, _id_isUnderlineText, jni.JniType.booleanType, []).boolean;

  static final _id_setUnderlineText =
      jniAccessors.getMethodIDOf(_classRef, "setUnderlineText", "(Z)V");

  /// from: public void setUnderlineText(boolean underlineText)
  ///
  /// Helper for setFlags(), setting or clearing the UNDERLINE_TEXT_FLAG bit
  ///@param underlineText true to set the underlineText bit in the paint's
  ///                      flags, false to clear it.
  void setUnderlineText(bool underlineText) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setUnderlineText,
      jni.JniType.voidType,
      [underlineText]).check();

  static final _id_isStrikeThruText =
      jniAccessors.getMethodIDOf(_classRef, "isStrikeThruText", "()Z");

  /// from: public final boolean isStrikeThruText()
  ///
  /// Helper for getFlags(), returning true if STRIKE_THRU_TEXT_FLAG bit is set
  ///@return true if the strikeThruText bit is set in the paint's flags.
  bool isStrikeThruText() => jniAccessors.callMethodWithArgs(
      reference, _id_isStrikeThruText, jni.JniType.booleanType, []).boolean;

  static final _id_setStrikeThruText =
      jniAccessors.getMethodIDOf(_classRef, "setStrikeThruText", "(Z)V");

  /// from: public void setStrikeThruText(boolean strikeThruText)
  ///
  /// Helper for setFlags(), setting or clearing the STRIKE_THRU_TEXT_FLAG bit
  ///@param strikeThruText true to set the strikeThruText bit in the paint's
  ///                       flags, false to clear it.
  void setStrikeThruText(bool strikeThruText) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStrikeThruText,
          jni.JniType.voidType, [strikeThruText]).check();

  static final _id_isFakeBoldText =
      jniAccessors.getMethodIDOf(_classRef, "isFakeBoldText", "()Z");

  /// from: public final boolean isFakeBoldText()
  ///
  /// Helper for getFlags(), returning true if FAKE_BOLD_TEXT_FLAG bit is set
  ///@return true if the fakeBoldText bit is set in the paint's flags.
  bool isFakeBoldText() => jniAccessors.callMethodWithArgs(
      reference, _id_isFakeBoldText, jni.JniType.booleanType, []).boolean;

  static final _id_setFakeBoldText =
      jniAccessors.getMethodIDOf(_classRef, "setFakeBoldText", "(Z)V");

  /// from: public void setFakeBoldText(boolean fakeBoldText)
  ///
  /// Helper for setFlags(), setting or clearing the FAKE_BOLD_TEXT_FLAG bit
  ///@param fakeBoldText true to set the fakeBoldText bit in the paint's
  ///                     flags, false to clear it.
  void setFakeBoldText(bool fakeBoldText) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFakeBoldText,
      jni.JniType.voidType,
      [fakeBoldText]).check();

  static final _id_isFilterBitmap =
      jniAccessors.getMethodIDOf(_classRef, "isFilterBitmap", "()Z");

  /// from: public final boolean isFilterBitmap()
  ///
  /// Whether or not the bitmap filter is activated.
  /// Filtering affects the sampling of bitmaps when they are transformed.
  /// Filtering does not affect how the colors in the bitmap are converted into
  /// device pixels. That is dependent on dithering and xfermodes.
  ///@see \#setFilterBitmap(boolean) setFilterBitmap()
  bool isFilterBitmap() => jniAccessors.callMethodWithArgs(
      reference, _id_isFilterBitmap, jni.JniType.booleanType, []).boolean;

  static final _id_setFilterBitmap =
      jniAccessors.getMethodIDOf(_classRef, "setFilterBitmap", "(Z)V");

  /// from: public void setFilterBitmap(boolean filter)
  ///
  /// Helper for setFlags(), setting or clearing the FILTER_BITMAP_FLAG bit.
  /// Filtering affects the sampling of bitmaps when they are transformed.
  /// Filtering does not affect how the colors in the bitmap are converted into
  /// device pixels. That is dependent on dithering and xfermodes.
  ///@param filter true to set the FILTER_BITMAP_FLAG bit in the paint's
  ///               flags, false to clear it.
  void setFilterBitmap(bool filter) => jniAccessors.callMethodWithArgs(
      reference, _id_setFilterBitmap, jni.JniType.voidType, [filter]).check();

  static final _id_getStyle = jniAccessors.getMethodIDOf(
      _classRef, "getStyle", "()Landroid/graphics/Paint\$Style;");

  /// from: public android.graphics.Paint.Style getStyle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the paint's style, used for controlling how primitives'
  /// geometries are interpreted (except for drawBitmap, which always assumes
  /// FILL_STYLE).
  ///@return the paint's style setting (Fill, Stroke, StrokeAndFill)
  Paint_Style getStyle() => Paint_Style.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getStyle, jni.JniType.objectType, []).object);

  static final _id_setStyle = jniAccessors.getMethodIDOf(
      _classRef, "setStyle", "(Landroid/graphics/Paint\$Style;)V");

  /// from: public void setStyle(android.graphics.Paint.Style style)
  ///
  /// Set the paint's style, used for controlling how primitives'
  /// geometries are interpreted (except for drawBitmap, which always assumes
  /// Fill).
  ///@param style The new style to set in the paint
  void setStyle(Paint_Style style) => jniAccessors.callMethodWithArgs(
      reference, _id_setStyle, jni.JniType.voidType, [style.reference]).check();

  static final _id_getColor =
      jniAccessors.getMethodIDOf(_classRef, "getColor", "()I");

  /// from: public int getColor()
  ///
  /// Return the paint's color. Note that the color is a 32bit value
  /// containing alpha as well as r,g,b. This 32bit value is not premultiplied,
  /// meaning that its alpha can be any value, regardless of the values of
  /// r,g,b. See the Color class for more details.
  ///@return the paint's color (and alpha).
  int getColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getColor, jni.JniType.intType, []).integer;

  static final _id_setColor =
      jniAccessors.getMethodIDOf(_classRef, "setColor", "(I)V");

  /// from: public void setColor(int color)
  ///
  /// Set the paint's color. Note that the color is an int containing alpha
  /// as well as r,g,b. This 32bit value is not premultiplied, meaning that
  /// its alpha can be any value, regardless of the values of r,g,b.
  /// See the Color class for more details.
  ///@param color The new color (including alpha) to set in the paint.
  void setColor(int color) => jniAccessors.callMethodWithArgs(
      reference, _id_setColor, jni.JniType.voidType, [color]).check();

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()I");

  /// from: public int getAlpha()
  ///
  /// Helper to getColor() that just returns the color's alpha value. This is
  /// the same as calling getColor() >>> 24. It always returns a value between
  /// 0 (completely transparent) and 255 (completely opaque).
  ///@return the alpha component of the paint's color.
  int getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.intType, []).integer;

  static final _id_setAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setAlpha", "(I)V");

  /// from: public void setAlpha(int a)
  ///
  /// Helper to setColor(), that only assigns the color's alpha value,
  /// leaving its r,g,b values unchanged. Results are undefined if the alpha
  /// value is outside of the range [0..255]
  ///@param a set the alpha component [0..255] of the paint's color.
  void setAlpha(int a) => jniAccessors.callMethodWithArgs(
      reference, _id_setAlpha, jni.JniType.voidType, [a]).check();

  static final _id_setARGB =
      jniAccessors.getMethodIDOf(_classRef, "setARGB", "(IIII)V");

  /// from: public void setARGB(int a, int r, int g, int b)
  ///
  /// Helper to setColor(), that takes a,r,g,b and constructs the color int
  ///@param a The new alpha component (0..255) of the paint's color.
  ///@param r The new red component (0..255) of the paint's color.
  ///@param g The new green component (0..255) of the paint's color.
  ///@param b The new blue component (0..255) of the paint's color.
  void setARGB(int a, int r, int g, int b) => jniAccessors.callMethodWithArgs(
      reference, _id_setARGB, jni.JniType.voidType, [a, r, g, b]).check();

  static final _id_getStrokeWidth =
      jniAccessors.getMethodIDOf(_classRef, "getStrokeWidth", "()F");

  /// from: public float getStrokeWidth()
  ///
  /// Return the width for stroking.
  /// <p/>
  /// A value of 0 strokes in hairline mode.
  /// Hairlines always draws a single pixel independent of the canva's matrix.
  ///@return the paint's stroke width, used whenever the paint's style is
  ///         Stroke or StrokeAndFill.
  double getStrokeWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getStrokeWidth, jni.JniType.floatType, []).float;

  static final _id_setStrokeWidth =
      jniAccessors.getMethodIDOf(_classRef, "setStrokeWidth", "(F)V");

  /// from: public void setStrokeWidth(float width)
  ///
  /// Set the width for stroking.
  /// Pass 0 to stroke in hairline mode.
  /// Hairlines always draws a single pixel independent of the canva's matrix.
  ///@param width set the paint's stroke width, used whenever the paint's
  ///              style is Stroke or StrokeAndFill.
  void setStrokeWidth(double width) => jniAccessors.callMethodWithArgs(
      reference, _id_setStrokeWidth, jni.JniType.voidType, [width]).check();

  static final _id_getStrokeMiter =
      jniAccessors.getMethodIDOf(_classRef, "getStrokeMiter", "()F");

  /// from: public float getStrokeMiter()
  ///
  /// Return the paint's stroke miter value. Used to control the behavior
  /// of miter joins when the joins angle is sharp.
  ///@return the paint's miter limit, used whenever the paint's style is
  ///         Stroke or StrokeAndFill.
  double getStrokeMiter() => jniAccessors.callMethodWithArgs(
      reference, _id_getStrokeMiter, jni.JniType.floatType, []).float;

  static final _id_setStrokeMiter =
      jniAccessors.getMethodIDOf(_classRef, "setStrokeMiter", "(F)V");

  /// from: public void setStrokeMiter(float miter)
  ///
  /// Set the paint's stroke miter value. This is used to control the behavior
  /// of miter joins when the joins angle is sharp. This value must be >= 0.
  ///@param miter set the miter limit on the paint, used whenever the paint's
  ///              style is Stroke or StrokeAndFill.
  void setStrokeMiter(double miter) => jniAccessors.callMethodWithArgs(
      reference, _id_setStrokeMiter, jni.JniType.voidType, [miter]).check();

  static final _id_getStrokeCap = jniAccessors.getMethodIDOf(
      _classRef, "getStrokeCap", "()Landroid/graphics/Paint\$Cap;");

  /// from: public android.graphics.Paint.Cap getStrokeCap()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the paint's Cap, controlling how the start and end of stroked
  /// lines and paths are treated.
  ///@return the line cap style for the paint, used whenever the paint's
  ///         style is Stroke or StrokeAndFill.
  Paint_Cap getStrokeCap() => Paint_Cap.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getStrokeCap, jni.JniType.objectType, []).object);

  static final _id_setStrokeCap = jniAccessors.getMethodIDOf(
      _classRef, "setStrokeCap", "(Landroid/graphics/Paint\$Cap;)V");

  /// from: public void setStrokeCap(android.graphics.Paint.Cap cap)
  ///
  /// Set the paint's Cap.
  ///@param cap set the paint's line cap style, used whenever the paint's
  ///            style is Stroke or StrokeAndFill.
  void setStrokeCap(Paint_Cap cap) => jniAccessors.callMethodWithArgs(reference,
      _id_setStrokeCap, jni.JniType.voidType, [cap.reference]).check();

  static final _id_getStrokeJoin = jniAccessors.getMethodIDOf(
      _classRef, "getStrokeJoin", "()Landroid/graphics/Paint\$Join;");

  /// from: public android.graphics.Paint.Join getStrokeJoin()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the paint's stroke join type.
  ///@return the paint's Join.
  Paint_Join getStrokeJoin() =>
      Paint_Join.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStrokeJoin, jni.JniType.objectType, []).object);

  static final _id_setStrokeJoin = jniAccessors.getMethodIDOf(
      _classRef, "setStrokeJoin", "(Landroid/graphics/Paint\$Join;)V");

  /// from: public void setStrokeJoin(android.graphics.Paint.Join join)
  ///
  /// Set the paint's Join.
  ///@param join set the paint's Join, used whenever the paint's style is
  ///             Stroke or StrokeAndFill.
  void setStrokeJoin(Paint_Join join) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setStrokeJoin,
      jni.JniType.voidType,
      [join.reference]).check();

  static final _id_getFillPath = jniAccessors.getMethodIDOf(_classRef,
      "getFillPath", "(Landroid/graphics/Path;Landroid/graphics/Path;)Z");

  /// from: public boolean getFillPath(android.graphics.Path src, android.graphics.Path dst)
  ///
  /// Applies any/all effects (patheffect, stroking) to src, returning the
  /// result in dst. The result is that drawing src with this paint will be
  /// the same as drawing dst with a default paint (at least from the
  /// geometric perspective).
  ///@param src input path
  ///@param dst output path (may be the same as src)
  ///@return true if the path should be filled, or false if it should be
  ///                 drawn with a hairline (width == 0)
  bool getFillPath(path_.Path src, path_.Path dst) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFillPath,
          jni.JniType.booleanType, [src.reference, dst.reference]).boolean;

  static final _id_getShader = jniAccessors.getMethodIDOf(
      _classRef, "getShader", "()Landroid/graphics/Shader;");

  /// from: public android.graphics.Shader getShader()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the paint's shader object.
  ///@return the paint's shader (or null)
  shader_.Shader getShader() =>
      shader_.Shader.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getShader, jni.JniType.objectType, []).object);

  static final _id_setShader = jniAccessors.getMethodIDOf(_classRef,
      "setShader", "(Landroid/graphics/Shader;)Landroid/graphics/Shader;");

  /// from: public android.graphics.Shader setShader(android.graphics.Shader shader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set or clear the shader object.
  /// <p/>
  /// Pass null to clear any previous shader.
  /// As a convenience, the parameter passed is also returned.
  ///@param shader May be null. the new shader to be installed in the paint
  ///@return shader
  shader_.Shader setShader(shader_.Shader shader) =>
      shader_.Shader.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setShader, jni.JniType.objectType, [shader.reference]).object);

  static final _id_getColorFilter = jniAccessors.getMethodIDOf(
      _classRef, "getColorFilter", "()Landroid/graphics/ColorFilter;");

  /// from: public android.graphics.ColorFilter getColorFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the paint's colorfilter (maybe be null).
  ///@return the paint's colorfilter (maybe be null)
  colorfilter_.ColorFilter getColorFilter() =>
      colorfilter_.ColorFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorFilter, jni.JniType.objectType, []).object);

  static final _id_setColorFilter = jniAccessors.getMethodIDOf(
      _classRef,
      "setColorFilter",
      "(Landroid/graphics/ColorFilter;)Landroid/graphics/ColorFilter;");

  /// from: public android.graphics.ColorFilter setColorFilter(android.graphics.ColorFilter filter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set or clear the paint's colorfilter, returning the parameter.
  ///@param filter May be null. The new filter to be installed in the paint
  ///@return filter
  colorfilter_.ColorFilter setColorFilter(colorfilter_.ColorFilter filter) =>
      colorfilter_.ColorFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setColorFilter,
          jni.JniType.objectType,
          [filter.reference]).object);

  static final _id_getXfermode = jniAccessors.getMethodIDOf(
      _classRef, "getXfermode", "()Landroid/graphics/Xfermode;");

  /// from: public android.graphics.Xfermode getXfermode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the paint's transfer mode object.
  ///@return the paint's transfer mode (or null)
  xfermode_.Xfermode getXfermode() =>
      xfermode_.Xfermode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getXfermode, jni.JniType.objectType, []).object);

  static final _id_setXfermode = jniAccessors.getMethodIDOf(
      _classRef,
      "setXfermode",
      "(Landroid/graphics/Xfermode;)Landroid/graphics/Xfermode;");

  /// from: public android.graphics.Xfermode setXfermode(android.graphics.Xfermode xfermode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set or clear the transfer mode object. A transfer mode defines how
  /// source pixels (generate by a drawing command) are composited with
  /// the destination pixels (content of the render target).
  /// <p/>
  /// Pass null to clear any previous transfer mode.
  /// As a convenience, the parameter passed is also returned.
  /// <p/>
  /// PorterDuffXfermode is the most common transfer mode.
  ///@param xfermode May be null. The xfermode to be installed in the paint
  ///@return xfermode
  xfermode_.Xfermode setXfermode(xfermode_.Xfermode xfermode) =>
      xfermode_.Xfermode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setXfermode,
          jni.JniType.objectType,
          [xfermode.reference]).object);

  static final _id_getPathEffect = jniAccessors.getMethodIDOf(
      _classRef, "getPathEffect", "()Landroid/graphics/PathEffect;");

  /// from: public android.graphics.PathEffect getPathEffect()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the paint's patheffect object.
  ///@return the paint's patheffect (or null)
  patheffect_.PathEffect getPathEffect() =>
      patheffect_.PathEffect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPathEffect, jni.JniType.objectType, []).object);

  static final _id_setPathEffect = jniAccessors.getMethodIDOf(
      _classRef,
      "setPathEffect",
      "(Landroid/graphics/PathEffect;)Landroid/graphics/PathEffect;");

  /// from: public android.graphics.PathEffect setPathEffect(android.graphics.PathEffect effect)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set or clear the patheffect object.
  /// <p/>
  /// Pass null to clear any previous patheffect.
  /// As a convenience, the parameter passed is also returned.
  ///@param effect May be null. The patheffect to be installed in the paint
  ///@return effect
  patheffect_.PathEffect setPathEffect(patheffect_.PathEffect effect) =>
      patheffect_.PathEffect.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setPathEffect,
          jni.JniType.objectType,
          [effect.reference]).object);

  static final _id_getMaskFilter = jniAccessors.getMethodIDOf(
      _classRef, "getMaskFilter", "()Landroid/graphics/MaskFilter;");

  /// from: public android.graphics.MaskFilter getMaskFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the paint's maskfilter object.
  ///@return the paint's maskfilter (or null)
  maskfilter_.MaskFilter getMaskFilter() =>
      maskfilter_.MaskFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMaskFilter, jni.JniType.objectType, []).object);

  static final _id_setMaskFilter = jniAccessors.getMethodIDOf(
      _classRef,
      "setMaskFilter",
      "(Landroid/graphics/MaskFilter;)Landroid/graphics/MaskFilter;");

  /// from: public android.graphics.MaskFilter setMaskFilter(android.graphics.MaskFilter maskfilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set or clear the maskfilter object.
  /// <p/>
  /// Pass null to clear any previous maskfilter.
  /// As a convenience, the parameter passed is also returned.
  ///@param maskfilter May be null. The maskfilter to be installed in the
  ///                   paint
  ///@return maskfilter
  maskfilter_.MaskFilter setMaskFilter(maskfilter_.MaskFilter maskfilter) =>
      maskfilter_.MaskFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setMaskFilter,
          jni.JniType.objectType,
          [maskfilter.reference]).object);

  static final _id_getTypeface = jniAccessors.getMethodIDOf(
      _classRef, "getTypeface", "()Landroid/graphics/Typeface;");

  /// from: public android.graphics.Typeface getTypeface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the paint's typeface object.
  /// <p/>
  /// The typeface object identifies which font to use when drawing or
  /// measuring text.
  ///@return the paint's typeface (or null)
  typeface_.Typeface getTypeface() =>
      typeface_.Typeface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTypeface, jni.JniType.objectType, []).object);

  static final _id_setTypeface = jniAccessors.getMethodIDOf(
      _classRef,
      "setTypeface",
      "(Landroid/graphics/Typeface;)Landroid/graphics/Typeface;");

  /// from: public android.graphics.Typeface setTypeface(android.graphics.Typeface typeface)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set or clear the typeface object.
  /// <p/>
  /// Pass null to clear any previous typeface.
  /// As a convenience, the parameter passed is also returned.
  ///@param typeface May be null. The typeface to be installed in the paint
  ///@return typeface
  typeface_.Typeface setTypeface(typeface_.Typeface typeface) =>
      typeface_.Typeface.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTypeface,
          jni.JniType.objectType,
          [typeface.reference]).object);

  static final _id_setShadowLayer =
      jniAccessors.getMethodIDOf(_classRef, "setShadowLayer", "(FFFI)V");

  /// from: public void setShadowLayer(float radius, float dx, float dy, int shadowColor)
  ///
  /// This draws a shadow layer below the main layer, with the specified
  /// offset and color, and blur radius. If radius is 0, then the shadow
  /// layer is removed.
  ///
  /// Can be used to create a blurred shadow underneath text. Support for use
  /// with other drawing operations is constrained to the software rendering
  /// pipeline.
  ///
  /// The alpha of the shadow will be the paint's alpha if the shadow color is
  /// opaque, or the alpha from the shadow color if not.
  void setShadowLayer(double radius, double dx, double dy, int shadowColor) =>
      jniAccessors.callMethodWithArgs(reference, _id_setShadowLayer,
          jni.JniType.voidType, [radius, dx, dy, shadowColor]).check();

  static final _id_clearShadowLayer =
      jniAccessors.getMethodIDOf(_classRef, "clearShadowLayer", "()V");

  /// from: public void clearShadowLayer()
  ///
  /// Clear the shadow layer.
  void clearShadowLayer() => jniAccessors.callMethodWithArgs(
      reference, _id_clearShadowLayer, jni.JniType.voidType, []).check();

  static final _id_getTextAlign = jniAccessors.getMethodIDOf(
      _classRef, "getTextAlign", "()Landroid/graphics/Paint\$Align;");

  /// from: public android.graphics.Paint.Align getTextAlign()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the paint's Align value for drawing text. This controls how the
  /// text is positioned relative to its origin. LEFT align means that all of
  /// the text will be drawn to the right of its origin (i.e. the origin
  /// specifieds the LEFT edge of the text) and so on.
  ///@return the paint's Align value for drawing text.
  Paint_Align getTextAlign() =>
      Paint_Align.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextAlign, jni.JniType.objectType, []).object);

  static final _id_setTextAlign = jniAccessors.getMethodIDOf(
      _classRef, "setTextAlign", "(Landroid/graphics/Paint\$Align;)V");

  /// from: public void setTextAlign(android.graphics.Paint.Align align)
  ///
  /// Set the paint's text alignment. This controls how the
  /// text is positioned relative to its origin. LEFT align means that all of
  /// the text will be drawn to the right of its origin (i.e. the origin
  /// specifieds the LEFT edge of the text) and so on.
  ///@param align set the paint's Align value for drawing text.
  void setTextAlign(Paint_Align align) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextAlign,
      jni.JniType.voidType,
      [align.reference]).check();

  static final _id_getTextLocale = jniAccessors.getMethodIDOf(
      _classRef, "getTextLocale", "()Ljava/util/Locale;");

  /// from: public java.util.Locale getTextLocale()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the text's primary Locale. Note that this is not all of the locale-related information
  /// Paint has. Use \#getTextLocales() to get the complete list.
  ///@return the paint's primary Locale used for drawing text, never null.
  jni.JniObject getTextLocale() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextLocale, jni.JniType.objectType, []).object);

  static final _id_getTextLocales = jniAccessors.getMethodIDOf(
      _classRef, "getTextLocales", "()Landroid/os/LocaleList;");

  /// from: public android.os.LocaleList getTextLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the text locale list.
  ///@return the paint's LocaleList used for drawing text, never null or empty.
  localelist_.LocaleList getTextLocales() =>
      localelist_.LocaleList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextLocales, jni.JniType.objectType, []).object);

  static final _id_setTextLocale = jniAccessors.getMethodIDOf(
      _classRef, "setTextLocale", "(Ljava/util/Locale;)V");

  /// from: public void setTextLocale(java.util.Locale locale)
  ///
  /// Set the text locale list to a one-member list consisting of just the locale.
  ///
  /// See \#setTextLocales(LocaleList) for how the locale list affects
  /// the way the text is drawn for some languages.
  ///@param locale the paint's locale value for drawing text, must not be null.
  ///
  /// This value must never be {@code null}.
  void setTextLocale(jni.JniObject locale) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTextLocale,
      jni.JniType.voidType,
      [locale.reference]).check();

  static final _id_setTextLocales = jniAccessors.getMethodIDOf(
      _classRef, "setTextLocales", "(Landroid/os/LocaleList;)V");

  /// from: public void setTextLocales(android.os.LocaleList locales)
  ///
  /// Set the text locale list.
  ///
  /// The text locale list affects how the text is drawn for some languages.
  ///
  /// For example, if the locale list contains Locale\#CHINESE or Locale\#CHINA,
  /// then the text renderer will prefer to draw text using a Chinese font. Likewise,
  /// if the locale list contains Locale\#JAPANESE or Locale\#JAPAN, then the text
  /// renderer will prefer to draw text using a Japanese font. If the locale list contains both,
  /// the order those locales appear in the list is considered for deciding the font.
  ///
  /// This distinction is important because Chinese and Japanese text both use many
  /// of the same Unicode code points but their appearance is subtly different for
  /// each language.
  ///
  /// By default, the text locale list is initialized to a one-member list just containing the
  /// system locales. This assumes that the text to be rendered will most likely be in the user's
  /// preferred language.
  ///
  /// If the actual language or languages of the text is/are known, then they can be provided to
  /// the text renderer using this method. The text renderer may attempt to guess the
  /// language script based on the contents of the text to be drawn independent of
  /// the text locale here. Specifying the text locales just helps it do a better
  /// job in certain ambiguous cases.
  ///@param locales the paint's locale list for drawing text, must not be null or empty.
  ///
  /// This value must never be {@code null}.
  void setTextLocales(localelist_.LocaleList locales) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextLocales,
          jni.JniType.voidType, [locales.reference]).check();

  static final _id_isElegantTextHeight =
      jniAccessors.getMethodIDOf(_classRef, "isElegantTextHeight", "()Z");

  /// from: public boolean isElegantTextHeight()
  ///
  /// Get the elegant metrics flag.
  ///@return true if elegant metrics are enabled for text drawing.
  bool isElegantTextHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_isElegantTextHeight, jni.JniType.booleanType, []).boolean;

  static final _id_setElegantTextHeight =
      jniAccessors.getMethodIDOf(_classRef, "setElegantTextHeight", "(Z)V");

  /// from: public void setElegantTextHeight(boolean elegant)
  ///
  /// Set the paint's elegant height metrics flag. This setting selects font
  /// variants that have not been compacted to fit Latin-based vertical
  /// metrics, and also increases top and bottom bounds to provide more space.
  ///@param elegant set the paint's elegant metrics flag for drawing text.
  void setElegantTextHeight(bool elegant) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setElegantTextHeight,
      jni.JniType.voidType,
      [elegant]).check();

  static final _id_getTextSize =
      jniAccessors.getMethodIDOf(_classRef, "getTextSize", "()F");

  /// from: public float getTextSize()
  ///
  /// Return the paint's text size.
  ///@return the paint's text size in pixel units.
  double getTextSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSize, jni.JniType.floatType, []).float;

  static final _id_setTextSize =
      jniAccessors.getMethodIDOf(_classRef, "setTextSize", "(F)V");

  /// from: public void setTextSize(float textSize)
  ///
  /// Set the paint's text size. This value must be > 0
  ///@param textSize set the paint's text size in pixel units.
  void setTextSize(double textSize) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextSize, jni.JniType.voidType, [textSize]).check();

  static final _id_getTextScaleX =
      jniAccessors.getMethodIDOf(_classRef, "getTextScaleX", "()F");

  /// from: public float getTextScaleX()
  ///
  /// Return the paint's horizontal scale factor for text. The default value
  /// is 1.0.
  ///@return the paint's scale factor in X for drawing/measuring text
  double getTextScaleX() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextScaleX, jni.JniType.floatType, []).float;

  static final _id_setTextScaleX =
      jniAccessors.getMethodIDOf(_classRef, "setTextScaleX", "(F)V");

  /// from: public void setTextScaleX(float scaleX)
  ///
  /// Set the paint's horizontal scale factor for text. The default value
  /// is 1.0. Values > 1.0 will stretch the text wider. Values < 1.0 will
  /// stretch the text narrower.
  ///@param scaleX set the paint's scale in X for drawing/measuring text.
  void setTextScaleX(double scaleX) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextScaleX, jni.JniType.voidType, [scaleX]).check();

  static final _id_getTextSkewX =
      jniAccessors.getMethodIDOf(_classRef, "getTextSkewX", "()F");

  /// from: public float getTextSkewX()
  ///
  /// Return the paint's horizontal skew factor for text. The default value
  /// is 0.
  ///@return the paint's skew factor in X for drawing text.
  double getTextSkewX() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSkewX, jni.JniType.floatType, []).float;

  static final _id_setTextSkewX =
      jniAccessors.getMethodIDOf(_classRef, "setTextSkewX", "(F)V");

  /// from: public void setTextSkewX(float skewX)
  ///
  /// Set the paint's horizontal skew factor for text. The default value
  /// is 0. For approximating oblique text, use values around -0.25.
  ///@param skewX set the paint's skew factor in X for drawing text.
  void setTextSkewX(double skewX) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextSkewX, jni.JniType.voidType, [skewX]).check();

  static final _id_getLetterSpacing =
      jniAccessors.getMethodIDOf(_classRef, "getLetterSpacing", "()F");

  /// from: public float getLetterSpacing()
  ///
  /// Return the paint's letter-spacing for text. The default value
  /// is 0.
  ///@return the paint's letter-spacing for drawing text.
  double getLetterSpacing() => jniAccessors.callMethodWithArgs(
      reference, _id_getLetterSpacing, jni.JniType.floatType, []).float;

  static final _id_setLetterSpacing =
      jniAccessors.getMethodIDOf(_classRef, "setLetterSpacing", "(F)V");

  /// from: public void setLetterSpacing(float letterSpacing)
  ///
  /// Set the paint's letter-spacing for text. The default value
  /// is 0.  The value is in 'EM' units.  Typical values for slight
  /// expansion will be around 0.05.  Negative values tighten text.
  ///@param letterSpacing set the paint's letter-spacing for drawing text.
  void setLetterSpacing(double letterSpacing) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLetterSpacing,
          jni.JniType.voidType, [letterSpacing]).check();

  static final _id_getFontFeatureSettings = jniAccessors.getMethodIDOf(
      _classRef, "getFontFeatureSettings", "()Ljava/lang/String;");

  /// from: public java.lang.String getFontFeatureSettings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the font feature settings. The format is the same as the CSS
  /// font-feature-settings attribute:
  /// <a href="https://www.w3.org/TR/css-fonts-3/\#font-feature-settings-prop">
  ///     https://www.w3.org/TR/css-fonts-3/\#font-feature-settings-prop</a>
  ///@return the paint's currently set font feature settings. Default is null.
  ///@see \#setFontFeatureSettings(String)
  jni.JniString getFontFeatureSettings() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFontFeatureSettings, jni.JniType.objectType, []).object);

  static final _id_setFontFeatureSettings = jniAccessors.getMethodIDOf(
      _classRef, "setFontFeatureSettings", "(Ljava/lang/String;)V");

  /// from: public void setFontFeatureSettings(java.lang.String settings)
  ///
  /// Set font feature settings.
  ///
  /// The format is the same as the CSS font-feature-settings attribute:
  /// <a href="https://www.w3.org/TR/css-fonts-3/\#font-feature-settings-prop">
  ///     https://www.w3.org/TR/css-fonts-3/\#font-feature-settings-prop</a>
  ///@see \#getFontFeatureSettings()
  ///@param settings the font feature settings string to use, may be null.
  void setFontFeatureSettings(jni.JniString settings) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFontFeatureSettings,
          jni.JniType.voidType, [settings.reference]).check();

  static final _id_getFontVariationSettings = jniAccessors.getMethodIDOf(
      _classRef, "getFontVariationSettings", "()Ljava/lang/String;");

  /// from: public java.lang.String getFontVariationSettings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the font variation settings.
  ///@return the paint's currently set font variation settings. Default is null.
  ///@see \#setFontVariationSettings(String)
  jni.JniString getFontVariationSettings() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFontVariationSettings, jni.JniType.objectType, []).object);

  static final _id_setFontVariationSettings = jniAccessors.getMethodIDOf(
      _classRef, "setFontVariationSettings", "(Ljava/lang/String;)Z");

  /// from: public boolean setFontVariationSettings(java.lang.String fontVariationSettings)
  ///
  /// Sets TrueType or OpenType font variation settings. The settings string is constructed from
  /// multiple pairs of axis tag and style values. The axis tag must contain four ASCII characters
  /// and must be wrapped with single quotes (U+0027) or double quotes (U+0022). Axis strings that
  /// are longer or shorter than four characters, or contain characters outside of U+0020..U+007E
  /// are invalid. If a specified axis name is not defined in the font, the settings will be
  /// ignored.
  ///
  /// Examples,
  /// <ul>
  /// <li>Set font width to 150.
  /// <pre>
  /// <code>
  ///   Paint paint = new Paint();
  ///   paint.setFontVariationSettings("'wdth' 150");
  /// </code>
  /// </pre>
  /// </li>
  ///
  /// <li>Set the font slant to 20 degrees and ask for italic style.
  /// <pre>
  /// <code>
  ///   Paint paint = new Paint();
  ///   paint.setFontVariationSettings("'slnt' 20, 'ital' 1");
  /// </code>
  /// </pre>
  /// </li>
  /// </ul>
  ///@param fontVariationSettings font variation settings. You can pass null or empty string as
  ///                              no variation settings.
  ///@return true if the given settings is effective to at least one font file underlying this
  ///         typeface. This function also returns true for empty settings string. Otherwise
  ///         returns false
  ///@throws IllegalArgumentException If given string is not a valid font variation settings
  ///                                  format
  ///@see \#getFontVariationSettings()
  ///@see FontVariationAxis
  bool setFontVariationSettings(jni.JniString fontVariationSettings) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFontVariationSettings,
          jni.JniType.booleanType, [fontVariationSettings.reference]).boolean;

  static final _id_ascent =
      jniAccessors.getMethodIDOf(_classRef, "ascent", "()F");

  /// from: public float ascent()
  ///
  /// Return the distance above (negative) the baseline (ascent) based on the
  /// current typeface and text size.
  ///
  /// Note that this is the ascent of the main typeface, and actual text rendered may need a
  /// larger ascent because fallback fonts may get used in rendering the text.
  ///@return the distance above (negative) the baseline (ascent) based on the
  ///         current typeface and text size.
  double ascent() => jniAccessors.callMethodWithArgs(
      reference, _id_ascent, jni.JniType.floatType, []).float;

  static final _id_descent =
      jniAccessors.getMethodIDOf(_classRef, "descent", "()F");

  /// from: public float descent()
  ///
  /// Return the distance below (positive) the baseline (descent) based on the
  /// current typeface and text size.
  ///
  /// Note that this is the descent of the main typeface, and actual text rendered may need a
  /// larger descent because fallback fonts may get used in rendering the text.
  ///@return the distance below (positive) the baseline (descent) based on
  ///         the current typeface and text size.
  double descent() => jniAccessors.callMethodWithArgs(
      reference, _id_descent, jni.JniType.floatType, []).float;

  static final _id_getFontMetrics = jniAccessors.getMethodIDOf(
      _classRef, "getFontMetrics", "(Landroid/graphics/Paint\$FontMetrics;)F");

  /// from: public float getFontMetrics(android.graphics.Paint.FontMetrics metrics)
  ///
  /// Return the font's recommended interline spacing, given the Paint's
  /// settings for typeface, textSize, etc. If metrics is not null, return the
  /// fontmetric values in it.
  ///
  /// Note that these are the values for the main typeface, and actual text rendered may need a
  /// larger set of values because fallback fonts may get used in rendering the text.
  ///@param metrics If this object is not null, its fields are filled with
  ///                the appropriate values given the paint's text attributes.
  ///@return the font's recommended interline spacing.
  double getFontMetrics(Paint_FontMetrics metrics) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFontMetrics,
          jni.JniType.floatType, [metrics.reference]).float;

  static final _id_getFontMetrics1 = jniAccessors.getMethodIDOf(
      _classRef, "getFontMetrics", "()Landroid/graphics/Paint\$FontMetrics;");

  /// from: public android.graphics.Paint.FontMetrics getFontMetrics()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Allocates a new FontMetrics object, and then calls getFontMetrics(fm)
  /// with it, returning the object.
  Paint_FontMetrics getFontMetrics1() =>
      Paint_FontMetrics.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFontMetrics1, jni.JniType.objectType, []).object);

  static final _id_getFontMetricsInt = jniAccessors.getMethodIDOf(_classRef,
      "getFontMetricsInt", "(Landroid/graphics/Paint\$FontMetricsInt;)I");

  /// from: public int getFontMetricsInt(android.graphics.Paint.FontMetricsInt fmi)
  ///
  /// Return the font's interline spacing, given the Paint's settings for
  /// typeface, textSize, etc. If metrics is not null, return the fontmetric
  /// values in it. Note: all values have been converted to integers from
  /// floats, in such a way has to make the answers useful for both spacing
  /// and clipping. If you want more control over the rounding, call
  /// getFontMetrics().
  ///
  /// Note that these are the values for the main typeface, and actual text rendered may need a
  /// larger set of values because fallback fonts may get used in rendering the text.
  ///@return the font's interline spacing.
  int getFontMetricsInt(Paint_FontMetricsInt fmi) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFontMetricsInt,
          jni.JniType.intType, [fmi.reference]).integer;

  static final _id_getFontMetricsInt1 = jniAccessors.getMethodIDOf(_classRef,
      "getFontMetricsInt", "()Landroid/graphics/Paint\$FontMetricsInt;");

  /// from: public android.graphics.Paint.FontMetricsInt getFontMetricsInt()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Paint_FontMetricsInt getFontMetricsInt1() =>
      Paint_FontMetricsInt.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFontMetricsInt1, jni.JniType.objectType, []).object);

  static final _id_getFontSpacing =
      jniAccessors.getMethodIDOf(_classRef, "getFontSpacing", "()F");

  /// from: public float getFontSpacing()
  ///
  /// Return the recommend line spacing based on the current typeface and
  /// text size.
  ///
  /// Note that this is the value for the main typeface, and actual text rendered may need a
  /// larger value because fallback fonts may get used in rendering the text.
  ///@return recommend line spacing based on the current typeface and
  ///          text size.
  double getFontSpacing() => jniAccessors.callMethodWithArgs(
      reference, _id_getFontSpacing, jni.JniType.floatType, []).float;

  static final _id_measureText =
      jniAccessors.getMethodIDOf(_classRef, "measureText", "([CII)F");

  /// from: public float measureText(char[] text, int index, int count)
  ///
  /// Return the width of the text.
  ///@param text The text to measure. Cannot be null.
  ///@param index The index of the first character to start measuring
  ///@param count THe number of characters to measure, beginning with start
  ///@return The width of the text
  double measureText(jni.JniObject text, int index, int count) =>
      jniAccessors.callMethodWithArgs(reference, _id_measureText,
          jni.JniType.floatType, [text.reference, index, count]).float;

  static final _id_measureText1 = jniAccessors.getMethodIDOf(
      _classRef, "measureText", "(Ljava/lang/String;II)F");

  /// from: public float measureText(java.lang.String text, int start, int end)
  ///
  /// Return the width of the text.
  ///@param text The text to measure. Cannot be null.
  ///@param start The index of the first character to start measuring
  ///@param end 1 beyond the index of the last character to measure
  ///@return The width of the text
  double measureText1(jni.JniString text, int start, int end) =>
      jniAccessors.callMethodWithArgs(reference, _id_measureText1,
          jni.JniType.floatType, [text.reference, start, end]).float;

  static final _id_measureText2 = jniAccessors.getMethodIDOf(
      _classRef, "measureText", "(Ljava/lang/String;)F");

  /// from: public float measureText(java.lang.String text)
  ///
  /// Return the width of the text.
  ///@param text The text to measure. Cannot be null.
  ///@return The width of the text
  double measureText2(jni.JniString text) => jniAccessors.callMethodWithArgs(
      reference,
      _id_measureText2,
      jni.JniType.floatType,
      [text.reference]).float;

  static final _id_measureText3 = jniAccessors.getMethodIDOf(
      _classRef, "measureText", "(Ljava/lang/CharSequence;II)F");

  /// from: public float measureText(java.lang.CharSequence text, int start, int end)
  ///
  /// Return the width of the text.
  ///@param text The text to measure
  ///@param start The index of the first character to start measuring
  ///@param end 1 beyond the index of the last character to measure
  ///@return The width of the text
  double measureText3(jni.JniObject text, int start, int end) =>
      jniAccessors.callMethodWithArgs(reference, _id_measureText3,
          jni.JniType.floatType, [text.reference, start, end]).float;

  static final _id_breakText =
      jniAccessors.getMethodIDOf(_classRef, "breakText", "([CIIF[F)I");

  /// from: public int breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)
  ///
  /// Measure the text, stopping early if the measured width exceeds maxWidth.
  /// Return the number of chars that were measured, and if measuredWidth is
  /// not null, return in it the actual width measured.
  ///@param text The text to measure. Cannot be null.
  ///@param index The offset into text to begin measuring at
  ///@param count The number of maximum number of entries to measure. If count
  ///              is negative, then the characters are measured in reverse order.
  ///@param maxWidth The maximum width to accumulate.
  ///@param measuredWidth Optional. If not null, returns the actual width
  ///                     measured.
  ///@return The number of chars that were measured. Will always be <=
  ///         abs(count).
  int breakText(jni.JniObject text, int index, int count, double maxWidth,
          jni.JniObject measuredWidth) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_breakText, jni.JniType.intType, [
        text.reference,
        index,
        count,
        maxWidth,
        measuredWidth.reference
      ]).integer;

  static final _id_breakText1 = jniAccessors.getMethodIDOf(
      _classRef, "breakText", "(Ljava/lang/CharSequence;IIZF[F)I");

  /// from: public int breakText(java.lang.CharSequence text, int start, int end, boolean measureForwards, float maxWidth, float[] measuredWidth)
  ///
  /// Measure the text, stopping early if the measured width exceeds maxWidth.
  /// Return the number of chars that were measured, and if measuredWidth is
  /// not null, return in it the actual width measured.
  ///@param text The text to measure. Cannot be null.
  ///@param start The offset into text to begin measuring at
  ///@param end The end of the text slice to measure.
  ///@param measureForwards If true, measure forwards, starting at start.
  ///                        Otherwise, measure backwards, starting with end.
  ///@param maxWidth The maximum width to accumulate.
  ///@param measuredWidth Optional. If not null, returns the actual width
  ///                     measured.
  ///@return The number of chars that were measured. Will always be <=
  ///         abs(end - start).
  int breakText1(jni.JniObject text, int start, int end, bool measureForwards,
          double maxWidth, jni.JniObject measuredWidth) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_breakText1, jni.JniType.intType, [
        text.reference,
        start,
        end,
        measureForwards,
        maxWidth,
        measuredWidth.reference
      ]).integer;

  static final _id_breakText2 = jniAccessors.getMethodIDOf(
      _classRef, "breakText", "(Ljava/lang/String;ZF[F)I");

  /// from: public int breakText(java.lang.String text, boolean measureForwards, float maxWidth, float[] measuredWidth)
  ///
  /// Measure the text, stopping early if the measured width exceeds maxWidth.
  /// Return the number of chars that were measured, and if measuredWidth is
  /// not null, return in it the actual width measured.
  ///@param text The text to measure. Cannot be null.
  ///@param measureForwards If true, measure forwards, starting with the
  ///                        first character in the string. Otherwise,
  ///                        measure backwards, starting with the
  ///                        last character in the string.
  ///@param maxWidth The maximum width to accumulate.
  ///@param measuredWidth Optional. If not null, returns the actual width
  ///                     measured.
  ///@return The number of chars that were measured. Will always be <=
  ///         abs(count).
  int breakText2(jni.JniString text, bool measureForwards, double maxWidth,
          jni.JniObject measuredWidth) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_breakText2, jni.JniType.intType, [
        text.reference,
        measureForwards,
        maxWidth,
        measuredWidth.reference
      ]).integer;

  static final _id_getTextWidths =
      jniAccessors.getMethodIDOf(_classRef, "getTextWidths", "([CII[F)I");

  /// from: public int getTextWidths(char[] text, int index, int count, float[] widths)
  ///
  /// Return the advance widths for the characters in the string.
  ///@param text The text to measure. Cannot be null.
  ///@param index The index of the first char to to measure
  ///@param count The number of chars starting with index to measure
  ///@param widths array to receive the advance widths of the characters.
  ///                 Must be at least a large as count.
  ///@return the actual number of widths returned.
  int getTextWidths(
          jni.JniObject text, int index, int count, jni.JniObject widths) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextWidths,
          jni.JniType.intType,
          [text.reference, index, count, widths.reference]).integer;

  static final _id_getTextWidths1 = jniAccessors.getMethodIDOf(
      _classRef, "getTextWidths", "(Ljava/lang/CharSequence;II[F)I");

  /// from: public int getTextWidths(java.lang.CharSequence text, int start, int end, float[] widths)
  ///
  /// Return the advance widths for the characters in the string.
  ///@param text The text to measure. Cannot be null.
  ///@param start The index of the first char to to measure
  ///@param end The end of the text slice to measure
  ///@param widths array to receive the advance widths of the characters.
  ///                 Must be at least a large as (end - start).
  ///@return the actual number of widths returned.
  int getTextWidths1(
          jni.JniObject text, int start, int end, jni.JniObject widths) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextWidths1,
          jni.JniType.intType,
          [text.reference, start, end, widths.reference]).integer;

  static final _id_getTextWidths2 = jniAccessors.getMethodIDOf(
      _classRef, "getTextWidths", "(Ljava/lang/String;II[F)I");

  /// from: public int getTextWidths(java.lang.String text, int start, int end, float[] widths)
  ///
  /// Return the advance widths for the characters in the string.
  ///@param text The text to measure. Cannot be null.
  ///@param start The index of the first char to to measure
  ///@param end The end of the text slice to measure
  ///@param widths array to receive the advance widths of the characters.
  ///               Must be at least a large as the text.
  ///@return the number of code units in the specified text.
  int getTextWidths2(
          jni.JniString text, int start, int end, jni.JniObject widths) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextWidths2,
          jni.JniType.intType,
          [text.reference, start, end, widths.reference]).integer;

  static final _id_getTextWidths3 = jniAccessors.getMethodIDOf(
      _classRef, "getTextWidths", "(Ljava/lang/String;[F)I");

  /// from: public int getTextWidths(java.lang.String text, float[] widths)
  ///
  /// Return the advance widths for the characters in the string.
  ///@param text The text to measure
  ///@param widths array to receive the advance widths of the characters.
  ///               Must be at least a large as the text.
  ///@return the number of code units in the specified text.
  int getTextWidths3(jni.JniString text, jni.JniObject widths) =>
      jniAccessors.callMethodWithArgs(reference, _id_getTextWidths3,
          jni.JniType.intType, [text.reference, widths.reference]).integer;

  static final _id_getTextPath = jniAccessors.getMethodIDOf(
      _classRef, "getTextPath", "([CIIFFLandroid/graphics/Path;)V");

  /// from: public void getTextPath(char[] text, int index, int count, float x, float y, android.graphics.Path path)
  ///
  /// Return the path (outline) for the specified text.
  /// Note: just like Canvas.drawText, this will respect the Align setting in
  /// the paint.
  ///@param text the text to retrieve the path from
  ///@param index the index of the first character in text
  ///@param count the number of characters starting with index
  ///@param x the x coordinate of the text's origin
  ///@param y the y coordinate of the text's origin
  ///@param path the path to receive the data describing the text. Must be allocated by the caller
  void getTextPath(jni.JniObject text, int index, int count, double x, double y,
          path_.Path path) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextPath,
          jni.JniType.voidType,
          [text.reference, index, count, x, y, path.reference]).check();

  static final _id_getTextPath1 = jniAccessors.getMethodIDOf(_classRef,
      "getTextPath", "(Ljava/lang/String;IIFFLandroid/graphics/Path;)V");

  /// from: public void getTextPath(java.lang.String text, int start, int end, float x, float y, android.graphics.Path path)
  ///
  /// Return the path (outline) for the specified text.
  /// Note: just like Canvas.drawText, this will respect the Align setting
  /// in the paint.
  ///@param text the text to retrieve the path from
  ///@param start the first character in the text
  ///@param end 1 past the last character in the text
  ///@param x the x coordinate of the text's origin
  ///@param y the y coordinate of the text's origin
  ///@param path the path to receive the data describing the text. Must be allocated by the caller
  void getTextPath1(jni.JniString text, int start, int end, double x, double y,
          path_.Path path) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextPath1,
          jni.JniType.voidType,
          [text.reference, start, end, x, y, path.reference]).check();

  static final _id_getTextBounds = jniAccessors.getMethodIDOf(_classRef,
      "getTextBounds", "(Ljava/lang/String;IILandroid/graphics/Rect;)V");

  /// from: public void getTextBounds(java.lang.String text, int start, int end, android.graphics.Rect bounds)
  ///
  /// Return in bounds (allocated by the caller) the smallest rectangle that
  /// encloses all of the characters, with an implied origin at (0,0).
  ///@param text string to measure and return its bounds
  ///@param start index of the first char in the string to measure
  ///@param end 1 past the last char in the string to measure
  ///@param bounds returns the unioned bounds of all the text. Must be allocated by the caller
  void getTextBounds(
          jni.JniString text, int start, int end, rect_.Rect bounds) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextBounds,
          jni.JniType.voidType,
          [text.reference, start, end, bounds.reference]).check();

  static final _id_getTextBounds1 = jniAccessors.getMethodIDOf(
      _classRef, "getTextBounds", "([CIILandroid/graphics/Rect;)V");

  /// from: public void getTextBounds(char[] text, int index, int count, android.graphics.Rect bounds)
  ///
  /// Return in bounds (allocated by the caller) the smallest rectangle that
  /// encloses all of the characters, with an implied origin at (0,0).
  ///@param text array of chars to measure and return their unioned bounds
  ///@param index index of the first char in the array to measure
  ///@param count the number of chars, beginning at index, to measure
  ///@param bounds returns the unioned bounds of all the text. Must be allocated by the caller
  void getTextBounds1(
          jni.JniObject text, int index, int count, rect_.Rect bounds) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextBounds1,
          jni.JniType.voidType,
          [text.reference, index, count, bounds.reference]).check();

  static final _id_hasGlyph = jniAccessors.getMethodIDOf(
      _classRef, "hasGlyph", "(Ljava/lang/String;)Z");

  /// from: public boolean hasGlyph(java.lang.String string)
  ///
  /// Determine whether the typeface set on the paint has a glyph supporting the string. The
  /// simplest case is when the string contains a single character, in which this method
  /// determines whether the font has the character. In the case of multiple characters, the
  /// method returns true if there is a single glyph representing the ligature. For example, if
  /// the input is a pair of regional indicator symbols, determine whether there is an emoji flag
  /// for the pair.
  ///
  /// Finally, if the string contains a variation selector, the method only returns true if
  /// the fonts contains a glyph specific to that variation.
  ///
  /// Checking is done on the entire fallback chain, not just the immediate font referenced.
  ///@param string the string to test whether there is glyph support
  ///@return true if the typeface has a glyph for the string
  bool hasGlyph(jni.JniString string) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasGlyph,
      jni.JniType.booleanType,
      [string.reference]).boolean;

  static final _id_getRunAdvance =
      jniAccessors.getMethodIDOf(_classRef, "getRunAdvance", "([CIIIIZI)F");

  /// from: public float getRunAdvance(char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)
  ///
  /// Measure cursor position within a run of text.
  ///
  /// The run of text includes the characters from {@code start} to {@code end} in the text. In
  /// addition, the range {@code contextStart} to {@code contextEnd} is used as context for the
  /// purpose of complex text shaping, such as Arabic text potentially shaped differently based on
  /// the text next to it.
  ///
  /// All text outside the range {@code contextStart..contextEnd} is ignored. The text between
  /// {@code start} and {@code end} will be laid out to be measured.
  ///
  /// The returned width measurement is the advance from {@code start} to {@code offset}. It is
  /// generally a positive value, no matter the direction of the run. If {@code offset == end},
  /// the return value is simply the width of the whole run from {@code start} to {@code end}.
  ///
  /// Ligatures are formed for characters in the range {@code start..end} (but not for
  /// {@code start..contextStart} or {@code end..contextEnd}). If {@code offset} points to a
  /// character in the middle of such a formed ligature, but at a grapheme cluster boundary, the
  /// return value will also reflect an advance in the middle of the ligature. See
  /// \#getOffsetForAdvance for more discussion of grapheme cluster boundaries.
  ///
  /// The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is
  /// suitable only for runs of a single direction.
  ///
  /// All indices are relative to the start of {@code text}. Further, {@code 0 <= contextStart
  /// <= start <= offset <= end <= contextEnd <= text.length} must hold on entry.
  ///@param text the text to measure. Cannot be null.
  ///@param start the index of the start of the range to measure
  ///@param end the index + 1 of the end of the range to measure
  ///@param contextStart the index of the start of the shaping context
  ///@param contextEnd the index + 1 of the end of the shaping context
  ///@param isRtl whether the run is in RTL direction
  ///@param offset index of caret position
  ///@return width measurement between start and offset
  double getRunAdvance(jni.JniObject text, int start, int end, int contextStart,
          int contextEnd, bool isRtl, int offset) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_getRunAdvance, jni.JniType.floatType, [
        text.reference,
        start,
        end,
        contextStart,
        contextEnd,
        isRtl,
        offset
      ]).float;

  static final _id_getRunAdvance1 = jniAccessors.getMethodIDOf(
      _classRef, "getRunAdvance", "(Ljava/lang/CharSequence;IIIIZI)F");

  /// from: public float getRunAdvance(java.lang.CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)
  ///
  /// @see \#getRunAdvance(char[], int, int, int, int, boolean, int)
  ///@param text the text to measure. Cannot be null.
  ///@param start the index of the start of the range to measure
  ///@param end the index + 1 of the end of the range to measure
  ///@param contextStart the index of the start of the shaping context
  ///@param contextEnd the index + 1 of the end of the shaping context
  ///@param isRtl whether the run is in RTL direction
  ///@param offset index of caret position
  ///@return width measurement between start and offset
  double getRunAdvance1(jni.JniObject text, int start, int end,
          int contextStart, int contextEnd, bool isRtl, int offset) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_getRunAdvance1, jni.JniType.floatType, [
        text.reference,
        start,
        end,
        contextStart,
        contextEnd,
        isRtl,
        offset
      ]).float;

  static final _id_getOffsetForAdvance = jniAccessors.getMethodIDOf(
      _classRef, "getOffsetForAdvance", "([CIIIIZF)I");

  /// from: public int getOffsetForAdvance(char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)
  ///
  /// Get the character offset within the string whose position is closest to the specified
  /// horizontal position.
  ///
  /// The returned value is generally the value of {@code offset} for which
  /// \#getRunAdvance yields a result most closely approximating {@code advance},
  /// and which is also on a grapheme cluster boundary. As such, it is the preferred method
  /// for positioning a cursor in response to a touch or pointer event. The grapheme cluster
  /// boundaries are based on
  /// <a href="http://unicode.org/reports/tr29/">Unicode Standard Annex \#29</a> but with some
  /// tailoring for better user experience.
  ///
  /// Note that {@code advance} is a (generally positive) width measurement relative to the start
  /// of the run. Thus, for RTL runs it the distance from the point to the right edge.
  ///
  /// All indices are relative to the start of {@code text}. Further, {@code 0 <= contextStart
  /// <= start <= end <= contextEnd <= text.length} must hold on entry, and {@code start <= result
  /// <= end} will hold on return.
  ///@param text the text to measure. Cannot be null.
  ///@param start the index of the start of the range to measure
  ///@param end the index + 1 of the end of the range to measure
  ///@param contextStart the index of the start of the shaping context
  ///@param contextEnd the index + 1 of the end of the range to measure
  ///@param isRtl whether the run is in RTL direction
  ///@param advance width relative to start of run
  ///@return index of offset
  int getOffsetForAdvance(jni.JniObject text, int start, int end,
          int contextStart, int contextEnd, bool isRtl, double advance) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_getOffsetForAdvance, jni.JniType.intType, [
        text.reference,
        start,
        end,
        contextStart,
        contextEnd,
        isRtl,
        advance
      ]).integer;

  static final _id_getOffsetForAdvance1 = jniAccessors.getMethodIDOf(
      _classRef, "getOffsetForAdvance", "(Ljava/lang/CharSequence;IIIIZF)I");

  /// from: public int getOffsetForAdvance(java.lang.CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)
  ///
  /// @see \#getOffsetForAdvance(char[], int, int, int, int, boolean, float)
  ///@param text the text to measure. Cannot be null.
  ///@param start the index of the start of the range to measure
  ///@param end the index + 1 of the end of the range to measure
  ///@param contextStart the index of the start of the shaping context
  ///@param contextEnd the index + 1 of the end of the range to measure
  ///@param isRtl whether the run is in RTL direction
  ///@param advance width relative to start of run
  ///@return index of offset
  int getOffsetForAdvance1(jni.JniObject text, int start, int end,
          int contextStart, int contextEnd, bool isRtl, double advance) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_getOffsetForAdvance1, jni.JniType.intType, [
        text.reference,
        start,
        end,
        contextStart,
        contextEnd,
        isRtl,
        advance
      ]).integer;

  static final _id_equalsForTextMeasurement = jniAccessors.getMethodIDOf(
      _classRef, "equalsForTextMeasurement", "(Landroid/graphics/Paint;)Z");

  /// from: public boolean equalsForTextMeasurement(android.graphics.Paint other)
  ///
  /// Returns true of the passed Paint will have the same effect on text measurement
  ///@param other A Paint object.
  /// This value must never be {@code null}.
  ///@return true if the other Paint has the same effect on text measurement.
  bool equalsForTextMeasurement(Paint other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equalsForTextMeasurement,
      jni.JniType.booleanType,
      [other.reference]).boolean;
}

/// from: android.graphics.Paint$Style
///
/// The Style specifies if the primitive being drawn is filled, stroked, or
/// both (in the same color). The default is FILL.
class Paint_Style extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Paint\$Style");
  Paint_Style.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Paint\$Style;");

  /// from: static public android.graphics.Paint.Style[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Paint\$Style;");

  /// from: static public android.graphics.Paint.Style valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Paint_Style valueOf(jni.JniString name) =>
      Paint_Style.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);
}

/// from: android.graphics.Paint$Join
///
/// The Join specifies the treatment where lines and curve segments
/// join on a stroked path. The default is MITER.
class Paint_Join extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Paint\$Join");
  Paint_Join.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Paint\$Join;");

  /// from: static public android.graphics.Paint.Join[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Paint\$Join;");

  /// from: static public android.graphics.Paint.Join valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Paint_Join valueOf(jni.JniString name) =>
      Paint_Join.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);
}

/// from: android.graphics.Paint$FontMetricsInt
///
/// Convenience method for callers that want to have FontMetrics values as
/// integers.
class Paint_FontMetricsInt extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Paint\$FontMetricsInt");
  Paint_FontMetricsInt.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ascent = jniAccessors.getFieldIDOf(_classRef, "ascent", "I");

  /// from: public int ascent
  ///
  /// The recommended distance above the baseline for singled spaced text.
  int get ascent =>
      jniAccessors.getField(reference, _id_ascent, jni.JniType.intType).integer;

  /// from: public int ascent
  ///
  /// The recommended distance above the baseline for singled spaced text.
  set ascent(int value) => jniEnv.SetIntField(reference, _id_ascent, value);

  static final _id_bottom = jniAccessors.getFieldIDOf(_classRef, "bottom", "I");

  /// from: public int bottom
  ///
  /// The maximum distance below the baseline for the lowest glyph in
  /// the font at a given text size.
  int get bottom =>
      jniAccessors.getField(reference, _id_bottom, jni.JniType.intType).integer;

  /// from: public int bottom
  ///
  /// The maximum distance below the baseline for the lowest glyph in
  /// the font at a given text size.
  set bottom(int value) => jniEnv.SetIntField(reference, _id_bottom, value);

  static final _id_descent =
      jniAccessors.getFieldIDOf(_classRef, "descent", "I");

  /// from: public int descent
  ///
  /// The recommended distance below the baseline for singled spaced text.
  int get descent => jniAccessors
      .getField(reference, _id_descent, jni.JniType.intType)
      .integer;

  /// from: public int descent
  ///
  /// The recommended distance below the baseline for singled spaced text.
  set descent(int value) => jniEnv.SetIntField(reference, _id_descent, value);

  static final _id_leading =
      jniAccessors.getFieldIDOf(_classRef, "leading", "I");

  /// from: public int leading
  ///
  /// The recommended additional space to add between lines of text.
  int get leading => jniAccessors
      .getField(reference, _id_leading, jni.JniType.intType)
      .integer;

  /// from: public int leading
  ///
  /// The recommended additional space to add between lines of text.
  set leading(int value) => jniEnv.SetIntField(reference, _id_leading, value);

  static final _id_top = jniAccessors.getFieldIDOf(_classRef, "top", "I");

  /// from: public int top
  ///
  /// The maximum distance above the baseline for the tallest glyph in
  /// the font at a given text size.
  int get top =>
      jniAccessors.getField(reference, _id_top, jni.JniType.intType).integer;

  /// from: public int top
  ///
  /// The maximum distance above the baseline for the tallest glyph in
  /// the font at a given text size.
  set top(int value) => jniEnv.SetIntField(reference, _id_top, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Paint_FontMetricsInt()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.graphics.Paint$FontMetrics
///
/// Class that describes the various metrics for a font at a given text size.
/// Remember, Y values increase going down, so those values will be positive,
/// and values that measure distances going up will be negative. This class
/// is returned by getFontMetrics().
class Paint_FontMetrics extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Paint\$FontMetrics");
  Paint_FontMetrics.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ascent = jniAccessors.getFieldIDOf(_classRef, "ascent", "F");

  /// from: public float ascent
  ///
  /// The recommended distance above the baseline for singled spaced text.
  double get ascent =>
      jniAccessors.getField(reference, _id_ascent, jni.JniType.floatType).float;

  /// from: public float ascent
  ///
  /// The recommended distance above the baseline for singled spaced text.
  set ascent(double value) =>
      jniEnv.SetFloatField(reference, _id_ascent, value);

  static final _id_bottom = jniAccessors.getFieldIDOf(_classRef, "bottom", "F");

  /// from: public float bottom
  ///
  /// The maximum distance below the baseline for the lowest glyph in
  /// the font at a given text size.
  double get bottom =>
      jniAccessors.getField(reference, _id_bottom, jni.JniType.floatType).float;

  /// from: public float bottom
  ///
  /// The maximum distance below the baseline for the lowest glyph in
  /// the font at a given text size.
  set bottom(double value) =>
      jniEnv.SetFloatField(reference, _id_bottom, value);

  static final _id_descent =
      jniAccessors.getFieldIDOf(_classRef, "descent", "F");

  /// from: public float descent
  ///
  /// The recommended distance below the baseline for singled spaced text.
  double get descent => jniAccessors
      .getField(reference, _id_descent, jni.JniType.floatType)
      .float;

  /// from: public float descent
  ///
  /// The recommended distance below the baseline for singled spaced text.
  set descent(double value) =>
      jniEnv.SetFloatField(reference, _id_descent, value);

  static final _id_leading =
      jniAccessors.getFieldIDOf(_classRef, "leading", "F");

  /// from: public float leading
  ///
  /// The recommended additional space to add between lines of text.
  double get leading => jniAccessors
      .getField(reference, _id_leading, jni.JniType.floatType)
      .float;

  /// from: public float leading
  ///
  /// The recommended additional space to add between lines of text.
  set leading(double value) =>
      jniEnv.SetFloatField(reference, _id_leading, value);

  static final _id_top = jniAccessors.getFieldIDOf(_classRef, "top", "F");

  /// from: public float top
  ///
  /// The maximum distance above the baseline for the tallest glyph in
  /// the font at a given text size.
  double get top =>
      jniAccessors.getField(reference, _id_top, jni.JniType.floatType).float;

  /// from: public float top
  ///
  /// The maximum distance above the baseline for the tallest glyph in
  /// the font at a given text size.
  set top(double value) => jniEnv.SetFloatField(reference, _id_top, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Paint_FontMetrics()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.graphics.Paint$Cap
///
/// The Cap specifies the treatment for the beginning and ending of
/// stroked lines and paths. The default is BUTT.
class Paint_Cap extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Paint\$Cap");
  Paint_Cap.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Paint\$Cap;");

  /// from: static public android.graphics.Paint.Cap[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Paint\$Cap;");

  /// from: static public android.graphics.Paint.Cap valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Paint_Cap valueOf(jni.JniString name) =>
      Paint_Cap.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);
}

/// from: android.graphics.Paint$Align
///
/// Align specifies how drawText aligns its text relative to the
/// [x,y] coordinates. The default is LEFT.
class Paint_Align extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Paint\$Align");
  Paint_Align.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Paint\$Align;");

  /// from: static public android.graphics.Paint.Align[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Paint\$Align;");

  /// from: static public android.graphics.Paint.Align valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Paint_Align valueOf(jni.JniString name) =>
      Paint_Align.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);
}
