// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "RectF.dart" as rectf_;

import "Matrix.dart" as matrix_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.graphics.Path
///
/// The Path class encapsulates compound (multiple contour) geometric paths
/// consisting of straight line segments, quadratic curves, and cubic curves.
/// It can be drawn with canvas.drawPath(path, paint), either filled or stroked
/// (based on the paint's Style), or it can be used for clipping or to draw
/// text on a path.
class Path extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Path");
  Path.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty path
  Path()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Path;)V");

  /// from: public void <init>(android.graphics.Path src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new path, copying the contents from the src path.
  ///@param src The path to copy from when initializing the new path
  Path.ctor1(Path src)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [src.reference]).object);

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Clear any lines and curves from the path, making it empty.
  /// This does NOT change the fill-type setting.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_rewind =
      jniAccessors.getMethodIDOf(_classRef, "rewind", "()V");

  /// from: public void rewind()
  ///
  /// Rewinds the path: clears any lines and curves from the path but
  /// keeps the internal data structure for faster reuse.
  void rewind() => jniAccessors.callMethodWithArgs(
      reference, _id_rewind, jni.JniType.voidType, []).check();

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(Landroid/graphics/Path;)V");

  /// from: public void set(android.graphics.Path src)
  ///
  /// Replace the contents of this with the contents of src.
  ///@param src This value must never be {@code null}.
  void set0(Path src) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.voidType, [src.reference]).check();

  static final _id_op = jniAccessors.getMethodIDOf(
      _classRef, "op", "(Landroid/graphics/Path;Landroid/graphics/Path\$Op;)Z");

  /// from: public boolean op(android.graphics.Path path, android.graphics.Path.Op op)
  ///
  /// Set this path to the result of applying the Op to this path and the specified path.
  /// The resulting path will be constructed from non-overlapping contours.
  /// The curve order is reduced where possible so that cubics may be turned
  /// into quadratics, and quadratics maybe turned into lines.
  ///@param path The second operand (for difference, the subtrahend)
  ///@return True if operation succeeded, false otherwise and this path remains unmodified.
  ///@see Op
  ///@see \#op(Path, Path, android.graphics.Path.Op)
  bool op(Path path, Path_Op op) => jniAccessors.callMethodWithArgs(reference,
      _id_op, jni.JniType.booleanType, [path.reference, op.reference]).boolean;

  static final _id_op1 = jniAccessors.getMethodIDOf(_classRef, "op",
      "(Landroid/graphics/Path;Landroid/graphics/Path;Landroid/graphics/Path\$Op;)Z");

  /// from: public boolean op(android.graphics.Path path1, android.graphics.Path path2, android.graphics.Path.Op op)
  ///
  /// Set this path to the result of applying the Op to the two specified paths.
  /// The resulting path will be constructed from non-overlapping contours.
  /// The curve order is reduced where possible so that cubics may be turned
  /// into quadratics, and quadratics maybe turned into lines.
  ///@param path1 The first operand (for difference, the minuend)
  ///@param path2 The second operand (for difference, the subtrahend)
  ///@return True if operation succeeded, false otherwise and this path remains unmodified.
  ///@see Op
  ///@see \#op(Path, android.graphics.Path.Op)
  bool op1(Path path1, Path path2, Path_Op op) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_op1,
          jni.JniType.booleanType,
          [path1.reference, path2.reference, op.reference]).boolean;

  static final _id_isConvex =
      jniAccessors.getMethodIDOf(_classRef, "isConvex", "()Z");

  /// from: public boolean isConvex()
  ///
  /// Returns the path's convexity, as defined by the content of the path.
  ///
  /// A path is convex if it has a single contour, and only ever curves in a
  /// single direction.
  ///
  /// This function will calculate the convexity of the path from its control
  /// points, and cache the result.
  ///@return True if the path is convex.
  bool isConvex() => jniAccessors.callMethodWithArgs(
      reference, _id_isConvex, jni.JniType.booleanType, []).boolean;

  static final _id_getFillType = jniAccessors.getMethodIDOf(
      _classRef, "getFillType", "()Landroid/graphics/Path\$FillType;");

  /// from: public android.graphics.Path.FillType getFillType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the path's fill type. This defines how "inside" is
  /// computed. The default value is WINDING.
  ///@return the path's fill type
  Path_FillType getFillType() =>
      Path_FillType.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFillType, jni.JniType.objectType, []).object);

  static final _id_setFillType = jniAccessors.getMethodIDOf(
      _classRef, "setFillType", "(Landroid/graphics/Path\$FillType;)V");

  /// from: public void setFillType(android.graphics.Path.FillType ft)
  ///
  /// Set the path's fill type. This defines how "inside" is computed.
  ///@param ft The new fill type for this path
  void setFillType(Path_FillType ft) => jniAccessors.callMethodWithArgs(
      reference, _id_setFillType, jni.JniType.voidType, [ft.reference]).check();

  static final _id_isInverseFillType =
      jniAccessors.getMethodIDOf(_classRef, "isInverseFillType", "()Z");

  /// from: public boolean isInverseFillType()
  ///
  /// Returns true if the filltype is one of the INVERSE variants
  ///@return true if the filltype is one of the INVERSE variants
  bool isInverseFillType() => jniAccessors.callMethodWithArgs(
      reference, _id_isInverseFillType, jni.JniType.booleanType, []).boolean;

  static final _id_toggleInverseFillType =
      jniAccessors.getMethodIDOf(_classRef, "toggleInverseFillType", "()V");

  /// from: public void toggleInverseFillType()
  ///
  /// Toggles the INVERSE state of the filltype
  void toggleInverseFillType() => jniAccessors.callMethodWithArgs(
      reference, _id_toggleInverseFillType, jni.JniType.voidType, []).check();

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public boolean isEmpty()
  ///
  /// Returns true if the path is empty (contains no lines or curves)
  ///@return true if the path is empty (contains no lines or curves)
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniType.booleanType, []).boolean;

  static final _id_isRect = jniAccessors.getMethodIDOf(
      _classRef, "isRect", "(Landroid/graphics/RectF;)Z");

  /// from: public boolean isRect(android.graphics.RectF rect)
  ///
  /// Returns true if the path specifies a rectangle. If so, and if rect is
  /// not null, set rect to the bounds of the path. If the path does not
  /// specify a rectangle, return false and ignore rect.
  ///@param rect If not null, returns the bounds of the path if it specifies
  ///             a rectangle
  /// This value may be {@code null}.
  ///@return true if the path specifies a rectangle
  bool isRect(rectf_.RectF rect) => jniAccessors.callMethodWithArgs(
      reference, _id_isRect, jni.JniType.booleanType, [rect.reference]).boolean;

  static final _id_computeBounds = jniAccessors.getMethodIDOf(
      _classRef, "computeBounds", "(Landroid/graphics/RectF;Z)V");

  /// from: public void computeBounds(android.graphics.RectF bounds, boolean exact)
  ///
  /// Compute the bounds of the control points of the path, and write the
  /// answer into bounds. If the path contains 0 or 1 points, the bounds is
  /// set to (0,0,0,0)
  ///@param bounds Returns the computed bounds of the path's control points.
  ///@param exact This parameter is no longer used.
  void computeBounds(rectf_.RectF bounds, bool exact) =>
      jniAccessors.callMethodWithArgs(reference, _id_computeBounds,
          jni.JniType.voidType, [bounds.reference, exact]).check();

  static final _id_incReserve =
      jniAccessors.getMethodIDOf(_classRef, "incReserve", "(I)V");

  /// from: public void incReserve(int extraPtCount)
  ///
  /// Hint to the path to prepare for adding more points. This can allow the
  /// path to more efficiently allocate its storage.
  ///@param extraPtCount The number of extra points that may be added to this
  ///                     path
  void incReserve(int extraPtCount) => jniAccessors.callMethodWithArgs(
      reference, _id_incReserve, jni.JniType.voidType, [extraPtCount]).check();

  static final _id_moveTo =
      jniAccessors.getMethodIDOf(_classRef, "moveTo", "(FF)V");

  /// from: public void moveTo(float x, float y)
  ///
  /// Set the beginning of the next contour to the point (x,y).
  ///@param x The x-coordinate of the start of a new contour
  ///@param y The y-coordinate of the start of a new contour
  void moveTo(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_moveTo, jni.JniType.voidType, [x, y]).check();

  static final _id_rMoveTo =
      jniAccessors.getMethodIDOf(_classRef, "rMoveTo", "(FF)V");

  /// from: public void rMoveTo(float dx, float dy)
  ///
  /// Set the beginning of the next contour relative to the last point on the
  /// previous contour. If there is no previous contour, this is treated the
  /// same as moveTo().
  ///@param dx The amount to add to the x-coordinate of the end of the
  ///           previous contour, to specify the start of a new contour
  ///@param dy The amount to add to the y-coordinate of the end of the
  ///           previous contour, to specify the start of a new contour
  void rMoveTo(double dx, double dy) => jniAccessors.callMethodWithArgs(
      reference, _id_rMoveTo, jni.JniType.voidType, [dx, dy]).check();

  static final _id_lineTo =
      jniAccessors.getMethodIDOf(_classRef, "lineTo", "(FF)V");

  /// from: public void lineTo(float x, float y)
  ///
  /// Add a line from the last point to the specified point (x,y).
  /// If no moveTo() call has been made for this contour, the first point is
  /// automatically set to (0,0).
  ///@param x The x-coordinate of the end of a line
  ///@param y The y-coordinate of the end of a line
  void lineTo(double x, double y) => jniAccessors.callMethodWithArgs(
      reference, _id_lineTo, jni.JniType.voidType, [x, y]).check();

  static final _id_rLineTo =
      jniAccessors.getMethodIDOf(_classRef, "rLineTo", "(FF)V");

  /// from: public void rLineTo(float dx, float dy)
  ///
  /// Same as lineTo, but the coordinates are considered relative to the last
  /// point on this contour. If there is no previous point, then a moveTo(0,0)
  /// is inserted automatically.
  ///@param dx The amount to add to the x-coordinate of the previous point on
  ///           this contour, to specify a line
  ///@param dy The amount to add to the y-coordinate of the previous point on
  ///           this contour, to specify a line
  void rLineTo(double dx, double dy) => jniAccessors.callMethodWithArgs(
      reference, _id_rLineTo, jni.JniType.voidType, [dx, dy]).check();

  static final _id_quadTo =
      jniAccessors.getMethodIDOf(_classRef, "quadTo", "(FFFF)V");

  /// from: public void quadTo(float x1, float y1, float x2, float y2)
  ///
  /// Add a quadratic bezier from the last point, approaching control point
  /// (x1,y1), and ending at (x2,y2). If no moveTo() call has been made for
  /// this contour, the first point is automatically set to (0,0).
  ///@param x1 The x-coordinate of the control point on a quadratic curve
  ///@param y1 The y-coordinate of the control point on a quadratic curve
  ///@param x2 The x-coordinate of the end point on a quadratic curve
  ///@param y2 The y-coordinate of the end point on a quadratic curve
  void quadTo(double x1, double y1, double x2, double y2) =>
      jniAccessors.callMethodWithArgs(reference, _id_quadTo,
          jni.JniType.voidType, [x1, y1, x2, y2]).check();

  static final _id_rQuadTo =
      jniAccessors.getMethodIDOf(_classRef, "rQuadTo", "(FFFF)V");

  /// from: public void rQuadTo(float dx1, float dy1, float dx2, float dy2)
  ///
  /// Same as quadTo, but the coordinates are considered relative to the last
  /// point on this contour. If there is no previous point, then a moveTo(0,0)
  /// is inserted automatically.
  ///@param dx1 The amount to add to the x-coordinate of the last point on
  ///            this contour, for the control point of a quadratic curve
  ///@param dy1 The amount to add to the y-coordinate of the last point on
  ///            this contour, for the control point of a quadratic curve
  ///@param dx2 The amount to add to the x-coordinate of the last point on
  ///            this contour, for the end point of a quadratic curve
  ///@param dy2 The amount to add to the y-coordinate of the last point on
  ///            this contour, for the end point of a quadratic curve
  void rQuadTo(double dx1, double dy1, double dx2, double dy2) =>
      jniAccessors.callMethodWithArgs(reference, _id_rQuadTo,
          jni.JniType.voidType, [dx1, dy1, dx2, dy2]).check();

  static final _id_cubicTo =
      jniAccessors.getMethodIDOf(_classRef, "cubicTo", "(FFFFFF)V");

  /// from: public void cubicTo(float x1, float y1, float x2, float y2, float x3, float y3)
  ///
  /// Add a cubic bezier from the last point, approaching control points
  /// (x1,y1) and (x2,y2), and ending at (x3,y3). If no moveTo() call has been
  /// made for this contour, the first point is automatically set to (0,0).
  ///@param x1 The x-coordinate of the 1st control point on a cubic curve
  ///@param y1 The y-coordinate of the 1st control point on a cubic curve
  ///@param x2 The x-coordinate of the 2nd control point on a cubic curve
  ///@param y2 The y-coordinate of the 2nd control point on a cubic curve
  ///@param x3 The x-coordinate of the end point on a cubic curve
  ///@param y3 The y-coordinate of the end point on a cubic curve
  void cubicTo(
          double x1, double y1, double x2, double y2, double x3, double y3) =>
      jniAccessors.callMethodWithArgs(reference, _id_cubicTo,
          jni.JniType.voidType, [x1, y1, x2, y2, x3, y3]).check();

  static final _id_rCubicTo =
      jniAccessors.getMethodIDOf(_classRef, "rCubicTo", "(FFFFFF)V");

  /// from: public void rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3)
  ///
  /// Same as cubicTo, but the coordinates are considered relative to the
  /// current point on this contour. If there is no previous point, then a
  /// moveTo(0,0) is inserted automatically.
  void rCubicTo(
          double x1, double y1, double x2, double y2, double x3, double y3) =>
      jniAccessors.callMethodWithArgs(reference, _id_rCubicTo,
          jni.JniType.voidType, [x1, y1, x2, y2, x3, y3]).check();

  static final _id_arcTo = jniAccessors.getMethodIDOf(
      _classRef, "arcTo", "(Landroid/graphics/RectF;FFZ)V");

  /// from: public void arcTo(android.graphics.RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo)
  ///
  /// Append the specified arc to the path as a new contour. If the start of
  /// the path is different from the path's current last point, then an
  /// automatic lineTo() is added to connect the current contour to the
  /// start of the arc. However, if the path is empty, then we call moveTo()
  /// with the first point of the arc.
  ///@param oval The bounds of oval defining shape and size of the arc
  ///@param startAngle Starting angle (in degrees) where the arc begins
  ///@param sweepAngle Sweep angle (in degrees) measured clockwise, treated
  ///                    mod 360.
  ///@param forceMoveTo If true, always begin a new contour with the arc
  void arcTo(rectf_.RectF oval, double startAngle, double sweepAngle,
          bool forceMoveTo) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_arcTo,
          jni.JniType.voidType,
          [oval.reference, startAngle, sweepAngle, forceMoveTo]).check();

  static final _id_arcTo1 = jniAccessors.getMethodIDOf(
      _classRef, "arcTo", "(Landroid/graphics/RectF;FF)V");

  /// from: public void arcTo(android.graphics.RectF oval, float startAngle, float sweepAngle)
  ///
  /// Append the specified arc to the path as a new contour. If the start of
  /// the path is different from the path's current last point, then an
  /// automatic lineTo() is added to connect the current contour to the
  /// start of the arc. However, if the path is empty, then we call moveTo()
  /// with the first point of the arc.
  ///@param oval The bounds of oval defining shape and size of the arc
  ///@param startAngle Starting angle (in degrees) where the arc begins
  ///@param sweepAngle Sweep angle (in degrees) measured clockwise
  void arcTo1(rectf_.RectF oval, double startAngle, double sweepAngle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_arcTo1,
          jni.JniType.voidType,
          [oval.reference, startAngle, sweepAngle]).check();

  static final _id_arcTo2 =
      jniAccessors.getMethodIDOf(_classRef, "arcTo", "(FFFFFFZ)V");

  /// from: public void arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo)
  ///
  /// Append the specified arc to the path as a new contour. If the start of
  /// the path is different from the path's current last point, then an
  /// automatic lineTo() is added to connect the current contour to the
  /// start of the arc. However, if the path is empty, then we call moveTo()
  /// with the first point of the arc.
  ///@param startAngle Starting angle (in degrees) where the arc begins
  ///@param sweepAngle Sweep angle (in degrees) measured clockwise, treated
  ///                    mod 360.
  ///@param forceMoveTo If true, always begin a new contour with the arc
  void arcTo2(double left, double top, double right, double bottom,
          double startAngle, double sweepAngle, bool forceMoveTo) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_arcTo2, jni.JniType.voidType, [
        left,
        top,
        right,
        bottom,
        startAngle,
        sweepAngle,
        forceMoveTo
      ]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close the current contour. If the current point is not equal to the
  /// first point of the contour, a line segment is automatically added.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_addRect = jniAccessors.getMethodIDOf(_classRef, "addRect",
      "(Landroid/graphics/RectF;Landroid/graphics/Path\$Direction;)V");

  /// from: public void addRect(android.graphics.RectF rect, android.graphics.Path.Direction dir)
  ///
  /// Add a closed rectangle contour to the path
  ///@param rect The rectangle to add as a closed contour to the path
  ///@param dir The direction to wind the rectangle's contour
  void addRect(rectf_.RectF rect, Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(reference, _id_addRect,
          jni.JniType.voidType, [rect.reference, dir.reference]).check();

  static final _id_addRect1 = jniAccessors.getMethodIDOf(
      _classRef, "addRect", "(FFFFLandroid/graphics/Path\$Direction;)V");

  /// from: public void addRect(float left, float top, float right, float bottom, android.graphics.Path.Direction dir)
  ///
  /// Add a closed rectangle contour to the path
  ///@param left The left side of a rectangle to add to the path
  ///@param top The top of a rectangle to add to the path
  ///@param right The right side of a rectangle to add to the path
  ///@param bottom The bottom of a rectangle to add to the path
  ///@param dir The direction to wind the rectangle's contour
  void addRect1(double left, double top, double right, double bottom,
          Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addRect1,
          jni.JniType.voidType,
          [left, top, right, bottom, dir.reference]).check();

  static final _id_addOval = jniAccessors.getMethodIDOf(_classRef, "addOval",
      "(Landroid/graphics/RectF;Landroid/graphics/Path\$Direction;)V");

  /// from: public void addOval(android.graphics.RectF oval, android.graphics.Path.Direction dir)
  ///
  /// Add a closed oval contour to the path
  ///@param oval The bounds of the oval to add as a closed contour to the path
  ///@param dir The direction to wind the oval's contour
  void addOval(rectf_.RectF oval, Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(reference, _id_addOval,
          jni.JniType.voidType, [oval.reference, dir.reference]).check();

  static final _id_addOval1 = jniAccessors.getMethodIDOf(
      _classRef, "addOval", "(FFFFLandroid/graphics/Path\$Direction;)V");

  /// from: public void addOval(float left, float top, float right, float bottom, android.graphics.Path.Direction dir)
  ///
  /// Add a closed oval contour to the path
  ///@param dir The direction to wind the oval's contour
  void addOval1(double left, double top, double right, double bottom,
          Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOval1,
          jni.JniType.voidType,
          [left, top, right, bottom, dir.reference]).check();

  static final _id_addCircle = jniAccessors.getMethodIDOf(
      _classRef, "addCircle", "(FFFLandroid/graphics/Path\$Direction;)V");

  /// from: public void addCircle(float x, float y, float radius, android.graphics.Path.Direction dir)
  ///
  /// Add a closed circle contour to the path
  ///@param x The x-coordinate of the center of a circle to add to the path
  ///@param y The y-coordinate of the center of a circle to add to the path
  ///@param radius The radius of a circle to add to the path
  ///@param dir The direction to wind the circle's contour
  void addCircle(double x, double y, double radius, Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(reference, _id_addCircle,
          jni.JniType.voidType, [x, y, radius, dir.reference]).check();

  static final _id_addArc = jniAccessors.getMethodIDOf(
      _classRef, "addArc", "(Landroid/graphics/RectF;FF)V");

  /// from: public void addArc(android.graphics.RectF oval, float startAngle, float sweepAngle)
  ///
  /// Add the specified arc to the path as a new contour.
  ///@param oval The bounds of oval defining the shape and size of the arc
  ///@param startAngle Starting angle (in degrees) where the arc begins
  ///@param sweepAngle Sweep angle (in degrees) measured clockwise
  void addArc(rectf_.RectF oval, double startAngle, double sweepAngle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addArc,
          jni.JniType.voidType,
          [oval.reference, startAngle, sweepAngle]).check();

  static final _id_addArc1 =
      jniAccessors.getMethodIDOf(_classRef, "addArc", "(FFFFFF)V");

  /// from: public void addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle)
  ///
  /// Add the specified arc to the path as a new contour.
  ///@param startAngle Starting angle (in degrees) where the arc begins
  ///@param sweepAngle Sweep angle (in degrees) measured clockwise
  void addArc1(double left, double top, double right, double bottom,
          double startAngle, double sweepAngle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addArc1,
          jni.JniType.voidType,
          [left, top, right, bottom, startAngle, sweepAngle]).check();

  static final _id_addRoundRect = jniAccessors.getMethodIDOf(
      _classRef,
      "addRoundRect",
      "(Landroid/graphics/RectF;FFLandroid/graphics/Path\$Direction;)V");

  /// from: public void addRoundRect(android.graphics.RectF rect, float rx, float ry, android.graphics.Path.Direction dir)
  ///
  /// Add a closed round-rectangle contour to the path
  ///@param rect The bounds of a round-rectangle to add to the path
  ///@param rx The x-radius of the rounded corners on the round-rectangle
  ///@param ry The y-radius of the rounded corners on the round-rectangle
  ///@param dir The direction to wind the round-rectangle's contour
  void addRoundRect(
          rectf_.RectF rect, double rx, double ry, Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addRoundRect,
          jni.JniType.voidType,
          [rect.reference, rx, ry, dir.reference]).check();

  static final _id_addRoundRect1 = jniAccessors.getMethodIDOf(
      _classRef, "addRoundRect", "(FFFFFFLandroid/graphics/Path\$Direction;)V");

  /// from: public void addRoundRect(float left, float top, float right, float bottom, float rx, float ry, android.graphics.Path.Direction dir)
  ///
  /// Add a closed round-rectangle contour to the path
  ///@param rx The x-radius of the rounded corners on the round-rectangle
  ///@param ry The y-radius of the rounded corners on the round-rectangle
  ///@param dir The direction to wind the round-rectangle's contour
  void addRoundRect1(double left, double top, double right, double bottom,
          double rx, double ry, Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addRoundRect1,
          jni.JniType.voidType,
          [left, top, right, bottom, rx, ry, dir.reference]).check();

  static final _id_addRoundRect2 = jniAccessors.getMethodIDOf(
      _classRef,
      "addRoundRect",
      "(Landroid/graphics/RectF;[FLandroid/graphics/Path\$Direction;)V");

  /// from: public void addRoundRect(android.graphics.RectF rect, float[] radii, android.graphics.Path.Direction dir)
  ///
  /// Add a closed round-rectangle contour to the path. Each corner receives
  /// two radius values [X, Y]. The corners are ordered top-left, top-right,
  /// bottom-right, bottom-left
  ///@param rect The bounds of a round-rectangle to add to the path
  ///@param radii Array of 8 values, 4 pairs of [X,Y] radii
  ///@param dir The direction to wind the round-rectangle's contour
  void addRoundRect2(
          rectf_.RectF rect, jni.JniObject radii, Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addRoundRect2,
          jni.JniType.voidType,
          [rect.reference, radii.reference, dir.reference]).check();

  static final _id_addRoundRect3 = jniAccessors.getMethodIDOf(
      _classRef, "addRoundRect", "(FFFF[FLandroid/graphics/Path\$Direction;)V");

  /// from: public void addRoundRect(float left, float top, float right, float bottom, float[] radii, android.graphics.Path.Direction dir)
  ///
  /// Add a closed round-rectangle contour to the path. Each corner receives
  /// two radius values [X, Y]. The corners are ordered top-left, top-right,
  /// bottom-right, bottom-left
  ///@param radii Array of 8 values, 4 pairs of [X,Y] radii
  ///@param dir The direction to wind the round-rectangle's contour
  void addRoundRect3(double left, double top, double right, double bottom,
          jni.JniObject radii, Path_Direction dir) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addRoundRect3,
          jni.JniType.voidType,
          [left, top, right, bottom, radii.reference, dir.reference]).check();

  static final _id_addPath = jniAccessors.getMethodIDOf(
      _classRef, "addPath", "(Landroid/graphics/Path;FF)V");

  /// from: public void addPath(android.graphics.Path src, float dx, float dy)
  ///
  /// Add a copy of src to the path, offset by (dx,dy)
  ///@param src The path to add as a new contour
  ///@param dx The amount to translate the path in X as it is added
  void addPath(Path src, double dx, double dy) =>
      jniAccessors.callMethodWithArgs(reference, _id_addPath,
          jni.JniType.voidType, [src.reference, dx, dy]).check();

  static final _id_addPath1 = jniAccessors.getMethodIDOf(
      _classRef, "addPath", "(Landroid/graphics/Path;)V");

  /// from: public void addPath(android.graphics.Path src)
  ///
  /// Add a copy of src to the path
  ///@param src The path that is appended to the current path
  void addPath1(Path src) => jniAccessors.callMethodWithArgs(
      reference, _id_addPath1, jni.JniType.voidType, [src.reference]).check();

  static final _id_addPath2 = jniAccessors.getMethodIDOf(_classRef, "addPath",
      "(Landroid/graphics/Path;Landroid/graphics/Matrix;)V");

  /// from: public void addPath(android.graphics.Path src, android.graphics.Matrix matrix)
  ///
  /// Add a copy of src to the path, transformed by matrix
  ///@param src The path to add as a new contour
  void addPath2(Path src, matrix_.Matrix matrix) =>
      jniAccessors.callMethodWithArgs(reference, _id_addPath2,
          jni.JniType.voidType, [src.reference, matrix.reference]).check();

  static final _id_offset = jniAccessors.getMethodIDOf(
      _classRef, "offset", "(FFLandroid/graphics/Path;)V");

  /// from: public void offset(float dx, float dy, android.graphics.Path dst)
  ///
  /// Offset the path by (dx,dy)
  ///@param dx The amount in the X direction to offset the entire path
  ///@param dy The amount in the Y direction to offset the entire path
  ///@param dst The translated path is written here. If this is null, then
  ///            the original path is modified.
  ///
  /// This value may be {@code null}.
  void offset(double dx, double dy, Path dst) =>
      jniAccessors.callMethodWithArgs(reference, _id_offset,
          jni.JniType.voidType, [dx, dy, dst.reference]).check();

  static final _id_offset1 =
      jniAccessors.getMethodIDOf(_classRef, "offset", "(FF)V");

  /// from: public void offset(float dx, float dy)
  ///
  /// Offset the path by (dx,dy)
  ///@param dx The amount in the X direction to offset the entire path
  ///@param dy The amount in the Y direction to offset the entire path
  void offset1(double dx, double dy) => jniAccessors.callMethodWithArgs(
      reference, _id_offset1, jni.JniType.voidType, [dx, dy]).check();

  static final _id_setLastPoint =
      jniAccessors.getMethodIDOf(_classRef, "setLastPoint", "(FF)V");

  /// from: public void setLastPoint(float dx, float dy)
  ///
  /// Sets the last point of the path.
  ///@param dx The new X coordinate for the last point
  ///@param dy The new Y coordinate for the last point
  void setLastPoint(double dx, double dy) => jniAccessors.callMethodWithArgs(
      reference, _id_setLastPoint, jni.JniType.voidType, [dx, dy]).check();

  static final _id_transform = jniAccessors.getMethodIDOf(_classRef,
      "transform", "(Landroid/graphics/Matrix;Landroid/graphics/Path;)V");

  /// from: public void transform(android.graphics.Matrix matrix, android.graphics.Path dst)
  ///
  /// Transform the points in this path by matrix, and write the answer
  /// into dst. If dst is null, then the the original path is modified.
  ///@param matrix The matrix to apply to the path
  ///@param dst The transformed path is written here. If dst is null,
  ///               then the the original path is modified
  void transform(matrix_.Matrix matrix, Path dst) =>
      jniAccessors.callMethodWithArgs(reference, _id_transform,
          jni.JniType.voidType, [matrix.reference, dst.reference]).check();

  static final _id_transform1 = jniAccessors.getMethodIDOf(
      _classRef, "transform", "(Landroid/graphics/Matrix;)V");

  /// from: public void transform(android.graphics.Matrix matrix)
  ///
  /// Transform the points in this path by matrix.
  ///@param matrix The matrix to apply to the path
  void transform1(matrix_.Matrix matrix) => jniAccessors.callMethodWithArgs(
      reference,
      _id_transform1,
      jni.JniType.voidType,
      [matrix.reference]).check();

  static final _id_approximate =
      jniAccessors.getMethodIDOf(_classRef, "approximate", "(F)[F");

  /// from: public float[] approximate(float acceptableError)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Approximate the <code>Path</code> with a series of line segments.
  /// This returns float[] with the array containing point components.
  /// There are three components for each point, in order:
  /// <ul>
  ///     <li>Fraction along the length of the path that the point resides</li>
  ///     <li>The x coordinate of the point</li>
  ///     <li>The y coordinate of the point</li>
  /// </ul>
  /// Two points may share the same fraction along its length when there is
  /// a move action within the Path.
  ///
  ///@param acceptableError The acceptable error for a line on the
  ///                        Path. Typically this would be 0.5 so that
  ///                        the error is less than half a pixel.
  /// Value is 0 or greater
  ///@return An array of components for points approximating the Path.
  ///
  /// This value will never be {@code null}.
  jni.JniObject approximate(double acceptableError) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_approximate, jni.JniType.objectType, [acceptableError]).object);
}

/// from: android.graphics.Path$Op
///
/// The logical operations that can be performed when combining two paths.
///@see \#op(Path, android.graphics.Path.Op)
///@see \#op(Path, Path, android.graphics.Path.Op)
class Path_Op extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/graphics/Path\$Op");
  Path_Op.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Path\$Op;");

  /// from: static public android.graphics.Path.Op[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(Ljava/lang/String;)Landroid/graphics/Path\$Op;");

  /// from: static public android.graphics.Path.Op valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Path_Op valueOf(jni.JniString name) =>
      Path_Op.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Path_Op()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.graphics.Path$FillType
///
/// Enum for the ways a path may be filled.
class Path_FillType extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Path\$FillType");
  Path_FillType.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Path\$FillType;");

  /// from: static public android.graphics.Path.FillType[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Path\$FillType;");

  /// from: static public android.graphics.Path.FillType valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Path_FillType valueOf(jni.JniString name) =>
      Path_FillType.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Path_FillType()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.graphics.Path$Direction
///
/// Specifies how closed shapes (e.g.&nbsp;rects, ovals) are oriented when they
/// are added to a path.
class Path_Direction extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/graphics/Path\$Direction");
  Path_Direction.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/graphics/Path\$Direction;");

  /// from: static public android.graphics.Path.Direction[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/graphics/Path\$Direction;");

  /// from: static public android.graphics.Path.Direction valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Path_Direction valueOf(jni.JniString name) =>
      Path_Direction.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Path_Direction()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
