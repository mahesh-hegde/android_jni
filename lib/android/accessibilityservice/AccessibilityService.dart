// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../app/Service.dart" as service_;

import "../view/accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "../view/KeyEvent.dart" as keyevent_;

import "../view/accessibility/AccessibilityNodeInfo.dart"
    as accessibilitynodeinfo_;

import "FingerprintGestureController.dart" as fingerprintgesturecontroller_;

import "GestureDescription.dart" as gesturedescription_;

import "../os/Handler.dart" as handler_;

import "AccessibilityButtonController.dart" as accessibilitybuttoncontroller_;

import "AccessibilityServiceInfo.dart" as accessibilityserviceinfo_;

import "../os/IBinder.dart" as ibinder_;

import "../content/Intent.dart" as intent_;

import "../graphics/Region.dart" as region_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.accessibilityservice.AccessibilityService
///
/// Accessibility services should only be used to assist users with disabilities in using
/// Android devices and apps. They run in the background and receive callbacks by the system
/// when AccessibilityEvents are fired. Such events denote some state transition
/// in the user interface, for example, the focus has changed, a button has been clicked,
/// etc. Such a service can optionally request the capability for querying the content
/// of the active window. Development of an accessibility service requires extending this
/// class and implementing its abstract methods.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating AccessibilityServices, read the
/// <a href="{@docRoot}guide/topics/ui/accessibility/index.html">Accessibility</a>
/// developer guide.
///
/// </div>
///
/// <h3>Lifecycle</h3>
///
/// The lifecycle of an accessibility service is managed exclusively by the system and
/// follows the established service life cycle. Starting an accessibility service is triggered
/// exclusively by the user explicitly turning the service on in device settings. After the system
/// binds to a service, it calls AccessibilityService\#onServiceConnected(). This method can
/// be overriden by clients that want to perform post binding setup.
///
///
///
/// An accessibility service stops either when the user turns it off in device settings or when
/// it calls AccessibilityService\#disableSelf().
///
///
/// <h3>Declaration</h3>
///
/// An accessibility is declared as any other service in an AndroidManifest.xml, but it
/// must do two things:
/// <ul>
///     <ol>
///         Specify that it handles the "android.accessibilityservice.AccessibilityService"
///         android.content.Intent.
///     </ol>
///     <ol>
///         Request the android.Manifest.permission\#BIND_ACCESSIBILITY_SERVICE permission to
///         ensure that only the system can bind to it.
///     </ol>
/// </ul>
/// If either of these items is missing, the system will ignore the accessibility service.
/// Following is an example declaration:
///
///
/// <pre> &lt;service android:name=".MyAccessibilityService"
///         android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"&gt;
///     &lt;intent-filter&gt;
///         &lt;action android:name="android.accessibilityservice.AccessibilityService" /&gt;
///     &lt;/intent-filter&gt;
///     . . .
/// &lt;/service&gt;</pre>
/// <h3>Configuration</h3>
///
/// An accessibility service can be configured to receive specific types of accessibility events,
/// listen only to specific packages, get events from each type only once in a given time frame,
/// retrieve window content, specify a settings activity, etc.
///
///
///
/// There are two approaches for configuring an accessibility service:
///
///
/// <ul>
/// <li>
/// Providing a \#SERVICE_META_DATA meta-data entry in the manifest when declaring
/// the service. A service declaration with a meta-data tag is presented below:
/// <pre> &lt;service android:name=".MyAccessibilityService"&gt;
///     &lt;intent-filter&gt;
///         &lt;action android:name="android.accessibilityservice.AccessibilityService" /&gt;
///     &lt;/intent-filter&gt;
///     &lt;meta-data android:name="android.accessibilityservice" android:resource="@xml/accessibilityservice" /&gt;
/// &lt;/service&gt;</pre>
/// <p class="note">
/// <strong>Note:</strong> This approach enables setting all properties.
///
///
///
/// For more details refer to \#SERVICE_META_DATA and
/// <code>&lt;android.R.styleable\#AccessibilityService accessibility-service&gt;</code>.
///
///
/// </li>
/// <li>
/// Calling AccessibilityService\#setServiceInfo(AccessibilityServiceInfo). Note
/// that this method can be called any time to dynamically change the service configuration.
/// <p class="note">
/// <strong>Note:</strong> This approach enables setting only dynamically configurable properties:
/// AccessibilityServiceInfo\#eventTypes,
/// AccessibilityServiceInfo\#feedbackType,
/// AccessibilityServiceInfo\#flags,
/// AccessibilityServiceInfo\#notificationTimeout,
/// AccessibilityServiceInfo\#packageNames
///
///
///
/// For more details refer to AccessibilityServiceInfo.
///
///
/// </li>
/// </ul>
/// <h3>Retrieving window content</h3>
///
/// A service can specify in its declaration that it can retrieve window
/// content which is represented as a tree of AccessibilityWindowInfo and
/// AccessibilityNodeInfo objects. Note that
/// declaring this capability requires that the service declares its configuration via
/// an XML resource referenced by \#SERVICE_META_DATA.
///
///
///
/// Window content may be retrieved with
/// AccessibilityEvent\#getSource() AccessibilityEvent.getSource(),
/// AccessibilityService\#findFocus(int),
/// AccessibilityService\#getWindows(), or
/// AccessibilityService\#getRootInActiveWindow().
///
///
/// <p class="note">
/// <strong>Note</strong> An accessibility service may have requested to be notified for
/// a subset of the event types, and thus be unaware when the node hierarchy has changed. It is also
/// possible for a node to contain outdated information because the window content may change at any
/// time.
///
///
/// <h3>Notification strategy</h3>
///
/// All accessibility services are notified of all events they have requested, regardless of their
/// feedback type.
///
///
/// <p class="note">
/// <strong>Note:</strong> The event notification timeout is useful to avoid propagating
/// events to the client too frequently since this is accomplished via an expensive
/// interprocess call. One can think of the timeout as a criteria to determine when
/// event generation has settled down.
///
/// <h3>Event types</h3>
/// <ul>
/// <li>AccessibilityEvent\#TYPE_VIEW_CLICKED</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_LONG_CLICKED</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_FOCUSED</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_SELECTED</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_TEXT_CHANGED</li>
/// <li>AccessibilityEvent\#TYPE_WINDOW_STATE_CHANGED</li>
/// <li>AccessibilityEvent\#TYPE_NOTIFICATION_STATE_CHANGED</li>
/// <li>AccessibilityEvent\#TYPE_TOUCH_EXPLORATION_GESTURE_START</li>
/// <li>AccessibilityEvent\#TYPE_TOUCH_EXPLORATION_GESTURE_END</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_HOVER_ENTER</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_HOVER_EXIT</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_SCROLLED</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_TEXT_SELECTION_CHANGED</li>
/// <li>AccessibilityEvent\#TYPE_WINDOW_CONTENT_CHANGED</li>
/// <li>AccessibilityEvent\#TYPE_ANNOUNCEMENT</li>
/// <li>AccessibilityEvent\#TYPE_GESTURE_DETECTION_START</li>
/// <li>AccessibilityEvent\#TYPE_GESTURE_DETECTION_END</li>
/// <li>AccessibilityEvent\#TYPE_TOUCH_INTERACTION_START</li>
/// <li>AccessibilityEvent\#TYPE_TOUCH_INTERACTION_END</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_ACCESSIBILITY_FOCUSED</li>
/// <li>AccessibilityEvent\#TYPE_WINDOWS_CHANGED</li>
/// <li>AccessibilityEvent\#TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED</li>
/// </ul>
/// <h3>Feedback types</h3>
/// <ul>
/// <li>AccessibilityServiceInfo\#FEEDBACK_AUDIBLE</li>
/// <li>AccessibilityServiceInfo\#FEEDBACK_HAPTIC</li>
/// <li>AccessibilityServiceInfo\#FEEDBACK_AUDIBLE</li>
/// <li>AccessibilityServiceInfo\#FEEDBACK_VISUAL</li>
/// <li>AccessibilityServiceInfo\#FEEDBACK_GENERIC</li>
/// <li>AccessibilityServiceInfo\#FEEDBACK_BRAILLE</li>
/// </ul>
///@see AccessibilityEvent
///@see AccessibilityServiceInfo
///@see android.view.accessibility.AccessibilityManager
class AccessibilityService extends service_.Service {
  static final _classRef = jniAccessors
      .getClassOf("android/accessibilityservice/AccessibilityService");
  AccessibilityService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int GESTURE_SWIPE_DOWN
  ///
  /// The user has performed a swipe down gesture on the touch screen.
  static const GESTURE_SWIPE_DOWN = 2;

  /// from: static public final int GESTURE_SWIPE_DOWN_AND_LEFT
  ///
  /// The user has performed an down and left gesture on the touch screen.
  static const GESTURE_SWIPE_DOWN_AND_LEFT = 15;

  /// from: static public final int GESTURE_SWIPE_DOWN_AND_RIGHT
  ///
  /// The user has performed an down and right gesture on the touch screen.
  static const GESTURE_SWIPE_DOWN_AND_RIGHT = 16;

  /// from: static public final int GESTURE_SWIPE_DOWN_AND_UP
  ///
  /// The user has performed a swipe down and up gesture on the touch screen.
  static const GESTURE_SWIPE_DOWN_AND_UP = 8;

  /// from: static public final int GESTURE_SWIPE_LEFT
  ///
  /// The user has performed a swipe left gesture on the touch screen.
  static const GESTURE_SWIPE_LEFT = 3;

  /// from: static public final int GESTURE_SWIPE_LEFT_AND_DOWN
  ///
  /// The user has performed a left and down gesture on the touch screen.
  static const GESTURE_SWIPE_LEFT_AND_DOWN = 10;

  /// from: static public final int GESTURE_SWIPE_LEFT_AND_RIGHT
  ///
  /// The user has performed a swipe left and right gesture on the touch screen.
  static const GESTURE_SWIPE_LEFT_AND_RIGHT = 5;

  /// from: static public final int GESTURE_SWIPE_LEFT_AND_UP
  ///
  /// The user has performed a left and up gesture on the touch screen.
  static const GESTURE_SWIPE_LEFT_AND_UP = 9;

  /// from: static public final int GESTURE_SWIPE_RIGHT
  ///
  /// The user has performed a swipe right gesture on the touch screen.
  static const GESTURE_SWIPE_RIGHT = 4;

  /// from: static public final int GESTURE_SWIPE_RIGHT_AND_DOWN
  ///
  /// The user has performed a right and down gesture on the touch screen.
  static const GESTURE_SWIPE_RIGHT_AND_DOWN = 12;

  /// from: static public final int GESTURE_SWIPE_RIGHT_AND_LEFT
  ///
  /// The user has performed a swipe right and left gesture on the touch screen.
  static const GESTURE_SWIPE_RIGHT_AND_LEFT = 6;

  /// from: static public final int GESTURE_SWIPE_RIGHT_AND_UP
  ///
  /// The user has performed a right and up gesture on the touch screen.
  static const GESTURE_SWIPE_RIGHT_AND_UP = 11;

  /// from: static public final int GESTURE_SWIPE_UP
  ///
  /// The user has performed a swipe up gesture on the touch screen.
  static const GESTURE_SWIPE_UP = 1;

  /// from: static public final int GESTURE_SWIPE_UP_AND_DOWN
  ///
  /// The user has performed a swipe up and down gesture on the touch screen.
  static const GESTURE_SWIPE_UP_AND_DOWN = 7;

  /// from: static public final int GESTURE_SWIPE_UP_AND_LEFT
  ///
  /// The user has performed an up and left gesture on the touch screen.
  static const GESTURE_SWIPE_UP_AND_LEFT = 13;

  /// from: static public final int GESTURE_SWIPE_UP_AND_RIGHT
  ///
  /// The user has performed an up and right gesture on the touch screen.
  static const GESTURE_SWIPE_UP_AND_RIGHT = 14;

  /// from: static public final int GLOBAL_ACTION_BACK
  ///
  /// Action to go back.
  static const GLOBAL_ACTION_BACK = 1;

  /// from: static public final int GLOBAL_ACTION_HOME
  ///
  /// Action to go home.
  static const GLOBAL_ACTION_HOME = 2;

  /// from: static public final int GLOBAL_ACTION_LOCK_SCREEN
  ///
  /// Action to lock the screen
  static const GLOBAL_ACTION_LOCK_SCREEN = 8;

  /// from: static public final int GLOBAL_ACTION_NOTIFICATIONS
  ///
  /// Action to open the notifications.
  static const GLOBAL_ACTION_NOTIFICATIONS = 4;

  /// from: static public final int GLOBAL_ACTION_POWER_DIALOG
  ///
  /// Action to open the power long-press dialog.
  static const GLOBAL_ACTION_POWER_DIALOG = 6;

  /// from: static public final int GLOBAL_ACTION_QUICK_SETTINGS
  ///
  /// Action to open the quick settings.
  static const GLOBAL_ACTION_QUICK_SETTINGS = 5;

  /// from: static public final int GLOBAL_ACTION_RECENTS
  ///
  /// Action to toggle showing the overview of recent apps. Will fail on platforms that don't
  /// show recent apps.
  static const GLOBAL_ACTION_RECENTS = 3;

  /// from: static public final int GLOBAL_ACTION_TAKE_SCREENSHOT
  ///
  /// Action to take a screenshot
  static const GLOBAL_ACTION_TAKE_SCREENSHOT = 9;

  /// from: static public final int GLOBAL_ACTION_TOGGLE_SPLIT_SCREEN
  ///
  /// Action to toggle docking the current app's window
  static const GLOBAL_ACTION_TOGGLE_SPLIT_SCREEN = 7;

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent that must be declared as handled by the service.
  static const SERVICE_INTERFACE =
      "android.accessibilityservice.AccessibilityService";

  /// from: static public final java.lang.String SERVICE_META_DATA
  ///
  /// Name under which an AccessibilityService component publishes information
  /// about itself. This meta-data must reference an XML resource containing an
  /// <code>&lt;android.R.styleable\#AccessibilityService accessibility-service&gt;</code>
  /// tag. This is a a sample XML file configuring an accessibility service:
  /// <pre> &lt;accessibility-service
  ///     android:accessibilityEventTypes="typeViewClicked|typeViewFocused"
  ///     android:packageNames="foo.bar, foo.baz"
  ///     android:accessibilityFeedbackType="feedbackSpoken"
  ///     android:notificationTimeout="100"
  ///     android:accessibilityFlags="flagDefault"
  ///     android:settingsActivity="foo.bar.TestBackActivity"
  ///     android:canRetrieveWindowContent="true"
  ///     android:canRequestTouchExplorationMode="true"
  ///     . . .
  /// /&gt;</pre>
  static const SERVICE_META_DATA = "android.accessibilityservice";

  /// from: static public final int SHOW_MODE_AUTO
  static const SHOW_MODE_AUTO = 0;

  /// from: static public final int SHOW_MODE_HIDDEN
  static const SHOW_MODE_HIDDEN = 1;

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AccessibilityService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onAccessibilityEvent",
      "(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public abstract void onAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Callback for android.view.accessibility.AccessibilityEvents.
  ///@param event The new event. This event is owned by the caller and cannot be used after
  /// this method returns. Services wishing to use the event after this method returns should
  /// make a copy.
  void onAccessibilityEvent(accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAccessibilityEvent,
          jni.JniType.voidType, [event.reference]).check();

  static final _id_onInterrupt =
      jniAccessors.getMethodIDOf(_classRef, "onInterrupt", "()V");

  /// from: public abstract void onInterrupt()
  ///
  /// Callback for interrupting the accessibility feedback.
  void onInterrupt() => jniAccessors.callMethodWithArgs(
      reference, _id_onInterrupt, jni.JniType.voidType, []).check();

  static final _id_onServiceConnected =
      jniAccessors.getMethodIDOf(_classRef, "onServiceConnected", "()V");

  /// from: protected void onServiceConnected()
  ///
  /// This method is a part of the AccessibilityService lifecycle and is
  /// called after the system has successfully bound to the service. If is
  /// convenient to use this method for setting the AccessibilityServiceInfo.
  ///@see AccessibilityServiceInfo
  ///@see \#setServiceInfo(AccessibilityServiceInfo)
  void onServiceConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_onServiceConnected, jni.JniType.voidType, []).check();

  static final _id_onGesture =
      jniAccessors.getMethodIDOf(_classRef, "onGesture", "(I)Z");

  /// from: protected boolean onGesture(int gestureId)
  ///
  /// Called by the system when the user performs a specific gesture on the
  /// touch screen.
  ///
  /// <strong>Note:</strong> To receive gestures an accessibility service must
  /// request that the device is in touch exploration mode by setting the
  /// android.accessibilityservice.AccessibilityServiceInfo\#FLAG_REQUEST_TOUCH_EXPLORATION_MODE
  /// flag.
  ///@param gestureId The unique id of the performed gesture.
  ///@return Whether the gesture was handled.
  ///@see \#GESTURE_SWIPE_UP
  ///@see \#GESTURE_SWIPE_UP_AND_LEFT
  ///@see \#GESTURE_SWIPE_UP_AND_DOWN
  ///@see \#GESTURE_SWIPE_UP_AND_RIGHT
  ///@see \#GESTURE_SWIPE_DOWN
  ///@see \#GESTURE_SWIPE_DOWN_AND_LEFT
  ///@see \#GESTURE_SWIPE_DOWN_AND_UP
  ///@see \#GESTURE_SWIPE_DOWN_AND_RIGHT
  ///@see \#GESTURE_SWIPE_LEFT
  ///@see \#GESTURE_SWIPE_LEFT_AND_UP
  ///@see \#GESTURE_SWIPE_LEFT_AND_RIGHT
  ///@see \#GESTURE_SWIPE_LEFT_AND_DOWN
  ///@see \#GESTURE_SWIPE_RIGHT
  ///@see \#GESTURE_SWIPE_RIGHT_AND_UP
  ///@see \#GESTURE_SWIPE_RIGHT_AND_LEFT
  ///@see \#GESTURE_SWIPE_RIGHT_AND_DOWN
  bool onGesture(int gestureId) => jniAccessors.callMethodWithArgs(
      reference, _id_onGesture, jni.JniType.booleanType, [gestureId]).boolean;

  static final _id_onKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "onKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: protected boolean onKeyEvent(android.view.KeyEvent event)
  ///
  /// Callback that allows an accessibility service to observe the key events
  /// before they are passed to the rest of the system. This means that the events
  /// are first delivered here before they are passed to the device policy, the
  /// input method, or applications.
  ///
  /// <strong>Note:</strong> It is important that key events are handled in such
  /// a way that the event stream that would be passed to the rest of the system
  /// is well-formed. For example, handling the down event but not the up event
  /// and vice versa would generate an inconsistent event stream.
  ///
  ///
  ///
  /// <strong>Note:</strong> The key events delivered in this method are copies
  /// and modifying them will have no effect on the events that will be passed
  /// to the system. This method is intended to perform purely filtering
  /// functionality.
  ///
  ///@param event The event to be processed. This event is owned by the caller and cannot be used
  /// after this method returns. Services wishing to use the event after this method returns should
  /// make a copy.
  ///@return If true then the event will be consumed and not delivered to
  ///         applications, otherwise it will be delivered as usual.
  bool onKeyEvent(keyevent_.KeyEvent event) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onKeyEvent,
      jni.JniType.booleanType,
      [event.reference]).boolean;

  static final _id_getWindows =
      jniAccessors.getMethodIDOf(_classRef, "getWindows", "()Ljava/util/List;");

  /// from: public java.util.List<android.view.accessibility.AccessibilityWindowInfo> getWindows()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the windows on the screen. This method returns only the windows
  /// that a sighted user can interact with, as opposed to all windows.
  /// For example, if there is a modal dialog shown and the user cannot touch
  /// anything behind it, then only the modal window will be reported
  /// (assuming it is the top one). For convenience the returned windows
  /// are ordered in a descending layer order, which is the windows that
  /// are on top are reported first. Since the user can always
  /// interact with the window that has input focus by typing, the focused
  /// window is always returned (even if covered by a modal window).
  ///
  /// <strong>Note:</strong> In order to access the windows your service has
  /// to declare the capability to retrieve window content by setting the
  /// android.R.styleable\#AccessibilityService_canRetrieveWindowContent
  /// property in its meta-data. For details refer to \#SERVICE_META_DATA.
  /// Also the service has to opt-in to retrieve the interactive windows by
  /// setting the AccessibilityServiceInfo\#FLAG_RETRIEVE_INTERACTIVE_WINDOWS
  /// flag.
  ///
  ///
  ///@return The windows if there are windows and the service is can retrieve
  ///         them, otherwise an empty list.
  jni.JniObject getWindows() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindows, jni.JniType.objectType, []).object);

  static final _id_getRootInActiveWindow = jniAccessors.getMethodIDOf(
      _classRef,
      "getRootInActiveWindow",
      "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo getRootInActiveWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the root node in the currently active window if this service
  /// can retrieve window content. The active window is the one that the user
  /// is currently touching or the window with input focus, if the user is not
  /// touching any window.
  ///
  /// The currently active window is defined as the window that most recently fired one
  /// of the following events:
  /// AccessibilityEvent\#TYPE_WINDOW_STATE_CHANGED,
  /// AccessibilityEvent\#TYPE_VIEW_HOVER_ENTER,
  /// AccessibilityEvent\#TYPE_VIEW_HOVER_EXIT.
  /// In other words, the last window shown that also has input focus.
  ///
  ///
  ///
  /// <strong>Note:</strong> In order to access the root node your service has
  /// to declare the capability to retrieve window content by setting the
  /// android.R.styleable\#AccessibilityService_canRetrieveWindowContent
  /// property in its meta-data. For details refer to \#SERVICE_META_DATA.
  ///
  ///
  ///@return The root node if this service can retrieve window content.
  accessibilitynodeinfo_.AccessibilityNodeInfo getRootInActiveWindow() =>
      accessibilitynodeinfo_.AccessibilityNodeInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getRootInActiveWindow,
              jni.JniType.objectType, []).object);

  static final _id_disableSelf =
      jniAccessors.getMethodIDOf(_classRef, "disableSelf", "()V");

  /// from: public final void disableSelf()
  ///
  /// Disables the service. After calling this method, the service will be disabled and settings
  /// will show that it is turned off.
  void disableSelf() => jniAccessors.callMethodWithArgs(
      reference, _id_disableSelf, jni.JniType.voidType, []).check();

  static final _id_getMagnificationController = jniAccessors.getMethodIDOf(
      _classRef,
      "getMagnificationController",
      "()Landroid/accessibilityservice/AccessibilityService\$MagnificationController;");

  /// from: public final android.accessibilityservice.AccessibilityService.MagnificationController getMagnificationController()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the magnification controller, which may be used to query and
  /// modify the state of display magnification.
  ///
  /// <strong>Note:</strong> In order to control magnification, your service
  /// must declare the capability by setting the
  /// android.R.styleable\#AccessibilityService_canControlMagnification
  /// property in its meta-data. For more information, see
  /// \#SERVICE_META_DATA.
  ///@return the magnification controller
  ///
  /// This value will never be {@code null}.
  AccessibilityService_MagnificationController getMagnificationController() =>
      AccessibilityService_MagnificationController.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getMagnificationController,
              jni.JniType.objectType, []).object);

  static final _id_getFingerprintGestureController = jniAccessors.getMethodIDOf(
      _classRef,
      "getFingerprintGestureController",
      "()Landroid/accessibilityservice/FingerprintGestureController;");

  /// from: public final android.accessibilityservice.FingerprintGestureController getFingerprintGestureController()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the controller for fingerprint gestures. This feature requires AccessibilityServiceInfo\#CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES.
  ///
  ///<strong>Note: </strong> The service must be connected before this method is called.
  ///
  /// Requires android.Manifest.permission\#USE_FINGERPRINT
  ///@return The controller for fingerprint gestures, or {@code null} if gestures are unavailable.
  fingerprintgesturecontroller_.FingerprintGestureController
      getFingerprintGestureController() =>
          fingerprintgesturecontroller_.FingerprintGestureController.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_getFingerprintGestureController,
                  jni.JniType.objectType, []).object);

  static final _id_dispatchGesture = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchGesture",
      "(Landroid/accessibilityservice/GestureDescription;Landroid/accessibilityservice/AccessibilityService\$GestureResultCallback;Landroid/os/Handler;)Z");

  /// from: public final boolean dispatchGesture(android.accessibilityservice.GestureDescription gesture, android.accessibilityservice.AccessibilityService.GestureResultCallback callback, android.os.Handler handler)
  ///
  /// Dispatch a gesture to the touch screen. Any gestures currently in progress, whether from
  /// the user, this service, or another service, will be cancelled.
  ///
  /// The gesture will be dispatched as if it were performed directly on the screen by a user, so
  /// the events may be affected by features such as magnification and explore by touch.
  ///
  ///
  ///
  /// <strong>Note:</strong> In order to dispatch gestures, your service
  /// must declare the capability by setting the
  /// android.R.styleable\#AccessibilityService_canPerformGestures
  /// property in its meta-data. For more information, see
  /// \#SERVICE_META_DATA.
  ///
  ///
  ///@param gesture The gesture to dispatch
  /// This value must never be {@code null}.
  ///@param callback The object to call back when the status of the gesture is known. If
  /// {@code null}, no status is reported.
  /// This value may be {@code null}.
  ///@param handler The handler on which to call back the {@code callback} object. If
  /// {@code null}, the object is called back on the service's main thread.
  ///
  /// This value may be {@code null}.
  ///@return {@code true} if the gesture is dispatched, {@code false} if not.
  bool dispatchGesture(
          gesturedescription_.GestureDescription gesture,
          AccessibilityService_GestureResultCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchGesture,
          jni.JniType.booleanType,
          [gesture.reference, callback.reference, handler.reference]).boolean;

  static final _id_getSoftKeyboardController = jniAccessors.getMethodIDOf(
      _classRef,
      "getSoftKeyboardController",
      "()Landroid/accessibilityservice/AccessibilityService\$SoftKeyboardController;");

  /// from: public final android.accessibilityservice.AccessibilityService.SoftKeyboardController getSoftKeyboardController()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the soft keyboard controller, which may be used to query and modify the soft keyboard
  /// show mode.
  ///@return the soft keyboard controller
  ///
  /// This value will never be {@code null}.
  AccessibilityService_SoftKeyboardController getSoftKeyboardController() =>
      AccessibilityService_SoftKeyboardController.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getSoftKeyboardController,
              jni.JniType.objectType, []).object);

  static final _id_getAccessibilityButtonController =
      jniAccessors.getMethodIDOf(_classRef, "getAccessibilityButtonController",
          "()Landroid/accessibilityservice/AccessibilityButtonController;");

  /// from: public final android.accessibilityservice.AccessibilityButtonController getAccessibilityButtonController()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the controller for the accessibility button within the system's navigation area.
  /// This instance may be used to query the accessibility button's state and register listeners
  /// for interactions with and state changes for the accessibility button when
  /// AccessibilityServiceInfo\#FLAG_REQUEST_ACCESSIBILITY_BUTTON is set.
  ///
  /// <strong>Note:</strong> Not all devices are capable of displaying the accessibility button
  /// within a navigation area, and as such, use of this class should be considered only as an
  /// optional feature or shortcut on supported device implementations.
  ///
  ///
  ///@return the accessibility button controller for this AccessibilityService
  ///
  /// This value will never be {@code null}.
  accessibilitybuttoncontroller_.AccessibilityButtonController
      getAccessibilityButtonController() =>
          accessibilitybuttoncontroller_.AccessibilityButtonController.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_getAccessibilityButtonController,
                  jni.JniType.objectType, []).object);

  static final _id_performGlobalAction =
      jniAccessors.getMethodIDOf(_classRef, "performGlobalAction", "(I)Z");

  /// from: public final boolean performGlobalAction(int action)
  ///
  /// Performs a global action. Such an action can be performed
  /// at any moment regardless of the current application or user
  /// location in that application. For example going back, going
  /// home, opening recents, etc.
  ///@param action The action to perform.
  ///@return Whether the action was successfully performed.
  ///@see \#GLOBAL_ACTION_BACK
  ///@see \#GLOBAL_ACTION_HOME
  ///@see \#GLOBAL_ACTION_NOTIFICATIONS
  ///@see \#GLOBAL_ACTION_RECENTS
  bool performGlobalAction(int action) => jniAccessors.callMethodWithArgs(
      reference,
      _id_performGlobalAction,
      jni.JniType.booleanType,
      [action]).boolean;

  static final _id_findFocus = jniAccessors.getMethodIDOf(_classRef,
      "findFocus", "(I)Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo findFocus(int focus)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the view that has the specified focus type. The search is performed
  /// across all windows.
  ///
  /// <strong>Note:</strong> In order to access the windows your service has
  /// to declare the capability to retrieve window content by setting the
  /// android.R.styleable\#AccessibilityService_canRetrieveWindowContent
  /// property in its meta-data. For details refer to \#SERVICE_META_DATA.
  /// Also the service has to opt-in to retrieve the interactive windows by
  /// setting the AccessibilityServiceInfo\#FLAG_RETRIEVE_INTERACTIVE_WINDOWS
  /// flag. Otherwise, the search will be performed only in the active window.
  ///
  ///
  ///@param focus The focus to find. One of AccessibilityNodeInfo\#FOCUS_INPUT or
  ///         AccessibilityNodeInfo\#FOCUS_ACCESSIBILITY.
  ///@return The node info of the focused view or null.
  ///@see AccessibilityNodeInfo\#FOCUS_INPUT
  ///@see AccessibilityNodeInfo\#FOCUS_ACCESSIBILITY
  accessibilitynodeinfo_.AccessibilityNodeInfo findFocus(int focus) =>
      accessibilitynodeinfo_.AccessibilityNodeInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_findFocus, jni.JniType.objectType,
              [focus]).object);

  static final _id_getServiceInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getServiceInfo",
      "()Landroid/accessibilityservice/AccessibilityServiceInfo;");

  /// from: public final android.accessibilityservice.AccessibilityServiceInfo getServiceInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the an AccessibilityServiceInfo describing this
  /// AccessibilityService. This method is useful if one wants
  /// to change some of the dynamically configurable properties at
  /// runtime.
  ///@return The accessibility service info.
  ///@see AccessibilityServiceInfo
  accessibilityserviceinfo_.AccessibilityServiceInfo getServiceInfo() =>
      accessibilityserviceinfo_.AccessibilityServiceInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getServiceInfo,
              jni.JniType.objectType, []).object);

  static final _id_setServiceInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "setServiceInfo",
      "(Landroid/accessibilityservice/AccessibilityServiceInfo;)V");

  /// from: public final void setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo info)
  ///
  /// Sets the AccessibilityServiceInfo that describes this service.
  ///
  /// Note: You can call this method any time but the info will be picked up after
  ///       the system has bound to this service and when this method is called thereafter.
  ///@param info The info.
  void setServiceInfo(
          accessibilityserviceinfo_.AccessibilityServiceInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_setServiceInfo,
          jni.JniType.voidType, [info.reference]).check();

  static final _id_getSystemService2 = jniAccessors.getMethodIDOf(
      _classRef, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");

  /// from: public java.lang.Object getSystemService(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param name Value is android.content.Context\#POWER_SERVICE, android.content.Context\#WINDOW_SERVICE, android.content.Context\#LAYOUT_INFLATER_SERVICE, android.content.Context\#ACCOUNT_SERVICE, android.content.Context\#ACTIVITY_SERVICE, android.content.Context\#ALARM_SERVICE, android.content.Context\#NOTIFICATION_SERVICE, android.content.Context\#ACCESSIBILITY_SERVICE, android.content.Context\#CAPTIONING_SERVICE, android.content.Context\#KEYGUARD_SERVICE, android.content.Context\#LOCATION_SERVICE, android.content.Context\#SEARCH_SERVICE, android.content.Context\#SENSOR_SERVICE, android.content.Context\#STORAGE_SERVICE, android.content.Context\#STORAGE_STATS_SERVICE, android.content.Context\#WALLPAPER_SERVICE, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, android.content.Context\#VIBRATOR_SERVICE, android.content.Context\#CONNECTIVITY_SERVICE, android.content.Context\#IPSEC_SERVICE, android.content.Context\#NETWORK_STATS_SERVICE, android.content.Context\#WIFI_SERVICE, android.content.Context\#WIFI_AWARE_SERVICE, android.content.Context\#WIFI_P2P_SERVICE, android.content.Context.WIFI_SCANNING_SERVICE, android.content.Context\#WIFI_RTT_RANGING_SERVICE, android.content.Context\#NSD_SERVICE, android.content.Context\#AUDIO_SERVICE, android.content.Context\#FINGERPRINT_SERVICE, android.content.Context\#MEDIA_ROUTER_SERVICE, android.content.Context\#TELEPHONY_SERVICE, android.content.Context\#TELEPHONY_SUBSCRIPTION_SERVICE, android.content.Context\#CARRIER_CONFIG_SERVICE, android.content.Context\#TELECOM_SERVICE, android.content.Context\#CLIPBOARD_SERVICE, android.content.Context\#INPUT_METHOD_SERVICE, android.content.Context\#TEXT_SERVICES_MANAGER_SERVICE, android.content.Context\#TEXT_CLASSIFICATION_SERVICE, android.content.Context\#APPWIDGET_SERVICE, android.content.Context\#DROPBOX_SERVICE, android.content.Context\#DEVICE_POLICY_SERVICE, android.content.Context\#UI_MODE_SERVICE, android.content.Context\#DOWNLOAD_SERVICE, android.content.Context\#NFC_SERVICE, android.content.Context\#BLUETOOTH_SERVICE, android.content.Context\#USB_SERVICE, android.content.Context\#LAUNCHER_APPS_SERVICE, android.content.Context\#INPUT_SERVICE, android.content.Context\#DISPLAY_SERVICE, android.content.Context\#USER_SERVICE, android.content.Context\#RESTRICTIONS_SERVICE, android.content.Context\#APP_OPS_SERVICE, android.content.Context\#CAMERA_SERVICE, android.content.Context\#PRINT_SERVICE, android.content.Context\#CONSUMER_IR_SERVICE, android.content.Context\#TV_INPUT_SERVICE, android.content.Context\#USAGE_STATS_SERVICE, android.content.Context\#MEDIA_SESSION_SERVICE, android.content.Context\#BATTERY_SERVICE, android.content.Context\#JOB_SCHEDULER_SERVICE, android.content.Context\#MEDIA_PROJECTION_SERVICE, android.content.Context\#MIDI_SERVICE, android.content.Context.RADIO_SERVICE, android.content.Context\#HARDWARE_PROPERTIES_SERVICE, android.content.Context\#SHORTCUT_SERVICE, android.content.Context\#SYSTEM_HEALTH_SERVICE, android.content.Context\#COMPANION_DEVICE_SERVICE, or android.content.Context\#CROSS_PROFILE_APPS_SERVICE
  ///
  /// This value must never be {@code null}.
  jni.JniObject getSystemService2(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSystemService2,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement to return the implementation of the internal accessibility
  /// service interface.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);
}

/// from: android.accessibilityservice.AccessibilityService$SoftKeyboardController
///
/// Used to control and query the soft keyboard show mode.
class AccessibilityService_SoftKeyboardController extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/accessibilityservice/AccessibilityService\$SoftKeyboardController");
  AccessibilityService_SoftKeyboardController.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/accessibilityservice/AccessibilityService;Ljava/lang/Object;)V");

  /// from: void <init>(android.accessibilityservice.AccessibilityService service, java.lang.Object lock)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AccessibilityService_SoftKeyboardController(
      AccessibilityService service, jni.JniObject lock)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [service.reference, lock.reference]).object);

  static final _id_addOnShowModeChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnShowModeChangedListener",
      "(Landroid/accessibilityservice/AccessibilityService\$SoftKeyboardController\$OnShowModeChangedListener;)V");

  /// from: public void addOnShowModeChangedListener(android.accessibilityservice.AccessibilityService.SoftKeyboardController.OnShowModeChangedListener listener)
  ///
  /// Adds the specified change listener to the list of show mode change listeners. The
  /// callback will occur on the service's main thread. Listener is not called on registration.
  ///@param listener This value must never be {@code null}.
  void addOnShowModeChangedListener(
          AccessibilityService_SoftKeyboardController_OnShowModeChangedListener
              listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnShowModeChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_addOnShowModeChangedListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnShowModeChangedListener",
      "(Landroid/accessibilityservice/AccessibilityService\$SoftKeyboardController\$OnShowModeChangedListener;Landroid/os/Handler;)V");

  /// from: public void addOnShowModeChangedListener(android.accessibilityservice.AccessibilityService.SoftKeyboardController.OnShowModeChangedListener listener, android.os.Handler handler)
  ///
  /// Adds the specified change listener to the list of soft keyboard show mode change
  /// listeners. The callback will occur on the specified Handler's thread, or on the
  /// services's main thread if the handler is {@code null}.
  ///@param listener the listener to add, must be non-null
  /// This value must never be {@code null}.
  ///@param handler the handler on which to callback should execute, or {@code null} to
  ///        execute on the service's main thread
  ///
  /// This value may be {@code null}.
  void addOnShowModeChangedListener1(
          AccessibilityService_SoftKeyboardController_OnShowModeChangedListener
              listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnShowModeChangedListener1,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeOnShowModeChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnShowModeChangedListener",
      "(Landroid/accessibilityservice/AccessibilityService\$SoftKeyboardController\$OnShowModeChangedListener;)Z");

  /// from: public boolean removeOnShowModeChangedListener(android.accessibilityservice.AccessibilityService.SoftKeyboardController.OnShowModeChangedListener listener)
  ///
  /// Removes the specified change listener from the list of keyboard show mode change
  /// listeners.
  ///@param listener the listener to remove, must be non-null
  /// This value must never be {@code null}.
  ///@return {@code true} if the listener was removed, {@code false} otherwise
  bool removeOnShowModeChangedListener(
          AccessibilityService_SoftKeyboardController_OnShowModeChangedListener
              listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnShowModeChangedListener,
          jni.JniType.booleanType,
          [listener.reference]).boolean;

  static final _id_getShowMode =
      jniAccessors.getMethodIDOf(_classRef, "getShowMode", "()I");

  /// from: public int getShowMode()
  ///
  /// Returns the show mode of the soft keyboard. The default show mode is
  /// {@code SHOW_MODE_AUTO}, where the soft keyboard is shown when a text input field is
  /// focused. An AccessibilityService can also request the show mode
  /// {@code SHOW_MODE_HIDDEN}, where the soft keyboard is never shown.
  ///@return the current soft keyboard show mode
  ///
  /// Value is android.accessibilityservice.AccessibilityService\#SHOW_MODE_AUTO, or android.accessibilityservice.AccessibilityService\#SHOW_MODE_HIDDEN
  int getShowMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getShowMode, jni.JniType.intType, []).integer;

  static final _id_setShowMode =
      jniAccessors.getMethodIDOf(_classRef, "setShowMode", "(I)Z");

  /// from: public boolean setShowMode(int showMode)
  ///
  /// Sets the soft keyboard show mode. The default show mode is
  /// {@code SHOW_MODE_AUTO}, where the soft keyboard is shown when a text input field is
  /// focused. An AccessibilityService can also request the show mode
  /// {@code SHOW_MODE_HIDDEN}, where the soft keyboard is never shown. The
  /// The lastto this method will be honored, regardless of any previous calls (including those
  /// made by other AccessibilityServices).
  ///
  /// <strong>Note:</strong> If the service is not yet connected (e.g.
  /// AccessibilityService\#onServiceConnected() has not yet been called) or the
  /// service has been disconnected, this method will have no effect and return {@code false}.
  ///@param showMode the new show mode for the soft keyboard
  /// Value is android.accessibilityservice.AccessibilityService\#SHOW_MODE_AUTO, or android.accessibilityservice.AccessibilityService\#SHOW_MODE_HIDDEN
  ///@return {@code true} on success
  bool setShowMode(int showMode) => jniAccessors.callMethodWithArgs(
      reference, _id_setShowMode, jni.JniType.booleanType, [showMode]).boolean;
}

/// from: android.accessibilityservice.AccessibilityService$SoftKeyboardController$OnShowModeChangedListener
///
/// Listener for changes in the soft keyboard show mode.
class AccessibilityService_SoftKeyboardController_OnShowModeChangedListener
    extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/accessibilityservice/AccessibilityService\$SoftKeyboardController\$OnShowModeChangedListener");
  AccessibilityService_SoftKeyboardController_OnShowModeChangedListener.fromRef(
      jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onShowModeChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onShowModeChanged",
      "(Landroid/accessibilityservice/AccessibilityService\$SoftKeyboardController;I)V");

  /// from: public abstract void onShowModeChanged(android.accessibilityservice.AccessibilityService.SoftKeyboardController controller, int showMode)
  ///
  /// Called when the soft keyboard behavior changes. The default show mode is
  /// {@code SHOW_MODE_AUTO}, where the soft keyboard is shown when a text input field is
  /// focused. An AccessibilityService can also request the show mode
  /// {@code SHOW_MODE_HIDDEN}, where the soft keyboard is never shown.
  ///@param controller the soft keyboard controller
  /// This value must never be {@code null}.
  ///@param showMode the current soft keyboard show mode
  ///
  /// Value is android.accessibilityservice.AccessibilityService\#SHOW_MODE_AUTO, or android.accessibilityservice.AccessibilityService\#SHOW_MODE_HIDDEN
  void onShowModeChanged(AccessibilityService_SoftKeyboardController controller,
          int showMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onShowModeChanged,
          jni.JniType.voidType, [controller.reference, showMode]).check();
}

/// from: android.accessibilityservice.AccessibilityService$MagnificationController
///
/// Used to control and query the state of display magnification.
class AccessibilityService_MagnificationController extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/accessibilityservice/AccessibilityService\$MagnificationController");
  AccessibilityService_MagnificationController.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/accessibilityservice/AccessibilityService;Ljava/lang/Object;)V");

  /// from: void <init>(android.accessibilityservice.AccessibilityService service, java.lang.Object lock)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AccessibilityService_MagnificationController(
      AccessibilityService service, jni.JniObject lock)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [service.reference, lock.reference]).object);

  static final _id_addListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addListener",
      "(Landroid/accessibilityservice/AccessibilityService\$MagnificationController\$OnMagnificationChangedListener;)V");

  /// from: public void addListener(android.accessibilityservice.AccessibilityService.MagnificationController.OnMagnificationChangedListener listener)
  ///
  /// Adds the specified change listener to the list of magnification
  /// change listeners. The callback will occur on the service's main
  /// thread.
  ///@param listener the listener to add, must be non-{@code null}
  ///
  /// This value must never be {@code null}.
  void addListener(
          AccessibilityService_MagnificationController_OnMagnificationChangedListener
              listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_addListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addListener",
      "(Landroid/accessibilityservice/AccessibilityService\$MagnificationController\$OnMagnificationChangedListener;Landroid/os/Handler;)V");

  /// from: public void addListener(android.accessibilityservice.AccessibilityService.MagnificationController.OnMagnificationChangedListener listener, android.os.Handler handler)
  ///
  /// Adds the specified change listener to the list of magnification
  /// change listeners. The callback will occur on the specified
  /// Handler's thread, or on the service's main thread if the
  /// handler is {@code null}.
  ///@param listener the listener to add, must be non-null
  /// This value must never be {@code null}.
  ///@param handler the handler on which the callback should execute, or
  ///        {@code null} to execute on the service's main thread
  ///
  /// This value may be {@code null}.
  void addListener1(
          AccessibilityService_MagnificationController_OnMagnificationChangedListener
              listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addListener1,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeListener",
      "(Landroid/accessibilityservice/AccessibilityService\$MagnificationController\$OnMagnificationChangedListener;)Z");

  /// from: public boolean removeListener(android.accessibilityservice.AccessibilityService.MagnificationController.OnMagnificationChangedListener listener)
  ///
  /// Removes the specified change listener from the list of magnification change listeners.
  ///@param listener the listener to remove, must be non-null
  /// This value must never be {@code null}.
  ///@return {@code true} if the listener was removed, {@code false} otherwise
  bool removeListener(
          AccessibilityService_MagnificationController_OnMagnificationChangedListener
              listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeListener,
          jni.JniType.booleanType, [listener.reference]).boolean;

  static final _id_getScale =
      jniAccessors.getMethodIDOf(_classRef, "getScale", "()F");

  /// from: public float getScale()
  ///
  /// Returns the current magnification scale.
  ///
  /// <strong>Note:</strong> If the service is not yet connected (e.g.
  /// AccessibilityService\#onServiceConnected() has not yet been
  /// called) or the service has been disconnected, this method will
  /// return a default value of {@code 1.0f}.
  ///@return the current magnification scale
  double getScale() => jniAccessors.callMethodWithArgs(
      reference, _id_getScale, jni.JniType.floatType, []).float;

  static final _id_getCenterX =
      jniAccessors.getMethodIDOf(_classRef, "getCenterX", "()F");

  /// from: public float getCenterX()
  ///
  /// Returns the unscaled screen-relative X coordinate of the focal
  /// center of the magnified region. This is the point around which
  /// zooming occurs and is guaranteed to lie within the magnified
  /// region.
  ///
  /// <strong>Note:</strong> If the service is not yet connected (e.g.
  /// AccessibilityService\#onServiceConnected() has not yet been
  /// called) or the service has been disconnected, this method will
  /// return a default value of {@code 0.0f}.
  ///@return the unscaled screen-relative X coordinate of the center of
  ///         the magnified region
  double getCenterX() => jniAccessors.callMethodWithArgs(
      reference, _id_getCenterX, jni.JniType.floatType, []).float;

  static final _id_getCenterY =
      jniAccessors.getMethodIDOf(_classRef, "getCenterY", "()F");

  /// from: public float getCenterY()
  ///
  /// Returns the unscaled screen-relative Y coordinate of the focal
  /// center of the magnified region. This is the point around which
  /// zooming occurs and is guaranteed to lie within the magnified
  /// region.
  ///
  /// <strong>Note:</strong> If the service is not yet connected (e.g.
  /// AccessibilityService\#onServiceConnected() has not yet been
  /// called) or the service has been disconnected, this method will
  /// return a default value of {@code 0.0f}.
  ///@return the unscaled screen-relative Y coordinate of the center of
  ///         the magnified region
  double getCenterY() => jniAccessors.callMethodWithArgs(
      reference, _id_getCenterY, jni.JniType.floatType, []).float;

  static final _id_getMagnificationRegion = jniAccessors.getMethodIDOf(
      _classRef, "getMagnificationRegion", "()Landroid/graphics/Region;");

  /// from: public android.graphics.Region getMagnificationRegion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the region of the screen currently active for magnification. Changes to
  /// magnification scale and center only affect this portion of the screen. The rest of the
  /// screen, for example input methods, cannot be magnified. This region is relative to the
  /// unscaled screen and is independent of the scale and center point.
  ///
  /// The returned region will be empty if magnification is not active. Magnification is active
  /// if magnification gestures are enabled or if a service is running that can control
  /// magnification.
  ///
  /// <strong>Note:</strong> If the service is not yet connected (e.g.
  /// AccessibilityService\#onServiceConnected() has not yet been
  /// called) or the service has been disconnected, this method will
  /// return an empty region.
  ///@return the region of the screen currently active for magnification, or an empty region
  /// if magnification is not active.
  ///
  /// This value will never be {@code null}.
  region_.Region getMagnificationRegion() =>
      region_.Region.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getMagnificationRegion, jni.JniType.objectType, []).object);

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "(Z)Z");

  /// from: public boolean reset(boolean animate)
  ///
  /// Resets magnification scale and center to their default (e.g.&nbsp;no
  /// magnification) values.
  ///
  /// <strong>Note:</strong> If the service is not yet connected (e.g.
  /// AccessibilityService\#onServiceConnected() has not yet been
  /// called) or the service has been disconnected, this method will have
  /// no effect and return {@code false}.
  ///@param animate {@code true} to animate from the current scale and
  ///                center or {@code false} to reset the scale and center
  ///                immediately
  ///@return {@code true} on success, {@code false} on failure
  bool reset(bool animate) => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.booleanType, [animate]).boolean;

  static final _id_setScale =
      jniAccessors.getMethodIDOf(_classRef, "setScale", "(FZ)Z");

  /// from: public boolean setScale(float scale, boolean animate)
  ///
  /// Sets the magnification scale.
  ///
  /// <strong>Note:</strong> If the service is not yet connected (e.g.
  /// AccessibilityService\#onServiceConnected() has not yet been
  /// called) or the service has been disconnected, this method will have
  /// no effect and return {@code false}.
  ///@param scale the magnification scale to set, must be >= 1 and <= 5
  ///@param animate {@code true} to animate from the current scale or
  ///                {@code false} to set the scale immediately
  ///@return {@code true} on success, {@code false} on failure
  bool setScale(double scale, bool animate) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setScale,
      jni.JniType.booleanType,
      [scale, animate]).boolean;

  static final _id_setCenter =
      jniAccessors.getMethodIDOf(_classRef, "setCenter", "(FFZ)Z");

  /// from: public boolean setCenter(float centerX, float centerY, boolean animate)
  ///
  /// Sets the center of the magnified viewport.
  ///
  /// <strong>Note:</strong> If the service is not yet connected (e.g.
  /// AccessibilityService\#onServiceConnected() has not yet been
  /// called) or the service has been disconnected, this method will have
  /// no effect and return {@code false}.
  ///@param centerX the unscaled screen-relative X coordinate on which to
  ///                center the viewport
  ///@param centerY the unscaled screen-relative Y coordinate on which to
  ///                center the viewport
  ///@param animate {@code true} to animate from the current viewport
  ///                center or {@code false} to set the center immediately
  ///@return {@code true} on success, {@code false} on failure
  bool setCenter(double centerX, double centerY, bool animate) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCenter,
          jni.JniType.booleanType, [centerX, centerY, animate]).boolean;
}

/// from: android.accessibilityservice.AccessibilityService$MagnificationController$OnMagnificationChangedListener
///
/// Listener for changes in the state of magnification.
class AccessibilityService_MagnificationController_OnMagnificationChangedListener
    extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/accessibilityservice/AccessibilityService\$MagnificationController\$OnMagnificationChangedListener");
  AccessibilityService_MagnificationController_OnMagnificationChangedListener.fromRef(
      jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onMagnificationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onMagnificationChanged",
      "(Landroid/accessibilityservice/AccessibilityService\$MagnificationController;Landroid/graphics/Region;FFF)V");

  /// from: public abstract void onMagnificationChanged(android.accessibilityservice.AccessibilityService.MagnificationController controller, android.graphics.Region region, float scale, float centerX, float centerY)
  ///
  /// Called when the magnified region, scale, or center changes.
  ///@param controller the magnification controller
  /// This value must never be {@code null}.
  ///@param region the magnification region
  /// This value must never be {@code null}.
  ///@param scale the new scale
  ///@param centerX the new X coordinate, in unscaled coordinates, around which
  /// magnification is focused
  ///@param centerY the new Y coordinate, in unscaled coordinates, around which
  /// magnification is focused
  void onMagnificationChanged(
          AccessibilityService_MagnificationController controller,
          region_.Region region,
          double scale,
          double centerX,
          double centerY) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onMagnificationChanged, jni.JniType.voidType, [
        controller.reference,
        region.reference,
        scale,
        centerX,
        centerY
      ]).check();
}

/// from: android.accessibilityservice.AccessibilityService$GestureResultCallback
///
/// Class used to report status of dispatched gestures
class AccessibilityService_GestureResultCallback extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/accessibilityservice/AccessibilityService\$GestureResultCallback");
  AccessibilityService_GestureResultCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AccessibilityService_GestureResultCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onCompleted = jniAccessors.getMethodIDOf(_classRef,
      "onCompleted", "(Landroid/accessibilityservice/GestureDescription;)V");

  /// from: public void onCompleted(android.accessibilityservice.GestureDescription gestureDescription)
  ///
  /// Called when the gesture has completed successfully
  ///@param gestureDescription The description of the gesture that completed.
  void onCompleted(gesturedescription_.GestureDescription gestureDescription) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCompleted,
          jni.JniType.voidType, [gestureDescription.reference]).check();

  static final _id_onCancelled = jniAccessors.getMethodIDOf(_classRef,
      "onCancelled", "(Landroid/accessibilityservice/GestureDescription;)V");

  /// from: public void onCancelled(android.accessibilityservice.GestureDescription gestureDescription)
  ///
  /// Called when the gesture was cancelled
  ///@param gestureDescription The description of the gesture that was cancelled.
  void onCancelled(gesturedescription_.GestureDescription gestureDescription) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCancelled,
          jni.JniType.voidType, [gestureDescription.reference]).check();
}
