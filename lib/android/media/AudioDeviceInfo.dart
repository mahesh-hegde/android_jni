// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.AudioDeviceInfo
///
/// Class to provide information about the audio devices.
class AudioDeviceInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/AudioDeviceInfo");
  AudioDeviceInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int TYPE_AUX_LINE
  ///
  /// A device type describing the auxiliary line-level connectors.
  static const TYPE_AUX_LINE = 19;

  /// from: static public final int TYPE_BLUETOOTH_A2DP
  ///
  /// A device type describing a Bluetooth device supporting the A2DP profile.
  static const TYPE_BLUETOOTH_A2DP = 8;

  /// from: static public final int TYPE_BLUETOOTH_SCO
  ///
  /// A device type describing a Bluetooth device typically used for telephony.
  static const TYPE_BLUETOOTH_SCO = 7;

  /// from: static public final int TYPE_BUILTIN_EARPIECE
  ///
  /// A device type describing the attached earphone speaker.
  static const TYPE_BUILTIN_EARPIECE = 1;

  /// from: static public final int TYPE_BUILTIN_MIC
  ///
  /// A device type describing the microphone(s) built in a device.
  static const TYPE_BUILTIN_MIC = 15;

  /// from: static public final int TYPE_BUILTIN_SPEAKER
  ///
  /// A device type describing the speaker system (i.e. a mono speaker or stereo speakers) built
  /// in a device.
  static const TYPE_BUILTIN_SPEAKER = 2;

  /// from: static public final int TYPE_BUS
  ///
  /// A type-agnostic device used for communication with external audio systems
  static const TYPE_BUS = 21;

  /// from: static public final int TYPE_DOCK
  ///
  /// A device type describing the audio device associated with a dock.
  static const TYPE_DOCK = 13;

  /// from: static public final int TYPE_FM
  ///
  /// A device type associated with the transmission of audio signals over FM.
  static const TYPE_FM = 14;

  /// from: static public final int TYPE_FM_TUNER
  ///
  /// A device type for accessing the audio content transmitted over FM.
  static const TYPE_FM_TUNER = 16;

  /// from: static public final int TYPE_HDMI
  ///
  /// A device type describing an HDMI connection .
  static const TYPE_HDMI = 9;

  /// from: static public final int TYPE_HDMI_ARC
  ///
  /// A device type describing the Audio Return Channel of an HDMI connection.
  static const TYPE_HDMI_ARC = 10;

  /// from: static public final int TYPE_HEARING_AID
  ///
  /// A device type describing a Hearing Aid.
  static const TYPE_HEARING_AID = 23;

  /// from: static public final int TYPE_IP
  ///
  /// A device type connected over IP.
  static const TYPE_IP = 20;

  /// from: static public final int TYPE_LINE_ANALOG
  ///
  /// A device type describing an analog line-level connection.
  static const TYPE_LINE_ANALOG = 5;

  /// from: static public final int TYPE_LINE_DIGITAL
  ///
  /// A device type describing a digital line connection (e.g.&nbsp;SPDIF).
  static const TYPE_LINE_DIGITAL = 6;

  /// from: static public final int TYPE_TELEPHONY
  ///
  /// A device type describing the transmission of audio signals over the telephony network.
  static const TYPE_TELEPHONY = 18;

  /// from: static public final int TYPE_TV_TUNER
  ///
  /// A device type for accessing the audio content transmitted over the TV tuner system.
  static const TYPE_TV_TUNER = 17;

  /// from: static public final int TYPE_UNKNOWN
  ///
  /// A device type associated with an unknown or uninitialized device.
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_USB_ACCESSORY
  ///
  /// A device type describing a USB audio device in accessory mode.
  static const TYPE_USB_ACCESSORY = 12;

  /// from: static public final int TYPE_USB_DEVICE
  ///
  /// A device type describing a USB audio device.
  static const TYPE_USB_DEVICE = 11;

  /// from: static public final int TYPE_USB_HEADSET
  ///
  /// A device type describing a USB audio headset.
  static const TYPE_USB_HEADSET = 22;

  /// from: static public final int TYPE_WIRED_HEADPHONES
  ///
  /// A device type describing a pair of wired headphones.
  static const TYPE_WIRED_HEADPHONES = 4;

  /// from: static public final int TYPE_WIRED_HEADSET
  ///
  /// A device type describing a headset, which is the combination of a headphones and microphone.
  static const TYPE_WIRED_HEADSET = 3;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AudioDeviceInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// @return The internal device ID.
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getProductName = jniAccessors.getMethodIDOf(
      _classRef, "getProductName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getProductName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The human-readable name of the audio device.
  jni.JniObject getProductName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getProductName, jni.JniType.objectType, []).object);

  static final _id_getAddress = jniAccessors.getMethodIDOf(
      _classRef, "getAddress", "()Ljava/lang/String;");

  /// from: public java.lang.String getAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The "address" string of the device. This generally contains device-specific
  /// parameters.
  ///
  /// This value will never be {@code null}.
  jni.JniString getAddress() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAddress, jni.JniType.objectType, []).object);

  static final _id_isSource =
      jniAccessors.getMethodIDOf(_classRef, "isSource", "()Z");

  /// from: public boolean isSource()
  ///
  /// @return true if the audio device is a source for audio data (e.e an input).
  bool isSource() => jniAccessors.callMethodWithArgs(
      reference, _id_isSource, jni.JniType.booleanType, []).boolean;

  static final _id_isSink =
      jniAccessors.getMethodIDOf(_classRef, "isSink", "()Z");

  /// from: public boolean isSink()
  ///
  /// @return true if the audio device is a sink for audio data (i.e. an output).
  bool isSink() => jniAccessors.callMethodWithArgs(
      reference, _id_isSink, jni.JniType.booleanType, []).boolean;

  static final _id_getSampleRates =
      jniAccessors.getMethodIDOf(_classRef, "getSampleRates", "()[I");

  /// from: public int[] getSampleRates()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return An array of sample rates supported by the audio device.
  ///
  /// Note: an empty array indicates that the device supports arbitrary rates.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getSampleRates() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSampleRates, jni.JniType.objectType, []).object);

  static final _id_getChannelMasks =
      jniAccessors.getMethodIDOf(_classRef, "getChannelMasks", "()[I");

  /// from: public int[] getChannelMasks()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return An array of channel position masks (e.g.&nbsp;AudioFormat\#CHANNEL_IN_STEREO,
  /// AudioFormat\#CHANNEL_OUT_7POINT1) for which this audio device can be configured.
  ///
  /// This value will never be {@code null}.
  ///@see AudioFormat Note: an empty array indicates that the device supports arbitrary channel masks.
  jni.JniObject getChannelMasks() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChannelMasks, jni.JniType.objectType, []).object);

  static final _id_getChannelIndexMasks =
      jniAccessors.getMethodIDOf(_classRef, "getChannelIndexMasks", "()[I");

  /// from: public int[] getChannelIndexMasks()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return An array of channel index masks for which this audio device can be configured.
  ///
  /// This value will never be {@code null}.
  ///@see AudioFormat Note: an empty array indicates that the device supports arbitrary channel index masks.
  jni.JniObject getChannelIndexMasks() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getChannelIndexMasks, jni.JniType.objectType, []).object);

  static final _id_getChannelCounts =
      jniAccessors.getMethodIDOf(_classRef, "getChannelCounts", "()[I");

  /// from: public int[] getChannelCounts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return An array of channel counts (1, 2, 4, ...) for which this audio device
  /// can be configured.
  ///
  /// Note: an empty array indicates that the device supports arbitrary channel counts.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getChannelCounts() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChannelCounts, jni.JniType.objectType, []).object);

  static final _id_getEncodings =
      jniAccessors.getMethodIDOf(_classRef, "getEncodings", "()[I");

  /// from: public int[] getEncodings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return An array of audio encodings (e.g.&nbsp;AudioFormat\#ENCODING_PCM_16BIT,
  /// AudioFormat\#ENCODING_PCM_FLOAT) supported by the audio device.
  /// <code>ENCODING_PCM_FLOAT</code> indicates the device supports more
  /// than 16 bits of integer precision.  As there is no AudioFormat constant
  /// specifically defined for 24-bit PCM, the value <code>ENCODING_PCM_FLOAT</code>
  /// indicates that AudioTrack or AudioRecord can preserve at least 24 bits of
  /// integer precision to that device.
  ///
  /// This value will never be {@code null}.
  ///@see AudioFormat Note: an empty array indicates that the device supports arbitrary encodings.
  jni.JniObject getEncodings() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getEncodings, jni.JniType.objectType, []).object);

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()I");

  /// from: public int getType()
  ///
  /// @return The device type identifier of the audio device (i.e. TYPE_BUILTIN_SPEAKER).
  int getType() => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, []).integer;
}
