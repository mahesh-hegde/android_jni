// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "RemoteControlClient.dart" as remotecontrolclient_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../content/Context.dart" as context_;

import "../view/Display.dart" as display_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaRouter
///
/// MediaRouter allows applications to control the routing of media channels
/// and streams from the current device to external speakers and destination devices.
///
/// A MediaRouter is retrieved through Context\#getSystemService(String) Context.getSystemService() of a Context\#MEDIA_ROUTER_SERVICE Context.MEDIA_ROUTER_SERVICE.
///
/// The media router API is not thread-safe; all interactions with it must be
/// done from the main thread of the process.
///
class MediaRouter extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/MediaRouter");
  MediaRouter.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CALLBACK_FLAG_PERFORM_ACTIVE_SCAN
  ///
  /// Flag for \#addCallback: Actively scan for routes while this callback
  /// is registered.
  ///
  /// When this flag is specified, the media router will actively scan for new
  /// routes.  Certain routes, such as wifi display routes, may not be discoverable
  /// except when actively scanning.  This flag is typically used when the route picker
  /// dialog has been opened by the user to ensure that the route information is
  /// up to date.
  ///
  ///
  /// Active scanning may consume a significant amount of power and may have intrusive
  /// effects on wireless connectivity.  Therefore it is important that active scanning
  /// only be requested when it is actually needed to satisfy a user request to
  /// discover and select a new route.
  ///
  ///
  static const CALLBACK_FLAG_PERFORM_ACTIVE_SCAN = 1;

  /// from: static public final int CALLBACK_FLAG_UNFILTERED_EVENTS
  ///
  /// Flag for \#addCallback: Do not filter route events.
  ///
  /// When this flag is specified, the callback will be invoked for event that affect any
  /// route even if they do not match the callback's filter.
  ///
  ///
  static const CALLBACK_FLAG_UNFILTERED_EVENTS = 2;

  /// from: static public final int ROUTE_TYPE_LIVE_AUDIO
  ///
  /// Route type flag for live audio.
  ///
  /// A device that supports live audio routing will allow the media audio stream
  /// to be routed to supported destinations. This can include internal speakers or
  /// audio jacks on the device itself, A2DP devices, and more.
  ///
  ///
  /// Once initiated this routing is transparent to the application. All audio
  /// played on the media stream will be routed to the selected destination.
  ///
  static const ROUTE_TYPE_LIVE_AUDIO = 1;

  /// from: static public final int ROUTE_TYPE_LIVE_VIDEO
  ///
  /// Route type flag for live video.
  ///
  /// A device that supports live video routing will allow a mirrored version
  /// of the device's primary display or a customized
  /// android.app.Presentation Presentation to be routed to supported destinations.
  ///
  ///
  /// Once initiated, display mirroring is transparent to the application.
  /// While remote routing is active the application may use a
  /// android.app.Presentation Presentation to replace the mirrored view
  /// on the external display with different content.
  ///
  ///@see RouteInfo\#getPresentationDisplay()
  ///@see android.app.Presentation
  static const ROUTE_TYPE_LIVE_VIDEO = 2;

  /// from: static public final int ROUTE_TYPE_USER
  ///
  /// Route type flag for application-specific usage.
  ///
  /// Unlike other media route types, user routes are managed by the application.
  /// The MediaRouter will manage and dispatch events for user routes, but the application
  /// is expected to interpret the meaning of these events and perform the requested
  /// routing tasks.
  ///
  static const ROUTE_TYPE_USER = 8388608;

  static final _id_getDefaultRoute = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultRoute", "()Landroid/media/MediaRouter\$RouteInfo;");

  /// from: public android.media.MediaRouter.RouteInfo getDefaultRoute()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the default route for playing media content on the system.
  ///
  /// The system always provides a default route.
  ///
  ///
  ///@return The default route, which is guaranteed to never be null.
  MediaRouter_RouteInfo getDefaultRoute() =>
      MediaRouter_RouteInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDefaultRoute, jni.JniType.objectType, []).object);

  static final _id_getSelectedRoute = jniAccessors.getMethodIDOf(_classRef,
      "getSelectedRoute", "(I)Landroid/media/MediaRouter\$RouteInfo;");

  /// from: public android.media.MediaRouter.RouteInfo getSelectedRoute(int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the currently selected route for any of the given types
  ///@param type route types
  ///@return the selected route
  MediaRouter_RouteInfo getSelectedRoute(int type) =>
      MediaRouter_RouteInfo.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSelectedRoute, jni.JniType.objectType, [type]).object);

  static final _id_addCallback = jniAccessors.getMethodIDOf(
      _classRef, "addCallback", "(ILandroid/media/MediaRouter\$Callback;)V");

  /// from: public void addCallback(int types, android.media.MediaRouter.Callback cb)
  ///
  /// Add a callback to listen to events about specific kinds of media routes.
  /// If the specified callback is already registered, its registration will be updated for any
  /// additional route types specified.
  ///
  /// This is a convenience method that has the same effect as calling
  /// \#addCallback(int, Callback, int) without flags.
  ///
  ///
  ///@param types Types of routes this callback is interested in
  ///@param cb Callback to add
  void addCallback(int types, MediaRouter_Callback cb) =>
      jniAccessors.callMethodWithArgs(reference, _id_addCallback,
          jni.JniType.voidType, [types, cb.reference]).check();

  static final _id_addCallback1 = jniAccessors.getMethodIDOf(
      _classRef, "addCallback", "(ILandroid/media/MediaRouter\$Callback;I)V");

  /// from: public void addCallback(int types, android.media.MediaRouter.Callback cb, int flags)
  ///
  /// Add a callback to listen to events about specific kinds of media routes.
  /// If the specified callback is already registered, its registration will be updated for any
  /// additional route types specified.
  ///
  /// By default, the callback will only be invoked for events that affect routes
  /// that match the specified selector.  The filtering may be disabled by specifying
  /// the \#CALLBACK_FLAG_UNFILTERED_EVENTS flag.
  ///
  ///
  ///@param types Types of routes this callback is interested in
  ///@param cb Callback to add
  ///@param flags Flags to control the behavior of the callback.
  /// May be zero or a combination of \#CALLBACK_FLAG_PERFORM_ACTIVE_SCAN and
  /// \#CALLBACK_FLAG_UNFILTERED_EVENTS.
  void addCallback1(int types, MediaRouter_Callback cb, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_addCallback1,
          jni.JniType.voidType, [types, cb.reference, flags]).check();

  static final _id_removeCallback = jniAccessors.getMethodIDOf(
      _classRef, "removeCallback", "(Landroid/media/MediaRouter\$Callback;)V");

  /// from: public void removeCallback(android.media.MediaRouter.Callback cb)
  ///
  /// Remove the specified callback. It will no longer receive events about media routing.
  ///@param cb Callback to remove
  void removeCallback(MediaRouter_Callback cb) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeCallback,
          jni.JniType.voidType, [cb.reference]).check();

  static final _id_selectRoute = jniAccessors.getMethodIDOf(
      _classRef, "selectRoute", "(ILandroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void selectRoute(int types, android.media.MediaRouter.RouteInfo route)
  ///
  /// Select the specified route to use for output of the given media types.
  /// <p class="note">
  /// As API version 18, this function may be used to select any route.
  /// In prior versions, this function could only be used to select user
  /// routes and would ignore any attempt to select a system route.
  ///
  ///
  ///@param types type flags indicating which types this route should be used for.
  ///              The route must support at least a subset.
  ///@param route Route to select
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the given route is {@code null}
  void selectRoute(int types, MediaRouter_RouteInfo route) =>
      jniAccessors.callMethodWithArgs(reference, _id_selectRoute,
          jni.JniType.voidType, [types, route.reference]).check();

  static final _id_addUserRoute = jniAccessors.getMethodIDOf(_classRef,
      "addUserRoute", "(Landroid/media/MediaRouter\$UserRouteInfo;)V");

  /// from: public void addUserRoute(android.media.MediaRouter.UserRouteInfo info)
  ///
  /// Add an app-specified route for media to the MediaRouter.
  /// App-specified route definitions are created using \#createUserRoute(RouteCategory)
  ///@param info Definition of the route to add
  ///@see \#createUserRoute(RouteCategory)
  ///@see \#removeUserRoute(UserRouteInfo)
  void addUserRoute(MediaRouter_UserRouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_addUserRoute,
          jni.JniType.voidType, [info.reference]).check();

  static final _id_removeUserRoute = jniAccessors.getMethodIDOf(_classRef,
      "removeUserRoute", "(Landroid/media/MediaRouter\$UserRouteInfo;)V");

  /// from: public void removeUserRoute(android.media.MediaRouter.UserRouteInfo info)
  ///
  /// Remove an app-specified route for media from the MediaRouter.
  ///@param info Definition of the route to remove
  ///@see \#addUserRoute(UserRouteInfo)
  void removeUserRoute(MediaRouter_UserRouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeUserRoute,
          jni.JniType.voidType, [info.reference]).check();

  static final _id_clearUserRoutes =
      jniAccessors.getMethodIDOf(_classRef, "clearUserRoutes", "()V");

  /// from: public void clearUserRoutes()
  ///
  /// Remove all app-specified routes from the MediaRouter.
  ///@see \#removeUserRoute(UserRouteInfo)
  void clearUserRoutes() => jniAccessors.callMethodWithArgs(
      reference, _id_clearUserRoutes, jni.JniType.voidType, []).check();

  static final _id_getCategoryCount =
      jniAccessors.getMethodIDOf(_classRef, "getCategoryCount", "()I");

  /// from: public int getCategoryCount()
  ///
  /// Return the number of MediaRouter.RouteCategory categories currently
  /// represented by routes known to this MediaRouter.
  ///@return the number of unique categories represented by this MediaRouter's known routes
  int getCategoryCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getCategoryCount, jni.JniType.intType, []).integer;

  static final _id_getCategoryAt = jniAccessors.getMethodIDOf(_classRef,
      "getCategoryAt", "(I)Landroid/media/MediaRouter\$RouteCategory;");

  /// from: public android.media.MediaRouter.RouteCategory getCategoryAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MediaRouter.RouteCategory category at the given index.
  /// Valid indices are in the range [0-getCategoryCount).
  ///@param index which category to return
  ///@return the category at index
  MediaRouter_RouteCategory getCategoryAt(int index) =>
      MediaRouter_RouteCategory.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCategoryAt,
          jni.JniType.objectType,
          [index]).object);

  static final _id_getRouteCount =
      jniAccessors.getMethodIDOf(_classRef, "getRouteCount", "()I");

  /// from: public int getRouteCount()
  ///
  /// Return the number of MediaRouter.RouteInfo routes currently known
  /// to this MediaRouter.
  ///@return the number of routes tracked by this router
  int getRouteCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRouteCount, jni.JniType.intType, []).integer;

  static final _id_getRouteAt = jniAccessors.getMethodIDOf(
      _classRef, "getRouteAt", "(I)Landroid/media/MediaRouter\$RouteInfo;");

  /// from: public android.media.MediaRouter.RouteInfo getRouteAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the route at the specified index.
  ///@param index index of the route to return
  ///@return the route at index
  MediaRouter_RouteInfo getRouteAt(int index) =>
      MediaRouter_RouteInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRouteAt, jni.JniType.objectType, [index]).object);

  static final _id_createUserRoute = jniAccessors.getMethodIDOf(
      _classRef,
      "createUserRoute",
      "(Landroid/media/MediaRouter\$RouteCategory;)Landroid/media/MediaRouter\$UserRouteInfo;");

  /// from: public android.media.MediaRouter.UserRouteInfo createUserRoute(android.media.MediaRouter.RouteCategory category)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new user route that may be modified and registered for use by the application.
  ///@param category The category the new route will belong to
  ///@return A new UserRouteInfo for use by the application
  ///@see \#addUserRoute(UserRouteInfo)
  ///@see \#removeUserRoute(UserRouteInfo)
  ///@see \#createRouteCategory(CharSequence, boolean)
  MediaRouter_UserRouteInfo createUserRoute(
          MediaRouter_RouteCategory category) =>
      MediaRouter_UserRouteInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createUserRoute,
          jni.JniType.objectType,
          [category.reference]).object);

  static final _id_createRouteCategory = jniAccessors.getMethodIDOf(
      _classRef,
      "createRouteCategory",
      "(Ljava/lang/CharSequence;Z)Landroid/media/MediaRouter\$RouteCategory;");

  /// from: public android.media.MediaRouter.RouteCategory createRouteCategory(java.lang.CharSequence name, boolean isGroupable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new route category. Each route must belong to a category.
  ///@param name Name of the new category
  ///@param isGroupable true if routes in this category may be grouped with one another
  ///@return the new RouteCategory
  MediaRouter_RouteCategory createRouteCategory(
          jni.JniObject name, bool isGroupable) =>
      MediaRouter_RouteCategory.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createRouteCategory,
          jni.JniType.objectType,
          [name.reference, isGroupable]).object);

  static final _id_createRouteCategory1 = jniAccessors.getMethodIDOf(_classRef,
      "createRouteCategory", "(IZ)Landroid/media/MediaRouter\$RouteCategory;");

  /// from: public android.media.MediaRouter.RouteCategory createRouteCategory(int nameResId, boolean isGroupable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new route category. Each route must belong to a category.
  ///@param nameResId Resource ID of the name of the new category
  ///@param isGroupable true if routes in this category may be grouped with one another
  ///@return the new RouteCategory
  MediaRouter_RouteCategory createRouteCategory1(
          int nameResId, bool isGroupable) =>
      MediaRouter_RouteCategory.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createRouteCategory1,
          jni.JniType.objectType,
          [nameResId, isGroupable]).object);
}

/// from: android.media.MediaRouter$VolumeCallback
///
/// Interface for receiving events about volume changes.
/// All methods of this interface will be called from the application's main thread.
///
/// A VolumeCallback will only receive events relevant to routes that the callback
/// was registered for.
///
///@see UserRouteInfo\#setVolumeCallback(VolumeCallback)
class MediaRouter_VolumeCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRouter\$VolumeCallback");
  MediaRouter_VolumeCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaRouter_VolumeCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onVolumeUpdateRequest = jniAccessors.getMethodIDOf(_classRef,
      "onVolumeUpdateRequest", "(Landroid/media/MediaRouter\$RouteInfo;I)V");

  /// from: public abstract void onVolumeUpdateRequest(android.media.MediaRouter.RouteInfo info, int direction)
  ///
  /// Called when the volume for the route should be increased or decreased.
  ///@param info the route affected by this event
  ///@param direction an integer indicating whether the volume is to be increased
  ///     (positive value) or decreased (negative value).
  ///     For bundled changes, the absolute value indicates the number of changes
  ///     in the same direction, e.g. +3 corresponds to three "volume up" changes.
  void onVolumeUpdateRequest(MediaRouter_RouteInfo info, int direction) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVolumeUpdateRequest,
          jni.JniType.voidType, [info.reference, direction]).check();

  static final _id_onVolumeSetRequest = jniAccessors.getMethodIDOf(_classRef,
      "onVolumeSetRequest", "(Landroid/media/MediaRouter\$RouteInfo;I)V");

  /// from: public abstract void onVolumeSetRequest(android.media.MediaRouter.RouteInfo info, int volume)
  ///
  /// Called when the volume for the route should be set to the given value
  ///@param info the route affected by this event
  ///@param volume an integer indicating the new volume value that should be used, always
  ///     between 0 and the value set by UserRouteInfo\#setVolumeMax(int).
  void onVolumeSetRequest(MediaRouter_RouteInfo info, int volume) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVolumeSetRequest,
          jni.JniType.voidType, [info.reference, volume]).check();
}

/// from: android.media.MediaRouter$UserRouteInfo
///
/// Information about a route that the application may define and modify.
/// A user route defaults to RouteInfo\#PLAYBACK_TYPE_REMOTE and
/// RouteInfo\#PLAYBACK_VOLUME_FIXED.
///@see MediaRouter.RouteInfo
class MediaRouter_UserRouteInfo extends MediaRouter_RouteInfo {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRouter\$UserRouteInfo");
  MediaRouter_UserRouteInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_setName = jniAccessors.getMethodIDOf(
      _classRef, "setName", "(Ljava/lang/CharSequence;)V");

  /// from: public void setName(java.lang.CharSequence name)
  ///
  /// Set the user-visible name of this route.
  ///@param name Name to display to the user to describe this route
  void setName(jni.JniObject name) => jniAccessors.callMethodWithArgs(
      reference, _id_setName, jni.JniType.voidType, [name.reference]).check();

  static final _id_setName1 =
      jniAccessors.getMethodIDOf(_classRef, "setName", "(I)V");

  /// from: public void setName(int resId)
  ///
  /// Set the user-visible name of this route.
  ///
  /// The route name identifies the destination represented by the route.
  /// It may be a user-supplied name, an alias, or device serial number.
  ///
  ///
  ///@param resId Resource ID of the name to display to the user to describe this route
  void setName1(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setName1, jni.JniType.voidType, [resId]).check();

  static final _id_setDescription = jniAccessors.getMethodIDOf(
      _classRef, "setDescription", "(Ljava/lang/CharSequence;)V");

  /// from: public void setDescription(java.lang.CharSequence description)
  ///
  /// Set the user-visible description of this route.
  ///
  /// The route description describes the kind of destination represented by the route.
  /// It may be a user-supplied string, a model number or brand of device.
  ///
  ///
  ///@param description The description of the route, or null if none.
  void setDescription(jni.JniObject description) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDescription,
          jni.JniType.voidType, [description.reference]).check();

  static final _id_setStatus = jniAccessors.getMethodIDOf(
      _classRef, "setStatus", "(Ljava/lang/CharSequence;)V");

  /// from: public void setStatus(java.lang.CharSequence status)
  ///
  /// Set the current user-visible status for this route.
  ///@param status Status to display to the user to describe what the endpoint
  /// of this route is currently doing
  void setStatus(jni.JniObject status) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setStatus,
      jni.JniType.voidType,
      [status.reference]).check();

  static final _id_setRemoteControlClient = jniAccessors.getMethodIDOf(
      _classRef,
      "setRemoteControlClient",
      "(Landroid/media/RemoteControlClient;)V");

  /// from: public void setRemoteControlClient(android.media.RemoteControlClient rcc)
  ///
  /// Set the RemoteControlClient responsible for reporting playback info for this
  /// user route.
  ///
  /// If this route manages remote playback, the data exposed by this
  /// RemoteControlClient will be used to reflect and update information
  /// such as route volume info in related UIs.
  ///
  ///
  /// The RemoteControlClient must have been previously registered with
  /// AudioManager\#registerRemoteControlClient(RemoteControlClient).
  ///
  ///@param rcc RemoteControlClient associated with this route
  void setRemoteControlClient(remotecontrolclient_.RemoteControlClient rcc) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRemoteControlClient,
          jni.JniType.voidType, [rcc.reference]).check();

  static final _id_getRemoteControlClient = jniAccessors.getMethodIDOf(
      _classRef,
      "getRemoteControlClient",
      "()Landroid/media/RemoteControlClient;");

  /// from: public android.media.RemoteControlClient getRemoteControlClient()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the RemoteControlClient associated with this route, if one has been set.
  ///@return the RemoteControlClient associated with this route
  ///@see \#setRemoteControlClient(RemoteControlClient)
  remotecontrolclient_.RemoteControlClient getRemoteControlClient() =>
      remotecontrolclient_.RemoteControlClient.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getRemoteControlClient,
              jni.JniType.objectType, []).object);

  static final _id_setIconDrawable = jniAccessors.getMethodIDOf(
      _classRef, "setIconDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setIconDrawable(android.graphics.drawable.Drawable icon)
  ///
  /// Set an icon that will be used to represent this route.
  /// The system may use this icon in picker UIs or similar.
  ///@param icon icon drawable to use to represent this route
  void setIconDrawable(drawable_.Drawable icon) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIconDrawable,
          jni.JniType.voidType, [icon.reference]).check();

  static final _id_setIconResource =
      jniAccessors.getMethodIDOf(_classRef, "setIconResource", "(I)V");

  /// from: public void setIconResource(int resId)
  ///
  /// Set an icon that will be used to represent this route.
  /// The system may use this icon in picker UIs or similar.
  ///@param resId Resource ID of an icon drawable to use to represent this route
  void setIconResource(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setIconResource, jni.JniType.voidType, [resId]).check();

  static final _id_setVolumeCallback = jniAccessors.getMethodIDOf(_classRef,
      "setVolumeCallback", "(Landroid/media/MediaRouter\$VolumeCallback;)V");

  /// from: public void setVolumeCallback(android.media.MediaRouter.VolumeCallback vcb)
  ///
  /// Set a callback to be notified of volume update requests
  ///@param vcb
  void setVolumeCallback(MediaRouter_VolumeCallback vcb) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVolumeCallback,
          jni.JniType.voidType, [vcb.reference]).check();

  static final _id_setPlaybackType =
      jniAccessors.getMethodIDOf(_classRef, "setPlaybackType", "(I)V");

  /// from: public void setPlaybackType(int type)
  ///
  /// Defines whether playback associated with this route is "local"
  ///    (RouteInfo\#PLAYBACK_TYPE_LOCAL) or "remote"
  ///    (RouteInfo\#PLAYBACK_TYPE_REMOTE).
  ///@param type Value is android.media.MediaRouter.RouteInfo\#PLAYBACK_TYPE_LOCAL, or android.media.MediaRouter.RouteInfo\#PLAYBACK_TYPE_REMOTE
  void setPlaybackType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setPlaybackType, jni.JniType.voidType, [type]).check();

  static final _id_setVolumeHandling =
      jniAccessors.getMethodIDOf(_classRef, "setVolumeHandling", "(I)V");

  /// from: public void setVolumeHandling(int volumeHandling)
  ///
  /// Defines whether volume for the playback associated with this route is fixed
  /// (RouteInfo\#PLAYBACK_VOLUME_FIXED) or can modified
  /// (RouteInfo\#PLAYBACK_VOLUME_VARIABLE).
  ///@param volumeHandling Value is android.media.MediaRouter.RouteInfo\#PLAYBACK_VOLUME_FIXED, or android.media.MediaRouter.RouteInfo\#PLAYBACK_VOLUME_VARIABLE
  void setVolumeHandling(int volumeHandling) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVolumeHandling,
      jni.JniType.voidType,
      [volumeHandling]).check();

  static final _id_setVolume =
      jniAccessors.getMethodIDOf(_classRef, "setVolume", "(I)V");

  /// from: public void setVolume(int volume)
  ///
  /// Defines at what volume the playback associated with this route is performed (for user
  /// feedback purposes). This information is only used when the playback is not local.
  ///@param volume
  void setVolume(int volume) => jniAccessors.callMethodWithArgs(
      reference, _id_setVolume, jni.JniType.voidType, [volume]).check();

  static final _id_requestSetVolume =
      jniAccessors.getMethodIDOf(_classRef, "requestSetVolume", "(I)V");

  /// from: public void requestSetVolume(int volume)
  void requestSetVolume(int volume) => jniAccessors.callMethodWithArgs(
      reference, _id_requestSetVolume, jni.JniType.voidType, [volume]).check();

  static final _id_requestUpdateVolume =
      jniAccessors.getMethodIDOf(_classRef, "requestUpdateVolume", "(I)V");

  /// from: public void requestUpdateVolume(int direction)
  void requestUpdateVolume(int direction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestUpdateVolume,
      jni.JniType.voidType,
      [direction]).check();

  static final _id_setVolumeMax =
      jniAccessors.getMethodIDOf(_classRef, "setVolumeMax", "(I)V");

  /// from: public void setVolumeMax(int volumeMax)
  ///
  /// Defines the maximum volume at which the playback associated with this route is performed
  /// (for user feedback purposes). This information is only used when the playback is not
  /// local.
  ///@param volumeMax
  void setVolumeMax(int volumeMax) => jniAccessors.callMethodWithArgs(
      reference, _id_setVolumeMax, jni.JniType.voidType, [volumeMax]).check();

  static final _id_setPlaybackStream =
      jniAccessors.getMethodIDOf(_classRef, "setPlaybackStream", "(I)V");

  /// from: public void setPlaybackStream(int stream)
  ///
  /// Defines over what stream type the media is presented.
  ///@param stream
  void setPlaybackStream(int stream) => jniAccessors.callMethodWithArgs(
      reference, _id_setPlaybackStream, jni.JniType.voidType, [stream]).check();
}

/// from: android.media.MediaRouter$SimpleCallback
///
/// Stub implementation of MediaRouter.Callback.
/// Each abstract method is defined as a no-op. Override just the ones
/// you need.
class MediaRouter_SimpleCallback extends MediaRouter_Callback {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRouter\$SimpleCallback");
  MediaRouter_SimpleCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaRouter_SimpleCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onRouteSelected = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteSelected",
      "(Landroid/media/MediaRouter;ILandroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void onRouteSelected(android.media.MediaRouter router, int type, android.media.MediaRouter.RouteInfo info)
  void onRouteSelected(
          MediaRouter router, int type, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRouteSelected,
          jni.JniType.voidType,
          [router.reference, type, info.reference]).check();

  static final _id_onRouteUnselected = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteUnselected",
      "(Landroid/media/MediaRouter;ILandroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void onRouteUnselected(android.media.MediaRouter router, int type, android.media.MediaRouter.RouteInfo info)
  void onRouteUnselected(
          MediaRouter router, int type, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRouteUnselected,
          jni.JniType.voidType,
          [router.reference, type, info.reference]).check();

  static final _id_onRouteAdded = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteAdded",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void onRouteAdded(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  void onRouteAdded(MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRouteAdded,
          jni.JniType.voidType, [router.reference, info.reference]).check();

  static final _id_onRouteRemoved = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteRemoved",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void onRouteRemoved(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  void onRouteRemoved(MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRouteRemoved,
          jni.JniType.voidType, [router.reference, info.reference]).check();

  static final _id_onRouteChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteChanged",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void onRouteChanged(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  void onRouteChanged(MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRouteChanged,
          jni.JniType.voidType, [router.reference, info.reference]).check();

  static final _id_onRouteGrouped = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteGrouped",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;Landroid/media/MediaRouter\$RouteGroup;I)V");

  /// from: public void onRouteGrouped(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info, android.media.MediaRouter.RouteGroup group, int index)
  void onRouteGrouped(MediaRouter router, MediaRouter_RouteInfo info,
          MediaRouter_RouteGroup group, int index) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRouteGrouped,
          jni.JniType.voidType,
          [router.reference, info.reference, group.reference, index]).check();

  static final _id_onRouteUngrouped = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteUngrouped",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;Landroid/media/MediaRouter\$RouteGroup;)V");

  /// from: public void onRouteUngrouped(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info, android.media.MediaRouter.RouteGroup group)
  void onRouteUngrouped(MediaRouter router, MediaRouter_RouteInfo info,
          MediaRouter_RouteGroup group) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRouteUngrouped,
          jni.JniType.voidType,
          [router.reference, info.reference, group.reference]).check();

  static final _id_onRouteVolumeChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteVolumeChanged",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void onRouteVolumeChanged(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  void onRouteVolumeChanged(MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRouteVolumeChanged,
          jni.JniType.voidType, [router.reference, info.reference]).check();
}

/// from: android.media.MediaRouter$RouteInfo
///
/// Information about a media route.
class MediaRouter_RouteInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRouter\$RouteInfo");
  MediaRouter_RouteInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DEVICE_TYPE_BLUETOOTH
  ///
  /// A receiver device type of the route indicating the presentation of the media is happening
  /// on a bluetooth device such as a bluetooth speaker.
  ///@see \#getDeviceType
  static const DEVICE_TYPE_BLUETOOTH = 3;

  /// from: static public final int DEVICE_TYPE_SPEAKER
  ///
  /// A receiver device type of the route indicating the presentation of the media is happening
  /// on a speaker.
  ///@see \#getDeviceType
  static const DEVICE_TYPE_SPEAKER = 2;

  /// from: static public final int DEVICE_TYPE_TV
  ///
  /// A receiver device type of the route indicating the presentation of the media is happening
  /// on a TV.
  ///@see \#getDeviceType
  static const DEVICE_TYPE_TV = 1;

  /// from: static public final int DEVICE_TYPE_UNKNOWN
  ///
  /// The default receiver device type of the route indicating the type is unknown.
  ///@see \#getDeviceType
  static const DEVICE_TYPE_UNKNOWN = 0;

  /// from: static public final int PLAYBACK_TYPE_LOCAL
  ///
  /// The default playback type, "local", indicating the presentation of the media is happening
  /// on the same device (e&\#46;g&\#46; a phone, a tablet) as where it is controlled from.
  ///@see \#getPlaybackType()
  static const PLAYBACK_TYPE_LOCAL = 0;

  /// from: static public final int PLAYBACK_TYPE_REMOTE
  ///
  /// A playback type indicating the presentation of the media is happening on
  /// a different device (i&\#46;e&\#46; the remote device) than where it is controlled from.
  ///@see \#getPlaybackType()
  static const PLAYBACK_TYPE_REMOTE = 1;

  /// from: static public final int PLAYBACK_VOLUME_FIXED
  ///
  /// Playback information indicating the playback volume is fixed, i&\#46;e&\#46; it cannot be
  /// controlled from this object. An example of fixed playback volume is a remote player,
  /// playing over HDMI where the user prefers to control the volume on the HDMI sink, rather
  /// than attenuate at the source.
  ///@see \#getVolumeHandling()
  static const PLAYBACK_VOLUME_FIXED = 0;

  /// from: static public final int PLAYBACK_VOLUME_VARIABLE
  ///
  /// Playback information indicating the playback volume is variable and can be controlled
  /// from this object.
  ///@see \#getVolumeHandling()
  static const PLAYBACK_VOLUME_VARIABLE = 1;

  static final _id_getName = jniAccessors.getMethodIDOf(
      _classRef, "getName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the user-visible name of the route.
  ///
  /// The route name identifies the destination represented by the route.
  /// It may be a user-supplied name, an alias, or device serial number.
  ///
  ///
  ///@return The user-visible name of a media route.  This is the string presented
  /// to users who may select this as the active route.
  jni.JniObject getName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_getName1 = jniAccessors.getMethodIDOf(_classRef, "getName",
      "(Landroid/content/Context;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getName(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the properly localized/resource user-visible name of this route.
  ///
  /// The route name identifies the destination represented by the route.
  /// It may be a user-supplied name, an alias, or device serial number.
  ///
  ///
  ///@param context Context used to resolve the correct configuration to load
  ///@return The user-visible name of a media route.  This is the string presented
  /// to users who may select this as the active route.
  jni.JniObject getName1(context_.Context context) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getName1, jni.JniType.objectType, [context.reference]).object);

  static final _id_getDescription = jniAccessors.getMethodIDOf(
      _classRef, "getDescription", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the user-visible description of the route.
  ///
  /// The route description describes the kind of destination represented by the route.
  /// It may be a user-supplied string, a model number or brand of device.
  ///
  ///
  ///@return The description of the route, or null if none.
  jni.JniObject getDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDescription, jni.JniType.objectType, []).object);

  static final _id_getStatus = jniAccessors.getMethodIDOf(
      _classRef, "getStatus", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getStatus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The user-visible status for a media route. This may include a description
  /// of the currently playing media, if available.
  jni.JniObject getStatus() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStatus, jni.JniType.objectType, []).object);

  static final _id_getSupportedTypes =
      jniAccessors.getMethodIDOf(_classRef, "getSupportedTypes", "()I");

  /// from: public int getSupportedTypes()
  ///
  /// @return A media type flag set describing which types this route supports.
  int getSupportedTypes() => jniAccessors.callMethodWithArgs(
      reference, _id_getSupportedTypes, jni.JniType.intType, []).integer;

  static final _id_getDeviceType =
      jniAccessors.getMethodIDOf(_classRef, "getDeviceType", "()I");

  /// from: public int getDeviceType()
  ///
  /// Gets the type of the receiver device associated with this route.
  ///@return The type of the receiver device associated with this route:
  /// \#DEVICE_TYPE_BLUETOOTH, \#DEVICE_TYPE_TV, \#DEVICE_TYPE_SPEAKER,
  /// or \#DEVICE_TYPE_UNKNOWN.
  ///
  /// Value is android.media.MediaRouter.RouteInfo\#DEVICE_TYPE_UNKNOWN, android.media.MediaRouter.RouteInfo\#DEVICE_TYPE_TV, android.media.MediaRouter.RouteInfo\#DEVICE_TYPE_SPEAKER, or android.media.MediaRouter.RouteInfo\#DEVICE_TYPE_BLUETOOTH
  int getDeviceType() => jniAccessors.callMethodWithArgs(
      reference, _id_getDeviceType, jni.JniType.intType, []).integer;

  static final _id_getGroup = jniAccessors.getMethodIDOf(
      _classRef, "getGroup", "()Landroid/media/MediaRouter\$RouteGroup;");

  /// from: public android.media.MediaRouter.RouteGroup getGroup()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The group that this route belongs to.
  MediaRouter_RouteGroup getGroup() =>
      MediaRouter_RouteGroup.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getGroup, jni.JniType.objectType, []).object);

  static final _id_getCategory = jniAccessors.getMethodIDOf(
      _classRef, "getCategory", "()Landroid/media/MediaRouter\$RouteCategory;");

  /// from: public android.media.MediaRouter.RouteCategory getCategory()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the category this route belongs to.
  MediaRouter_RouteCategory getCategory() =>
      MediaRouter_RouteCategory.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCategory, jni.JniType.objectType, []).object);

  static final _id_getIconDrawable = jniAccessors.getMethodIDOf(
      _classRef, "getIconDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getIconDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the icon representing this route.
  /// This icon will be used in picker UIs if available.
  ///@return the icon representing this route or null if no icon is available
  drawable_.Drawable getIconDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIconDrawable, jni.JniType.objectType, []).object);

  static final _id_setTag =
      jniAccessors.getMethodIDOf(_classRef, "setTag", "(Ljava/lang/Object;)V");

  /// from: public void setTag(java.lang.Object tag)
  ///
  /// Set an application-specific tag object for this route.
  /// The application may use this to store arbitrary data associated with the
  /// route for internal tracking.
  ///
  /// Note that the lifespan of a route may be well past the lifespan of
  /// an Activity or other Context; take care that objects you store here
  /// will not keep more data in memory alive than you intend.
  ///
  ///@param tag Arbitrary, app-specific data for this route to hold for later use
  void setTag(jni.JniObject tag) => jniAccessors.callMethodWithArgs(
      reference, _id_setTag, jni.JniType.voidType, [tag.reference]).check();

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Ljava/lang/Object;");

  /// from: public java.lang.Object getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The tag object previously set by the application
  ///@see \#setTag(Object)
  jni.JniObject getTag() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_getPlaybackType =
      jniAccessors.getMethodIDOf(_classRef, "getPlaybackType", "()I");

  /// from: public int getPlaybackType()
  ///
  /// @return the type of playback associated with this route
  /// Value is android.media.MediaRouter.RouteInfo\#PLAYBACK_TYPE_LOCAL, or android.media.MediaRouter.RouteInfo\#PLAYBACK_TYPE_REMOTE
  ///@see UserRouteInfo\#setPlaybackType(int)
  int getPlaybackType() => jniAccessors.callMethodWithArgs(
      reference, _id_getPlaybackType, jni.JniType.intType, []).integer;

  static final _id_getPlaybackStream =
      jniAccessors.getMethodIDOf(_classRef, "getPlaybackStream", "()I");

  /// from: public int getPlaybackStream()
  ///
  /// @return the stream over which the playback associated with this route is performed
  ///@see UserRouteInfo\#setPlaybackStream(int)
  int getPlaybackStream() => jniAccessors.callMethodWithArgs(
      reference, _id_getPlaybackStream, jni.JniType.intType, []).integer;

  static final _id_getVolume =
      jniAccessors.getMethodIDOf(_classRef, "getVolume", "()I");

  /// from: public int getVolume()
  ///
  /// Return the current volume for this route. Depending on the route, this may only
  /// be valid if the route is currently selected.
  ///@return the volume at which the playback associated with this route is performed
  ///@see UserRouteInfo\#setVolume(int)
  int getVolume() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolume, jni.JniType.intType, []).integer;

  static final _id_requestSetVolume =
      jniAccessors.getMethodIDOf(_classRef, "requestSetVolume", "(I)V");

  /// from: public void requestSetVolume(int volume)
  ///
  /// Request a volume change for this route.
  ///@param volume value between 0 and getVolumeMax
  void requestSetVolume(int volume) => jniAccessors.callMethodWithArgs(
      reference, _id_requestSetVolume, jni.JniType.voidType, [volume]).check();

  static final _id_requestUpdateVolume =
      jniAccessors.getMethodIDOf(_classRef, "requestUpdateVolume", "(I)V");

  /// from: public void requestUpdateVolume(int direction)
  ///
  /// Request an incremental volume update for this route.
  ///@param direction Delta to apply to the current volume
  void requestUpdateVolume(int direction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestUpdateVolume,
      jni.JniType.voidType,
      [direction]).check();

  static final _id_getVolumeMax =
      jniAccessors.getMethodIDOf(_classRef, "getVolumeMax", "()I");

  /// from: public int getVolumeMax()
  ///
  /// @return the maximum volume at which the playback associated with this route is performed
  ///@see UserRouteInfo\#setVolumeMax(int)
  int getVolumeMax() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolumeMax, jni.JniType.intType, []).integer;

  static final _id_getVolumeHandling =
      jniAccessors.getMethodIDOf(_classRef, "getVolumeHandling", "()I");

  /// from: public int getVolumeHandling()
  ///
  /// @return how volume is handling on the route
  /// Value is android.media.MediaRouter.RouteInfo\#PLAYBACK_VOLUME_FIXED, or android.media.MediaRouter.RouteInfo\#PLAYBACK_VOLUME_VARIABLE
  ///@see UserRouteInfo\#setVolumeHandling(int)
  int getVolumeHandling() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolumeHandling, jni.JniType.intType, []).integer;

  static final _id_getPresentationDisplay = jniAccessors.getMethodIDOf(
      _classRef, "getPresentationDisplay", "()Landroid/view/Display;");

  /// from: public android.view.Display getPresentationDisplay()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Display that should be used by the application to show
  /// a android.app.Presentation on an external display when this route is selected.
  /// Depending on the route, this may only be valid if the route is currently
  /// selected.
  ///
  /// The preferred presentation display may change independently of the route
  /// being selected or unselected.  For example, the presentation display
  /// of the default system route may change when an external HDMI display is connected
  /// or disconnected even though the route itself has not changed.
  ///
  ///
  /// This method may return null if there is no external display associated with
  /// the route or if the display is not ready to show UI yet.
  ///
  ///
  /// The application should listen for changes to the presentation display
  /// using the Callback\#onRoutePresentationDisplayChanged callback and
  /// show or dismiss its android.app.Presentation accordingly when the display
  /// becomes available or is removed.
  ///
  ///
  /// This method only makes sense for \#ROUTE_TYPE_LIVE_VIDEO live video routes.
  ///
  ///
  ///@return The preferred presentation display to use when this route is
  /// selected or null if none.
  ///@see \#ROUTE_TYPE_LIVE_VIDEO
  ///@see android.app.Presentation
  display_.Display getPresentationDisplay() =>
      display_.Display.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPresentationDisplay, jni.JniType.objectType, []).object);

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Returns true if this route is enabled and may be selected.
  ///@return True if this route is enabled.
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_isConnecting =
      jniAccessors.getMethodIDOf(_classRef, "isConnecting", "()Z");

  /// from: public boolean isConnecting()
  ///
  /// Returns true if the route is in the process of connecting and is not
  /// yet ready for use.
  ///@return True if this route is in the process of connecting.
  bool isConnecting() => jniAccessors.callMethodWithArgs(
      reference, _id_isConnecting, jni.JniType.booleanType, []).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaRouter$RouteGroup
///
/// Information about a route that consists of multiple other routes in a group.
class MediaRouter_RouteGroup extends MediaRouter_RouteInfo {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRouter\$RouteGroup");
  MediaRouter_RouteGroup.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_addRoute = jniAccessors.getMethodIDOf(
      _classRef, "addRoute", "(Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void addRoute(android.media.MediaRouter.RouteInfo route)
  ///
  /// Add a route to this group. The route must not currently belong to another group.
  ///@param route route to add to this group
  void addRoute(MediaRouter_RouteInfo route) => jniAccessors.callMethodWithArgs(
      reference, _id_addRoute, jni.JniType.voidType, [route.reference]).check();

  static final _id_addRoute1 = jniAccessors.getMethodIDOf(
      _classRef, "addRoute", "(Landroid/media/MediaRouter\$RouteInfo;I)V");

  /// from: public void addRoute(android.media.MediaRouter.RouteInfo route, int insertAt)
  ///
  /// Add a route to this group before the specified index.
  ///@param route route to add
  ///@param insertAt insert the new route before this index
  void addRoute1(MediaRouter_RouteInfo route, int insertAt) =>
      jniAccessors.callMethodWithArgs(reference, _id_addRoute1,
          jni.JniType.voidType, [route.reference, insertAt]).check();

  static final _id_removeRoute = jniAccessors.getMethodIDOf(
      _classRef, "removeRoute", "(Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void removeRoute(android.media.MediaRouter.RouteInfo route)
  ///
  /// Remove a route from this group.
  ///@param route route to remove
  void removeRoute(MediaRouter_RouteInfo route) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeRoute,
          jni.JniType.voidType, [route.reference]).check();

  static final _id_removeRoute1 =
      jniAccessors.getMethodIDOf(_classRef, "removeRoute", "(I)V");

  /// from: public void removeRoute(int index)
  ///
  /// Remove the route at the specified index from this group.
  ///@param index index of the route to remove
  void removeRoute1(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_removeRoute1, jni.JniType.voidType, [index]).check();

  static final _id_getRouteCount =
      jniAccessors.getMethodIDOf(_classRef, "getRouteCount", "()I");

  /// from: public int getRouteCount()
  ///
  /// @return The number of routes in this group
  int getRouteCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRouteCount, jni.JniType.intType, []).integer;

  static final _id_getRouteAt = jniAccessors.getMethodIDOf(
      _classRef, "getRouteAt", "(I)Landroid/media/MediaRouter\$RouteInfo;");

  /// from: public android.media.MediaRouter.RouteInfo getRouteAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the route in this group at the specified index
  ///@param index Index to fetch
  ///@return The route at index
  MediaRouter_RouteInfo getRouteAt(int index) =>
      MediaRouter_RouteInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRouteAt, jni.JniType.objectType, [index]).object);

  static final _id_setIconDrawable = jniAccessors.getMethodIDOf(
      _classRef, "setIconDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setIconDrawable(android.graphics.drawable.Drawable icon)
  ///
  /// Set an icon that will be used to represent this group.
  /// The system may use this icon in picker UIs or similar.
  ///@param icon icon drawable to use to represent this group
  void setIconDrawable(drawable_.Drawable icon) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIconDrawable,
          jni.JniType.voidType, [icon.reference]).check();

  static final _id_setIconResource =
      jniAccessors.getMethodIDOf(_classRef, "setIconResource", "(I)V");

  /// from: public void setIconResource(int resId)
  ///
  /// Set an icon that will be used to represent this group.
  /// The system may use this icon in picker UIs or similar.
  ///@param resId Resource ID of an icon drawable to use to represent this group
  void setIconResource(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setIconResource, jni.JniType.voidType, [resId]).check();

  static final _id_requestSetVolume =
      jniAccessors.getMethodIDOf(_classRef, "requestSetVolume", "(I)V");

  /// from: public void requestSetVolume(int volume)
  void requestSetVolume(int volume) => jniAccessors.callMethodWithArgs(
      reference, _id_requestSetVolume, jni.JniType.voidType, [volume]).check();

  static final _id_requestUpdateVolume =
      jniAccessors.getMethodIDOf(_classRef, "requestUpdateVolume", "(I)V");

  /// from: public void requestUpdateVolume(int direction)
  void requestUpdateVolume(int direction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestUpdateVolume,
      jni.JniType.voidType,
      [direction]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaRouter$RouteCategory
///
/// Definition of a category of routes. All routes belong to a category.
class MediaRouter_RouteCategory extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRouter\$RouteCategory");
  MediaRouter_RouteCategory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getName = jniAccessors.getMethodIDOf(
      _classRef, "getName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the name of this route category
  jni.JniObject getName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_getName1 = jniAccessors.getMethodIDOf(_classRef, "getName",
      "(Landroid/content/Context;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getName(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the properly localized/configuration dependent name of this RouteCategory.
  ///@param context Context to resolve name resources
  ///@return the name of this route category
  jni.JniObject getName1(context_.Context context) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getName1, jni.JniType.objectType, [context.reference]).object);

  static final _id_getRoutes = jniAccessors.getMethodIDOf(
      _classRef, "getRoutes", "(Ljava/util/List;)Ljava/util/List;");

  /// from: public java.util.List<android.media.MediaRouter.RouteInfo> getRoutes(java.util.List<android.media.MediaRouter.RouteInfo> out)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current list of routes in this category that have been added
  /// to the MediaRouter.
  ///
  /// This list will not include routes that are nested within RouteGroups.
  /// A RouteGroup is treated as a single route within its category.
  ///
  ///@param out a List to fill with the routes in this category. If this parameter is
  ///            non-null, it will be cleared, filled with the current routes with this
  ///            category, and returned. If this parameter is null, a new List will be
  ///            allocated to report the category's current routes.
  ///@return A list with the routes in this category that have been added to the MediaRouter.
  jni.JniObject getRoutes(jni.JniObject out) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRoutes, jni.JniType.objectType, [out.reference]).object);

  static final _id_getSupportedTypes =
      jniAccessors.getMethodIDOf(_classRef, "getSupportedTypes", "()I");

  /// from: public int getSupportedTypes()
  ///
  /// @return Flag set describing the route types supported by this category
  int getSupportedTypes() => jniAccessors.callMethodWithArgs(
      reference, _id_getSupportedTypes, jni.JniType.intType, []).integer;

  static final _id_isGroupable =
      jniAccessors.getMethodIDOf(_classRef, "isGroupable", "()Z");

  /// from: public boolean isGroupable()
  ///
  /// Return whether or not this category supports grouping.
  ///
  /// If this method returns true, all routes obtained from this category
  /// via calls to \#getRouteAt(int) will be MediaRouter.RouteGroups.
  ///
  ///@return true if this category supports
  bool isGroupable() => jniAccessors.callMethodWithArgs(
      reference, _id_isGroupable, jni.JniType.booleanType, []).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaRouter$Callback
///
/// Interface for receiving events about media routing changes.
/// All methods of this interface will be called from the application's main thread.
///
/// A Callback will only receive events relevant to routes that the callback
/// was registered for unless the MediaRouter\#CALLBACK_FLAG_UNFILTERED_EVENTS
/// flag was specified in MediaRouter\#addCallback(int, Callback, int).
///
///
///@see MediaRouter\#addCallback(int, Callback, int)
///@see MediaRouter\#removeCallback(Callback)
class MediaRouter_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRouter\$Callback");
  MediaRouter_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaRouter_Callback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onRouteSelected = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteSelected",
      "(Landroid/media/MediaRouter;ILandroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public abstract void onRouteSelected(android.media.MediaRouter router, int type, android.media.MediaRouter.RouteInfo info)
  ///
  /// Called when the supplied route becomes selected as the active route
  /// for the given route type.
  ///@param router the MediaRouter reporting the event
  ///@param type Type flag set indicating the routes that have been selected
  ///@param info Route that has been selected for the given route types
  void onRouteSelected(
          MediaRouter router, int type, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRouteSelected,
          jni.JniType.voidType,
          [router.reference, type, info.reference]).check();

  static final _id_onRouteUnselected = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteUnselected",
      "(Landroid/media/MediaRouter;ILandroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public abstract void onRouteUnselected(android.media.MediaRouter router, int type, android.media.MediaRouter.RouteInfo info)
  ///
  /// Called when the supplied route becomes unselected as the active route
  /// for the given route type.
  ///@param router the MediaRouter reporting the event
  ///@param type Type flag set indicating the routes that have been unselected
  ///@param info Route that has been unselected for the given route types
  void onRouteUnselected(
          MediaRouter router, int type, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRouteUnselected,
          jni.JniType.voidType,
          [router.reference, type, info.reference]).check();

  static final _id_onRouteAdded = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteAdded",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public abstract void onRouteAdded(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  ///
  /// Called when a route for the specified type was added.
  ///@param router the MediaRouter reporting the event
  ///@param info Route that has become available for use
  void onRouteAdded(MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRouteAdded,
          jni.JniType.voidType, [router.reference, info.reference]).check();

  static final _id_onRouteRemoved = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteRemoved",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public abstract void onRouteRemoved(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  ///
  /// Called when a route for the specified type was removed.
  ///@param router the MediaRouter reporting the event
  ///@param info Route that has been removed from availability
  void onRouteRemoved(MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRouteRemoved,
          jni.JniType.voidType, [router.reference, info.reference]).check();

  static final _id_onRouteChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteChanged",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public abstract void onRouteChanged(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  ///
  /// Called when an aspect of the indicated route has changed.
  ///
  /// This will not indicate that the types supported by this route have
  /// changed, only that cosmetic info such as name or status have been updated.
  ///
  ///@param router the MediaRouter reporting the event
  ///@param info The route that was changed
  void onRouteChanged(MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRouteChanged,
          jni.JniType.voidType, [router.reference, info.reference]).check();

  static final _id_onRouteGrouped = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteGrouped",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;Landroid/media/MediaRouter\$RouteGroup;I)V");

  /// from: public abstract void onRouteGrouped(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info, android.media.MediaRouter.RouteGroup group, int index)
  ///
  /// Called when a route is added to a group.
  ///@param router the MediaRouter reporting the event
  ///@param info The route that was added
  ///@param group The group the route was added to
  ///@param index The route index within group that info was added at
  void onRouteGrouped(MediaRouter router, MediaRouter_RouteInfo info,
          MediaRouter_RouteGroup group, int index) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRouteGrouped,
          jni.JniType.voidType,
          [router.reference, info.reference, group.reference, index]).check();

  static final _id_onRouteUngrouped = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteUngrouped",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;Landroid/media/MediaRouter\$RouteGroup;)V");

  /// from: public abstract void onRouteUngrouped(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info, android.media.MediaRouter.RouteGroup group)
  ///
  /// Called when a route is removed from a group.
  ///@param router the MediaRouter reporting the event
  ///@param info The route that was removed
  ///@param group The group the route was removed from
  void onRouteUngrouped(MediaRouter router, MediaRouter_RouteInfo info,
          MediaRouter_RouteGroup group) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRouteUngrouped,
          jni.JniType.voidType,
          [router.reference, info.reference, group.reference]).check();

  static final _id_onRouteVolumeChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onRouteVolumeChanged",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public abstract void onRouteVolumeChanged(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  ///
  /// Called when a route's volume changes.
  ///@param router the MediaRouter reporting the event
  ///@param info The route with altered volume
  void onRouteVolumeChanged(MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRouteVolumeChanged,
          jni.JniType.voidType, [router.reference, info.reference]).check();

  static final _id_onRoutePresentationDisplayChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onRoutePresentationDisplayChanged",
      "(Landroid/media/MediaRouter;Landroid/media/MediaRouter\$RouteInfo;)V");

  /// from: public void onRoutePresentationDisplayChanged(android.media.MediaRouter router, android.media.MediaRouter.RouteInfo info)
  ///
  /// Called when a route's presentation display changes.
  ///
  /// This method is called whenever the route's presentation display becomes
  /// available, is removes or has changes to some of its properties (such as its size).
  ///
  ///
  ///@param router the MediaRouter reporting the event
  ///@param info The route whose presentation display changed
  ///@see RouteInfo\#getPresentationDisplay()
  void onRoutePresentationDisplayChanged(
          MediaRouter router, MediaRouter_RouteInfo info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRoutePresentationDisplayChanged,
          jni.JniType.voidType,
          [router.reference, info.reference]).check();
}
