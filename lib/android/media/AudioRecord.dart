// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AudioFormat.dart" as audioformat_;

import "AudioTimestamp.dart" as audiotimestamp_;

import "MediaSyncEvent.dart" as mediasyncevent_;

import "../os/PersistableBundle.dart" as persistablebundle_;

import "../os/Handler.dart" as handler_;

import "AudioDeviceInfo.dart" as audiodeviceinfo_;

import "AudioRouting.dart" as audiorouting_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.AudioRecord
///
/// The AudioRecord class manages the audio resources for Java applications
/// to record audio from the audio input hardware of the platform. This is
/// achieved by "pulling" (reading) the data from the AudioRecord object. The
/// application is responsible for polling the AudioRecord object in time using one of
/// the following three methods:  \#read(byte[],int, int), \#read(short[], int, int)
/// or \#read(ByteBuffer, int). The choice of which method to use will be based
/// on the audio data storage format that is the most convenient for the user of AudioRecord.
/// Upon creation, an AudioRecord object initializes its associated audio buffer that it will
/// fill with the new audio data. The size of this buffer, specified during the construction,
/// determines how long an AudioRecord can record before "over-running" data that has not
/// been read yet. Data should be read from the audio hardware in chunks of sizes inferior to
/// the total recording buffer size.
class AudioRecord extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/AudioRecord");
  AudioRecord.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ERROR
  ///
  /// Denotes a generic operation failure.
  static const ERROR = -1;

  /// from: static public final int ERROR_BAD_VALUE
  ///
  /// Denotes a failure due to the use of an invalid value.
  static const ERROR_BAD_VALUE = -2;

  /// from: static public final int ERROR_DEAD_OBJECT
  ///
  /// An error code indicating that the object reporting it is no longer valid and needs to
  /// be recreated.
  static const ERROR_DEAD_OBJECT = -6;

  /// from: static public final int ERROR_INVALID_OPERATION
  ///
  /// Denotes a failure due to the improper use of a method.
  static const ERROR_INVALID_OPERATION = -3;

  /// from: static public final int READ_BLOCKING
  ///
  /// The read mode indicating the read operation will block until all data
  /// requested has been read.
  static const READ_BLOCKING = 0;

  /// from: static public final int READ_NON_BLOCKING
  ///
  /// The read mode indicating the read operation will return immediately after
  /// reading as much audio data as possible without blocking.
  static const READ_NON_BLOCKING = 1;

  /// from: static public final int RECORDSTATE_RECORDING
  ///
  /// indicates AudioRecord recording state is recording
  static const RECORDSTATE_RECORDING = 3;

  /// from: static public final int RECORDSTATE_STOPPED
  ///
  /// indicates AudioRecord recording state is not recording
  static const RECORDSTATE_STOPPED = 1;

  /// from: static public final int STATE_INITIALIZED
  ///
  /// indicates AudioRecord state is ready to be used
  static const STATE_INITIALIZED = 1;

  /// from: static public final int STATE_UNINITIALIZED
  ///
  /// indicates AudioRecord state is not successfully initialized.
  static const STATE_UNINITIALIZED = 0;

  /// from: static public final int SUCCESS
  ///
  /// Denotes a successful operation.
  static const SUCCESS = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIIII)V");

  /// from: public void <init>(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class constructor.
  /// Though some invalid parameters will result in an IllegalArgumentException exception,
  /// other errors do not.  Thus you should call \#getState() immediately after construction
  /// to confirm that the object is usable.
  ///@param audioSource the recording source.
  ///   See MediaRecorder.AudioSource for the recording source definitions.
  ///@param sampleRateInHz the sample rate expressed in Hertz. 44100Hz is currently the only
  ///   rate that is guaranteed to work on all devices, but other rates such as 22050,
  ///   16000, and 11025 may work on some devices.
  ///   AudioFormat\#SAMPLE_RATE_UNSPECIFIED means to use a route-dependent value
  ///   which is usually the sample rate of the source.
  ///   \#getSampleRate() can be used to retrieve the actual sample rate chosen.
  ///@param channelConfig describes the configuration of the audio channels.
  ///   See AudioFormat\#CHANNEL_IN_MONO and
  ///   AudioFormat\#CHANNEL_IN_STEREO.  AudioFormat\#CHANNEL_IN_MONO is guaranteed
  ///   to work on all devices.
  ///@param audioFormat the format in which the audio data is to be returned.
  ///   See AudioFormat\#ENCODING_PCM_8BIT, AudioFormat\#ENCODING_PCM_16BIT,
  ///   and AudioFormat\#ENCODING_PCM_FLOAT.
  ///@param bufferSizeInBytes the total size (in bytes) of the buffer where audio data is written
  ///   to during the recording. New audio data can be read from this buffer in smaller chunks
  ///   than this size. See \#getMinBufferSize(int, int, int) to determine the minimum
  ///   required buffer size for the successful creation of an AudioRecord instance. Using values
  ///   smaller than getMinBufferSize() will result in an initialization failure.
  ///@throws java.lang.IllegalArgumentException
  AudioRecord(int audioSource, int sampleRateInHz, int channelConfig,
      int audioFormat, int bufferSizeInBytes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          audioSource,
          sampleRateInHz,
          channelConfig,
          audioFormat,
          bufferSizeInBytes
        ]).object);

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Releases the native AudioRecord resources.
  /// The object can no longer be used and the reference should be set to null
  /// after a call to release()
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getSampleRate =
      jniAccessors.getMethodIDOf(_classRef, "getSampleRate", "()I");

  /// from: public int getSampleRate()
  ///
  /// Returns the configured audio sink sample rate in Hz.
  /// The sink sample rate never changes after construction.
  /// If the constructor had a specific sample rate, then the sink sample rate is that value.
  /// If the constructor had AudioFormat\#SAMPLE_RATE_UNSPECIFIED,
  /// then the sink sample rate is a route-dependent default value based on the source [sic].
  int getSampleRate() => jniAccessors.callMethodWithArgs(
      reference, _id_getSampleRate, jni.JniType.intType, []).integer;

  static final _id_getAudioSource =
      jniAccessors.getMethodIDOf(_classRef, "getAudioSource", "()I");

  /// from: public int getAudioSource()
  ///
  /// Returns the audio recording source.
  ///@see MediaRecorder.AudioSource
  int getAudioSource() => jniAccessors.callMethodWithArgs(
      reference, _id_getAudioSource, jni.JniType.intType, []).integer;

  static final _id_getAudioFormat =
      jniAccessors.getMethodIDOf(_classRef, "getAudioFormat", "()I");

  /// from: public int getAudioFormat()
  ///
  /// Returns the configured audio data encoding. See AudioFormat\#ENCODING_PCM_8BIT,
  /// AudioFormat\#ENCODING_PCM_16BIT, and AudioFormat\#ENCODING_PCM_FLOAT.
  int getAudioFormat() => jniAccessors.callMethodWithArgs(
      reference, _id_getAudioFormat, jni.JniType.intType, []).integer;

  static final _id_getChannelConfiguration =
      jniAccessors.getMethodIDOf(_classRef, "getChannelConfiguration", "()I");

  /// from: public int getChannelConfiguration()
  ///
  /// Returns the configured channel position mask.
  ///  See AudioFormat\#CHANNEL_IN_MONO
  /// and AudioFormat\#CHANNEL_IN_STEREO.
  /// This method may return AudioFormat\#CHANNEL_INVALID if
  /// a channel index mask is used.
  /// Consider \#getFormat() instead, to obtain an AudioFormat,
  /// which contains both the channel position mask and the channel index mask.
  int getChannelConfiguration() => jniAccessors.callMethodWithArgs(
      reference, _id_getChannelConfiguration, jni.JniType.intType, []).integer;

  static final _id_getFormat = jniAccessors.getMethodIDOf(
      _classRef, "getFormat", "()Landroid/media/AudioFormat;");

  /// from: public android.media.AudioFormat getFormat()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the configured <code>AudioRecord</code> format.
  ///@return an AudioFormat containing the
  /// <code>AudioRecord</code> parameters at the time of configuration.
  ///
  /// This value will never be {@code null}.
  audioformat_.AudioFormat getFormat() =>
      audioformat_.AudioFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFormat, jni.JniType.objectType, []).object);

  static final _id_getChannelCount =
      jniAccessors.getMethodIDOf(_classRef, "getChannelCount", "()I");

  /// from: public int getChannelCount()
  ///
  /// Returns the configured number of channels.
  int getChannelCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getChannelCount, jni.JniType.intType, []).integer;

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public int getState()
  ///
  /// Returns the state of the AudioRecord instance. This is useful after the
  /// AudioRecord instance has been created to check if it was initialized
  /// properly. This ensures that the appropriate hardware resources have been
  /// acquired.
  ///@see AudioRecord\#STATE_INITIALIZED
  ///@see AudioRecord\#STATE_UNINITIALIZED
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_getRecordingState =
      jniAccessors.getMethodIDOf(_classRef, "getRecordingState", "()I");

  /// from: public int getRecordingState()
  ///
  /// Returns the recording state of the AudioRecord instance.
  ///@see AudioRecord\#RECORDSTATE_STOPPED
  ///@see AudioRecord\#RECORDSTATE_RECORDING
  int getRecordingState() => jniAccessors.callMethodWithArgs(
      reference, _id_getRecordingState, jni.JniType.intType, []).integer;

  static final _id_getBufferSizeInFrames =
      jniAccessors.getMethodIDOf(_classRef, "getBufferSizeInFrames", "()I");

  /// from: public int getBufferSizeInFrames()
  ///
  /// Returns the frame count of the native <code>AudioRecord</code> buffer.
  ///  This is greater than or equal to the bufferSizeInBytes converted to frame units
  ///  specified in the <code>AudioRecord</code> constructor or Builder.
  ///  The native frame count may be enlarged to accommodate the requirements of the
  ///  source on creation or if the <code>AudioRecord</code>
  ///  is subsequently rerouted.
  ///@return current size in frames of the <code>AudioRecord</code> buffer.
  ///@throws IllegalStateException
  int getBufferSizeInFrames() => jniAccessors.callMethodWithArgs(
      reference, _id_getBufferSizeInFrames, jni.JniType.intType, []).integer;

  static final _id_getNotificationMarkerPosition = jniAccessors.getMethodIDOf(
      _classRef, "getNotificationMarkerPosition", "()I");

  /// from: public int getNotificationMarkerPosition()
  ///
  /// Returns the notification marker position expressed in frames.
  int getNotificationMarkerPosition() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getNotificationMarkerPosition,
      jni.JniType.intType, []).integer;

  static final _id_getPositionNotificationPeriod = jniAccessors.getMethodIDOf(
      _classRef, "getPositionNotificationPeriod", "()I");

  /// from: public int getPositionNotificationPeriod()
  ///
  /// Returns the notification update period expressed in frames.
  int getPositionNotificationPeriod() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPositionNotificationPeriod,
      jni.JniType.intType, []).integer;

  static final _id_getTimestamp = jniAccessors.getMethodIDOf(
      _classRef, "getTimestamp", "(Landroid/media/AudioTimestamp;I)I");

  /// from: public int getTimestamp(android.media.AudioTimestamp outTimestamp, int timebase)
  ///
  /// Poll for an AudioTimestamp on demand.
  ///
  /// The AudioTimestamp reflects the frame delivery information at
  /// the earliest point available in the capture pipeline.
  ///
  /// Calling \#startRecording() following a \#stop() will reset
  /// the frame count to 0.
  ///@param outTimestamp a caller provided non-null AudioTimestamp instance,
  ///        which is updated with the AudioRecord frame delivery information upon success.
  /// This value must never be {@code null}.
  ///@param timebase one of
  ///        AudioTimestamp\#TIMEBASE_BOOTTIME AudioTimestamp.TIMEBASE_BOOTTIME or
  ///        AudioTimestamp\#TIMEBASE_MONOTONIC AudioTimestamp.TIMEBASE_MONOTONIC,
  ///        used to select the clock for the AudioTimestamp time.
  /// Value is android.media.AudioTimestamp\#TIMEBASE_MONOTONIC, or android.media.AudioTimestamp\#TIMEBASE_BOOTTIME
  ///@return \#SUCCESS if a timestamp is available,
  ///         or \#ERROR_INVALID_OPERATION if a timestamp not available.
  int getTimestamp(audiotimestamp_.AudioTimestamp outTimestamp, int timebase) =>
      jniAccessors.callMethodWithArgs(reference, _id_getTimestamp,
          jni.JniType.intType, [outTimestamp.reference, timebase]).integer;

  static final _id_getMinBufferSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMinBufferSize", "(III)I");

  /// from: static public int getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat)
  ///
  /// Returns the minimum buffer size required for the successful creation of an AudioRecord
  /// object, in byte units.
  /// Note that this size doesn't guarantee a smooth recording under load, and higher values
  /// should be chosen according to the expected frequency at which the AudioRecord instance
  /// will be polled for new data.
  /// See \#AudioRecord(int, int, int, int, int) for more information on valid
  /// configuration values.
  ///@param sampleRateInHz the sample rate expressed in Hertz.
  ///   AudioFormat\#SAMPLE_RATE_UNSPECIFIED is not permitted.
  ///@param channelConfig describes the configuration of the audio channels.
  ///   See AudioFormat\#CHANNEL_IN_MONO and
  ///   AudioFormat\#CHANNEL_IN_STEREO
  ///@param audioFormat the format in which the audio data is represented.
  ///   See AudioFormat\#ENCODING_PCM_16BIT.
  ///@return \#ERROR_BAD_VALUE if the recording parameters are not supported by the
  ///  hardware, or an invalid parameter was passed,
  ///  or \#ERROR if the implementation was unable to query the hardware for its
  ///  input properties,
  ///   or the minimum buffer size expressed in bytes.
  ///@see \#AudioRecord(int, int, int, int, int)
  static int getMinBufferSize(
          int sampleRateInHz, int channelConfig, int audioFormat) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getMinBufferSize,
          jni.JniType.intType,
          [sampleRateInHz, channelConfig, audioFormat]).integer;

  static final _id_getAudioSessionId =
      jniAccessors.getMethodIDOf(_classRef, "getAudioSessionId", "()I");

  /// from: public int getAudioSessionId()
  ///
  /// Returns the audio session ID.
  ///@return the ID of the audio session this AudioRecord belongs to.
  int getAudioSessionId() => jniAccessors.callMethodWithArgs(
      reference, _id_getAudioSessionId, jni.JniType.intType, []).integer;

  static final _id_startRecording =
      jniAccessors.getMethodIDOf(_classRef, "startRecording", "()V");

  /// from: public void startRecording()
  ///
  /// Starts recording from the AudioRecord instance.
  ///@throws IllegalStateException
  void startRecording() => jniAccessors.callMethodWithArgs(
      reference, _id_startRecording, jni.JniType.voidType, []).check();

  static final _id_startRecording1 = jniAccessors.getMethodIDOf(
      _classRef, "startRecording", "(Landroid/media/MediaSyncEvent;)V");

  /// from: public void startRecording(android.media.MediaSyncEvent syncEvent)
  ///
  /// Starts recording from the AudioRecord instance when the specified synchronization event
  /// occurs on the specified audio session.
  ///@throws IllegalStateException
  ///@param syncEvent event that triggers the capture.
  ///@see MediaSyncEvent
  void startRecording1(mediasyncevent_.MediaSyncEvent syncEvent) =>
      jniAccessors.callMethodWithArgs(reference, _id_startRecording1,
          jni.JniType.voidType, [syncEvent.reference]).check();

  static final _id_stop = jniAccessors.getMethodIDOf(_classRef, "stop", "()V");

  /// from: public void stop()
  ///
  /// Stops recording.
  ///@throws IllegalStateException
  void stop() => jniAccessors.callMethodWithArgs(
      reference, _id_stop, jni.JniType.voidType, []).check();

  static final _id_read =
      jniAccessors.getMethodIDOf(_classRef, "read", "([BII)I");

  /// from: public int read(byte[] audioData, int offsetInBytes, int sizeInBytes)
  ///
  /// Reads audio data from the audio hardware for recording into a byte array.
  /// The format specified in the AudioRecord constructor should be
  /// AudioFormat\#ENCODING_PCM_8BIT to correspond to the data in the array.
  ///@param audioData the array to which the recorded audio data is written.
  /// This value must never be {@code null}.
  ///@param offsetInBytes index in audioData from which the data is written expressed in bytes.
  ///@param sizeInBytes the number of requested bytes.
  ///@return zero or the positive number of bytes that were read, or one of the following
  ///    error codes. The number of bytes will not exceed sizeInBytes.
  /// <ul>
  /// <li>\#ERROR_INVALID_OPERATION if the object isn't properly initialized</li>
  /// <li>\#ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes</li>
  /// <li>\#ERROR_DEAD_OBJECT if the object is not valid anymore and
  ///    needs to be recreated. The dead object error code is not returned if some data was
  ///    successfully transferred. In this case, the error is returned at the next read()</li>
  /// <li>\#ERROR in case of other error</li>
  /// </ul>
  int read(jni.JniObject audioData, int offsetInBytes, int sizeInBytes) =>
      jniAccessors.callMethodWithArgs(reference, _id_read, jni.JniType.intType,
          [audioData.reference, offsetInBytes, sizeInBytes]).integer;

  static final _id_read1 =
      jniAccessors.getMethodIDOf(_classRef, "read", "([BIII)I");

  /// from: public int read(byte[] audioData, int offsetInBytes, int sizeInBytes, int readMode)
  ///
  /// Reads audio data from the audio hardware for recording into a byte array.
  /// The format specified in the AudioRecord constructor should be
  /// AudioFormat\#ENCODING_PCM_8BIT to correspond to the data in the array.
  /// The format can be AudioFormat\#ENCODING_PCM_16BIT, but this is deprecated.
  ///@param audioData the array to which the recorded audio data is written.
  /// This value must never be {@code null}.
  ///@param offsetInBytes index in audioData to which the data is written expressed in bytes.
  ///        Must not be negative, or cause the data access to go out of bounds of the array.
  ///@param sizeInBytes the number of requested bytes.
  ///        Must not be negative, or cause the data access to go out of bounds of the array.
  ///@param readMode one of \#READ_BLOCKING, \#READ_NON_BLOCKING.
  ///     <br>With \#READ_BLOCKING, the read will block until all the requested data
  ///     is read.
  ///     <br>With \#READ_NON_BLOCKING, the read will return immediately after
  ///     reading as much audio data as possible without blocking.
  /// Value is android.media.AudioRecord\#READ_BLOCKING, or android.media.AudioRecord\#READ_NON_BLOCKING
  ///@return zero or the positive number of bytes that were read, or one of the following
  ///    error codes. The number of bytes will be a multiple of the frame size in bytes
  ///    not to exceed sizeInBytes.
  /// <ul>
  /// <li>\#ERROR_INVALID_OPERATION if the object isn't properly initialized</li>
  /// <li>\#ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes</li>
  /// <li>\#ERROR_DEAD_OBJECT if the object is not valid anymore and
  ///    needs to be recreated. The dead object error code is not returned if some data was
  ///    successfully transferred. In this case, the error is returned at the next read()</li>
  /// <li>\#ERROR in case of other error</li>
  /// </ul>
  int read1(jni.JniObject audioData, int offsetInBytes, int sizeInBytes,
          int readMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_read1, jni.JniType.intType,
          [audioData.reference, offsetInBytes, sizeInBytes, readMode]).integer;

  static final _id_read2 =
      jniAccessors.getMethodIDOf(_classRef, "read", "([SII)I");

  /// from: public int read(short[] audioData, int offsetInShorts, int sizeInShorts)
  ///
  /// Reads audio data from the audio hardware for recording into a short array.
  /// The format specified in the AudioRecord constructor should be
  /// AudioFormat\#ENCODING_PCM_16BIT to correspond to the data in the array.
  ///@param audioData the array to which the recorded audio data is written.
  /// This value must never be {@code null}.
  ///@param offsetInShorts index in audioData to which the data is written expressed in shorts.
  ///        Must not be negative, or cause the data access to go out of bounds of the array.
  ///@param sizeInShorts the number of requested shorts.
  ///        Must not be negative, or cause the data access to go out of bounds of the array.
  ///@return zero or the positive number of shorts that were read, or one of the following
  ///    error codes. The number of shorts will be a multiple of the channel count not to exceed
  ///    sizeInShorts.
  /// <ul>
  /// <li>\#ERROR_INVALID_OPERATION if the object isn't properly initialized</li>
  /// <li>\#ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes</li>
  /// <li>\#ERROR_DEAD_OBJECT if the object is not valid anymore and
  ///    needs to be recreated. The dead object error code is not returned if some data was
  ///    successfully transferred. In this case, the error is returned at the next read()</li>
  /// <li>\#ERROR in case of other error</li>
  /// </ul>
  int read2(jni.JniObject audioData, int offsetInShorts, int sizeInShorts) =>
      jniAccessors.callMethodWithArgs(reference, _id_read2, jni.JniType.intType,
          [audioData.reference, offsetInShorts, sizeInShorts]).integer;

  static final _id_read3 =
      jniAccessors.getMethodIDOf(_classRef, "read", "([SIII)I");

  /// from: public int read(short[] audioData, int offsetInShorts, int sizeInShorts, int readMode)
  ///
  /// Reads audio data from the audio hardware for recording into a short array.
  /// The format specified in the AudioRecord constructor should be
  /// AudioFormat\#ENCODING_PCM_16BIT to correspond to the data in the array.
  ///@param audioData the array to which the recorded audio data is written.
  /// This value must never be {@code null}.
  ///@param offsetInShorts index in audioData from which the data is written expressed in shorts.
  ///        Must not be negative, or cause the data access to go out of bounds of the array.
  ///@param sizeInShorts the number of requested shorts.
  ///        Must not be negative, or cause the data access to go out of bounds of the array.
  ///@param readMode one of \#READ_BLOCKING, \#READ_NON_BLOCKING.
  ///     <br>With \#READ_BLOCKING, the read will block until all the requested data
  ///     is read.
  ///     <br>With \#READ_NON_BLOCKING, the read will return immediately after
  ///     reading as much audio data as possible without blocking.
  /// Value is android.media.AudioRecord\#READ_BLOCKING, or android.media.AudioRecord\#READ_NON_BLOCKING
  ///@return zero or the positive number of shorts that were read, or one of the following
  ///    error codes. The number of shorts will be a multiple of the channel count not to exceed
  ///    sizeInShorts.
  /// <ul>
  /// <li>\#ERROR_INVALID_OPERATION if the object isn't properly initialized</li>
  /// <li>\#ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes</li>
  /// <li>\#ERROR_DEAD_OBJECT if the object is not valid anymore and
  ///    needs to be recreated. The dead object error code is not returned if some data was
  ///    successfully transferred. In this case, the error is returned at the next read()</li>
  /// <li>\#ERROR in case of other error</li>
  /// </ul>
  int read3(jni.JniObject audioData, int offsetInShorts, int sizeInShorts,
          int readMode) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_read3, jni.JniType.intType, [
        audioData.reference,
        offsetInShorts,
        sizeInShorts,
        readMode
      ]).integer;

  static final _id_read4 =
      jniAccessors.getMethodIDOf(_classRef, "read", "([FIII)I");

  /// from: public int read(float[] audioData, int offsetInFloats, int sizeInFloats, int readMode)
  ///
  /// Reads audio data from the audio hardware for recording into a float array.
  /// The format specified in the AudioRecord constructor should be
  /// AudioFormat\#ENCODING_PCM_FLOAT to correspond to the data in the array.
  ///@param audioData the array to which the recorded audio data is written.
  /// This value must never be {@code null}.
  ///@param offsetInFloats index in audioData from which the data is written.
  ///        Must not be negative, or cause the data access to go out of bounds of the array.
  ///@param sizeInFloats the number of requested floats.
  ///        Must not be negative, or cause the data access to go out of bounds of the array.
  ///@param readMode one of \#READ_BLOCKING, \#READ_NON_BLOCKING.
  ///     <br>With \#READ_BLOCKING, the read will block until all the requested data
  ///     is read.
  ///     <br>With \#READ_NON_BLOCKING, the read will return immediately after
  ///     reading as much audio data as possible without blocking.
  /// Value is android.media.AudioRecord\#READ_BLOCKING, or android.media.AudioRecord\#READ_NON_BLOCKING
  ///@return zero or the positive number of floats that were read, or one of the following
  ///    error codes. The number of floats will be a multiple of the channel count not to exceed
  ///    sizeInFloats.
  /// <ul>
  /// <li>\#ERROR_INVALID_OPERATION if the object isn't properly initialized</li>
  /// <li>\#ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes</li>
  /// <li>\#ERROR_DEAD_OBJECT if the object is not valid anymore and
  ///    needs to be recreated. The dead object error code is not returned if some data was
  ///    successfully transferred. In this case, the error is returned at the next read()</li>
  /// <li>\#ERROR in case of other error</li>
  /// </ul>
  int read4(jni.JniObject audioData, int offsetInFloats, int sizeInFloats,
          int readMode) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_read4, jni.JniType.intType, [
        audioData.reference,
        offsetInFloats,
        sizeInFloats,
        readMode
      ]).integer;

  static final _id_read5 = jniAccessors.getMethodIDOf(
      _classRef, "read", "(Ljava/nio/ByteBuffer;I)I");

  /// from: public int read(java.nio.ByteBuffer audioBuffer, int sizeInBytes)
  ///
  /// Reads audio data from the audio hardware for recording into a direct buffer. If this buffer
  /// is not a direct buffer, this method will always return 0.
  /// Note that the value returned by java.nio.Buffer\#position() on this buffer is
  /// unchanged after a call to this method.
  /// The representation of the data in the buffer will depend on the format specified in
  /// the AudioRecord constructor, and will be native endian.
  ///@param audioBuffer the direct buffer to which the recorded audio data is written.
  /// Data is written to audioBuffer.position().
  /// This value must never be {@code null}.
  ///@param sizeInBytes the number of requested bytes. It is recommended but not enforced
  ///    that the number of bytes requested be a multiple of the frame size (sample size in
  ///    bytes multiplied by the channel count).
  ///@return zero or the positive number of bytes that were read, or one of the following
  ///    error codes. The number of bytes will not exceed sizeInBytes and will be truncated to be
  ///    a multiple of the frame size.
  /// <ul>
  /// <li>\#ERROR_INVALID_OPERATION if the object isn't properly initialized</li>
  /// <li>\#ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes</li>
  /// <li>\#ERROR_DEAD_OBJECT if the object is not valid anymore and
  ///    needs to be recreated. The dead object error code is not returned if some data was
  ///    successfully transferred. In this case, the error is returned at the next read()</li>
  /// <li>\#ERROR in case of other error</li>
  /// </ul>
  int read5(jni.JniObject audioBuffer, int sizeInBytes) =>
      jniAccessors.callMethodWithArgs(reference, _id_read5, jni.JniType.intType,
          [audioBuffer.reference, sizeInBytes]).integer;

  static final _id_read6 = jniAccessors.getMethodIDOf(
      _classRef, "read", "(Ljava/nio/ByteBuffer;II)I");

  /// from: public int read(java.nio.ByteBuffer audioBuffer, int sizeInBytes, int readMode)
  ///
  /// Reads audio data from the audio hardware for recording into a direct buffer. If this buffer
  /// is not a direct buffer, this method will always return 0.
  /// Note that the value returned by java.nio.Buffer\#position() on this buffer is
  /// unchanged after a call to this method.
  /// The representation of the data in the buffer will depend on the format specified in
  /// the AudioRecord constructor, and will be native endian.
  ///@param audioBuffer the direct buffer to which the recorded audio data is written.
  /// Data is written to audioBuffer.position().
  /// This value must never be {@code null}.
  ///@param sizeInBytes the number of requested bytes. It is recommended but not enforced
  ///    that the number of bytes requested be a multiple of the frame size (sample size in
  ///    bytes multiplied by the channel count).
  ///@param readMode one of \#READ_BLOCKING, \#READ_NON_BLOCKING.
  ///     <br>With \#READ_BLOCKING, the read will block until all the requested data
  ///     is read.
  ///     <br>With \#READ_NON_BLOCKING, the read will return immediately after
  ///     reading as much audio data as possible without blocking.
  /// Value is android.media.AudioRecord\#READ_BLOCKING, or android.media.AudioRecord\#READ_NON_BLOCKING
  ///@return zero or the positive number of bytes that were read, or one of the following
  ///    error codes. The number of bytes will not exceed sizeInBytes and will be truncated to be
  ///    a multiple of the frame size.
  /// <ul>
  /// <li>\#ERROR_INVALID_OPERATION if the object isn't properly initialized</li>
  /// <li>\#ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes</li>
  /// <li>\#ERROR_DEAD_OBJECT if the object is not valid anymore and
  ///    needs to be recreated. The dead object error code is not returned if some data was
  ///    successfully transferred. In this case, the error is returned at the next read()</li>
  /// <li>\#ERROR in case of other error</li>
  /// </ul>
  int read6(jni.JniObject audioBuffer, int sizeInBytes, int readMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_read6, jni.JniType.intType,
          [audioBuffer.reference, sizeInBytes, readMode]).integer;

  static final _id_getMetrics = jniAccessors.getMethodIDOf(
      _classRef, "getMetrics", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getMetrics()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return Metrics data about the current AudioTrack instance.
  ///@return a PersistableBundle containing the set of attributes and values
  /// available for the media being handled by this instance of AudioRecord
  /// The attributes are descibed in MetricsConstants.
  ///
  /// Additional vendor-specific fields may also be present in
  /// the return value.
  persistablebundle_.PersistableBundle getMetrics() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getMetrics, jni.JniType.objectType, []).object);

  static final _id_setRecordPositionUpdateListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setRecordPositionUpdateListener",
      "(Landroid/media/AudioRecord\$OnRecordPositionUpdateListener;)V");

  /// from: public void setRecordPositionUpdateListener(android.media.AudioRecord.OnRecordPositionUpdateListener listener)
  ///
  /// Sets the listener the AudioRecord notifies when a previously set marker is reached or
  /// for each periodic record head position update.
  ///@param listener
  void setRecordPositionUpdateListener(
          AudioRecord_OnRecordPositionUpdateListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRecordPositionUpdateListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setRecordPositionUpdateListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setRecordPositionUpdateListener",
      "(Landroid/media/AudioRecord\$OnRecordPositionUpdateListener;Landroid/os/Handler;)V");

  /// from: public void setRecordPositionUpdateListener(android.media.AudioRecord.OnRecordPositionUpdateListener listener, android.os.Handler handler)
  ///
  /// Sets the listener the AudioRecord notifies when a previously set marker is reached or
  /// for each periodic record head position update.
  /// Use this method to receive AudioRecord events in the Handler associated with another
  /// thread than the one in which you created the AudioRecord instance.
  ///@param listener
  ///@param handler the Handler that will receive the event notification messages.
  void setRecordPositionUpdateListener1(
          AudioRecord_OnRecordPositionUpdateListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRecordPositionUpdateListener1,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_setNotificationMarkerPosition = jniAccessors.getMethodIDOf(
      _classRef, "setNotificationMarkerPosition", "(I)I");

  /// from: public int setNotificationMarkerPosition(int markerInFrames)
  ///
  /// Sets the marker position at which the listener is called, if set with
  /// \#setRecordPositionUpdateListener(OnRecordPositionUpdateListener) or
  /// \#setRecordPositionUpdateListener(OnRecordPositionUpdateListener, Handler).
  ///@param markerInFrames marker position expressed in frames
  ///@return error code or success, see \#SUCCESS, \#ERROR_BAD_VALUE,
  ///  \#ERROR_INVALID_OPERATION
  int setNotificationMarkerPosition(int markerInFrames) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setNotificationMarkerPosition,
          jni.JniType.intType,
          [markerInFrames]).integer;

  static final _id_getRoutedDevice = jniAccessors.getMethodIDOf(
      _classRef, "getRoutedDevice", "()Landroid/media/AudioDeviceInfo;");

  /// from: public android.media.AudioDeviceInfo getRoutedDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an AudioDeviceInfo identifying the current routing of this AudioRecord.
  /// Note: The query is only valid if the AudioRecord is currently recording. If it is not,
  /// <code>getRoutedDevice()</code> will return null.
  audiodeviceinfo_.AudioDeviceInfo getRoutedDevice() =>
      audiodeviceinfo_.AudioDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRoutedDevice, jni.JniType.objectType, []).object);

  static final _id_addOnRoutingChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnRoutingChangedListener",
      "(Landroid/media/AudioRouting\$OnRoutingChangedListener;Landroid/os/Handler;)V");

  /// from: public void addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener listener, android.os.Handler handler)
  ///
  /// Adds an AudioRouting.OnRoutingChangedListener to receive notifications of
  /// routing changes on this AudioRecord.
  ///@param listener The AudioRouting.OnRoutingChangedListener interface to receive
  /// notifications of rerouting events.
  ///@param handler Specifies the Handler object for the thread on which to execute
  /// the callback. If <code>null</code>, the Handler associated with the main
  /// Looper will be used.
  void addOnRoutingChangedListener(
          audiorouting_.AudioRouting_OnRoutingChangedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnRoutingChangedListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeOnRoutingChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnRoutingChangedListener",
      "(Landroid/media/AudioRouting\$OnRoutingChangedListener;)V");

  /// from: public void removeOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener listener)
  ///
  /// Removes an AudioRouting.OnRoutingChangedListener which has been previously added
  /// to receive rerouting notifications.
  ///@param listener The previously added AudioRouting.OnRoutingChangedListener interface
  /// to remove.
  void removeOnRoutingChangedListener(
          audiorouting_.AudioRouting_OnRoutingChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnRoutingChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_addOnRoutingChangedListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnRoutingChangedListener",
      "(Landroid/media/AudioRecord\$OnRoutingChangedListener;Landroid/os/Handler;)V");

  /// from: public void addOnRoutingChangedListener(android.media.AudioRecord.OnRoutingChangedListener listener, android.os.Handler handler)
  ///
  /// Adds an OnRoutingChangedListener to receive notifications of routing changes
  /// on this AudioRecord.
  ///@param listener The OnRoutingChangedListener interface to receive notifications
  /// of rerouting events.
  ///@param handler Specifies the Handler object for the thread on which to execute
  /// the callback. If <code>null</code>, the Handler associated with the main
  /// Looper will be used.
  ///@deprecated users should switch to the general purpose
  ///             AudioRouting.OnRoutingChangedListener class instead.
  void addOnRoutingChangedListener1(
          AudioRecord_OnRoutingChangedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnRoutingChangedListener1,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeOnRoutingChangedListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnRoutingChangedListener",
      "(Landroid/media/AudioRecord\$OnRoutingChangedListener;)V");

  /// from: public void removeOnRoutingChangedListener(android.media.AudioRecord.OnRoutingChangedListener listener)
  ///
  /// Removes an OnRoutingChangedListener which has been previously added
  /// to receive rerouting notifications.
  ///@param listener The previously added OnRoutingChangedListener interface to remove.
  ///@deprecated users should switch to the general purpose
  ///             AudioRouting.OnRoutingChangedListener class instead.
  void removeOnRoutingChangedListener1(
          AudioRecord_OnRoutingChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnRoutingChangedListener1,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setPositionNotificationPeriod = jniAccessors.getMethodIDOf(
      _classRef, "setPositionNotificationPeriod", "(I)I");

  /// from: public int setPositionNotificationPeriod(int periodInFrames)
  ///
  /// Sets the period at which the listener is called, if set with
  /// \#setRecordPositionUpdateListener(OnRecordPositionUpdateListener) or
  /// \#setRecordPositionUpdateListener(OnRecordPositionUpdateListener, Handler).
  /// It is possible for notifications to be lost if the period is too small.
  ///@param periodInFrames update period expressed in frames
  ///@return error code or success, see \#SUCCESS, \#ERROR_INVALID_OPERATION
  int setPositionNotificationPeriod(int periodInFrames) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPositionNotificationPeriod,
          jni.JniType.intType,
          [periodInFrames]).integer;

  static final _id_setPreferredDevice = jniAccessors.getMethodIDOf(
      _classRef, "setPreferredDevice", "(Landroid/media/AudioDeviceInfo;)Z");

  /// from: public boolean setPreferredDevice(android.media.AudioDeviceInfo deviceInfo)
  ///
  /// Specifies an audio device (via an AudioDeviceInfo object) to route
  /// the input to this AudioRecord.
  ///@param deviceInfo The AudioDeviceInfo specifying the audio source.
  ///  If deviceInfo is null, default routing is restored.
  ///@return true if successful, false if the specified AudioDeviceInfo is non-null and
  /// does not correspond to a valid audio input device.
  bool setPreferredDevice(audiodeviceinfo_.AudioDeviceInfo deviceInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreferredDevice,
          jni.JniType.booleanType, [deviceInfo.reference]).boolean;

  static final _id_getPreferredDevice = jniAccessors.getMethodIDOf(
      _classRef, "getPreferredDevice", "()Landroid/media/AudioDeviceInfo;");

  /// from: public android.media.AudioDeviceInfo getPreferredDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the selected input specified by \#setPreferredDevice. Note that this
  /// is not guarenteed to correspond to the actual device being used for recording.
  audiodeviceinfo_.AudioDeviceInfo getPreferredDevice() =>
      audiodeviceinfo_.AudioDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPreferredDevice,
          jni.JniType.objectType, []).object);

  static final _id_getActiveMicrophones = jniAccessors.getMethodIDOf(
      _classRef, "getActiveMicrophones", "()Ljava/util/List;");

  /// from: public java.util.List<android.media.MicrophoneInfo> getActiveMicrophones()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a lists of MicrophoneInfo representing the active microphones.
  /// By querying channel mapping for each active microphone, developer can know how
  /// the microphone is used by each channels or a capture stream.
  /// Note that the information about the active microphones may change during a recording.
  /// See AudioManager\#registerAudioDeviceCallback to be notified of changes
  /// in the audio devices, querying the active microphones then will return the latest
  /// information.
  ///@return a lists of MicrophoneInfo representing the active microphones.
  ///@throws IOException if an error occurs
  jni.JniObject getActiveMicrophones() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getActiveMicrophones, jni.JniType.objectType, []).object);
}

/// from: android.media.AudioRecord$OnRoutingChangedListener
///
/// Defines the interface by which applications can receive notifications of
/// routing changes for the associated AudioRecord.
///@deprecated users should switch to the general purpose
///             AudioRouting.OnRoutingChangedListener class instead.
class AudioRecord_OnRoutingChangedListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/AudioRecord\$OnRoutingChangedListener");
  AudioRecord_OnRoutingChangedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onRoutingChanged = jniAccessors.getMethodIDOf(
      _classRef, "onRoutingChanged", "(Landroid/media/AudioRecord;)V");

  /// from: public abstract void onRoutingChanged(android.media.AudioRecord audioRecord)
  ///
  /// Called when the routing of an AudioRecord changes from either and
  /// explicit or policy rerouting. Use \#getRoutedDevice() to
  /// retrieve the newly routed-from device.
  void onRoutingChanged(AudioRecord audioRecord) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRoutingChanged,
          jni.JniType.voidType, [audioRecord.reference]).check();

  static final _id_onRoutingChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "onRoutingChanged", "(Landroid/media/AudioRouting;)V");

  /// from: default public void onRoutingChanged(android.media.AudioRouting router)
  void onRoutingChanged1(audiorouting_.AudioRouting router) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRoutingChanged1,
          jni.JniType.voidType, [router.reference]).check();
}

/// from: android.media.AudioRecord$OnRecordPositionUpdateListener
///
/// Interface definition for a callback to be invoked when an AudioRecord has
/// reached a notification marker set by AudioRecord\#setNotificationMarkerPosition(int)
/// or for periodic updates on the progress of the record head, as set by
/// AudioRecord\#setPositionNotificationPeriod(int).
class AudioRecord_OnRecordPositionUpdateListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/AudioRecord\$OnRecordPositionUpdateListener");
  AudioRecord_OnRecordPositionUpdateListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onMarkerReached = jniAccessors.getMethodIDOf(
      _classRef, "onMarkerReached", "(Landroid/media/AudioRecord;)V");

  /// from: public abstract void onMarkerReached(android.media.AudioRecord recorder)
  ///
  /// Called on the listener to notify it that the previously set marker has been reached
  /// by the recording head.
  void onMarkerReached(AudioRecord recorder) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onMarkerReached,
      jni.JniType.voidType,
      [recorder.reference]).check();

  static final _id_onPeriodicNotification = jniAccessors.getMethodIDOf(
      _classRef, "onPeriodicNotification", "(Landroid/media/AudioRecord;)V");

  /// from: public abstract void onPeriodicNotification(android.media.AudioRecord recorder)
  ///
  /// Called on the listener to periodically notify it that the record head has reached
  /// a multiple of the notification period.
  void onPeriodicNotification(AudioRecord recorder) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPeriodicNotification,
          jni.JniType.voidType, [recorder.reference]).check();
}

/// from: android.media.AudioRecord$MetricsConstants
class AudioRecord_MetricsConstants extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/AudioRecord\$MetricsConstants");
  AudioRecord_MetricsConstants.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CHANNELS
  ///
  /// Key to extract the number of channels being recorded in this record track
  /// from the AudioRecord\#getMetrics return value.
  /// The value is an integer.
  static const CHANNELS = "android.media.audiorecord.channels";

  /// from: static public final java.lang.String ENCODING
  ///
  /// Key to extract the output format being recorded
  /// from the AudioRecord\#getMetrics return value.
  /// The value is a String.
  static const ENCODING = "android.media.audiorecord.encoding";

  /// from: static public final java.lang.String LATENCY
  ///
  /// Key to extract the estimated latency through the recording pipeline
  /// from the AudioRecord\#getMetrics return value.
  /// This is in units of milliseconds.
  /// The value is an integer.
  static const LATENCY = "android.media.audiorecord.latency";

  /// from: static public final java.lang.String SAMPLERATE
  ///
  /// Key to extract the sink sample rate for this record track in Hz
  /// from the AudioRecord\#getMetrics return value.
  /// The value is an integer.
  static const SAMPLERATE = "android.media.audiorecord.samplerate";

  /// from: static public final java.lang.String SOURCE
  ///
  /// Key to extract the Source Type for this track
  /// from the AudioRecord\#getMetrics return value.
  /// The value is a String.
  static const SOURCE = "android.media.audiorecord.source";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AudioRecord_MetricsConstants()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.media.AudioRecord$Builder
///
/// Builder class for AudioRecord objects.
/// Use this class to configure and create an <code>AudioRecord</code> instance. By setting the
/// recording source and audio format parameters, you indicate which of
/// those vary from the default behavior on the device.
///  Here is an example where <code>Builder</code> is used to specify all AudioFormat
/// parameters, to be used by a new <code>AudioRecord</code> instance:
///
/// <pre class="prettyprint">
/// AudioRecord recorder = new AudioRecord.Builder()
///         .setAudioSource(MediaRecorder.AudioSource.VOICE_COMMUNICATION)
///         .setAudioFormat(new AudioFormat.Builder()
///                 .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
///                 .setSampleRate(32000)
///                 .setChannelMask(AudioFormat.CHANNEL_IN_MONO)
///                 .build())
///         .setBufferSize(2*minBuffSize)
///         .build();
/// </pre>
///
/// If the audio source is not set with \#setAudioSource(int),
/// MediaRecorder.AudioSource\#DEFAULT is used.
/// <br>If the audio format is not specified or is incomplete, its channel configuration will be
/// AudioFormat\#CHANNEL_IN_MONO, and the encoding will be
/// AudioFormat\#ENCODING_PCM_16BIT.
/// The sample rate will depend on the device actually selected for capture and can be queried
/// with \#getSampleRate() method.
/// <br>If the buffer size is not specified with \#setBufferSizeInBytes(int),
/// the minimum buffer size for the source is used.
class AudioRecord_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/AudioRecord\$Builder");
  AudioRecord_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new Builder with the default values as described above.
  AudioRecord_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setAudioSource = jniAccessors.getMethodIDOf(
      _classRef, "setAudioSource", "(I)Landroid/media/AudioRecord\$Builder;");

  /// from: public android.media.AudioRecord.Builder setAudioSource(int source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param source the audio source.
  /// See MediaRecorder.AudioSource for the supported audio source definitions.
  ///@return the same Builder instance.
  ///@throws IllegalArgumentException
  AudioRecord_Builder setAudioSource(int source) =>
      AudioRecord_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setAudioSource, jni.JniType.objectType, [source]).object);

  static final _id_setAudioFormat = jniAccessors.getMethodIDOf(
      _classRef,
      "setAudioFormat",
      "(Landroid/media/AudioFormat;)Landroid/media/AudioRecord\$Builder;");

  /// from: public android.media.AudioRecord.Builder setAudioFormat(android.media.AudioFormat format)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the format of the audio data to be captured.
  ///@param format a non-null AudioFormat instance
  /// This value must never be {@code null}.
  ///@return the same Builder instance.
  ///@throws IllegalArgumentException
  AudioRecord_Builder setAudioFormat(audioformat_.AudioFormat format) =>
      AudioRecord_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setAudioFormat,
          jni.JniType.objectType,
          [format.reference]).object);

  static final _id_setBufferSizeInBytes = jniAccessors.getMethodIDOf(_classRef,
      "setBufferSizeInBytes", "(I)Landroid/media/AudioRecord\$Builder;");

  /// from: public android.media.AudioRecord.Builder setBufferSizeInBytes(int bufferSizeInBytes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the total size (in bytes) of the buffer where audio data is written
  /// during the recording. New audio data can be read from this buffer in smaller chunks
  /// than this size. See \#getMinBufferSize(int, int, int) to determine the minimum
  /// required buffer size for the successful creation of an AudioRecord instance.
  /// Since bufferSizeInBytes may be internally increased to accommodate the source
  /// requirements, use \#getBufferSizeInFrames() to determine the actual buffer size
  /// in frames.
  ///@param bufferSizeInBytes a value strictly greater than 0
  ///@return the same Builder instance.
  ///@throws IllegalArgumentException
  AudioRecord_Builder setBufferSizeInBytes(int bufferSizeInBytes) =>
      AudioRecord_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setBufferSizeInBytes,
          jni.JniType.objectType,
          [bufferSizeInBytes]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/media/AudioRecord;");

  /// from: public android.media.AudioRecord build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return a new AudioRecord instance successfully initialized with all
  ///     the parameters set on this <code>Builder</code>.
  ///@throws UnsupportedOperationException if the parameters set on the <code>Builder</code>
  ///     were incompatible, or if they are not supported by the device,
  ///     or if the device was not available.
  AudioRecord build() => AudioRecord.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_build, jni.JniType.objectType, []).object);
}
