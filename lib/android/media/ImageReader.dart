// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/Surface.dart" as surface_;

import "Image.dart" as image_;

import "../os/Handler.dart" as handler_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.ImageReader
///
/// The ImageReader class allows direct application access to image data
/// rendered into a android.view.Surface
///
///
/// Several Android media API classes accept Surface objects as targets to
/// render to, including MediaPlayer, MediaCodec,
/// android.hardware.camera2.CameraDevice, ImageWriter and
/// android.renderscript.Allocation RenderScript Allocations. The image
/// sizes and formats that can be used with each source vary, and should be
/// checked in the documentation for the specific API.
///
///
/// The image data is encapsulated in Image objects, and multiple such
/// objects can be accessed at the same time, up to the number specified by the
/// {@code maxImages} constructor parameter. New images sent to an ImageReader
/// through its Surface are queued until accessed through the \#acquireLatestImage
/// or \#acquireNextImage call. Due to memory limits, an image source will
/// eventually stall or drop Images in trying to render to the Surface if the
/// ImageReader does not obtain and release Images at a rate equal to the
/// production rate.
///
class ImageReader extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/ImageReader");
  ImageReader.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_newInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "newInstance", "(IIII)Landroid/media/ImageReader;");

  /// from: static public android.media.ImageReader newInstance(int width, int height, int format, int maxImages)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  /// Create a new reader for images of the desired size and format.
  ///
  ///
  ///
  /// The {@code maxImages} parameter determines the maximum number of
  /// Image objects that can be be acquired from the
  /// {@code ImageReader} simultaneously. Requesting more buffers will use up
  /// more memory, so it is important to use only the minimum number necessary
  /// for the use case.
  ///
  ///
  ///
  /// The valid sizes and formats depend on the source of the image data.
  ///
  ///
  ///
  /// If the {@code format} is ImageFormat\#PRIVATE PRIVATE, the created
  /// ImageReader will produce images that are not directly accessible
  /// by the application. The application can still acquire images from this
  /// ImageReader, and send them to the
  /// android.hardware.camera2.CameraDevice camera for reprocessing via
  /// ImageWriter interface. However, the Image\#getPlanes() getPlanes() will return an empty array for ImageFormat\#PRIVATE PRIVATE format images. The application can check if an existing reader's
  /// format by calling \#getImageFormat().
  ///
  ///
  ///
  /// ImageFormat\#PRIVATE PRIVATE format ImageReader ImageReaders are more efficient to use when application access to image
  /// data is not necessary, compared to ImageReaders using other format such
  /// as ImageFormat\#YUV_420_888 YUV_420_888.
  ///
  ///
  ///@param width The default width in pixels of the Images that this reader
  ///            will produce.
  ///@param height The default height in pixels of the Images that this reader
  ///            will produce.
  ///@param format The format of the Image that this reader will produce. This
  ///            must be one of the android.graphics.ImageFormat or
  ///            android.graphics.PixelFormat constants. Note that not
  ///            all formats are supported, like ImageFormat.NV21.
  ///@param maxImages The maximum number of images the user will want to
  ///            access simultaneously. This should be as small as possible to
  ///            limit memory use. Once maxImages Images are obtained by the
  ///            user, one of them has to be released before a new Image will
  ///            become available for access through
  ///            \#acquireLatestImage() or \#acquireNextImage().
  ///            Must be greater than 0.
  ///@see Image
  static ImageReader newInstance(
          int width, int height, int format, int maxImages) =>
      ImageReader.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newInstance,
          jni.JniType.objectType,
          [width, height, format, maxImages]).object);

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// The default width of Image Images, in pixels.
  ///
  /// The width may be overridden by the producer sending buffers to this
  /// ImageReader's Surface. If so, the actual width of the images can be
  /// found using Image\#getWidth.
  ///
  ///@return the expected width of an Image
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// The default height of Image Images, in pixels.
  ///
  /// The height may be overridden by the producer sending buffers to this
  /// ImageReader's Surface. If so, the actual height of the images can be
  /// found using Image\#getHeight.
  ///
  ///@return the expected height of an Image
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getImageFormat =
      jniAccessors.getMethodIDOf(_classRef, "getImageFormat", "()I");

  /// from: public int getImageFormat()
  ///
  /// The default ImageFormat image format of Image Images.
  ///
  /// Some color formats may be overridden by the producer sending buffers to
  /// this ImageReader's Surface if the default color format allows. ImageReader
  /// guarantees that all Image Images acquired from ImageReader
  /// (for example, with \#acquireNextImage) will have a "compatible"
  /// format to what was specified in \#newInstance.
  /// As of now, each format is only compatible to itself.
  /// The actual format of the images can be found using Image\#getFormat.
  ///
  ///@return the expected format of an Image
  ///@see ImageFormat
  int getImageFormat() => jniAccessors.callMethodWithArgs(
      reference, _id_getImageFormat, jni.JniType.intType, []).integer;

  static final _id_getMaxImages =
      jniAccessors.getMethodIDOf(_classRef, "getMaxImages", "()I");

  /// from: public int getMaxImages()
  ///
  /// Maximum number of images that can be acquired from the ImageReader by any time (for example,
  /// with \#acquireNextImage).
  ///
  /// An image is considered acquired after it's returned by a function from ImageReader, and
  /// until the Image is Image\#close closed to release the image back to the ImageReader.
  ///
  ///
  ///
  /// Attempting to acquire more than {@code maxImages} concurrently will result in the
  /// acquire function throwing a IllegalStateException. Furthermore,
  /// while the max number of images have been acquired by the ImageReader user, the producer
  /// enqueueing additional images may stall until at least one image has been released.
  ///
  ///@return Maximum number of images for this ImageReader.
  ///@see Image\#close
  int getMaxImages() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxImages, jni.JniType.intType, []).integer;

  static final _id_getSurface = jniAccessors.getMethodIDOf(
      _classRef, "getSurface", "()Landroid/view/Surface;");

  /// from: public android.view.Surface getSurface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a Surface that can be used to produce Image Images for this
  /// {@code ImageReader}.
  ///
  ///
  /// Until valid image data is rendered into this Surface, the
  /// \#acquireNextImage method will return {@code null}. Only one source
  /// can be producing data into this Surface at the same time, although the
  /// same Surface can be reused with a different API once the first source is
  /// disconnected from the Surface.
  ///
  ///
  /// Please note that holding on to the Surface object returned by this method is not enough
  /// to keep its parent ImageReader from being reclaimed. In that sense, a Surface acts like a
  /// java.lang.ref.WeakReference weak reference to the ImageReader that provides it.
  ///
  ///@return A Surface to use for a drawing target for various APIs.
  surface_.Surface getSurface() =>
      surface_.Surface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurface, jni.JniType.objectType, []).object);

  static final _id_acquireLatestImage = jniAccessors.getMethodIDOf(
      _classRef, "acquireLatestImage", "()Landroid/media/Image;");

  /// from: public android.media.Image acquireLatestImage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  /// Acquire the latest Image from the ImageReader's queue, dropping older
  /// Image images. Returns {@code null} if no new image is available.
  ///
  ///
  ///
  /// This operation will acquire all the images possible from the ImageReader,
  /// but \#close all images that aren't the latest. This function is
  /// recommended to use over \#acquireNextImage for most use-cases, as it's
  /// more suited for real-time processing.
  ///
  ///
  ///
  /// Note that \#getMaxImages maxImages should be at least 2 for
  /// \#acquireLatestImage to be any different than \#acquireNextImage -
  /// discarding all-but-the-newest Image requires temporarily acquiring two
  /// Image Images at once. Or more generally, calling \#acquireLatestImage
  /// with less than two images of margin, that is
  /// {@code (maxImages - currentAcquiredImages < 2)} will not discard as expected.
  ///
  ///
  ///
  /// This operation will fail by throwing an IllegalStateException if
  /// {@code maxImages} have been acquired with \#acquireLatestImage or
  /// \#acquireNextImage. In particular a sequence of \#acquireLatestImage
  /// calls greater than \#getMaxImages without calling Image\#close in-between
  /// will exhaust the underlying queue. At such a time, IllegalStateException
  /// will be thrown until more images are
  /// released with Image\#close.
  ///
  ///
  ///@return latest frame of image data, or {@code null} if no image data is available.
  ///@throws IllegalStateException if too many images are currently acquired
  image_.Image acquireLatestImage() =>
      image_.Image.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_acquireLatestImage, jni.JniType.objectType, []).object);

  static final _id_acquireNextImage = jniAccessors.getMethodIDOf(
      _classRef, "acquireNextImage", "()Landroid/media/Image;");

  /// from: public android.media.Image acquireNextImage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  /// Acquire the next Image from the ImageReader's queue. Returns {@code null} if
  /// no new image is available.
  ///
  ///
  ///
  /// <i>Warning:</i> Consider using \#acquireLatestImage() instead, as it will
  /// automatically release older images, and allow slower-running processing routines to catch
  /// up to the newest frame. Usage of \#acquireNextImage is recommended for
  /// batch/background processing. Incorrectly using this function can cause images to appear
  /// with an ever-increasing delay, followed by a complete stall where no new images seem to
  /// appear.
  ///
  ///
  ///
  ///
  /// This operation will fail by throwing an IllegalStateException if
  /// {@code maxImages} have been acquired with \#acquireNextImage or
  /// \#acquireLatestImage. In particular a sequence of \#acquireNextImage or
  /// \#acquireLatestImage calls greater than \#getMaxImages maxImages without
  /// calling Image\#close in-between will exhaust the underlying queue. At such a time,
  /// IllegalStateException will be thrown until more images are released with
  /// Image\#close.
  ///
  ///
  ///@return a new frame of image data, or {@code null} if no image data is available.
  ///@throws IllegalStateException if {@code maxImages} images are currently acquired
  ///@see \#acquireLatestImage
  image_.Image acquireNextImage() =>
      image_.Image.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_acquireNextImage, jni.JniType.objectType, []).object);

  static final _id_setOnImageAvailableListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnImageAvailableListener",
      "(Landroid/media/ImageReader\$OnImageAvailableListener;Landroid/os/Handler;)V");

  /// from: public void setOnImageAvailableListener(android.media.ImageReader.OnImageAvailableListener listener, android.os.Handler handler)
  ///
  /// Register a listener to be invoked when a new image becomes available
  /// from the ImageReader.
  ///@param listener The listener that will be run.
  ///@param handler The handler on which the listener should be invoked, or null
  ///            if the listener should be invoked on the calling thread's looper.
  ///@throws IllegalArgumentException If no handler specified and the calling thread has no looper.
  void setOnImageAvailableListener(
          ImageReader_OnImageAvailableListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnImageAvailableListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Free up all the resources associated with this ImageReader.
  ///
  ///
  /// After calling this method, this ImageReader can not be used. Calling
  /// any methods on this ImageReader and Images previously provided by
  /// \#acquireNextImage or \#acquireLatestImage
  /// will result in an IllegalStateException, and attempting to read from
  /// ByteBuffer ByteBuffers returned by an earlier
  /// Image.Plane\#getBuffer Plane\#getBuffer call will
  /// have undefined behavior.
  ///
  ///
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_discardFreeBuffers =
      jniAccessors.getMethodIDOf(_classRef, "discardFreeBuffers", "()V");

  /// from: public void discardFreeBuffers()
  ///
  /// Discard any free buffers owned by this ImageReader.
  ///
  ///
  /// Generally, the ImageReader caches buffers for reuse once they have been
  /// allocated, for best performance. However, sometimes it may be important to
  /// release all the cached, unused buffers to save on memory.
  ///
  ///
  ///
  /// Calling this method will discard all free cached buffers. This does not include any buffers
  /// associated with Images acquired from the ImageReader, any filled buffers waiting to be
  /// acquired, and any buffers currently in use by the source rendering buffers into the
  /// ImageReader's Surface.
  ///
  /// The ImageReader continues to be usable after this call, but may need to reallocate buffers
  /// when more buffers are needed for rendering.
  ///
  ///
  void discardFreeBuffers() => jniAccessors.callMethodWithArgs(
      reference, _id_discardFreeBuffers, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.media.ImageReader$OnImageAvailableListener
///
/// Callback interface for being notified that a new image is available.
///
///
/// The onImageAvailable is called per image basis, that is, callback fires for every new frame
/// available from ImageReader.
///
///
class ImageReader_OnImageAvailableListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/ImageReader\$OnImageAvailableListener");
  ImageReader_OnImageAvailableListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onImageAvailable = jniAccessors.getMethodIDOf(
      _classRef, "onImageAvailable", "(Landroid/media/ImageReader;)V");

  /// from: public abstract void onImageAvailable(android.media.ImageReader reader)
  ///
  /// Callback that is called when a new image is available from ImageReader.
  ///@param reader the ImageReader the callback is associated with.
  ///@see ImageReader
  ///@see Image
  void onImageAvailable(ImageReader reader) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onImageAvailable,
      jni.JniType.voidType,
      [reader.reference]).check();
}
