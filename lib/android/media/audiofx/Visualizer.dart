// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.audiofx.Visualizer
///
/// The Visualizer class enables application to retrieve part of the currently playing audio for
/// visualization purpose. It is not an audio recording interface and only returns partial and low
/// quality audio content. However, to protect privacy of certain audio data (e.g voice mail) the use
/// of the visualizer requires the permission android.permission.RECORD_AUDIO.
/// The audio session ID passed to the constructor indicates which audio content should be
/// visualized:<br>
/// <ul>
///   <li>If the session is 0, the audio output mix is visualized</li>
///   <li>If the session is not 0, the audio from a particular android.media.MediaPlayer or
///   android.media.AudioTrack
///   using this audio session is visualized </li>
/// </ul>
/// Two types of representation of audio content can be captured: <br>
/// <ul>
///   <li>Waveform data: consecutive 8-bit (unsigned) mono samples by using the
///   \#getWaveForm(byte[]) method</li>
///   <li>Frequency data: 8-bit magnitude FFT by using the \#getFft(byte[]) method</li>
/// </ul>
/// The length of the capture can be retrieved or specified by calling respectively
/// \#getCaptureSize() and \#setCaptureSize(int) methods. The capture size must be a
/// power of 2 in the range returned by \#getCaptureSizeRange().
/// In addition to the polling capture mode described above with \#getWaveForm(byte[]) and
///  \#getFft(byte[]) methods, a callback mode is also available by installing a listener by
///  use of the \#setDataCaptureListener(OnDataCaptureListener, int, boolean, boolean) method.
///  The rate at which the listener capture method is called as well as the type of data returned is
///  specified.
/// Before capturing data, the Visualizer must be enabled by calling the
/// \#setEnabled(boolean) method.
/// When data capture is not needed any more, the Visualizer should be disabled.
/// It is good practice to call the \#release() method when the Visualizer is not used
/// anymore to free up native resources associated to the Visualizer instance.
/// Creating a Visualizer on the output mix (audio session 0) requires permission
/// android.Manifest.permission\#MODIFY_AUDIO_SETTINGS
/// The Visualizer class can also be used to perform measurements on the audio being played back.
/// The measurements to perform are defined by setting a mask of the requested measurement modes with
/// \#setMeasurementMode(int). Supported values are \#MEASUREMENT_MODE_NONE to cancel
/// any measurement, and \#MEASUREMENT_MODE_PEAK_RMS for peak and RMS monitoring.
/// Measurements can be retrieved through \#getMeasurementPeakRms(MeasurementPeakRms).
class Visualizer extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/audiofx/Visualizer");
  Visualizer.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ALREADY_EXISTS
  ///
  /// Internal operation status. Not returned by any method.
  static const ALREADY_EXISTS = -2;

  /// from: static public final int ERROR
  ///
  /// Unspecified error.
  static const ERROR = -1;

  /// from: static public final int ERROR_BAD_VALUE
  ///
  /// Operation failed due to bad parameter value.
  static const ERROR_BAD_VALUE = -4;

  /// from: static public final int ERROR_DEAD_OBJECT
  ///
  /// Operation failed due to dead remote object.
  static const ERROR_DEAD_OBJECT = -7;

  /// from: static public final int ERROR_INVALID_OPERATION
  ///
  /// Operation failed because it was requested in wrong state.
  static const ERROR_INVALID_OPERATION = -5;

  /// from: static public final int ERROR_NO_INIT
  ///
  /// Operation failed due to bad object initialization.
  static const ERROR_NO_INIT = -3;

  /// from: static public final int ERROR_NO_MEMORY
  ///
  /// Operation failed due to lack of memory.
  static const ERROR_NO_MEMORY = -6;

  /// from: static public final int MEASUREMENT_MODE_NONE
  ///
  /// Defines a measurement mode in which no measurements are performed.
  static const MEASUREMENT_MODE_NONE = 0;

  /// from: static public final int MEASUREMENT_MODE_PEAK_RMS
  ///
  /// Defines a measurement mode which computes the peak and RMS value in mB, where 0mB is the
  /// maximum sample value, and -9600mB is the minimum value.
  /// Values for peak and RMS can be retrieved with
  /// \#getMeasurementPeakRms(MeasurementPeakRms).
  static const MEASUREMENT_MODE_PEAK_RMS = 1;

  /// from: static public final int SCALING_MODE_AS_PLAYED
  ///
  /// Defines a capture mode where the playback volume will affect (scale) the range of the
  /// captured data. A low playback volume will lead to low sample and fft values, and vice-versa.
  static const SCALING_MODE_AS_PLAYED = 1;

  /// from: static public final int SCALING_MODE_NORMALIZED
  ///
  /// Defines a capture mode where amplification is applied based on the content of the captured
  /// data. This is the default Visualizer mode, and is suitable for music visualization.
  static const SCALING_MODE_NORMALIZED = 0;

  /// from: static public final int STATE_ENABLED
  ///
  /// State of a Visualizer object that is active.
  static const STATE_ENABLED = 2;

  /// from: static public final int STATE_INITIALIZED
  ///
  /// State of a Visualizer object that is ready to be used.
  static const STATE_INITIALIZED = 1;

  /// from: static public final int STATE_UNINITIALIZED
  ///
  /// State of a Visualizer object that was not successfully initialized upon creation
  static const STATE_UNINITIALIZED = 0;

  /// from: static public final int SUCCESS
  ///
  /// Successful operation.
  static const SUCCESS = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int audioSession)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class constructor.
  ///@param audioSession system wide unique audio session identifier. If audioSession
  ///  is not 0, the visualizer will be attached to the MediaPlayer or AudioTrack in the
  ///  same audio session. Otherwise, the Visualizer will apply to the output mix.
  ///@throws java.lang.UnsupportedOperationException
  ///@throws java.lang.RuntimeException
  Visualizer(int audioSession)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [audioSession]).object);

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Releases the native Visualizer resources. It is a good practice to release the
  /// visualization engine when not in use.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_setEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)I");

  /// from: public int setEnabled(boolean enabled)
  ///
  /// Enable or disable the visualization engine.
  ///@param enabled requested enable state
  ///@return \#SUCCESS in case of success,
  /// \#ERROR_INVALID_OPERATION or \#ERROR_DEAD_OBJECT in case of failure.
  ///@throws IllegalStateException
  int setEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled, jni.JniType.intType, [enabled]).integer;

  static final _id_getEnabled =
      jniAccessors.getMethodIDOf(_classRef, "getEnabled", "()Z");

  /// from: public boolean getEnabled()
  ///
  /// Get current activation state of the visualizer.
  ///@return true if the visualizer is active, false otherwise
  bool getEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_getEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getCaptureSizeRange = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCaptureSizeRange", "()[I");

  /// from: static public native int[] getCaptureSizeRange()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the capture size range.
  ///@return the mininum capture size is returned in first array element and the maximum in second
  /// array element.
  static jni.JniObject getCaptureSizeRange() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getCaptureSizeRange, jni.JniType.objectType, []).object);

  static final _id_getMaxCaptureRate =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMaxCaptureRate", "()I");

  /// from: static public native int getMaxCaptureRate()
  ///
  /// Returns the maximum capture rate for the callback capture method. This is the maximum value
  /// for the rate parameter of the
  /// \#setDataCaptureListener(OnDataCaptureListener, int, boolean, boolean) method.
  ///@return the maximum capture rate expressed in milliHertz
  static int getMaxCaptureRate() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMaxCaptureRate, jni.JniType.intType, []).integer;

  static final _id_setCaptureSize =
      jniAccessors.getMethodIDOf(_classRef, "setCaptureSize", "(I)I");

  /// from: public int setCaptureSize(int size)
  ///
  /// Sets the capture size, i.e. the number of bytes returned by \#getWaveForm(byte[]) and
  /// \#getFft(byte[]) methods. The capture size must be a power of 2 in the range returned
  /// by \#getCaptureSizeRange().
  /// This method must not be called when the Visualizer is enabled.
  ///@param size requested capture size
  ///@return \#SUCCESS in case of success,
  /// \#ERROR_BAD_VALUE in case of failure.
  ///@throws IllegalStateException
  int setCaptureSize(int size) => jniAccessors.callMethodWithArgs(
      reference, _id_setCaptureSize, jni.JniType.intType, [size]).integer;

  static final _id_getCaptureSize =
      jniAccessors.getMethodIDOf(_classRef, "getCaptureSize", "()I");

  /// from: public int getCaptureSize()
  ///
  /// Returns current capture size.
  ///@return the capture size in bytes.
  int getCaptureSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getCaptureSize, jni.JniType.intType, []).integer;

  static final _id_setScalingMode =
      jniAccessors.getMethodIDOf(_classRef, "setScalingMode", "(I)I");

  /// from: public int setScalingMode(int mode)
  ///
  /// Set the type of scaling applied on the captured visualization data.
  ///@param mode see \#SCALING_MODE_NORMALIZED
  ///     and \#SCALING_MODE_AS_PLAYED
  ///@return \#SUCCESS in case of success,
  ///     \#ERROR_BAD_VALUE in case of failure.
  ///@throws IllegalStateException
  int setScalingMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setScalingMode, jni.JniType.intType, [mode]).integer;

  static final _id_getScalingMode =
      jniAccessors.getMethodIDOf(_classRef, "getScalingMode", "()I");

  /// from: public int getScalingMode()
  ///
  /// Returns the current scaling mode on the captured visualization data.
  ///@return the scaling mode, see \#SCALING_MODE_NORMALIZED
  ///     and \#SCALING_MODE_AS_PLAYED.
  ///@throws IllegalStateException
  int getScalingMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getScalingMode, jni.JniType.intType, []).integer;

  static final _id_setMeasurementMode =
      jniAccessors.getMethodIDOf(_classRef, "setMeasurementMode", "(I)I");

  /// from: public int setMeasurementMode(int mode)
  ///
  /// Sets the combination of measurement modes to be performed by this audio effect.
  ///@param mode a mask of the measurements to perform. The valid values are
  ///     \#MEASUREMENT_MODE_NONE (to cancel any measurement)
  ///     or \#MEASUREMENT_MODE_PEAK_RMS.
  ///@return \#SUCCESS in case of success, \#ERROR_BAD_VALUE in case of failure.
  ///@throws IllegalStateException
  int setMeasurementMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setMeasurementMode, jni.JniType.intType, [mode]).integer;

  static final _id_getMeasurementMode =
      jniAccessors.getMethodIDOf(_classRef, "getMeasurementMode", "()I");

  /// from: public int getMeasurementMode()
  ///
  /// Returns the current measurement modes performed by this audio effect
  ///@return the mask of the measurements,
  ///     \#MEASUREMENT_MODE_NONE (when no measurements are performed)
  ///     or \#MEASUREMENT_MODE_PEAK_RMS.
  ///@throws IllegalStateException
  int getMeasurementMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getMeasurementMode, jni.JniType.intType, []).integer;

  static final _id_getSamplingRate =
      jniAccessors.getMethodIDOf(_classRef, "getSamplingRate", "()I");

  /// from: public int getSamplingRate()
  ///
  /// Returns the sampling rate of the captured audio.
  ///@return the sampling rate in milliHertz.
  int getSamplingRate() => jniAccessors.callMethodWithArgs(
      reference, _id_getSamplingRate, jni.JniType.intType, []).integer;

  static final _id_getWaveForm =
      jniAccessors.getMethodIDOf(_classRef, "getWaveForm", "([B)I");

  /// from: public int getWaveForm(byte[] waveform)
  ///
  /// Returns a waveform capture of currently playing audio content. The capture consists in
  /// a number of consecutive 8-bit (unsigned) mono PCM samples equal to the capture size returned
  /// by \#getCaptureSize().
  /// This method must be called when the Visualizer is enabled.
  ///@param waveform array of bytes where the waveform should be returned
  ///@return \#SUCCESS in case of success,
  /// \#ERROR_NO_MEMORY, \#ERROR_INVALID_OPERATION or \#ERROR_DEAD_OBJECT
  /// in case of failure.
  ///@throws IllegalStateException
  int getWaveForm(jni.JniObject waveform) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getWaveForm,
      jni.JniType.intType,
      [waveform.reference]).integer;

  static final _id_getFft =
      jniAccessors.getMethodIDOf(_classRef, "getFft", "([B)I");

  /// from: public int getFft(byte[] fft)
  ///
  /// Returns a frequency capture of currently playing audio content.
  /// This method must be called when the Visualizer is enabled.
  /// The capture is an 8-bit magnitude FFT, the frequency range covered being 0 (DC) to half of
  /// the sampling rate returned by \#getSamplingRate(). The capture returns the real and
  /// imaginary parts of a number of frequency points equal to half of the capture size plus one.
  /// Note: only the real part is returned for the first point (DC) and the last point
  /// (sampling frequency / 2).
  /// The layout in the returned byte array is as follows:
  /// <ul>
  ///   <li> n is the capture size returned by getCaptureSize()</li>
  ///   <li> Rfk, Ifk are respectively  the real and imaginary parts of the kth frequency
  ///   component</li>
  ///   <li> If Fs is the sampling frequency retuned by getSamplingRate() the kth frequency is:
  ///   (k*Fs)/(n/2) </li>
  /// </ul>
  /// <table border="0"cellspacing="0"cellpadding="0">
  /// <tr><td>Index
  ///</td>
  ///     <td>0
  ///</td>
  ///     <td>1
  ///</td>
  ///     <td>2
  ///</td>
  ///     <td>3
  ///</td>
  ///     <td>4
  ///</td>
  ///     <td>5
  ///</td>
  ///     <td>...
  ///</td>
  ///     <td>n - 2
  ///</td>
  ///     <td>n - 1
  ///</td></tr>
  /// <tr><td>Data
  ///</td>
  ///     <td>Rf0
  ///</td>
  ///     <td>Rf(n/2)
  ///</td>
  ///     <td>Rf1
  ///</td>
  ///     <td>If1
  ///</td>
  ///     <td>Rf2
  ///</td>
  ///     <td>If2
  ///</td>
  ///     <td>...
  ///</td>
  ///     <td>Rf(n-1)/2
  ///</td>
  ///     <td>If(n-1)/2
  ///</td></tr>
  /// </table>
  ///@param fft array of bytes where the FFT should be returned
  ///@return \#SUCCESS in case of success,
  /// \#ERROR_NO_MEMORY, \#ERROR_INVALID_OPERATION or \#ERROR_DEAD_OBJECT
  /// in case of failure.
  ///@throws IllegalStateException
  int getFft(jni.JniObject fft) => jniAccessors.callMethodWithArgs(
      reference, _id_getFft, jni.JniType.intType, [fft.reference]).integer;

  static final _id_getMeasurementPeakRms = jniAccessors.getMethodIDOf(
      _classRef,
      "getMeasurementPeakRms",
      "(Landroid/media/audiofx/Visualizer\$MeasurementPeakRms;)I");

  /// from: public int getMeasurementPeakRms(android.media.audiofx.Visualizer.MeasurementPeakRms measurement)
  ///
  /// Retrieves the latest peak and RMS measurement.
  /// Sets the peak and RMS fields of the supplied Visualizer.MeasurementPeakRms to the
  /// latest measured values.
  ///@param measurement a non-null Visualizer.MeasurementPeakRms instance to store
  ///    the measurement values.
  ///@return \#SUCCESS in case of success, \#ERROR_BAD_VALUE,
  ///    \#ERROR_NO_MEMORY, \#ERROR_INVALID_OPERATION or \#ERROR_DEAD_OBJECT
  ///    in case of failure.
  int getMeasurementPeakRms(Visualizer_MeasurementPeakRms measurement) =>
      jniAccessors.callMethodWithArgs(reference, _id_getMeasurementPeakRms,
          jni.JniType.intType, [measurement.reference]).integer;

  static final _id_setDataCaptureListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setDataCaptureListener",
      "(Landroid/media/audiofx/Visualizer\$OnDataCaptureListener;IZZ)I");

  /// from: public int setDataCaptureListener(android.media.audiofx.Visualizer.OnDataCaptureListener listener, int rate, boolean waveform, boolean fft)
  ///
  /// Registers an OnDataCaptureListener interface and specifies the rate at which the capture
  /// should be updated as well as the type of capture requested.
  /// Call this method with a null listener to stop receiving the capture updates.
  ///@param listener OnDataCaptureListener registered
  ///@param rate rate in milliHertz at which the capture should be updated
  ///@param waveform true if a waveform capture is requested: the onWaveFormDataCapture()
  /// method will be called on the OnDataCaptureListener interface.
  ///@param fft true if a frequency capture is requested: the onFftDataCapture() method will be
  /// called on the OnDataCaptureListener interface.
  ///@return \#SUCCESS in case of success,
  /// \#ERROR_NO_INIT or \#ERROR_BAD_VALUE in case of failure.
  int setDataCaptureListener(Visualizer_OnDataCaptureListener listener,
          int rate, bool waveform, bool fft) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDataCaptureListener,
          jni.JniType.intType,
          [listener.reference, rate, waveform, fft]).integer;
}

/// from: android.media.audiofx.Visualizer$OnDataCaptureListener
///
/// The OnDataCaptureListener interface defines methods called by the Visualizer to periodically
/// update the audio visualization capture.
/// The client application can implement this interface and register the listener with the
/// \#setDataCaptureListener(OnDataCaptureListener, int, boolean, boolean) method.
class Visualizer_OnDataCaptureListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/audiofx/Visualizer\$OnDataCaptureListener");
  Visualizer_OnDataCaptureListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onWaveFormDataCapture = jniAccessors.getMethodIDOf(_classRef,
      "onWaveFormDataCapture", "(Landroid/media/audiofx/Visualizer;[BI)V");

  /// from: public abstract void onWaveFormDataCapture(android.media.audiofx.Visualizer visualizer, byte[] waveform, int samplingRate)
  ///
  /// Method called when a new waveform capture is available.
  /// Data in the waveform buffer is valid only within the scope of the callback.
  /// Applications which need access to the waveform data after returning from the callback
  /// should make a copy of the data instead of holding a reference.
  ///@param visualizer Visualizer object on which the listener is registered.
  ///@param waveform array of bytes containing the waveform representation.
  ///@param samplingRate sampling rate of the visualized audio.
  void onWaveFormDataCapture(
          Visualizer visualizer, jni.JniObject waveform, int samplingRate) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onWaveFormDataCapture,
          jni.JniType.voidType,
          [visualizer.reference, waveform.reference, samplingRate]).check();

  static final _id_onFftDataCapture = jniAccessors.getMethodIDOf(_classRef,
      "onFftDataCapture", "(Landroid/media/audiofx/Visualizer;[BI)V");

  /// from: public abstract void onFftDataCapture(android.media.audiofx.Visualizer visualizer, byte[] fft, int samplingRate)
  ///
  /// Method called when a new frequency capture is available.
  /// Data in the fft buffer is valid only within the scope of the callback.
  /// Applications which need access to the fft data after returning from the callback
  /// should make a copy of the data instead of holding a reference.
  ///
  /// In order to obtain magnitude and phase values the following formulas can
  /// be used:
  ///    <pre class="prettyprint">
  ///       for (int i = 0; i &lt; fft.size(); i += 2) {
  ///           float magnitude = (float)Math.hypot(fft[i], fft[i + 1]);
  ///           float phase = (float)Math.atan2(fft[i + 1], fft[i]);
  ///       }</pre>
  ///@param visualizer Visualizer object on which the listener is registered.
  ///@param fft array of bytes containing the frequency representation.
  ///    The fft array only contains the first half of the actual
  ///    FFT spectrum (frequencies up to Nyquist frequency), exploiting
  ///    the symmetry of the spectrum. For each frequencies bin <code>i</code>:
  ///    <ul>
  ///      <li>the element at index <code>2*i</code> in the array contains
  ///          the real part of a complex number,</li>
  ///      <li>the element at index <code>2*i+1</code> contains the imaginary
  ///          part of the complex number.</li>
  ///    </ul>
  ///@param samplingRate sampling rate of the visualized audio.
  void onFftDataCapture(
          Visualizer visualizer, jni.JniObject fft, int samplingRate) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFftDataCapture,
          jni.JniType.voidType,
          [visualizer.reference, fft.reference, samplingRate]).check();
}

/// from: android.media.audiofx.Visualizer$MeasurementPeakRms
///
/// A class to store peak and RMS values.
/// Peak and RMS are expressed in mB, as described in the
/// Visualizer\#MEASUREMENT_MODE_PEAK_RMS measurement mode.
class Visualizer_MeasurementPeakRms extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/audiofx/Visualizer\$MeasurementPeakRms");
  Visualizer_MeasurementPeakRms.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_mPeak = jniAccessors.getFieldIDOf(_classRef, "mPeak", "I");

  /// from: public int mPeak
  ///
  /// The peak value in mB.
  int get mPeak =>
      jniAccessors.getField(reference, _id_mPeak, jni.JniType.intType).integer;

  /// from: public int mPeak
  ///
  /// The peak value in mB.
  set mPeak(int value) => jniEnv.SetIntField(reference, _id_mPeak, value);

  static final _id_mRms = jniAccessors.getFieldIDOf(_classRef, "mRms", "I");

  /// from: public int mRms
  ///
  /// The RMS value in mB.
  int get mRms =>
      jniAccessors.getField(reference, _id_mRms, jni.JniType.intType).integer;

  /// from: public int mRms
  ///
  /// The RMS value in mB.
  set mRms(int value) => jniEnv.SetIntField(reference, _id_mRms, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Visualizer_MeasurementPeakRms()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
