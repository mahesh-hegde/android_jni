// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AudioEffect.dart" as audioeffect_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.audiofx.Virtualizer
///
/// An audio virtualizer is a general name for an effect to spatialize audio channels. The exact
/// behavior of this effect is dependent on the number of audio input channels and the types and
/// number of audio output channels of the device. For example, in the case of a stereo input and
/// stereo headphone output, a stereo widening effect is used when this effect is turned on.
/// An application creates a Virtualizer object to instantiate and control a virtualizer engine
/// in the audio framework.
/// The methods, parameter types and units exposed by the Virtualizer implementation are directly
/// mapping those defined by the OpenSL ES 1.0.1 Specification (http://www.khronos.org/opensles/)
/// for the SLVirtualizerItf interface. Please refer to this specification for more details.
/// To attach the Virtualizer to a particular AudioTrack or MediaPlayer, specify the audio session
/// ID of this AudioTrack or MediaPlayer when constructing the Virtualizer.
/// NOTE: attaching a Virtualizer to the global audio output mix by use of session 0 is
/// deprecated.
/// See android.media.MediaPlayer\#getAudioSessionId() for details on audio sessions.
/// See android.media.audiofx.AudioEffect class for more details on controlling
/// audio effects.
class Virtualizer extends audioeffect_.AudioEffect {
  static final _classRef =
      jniAccessors.getClassOf("android/media/audiofx/Virtualizer");
  Virtualizer.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int PARAM_STRENGTH
  ///
  /// Virtualizer effect strength. Parameter ID for
  /// android.media.audiofx.Virtualizer.OnParameterChangeListener
  static const PARAM_STRENGTH = 1;

  /// from: static public final int PARAM_STRENGTH_SUPPORTED
  ///
  /// Is strength parameter supported by virtualizer engine. Parameter ID for getParameter().
  static const PARAM_STRENGTH_SUPPORTED = 0;

  /// from: static public final int VIRTUALIZATION_MODE_AUTO
  ///
  /// A virtualization mode used to indicate the virtualizer effect must stop forcing the
  /// processing to a particular mode in \#forceVirtualizationMode(int).
  static const VIRTUALIZATION_MODE_AUTO = 1;

  /// from: static public final int VIRTUALIZATION_MODE_BINAURAL
  ///
  /// A virtualization mode typically used over headphones.
  /// Binaural virtualization describes an audio processing configuration for virtualization
  /// where the left and right channels are respectively reaching the left and right ear of the
  /// user, without also feeding the opposite ear (as is the case when listening over speakers).
  /// Such a mode is therefore meant to be used when audio is playing over stereo wired
  /// headphones or headsets, but also stereo headphones through a wireless A2DP Bluetooth link.
  /// See \#canVirtualize(int, int) to verify this mode is supported by this Virtualizer.
  static const VIRTUALIZATION_MODE_BINAURAL = 2;

  /// from: static public final int VIRTUALIZATION_MODE_OFF
  ///
  /// A virtualization mode indicating virtualization processing is not active.
  /// See \#getVirtualizationMode() as one of the possible return value.
  static const VIRTUALIZATION_MODE_OFF = 0;

  /// from: static public final int VIRTUALIZATION_MODE_TRANSAURAL
  ///
  /// A virtualization mode typically used over speakers.
  /// Transaural virtualization describes an audio processing configuration that differs from
  /// binaural (as described in \#VIRTUALIZATION_MODE_BINAURAL in that cross-talk is
  /// present, i.e. audio played from the left channel also reaches the right ear of the user,
  /// and vice-versa.
  /// When supported, such a mode is therefore meant to be used when audio is playing over the
  /// built-in stereo speakers of a device, if they are featured.
  /// See \#canVirtualize(int, int) to verify this mode is supported by this Virtualizer.
  static const VIRTUALIZATION_MODE_TRANSAURAL = 3;

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int priority, int audioSession)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class constructor.
  ///@param priority the priority level requested by the application for controlling the Virtualizer
  /// engine. As the same engine can be shared by several applications, this parameter indicates
  /// how much the requesting application needs control of effect parameters. The normal priority
  /// is 0, above normal is a positive number, below normal a negative number.
  ///@param audioSession system wide unique audio session identifier. The Virtualizer will
  /// be attached to the MediaPlayer or AudioTrack in the same audio session.
  ///@throws java.lang.IllegalStateException
  ///@throws java.lang.IllegalArgumentException
  ///@throws java.lang.UnsupportedOperationException
  ///@throws java.lang.RuntimeException
  Virtualizer.ctor1(int priority, int audioSession)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [priority, audioSession]).object);

  static final _id_getStrengthSupported =
      jniAccessors.getMethodIDOf(_classRef, "getStrengthSupported", "()Z");

  /// from: public boolean getStrengthSupported()
  ///
  /// Indicates whether setting strength is supported. If this method returns false, only one
  /// strength is supported and the setStrength() method always rounds to that value.
  ///@return true is strength parameter is supported, false otherwise
  bool getStrengthSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_getStrengthSupported, jni.JniType.booleanType, []).boolean;

  static final _id_setStrength =
      jniAccessors.getMethodIDOf(_classRef, "setStrength", "(S)V");

  /// from: public void setStrength(short strength)
  ///
  /// Sets the strength of the virtualizer effect. If the implementation does not support per mille
  /// accuracy for setting the strength, it is allowed to round the given strength to the nearest
  /// supported value. You can use the \#getRoundedStrength() method to query the
  /// (possibly rounded) value that was actually set.
  ///@param strength strength of the effect. The valid range for strength strength is [0, 1000],
  /// where 0 per mille designates the mildest effect and 1000 per mille designates the strongest.
  ///@throws IllegalStateException
  ///@throws IllegalArgumentException
  ///@throws UnsupportedOperationException
  void setStrength(int strength) => jniAccessors.callMethodWithArgs(
      reference, _id_setStrength, jni.JniType.voidType, [strength]).check();

  static final _id_getRoundedStrength =
      jniAccessors.getMethodIDOf(_classRef, "getRoundedStrength", "()S");

  /// from: public short getRoundedStrength()
  ///
  /// Gets the current strength of the effect.
  ///@return the strength of the effect. The valid range for strength is [0, 1000], where 0 per
  /// mille designates the mildest effect and 1000 per mille the strongest
  ///@throws IllegalStateException
  ///@throws IllegalArgumentException
  ///@throws UnsupportedOperationException
  int getRoundedStrength() => jniAccessors.callMethodWithArgs(
      reference, _id_getRoundedStrength, jni.JniType.shortType, []).short;

  static final _id_canVirtualize =
      jniAccessors.getMethodIDOf(_classRef, "canVirtualize", "(II)Z");

  /// from: public boolean canVirtualize(int inputChannelMask, int virtualizationMode)
  ///
  /// Checks if the combination of a channel mask and virtualization mode is supported by this
  /// virtualizer.
  /// Some virtualizer implementations may only support binaural processing (i.e. only support
  /// headphone output, see \#VIRTUALIZATION_MODE_BINAURAL), some may support transaural
  /// processing (i.e. for speaker output, see \#VIRTUALIZATION_MODE_TRANSAURAL) for the
  /// built-in speakers. Use this method to query the virtualizer implementation capabilities.
  ///@param inputChannelMask the channel mask of the content to virtualize.
  ///@param virtualizationMode the mode for which virtualization processing is to be performed,
  ///    one of \#VIRTUALIZATION_MODE_BINAURAL, \#VIRTUALIZATION_MODE_TRANSAURAL.
  /// Value is android.media.audiofx.Virtualizer\#VIRTUALIZATION_MODE_BINAURAL, or android.media.audiofx.Virtualizer\#VIRTUALIZATION_MODE_TRANSAURAL
  ///@return true if the combination of channel mask and virtualization mode is supported, false
  ///    otherwise.
  ///    <br>An indication that a certain channel mask is not supported doesn't necessarily mean
  ///    you cannot play content with that channel mask, it more likely implies the content will
  ///    be downmixed before being virtualized. For instance a virtualizer that only supports a
  ///    mask such as AudioFormat\#CHANNEL_OUT_STEREO
  ///    will still be able to process content with a mask of
  ///    AudioFormat\#CHANNEL_OUT_5POINT1, but will downmix the content to stereo first, and
  ///    then will virtualize, as opposed to virtualizing each channel individually.
  ///@throws IllegalStateException
  ///@throws IllegalArgumentException
  ///@throws UnsupportedOperationException
  bool canVirtualize(int inputChannelMask, int virtualizationMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_canVirtualize,
          jni.JniType.booleanType,
          [inputChannelMask, virtualizationMode]).boolean;

  static final _id_getSpeakerAngles =
      jniAccessors.getMethodIDOf(_classRef, "getSpeakerAngles", "(II[I)Z");

  /// from: public boolean getSpeakerAngles(int inputChannelMask, int virtualizationMode, int[] angles)
  ///
  /// Queries the virtual speaker angles (azimuth and elevation) for a combination of a channel
  /// mask and virtualization mode.
  /// If the virtualization configuration (mask and mode) is supported (see
  /// \#canVirtualize(int, int), the array angles will contain upon return the
  /// definition of each virtual speaker and its azimuth and elevation angles relative to the
  /// listener.
  /// <br>Note that in some virtualizer implementations, the angles may be strength-dependent.
  ///@param inputChannelMask the channel mask of the content to virtualize.
  ///@param virtualizationMode the mode for which virtualization processing is to be performed,
  ///    one of \#VIRTUALIZATION_MODE_BINAURAL, \#VIRTUALIZATION_MODE_TRANSAURAL.
  /// Value is android.media.audiofx.Virtualizer\#VIRTUALIZATION_MODE_BINAURAL, or android.media.audiofx.Virtualizer\#VIRTUALIZATION_MODE_TRANSAURAL
  ///@param angles a non-null array whose length is 3 times the number of channels in the channel
  ///    mask.
  ///    If the method indicates the configuration is supported, the array will contain upon return
  ///    triplets of values: for each channel <code>i</code> among the channels of the mask:
  ///    <ul>
  ///      <li>the element at index <code>3*i</code> in the array contains the speaker
  ///          identification (e.g. AudioFormat\#CHANNEL_OUT_FRONT_LEFT),</li>
  ///      <li>the element at index <code>3*i+1</code> contains its corresponding azimuth angle
  ///          expressed in degrees, where 0 is the direction the listener faces, 180 is behind
  ///          the listener, and -90 is to her/his left,</li>
  ///      <li>the element at index <code>3*i+2</code> contains its corresponding elevation angle
  ///          where +90 is directly above the listener, 0 is the horizontal plane, and -90 is
  ///          directly below the listener.</li>
  ///@return true if the combination of channel mask and virtualization mode is supported, false
  ///    otherwise.
  ///@throws IllegalStateException
  ///@throws IllegalArgumentException
  ///@throws UnsupportedOperationException
  bool getSpeakerAngles(
          int inputChannelMask, int virtualizationMode, jni.JniObject angles) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getSpeakerAngles,
          jni.JniType.booleanType,
          [inputChannelMask, virtualizationMode, angles.reference]).boolean;

  static final _id_forceVirtualizationMode =
      jniAccessors.getMethodIDOf(_classRef, "forceVirtualizationMode", "(I)Z");

  /// from: public boolean forceVirtualizationMode(int virtualizationMode)
  ///
  /// Forces the virtualizer effect to use the given processing mode.
  /// The effect must be enabled for the forced mode to be applied.
  ///@param virtualizationMode one of \#VIRTUALIZATION_MODE_BINAURAL,
  ///     \#VIRTUALIZATION_MODE_TRANSAURAL to force a particular processing mode, or
  ///     {@value \#VIRTUALIZATION_MODE_AUTO} to stop forcing a mode.
  /// Value is android.media.audiofx.Virtualizer\#VIRTUALIZATION_MODE_AUTO, android.media.audiofx.Virtualizer\#VIRTUALIZATION_MODE_BINAURAL, or android.media.audiofx.Virtualizer\#VIRTUALIZATION_MODE_TRANSAURAL
  ///@return true if the processing mode is supported, and it is successfully set, or
  ///     forcing was successfully disabled, false otherwise.
  ///@throws IllegalStateException
  ///@throws IllegalArgumentException
  ///@throws UnsupportedOperationException
  bool forceVirtualizationMode(int virtualizationMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_forceVirtualizationMode,
          jni.JniType.booleanType, [virtualizationMode]).boolean;

  static final _id_getVirtualizationMode =
      jniAccessors.getMethodIDOf(_classRef, "getVirtualizationMode", "()I");

  /// from: public int getVirtualizationMode()
  ///
  /// Return the virtualization mode being used, if any.
  ///@return the virtualization mode being used.
  ///     If virtualization is not active, the virtualization mode will be
  ///     \#VIRTUALIZATION_MODE_OFF. Otherwise the value will be
  ///     \#VIRTUALIZATION_MODE_BINAURAL or \#VIRTUALIZATION_MODE_TRANSAURAL.
  ///     Virtualization may not be active either because the effect is not enabled or
  ///     because the current output device is not compatible with this virtualization
  ///     implementation.
  ///@throws IllegalStateException
  ///@throws UnsupportedOperationException
  int getVirtualizationMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getVirtualizationMode, jni.JniType.intType, []).integer;

  static final _id_setParameterListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setParameterListener",
      "(Landroid/media/audiofx/Virtualizer\$OnParameterChangeListener;)V");

  /// from: public void setParameterListener(android.media.audiofx.Virtualizer.OnParameterChangeListener listener)
  ///
  /// Registers an OnParameterChangeListener interface.
  ///@param listener OnParameterChangeListener interface registered
  void setParameterListener(Virtualizer_OnParameterChangeListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setParameterListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_getProperties = jniAccessors.getMethodIDOf(_classRef,
      "getProperties", "()Landroid/media/audiofx/Virtualizer\$Settings;");

  /// from: public android.media.audiofx.Virtualizer.Settings getProperties()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the virtualizer properties. This method is useful when a snapshot of current
  /// virtualizer settings must be saved by the application.
  ///@return a Virtualizer.Settings object containing all current parameters values
  ///@throws IllegalStateException
  ///@throws IllegalArgumentException
  ///@throws UnsupportedOperationException
  Virtualizer_Settings getProperties() =>
      Virtualizer_Settings.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getProperties, jni.JniType.objectType, []).object);

  static final _id_setProperties = jniAccessors.getMethodIDOf(_classRef,
      "setProperties", "(Landroid/media/audiofx/Virtualizer\$Settings;)V");

  /// from: public void setProperties(android.media.audiofx.Virtualizer.Settings settings)
  ///
  /// Sets the virtualizer properties. This method is useful when virtualizer settings have to
  /// be applied from a previous backup.
  ///@param settings a Virtualizer.Settings object containing the properties to apply
  ///@throws IllegalStateException
  ///@throws IllegalArgumentException
  ///@throws UnsupportedOperationException
  void setProperties(Virtualizer_Settings settings) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProperties,
          jni.JniType.voidType, [settings.reference]).check();
}

/// from: android.media.audiofx.Virtualizer$Settings
///
/// The Settings class regroups all virtualizer parameters. It is used in
/// conjuntion with getProperties() and setProperties() methods to backup and restore
/// all parameters in a single call.
class Virtualizer_Settings extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/audiofx/Virtualizer\$Settings");
  Virtualizer_Settings.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_strength =
      jniAccessors.getFieldIDOf(_classRef, "strength", "S");

  /// from: public short strength
  int get strength => jniAccessors
      .getField(reference, _id_strength, jni.JniType.shortType)
      .short;

  /// from: public short strength
  set strength(int value) =>
      jniEnv.SetShortField(reference, _id_strength, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Virtualizer_Settings()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String settings)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Settings class constructor from a key=value; pairs formatted string. The string is
  /// typically returned by Settings.toString() method.
  ///@throws IllegalArgumentException if the string is not correctly formatted.
  Virtualizer_Settings.ctor1(jni.JniString settings)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [settings.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.media.audiofx.Virtualizer$OnParameterChangeListener
///
/// The OnParameterChangeListener interface defines a method called by the Virtualizer when a
/// parameter value has changed.
class Virtualizer_OnParameterChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/media/audiofx/Virtualizer\$OnParameterChangeListener");
  Virtualizer_OnParameterChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onParameterChange = jniAccessors.getMethodIDOf(_classRef,
      "onParameterChange", "(Landroid/media/audiofx/Virtualizer;IIS)V");

  /// from: public abstract void onParameterChange(android.media.audiofx.Virtualizer effect, int status, int param, short value)
  ///
  /// Method called when a parameter value has changed. The method is called only if the
  /// parameter was changed by another application having the control of the same
  /// Virtualizer engine.
  ///@param effect the Virtualizer on which the interface is registered.
  ///@param status status of the set parameter operation.
  ///@param param ID of the modified parameter. See \#PARAM_STRENGTH ...
  ///@param value the new parameter value.
  void onParameterChange(
          Virtualizer effect, int status, int param, int value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onParameterChange,
          jni.JniType.voidType,
          [effect.reference, status, param, value]).check();
}
