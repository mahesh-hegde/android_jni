// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.audiofx.AudioEffect
///
/// AudioEffect is the base class for controlling audio effects provided by the android audio
/// framework.
/// Applications should not use the AudioEffect class directly but one of its derived classes to
/// control specific effects:
/// <ul>
///   <li> android.media.audiofx.Equalizer</li>
///   <li> android.media.audiofx.Virtualizer</li>
///   <li> android.media.audiofx.BassBoost</li>
///   <li> android.media.audiofx.PresetReverb</li>
///   <li> android.media.audiofx.EnvironmentalReverb</li>
///   <li> android.media.audiofx.DynamicsProcessing</li>
/// </ul>
/// To apply the audio effect to a specific AudioTrack or MediaPlayer instance,
/// the application must specify the audio session ID of that instance when creating the AudioEffect.
/// (see android.media.MediaPlayer\#getAudioSessionId() for details on audio sessions).
/// NOTE: attaching insert effects (equalizer, bass boost, virtualizer) to the global audio output
/// mix by use of session 0 is deprecated.
/// Creating an AudioEffect object will create the corresponding effect engine in the audio
/// framework if no instance of the same effect type exists in the specified audio session.
/// If one exists, this instance will be used.
/// The application creating the AudioEffect object (or a derived class) will either receive
/// control of the effect engine or not depending on the priority parameter. If priority is higher
/// than the priority used by the current effect engine owner, the control will be transfered to the
/// new object. Otherwise control will remain with the previous object. In this case, the new
/// application will be notified of changes in effect engine state or control ownership by the
/// appropriate listener.
class AudioEffect extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/audiofx/AudioEffect");
  AudioEffect.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION
  ///
  /// Intent to signal to the effect control application or service that an audio session
  ///  is closed and that effects should not be applied anymore.
  ///  The effect control application receiving this intent will delete all effects on
  ///  this session and store current settings in package specific storage.
  ///  The calling package name is indicated by the \#EXTRA_PACKAGE_NAME extra and the
  ///  audio session ID by the \#EXTRA_AUDIO_SESSION extra. Both extras are mandatory.
  ///  It is good practice for applications to broadcast this intent when music playback stops
  ///  and/or when exiting to free system resources consumed by audio effect engines.
  static const ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION =
      "android.media.action.CLOSE_AUDIO_EFFECT_CONTROL_SESSION";

  /// from: static public final java.lang.String ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL
  ///
  /// Intent to launch an audio effect control panel UI.
  ///  The goal of this intent is to enable separate implementations of music/media player
  ///  applications and audio effect control application or services.
  ///  This will allow platform vendors to offer more advanced control options for standard effects
  ///  or control for platform specific effects.
  ///  The intent carries a number of extras used by the player application to communicate
  ///  necessary pieces of information to the control panel application.
  ///  The calling application must use the
  ///  android.app.Activity\#startActivityForResult(Intent, int) method to launch the
  ///  control panel so that its package name is indicated and used by the control panel
  ///  application to keep track of changes for this particular application.
  ///  The \#EXTRA_AUDIO_SESSION extra will indicate an audio session to which the
  ///  audio effects should be applied. If no audio session is specified, either one of the
  ///  follownig will happen:
  ///  - If an audio session was previously opened by the calling application with
  ///  \#ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION intent, the effect changes will
  ///  be applied to that session.
  ///  - If no audio session is opened, the changes will be stored in the package specific
  ///  storage area and applied whenever a new audio session is opened by this application.
  ///  The \#EXTRA_CONTENT_TYPE extra will help the control panel application
  ///  customize both the UI layout and the default audio effect settings if none are already
  ///  stored for the calling application.
  static const ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL =
      "android.media.action.DISPLAY_AUDIO_EFFECT_CONTROL_PANEL";

  /// from: static public final java.lang.String ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION
  ///
  /// Intent to signal to the effect control application or service that a new audio session
  ///  is opened and requires audio effects to be applied.
  ///  This is different from \#ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL in that no
  ///  UI should be displayed in this case. Music player applications can broadcast this intent
  ///  before starting playback to make sure that any audio effect settings previously selected
  ///  by the user are applied.
  ///  The effect control application receiving this intent will look for previously stored
  ///  settings for the calling application, create all required audio effects and apply the
  ///  effect settings to the specified audio session.
  ///  The calling package name is indicated by the \#EXTRA_PACKAGE_NAME extra and the
  ///  audio session ID by the \#EXTRA_AUDIO_SESSION extra. Both extras are mandatory.
  ///  If no stored settings are found for the calling application, default settings for the
  ///  content type indicated by \#EXTRA_CONTENT_TYPE will be applied. The default settings
  ///  for a given content type are platform specific.
  static const ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION =
      "android.media.action.OPEN_AUDIO_EFFECT_CONTROL_SESSION";

  /// from: static public final int ALREADY_EXISTS
  ///
  /// Internal operation status. Not returned by any method.
  static const ALREADY_EXISTS = -2;

  /// from: static public final int CONTENT_TYPE_GAME
  ///
  /// Value for \#EXTRA_CONTENT_TYPE when the type of content played is game audio
  static const CONTENT_TYPE_GAME = 2;

  /// from: static public final int CONTENT_TYPE_MOVIE
  ///
  /// Value for \#EXTRA_CONTENT_TYPE when the type of content played is video or movie
  static const CONTENT_TYPE_MOVIE = 1;

  /// from: static public final int CONTENT_TYPE_MUSIC
  ///
  /// Value for \#EXTRA_CONTENT_TYPE when the type of content played is music
  static const CONTENT_TYPE_MUSIC = 0;

  /// from: static public final int CONTENT_TYPE_VOICE
  ///
  /// Value for \#EXTRA_CONTENT_TYPE when the type of content played is voice audio
  static const CONTENT_TYPE_VOICE = 3;

  /// from: static public final java.lang.String EFFECT_AUXILIARY
  ///
  /// Effect connection mode is auxiliary.
  /// Auxiliary effects must be created on session 0 (global output mix). In order for a
  /// MediaPlayer or AudioTrack to be fed into this effect, they must be explicitely attached to
  /// this effect and a send level must be specified.
  /// Use the effect ID returned by \#getId() to designate this particular effect when
  /// attaching it to the MediaPlayer or AudioTrack.
  static const EFFECT_AUXILIARY = "Auxiliary";

  /// from: static public final java.lang.String EFFECT_INSERT
  ///
  /// Effect connection mode is insert. Specifying an audio session ID when creating the effect
  /// will insert this effect after all players in the same audio session.
  static const EFFECT_INSERT = "Insert";

  static final _id_EFFECT_TYPE_AEC = jniAccessors.getStaticFieldIDOf(
      _classRef, "EFFECT_TYPE_AEC", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_AEC
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for Acoustic Echo Canceler (AEC)
  static jni.JniObject get EFFECT_TYPE_AEC => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_EFFECT_TYPE_AEC, jni.JniType.objectType)
      .object);

  static final _id_EFFECT_TYPE_AGC = jniAccessors.getStaticFieldIDOf(
      _classRef, "EFFECT_TYPE_AGC", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_AGC
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for Automatic Gain Control (AGC)
  static jni.JniObject get EFFECT_TYPE_AGC => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_EFFECT_TYPE_AGC, jni.JniType.objectType)
      .object);

  static final _id_EFFECT_TYPE_BASS_BOOST = jniAccessors.getStaticFieldIDOf(
      _classRef, "EFFECT_TYPE_BASS_BOOST", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_BASS_BOOST
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for bass boost effect
  static jni.JniObject get EFFECT_TYPE_BASS_BOOST =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_EFFECT_TYPE_BASS_BOOST, jni.JniType.objectType)
          .object);

  static final _id_EFFECT_TYPE_DYNAMICS_PROCESSING =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "EFFECT_TYPE_DYNAMICS_PROCESSING", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_DYNAMICS_PROCESSING
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for Dynamics Processing
  static jni.JniObject get EFFECT_TYPE_DYNAMICS_PROCESSING =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_EFFECT_TYPE_DYNAMICS_PROCESSING,
              jni.JniType.objectType)
          .object);

  static final _id_EFFECT_TYPE_ENV_REVERB = jniAccessors.getStaticFieldIDOf(
      _classRef, "EFFECT_TYPE_ENV_REVERB", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_ENV_REVERB
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for environmental reverberation effect
  static jni.JniObject get EFFECT_TYPE_ENV_REVERB =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_EFFECT_TYPE_ENV_REVERB, jni.JniType.objectType)
          .object);

  static final _id_EFFECT_TYPE_EQUALIZER = jniAccessors.getStaticFieldIDOf(
      _classRef, "EFFECT_TYPE_EQUALIZER", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_EQUALIZER
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for equalizer effect
  static jni.JniObject get EFFECT_TYPE_EQUALIZER =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_EFFECT_TYPE_EQUALIZER, jni.JniType.objectType)
          .object);

  static final _id_EFFECT_TYPE_LOUDNESS_ENHANCER =
      jniAccessors.getStaticFieldIDOf(
          _classRef, "EFFECT_TYPE_LOUDNESS_ENHANCER", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_LOUDNESS_ENHANCER
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for Loudness Enhancer
  static jni.JniObject get EFFECT_TYPE_LOUDNESS_ENHANCER =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_EFFECT_TYPE_LOUDNESS_ENHANCER,
              jni.JniType.objectType)
          .object);

  static final _id_EFFECT_TYPE_NS = jniAccessors.getStaticFieldIDOf(
      _classRef, "EFFECT_TYPE_NS", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_NS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for Noise Suppressor (NS)
  static jni.JniObject get EFFECT_TYPE_NS => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_EFFECT_TYPE_NS, jni.JniType.objectType)
      .object);

  static final _id_EFFECT_TYPE_PRESET_REVERB = jniAccessors.getStaticFieldIDOf(
      _classRef, "EFFECT_TYPE_PRESET_REVERB", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_PRESET_REVERB
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for preset reverberation effect
  static jni.JniObject get EFFECT_TYPE_PRESET_REVERB =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_EFFECT_TYPE_PRESET_REVERB, jni.JniType.objectType)
          .object);

  static final _id_EFFECT_TYPE_VIRTUALIZER = jniAccessors.getStaticFieldIDOf(
      _classRef, "EFFECT_TYPE_VIRTUALIZER", "Ljava/util/UUID;");

  /// from: static public final java.util.UUID EFFECT_TYPE_VIRTUALIZER
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID for virtualizer effect
  static jni.JniObject get EFFECT_TYPE_VIRTUALIZER =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_EFFECT_TYPE_VIRTUALIZER, jni.JniType.objectType)
          .object);

  /// from: static public final int ERROR
  ///
  /// Unspecified error.
  static const ERROR = -1;

  /// from: static public final int ERROR_BAD_VALUE
  ///
  /// Operation failed due to bad parameter value.
  static const ERROR_BAD_VALUE = -4;

  /// from: static public final int ERROR_DEAD_OBJECT
  ///
  /// Operation failed due to dead remote object.
  static const ERROR_DEAD_OBJECT = -7;

  /// from: static public final int ERROR_INVALID_OPERATION
  ///
  /// Operation failed because it was requested in wrong state.
  static const ERROR_INVALID_OPERATION = -5;

  /// from: static public final int ERROR_NO_INIT
  ///
  /// Operation failed due to bad object initialization.
  static const ERROR_NO_INIT = -3;

  /// from: static public final int ERROR_NO_MEMORY
  ///
  /// Operation failed due to lack of memory.
  static const ERROR_NO_MEMORY = -6;

  /// from: static public final java.lang.String EXTRA_AUDIO_SESSION
  ///
  /// Contains the ID of the audio session the effects should be applied to.
  /// This extra is for use with \#ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL,
  /// \#ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION and
  /// \#ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION intents.
  /// The extra value is of type int and is the audio session ID.
  ///@see android.media.MediaPlayer\#getAudioSessionId() for details on audio sessions.
  static const EXTRA_AUDIO_SESSION = "android.media.extra.AUDIO_SESSION";

  /// from: static public final java.lang.String EXTRA_CONTENT_TYPE
  ///
  /// Indicates which type of content is played by the application.
  /// This extra is for use with \#ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL and
  /// \#ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION intents.
  /// This information is used by the effect control application to customize UI and select
  /// appropriate default effect settings. The content type is one of the following:
  /// <ul>
  ///   <li>\#CONTENT_TYPE_MUSIC</li>
  ///   <li>\#CONTENT_TYPE_MOVIE</li>
  ///   <li>\#CONTENT_TYPE_GAME</li>
  ///   <li>\#CONTENT_TYPE_VOICE</li>
  /// </ul>
  /// If omitted, the content type defaults to \#CONTENT_TYPE_MUSIC.
  static const EXTRA_CONTENT_TYPE = "android.media.extra.CONTENT_TYPE";

  /// from: static public final java.lang.String EXTRA_PACKAGE_NAME
  ///
  /// Contains the package name of the calling application.
  /// This extra is for use with \#ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION and
  /// \#ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION intents.
  /// The extra value is a string containing the full package name.
  static const EXTRA_PACKAGE_NAME = "android.media.extra.PACKAGE_NAME";

  /// from: static public final int SUCCESS
  ///
  /// Successful operation.
  static const SUCCESS = 0;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/util/UUID;Ljava/util/UUID;II)V");

  /// from: void <init>(java.util.UUID type, java.util.UUID uuid, int priority, int audioSession)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class constructor.
  ///@param type type of effect engine created. See \#EFFECT_TYPE_ENV_REVERB,
  ///            \#EFFECT_TYPE_EQUALIZER ... Types corresponding to
  ///            built-in effects are defined by AudioEffect class. Other types
  ///            can be specified provided they correspond an existing OpenSL
  ///            ES interface ID and the corresponsing effect is available on
  ///            the platform. If an unspecified effect type is requested, the
  ///            constructor with throw the IllegalArgumentException. This
  ///            parameter can be set to \#EFFECT_TYPE_NULL in which
  ///            case only the uuid will be used to select the effect.
  ///@param uuid unique identifier of a particular effect implementation.
  ///            Must be specified if the caller wants to use a particular
  ///            implementation of an effect type. This parameter can be set to
  ///            \#EFFECT_TYPE_NULL in which case only the type will
  ///            be used to select the effect.
  ///@param priority the priority level requested by the application for
  ///            controlling the effect engine. As the same effect engine can
  ///            be shared by several applications, this parameter indicates
  ///            how much the requesting application needs control of effect
  ///            parameters. The normal priority is 0, above normal is a
  ///            positive number, below normal a negative number.
  ///@param audioSession system wide unique audio session identifier.
  ///            The effect will be attached to the MediaPlayer or AudioTrack in
  ///            the same audio session.
  ///@throws java.lang.IllegalArgumentException
  ///@throws java.lang.UnsupportedOperationException
  ///@throws java.lang.RuntimeException
  ///@hide
  AudioEffect(
      jni.JniObject type, jni.JniObject uuid, int priority, int audioSession)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [type.reference, uuid.reference, priority, audioSession]).object);

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Releases the native AudioEffect resources. It is a good practice to
  /// release the effect engine when not in use as control can be returned to
  /// other applications or the native resources released.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getDescriptor = jniAccessors.getMethodIDOf(_classRef,
      "getDescriptor", "()Landroid/media/audiofx/AudioEffect\$Descriptor;");

  /// from: public android.media.audiofx.AudioEffect.Descriptor getDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the effect descriptor.
  ///@see android.media.audiofx.AudioEffect.Descriptor
  ///@throws IllegalStateException
  AudioEffect_Descriptor getDescriptor() =>
      AudioEffect_Descriptor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDescriptor, jni.JniType.objectType, []).object);

  static final _id_queryEffects = jniAccessors.getStaticMethodIDOf(_classRef,
      "queryEffects", "()[Landroid/media/audiofx/AudioEffect\$Descriptor;");

  /// from: static public android.media.audiofx.AudioEffect.Descriptor[] queryEffects()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query all effects available on the platform. Returns an array of
  /// android.media.audiofx.AudioEffect.Descriptor objects
  ///@throws IllegalStateException
  static jni.JniObject queryEffects() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_queryEffects, jni.JniType.objectType, []).object);

  static final _id_setEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)I");

  /// from: public int setEnabled(boolean enabled)
  ///
  /// Enable or disable the effect.
  /// Creating an audio effect does not automatically apply this effect on the audio source. It
  /// creates the resources necessary to process this effect but the audio signal is still bypassed
  /// through the effect engine. Calling this method will make that the effect is actually applied
  /// or not to the audio content being played in the corresponding audio session.
  ///@param enabled the requested enable state
  ///@return \#SUCCESS in case of success, \#ERROR_INVALID_OPERATION
  ///         or \#ERROR_DEAD_OBJECT in case of failure.
  ///@throws IllegalStateException
  int setEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled, jni.JniType.intType, [enabled]).integer;

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// Returns effect unique identifier. This system wide unique identifier can
  /// be used to attach this effect to a MediaPlayer or an AudioTrack when the
  /// effect is an auxiliary effect (Reverb)
  ///@return the effect identifier.
  ///@throws IllegalStateException
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getEnabled =
      jniAccessors.getMethodIDOf(_classRef, "getEnabled", "()Z");

  /// from: public boolean getEnabled()
  ///
  /// Returns effect enabled state
  ///@return true if the effect is enabled, false otherwise.
  ///@throws IllegalStateException
  bool getEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_getEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_hasControl =
      jniAccessors.getMethodIDOf(_classRef, "hasControl", "()Z");

  /// from: public boolean hasControl()
  ///
  /// Checks if this AudioEffect object is controlling the effect engine.
  ///@return true if this instance has control of effect engine, false
  ///         otherwise.
  ///@throws IllegalStateException
  bool hasControl() => jniAccessors.callMethodWithArgs(
      reference, _id_hasControl, jni.JniType.booleanType, []).boolean;

  static final _id_setEnableStatusListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setEnableStatusListener",
      "(Landroid/media/audiofx/AudioEffect\$OnEnableStatusChangeListener;)V");

  /// from: public void setEnableStatusListener(android.media.audiofx.AudioEffect.OnEnableStatusChangeListener listener)
  ///
  /// Sets the listener AudioEffect notifies when the effect engine is enabled
  /// or disabled.
  ///@param listener
  void setEnableStatusListener(
          AudioEffect_OnEnableStatusChangeListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEnableStatusListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setControlStatusListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setControlStatusListener",
      "(Landroid/media/audiofx/AudioEffect\$OnControlStatusChangeListener;)V");

  /// from: public void setControlStatusListener(android.media.audiofx.AudioEffect.OnControlStatusChangeListener listener)
  ///
  /// Sets the listener AudioEffect notifies when the effect engine control is
  /// taken or returned.
  ///@param listener
  void setControlStatusListener(
          AudioEffect_OnControlStatusChangeListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setControlStatusListener,
          jni.JniType.voidType, [listener.reference]).check();
}

/// from: android.media.audiofx.AudioEffect$OnEnableStatusChangeListener
///
/// The OnEnableStatusChangeListener interface defines a method called by the AudioEffect
/// when a the enabled state of the effect engine was changed by the controlling application.
class AudioEffect_OnEnableStatusChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/media/audiofx/AudioEffect\$OnEnableStatusChangeListener");
  AudioEffect_OnEnableStatusChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onEnableStatusChange = jniAccessors.getMethodIDOf(_classRef,
      "onEnableStatusChange", "(Landroid/media/audiofx/AudioEffect;Z)V");

  /// from: public abstract void onEnableStatusChange(android.media.audiofx.AudioEffect effect, boolean enabled)
  ///
  /// Called on the listener to notify it that the effect engine has been
  /// enabled or disabled.
  ///@param effect the effect on which the interface is registered.
  ///@param enabled new effect state.
  void onEnableStatusChange(AudioEffect effect, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_onEnableStatusChange,
          jni.JniType.voidType, [effect.reference, enabled]).check();
}

/// from: android.media.audiofx.AudioEffect$OnControlStatusChangeListener
///
/// The OnControlStatusChangeListener interface defines a method called by the AudioEffect
/// when a the control of the effect engine is gained or lost by the application
class AudioEffect_OnControlStatusChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/media/audiofx/AudioEffect\$OnControlStatusChangeListener");
  AudioEffect_OnControlStatusChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onControlStatusChange = jniAccessors.getMethodIDOf(_classRef,
      "onControlStatusChange", "(Landroid/media/audiofx/AudioEffect;Z)V");

  /// from: public abstract void onControlStatusChange(android.media.audiofx.AudioEffect effect, boolean controlGranted)
  ///
  /// Called on the listener to notify it that the effect engine control
  /// has been taken or returned.
  ///@param effect the effect on which the interface is registered.
  ///@param controlGranted true if the application has been granted control of the effect
  /// engine, false otherwise.
  void onControlStatusChange(AudioEffect effect, bool controlGranted) =>
      jniAccessors.callMethodWithArgs(reference, _id_onControlStatusChange,
          jni.JniType.voidType, [effect.reference, controlGranted]).check();
}

/// from: android.media.audiofx.AudioEffect$Descriptor
///
/// The effect descriptor contains information on a particular effect implemented in the
/// audio framework:<br>
/// <ul>
///  <li>type: UUID identifying the effect type. May be one of:
/// AudioEffect\#EFFECT_TYPE_AEC, AudioEffect\#EFFECT_TYPE_AGC,
/// AudioEffect\#EFFECT_TYPE_BASS_BOOST, AudioEffect\#EFFECT_TYPE_ENV_REVERB,
/// AudioEffect\#EFFECT_TYPE_EQUALIZER, AudioEffect\#EFFECT_TYPE_NS,
/// AudioEffect\#EFFECT_TYPE_PRESET_REVERB, AudioEffect\#EFFECT_TYPE_VIRTUALIZER,
/// AudioEffect\#EFFECT_TYPE_DYNAMICS_PROCESSING.
///  </li>
///  <li>uuid: UUID for this particular implementation</li>
///  <li>connectMode: \#EFFECT_INSERT or \#EFFECT_AUXILIARY</li>
///  <li>name: human readable effect name</li>
///  <li>implementor: human readable effect implementor name</li>
/// </ul>
/// The method \#queryEffects() returns an array of Descriptors to facilitate effects
/// enumeration.
class AudioEffect_Descriptor extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/audiofx/AudioEffect\$Descriptor");
  AudioEffect_Descriptor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_connectMode =
      jniAccessors.getFieldIDOf(_classRef, "connectMode", "Ljava/lang/String;");

  /// from: public java.lang.String connectMode
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates if the effect is of insert category \#EFFECT_INSERT or auxiliary
  ///  category \#EFFECT_AUXILIARY.
  ///  Insert effects (typically an Equalizer) are applied
  ///  to the entire audio source and usually not shared by several sources. Auxiliary effects
  ///  (typically a reverberator) are applied to part of the signal (wet) and the effect output
  ///  is added to the original signal (dry).
  ///  Audio pre processing are applied to audio captured on a particular
  /// android.media.AudioRecord.
  jni.JniString get connectMode => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_connectMode, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String connectMode
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates if the effect is of insert category \#EFFECT_INSERT or auxiliary
  ///  category \#EFFECT_AUXILIARY.
  ///  Insert effects (typically an Equalizer) are applied
  ///  to the entire audio source and usually not shared by several sources. Auxiliary effects
  ///  (typically a reverberator) are applied to part of the signal (wet) and the effect output
  ///  is added to the original signal (dry).
  ///  Audio pre processing are applied to audio captured on a particular
  /// android.media.AudioRecord.
  set connectMode(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_connectMode, value.reference);

  static final _id_implementor =
      jniAccessors.getFieldIDOf(_classRef, "implementor", "Ljava/lang/String;");

  /// from: public java.lang.String implementor
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Human readable effect implementor name
  jni.JniString get implementor => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_implementor, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String implementor
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Human readable effect implementor name
  set implementor(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_implementor, value.reference);

  static final _id_name =
      jniAccessors.getFieldIDOf(_classRef, "name", "Ljava/lang/String;");

  /// from: public java.lang.String name
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Human readable effect name
  jni.JniString get name => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_name, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String name
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Human readable effect name
  set name(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_name, value.reference);

  static final _id_type =
      jniAccessors.getFieldIDOf(_classRef, "type", "Ljava/util/UUID;");

  /// from: public java.util.UUID type
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the generic type of the effect (Equalizer, Bass boost ...).
  ///  One of AudioEffect\#EFFECT_TYPE_AEC,
  ///  AudioEffect\#EFFECT_TYPE_AGC, AudioEffect\#EFFECT_TYPE_BASS_BOOST,
  ///  AudioEffect\#EFFECT_TYPE_ENV_REVERB, AudioEffect\#EFFECT_TYPE_EQUALIZER,
  ///  AudioEffect\#EFFECT_TYPE_NS, AudioEffect\#EFFECT_TYPE_PRESET_REVERB
  ///  AudioEffect\#EFFECT_TYPE_VIRTUALIZER
  ///   or AudioEffect\#EFFECT_TYPE_DYNAMICS_PROCESSING.<br>
  ///  For reverberation, bass boost, EQ and virtualizer, the UUID
  ///  corresponds to the OpenSL ES Interface ID.
  jni.JniObject get type => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_type, jni.JniType.objectType)
      .object);

  /// from: public java.util.UUID type
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the generic type of the effect (Equalizer, Bass boost ...).
  ///  One of AudioEffect\#EFFECT_TYPE_AEC,
  ///  AudioEffect\#EFFECT_TYPE_AGC, AudioEffect\#EFFECT_TYPE_BASS_BOOST,
  ///  AudioEffect\#EFFECT_TYPE_ENV_REVERB, AudioEffect\#EFFECT_TYPE_EQUALIZER,
  ///  AudioEffect\#EFFECT_TYPE_NS, AudioEffect\#EFFECT_TYPE_PRESET_REVERB
  ///  AudioEffect\#EFFECT_TYPE_VIRTUALIZER
  ///   or AudioEffect\#EFFECT_TYPE_DYNAMICS_PROCESSING.<br>
  ///  For reverberation, bass boost, EQ and virtualizer, the UUID
  ///  corresponds to the OpenSL ES Interface ID.
  set type(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_type, value.reference);

  static final _id_uuid =
      jniAccessors.getFieldIDOf(_classRef, "uuid", "Ljava/util/UUID;");

  /// from: public java.util.UUID uuid
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the particular implementation of the effect in that type. Several effects
  ///  can have the same type but this uuid is unique to a given implementation.
  jni.JniObject get uuid => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_uuid, jni.JniType.objectType)
      .object);

  /// from: public java.util.UUID uuid
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates the particular implementation of the effect in that type. Several effects
  ///  can have the same type but this uuid is unique to a given implementation.
  set uuid(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_uuid, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AudioEffect_Descriptor()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String type, java.lang.String uuid, java.lang.String connectMode, java.lang.String name, java.lang.String implementor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param type UUID identifying the effect type. May be one of:
  /// AudioEffect\#EFFECT_TYPE_AEC, AudioEffect\#EFFECT_TYPE_AGC,
  /// AudioEffect\#EFFECT_TYPE_BASS_BOOST, AudioEffect\#EFFECT_TYPE_ENV_REVERB,
  /// AudioEffect\#EFFECT_TYPE_EQUALIZER, AudioEffect\#EFFECT_TYPE_NS,
  /// AudioEffect\#EFFECT_TYPE_PRESET_REVERB,
  /// AudioEffect\#EFFECT_TYPE_VIRTUALIZER,
  /// AudioEffect\#EFFECT_TYPE_DYNAMICS_PROCESSING.
  ///@param uuid UUID for this particular implementation
  ///@param connectMode \#EFFECT_INSERT or \#EFFECT_AUXILIARY
  ///@param name human readable effect name
  ///@param implementor human readable effect implementor name
  AudioEffect_Descriptor.ctor1(jni.JniString type, jni.JniString uuid,
      jni.JniString connectMode, jni.JniString name, jni.JniString implementor)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          type.reference,
          uuid.reference,
          connectMode.reference,
          name.reference,
          implementor.reference
        ]).object);
}
