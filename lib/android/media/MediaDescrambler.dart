// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "MediaCas.dart" as mediacas_;

import "MediaCodec.dart" as mediacodec_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaDescrambler
///
/// MediaDescrambler class can be used in conjunction with android.media.MediaCodec
/// and android.media.MediaExtractor to decode media data scrambled by conditional
/// access (CA) systems such as those in the ISO/IEC13818-1.
///
/// A MediaDescrambler object is initialized from a session opened by a MediaCas object,
/// and can be used to descramble media streams scrambled with that session's keys.
///
/// Scrambling schemes are identified by 16-bit unsigned integer as in CA_system_id.
class MediaDescrambler extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaDescrambler");
  MediaDescrambler.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final byte SCRAMBLE_CONTROL_EVEN_KEY
  ///
  /// Scramble control value indicating that the even key is used.
  ///@see \#descramble(ByteBuffer, ByteBuffer, android.media.MediaCodec.CryptoInfo)
  static const SCRAMBLE_CONTROL_EVEN_KEY = 2;

  /// from: static public final byte SCRAMBLE_CONTROL_ODD_KEY
  ///
  /// Scramble control value indicating that the odd key is used.
  ///@see \#descramble(ByteBuffer, ByteBuffer, android.media.MediaCodec.CryptoInfo)
  static const SCRAMBLE_CONTROL_ODD_KEY = 3;

  /// from: static public final byte SCRAMBLE_CONTROL_RESERVED
  ///
  /// Scramble control value reserved and shouldn't be used currently.
  ///@see \#descramble(ByteBuffer, ByteBuffer, android.media.MediaCodec.CryptoInfo)
  static const SCRAMBLE_CONTROL_RESERVED = 1;

  /// from: static public final byte SCRAMBLE_CONTROL_UNSCRAMBLED
  ///
  /// Scramble control value indicating that the samples are not scrambled.
  ///@see \#descramble(ByteBuffer, ByteBuffer, android.media.MediaCodec.CryptoInfo)
  static const SCRAMBLE_CONTROL_UNSCRAMBLED = 0;

  /// from: static public final byte SCRAMBLE_FLAG_PES_HEADER
  ///
  /// Scramble flag for a hint indicating that the descrambling request is for
  /// retrieving the PES header info only.
  ///@see \#descramble(ByteBuffer, ByteBuffer, android.media.MediaCodec.CryptoInfo)
  static const SCRAMBLE_FLAG_PES_HEADER = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int CA_system_id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiate a MediaDescrambler.
  ///@param CA_system_id The system id of the scrambling scheme.
  ///@throws UnsupportedCasException if the scrambling scheme is not supported.
  MediaDescrambler(int CA_system_id)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [CA_system_id]).object);

  static final _id_requiresSecureDecoderComponent = jniAccessors.getMethodIDOf(
      _classRef, "requiresSecureDecoderComponent", "(Ljava/lang/String;)Z");

  /// from: public boolean requiresSecureDecoderComponent(java.lang.String mime)
  ///
  /// Query if the scrambling scheme requires the use of a secure decoder
  /// to decode data of the given mime type.
  ///@param mime The mime type of the media data
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the descrambler instance is not valid.
  bool requiresSecureDecoderComponent(jni.JniString mime) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requiresSecureDecoderComponent,
          jni.JniType.booleanType,
          [mime.reference]).boolean;

  static final _id_setMediaCasSession = jniAccessors.getMethodIDOf(
      _classRef, "setMediaCasSession", "(Landroid/media/MediaCas\$Session;)V");

  /// from: public void setMediaCasSession(android.media.MediaCas.Session session)
  ///
  /// Associate a MediaCas session with this MediaDescrambler instance.
  /// The MediaCas session is used to securely load decryption keys for
  /// the descrambler. The crypto keys loaded through the MediaCas session
  /// may be selected for use during the descrambling operation performed
  /// by android.media.MediaExtractor or @link
  /// android.media.MediaCodec\#queueSecureInputBuffer by specifying even
  /// or odd key in the android.media.MediaCodec.CryptoInfo\#key field.
  ///@param session the MediaCas session to associate with this
  /// MediaDescrambler instance.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the descrambler instance is not valid.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void setMediaCasSession(mediacas_.MediaCas_Session session) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMediaCasSession,
          jni.JniType.voidType, [session.reference]).check();

  static final _id_descramble = jniAccessors.getMethodIDOf(
      _classRef,
      "descramble",
      "(Ljava/nio/ByteBuffer;Ljava/nio/ByteBuffer;Landroid/media/MediaCodec\$CryptoInfo;)I");

  /// from: public int descramble(java.nio.ByteBuffer srcBuf, java.nio.ByteBuffer dstBuf, android.media.MediaCodec.CryptoInfo cryptoInfo)
  ///
  /// Descramble a ByteBuffer of data described by a
  /// android.media.MediaCodec.CryptoInfo structure.
  ///@param srcBuf ByteBuffer containing the scrambled data, which starts at
  /// srcBuf.position().
  /// This value must never be {@code null}.
  ///@param dstBuf ByteBuffer to hold the descrambled data, which starts at
  /// dstBuf.position().
  /// This value must never be {@code null}.
  ///@param cryptoInfo a android.media.MediaCodec.CryptoInfo structure
  /// describing the subsamples contained in srcBuf. The iv and mode fields in
  /// CryptoInfo are not used. key[0] contains the MPEG2TS scrambling control bits
  /// (as defined in ETSI TS 100 289 (2011): "Digital Video Broadcasting (DVB);
  /// Support for use of the DVB Scrambling Algorithm version 3 within digital
  /// broadcasting systems"), and the value must be one of \#SCRAMBLE_CONTROL_UNSCRAMBLED,
  /// \#SCRAMBLE_CONTROL_RESERVED, \#SCRAMBLE_CONTROL_EVEN_KEY or
  /// \#SCRAMBLE_CONTROL_ODD_KEY. key[1] is a set of bit flags, with the
  /// only possible bit being \#SCRAMBLE_FLAG_PES_HEADER currently.
  /// key[2~15] are not used.
  ///
  /// This value must never be {@code null}.
  ///@return number of bytes that have been successfully descrambled, with negative
  /// values indicating errors.
  ///@throws IllegalStateException if the descrambler instance is not valid.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  int descramble(jni.JniObject srcBuf, jni.JniObject dstBuf,
          mediacodec_.MediaCodec_CryptoInfo cryptoInfo) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_descramble,
          jni.JniType.intType,
          [srcBuf.reference, dstBuf.reference, cryptoInfo.reference]).integer;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
