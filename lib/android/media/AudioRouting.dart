// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AudioDeviceInfo.dart" as audiodeviceinfo_;

import "../os/Handler.dart" as handler_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.AudioRouting
///
/// AudioRouting defines an interface for controlling routing and routing notifications in
/// AudioTrack and AudioRecord objects.
class AudioRouting extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/AudioRouting");
  AudioRouting.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_setPreferredDevice = jniAccessors.getMethodIDOf(
      _classRef, "setPreferredDevice", "(Landroid/media/AudioDeviceInfo;)Z");

  /// from: public abstract boolean setPreferredDevice(android.media.AudioDeviceInfo deviceInfo)
  ///
  /// Specifies an audio device (via an AudioDeviceInfo object) to route
  /// the output/input to/from.
  ///@param deviceInfo The AudioDeviceInfo specifying the audio sink or source.
  ///  If deviceInfo is null, default routing is restored.
  ///@return true if succesful, false if the specified AudioDeviceInfo is non-null and
  /// does not correspond to a valid audio device.
  bool setPreferredDevice(audiodeviceinfo_.AudioDeviceInfo deviceInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreferredDevice,
          jni.JniType.booleanType, [deviceInfo.reference]).boolean;

  static final _id_getPreferredDevice = jniAccessors.getMethodIDOf(
      _classRef, "getPreferredDevice", "()Landroid/media/AudioDeviceInfo;");

  /// from: public abstract android.media.AudioDeviceInfo getPreferredDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the selected output/input specified by \#setPreferredDevice. Note that this
  /// is not guaranteed to correspond to the actual device being used for playback/recording.
  audiodeviceinfo_.AudioDeviceInfo getPreferredDevice() =>
      audiodeviceinfo_.AudioDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPreferredDevice,
          jni.JniType.objectType, []).object);

  static final _id_getRoutedDevice = jniAccessors.getMethodIDOf(
      _classRef, "getRoutedDevice", "()Landroid/media/AudioDeviceInfo;");

  /// from: public abstract android.media.AudioDeviceInfo getRoutedDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an AudioDeviceInfo identifying the current routing of this
  /// AudioTrack/AudioRecord.
  /// Note: The query is only valid if the AudioTrack/AudioRecord is currently playing.
  /// If it is not, <code>getRoutedDevice()</code> will return null.
  audiodeviceinfo_.AudioDeviceInfo getRoutedDevice() =>
      audiodeviceinfo_.AudioDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRoutedDevice, jni.JniType.objectType, []).object);

  static final _id_addOnRoutingChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnRoutingChangedListener",
      "(Landroid/media/AudioRouting\$OnRoutingChangedListener;Landroid/os/Handler;)V");

  /// from: public abstract void addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener listener, android.os.Handler handler)
  ///
  /// Adds an AudioRouting.OnRoutingChangedListener to receive notifications of routing
  /// changes on this AudioTrack/AudioRecord.
  ///@param listener The AudioRouting.OnRoutingChangedListener interface to receive
  /// notifications of rerouting events.
  ///@param handler Specifies the Handler object for the thread on which to execute
  /// the callback. If <code>null</code>, the Handler associated with the main
  /// Looper will be used.
  void addOnRoutingChangedListener(
          AudioRouting_OnRoutingChangedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnRoutingChangedListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeOnRoutingChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnRoutingChangedListener",
      "(Landroid/media/AudioRouting\$OnRoutingChangedListener;)V");

  /// from: public abstract void removeOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener listener)
  ///
  /// Removes an AudioRouting.OnRoutingChangedListener which has been previously added
  /// to receive rerouting notifications.
  ///@param listener The previously added AudioRouting.OnRoutingChangedListener interface
  /// to remove.
  void removeOnRoutingChangedListener(
          AudioRouting_OnRoutingChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnRoutingChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();
}

/// from: android.media.AudioRouting$OnRoutingChangedListener
///
/// Defines the interface by which applications can receive notifications of routing
/// changes for the associated AudioRouting.
class AudioRouting_OnRoutingChangedListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/AudioRouting\$OnRoutingChangedListener");
  AudioRouting_OnRoutingChangedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onRoutingChanged = jniAccessors.getMethodIDOf(
      _classRef, "onRoutingChanged", "(Landroid/media/AudioRouting;)V");

  /// from: public abstract void onRoutingChanged(android.media.AudioRouting router)
  void onRoutingChanged(AudioRouting router) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRoutingChanged,
      jni.JniType.voidType,
      [router.reference]).check();
}
