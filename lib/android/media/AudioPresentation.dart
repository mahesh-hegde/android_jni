// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.AudioPresentation
///
/// The AudioPresentation class encapsulates the information that describes an audio presentation
/// which is available in next generation audio content.
///
/// Used by MediaExtractor MediaExtractor\#getAudioPresentations(int) and
/// AudioTrack AudioTrack\#setPresentation(AudioPresentation) to query available
/// presentations and to select one.
///
/// A list of available audio presentations in a media source can be queried using
/// MediaExtractor\#getAudioPresentations(int). This list can be presented to a user for
/// selection.
/// An AudioPresentation can be passed to an offloaded audio decoder via
/// AudioTrack\#setPresentation(AudioPresentation) to request decoding of the selected
/// presentation. An audio stream may contain multiple presentations that differ by language,
/// accessibility, end point mastering and dialogue enhancement. An audio presentation may also have
/// a set of description labels in different languages to help the user to make an informed
/// selection.
class AudioPresentation extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/AudioPresentation");
  AudioPresentation.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MASTERED_FOR_3D
  ///
  /// Three-dimensional (e.g.&nbsp;5.1.2) speaker layout.
  static const MASTERED_FOR_3D = 3;

  /// from: static public final int MASTERED_FOR_HEADPHONE
  ///
  /// Prerendered for headphone playback.
  static const MASTERED_FOR_HEADPHONE = 4;

  /// from: static public final int MASTERED_FOR_STEREO
  ///
  /// Stereo speaker layout.
  static const MASTERED_FOR_STEREO = 1;

  /// from: static public final int MASTERED_FOR_SURROUND
  ///
  /// Two-dimensional (e.g.&nbsp;5.1) speaker layout.
  static const MASTERED_FOR_SURROUND = 2;

  /// from: static public final int MASTERING_NOT_INDICATED
  ///
  /// No preferred reproduction channel layout.
  static const MASTERING_NOT_INDICATED = 0;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(IILjava/util/Map;Ljava/lang/String;IZZZ)V");

  /// from: void <init>(int presentationId, int programId, java.util.Map<java.lang.String,java.lang.String> labels, java.lang.String language, int masteringIndication, boolean audioDescriptionAvailable, boolean spokenSubtitlesAvailable, boolean dialogueEnhancementAvailable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  AudioPresentation(
      int presentationId,
      int programId,
      jni.JniObject labels,
      jni.JniString language,
      int masteringIndication,
      bool audioDescriptionAvailable,
      bool spokenSubtitlesAvailable,
      bool dialogueEnhancementAvailable)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          presentationId,
          programId,
          labels.reference,
          language.reference,
          masteringIndication,
          audioDescriptionAvailable,
          spokenSubtitlesAvailable,
          dialogueEnhancementAvailable
        ]).object);

  static final _id_getLabels =
      jniAccessors.getMethodIDOf(_classRef, "getLabels", "()Ljava/util/Map;");

  /// from: public java.util.Map<java.util.Locale,java.lang.String> getLabels()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return a map of available text labels for this presentation. Each label is indexed by its
  /// locale corresponding to the language code as specified by ISO 639-2. Either ISO 639-2/B
  /// or ISO 639-2/T could be used.
  jni.JniObject getLabels() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLabels, jni.JniType.objectType, []).object);

  static final _id_getLocale = jniAccessors.getMethodIDOf(
      _classRef, "getLocale", "()Ljava/util/Locale;");

  /// from: public java.util.Locale getLocale()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the locale corresponding to audio presentation's ISO 639-1/639-2 language code.
  jni.JniObject getLocale() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocale, jni.JniType.objectType, []).object);

  static final _id_getMasteringIndication =
      jniAccessors.getMethodIDOf(_classRef, "getMasteringIndication", "()I");

  /// from: public int getMasteringIndication()
  ///
  /// @return the mastering indication of the audio presentation.
  /// See \#MASTERING_NOT_INDICATED, \#MASTERED_FOR_STEREO,
  /// \#MASTERED_FOR_SURROUND, \#MASTERED_FOR_3D, \#MASTERED_FOR_HEADPHONE
  ///
  /// Value is android.media.AudioPresentation\#MASTERING_NOT_INDICATED, android.media.AudioPresentation\#MASTERED_FOR_STEREO, android.media.AudioPresentation\#MASTERED_FOR_SURROUND, android.media.AudioPresentation\#MASTERED_FOR_3D, or android.media.AudioPresentation\#MASTERED_FOR_HEADPHONE
  int getMasteringIndication() => jniAccessors.callMethodWithArgs(
      reference, _id_getMasteringIndication, jni.JniType.intType, []).integer;

  static final _id_hasAudioDescription =
      jniAccessors.getMethodIDOf(_classRef, "hasAudioDescription", "()Z");

  /// from: public boolean hasAudioDescription()
  ///
  /// Indicates whether an audio description for the visually impaired is available.
  ///@return {@code true} if audio description is available.
  bool hasAudioDescription() => jniAccessors.callMethodWithArgs(
      reference, _id_hasAudioDescription, jni.JniType.booleanType, []).boolean;

  static final _id_hasSpokenSubtitles =
      jniAccessors.getMethodIDOf(_classRef, "hasSpokenSubtitles", "()Z");

  /// from: public boolean hasSpokenSubtitles()
  ///
  /// Indicates whether spoken subtitles for the visually impaired are available.
  ///@return {@code true} if spoken subtitles are available.
  bool hasSpokenSubtitles() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSpokenSubtitles, jni.JniType.booleanType, []).boolean;

  static final _id_hasDialogueEnhancement =
      jniAccessors.getMethodIDOf(_classRef, "hasDialogueEnhancement", "()Z");

  /// from: public boolean hasDialogueEnhancement()
  ///
  /// Indicates whether dialogue enhancement is available.
  ///@return {@code true} if dialogue enhancement is available.
  bool hasDialogueEnhancement() => jniAccessors.callMethodWithArgs(reference,
      _id_hasDialogueEnhancement, jni.JniType.booleanType, []).boolean;
}
