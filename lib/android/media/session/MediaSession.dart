// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;

import "../../os/Handler.dart" as handler_;

import "../../app/PendingIntent.dart" as pendingintent_;

import "../AudioAttributes.dart" as audioattributes_;

import "../VolumeProvider.dart" as volumeprovider_;

import "../../os/Bundle.dart" as bundle_;

import "MediaController.dart" as mediacontroller_;

import "PlaybackState.dart" as playbackstate_;

import "../MediaMetadata.dart" as mediametadata_;

import "MediaSessionManager.dart" as mediasessionmanager_;

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;

import "../MediaDescription.dart" as mediadescription_;

import "../../os/ResultReceiver.dart" as resultreceiver_;

import "../../content/Intent.dart" as intent_;

import "../../net/Uri.dart" as uri_;

import "../Rating.dart" as rating_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.session.MediaSession
///
/// Allows interaction with media controllers, volume keys, media buttons, and
/// transport controls.
///
/// A MediaSession should be created when an app wants to publish media playback
/// information or handle media keys. In general an app only needs one session
/// for all playback, though multiple sessions can be created to provide finer
/// grain controls of media.
///
/// Once a session is created the owner of the session may pass its
/// \#getSessionToken() session token to other processes to allow them to
/// create a MediaController to interact with the session.
///
/// To receive commands, media keys, and other events a Callback must be
/// set with \#setCallback(Callback) and \#setActive(boolean) setActive(true) must be called.
///
/// When an app is finished performing playback it must call \#release()
/// to clean up the session and notify any controllers.
///
/// MediaSession objects are thread safe.
class MediaSession extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/session/MediaSession");
  MediaSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int FLAG_HANDLES_MEDIA_BUTTONS
  ///
  /// Set this flag on the session to indicate that it can handle media button
  /// events.
  ///@deprecated This flag is no longer used. All media sessions are expected to handle media
  /// button events now.
  static const FLAG_HANDLES_MEDIA_BUTTONS = 1;

  /// from: static public final int FLAG_HANDLES_TRANSPORT_CONTROLS
  ///
  /// Set this flag on the session to indicate that it handles transport
  /// control commands through its Callback.
  ///@deprecated This flag is no longer used. All media sessions are expected to handle transport
  /// controls now.
  static const FLAG_HANDLES_TRANSPORT_CONTROLS = 2;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Ljava/lang/String;)V");

  /// from: public void <init>(android.content.Context context, java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new session. The session will automatically be registered with
  /// the system but will not be published until \#setActive(boolean) setActive(true) is called. You must call \#release() when
  /// finished with the session.
  ///@param context The context to use to create the session.
  /// This value must never be {@code null}.
  ///@param tag A short name for debugging purposes.
  ///
  /// This value must never be {@code null}.
  MediaSession(context_.Context context, jni.JniString tag)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference, tag.reference]).object);

  static final _id_setCallback = jniAccessors.getMethodIDOf(_classRef,
      "setCallback", "(Landroid/media/session/MediaSession\$Callback;)V");

  /// from: public void setCallback(android.media.session.MediaSession.Callback callback)
  ///
  /// Set the callback to receive updates for the MediaSession. This includes
  /// media button events and transport controls. The caller's thread will be
  /// used to post updates.
  ///
  /// Set the callback to null to stop receiving updates.
  ///@param callback The callback object
  ///
  /// This value may be {@code null}.
  void setCallback(MediaSession_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_setCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setCallback",
      "(Landroid/media/session/MediaSession\$Callback;Landroid/os/Handler;)V");

  /// from: public void setCallback(android.media.session.MediaSession.Callback callback, android.os.Handler handler)
  ///
  /// Set the callback to receive updates for the MediaSession. This includes
  /// media button events and transport controls.
  ///
  /// Set the callback to null to stop receiving updates.
  ///@param callback The callback to receive updates on.
  /// This value may be {@code null}.
  ///@param handler The handler that events should be posted on.
  ///
  /// This value may be {@code null}.
  void setCallback1(MediaSession_Callback callback, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCallback1,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_setSessionActivity = jniAccessors.getMethodIDOf(
      _classRef, "setSessionActivity", "(Landroid/app/PendingIntent;)V");

  /// from: public void setSessionActivity(android.app.PendingIntent pi)
  ///
  /// Set an intent for launching UI for this Session. This can be used as a
  /// quick link to an ongoing media screen. The intent should be for an
  /// activity that may be started using Activity\#startActivity(Intent).
  ///@param pi The intent to launch to show UI for this Session.
  ///
  /// This value may be {@code null}.
  void setSessionActivity(pendingintent_.PendingIntent pi) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSessionActivity,
          jni.JniType.voidType, [pi.reference]).check();

  static final _id_setMediaButtonReceiver = jniAccessors.getMethodIDOf(
      _classRef, "setMediaButtonReceiver", "(Landroid/app/PendingIntent;)V");

  /// from: public void setMediaButtonReceiver(android.app.PendingIntent mbr)
  ///
  /// Set a pending intent for your media button receiver to allow restarting
  /// playback after the session has been stopped. If your app is started in
  /// this way an Intent\#ACTION_MEDIA_BUTTON intent will be sent via
  /// the pending intent.
  ///@param mbr The PendingIntent to send the media button event to.
  ///
  /// This value may be {@code null}.
  void setMediaButtonReceiver(pendingintent_.PendingIntent mbr) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMediaButtonReceiver,
          jni.JniType.voidType, [mbr.reference]).check();

  static final _id_setFlags =
      jniAccessors.getMethodIDOf(_classRef, "setFlags", "(I)V");

  /// from: public void setFlags(int flags)
  ///
  /// Set any flags for the session.
  ///@param flags The flags to set for this session.
  ///
  /// Value is either <code>0</code> or a combination of android.media.session.MediaSession\#FLAG_HANDLES_MEDIA_BUTTONS, android.media.session.MediaSession\#FLAG_HANDLES_TRANSPORT_CONTROLS, and android.media.session.MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY
  void setFlags(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_setFlags, jni.JniType.voidType, [flags]).check();

  static final _id_setPlaybackToLocal = jniAccessors.getMethodIDOf(
      _classRef, "setPlaybackToLocal", "(Landroid/media/AudioAttributes;)V");

  /// from: public void setPlaybackToLocal(android.media.AudioAttributes attributes)
  ///
  /// Set the attributes for this session's audio. This will affect the
  /// system's volume handling for this session. If
  /// \#setPlaybackToRemote was previously called it will stop receiving
  /// volume commands and the system will begin sending volume changes to the
  /// appropriate stream.
  ///
  /// By default sessions use attributes for media.
  ///@param attributes The AudioAttributes for this session's audio.
  void setPlaybackToLocal(audioattributes_.AudioAttributes attributes) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPlaybackToLocal,
          jni.JniType.voidType, [attributes.reference]).check();

  static final _id_setPlaybackToRemote = jniAccessors.getMethodIDOf(
      _classRef, "setPlaybackToRemote", "(Landroid/media/VolumeProvider;)V");

  /// from: public void setPlaybackToRemote(android.media.VolumeProvider volumeProvider)
  ///
  /// Configure this session to use remote volume handling. This must be called
  /// to receive volume button events, otherwise the system will adjust the
  /// appropriate stream volume for this session. If
  /// \#setPlaybackToLocal was previously called the system will stop
  /// handling volume changes for this session and pass them to the volume
  /// provider instead.
  ///@param volumeProvider The provider that will handle volume changes. May
  ///            not be null.
  ///
  /// This value must never be {@code null}.
  void setPlaybackToRemote(volumeprovider_.VolumeProvider volumeProvider) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPlaybackToRemote,
          jni.JniType.voidType, [volumeProvider.reference]).check();

  static final _id_setActive =
      jniAccessors.getMethodIDOf(_classRef, "setActive", "(Z)V");

  /// from: public void setActive(boolean active)
  ///
  /// Set if this session is currently active and ready to receive commands. If
  /// set to false your session's controller may not be discoverable. You must
  /// set the session to active before it can start receiving media button
  /// events or transport commands.
  ///@param active Whether this session is active or not.
  void setActive(bool active) => jniAccessors.callMethodWithArgs(
      reference, _id_setActive, jni.JniType.voidType, [active]).check();

  static final _id_isActive =
      jniAccessors.getMethodIDOf(_classRef, "isActive", "()Z");

  /// from: public boolean isActive()
  ///
  /// Get the current active state of this session.
  ///@return True if the session is active, false otherwise.
  bool isActive() => jniAccessors.callMethodWithArgs(
      reference, _id_isActive, jni.JniType.booleanType, []).boolean;

  static final _id_sendSessionEvent = jniAccessors.getMethodIDOf(_classRef,
      "sendSessionEvent", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void sendSessionEvent(java.lang.String event, android.os.Bundle extras)
  ///
  /// Send a proprietary event to all MediaControllers listening to this
  /// Session. It's up to the Controller/Session owner to determine the meaning
  /// of any events.
  ///@param event The name of the event to send
  /// This value must never be {@code null}.
  ///@param extras Any extras included with the event
  ///
  /// This value may be {@code null}.
  void sendSessionEvent(jni.JniString event, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendSessionEvent,
          jni.JniType.voidType, [event.reference, extras.reference]).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// This must be called when an app has finished performing playback. If
  /// playback is expected to start again shortly the session can be left open,
  /// but it must be released if your activity or service is being destroyed.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_getSessionToken = jniAccessors.getMethodIDOf(_classRef,
      "getSessionToken", "()Landroid/media/session/MediaSession\$Token;");

  /// from: public android.media.session.MediaSession.Token getSessionToken()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a token object that can be used by apps to create a
  /// MediaController for interacting with this session. The owner of
  /// the session is responsible for deciding how to distribute these tokens.
  ///@return A token that can be used to create a MediaController for this
  ///         session
  ///
  /// This value will never be {@code null}.
  MediaSession_Token getSessionToken() =>
      MediaSession_Token.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSessionToken, jni.JniType.objectType, []).object);

  static final _id_getController = jniAccessors.getMethodIDOf(
      _classRef, "getController", "()Landroid/media/session/MediaController;");

  /// from: public android.media.session.MediaController getController()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a controller for this session. This is a convenience method to avoid
  /// having to cache your own controller in process.
  ///@return A controller for this session.
  ///
  /// This value will never be {@code null}.
  mediacontroller_.MediaController getController() =>
      mediacontroller_.MediaController.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getController, jni.JniType.objectType, []).object);

  static final _id_setPlaybackState = jniAccessors.getMethodIDOf(_classRef,
      "setPlaybackState", "(Landroid/media/session/PlaybackState;)V");

  /// from: public void setPlaybackState(android.media.session.PlaybackState state)
  ///
  /// Update the current playback state.
  ///@param state The current state of playback
  ///
  /// This value may be {@code null}.
  void setPlaybackState(playbackstate_.PlaybackState state) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPlaybackState,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_setMetadata = jniAccessors.getMethodIDOf(
      _classRef, "setMetadata", "(Landroid/media/MediaMetadata;)V");

  /// from: public void setMetadata(android.media.MediaMetadata metadata)
  ///
  /// Update the current metadata. New metadata can be created using
  /// android.media.MediaMetadata.Builder. This operation may take time proportional to
  /// the size of the bitmap to replace large bitmaps with a scaled down copy.
  ///@param metadata The new metadata
  /// This value may be {@code null}.
  ///@see android.media.MediaMetadata.Builder\#putBitmap
  void setMetadata(mediametadata_.MediaMetadata metadata) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMetadata,
          jni.JniType.voidType, [metadata.reference]).check();

  static final _id_setQueue =
      jniAccessors.getMethodIDOf(_classRef, "setQueue", "(Ljava/util/List;)V");

  /// from: public void setQueue(java.util.List<android.media.session.MediaSession.QueueItem> queue)
  ///
  /// Update the list of items in the play queue. It is an ordered list and
  /// should contain the current item, and previous or upcoming items if they
  /// exist. Specify null if there is no current play queue.
  ///
  /// The queue should be of reasonable size. If the play queue is unbounded
  /// within your app, it is better to send a reasonable amount in a sliding
  /// window instead.
  ///@param queue A list of items in the play queue.
  ///
  /// This value may be {@code null}.
  void setQueue(jni.JniObject queue) => jniAccessors.callMethodWithArgs(
      reference, _id_setQueue, jni.JniType.voidType, [queue.reference]).check();

  static final _id_setQueueTitle = jniAccessors.getMethodIDOf(
      _classRef, "setQueueTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public void setQueueTitle(java.lang.CharSequence title)
  ///
  /// Set the title of the play queue. The UI should display this title along
  /// with the play queue itself.
  /// e.g. "Play Queue", "Now Playing", or an album name.
  ///@param title The title of the play queue.
  ///
  /// This value may be {@code null}.
  void setQueueTitle(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setQueueTitle,
      jni.JniType.voidType,
      [title.reference]).check();

  static final _id_setRatingType =
      jniAccessors.getMethodIDOf(_classRef, "setRatingType", "(I)V");

  /// from: public void setRatingType(int type)
  ///
  /// Set the style of rating used by this session. Apps trying to set the
  /// rating should use this style. Must be one of the following:
  /// <ul>
  /// <li>Rating\#RATING_NONE</li>
  /// <li>Rating\#RATING_3_STARS</li>
  /// <li>Rating\#RATING_4_STARS</li>
  /// <li>Rating\#RATING_5_STARS</li>
  /// <li>Rating\#RATING_HEART</li>
  /// <li>Rating\#RATING_PERCENTAGE</li>
  /// <li>Rating\#RATING_THUMB_UP_DOWN</li>
  /// </ul>
  ///@param type Value is android.media.Rating\#RATING_NONE, android.media.Rating\#RATING_HEART, android.media.Rating\#RATING_THUMB_UP_DOWN, android.media.Rating\#RATING_3_STARS, android.media.Rating\#RATING_4_STARS, android.media.Rating\#RATING_5_STARS, or android.media.Rating\#RATING_PERCENTAGE
  void setRatingType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setRatingType, jni.JniType.voidType, [type]).check();

  static final _id_setExtras = jniAccessors.getMethodIDOf(
      _classRef, "setExtras", "(Landroid/os/Bundle;)V");

  /// from: public void setExtras(android.os.Bundle extras)
  ///
  /// Set some extras that can be associated with the MediaSession. No assumptions should
  /// be made as to how a MediaController will handle these extras.
  /// Keys should be fully qualified (e.g. com.example.MY_EXTRA) to avoid conflicts.
  ///@param extras The extras associated with the MediaSession.
  ///
  /// This value may be {@code null}.
  void setExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_getCurrentControllerInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getCurrentControllerInfo",
      "()Landroid/media/session/MediaSessionManager\$RemoteUserInfo;");

  /// from: public android.media.session.MediaSessionManager.RemoteUserInfo getCurrentControllerInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the controller information who sent the current request.
  ///
  /// Note: This is only valid while in a request callback, such as Callback\#onPlay.
  ///@throws IllegalStateException If this method is called outside of Callback methods.
  ///@see MediaSessionManager\#isTrustedForMediaControl(RemoteUserInfo)
  ///@return This value will never be {@code null}.
  mediasessionmanager_.MediaSessionManager_RemoteUserInfo
      getCurrentControllerInfo() =>
          mediasessionmanager_.MediaSessionManager_RemoteUserInfo.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_getCurrentControllerInfo,
                  jni.JniType.objectType, []).object);
}

/// from: android.media.session.MediaSession$Token
///
/// Represents an ongoing session. This may be passed to apps by the session
/// owner to allow them to create a MediaController to communicate with
/// the session.
class MediaSession_Token extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/session/MediaSession\$Token");
  MediaSession_Token.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.media.session.MediaSession.Token> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaSession_Token()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;
}

/// from: android.media.session.MediaSession$QueueItem
///
/// A single item that is part of the play queue. It contains a description
/// of the item and its id in the queue.
class MediaSession_QueueItem extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/session/MediaSession\$QueueItem");
  MediaSession_QueueItem.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.media.session.MediaSession.QueueItem> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int UNKNOWN_ID
  ///
  /// This id is reserved. No items can be explicitly assigned this id.
  static const UNKNOWN_ID = -1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/media/MediaDescription;J)V");

  /// from: public void <init>(android.media.MediaDescription description, long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new MediaSession.QueueItem.
  ///@param description The MediaDescription for this item.
  ///@param id An identifier for this item. It must be unique within the
  ///            play queue and cannot be \#UNKNOWN_ID.
  MediaSession_QueueItem(mediadescription_.MediaDescription description, int id)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [description.reference, id]).object);

  static final _id_getDescription = jniAccessors.getMethodIDOf(
      _classRef, "getDescription", "()Landroid/media/MediaDescription;");

  /// from: public android.media.MediaDescription getDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the description for this item.
  mediadescription_.MediaDescription getDescription() =>
      mediadescription_.MediaDescription.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getDescription,
              jni.JniType.objectType, []).object);

  static final _id_getQueueId =
      jniAccessors.getMethodIDOf(_classRef, "getQueueId", "()J");

  /// from: public long getQueueId()
  ///
  /// Get the queue id for this item.
  int getQueueId() => jniAccessors.callMethodWithArgs(
      reference, _id_getQueueId, jni.JniType.longType, []).long;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;
}

/// from: android.media.session.MediaSession$Callback
///
/// Receives media buttons, transport controls, and commands from controllers
/// and the system. A callback may be set using \#setCallback.
class MediaSession_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/session/MediaSession\$Callback");
  MediaSession_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaSession_Callback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onCommand = jniAccessors.getMethodIDOf(
      _classRef,
      "onCommand",
      "(Ljava/lang/String;Landroid/os/Bundle;Landroid/os/ResultReceiver;)V");

  /// from: public void onCommand(java.lang.String command, android.os.Bundle args, android.os.ResultReceiver cb)
  ///
  /// Called when a controller has sent a command to this session.
  /// The owner of the session may handle custom commands but is not
  /// required to.
  ///@param command The command name.
  /// This value must never be {@code null}.
  ///@param args Optional parameters for the command, may be null.
  /// This value may be {@code null}.
  ///@param cb A result receiver to which a result may be sent by the command, may be null.
  ///
  /// This value may be {@code null}.
  void onCommand(jni.JniString command, bundle_.Bundle args,
          resultreceiver_.ResultReceiver cb) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCommand,
          jni.JniType.voidType,
          [command.reference, args.reference, cb.reference]).check();

  static final _id_onMediaButtonEvent = jniAccessors.getMethodIDOf(
      _classRef, "onMediaButtonEvent", "(Landroid/content/Intent;)Z");

  /// from: public boolean onMediaButtonEvent(android.content.Intent mediaButtonIntent)
  ///
  /// Called when a media button is pressed and this session has the
  /// highest priority or a controller sends a media button event to the
  /// session. The default behavior will call the relevant method if the
  /// action for it was set.
  ///
  /// The intent will be of type Intent\#ACTION_MEDIA_BUTTON with a
  /// KeyEvent in Intent\#EXTRA_KEY_EVENT
  ///@param mediaButtonIntent an intent containing the KeyEvent as an
  ///            extra
  /// This value must never be {@code null}.
  ///@return True if the event was handled, false otherwise.
  bool onMediaButtonEvent(intent_.Intent mediaButtonIntent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMediaButtonEvent,
          jni.JniType.booleanType, [mediaButtonIntent.reference]).boolean;

  static final _id_onPrepare =
      jniAccessors.getMethodIDOf(_classRef, "onPrepare", "()V");

  /// from: public void onPrepare()
  ///
  /// Override to handle requests to prepare playback. During the preparation, a session should
  /// not hold audio focus in order to allow other sessions play seamlessly. The state of
  /// playback should be updated to PlaybackState\#STATE_PAUSED after the preparation is
  /// done.
  void onPrepare() => jniAccessors.callMethodWithArgs(
      reference, _id_onPrepare, jni.JniType.voidType, []).check();

  static final _id_onPrepareFromMediaId = jniAccessors.getMethodIDOf(_classRef,
      "onPrepareFromMediaId", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onPrepareFromMediaId(java.lang.String mediaId, android.os.Bundle extras)
  ///
  /// Override to handle requests to prepare for playing a specific mediaId that was provided
  /// by your app's MediaBrowserService. During the preparation, a session should not
  /// hold audio focus in order to allow other sessions play seamlessly. The state of playback
  /// should be updated to PlaybackState\#STATE_PAUSED after the preparation is done.
  /// The playback of the prepared content should start in the implementation of
  /// \#onPlay. Override \#onPlayFromMediaId to handle requests for starting
  /// playback without preparation.
  void onPrepareFromMediaId(jni.JniString mediaId, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrepareFromMediaId,
          jni.JniType.voidType, [mediaId.reference, extras.reference]).check();

  static final _id_onPrepareFromSearch = jniAccessors.getMethodIDOf(_classRef,
      "onPrepareFromSearch", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onPrepareFromSearch(java.lang.String query, android.os.Bundle extras)
  ///
  /// Override to handle requests to prepare playback from a search query. An empty query
  /// indicates that the app may prepare any music. The implementation should attempt to make a
  /// smart choice about what to play. During the preparation, a session should not hold audio
  /// focus in order to allow other sessions play seamlessly. The state of playback should be
  /// updated to PlaybackState\#STATE_PAUSED after the preparation is done. The playback
  /// of the prepared content should start in the implementation of \#onPlay. Override
  /// \#onPlayFromSearch to handle requests for starting playback without preparation.
  void onPrepareFromSearch(jni.JniString query, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrepareFromSearch,
          jni.JniType.voidType, [query.reference, extras.reference]).check();

  static final _id_onPrepareFromUri = jniAccessors.getMethodIDOf(
      _classRef, "onPrepareFromUri", "(Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void onPrepareFromUri(android.net.Uri uri, android.os.Bundle extras)
  ///
  /// Override to handle requests to prepare a specific media item represented by a URI.
  /// During the preparation, a session should not hold audio focus in order to allow
  /// other sessions play seamlessly. The state of playback should be updated to
  /// PlaybackState\#STATE_PAUSED after the preparation is done.
  /// The playback of the prepared content should start in the implementation of
  /// \#onPlay. Override \#onPlayFromUri to handle requests
  /// for starting playback without preparation.
  void onPrepareFromUri(uri_.Uri uri, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrepareFromUri,
          jni.JniType.voidType, [uri.reference, extras.reference]).check();

  static final _id_onPlay =
      jniAccessors.getMethodIDOf(_classRef, "onPlay", "()V");

  /// from: public void onPlay()
  ///
  /// Override to handle requests to begin playback.
  void onPlay() => jniAccessors.callMethodWithArgs(
      reference, _id_onPlay, jni.JniType.voidType, []).check();

  static final _id_onPlayFromSearch = jniAccessors.getMethodIDOf(_classRef,
      "onPlayFromSearch", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onPlayFromSearch(java.lang.String query, android.os.Bundle extras)
  ///
  /// Override to handle requests to begin playback from a search query. An
  /// empty query indicates that the app may play any music. The
  /// implementation should attempt to make a smart choice about what to
  /// play.
  void onPlayFromSearch(jni.JniString query, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPlayFromSearch,
          jni.JniType.voidType, [query.reference, extras.reference]).check();

  static final _id_onPlayFromMediaId = jniAccessors.getMethodIDOf(_classRef,
      "onPlayFromMediaId", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onPlayFromMediaId(java.lang.String mediaId, android.os.Bundle extras)
  ///
  /// Override to handle requests to play a specific mediaId that was
  /// provided by your app's MediaBrowserService.
  void onPlayFromMediaId(jni.JniString mediaId, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPlayFromMediaId,
          jni.JniType.voidType, [mediaId.reference, extras.reference]).check();

  static final _id_onPlayFromUri = jniAccessors.getMethodIDOf(
      _classRef, "onPlayFromUri", "(Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void onPlayFromUri(android.net.Uri uri, android.os.Bundle extras)
  ///
  /// Override to handle requests to play a specific media item represented by a URI.
  void onPlayFromUri(uri_.Uri uri, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPlayFromUri,
          jni.JniType.voidType, [uri.reference, extras.reference]).check();

  static final _id_onSkipToQueueItem =
      jniAccessors.getMethodIDOf(_classRef, "onSkipToQueueItem", "(J)V");

  /// from: public void onSkipToQueueItem(long id)
  ///
  /// Override to handle requests to play an item with a given id from the
  /// play queue.
  void onSkipToQueueItem(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_onSkipToQueueItem, jni.JniType.voidType, [id]).check();

  static final _id_onPause =
      jniAccessors.getMethodIDOf(_classRef, "onPause", "()V");

  /// from: public void onPause()
  ///
  /// Override to handle requests to pause playback.
  void onPause() => jniAccessors.callMethodWithArgs(
      reference, _id_onPause, jni.JniType.voidType, []).check();

  static final _id_onSkipToNext =
      jniAccessors.getMethodIDOf(_classRef, "onSkipToNext", "()V");

  /// from: public void onSkipToNext()
  ///
  /// Override to handle requests to skip to the next media item.
  void onSkipToNext() => jniAccessors.callMethodWithArgs(
      reference, _id_onSkipToNext, jni.JniType.voidType, []).check();

  static final _id_onSkipToPrevious =
      jniAccessors.getMethodIDOf(_classRef, "onSkipToPrevious", "()V");

  /// from: public void onSkipToPrevious()
  ///
  /// Override to handle requests to skip to the previous media item.
  void onSkipToPrevious() => jniAccessors.callMethodWithArgs(
      reference, _id_onSkipToPrevious, jni.JniType.voidType, []).check();

  static final _id_onFastForward =
      jniAccessors.getMethodIDOf(_classRef, "onFastForward", "()V");

  /// from: public void onFastForward()
  ///
  /// Override to handle requests to fast forward.
  void onFastForward() => jniAccessors.callMethodWithArgs(
      reference, _id_onFastForward, jni.JniType.voidType, []).check();

  static final _id_onRewind =
      jniAccessors.getMethodIDOf(_classRef, "onRewind", "()V");

  /// from: public void onRewind()
  ///
  /// Override to handle requests to rewind.
  void onRewind() => jniAccessors.callMethodWithArgs(
      reference, _id_onRewind, jni.JniType.voidType, []).check();

  static final _id_onStop =
      jniAccessors.getMethodIDOf(_classRef, "onStop", "()V");

  /// from: public void onStop()
  ///
  /// Override to handle requests to stop playback.
  void onStop() => jniAccessors.callMethodWithArgs(
      reference, _id_onStop, jni.JniType.voidType, []).check();

  static final _id_onSeekTo =
      jniAccessors.getMethodIDOf(_classRef, "onSeekTo", "(J)V");

  /// from: public void onSeekTo(long pos)
  ///
  /// Override to handle requests to seek to a specific position in ms.
  ///@param pos New position to move to, in milliseconds.
  void onSeekTo(int pos) => jniAccessors.callMethodWithArgs(
      reference, _id_onSeekTo, jni.JniType.voidType, [pos]).check();

  static final _id_onSetRating = jniAccessors.getMethodIDOf(
      _classRef, "onSetRating", "(Landroid/media/Rating;)V");

  /// from: public void onSetRating(android.media.Rating rating)
  ///
  /// Override to handle the item being rated.
  ///@param rating This value must never be {@code null}.
  void onSetRating(rating_.Rating rating) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSetRating,
      jni.JniType.voidType,
      [rating.reference]).check();

  static final _id_onCustomAction = jniAccessors.getMethodIDOf(
      _classRef, "onCustomAction", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onCustomAction(java.lang.String action, android.os.Bundle extras)
  ///
  /// Called when a MediaController wants a PlaybackState.CustomAction to be
  /// performed.
  ///@param action The action that was originally sent in the
  ///               PlaybackState.CustomAction.
  /// This value must never be {@code null}.
  ///@param extras Optional extras specified by the MediaController.
  ///
  /// This value may be {@code null}.
  void onCustomAction(jni.JniString action, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCustomAction,
          jni.JniType.voidType, [action.reference, extras.reference]).check();
}
