// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;

import "MediaSession.dart" as mediasession_;

import "../../view/KeyEvent.dart" as keyevent_;

import "PlaybackState.dart" as playbackstate_;

import "../MediaMetadata.dart" as mediametadata_;

import "../../os/Bundle.dart" as bundle_;

import "../../app/PendingIntent.dart" as pendingintent_;

import "../../os/Handler.dart" as handler_;

import "../../os/ResultReceiver.dart" as resultreceiver_;

import "../../net/Uri.dart" as uri_;

import "../Rating.dart" as rating_;

import "../AudioAttributes.dart" as audioattributes_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.session.MediaController
///
/// Allows an app to interact with an ongoing media session. Media buttons and
/// other commands can be sent to the session. A callback may be registered to
/// receive updates from the session, such as metadata and play state changes.
///
/// A MediaController can be created through MediaSessionManager if you
/// hold the "android.permission.MEDIA_CONTENT_CONTROL" permission or are an
/// enabled notification listener or by getting a MediaSession.Token
/// directly from the session owner.
///
/// MediaController objects are thread-safe.
class MediaController extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/session/MediaController");
  MediaController.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/media/session/MediaSession\$Token;)V");

  /// from: public void <init>(android.content.Context context, android.media.session.MediaSession.Token token)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new MediaController from a session's token.
  ///@param context The caller's context.
  /// This value must never be {@code null}.
  ///@param token The token for the session.
  ///
  /// This value must never be {@code null}.
  MediaController(
      context_.Context context, mediasession_.MediaSession_Token token)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference, token.reference]).object);

  static final _id_getTransportControls = jniAccessors.getMethodIDOf(
      _classRef,
      "getTransportControls",
      "()Landroid/media/session/MediaController\$TransportControls;");

  /// from: public android.media.session.MediaController.TransportControls getTransportControls()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a TransportControls instance to send transport actions to
  /// the associated session.
  ///@return A transport controls instance.
  ///
  /// This value will never be {@code null}.
  MediaController_TransportControls getTransportControls() =>
      MediaController_TransportControls.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTransportControls,
          jni.JniType.objectType, []).object);

  static final _id_dispatchMediaButtonEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchMediaButtonEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchMediaButtonEvent(android.view.KeyEvent keyEvent)
  ///
  /// Send the specified media button event to the session. Only media keys can
  /// be sent by this method, other keys will be ignored.
  ///@param keyEvent The media button event to dispatch.
  /// This value must never be {@code null}.
  ///@return true if the event was sent to the session, false otherwise.
  bool dispatchMediaButtonEvent(keyevent_.KeyEvent keyEvent) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchMediaButtonEvent,
          jni.JniType.booleanType, [keyEvent.reference]).boolean;

  static final _id_getPlaybackState = jniAccessors.getMethodIDOf(
      _classRef, "getPlaybackState", "()Landroid/media/session/PlaybackState;");

  /// from: public android.media.session.PlaybackState getPlaybackState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the current playback state for this session.
  ///@return The current PlaybackState or null
  playbackstate_.PlaybackState getPlaybackState() =>
      playbackstate_.PlaybackState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPlaybackState, jni.JniType.objectType, []).object);

  static final _id_getMetadata = jniAccessors.getMethodIDOf(
      _classRef, "getMetadata", "()Landroid/media/MediaMetadata;");

  /// from: public android.media.MediaMetadata getMetadata()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the current metadata for this session.
  ///@return The current MediaMetadata or null.
  mediametadata_.MediaMetadata getMetadata() =>
      mediametadata_.MediaMetadata.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMetadata, jni.JniType.objectType, []).object);

  static final _id_getQueue =
      jniAccessors.getMethodIDOf(_classRef, "getQueue", "()Ljava/util/List;");

  /// from: public java.util.List<android.media.session.MediaSession.QueueItem> getQueue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the current play queue for this session if one is set. If you only
  /// care about the current item \#getMetadata() should be used.
  ///@return The current play queue or null.
  jni.JniObject getQueue() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getQueue, jni.JniType.objectType, []).object);

  static final _id_getQueueTitle = jniAccessors.getMethodIDOf(
      _classRef, "getQueueTitle", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getQueueTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the queue title for this session.
  ///@return This value may be {@code null}.
  jni.JniObject getQueueTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getQueueTitle, jni.JniType.objectType, []).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the extras for this session.
  ///@return This value may be {@code null}.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_getRatingType =
      jniAccessors.getMethodIDOf(_classRef, "getRatingType", "()I");

  /// from: public int getRatingType()
  ///
  /// Get the rating type supported by the session. One of:
  /// <ul>
  /// <li>Rating\#RATING_NONE</li>
  /// <li>Rating\#RATING_HEART</li>
  /// <li>Rating\#RATING_THUMB_UP_DOWN</li>
  /// <li>Rating\#RATING_3_STARS</li>
  /// <li>Rating\#RATING_4_STARS</li>
  /// <li>Rating\#RATING_5_STARS</li>
  /// <li>Rating\#RATING_PERCENTAGE</li>
  /// </ul>
  ///@return The supported rating type
  int getRatingType() => jniAccessors.callMethodWithArgs(
      reference, _id_getRatingType, jni.JniType.intType, []).integer;

  static final _id_getFlags =
      jniAccessors.getMethodIDOf(_classRef, "getFlags", "()J");

  /// from: public long getFlags()
  ///
  /// Get the flags for this session. Flags are defined in MediaSession.
  ///@return The current set of flags for the session.
  ///
  /// Value is either <code>0</code> or a combination of android.media.session.MediaSession\#FLAG_HANDLES_MEDIA_BUTTONS, android.media.session.MediaSession\#FLAG_HANDLES_TRANSPORT_CONTROLS, and android.media.session.MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY
  int getFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getFlags, jni.JniType.longType, []).long;

  static final _id_getPlaybackInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getPlaybackInfo",
      "()Landroid/media/session/MediaController\$PlaybackInfo;");

  /// from: public android.media.session.MediaController.PlaybackInfo getPlaybackInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the current playback info for this session.
  ///@return The current playback info or null.
  MediaController_PlaybackInfo getPlaybackInfo() =>
      MediaController_PlaybackInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPlaybackInfo, jni.JniType.objectType, []).object);

  static final _id_getSessionActivity = jniAccessors.getMethodIDOf(
      _classRef, "getSessionActivity", "()Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getSessionActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an intent for launching UI associated with this session if one
  /// exists.
  ///@return A PendingIntent to launch UI or null.
  pendingintent_.PendingIntent getSessionActivity() =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSessionActivity,
          jni.JniType.objectType, []).object);

  static final _id_getSessionToken = jniAccessors.getMethodIDOf(_classRef,
      "getSessionToken", "()Landroid/media/session/MediaSession\$Token;");

  /// from: public android.media.session.MediaSession.Token getSessionToken()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the token for the session this is connected to.
  ///@return The token for the connected session.
  ///
  /// This value will never be {@code null}.
  mediasession_.MediaSession_Token getSessionToken() =>
      mediasession_.MediaSession_Token.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSessionToken, jni.JniType.objectType, []).object);

  static final _id_setVolumeTo =
      jniAccessors.getMethodIDOf(_classRef, "setVolumeTo", "(II)V");

  /// from: public void setVolumeTo(int value, int flags)
  ///
  /// Set the volume of the output this session is playing on. The command will
  /// be ignored if it does not support
  /// VolumeProvider\#VOLUME_CONTROL_ABSOLUTE. The flags in
  /// AudioManager may be used to affect the handling.
  ///@see \#getPlaybackInfo()
  ///@param value The value to set it to, between 0 and the reported max.
  ///@param flags Flags from AudioManager to include with the volume
  ///            request.
  void setVolumeTo(int value, int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_setVolumeTo, jni.JniType.voidType, [value, flags]).check();

  static final _id_adjustVolume =
      jniAccessors.getMethodIDOf(_classRef, "adjustVolume", "(II)V");

  /// from: public void adjustVolume(int direction, int flags)
  ///
  /// Adjust the volume of the output this session is playing on. The direction
  /// must be one of AudioManager\#ADJUST_LOWER,
  /// AudioManager\#ADJUST_RAISE, or AudioManager\#ADJUST_SAME.
  /// The command will be ignored if the session does not support
  /// VolumeProvider\#VOLUME_CONTROL_RELATIVE or
  /// VolumeProvider\#VOLUME_CONTROL_ABSOLUTE. The flags in
  /// AudioManager may be used to affect the handling.
  ///@see \#getPlaybackInfo()
  ///@param direction The direction to adjust the volume in.
  ///@param flags Any flags to pass with the command.
  void adjustVolume(int direction, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_adjustVolume,
          jni.JniType.voidType, [direction, flags]).check();

  static final _id_registerCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerCallback",
      "(Landroid/media/session/MediaController\$Callback;)V");

  /// from: public void registerCallback(android.media.session.MediaController.Callback callback)
  ///
  /// Registers a callback to receive updates from the Session. Updates will be
  /// posted on the caller's thread.
  ///@param callback The callback object, must not be null.
  ///
  /// This value must never be {@code null}.
  void registerCallback(MediaController_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_registerCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerCallback",
      "(Landroid/media/session/MediaController\$Callback;Landroid/os/Handler;)V");

  /// from: public void registerCallback(android.media.session.MediaController.Callback callback, android.os.Handler handler)
  ///
  /// Registers a callback to receive updates from the session. Updates will be
  /// posted on the specified handler's thread.
  ///@param callback The callback object, must not be null.
  /// This value must never be {@code null}.
  ///@param handler The handler to post updates on. If null the callers thread
  ///            will be used.
  ///
  /// This value may be {@code null}.
  void registerCallback1(
          MediaController_Callback callback, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerCallback1,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterCallback",
      "(Landroid/media/session/MediaController\$Callback;)V");

  /// from: public void unregisterCallback(android.media.session.MediaController.Callback callback)
  ///
  /// Unregisters the specified callback. If an update has already been posted
  /// you may still receive it after calling this method.
  ///@param callback The callback to remove.
  ///
  /// This value must never be {@code null}.
  void unregisterCallback(MediaController_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_sendCommand = jniAccessors.getMethodIDOf(
      _classRef,
      "sendCommand",
      "(Ljava/lang/String;Landroid/os/Bundle;Landroid/os/ResultReceiver;)V");

  /// from: public void sendCommand(java.lang.String command, android.os.Bundle args, android.os.ResultReceiver cb)
  ///
  /// Sends a generic command to the session. It is up to the session creator
  /// to decide what commands and parameters they will support. As such,
  /// commands should only be sent to sessions that the controller owns.
  ///@param command The command to send
  /// This value must never be {@code null}.
  ///@param args Any parameters to include with the command
  /// This value may be {@code null}.
  ///@param cb The callback to receive the result on
  ///
  /// This value may be {@code null}.
  void sendCommand(jni.JniString command, bundle_.Bundle args,
          resultreceiver_.ResultReceiver cb) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendCommand,
          jni.JniType.voidType,
          [command.reference, args.reference, cb.reference]).check();

  static final _id_getPackageName = jniAccessors.getMethodIDOf(
      _classRef, "getPackageName", "()Ljava/lang/String;");

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the session owner's package name.
  ///@return The package name of of the session owner.
  jni.JniString getPackageName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPackageName, jni.JniType.objectType, []).object);
}

/// from: android.media.session.MediaController$TransportControls
///
/// Interface for controlling media playback on a session. This allows an app
/// to send media transport commands to the session.
class MediaController_TransportControls extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/session/MediaController\$TransportControls");
  MediaController_TransportControls.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaController_TransportControls()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_prepare =
      jniAccessors.getMethodIDOf(_classRef, "prepare", "()V");

  /// from: public void prepare()
  ///
  /// Request that the player prepare its playback. In other words, other sessions can continue
  /// to play during the preparation of this session. This method can be used to speed up the
  /// start of the playback. Once the preparation is done, the session will change its playback
  /// state to PlaybackState\#STATE_PAUSED. Afterwards, \#play can be called to
  /// start playback.
  void prepare() => jniAccessors.callMethodWithArgs(
      reference, _id_prepare, jni.JniType.voidType, []).check();

  static final _id_prepareFromMediaId = jniAccessors.getMethodIDOf(_classRef,
      "prepareFromMediaId", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void prepareFromMediaId(java.lang.String mediaId, android.os.Bundle extras)
  ///
  /// Request that the player prepare playback for a specific media id. In other words, other
  /// sessions can continue to play during the preparation of this session. This method can be
  /// used to speed up the start of the playback. Once the preparation is done, the session
  /// will change its playback state to PlaybackState\#STATE_PAUSED. Afterwards,
  /// \#play can be called to start playback. If the preparation is not needed,
  /// \#playFromMediaId can be directly called without this method.
  ///@param mediaId The id of the requested media.
  ///@param extras Optional extras that can include extra information about the media item
  ///               to be prepared.
  void prepareFromMediaId(jni.JniString mediaId, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_prepareFromMediaId,
          jni.JniType.voidType, [mediaId.reference, extras.reference]).check();

  static final _id_prepareFromSearch = jniAccessors.getMethodIDOf(_classRef,
      "prepareFromSearch", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void prepareFromSearch(java.lang.String query, android.os.Bundle extras)
  ///
  /// Request that the player prepare playback for a specific search query. An empty or null
  /// query should be treated as a request to prepare any music. In other words, other sessions
  /// can continue to play during the preparation of this session. This method can be used to
  /// speed up the start of the playback. Once the preparation is done, the session will
  /// change its playback state to PlaybackState\#STATE_PAUSED. Afterwards,
  /// \#play can be called to start playback. If the preparation is not needed,
  /// \#playFromSearch can be directly called without this method.
  ///@param query The search query.
  ///@param extras Optional extras that can include extra information
  ///               about the query.
  void prepareFromSearch(jni.JniString query, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_prepareFromSearch,
          jni.JniType.voidType, [query.reference, extras.reference]).check();

  static final _id_prepareFromUri = jniAccessors.getMethodIDOf(
      _classRef, "prepareFromUri", "(Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void prepareFromUri(android.net.Uri uri, android.os.Bundle extras)
  ///
  /// Request that the player prepare playback for a specific Uri. In other words,
  /// other sessions can continue to play during the preparation of this session. This method
  /// can be used to speed up the start of the playback. Once the preparation is done, the
  /// session will change its playback state to PlaybackState\#STATE_PAUSED. Afterwards,
  /// \#play can be called to start playback. If the preparation is not needed,
  /// \#playFromUri can be directly called without this method.
  ///@param uri The URI of the requested media.
  ///@param extras Optional extras that can include extra information about the media item
  ///               to be prepared.
  void prepareFromUri(uri_.Uri uri, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_prepareFromUri,
          jni.JniType.voidType, [uri.reference, extras.reference]).check();

  static final _id_play = jniAccessors.getMethodIDOf(_classRef, "play", "()V");

  /// from: public void play()
  ///
  /// Request that the player start its playback at its current position.
  void play() => jniAccessors.callMethodWithArgs(
      reference, _id_play, jni.JniType.voidType, []).check();

  static final _id_playFromMediaId = jniAccessors.getMethodIDOf(
      _classRef, "playFromMediaId", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void playFromMediaId(java.lang.String mediaId, android.os.Bundle extras)
  ///
  /// Request that the player start playback for a specific media id.
  ///@param mediaId The id of the requested media.
  ///@param extras Optional extras that can include extra information about the media item
  ///               to be played.
  void playFromMediaId(jni.JniString mediaId, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_playFromMediaId,
          jni.JniType.voidType, [mediaId.reference, extras.reference]).check();

  static final _id_playFromSearch = jniAccessors.getMethodIDOf(
      _classRef, "playFromSearch", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void playFromSearch(java.lang.String query, android.os.Bundle extras)
  ///
  /// Request that the player start playback for a specific search query.
  /// An empty or null query should be treated as a request to play any
  /// music.
  ///@param query The search query.
  ///@param extras Optional extras that can include extra information
  ///               about the query.
  void playFromSearch(jni.JniString query, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_playFromSearch,
          jni.JniType.voidType, [query.reference, extras.reference]).check();

  static final _id_playFromUri = jniAccessors.getMethodIDOf(
      _classRef, "playFromUri", "(Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void playFromUri(android.net.Uri uri, android.os.Bundle extras)
  ///
  /// Request that the player start playback for a specific Uri.
  ///@param uri The URI of the requested media.
  ///@param extras Optional extras that can include extra information about the media item
  ///               to be played.
  void playFromUri(uri_.Uri uri, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_playFromUri,
          jni.JniType.voidType, [uri.reference, extras.reference]).check();

  static final _id_skipToQueueItem =
      jniAccessors.getMethodIDOf(_classRef, "skipToQueueItem", "(J)V");

  /// from: public void skipToQueueItem(long id)
  ///
  /// Play an item with a specific id in the play queue. If you specify an
  /// id that is not in the play queue, the behavior is undefined.
  void skipToQueueItem(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_skipToQueueItem, jni.JniType.voidType, [id]).check();

  static final _id_pause =
      jniAccessors.getMethodIDOf(_classRef, "pause", "()V");

  /// from: public void pause()
  ///
  /// Request that the player pause its playback and stay at its current
  /// position.
  void pause() => jniAccessors.callMethodWithArgs(
      reference, _id_pause, jni.JniType.voidType, []).check();

  static final _id_stop = jniAccessors.getMethodIDOf(_classRef, "stop", "()V");

  /// from: public void stop()
  ///
  /// Request that the player stop its playback; it may clear its state in
  /// whatever way is appropriate.
  void stop() => jniAccessors.callMethodWithArgs(
      reference, _id_stop, jni.JniType.voidType, []).check();

  static final _id_seekTo =
      jniAccessors.getMethodIDOf(_classRef, "seekTo", "(J)V");

  /// from: public void seekTo(long pos)
  ///
  /// Move to a new location in the media stream.
  ///@param pos Position to move to, in milliseconds.
  void seekTo(int pos) => jniAccessors.callMethodWithArgs(
      reference, _id_seekTo, jni.JniType.voidType, [pos]).check();

  static final _id_fastForward =
      jniAccessors.getMethodIDOf(_classRef, "fastForward", "()V");

  /// from: public void fastForward()
  ///
  /// Start fast forwarding. If playback is already fast forwarding this
  /// may increase the rate.
  void fastForward() => jniAccessors.callMethodWithArgs(
      reference, _id_fastForward, jni.JniType.voidType, []).check();

  static final _id_skipToNext =
      jniAccessors.getMethodIDOf(_classRef, "skipToNext", "()V");

  /// from: public void skipToNext()
  ///
  /// Skip to the next item.
  void skipToNext() => jniAccessors.callMethodWithArgs(
      reference, _id_skipToNext, jni.JniType.voidType, []).check();

  static final _id_rewind =
      jniAccessors.getMethodIDOf(_classRef, "rewind", "()V");

  /// from: public void rewind()
  ///
  /// Start rewinding. If playback is already rewinding this may increase
  /// the rate.
  void rewind() => jniAccessors.callMethodWithArgs(
      reference, _id_rewind, jni.JniType.voidType, []).check();

  static final _id_skipToPrevious =
      jniAccessors.getMethodIDOf(_classRef, "skipToPrevious", "()V");

  /// from: public void skipToPrevious()
  ///
  /// Skip to the previous item.
  void skipToPrevious() => jniAccessors.callMethodWithArgs(
      reference, _id_skipToPrevious, jni.JniType.voidType, []).check();

  static final _id_setRating = jniAccessors.getMethodIDOf(
      _classRef, "setRating", "(Landroid/media/Rating;)V");

  /// from: public void setRating(android.media.Rating rating)
  ///
  /// Rate the current content. This will cause the rating to be set for
  /// the current user. The Rating type must match the type returned by
  /// \#getRatingType().
  ///@param rating The rating to set for the current content
  void setRating(rating_.Rating rating) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRating,
      jni.JniType.voidType,
      [rating.reference]).check();

  static final _id_sendCustomAction = jniAccessors.getMethodIDOf(
      _classRef,
      "sendCustomAction",
      "(Landroid/media/session/PlaybackState\$CustomAction;Landroid/os/Bundle;)V");

  /// from: public void sendCustomAction(android.media.session.PlaybackState.CustomAction customAction, android.os.Bundle args)
  ///
  /// Send a custom action back for the MediaSession to perform.
  ///@param customAction The action to perform.
  /// This value must never be {@code null}.
  ///@param args Optional arguments to supply to the MediaSession for this
  ///             custom action.
  ///
  /// This value may be {@code null}.
  void sendCustomAction(playbackstate_.PlaybackState_CustomAction customAction,
          bundle_.Bundle args) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendCustomAction,
          jni.JniType.voidType,
          [customAction.reference, args.reference]).check();

  static final _id_sendCustomAction1 = jniAccessors.getMethodIDOf(_classRef,
      "sendCustomAction", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void sendCustomAction(java.lang.String action, android.os.Bundle args)
  ///
  /// Send the id and args from a custom action back for the MediaSession to perform.
  ///@see \#sendCustomAction(PlaybackState.CustomAction action, Bundle args)
  ///@param action The action identifier of the PlaybackState.CustomAction as
  ///               specified by the MediaSession.
  /// This value must never be {@code null}.
  ///@param args Optional arguments to supply to the MediaSession for this
  ///             custom action.
  ///
  /// This value may be {@code null}.
  void sendCustomAction1(jni.JniString action, bundle_.Bundle args) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendCustomAction1,
          jni.JniType.voidType, [action.reference, args.reference]).check();
}

/// from: android.media.session.MediaController$PlaybackInfo
///
/// Holds information about the current playback and how audio is handled for
/// this session.
class MediaController_PlaybackInfo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/session/MediaController\$PlaybackInfo");
  MediaController_PlaybackInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int PLAYBACK_TYPE_LOCAL
  ///
  /// The session uses local playback.
  static const PLAYBACK_TYPE_LOCAL = 1;

  /// from: static public final int PLAYBACK_TYPE_REMOTE
  ///
  /// The session uses remote playback.
  static const PLAYBACK_TYPE_REMOTE = 2;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILandroid/media/AudioAttributes;III)V");

  /// from: void <init>(int type, android.media.AudioAttributes attrs, int control, int max, int current)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  MediaController_PlaybackInfo(int type, audioattributes_.AudioAttributes attrs,
      int control, int max, int current)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [type, attrs.reference, control, max, current]).object);

  static final _id_getPlaybackType =
      jniAccessors.getMethodIDOf(_classRef, "getPlaybackType", "()I");

  /// from: public int getPlaybackType()
  ///
  /// Get the type of playback which affects volume handling. One of:
  /// <ul>
  /// <li>\#PLAYBACK_TYPE_LOCAL</li>
  /// <li>\#PLAYBACK_TYPE_REMOTE</li>
  /// </ul>
  ///@return The type of playback this session is using.
  int getPlaybackType() => jniAccessors.callMethodWithArgs(
      reference, _id_getPlaybackType, jni.JniType.intType, []).integer;

  static final _id_getAudioAttributes = jniAccessors.getMethodIDOf(
      _classRef, "getAudioAttributes", "()Landroid/media/AudioAttributes;");

  /// from: public android.media.AudioAttributes getAudioAttributes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the audio attributes for this session. The attributes will affect
  /// volume handling for the session. When the volume type is
  /// PlaybackInfo\#PLAYBACK_TYPE_REMOTE these may be ignored by the
  /// remote volume handler.
  ///@return The attributes for this session.
  audioattributes_.AudioAttributes getAudioAttributes() =>
      audioattributes_.AudioAttributes.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAudioAttributes,
          jni.JniType.objectType, []).object);

  static final _id_getVolumeControl =
      jniAccessors.getMethodIDOf(_classRef, "getVolumeControl", "()I");

  /// from: public int getVolumeControl()
  ///
  /// Get the type of volume control that can be used. One of:
  /// <ul>
  /// <li>VolumeProvider\#VOLUME_CONTROL_ABSOLUTE</li>
  /// <li>VolumeProvider\#VOLUME_CONTROL_RELATIVE</li>
  /// <li>VolumeProvider\#VOLUME_CONTROL_FIXED</li>
  /// </ul>
  ///@return The type of volume control that may be used with this
  ///         session.
  int getVolumeControl() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolumeControl, jni.JniType.intType, []).integer;

  static final _id_getMaxVolume =
      jniAccessors.getMethodIDOf(_classRef, "getMaxVolume", "()I");

  /// from: public int getMaxVolume()
  ///
  /// Get the maximum volume that may be set for this session.
  ///@return The maximum allowed volume where this session is playing.
  int getMaxVolume() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxVolume, jni.JniType.intType, []).integer;

  static final _id_getCurrentVolume =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentVolume", "()I");

  /// from: public int getCurrentVolume()
  ///
  /// Get the current volume for this session.
  ///@return The current volume where this session is playing.
  int getCurrentVolume() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentVolume, jni.JniType.intType, []).integer;
}

/// from: android.media.session.MediaController$Callback
///
/// Callback for receiving updates from the session. A Callback can be
/// registered using \#registerCallback.
class MediaController_Callback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/session/MediaController\$Callback");
  MediaController_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaController_Callback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onSessionDestroyed =
      jniAccessors.getMethodIDOf(_classRef, "onSessionDestroyed", "()V");

  /// from: public void onSessionDestroyed()
  ///
  /// Override to handle the session being destroyed. The session is no
  /// longer valid after this call and calls to it will be ignored.
  void onSessionDestroyed() => jniAccessors.callMethodWithArgs(
      reference, _id_onSessionDestroyed, jni.JniType.voidType, []).check();

  static final _id_onSessionEvent = jniAccessors.getMethodIDOf(
      _classRef, "onSessionEvent", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onSessionEvent(java.lang.String event, android.os.Bundle extras)
  ///
  /// Override to handle custom events sent by the session owner without a
  /// specified interface. Controllers should only handle these for
  /// sessions they own.
  ///@param event The event from the session.
  /// This value must never be {@code null}.
  ///@param extras Optional parameters for the event, may be null.
  ///
  /// This value may be {@code null}.
  void onSessionEvent(jni.JniString event, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSessionEvent,
          jni.JniType.voidType, [event.reference, extras.reference]).check();

  static final _id_onPlaybackStateChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onPlaybackStateChanged",
      "(Landroid/media/session/PlaybackState;)V");

  /// from: public void onPlaybackStateChanged(android.media.session.PlaybackState state)
  ///
  /// Override to handle changes in playback state.
  ///@param state The new playback state of the session
  ///
  /// This value may be {@code null}.
  void onPlaybackStateChanged(playbackstate_.PlaybackState state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPlaybackStateChanged,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_onMetadataChanged = jniAccessors.getMethodIDOf(
      _classRef, "onMetadataChanged", "(Landroid/media/MediaMetadata;)V");

  /// from: public void onMetadataChanged(android.media.MediaMetadata metadata)
  ///
  /// Override to handle changes to the current metadata.
  ///@param metadata The current metadata for the session or null if none.
  /// This value may be {@code null}.
  ///@see MediaMetadata
  void onMetadataChanged(mediametadata_.MediaMetadata metadata) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMetadataChanged,
          jni.JniType.voidType, [metadata.reference]).check();

  static final _id_onQueueChanged = jniAccessors.getMethodIDOf(
      _classRef, "onQueueChanged", "(Ljava/util/List;)V");

  /// from: public void onQueueChanged(java.util.List<android.media.session.MediaSession.QueueItem> queue)
  ///
  /// Override to handle changes to items in the queue.
  ///@param queue A list of items in the current play queue. It should
  ///            include the currently playing item as well as previous and
  ///            upcoming items if applicable.
  /// This value may be {@code null}.
  ///@see MediaSession.QueueItem
  void onQueueChanged(jni.JniObject queue) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onQueueChanged,
      jni.JniType.voidType,
      [queue.reference]).check();

  static final _id_onQueueTitleChanged = jniAccessors.getMethodIDOf(
      _classRef, "onQueueTitleChanged", "(Ljava/lang/CharSequence;)V");

  /// from: public void onQueueTitleChanged(java.lang.CharSequence title)
  ///
  /// Override to handle changes to the queue title.
  ///@param title The title that should be displayed along with the play queue such as
  ///              "Now Playing". May be null if there is no such title.
  ///
  /// This value may be {@code null}.
  void onQueueTitleChanged(jni.JniObject title) =>
      jniAccessors.callMethodWithArgs(reference, _id_onQueueTitleChanged,
          jni.JniType.voidType, [title.reference]).check();

  static final _id_onExtrasChanged = jniAccessors.getMethodIDOf(
      _classRef, "onExtrasChanged", "(Landroid/os/Bundle;)V");

  /// from: public void onExtrasChanged(android.os.Bundle extras)
  ///
  /// Override to handle changes to the MediaSession extras.
  ///@param extras The extras that can include other information associated with the
  ///               MediaSession.
  ///
  /// This value may be {@code null}.
  void onExtrasChanged(bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_onExtrasChanged,
          jni.JniType.voidType, [extras.reference]).check();

  static final _id_onAudioInfoChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onAudioInfoChanged",
      "(Landroid/media/session/MediaController\$PlaybackInfo;)V");

  /// from: public void onAudioInfoChanged(android.media.session.MediaController.PlaybackInfo info)
  ///
  /// Override to handle changes to the audio info.
  ///@param info The current audio info for this session.
  void onAudioInfoChanged(MediaController_PlaybackInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAudioInfoChanged,
          jni.JniType.voidType, [info.reference]).check();
}
