// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "MediaDataSource.dart" as mediadatasource_;

import "../content/Context.dart" as context_;

import "../net/Uri.dart" as uri_;

import "../content/res/AssetFileDescriptor.dart" as assetfiledescriptor_;

import "MediaCas.dart" as mediacas_;

import "DrmInitData.dart" as drminitdata_;

import "MediaFormat.dart" as mediaformat_;

import "MediaCodec.dart" as mediacodec_;

import "../os/PersistableBundle.dart" as persistablebundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaExtractor
///
/// MediaExtractor facilitates extraction of demuxed, typically encoded,  media data
/// from a data source.
/// It is generally used like this:
/// <pre>
/// MediaExtractor extractor = new MediaExtractor();
/// extractor.setDataSource(...);
/// int numTracks = extractor.getTrackCount();
/// for (int i = 0; i &lt; numTracks; ++i) {
///   MediaFormat format = extractor.getTrackFormat(i);
///   String mime = format.getString(MediaFormat.KEY_MIME);
///   if (weAreInterestedInThisTrack) {
///     extractor.selectTrack(i);
///   }
/// }
/// ByteBuffer inputBuffer = ByteBuffer.allocate(...)
/// while (extractor.readSampleData(inputBuffer, ...) &gt;= 0) {
///   int trackIndex = extractor.getSampleTrackIndex();
///   long presentationTimeUs = extractor.getSampleTime();
///   ...
///   extractor.advance();
/// }
///
/// extractor.release();
/// extractor = null;
/// </pre>
///
/// This class requires the android.Manifest.permission\#INTERNET permission
/// when used with network-based content.
class MediaExtractor extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaExtractor");
  MediaExtractor.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SAMPLE_FLAG_ENCRYPTED
  ///
  /// The sample is (at least partially) encrypted, see also the documentation
  /// for android.media.MediaCodec\#queueSecureInputBuffer
  static const SAMPLE_FLAG_ENCRYPTED = 2;

  /// from: static public final int SAMPLE_FLAG_PARTIAL_FRAME
  ///
  /// This indicates that the buffer only contains part of a frame,
  /// and the decoder should batch the data until a buffer without
  /// this flag appears before decoding the frame.
  ///@see MediaCodec\#BUFFER_FLAG_PARTIAL_FRAME
  static const SAMPLE_FLAG_PARTIAL_FRAME = 4;

  /// from: static public final int SAMPLE_FLAG_SYNC
  ///
  /// The sample is a sync sample (or in MediaCodec's terminology
  /// it is a key frame.)
  ///@see MediaCodec\#BUFFER_FLAG_KEY_FRAME
  static const SAMPLE_FLAG_SYNC = 1;

  /// from: static public final int SEEK_TO_CLOSEST_SYNC
  ///
  /// If possible, seek to the sync sample closest to the specified time
  static const SEEK_TO_CLOSEST_SYNC = 2;

  /// from: static public final int SEEK_TO_NEXT_SYNC
  ///
  /// If possible, seek to a sync sample at or after the specified time
  static const SEEK_TO_NEXT_SYNC = 1;

  /// from: static public final int SEEK_TO_PREVIOUS_SYNC
  ///
  /// If possible, seek to a sync sample at or before the specified time
  static const SEEK_TO_PREVIOUS_SYNC = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaExtractor()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setDataSource = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Landroid/media/MediaDataSource;)V");

  /// from: public native void setDataSource(android.media.MediaDataSource dataSource)
  ///
  /// Sets the data source (MediaDataSource) to use.
  ///@param dataSource the MediaDataSource for the media you want to extract from
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if dataSource is invalid.
  void setDataSource(mediadatasource_.MediaDataSource dataSource) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource,
          jni.JniType.voidType, [dataSource.reference]).check();

  static final _id_setDataSource1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setDataSource",
      "(Landroid/content/Context;Landroid/net/Uri;Ljava/util/Map;)V");

  /// from: public void setDataSource(android.content.Context context, android.net.Uri uri, java.util.Map<java.lang.String,java.lang.String> headers)
  ///
  /// Sets the data source as a content Uri.
  ///@param context the Context to use when resolving the Uri
  /// This value must never be {@code null}.
  ///@param uri the Content URI of the data you want to extract from.
  ///
  /// When <code>uri</code> refers to a network file the
  /// android.Manifest.permission\#INTERNET permission is required.
  ///
  /// This value must never be {@code null}.
  ///@param headers the headers to be sent together with the request for the data.
  ///        This can be {@code null} if no specific headers are to be sent with the
  ///        request.
  ///
  /// This value may be {@code null}.
  void setDataSource1(
          context_.Context context, uri_.Uri uri, jni.JniObject headers) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDataSource1,
          jni.JniType.voidType,
          [context.reference, uri.reference, headers.reference]).check();

  static final _id_setDataSource2 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/lang/String;Ljava/util/Map;)V");

  /// from: public void setDataSource(java.lang.String path, java.util.Map<java.lang.String,java.lang.String> headers)
  ///
  /// Sets the data source (file-path or http URL) to use.
  ///@param path the path of the file, or the http URL
  ///
  /// When <code>path</code> refers to a network file the
  /// android.Manifest.permission\#INTERNET permission is required.
  ///
  /// This value must never be {@code null}.
  ///@param headers the headers associated with the http request for the stream you want to play.
  ///        This can be {@code null} if no specific headers are to be sent with the
  ///        request.
  ///
  /// This value may be {@code null}.
  void setDataSource2(jni.JniString path, jni.JniObject headers) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource2,
          jni.JniType.voidType, [path.reference, headers.reference]).check();

  static final _id_setDataSource3 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/lang/String;)V");

  /// from: public void setDataSource(java.lang.String path)
  ///
  /// Sets the data source (file-path or http URL) to use.
  ///@param path the path of the file, or the http URL of the stream
  ///
  /// When <code>path</code> refers to a local file, the file may actually be opened by a
  /// process other than the calling application.  This implies that the pathname
  /// should be an absolute path (as any other process runs with unspecified current working
  /// directory), and that the pathname should reference a world-readable file.
  /// As an alternative, the application could first open the file for reading,
  /// and then use the file descriptor form \#setDataSource(FileDescriptor).
  ///
  /// When <code>path</code> refers to a network file the
  /// android.Manifest.permission\#INTERNET permission is required.
  ///
  /// This value must never be {@code null}.
  void setDataSource3(jni.JniString path) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDataSource3,
      jni.JniType.voidType,
      [path.reference]).check();

  static final _id_setDataSource4 = jniAccessors.getMethodIDOf(_classRef,
      "setDataSource", "(Landroid/content/res/AssetFileDescriptor;)V");

  /// from: public void setDataSource(android.content.res.AssetFileDescriptor afd)
  ///
  /// Sets the data source (AssetFileDescriptor) to use. It is the caller's
  /// responsibility to close the file descriptor. It is safe to do so as soon
  /// as this call returns.
  ///@param afd the AssetFileDescriptor for the file you want to extract from.
  ///
  /// This value must never be {@code null}.
  void setDataSource4(assetfiledescriptor_.AssetFileDescriptor afd) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource4,
          jni.JniType.voidType, [afd.reference]).check();

  static final _id_setDataSource5 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/io/FileDescriptor;)V");

  /// from: public void setDataSource(java.io.FileDescriptor fd)
  ///
  /// Sets the data source (FileDescriptor) to use. It is the caller's responsibility
  /// to close the file descriptor. It is safe to do so as soon as this call returns.
  ///@param fd the FileDescriptor for the file you want to extract from.
  ///
  /// This value must never be {@code null}.
  void setDataSource5(jni.JniObject fd) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDataSource5,
      jni.JniType.voidType,
      [fd.reference]).check();

  static final _id_setDataSource6 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/io/FileDescriptor;JJ)V");

  /// from: public native void setDataSource(java.io.FileDescriptor fd, long offset, long length)
  ///
  /// Sets the data source (FileDescriptor) to use.  The FileDescriptor must be
  /// seekable (N.B. a LocalSocket is not seekable). It is the caller's responsibility
  /// to close the file descriptor. It is safe to do so as soon as this call returns.
  ///@param fd the FileDescriptor for the file you want to extract from.
  /// This value must never be {@code null}.
  ///@param offset the offset into the file where the data to be extracted starts, in bytes
  ///@param length the length in bytes of the data to be extracted
  void setDataSource6(jni.JniObject fd, int offset, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource6,
          jni.JniType.voidType, [fd.reference, offset, length]).check();

  static final _id_setMediaCas = jniAccessors.getMethodIDOf(
      _classRef, "setMediaCas", "(Landroid/media/MediaCas;)V");

  /// from: public void setMediaCas(android.media.MediaCas mediaCas)
  ///
  /// Sets the MediaCas instance to use. This should be called after a
  /// successful setDataSource() if at least one track reports mime type
  /// of android.media.MediaFormat\#MIMETYPE_AUDIO_SCRAMBLED
  /// or android.media.MediaFormat\#MIMETYPE_VIDEO_SCRAMBLED.
  /// Stream parsing will not proceed until a valid MediaCas object
  /// is provided.
  ///@param mediaCas the MediaCas object to use.
  ///
  /// This value must never be {@code null}.
  void setMediaCas(mediacas_.MediaCas mediaCas) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMediaCas,
          jni.JniType.voidType, [mediaCas.reference]).check();

  static final _id_getCasInfo = jniAccessors.getMethodIDOf(
      _classRef, "getCasInfo", "(I)Landroid/media/MediaExtractor\$CasInfo;");

  /// from: public android.media.MediaExtractor.CasInfo getCasInfo(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the information about the conditional access system used to scramble
  /// a track.
  ///@param index of the track.
  ///@return an CasInfo object describing the conditional access system.
  MediaExtractor_CasInfo getCasInfo(int index) =>
      MediaExtractor_CasInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCasInfo, jni.JniType.objectType, [index]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public native void release()
  ///
  /// Make sure you call this when you're done to free up any resources
  /// instead of relying on the garbage collector to do this for you at
  /// some point in the future.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_getTrackCount =
      jniAccessors.getMethodIDOf(_classRef, "getTrackCount", "()I");

  /// from: public native int getTrackCount()
  ///
  /// Count the number of tracks found in the data source.
  int getTrackCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getTrackCount, jni.JniType.intType, []).integer;

  static final _id_getDrmInitData = jniAccessors.getMethodIDOf(
      _classRef, "getDrmInitData", "()Landroid/media/DrmInitData;");

  /// from: public android.media.DrmInitData getDrmInitData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Extract DRM initialization data if it exists
  ///@return DRM initialization data in the content, or {@code null}
  /// if no recognizable DRM format is found;
  ///@see DrmInitData
  drminitdata_.DrmInitData getDrmInitData() =>
      drminitdata_.DrmInitData.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrmInitData, jni.JniType.objectType, []).object);

  static final _id_getAudioPresentations = jniAccessors.getMethodIDOf(
      _classRef, "getAudioPresentations", "(I)Ljava/util/List;");

  /// from: public java.util.List<android.media.AudioPresentation> getAudioPresentations(int trackIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of available audio presentations for the track.
  ///@param trackIndex index of the track.
  ///@return a list of available audio presentations for a given valid audio track index.
  /// The list will be empty if the source does not contain any audio presentations.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getAudioPresentations(int trackIndex) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAudioPresentations,
          jni.JniType.objectType,
          [trackIndex]).object);

  static final _id_getPsshInfo =
      jniAccessors.getMethodIDOf(_classRef, "getPsshInfo", "()Ljava/util/Map;");

  /// from: public java.util.Map<java.util.UUID,byte[]> getPsshInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the PSSH info if present.
  ///@return a map of uuid-to-bytes, with the uuid specifying
  /// the crypto scheme, and the bytes being the data specific to that scheme.
  /// This can be {@code null} if the source does not contain PSSH info.
  jni.JniObject getPsshInfo() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPsshInfo, jni.JniType.objectType, []).object);

  static final _id_getTrackFormat = jniAccessors.getMethodIDOf(
      _classRef, "getTrackFormat", "(I)Landroid/media/MediaFormat;");

  /// from: public android.media.MediaFormat getTrackFormat(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the track format at the specified index.
  ///
  /// More detail on the representation can be found at android.media.MediaCodec
  ///
  /// The following table summarizes support for format keys across android releases:
  ///
  /// <table style="width: 0%">
  ///  <thead>
  ///   <tr>
  ///    <th rowspan=2>OS Version(s)</th>
  ///    <td colspan=3>{@code MediaFormat} keys used for</th>
  ///   </tr><tr>
  ///    <th>All Tracks</th>
  ///    <th>Audio Tracks</th>
  ///    <th>Video Tracks</th>
  ///   </tr>
  ///  </thead>
  ///  <tbody>
  ///   <tr>
  ///    <td>android.os.Build.VERSION_CODES\#JELLY_BEAN</td>
  ///    <td rowspan=8>MediaFormat\#KEY_MIME,<br>
  ///        MediaFormat\#KEY_DURATION,<br>
  ///        MediaFormat\#KEY_MAX_INPUT_SIZE</td>
  ///    <td rowspan=5>MediaFormat\#KEY_SAMPLE_RATE,<br>
  ///        MediaFormat\#KEY_CHANNEL_COUNT,<br>
  ///        MediaFormat\#KEY_CHANNEL_MASK,<br>
  ///        gapless playback information<sup>.mp3, .mp4</sup>,<br>
  ///        MediaFormat\#KEY_IS_ADTS<sup>AAC if streaming</sup>,<br>
  ///        codec-specific data<sup>AAC, Vorbis</sup></td>
  ///    <td rowspan=2>MediaFormat\#KEY_WIDTH,<br>
  ///        MediaFormat\#KEY_HEIGHT,<br>
  ///        codec-specific data<sup>AVC, MPEG4</sup></td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1</td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2</td>
  ///    <td rowspan=3>as above, plus<br>
  ///        Pixel aspect ratio information<sup>AVC, *</sup></td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#KITKAT</td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#KITKAT_WATCH</td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#LOLLIPOP</td>
  ///    <td rowspan=2>as above, plus<br>
  ///        MediaFormat\#KEY_BIT_RATE<sup>AAC</sup>,<br>
  ///        codec-specific data<sup>Opus</sup></td>
  ///    <td rowspan=2>as above, plus<br>
  ///        MediaFormat\#KEY_ROTATION<sup>.mp4</sup>,<br>
  ///        MediaFormat\#KEY_BIT_RATE<sup>MPEG4</sup>,<br>
  ///        codec-specific data<sup>HEVC</sup></td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#LOLLIPOP_MR1</td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#M</td>
  ///    <td>as above, plus<br>
  ///        gapless playback information<sup>Opus</sup></td>
  ///    <td>as above, plus<br>
  ///        MediaFormat\#KEY_FRAME_RATE (integer)</td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#N</td>
  ///    <td>as above, plus<br>
  ///        MediaFormat\#KEY_TRACK_ID,<br>
  ///        <!-- {link MediaFormat\#KEY_MAX_BIT_RATE}<sup>\#, .mp4</sup>,<br> -->
  ///        MediaFormat\#KEY_BIT_RATE<sup>\#, .mp4</sup></td>
  ///    <td>as above, plus<br>
  ///        MediaFormat\#KEY_PCM_ENCODING,<br>
  ///        MediaFormat\#KEY_PROFILE<sup>AAC</sup></td>
  ///    <td>as above, plus<br>
  ///        MediaFormat\#KEY_HDR_STATIC_INFO<sup>\#, .webm</sup>,<br>
  ///        MediaFormat\#KEY_COLOR_STANDARD<sup>\#</sup>,<br>
  ///        MediaFormat\#KEY_COLOR_TRANSFER<sup>\#</sup>,<br>
  ///        MediaFormat\#KEY_COLOR_RANGE<sup>\#</sup>,<br>
  ///        MediaFormat\#KEY_PROFILE<sup>MPEG2, H.263, MPEG4, AVC, HEVC, VP9</sup>,<br>
  ///        MediaFormat\#KEY_LEVEL<sup>H.263, MPEG4, AVC, HEVC, VP9</sup>,<br>
  ///        codec-specific data<sup>VP9</sup></td>
  ///   </tr>
  ///   <tr>
  ///    <td colspan=4>
  ///     <p class=note><strong>Notes:</strong><br>
  ///      \#: container-specified value only.<br>
  ///      .mp4, .webm&hellip;: for listed containers<br>
  ///      MPEG4, AAC&hellip;: for listed codecs
  ///    </td>
  ///   </tr><tr>
  ///    <td colspan=4>
  ///     <p class=note>Note that that level information contained in the container many times
  ///     does not match the level of the actual bitstream. You may want to clear the level using
  ///     {@code MediaFormat.setString(KEY_LEVEL, null)} before using the track format to find a
  ///     decoder that can play back a particular track.
  ///    </td>
  ///   </tr><tr>
  ///    <td colspan=4>
  ///     <p class=note><strong>*Pixel (sample) aspect ratio</strong> is returned in the following
  ///     keys. The display width can be calculated for example as:
  ///     <p align=center>
  ///     display-width = display-height * crop-width / crop-height * sar-width / sar-height
  ///    </td>
  ///   </tr><tr>
  ///    <th>Format Key</th><th>Value Type</th><th colspan=2>Description</th>
  ///   </tr><tr>
  ///    <td>{@code "sar-width"}</td><td>Integer</td><td colspan=2>Pixel aspect ratio width</td>
  ///   </tr><tr>
  ///    <td>{@code "sar-height"}</td><td>Integer</td><td colspan=2>Pixel aspect ratio height</td>
  ///   </tr>
  ///  </tbody>
  /// </table>
  mediaformat_.MediaFormat getTrackFormat(int index) =>
      mediaformat_.MediaFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTrackFormat,
          jni.JniType.objectType,
          [index]).object);

  static final _id_selectTrack =
      jniAccessors.getMethodIDOf(_classRef, "selectTrack", "(I)V");

  /// from: public native void selectTrack(int index)
  ///
  /// Subsequent calls to \#readSampleData, \#getSampleTrackIndex and
  /// \#getSampleTime only retrieve information for the subset of tracks
  /// selected.
  /// Selecting the same track multiple times has no effect, the track is
  /// only selected once.
  void selectTrack(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_selectTrack, jni.JniType.voidType, [index]).check();

  static final _id_unselectTrack =
      jniAccessors.getMethodIDOf(_classRef, "unselectTrack", "(I)V");

  /// from: public native void unselectTrack(int index)
  ///
  /// Subsequent calls to \#readSampleData, \#getSampleTrackIndex and
  /// \#getSampleTime only retrieve information for the subset of tracks
  /// selected.
  void unselectTrack(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_unselectTrack, jni.JniType.voidType, [index]).check();

  static final _id_seekTo =
      jniAccessors.getMethodIDOf(_classRef, "seekTo", "(JI)V");

  /// from: public native void seekTo(long timeUs, int mode)
  ///
  /// All selected tracks seek near the requested time according to the
  /// specified mode.
  ///@param mode Value is android.media.MediaExtractor\#SEEK_TO_PREVIOUS_SYNC, android.media.MediaExtractor\#SEEK_TO_NEXT_SYNC, or android.media.MediaExtractor\#SEEK_TO_CLOSEST_SYNC
  void seekTo(int timeUs, int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_seekTo, jni.JniType.voidType, [timeUs, mode]).check();

  static final _id_advance =
      jniAccessors.getMethodIDOf(_classRef, "advance", "()Z");

  /// from: public native boolean advance()
  ///
  /// Advance to the next sample. Returns false if no more sample data
  /// is available (end of stream).
  ///
  /// When extracting a local file, the behaviors of \#advance and
  /// \#readSampleData are undefined in presence of concurrent
  /// writes to the same local file; more specifically, end of stream
  /// could be signalled earlier than expected.
  bool advance() => jniAccessors.callMethodWithArgs(
      reference, _id_advance, jni.JniType.booleanType, []).boolean;

  static final _id_readSampleData = jniAccessors.getMethodIDOf(
      _classRef, "readSampleData", "(Ljava/nio/ByteBuffer;I)I");

  /// from: public native int readSampleData(java.nio.ByteBuffer byteBuf, int offset)
  ///
  /// Retrieve the current encoded sample and store it in the byte buffer
  /// starting at the given offset.
  ///
  /// __Note:__As of API 21, on success the position and limit of
  /// {@code byteBuf} is updated to point to the data just read.
  ///@param byteBuf the destination byte buffer
  /// This value must never be {@code null}.
  ///@return the sample size (or -1 if no more samples are available).
  int readSampleData(jni.JniObject byteBuf, int offset) =>
      jniAccessors.callMethodWithArgs(reference, _id_readSampleData,
          jni.JniType.intType, [byteBuf.reference, offset]).integer;

  static final _id_getSampleTrackIndex =
      jniAccessors.getMethodIDOf(_classRef, "getSampleTrackIndex", "()I");

  /// from: public native int getSampleTrackIndex()
  ///
  /// Returns the track index the current sample originates from (or -1
  /// if no more samples are available)
  int getSampleTrackIndex() => jniAccessors.callMethodWithArgs(
      reference, _id_getSampleTrackIndex, jni.JniType.intType, []).integer;

  static final _id_getSampleTime =
      jniAccessors.getMethodIDOf(_classRef, "getSampleTime", "()J");

  /// from: public native long getSampleTime()
  ///
  /// Returns the current sample's presentation time in microseconds.
  /// or -1 if no more samples are available.
  int getSampleTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getSampleTime, jni.JniType.longType, []).long;

  static final _id_getSampleSize =
      jniAccessors.getMethodIDOf(_classRef, "getSampleSize", "()J");

  /// from: public native long getSampleSize()
  ///
  /// @return size of the current sample in bytes or -1 if no more
  /// samples are available.
  int getSampleSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getSampleSize, jni.JniType.longType, []).long;

  static final _id_getSampleFlags =
      jniAccessors.getMethodIDOf(_classRef, "getSampleFlags", "()I");

  /// from: public native int getSampleFlags()
  ///
  /// Returns the current sample's flags.
  ///@return Value is either <code>0</code> or a combination of android.media.MediaExtractor\#SAMPLE_FLAG_SYNC, android.media.MediaExtractor\#SAMPLE_FLAG_ENCRYPTED, and android.media.MediaExtractor\#SAMPLE_FLAG_PARTIAL_FRAME
  int getSampleFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getSampleFlags, jni.JniType.intType, []).integer;

  static final _id_getSampleCryptoInfo = jniAccessors.getMethodIDOf(_classRef,
      "getSampleCryptoInfo", "(Landroid/media/MediaCodec\$CryptoInfo;)Z");

  /// from: public native boolean getSampleCryptoInfo(android.media.MediaCodec.CryptoInfo info)
  ///
  /// If the sample flags indicate that the current sample is at least
  /// partially encrypted, this call returns relevant information about
  /// the structure of the sample data required for decryption.
  ///@param info The android.media.MediaCodec.CryptoInfo structure
  ///             to be filled in.
  /// This value must never be {@code null}.
  ///@return true iff the sample flags contain \#SAMPLE_FLAG_ENCRYPTED
  bool getSampleCryptoInfo(mediacodec_.MediaCodec_CryptoInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_getSampleCryptoInfo,
          jni.JniType.booleanType, [info.reference]).boolean;

  static final _id_getCachedDuration =
      jniAccessors.getMethodIDOf(_classRef, "getCachedDuration", "()J");

  /// from: public native long getCachedDuration()
  ///
  /// Returns an estimate of how much data is presently cached in memory
  /// expressed in microseconds. Returns -1 if that information is unavailable
  /// or not applicable (no cache).
  int getCachedDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getCachedDuration, jni.JniType.longType, []).long;

  static final _id_hasCacheReachedEndOfStream = jniAccessors.getMethodIDOf(
      _classRef, "hasCacheReachedEndOfStream", "()Z");

  /// from: public native boolean hasCacheReachedEndOfStream()
  ///
  /// Returns true iff we are caching data and the cache has reached the
  /// end of the data stream (for now, a future seek may of course restart
  /// the fetching of data).
  /// This API only returns a meaningful result if \#getCachedDuration
  /// indicates the presence of a cache, i.e. does NOT return -1.
  bool hasCacheReachedEndOfStream() => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasCacheReachedEndOfStream,
      jni.JniType.booleanType, []).boolean;

  static final _id_getMetrics = jniAccessors.getMethodIDOf(
      _classRef, "getMetrics", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getMetrics()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return Metrics data about the current media container.
  ///@return a PersistableBundle containing the set of attributes and values
  /// available for the media container being handled by this instance
  /// of MediaExtractor.
  /// The attributes are descibed in MetricsConstants.
  ///
  ///  Additional vendor-specific fields may also be present in
  ///  the return value.
  persistablebundle_.PersistableBundle getMetrics() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getMetrics, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaExtractor$MetricsConstants
class MediaExtractor_MetricsConstants extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaExtractor\$MetricsConstants");
  MediaExtractor_MetricsConstants.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String FORMAT
  ///
  /// Key to extract the container format
  /// from the MediaExtractor\#getMetrics return value.
  /// The value is a String.
  static const FORMAT = "android.media.mediaextractor.fmt";

  /// from: static public final java.lang.String MIME_TYPE
  ///
  /// Key to extract the container MIME type
  /// from the MediaExtractor\#getMetrics return value.
  /// The value is a String.
  static const MIME_TYPE = "android.media.mediaextractor.mime";

  /// from: static public final java.lang.String TRACKS
  ///
  /// Key to extract the number of tracks in the container
  /// from the MediaExtractor\#getMetrics return value.
  /// The value is an integer.
  static const TRACKS = "android.media.mediaextractor.ntrk";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaExtractor_MetricsConstants()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.media.MediaExtractor$CasInfo
///
/// Describes the conditional access system used to scramble a track.
class MediaExtractor_CasInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaExtractor\$CasInfo");
  MediaExtractor_CasInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILandroid/media/MediaCas\$Session;)V");

  /// from: void <init>(int systemId, android.media.MediaCas.Session session)
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaExtractor_CasInfo(int systemId, mediacas_.MediaCas_Session session)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [systemId, session.reference]).object);

  static final _id_getSystemId =
      jniAccessors.getMethodIDOf(_classRef, "getSystemId", "()I");

  /// from: public int getSystemId()
  ///
  /// Retrieves the system id of the conditional access system.
  ///@return CA system id of the CAS used to scramble the track.
  int getSystemId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSystemId, jni.JniType.intType, []).integer;

  static final _id_getSession = jniAccessors.getMethodIDOf(
      _classRef, "getSession", "()Landroid/media/MediaCas\$Session;");

  /// from: public android.media.MediaCas.Session getSession()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the MediaCas.Session associated with a track. The
  /// session is needed to initialize a descrambler in order to decode the
  /// scrambled track.
  ///
  ///@see MediaDescrambler\#setMediaCasSession
  ///@return a MediaCas.Session object associated with a track.
  mediacas_.MediaCas_Session getSession() =>
      mediacas_.MediaCas_Session.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSession, jni.JniType.objectType, []).object);
}
