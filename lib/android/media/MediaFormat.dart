// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaFormat
///
/// Encapsulates the information describing the format of media data,
/// be it audio or video.
///
/// The format of the media data is specified as string/value pairs.
///
/// Keys common to all audio/video formats, __all keys not marked optional are mandatory__:
///
/// <table>
/// <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>
/// <tr><td>\#KEY_MIME</td><td>String</td><td>The type of the format.</td></tr>
/// <tr><td>\#KEY_MAX_INPUT_SIZE</td><td>Integer</td><td>optional, maximum size of a buffer of input data</td></tr>
/// <tr><td>\#KEY_BIT_RATE</td><td>Integer</td><td>__encoder-only__, desired bitrate in bits/second</td></tr>
/// </table>
///
/// Video formats have the following keys:
/// <table>
/// <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>
/// <tr><td>\#KEY_WIDTH</td><td>Integer</td><td></td></tr>
/// <tr><td>\#KEY_HEIGHT</td><td>Integer</td><td></td></tr>
/// <tr><td>\#KEY_COLOR_FORMAT</td><td>Integer</td><td>set by the user
///         for encoders, readable in the output format of decoders__</td></tr>
/// <tr><td>\#KEY_FRAME_RATE</td><td>Integer or Float</td><td>required for __encoders__,
///         optional for __decoders__</td></tr>
/// <tr><td>\#KEY_CAPTURE_RATE</td><td>Integer</td><td></td></tr>
/// <tr><td>\#KEY_I_FRAME_INTERVAL</td><td>Integer (or Float)</td><td>__encoder-only__,
///         time-interval between key frames.
///         Float support added in android.os.Build.VERSION_CODES\#N_MR1</td></tr>
/// <tr><td>\#KEY_INTRA_REFRESH_PERIOD</td><td>Integer</td><td>__encoder-only__, optional</td></tr>
/// <tr><td>\#KEY_LATENCY</td><td>Integer</td><td>__encoder-only__, optional</td></tr>
/// <tr><td>\#KEY_MAX_WIDTH</td><td>Integer</td><td>__decoder-only__, optional, max-resolution width</td></tr>
/// <tr><td>\#KEY_MAX_HEIGHT</td><td>Integer</td><td>__decoder-only__, optional, max-resolution height</td></tr>
/// <tr><td>\#KEY_REPEAT_PREVIOUS_FRAME_AFTER</td><td>Long</td><td>__encoder in surface-mode
///         only__, optional</td></tr>
/// <tr><td>\#KEY_PUSH_BLANK_BUFFERS_ON_STOP</td><td>Integer(1)</td><td>__decoder rendering
///         to a surface only__, optional</td></tr>
/// <tr><td>\#KEY_TEMPORAL_LAYERING</td><td>String</td><td>__encoder only__, optional,
///         temporal-layering schema</td></tr>
/// </table>
/// Specify both \#KEY_MAX_WIDTH and \#KEY_MAX_HEIGHT to enable
/// adaptive playback (seamless resolution change) for a video decoder that
/// supports it (MediaCodecInfo.CodecCapabilities\#FEATURE_AdaptivePlayback).
/// The values are used as hints for the codec: they are the maximum expected
/// resolution to prepare for.  Depending on codec support, preparing for larger
/// maximum resolution may require more memory even if that resolution is never
/// reached.  These fields have no effect for codecs that do not support adaptive
/// playback.<br/><br/>
///
/// Audio formats have the following keys:
/// <table>
/// <tr><th>Name</th><th>Value Type</th><th>Description</th></tr>
/// <tr><td>\#KEY_CHANNEL_COUNT</td><td>Integer</td><td></td></tr>
/// <tr><td>\#KEY_SAMPLE_RATE</td><td>Integer</td><td></td></tr>
/// <tr><td>\#KEY_PCM_ENCODING</td><td>Integer</td><td>optional</td></tr>
/// <tr><td>\#KEY_IS_ADTS</td><td>Integer</td><td>optional, if _decoding_ AAC audio content, setting this key to 1 indicates that each audio frame is prefixed by the ADTS header.</td></tr>
/// <tr><td>\#KEY_AAC_PROFILE</td><td>Integer</td><td>__encoder-only__, optional, if content is AAC audio, specifies the desired profile.</td></tr>
/// <tr><td>\#KEY_AAC_SBR_MODE</td><td>Integer</td><td>__encoder-only__, optional, if content is AAC audio, specifies the desired SBR mode.</td></tr>
/// <tr><td>\#KEY_AAC_DRC_TARGET_REFERENCE_LEVEL</td><td>Integer</td><td>__decoder-only__, optional, if content is AAC audio, specifies the target reference level.</td></tr>
/// <tr><td>\#KEY_AAC_ENCODED_TARGET_LEVEL</td><td>Integer</td><td>__decoder-only__, optional, if content is AAC audio, specifies the target reference level used at encoder.</td></tr>
/// <tr><td>\#KEY_AAC_DRC_BOOST_FACTOR</td><td>Integer</td><td>__decoder-only__, optional, if content is AAC audio, specifies the DRC boost factor.</td></tr>
/// <tr><td>\#KEY_AAC_DRC_ATTENUATION_FACTOR</td><td>Integer</td><td>__decoder-only__, optional, if content is AAC audio, specifies the DRC attenuation factor.</td></tr>
/// <tr><td>\#KEY_AAC_DRC_HEAVY_COMPRESSION</td><td>Integer</td><td>__decoder-only__, optional, if content is AAC audio, specifies whether to use heavy compression.</td></tr>
/// <tr><td>\#KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT</td><td>Integer</td><td>__decoder-only__, optional, if content is AAC audio, specifies the maximum number of channels the decoder outputs.</td></tr>
/// <tr><td>\#KEY_AAC_DRC_EFFECT_TYPE</td><td>Integer</td><td>__decoder-only__, optional, if content is AAC audio, specifies the MPEG-D DRC effect type to use.</td></tr>
/// <tr><td>\#KEY_CHANNEL_MASK</td><td>Integer</td><td>optional, a mask of audio channel assignments</td></tr>
/// <tr><td>\#KEY_FLAC_COMPRESSION_LEVEL</td><td>Integer</td><td>__encoder-only__, optional, if content is FLAC audio, specifies the desired compression level.</td></tr>
/// </table>
///
/// Subtitle formats have the following keys:
/// <table>
/// <tr><td>\#KEY_MIME</td><td>String</td><td>The type of the format.</td></tr>
/// <tr><td>\#KEY_LANGUAGE</td><td>String</td><td>The language of the content.</td></tr>
/// </table>
///
/// Image formats have the following keys:
/// <table>
/// <tr><td>\#KEY_MIME</td><td>String</td><td>The type of the format.</td></tr>
/// <tr><td>\#KEY_WIDTH</td><td>Integer</td><td></td></tr>
/// <tr><td>\#KEY_HEIGHT</td><td>Integer</td><td></td></tr>
/// <tr><td>\#KEY_COLOR_FORMAT</td><td>Integer</td><td>set by the user
///         for encoders, readable in the output format of decoders__</td></tr>
/// <tr><td>\#KEY_TILE_WIDTH</td><td>Integer</td><td>required if the image has grid</td></tr>
/// <tr><td>\#KEY_TILE_HEIGHT</td><td>Integer</td><td>required if the image has grid</td></tr>
/// <tr><td>\#KEY_GRID_ROWS</td><td>Integer</td><td>required if the image has grid</td></tr>
/// <tr><td>\#KEY_GRID_COLUMNS</td><td>Integer</td><td>required if the image has grid</td></tr>
/// </table>
class MediaFormat extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/MediaFormat");
  MediaFormat.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int COLOR_RANGE_FULL
  ///
  /// Full range. Y, Cr and Cb component values range from 0 to 255 for 8-bit content.
  static const COLOR_RANGE_FULL = 1;

  /// from: static public final int COLOR_RANGE_LIMITED
  ///
  /// Limited range. Y component values range from 16 to 235 for 8-bit content.
  ///  Cr, Cy values range from 16 to 240 for 8-bit content.
  ///  This is the default for video content.
  static const COLOR_RANGE_LIMITED = 2;

  /// from: static public final int COLOR_STANDARD_BT2020
  ///
  /// BT.2020 color chromacity coordinates with KR = 0.2627, KB = 0.0593.
  static const COLOR_STANDARD_BT2020 = 6;

  /// from: static public final int COLOR_STANDARD_BT601_NTSC
  ///
  /// BT.601 525 color chromacity coordinates with KR = 0.299, KB = 0.114.
  static const COLOR_STANDARD_BT601_NTSC = 4;

  /// from: static public final int COLOR_STANDARD_BT601_PAL
  ///
  /// BT.601 625 color chromacity coordinates with KR = 0.299, KB = 0.114.
  static const COLOR_STANDARD_BT601_PAL = 2;

  /// from: static public final int COLOR_STANDARD_BT709
  ///
  /// BT.709 color chromacity coordinates with KR = 0.2126, KB = 0.0722.
  static const COLOR_STANDARD_BT709 = 1;

  /// from: static public final int COLOR_TRANSFER_HLG
  ///
  /// ARIB STD-B67 hybrid-log-gamma transfer function. This is used by some HDR video content.
  static const COLOR_TRANSFER_HLG = 7;

  /// from: static public final int COLOR_TRANSFER_LINEAR
  ///
  /// Linear transfer characteristic curve.
  static const COLOR_TRANSFER_LINEAR = 1;

  /// from: static public final int COLOR_TRANSFER_SDR_VIDEO
  ///
  /// SMPTE 170M transfer characteristic curve used by BT.601/BT.709/BT.2020. This is the curve
  ///  used by most non-HDR video content.
  static const COLOR_TRANSFER_SDR_VIDEO = 3;

  /// from: static public final int COLOR_TRANSFER_ST2084
  ///
  /// SMPTE ST 2084 transfer function. This is used by some HDR video content.
  static const COLOR_TRANSFER_ST2084 = 6;

  /// from: static public final java.lang.String KEY_AAC_DRC_ATTENUATION_FACTOR
  ///
  /// A key describing the attenuation factor allowing to adapt the dynamics of the output to the
  /// actual listening requirements.
  /// See \#KEY_AAC_DRC_BOOST_FACTOR for a description of the role of this attenuation
  /// factor and the value range.
  /// The default value is 127 (fully apply attenuation DRC gains).
  /// This key is only used during decoding.
  static const KEY_AAC_DRC_ATTENUATION_FACTOR = "aac-drc-cut-level";

  /// from: static public final java.lang.String KEY_AAC_DRC_BOOST_FACTOR
  ///
  /// A key describing the boost factor allowing to adapt the dynamics of the output to the
  /// actual listening requirements. This relies on DRC gain sequences that can be transmitted in
  /// the encoded bitstream to be able to reduce the dynamics of the output signal upon request.
  /// This factor enables the user to select how much of the gains are applied.
  /// Positive gains (boost) and negative gains (attenuation, see
  /// \#KEY_AAC_DRC_ATTENUATION_FACTOR) can be controlled separately for a better match
  /// to different use-cases.
  /// Typically, attenuation gains are sent for loud signal segments, and boost gains are sent
  /// for soft signal segments. If the output is listened to in a noisy environment, for example,
  /// the boost factor is used to enable the positive gains, i.e. to amplify soft signal segments
  /// beyond the noise floor. But for listening late at night, the attenuation
  /// factor is used to enable the negative gains, to prevent loud signal from surprising
  /// the listener. In applications which generally need a low dynamic range, both the boost factor
  /// and the attenuation factor are used in order to enable all DRC gains.
  /// In order to prevent clipping, it is also recommended to apply the attenuation gains
  /// in case of a downmix and/or loudness normalization to high target reference levels.
  /// Both the boost and the attenuation factor parameters are given as integer values
  /// between 0 and 127, representing the range of the factor of 0 (i.e. don't apply)
  /// to 1 (i.e. fully apply boost/attenuation gains respectively).
  /// The default value is 127 (fully apply boost DRC gains).
  /// This key is only used during decoding.
  static const KEY_AAC_DRC_BOOST_FACTOR = "aac-drc-boost-level";

  /// from: static public final java.lang.String KEY_AAC_DRC_EFFECT_TYPE
  ///
  /// A key describing for selecting the DRC effect type for MPEG-D DRC.
  /// The supported values are defined in ISO/IEC 23003-4:2015 and are described as follows:
  /// <table>
  /// <tr><th>Value</th><th>Effect</th></tr>
  /// <tr><th>-1</th><th>Off</th></tr>
  /// <tr><th>0</th><th>None</th></tr>
  /// <tr><th>1</th><th>Late night</th></tr>
  /// <tr><th>2</th><th>Noisy environment</th></tr>
  /// <tr><th>3</th><th>Limited playback range</th></tr>
  /// <tr><th>4</th><th>Low playback level</th></tr>
  /// <tr><th>5</th><th>Dialog enhancement</th></tr>
  /// <tr><th>6</th><th>General compression</th></tr>
  /// </table>
  /// The value -1 (Off) disables DRC processing, while loudness normalization may still be
  /// active and dependent on KEY_AAC_DRC_TARGET_REFERENCE_LEVEL.<br>
  /// The value 0 (None) automatically enables DRC processing if necessary to prevent signal
  /// clipping<br>
  /// The value 6 (General compression) can be used for enabling MPEG-D DRC without particular
  /// DRC effect type request.<br>
  /// The default DRC effect type is 3 ("Limited playback range") on mobile devices.
  /// This key is only used during decoding.
  static const KEY_AAC_DRC_EFFECT_TYPE = "aac-drc-effect-type";

  /// from: static public final java.lang.String KEY_AAC_DRC_HEAVY_COMPRESSION
  ///
  /// A key describing the selection of the heavy compression profile for DRC.
  /// Two separate DRC gain sequences can be transmitted in one bitstream: MPEG-4 DRC light
  /// compression, and DVB-specific heavy compression. When selecting the application of the heavy
  /// compression, one of the sequences is selected:
  /// <ul>
  /// <li>0 enables light compression,</li>
  /// <li>1 enables heavy compression instead.
  /// </ul>
  /// Note that only light compression offers the features of scaling of DRC gains
  /// (see \#KEY_AAC_DRC_BOOST_FACTOR and \#KEY_AAC_DRC_ATTENUATION_FACTOR for the
  /// boost and attenuation factors, and frequency-selective (multiband) DRC.
  /// Light compression usually contains clipping prevention for stereo downmixing while heavy
  /// compression, if additionally provided in the bitstream, is usually stronger, and contains
  /// clipping prevention for stereo and mono downmixing.
  /// The default is 1 (heavy compression).
  /// This key is only used during decoding.
  static const KEY_AAC_DRC_HEAVY_COMPRESSION = "aac-drc-heavy-compression";

  /// from: static public final java.lang.String KEY_AAC_DRC_TARGET_REFERENCE_LEVEL
  ///
  /// A key describing a gain to be applied so that the output loudness matches the
  /// Target Reference Level. This is typically used to normalize loudness across program items.
  /// The gain is derived as the difference between the Target Reference Level and the
  /// Program Reference Level. The latter can be given in the bitstream and indicates the actual
  /// loudness value of the program item.
  /// The Target Reference Level controls loudness normalization for both MPEG-4 DRC and
  /// MPEG-D DRC.
  /// The value is given as an integer value between
  /// 40 and 127, and is calculated as -4 * Target Reference Level in LKFS.
  /// Therefore, it represents the range of -10 to -31.75 LKFS.
  /// The default value on mobile devices is 64 (-16 LKFS).
  /// This key is only used during decoding.
  static const KEY_AAC_DRC_TARGET_REFERENCE_LEVEL = "aac-target-ref-level";

  /// from: static public final java.lang.String KEY_AAC_ENCODED_TARGET_LEVEL
  ///
  /// A key describing the target reference level that was assumed at the encoder for
  /// calculation of attenuation gains for clipping prevention.
  /// If it is known, this information can be provided as an integer value between
  /// 0 and 127, which is calculated as -4 * Encoded Target Level in LKFS.
  /// If the Encoded Target Level is unknown, the value can be set to -1.
  /// The default value is -1 (unknown).
  /// The value is ignored when heavy compression is used (see
  /// \#KEY_AAC_DRC_HEAVY_COMPRESSION).
  /// This key is only used during decoding.
  static const KEY_AAC_ENCODED_TARGET_LEVEL = "aac-encoded-target-level";

  /// from: static public final java.lang.String KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT
  ///
  /// A key describing the maximum number of channels that can be output by the AAC decoder.
  /// By default, the decoder will output the same number of channels as present in the encoded
  /// stream, if supported. Set this value to limit the number of output channels, and use
  /// the downmix information in the stream, if available.
  /// Values larger than the number of channels in the content to decode are ignored.
  /// This key is only used during decoding.
  static const KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT =
      "aac-max-output-channel_count";

  /// from: static public final java.lang.String KEY_AAC_PROFILE
  ///
  /// A key describing the AAC profile to be used (AAC audio formats only).
  /// Constants are declared in android.media.MediaCodecInfo.CodecProfileLevel.
  static const KEY_AAC_PROFILE = "aac-profile";

  /// from: static public final java.lang.String KEY_AAC_SBR_MODE
  ///
  /// A key describing the AAC SBR mode to be used (AAC audio formats only).
  /// The associated value is an integer and can be set to following values:
  /// <ul>
  /// <li>0 - no SBR should be applied</li>
  /// <li>1 - single rate SBR</li>
  /// <li>2 - double rate SBR</li>
  /// </ul>
  /// Note: If this key is not defined the default SRB mode for the desired AAC profile will
  /// be used.
  /// This key is only used during encoding.
  static const KEY_AAC_SBR_MODE = "aac-sbr-mode";

  /// from: static public final java.lang.String KEY_AUDIO_SESSION_ID
  ///
  /// A key describing the audio session ID of the AudioTrack associated
  /// to a tunneled video codec.
  /// The associated value is an integer.
  ///@see MediaCodecInfo.CodecCapabilities\#FEATURE_TunneledPlayback
  static const KEY_AUDIO_SESSION_ID = "audio-session-id";

  /// from: static public final java.lang.String KEY_BITRATE_MODE
  ///
  /// A key describing the desired bitrate mode to be used by an encoder.
  /// Constants are declared in MediaCodecInfo.CodecCapabilities.
  ///@see MediaCodecInfo.EncoderCapabilities\#isBitrateModeSupported(int)
  static const KEY_BITRATE_MODE = "bitrate-mode";

  /// from: static public final java.lang.String KEY_BIT_RATE
  ///
  /// A key describing the average bitrate in bits/sec.
  /// The associated value is an integer
  static const KEY_BIT_RATE = "bitrate";

  /// from: static public final java.lang.String KEY_CAPTURE_RATE
  ///
  /// A key describing the capture rate of a video format in frames/sec.
  ///
  /// When capture rate is different than the frame rate, it means that the
  /// video is acquired at a different rate than the playback, which produces
  /// slow motion or timelapse effect during playback. Application can use the
  /// value of this key to tell the relative speed ratio between capture and
  /// playback rates when the video was recorded.
  ///
  ///
  ///
  /// The associated value is an integer or a float.
  ///
  ///
  static const KEY_CAPTURE_RATE = "capture-rate";

  /// from: static public final java.lang.String KEY_CHANNEL_COUNT
  ///
  /// A key describing the number of channels in an audio format.
  /// The associated value is an integer
  static const KEY_CHANNEL_COUNT = "channel-count";

  /// from: static public final java.lang.String KEY_CHANNEL_MASK
  ///
  /// A key describing the channel composition of audio content. This mask
  /// is composed of bits drawn from channel mask definitions in android.media.AudioFormat.
  /// The associated value is an integer.
  static const KEY_CHANNEL_MASK = "channel-mask";

  /// from: static public final java.lang.String KEY_COLOR_FORMAT
  ///
  /// A key describing the color format of the content in a video format.
  /// Constants are declared in android.media.MediaCodecInfo.CodecCapabilities.
  static const KEY_COLOR_FORMAT = "color-format";

  /// from: static public final java.lang.String KEY_COLOR_RANGE
  ///
  /// An optional key describing the range of the component values of the video content.
  ///
  /// The associated value is an integer: 0 if unspecified, or one of the
  /// COLOR_RANGE_ values.
  static const KEY_COLOR_RANGE = "color-range";

  /// from: static public final java.lang.String KEY_COLOR_STANDARD
  ///
  /// An optional key describing the color primaries, white point and
  /// luminance factors for video content.
  ///
  /// The associated value is an integer: 0 if unspecified, or one of the
  /// COLOR_STANDARD_ values.
  static const KEY_COLOR_STANDARD = "color-standard";

  /// from: static public final java.lang.String KEY_COLOR_TRANSFER
  ///
  /// An optional key describing the opto-electronic transfer function used
  /// for the video content.
  ///
  /// The associated value is an integer: 0 if unspecified, or one of the
  /// COLOR_TRANSFER_ values.
  static const KEY_COLOR_TRANSFER = "color-transfer";

  /// from: static public final java.lang.String KEY_COMPLEXITY
  ///
  /// A key describing the encoding complexity.
  /// The associated value is an integer.  These values are device and codec specific,
  /// but lower values generally result in faster and/or less power-hungry encoding.
  ///@see MediaCodecInfo.EncoderCapabilities\#getComplexityRange()
  static const KEY_COMPLEXITY = "complexity";

  /// from: static public final java.lang.String KEY_DURATION
  ///
  /// A key describing the duration (in microseconds) of the content.
  /// The associated value is a long.
  static const KEY_DURATION = "durationUs";

  /// from: static public final java.lang.String KEY_FLAC_COMPRESSION_LEVEL
  ///
  /// A key describing the FLAC compression level to be used (FLAC audio format only).
  /// The associated value is an integer ranging from 0 (fastest, least compression)
  /// to 8 (slowest, most compression).
  static const KEY_FLAC_COMPRESSION_LEVEL = "flac-compression-level";

  /// from: static public final java.lang.String KEY_FRAME_RATE
  ///
  /// A key describing the frame rate of a video format in frames/sec.
  /// The associated value is normally an integer when the value is used by the platform,
  /// but video codecs also accept float configuration values.
  /// Specifically, MediaExtractor\#getTrackFormat MediaExtractor provides an integer
  /// value corresponding to the frame rate information of the track if specified and non-zero.
  /// Otherwise, this key is not present. MediaCodec\#configure MediaCodec accepts both
  /// float and integer values. This represents the desired operating frame rate if the
  /// \#KEY_OPERATING_RATE is not present and \#KEY_PRIORITY is {@code 0}
  /// (realtime). For video encoders this value corresponds to the intended frame rate,
  /// although encoders are expected
  /// to support variable frame rate based on MediaCodec.BufferInfo\#presentationTimeUs buffer timestamp. This key is not used in the {@code MediaCodec}
  /// MediaCodec\#getInputFormat input/MediaCodec\#getOutputFormat output formats,
  /// nor by MediaMuxer\#addTrack MediaMuxer.
  static const KEY_FRAME_RATE = "frame-rate";

  /// from: static public final java.lang.String KEY_GRID_COLUMNS
  ///
  /// A key describing the number of grid columns in the content in a
  /// \#MIMETYPE_IMAGE_ANDROID_HEIC track. The associated value is an integer.
  ///
  /// Refer to \#MIMETYPE_IMAGE_ANDROID_HEIC on decoding instructions of such tracks.
  ///@see \#KEY_TILE_WIDTH
  ///@see \#KEY_TILE_HEIGHT
  ///@see \#KEY_GRID_ROWS
  static const KEY_GRID_COLUMNS = "grid-cols";

  /// from: static public final java.lang.String KEY_GRID_ROWS
  ///
  /// A key describing the number of grid rows in the content in a
  /// \#MIMETYPE_IMAGE_ANDROID_HEIC track. The associated value is an integer.
  ///
  /// Refer to \#MIMETYPE_IMAGE_ANDROID_HEIC on decoding instructions of such tracks.
  ///@see \#KEY_TILE_WIDTH
  ///@see \#KEY_TILE_HEIGHT
  ///@see \#KEY_GRID_COLUMNS
  static const KEY_GRID_ROWS = "grid-rows";

  /// from: static public final java.lang.String KEY_HDR_STATIC_INFO
  ///
  /// An optional key describing the static metadata of HDR (high-dynamic-range) video content.
  ///
  /// The associated value is a ByteBuffer. This buffer contains the raw contents of the
  /// Static Metadata Descriptor (including the descriptor ID) of an HDMI Dynamic Range and
  /// Mastering InfoFrame as defined by CTA-861.3. This key must be provided to video decoders
  /// for HDR video content unless this information is contained in the bitstream and the video
  /// decoder supports an HDR-capable profile. This key must be provided to video encoders for
  /// HDR video content.
  static const KEY_HDR_STATIC_INFO = "hdr-static-info";

  /// from: static public final java.lang.String KEY_HEIGHT
  ///
  /// A key describing the height of the content in a video format.
  /// The associated value is an integer
  static const KEY_HEIGHT = "height";

  /// from: static public final java.lang.String KEY_INTRA_REFRESH_PERIOD
  ///
  /// An optional key describing the period of intra refresh in frames. This is an
  /// optional parameter that applies only to video encoders. If encoder supports it
  /// (MediaCodecInfo.CodecCapabilities\#FEATURE_IntraRefresh), the whole
  /// frame is completely refreshed after the specified period. Also for each frame,
  /// a fix subset of macroblocks must be intra coded which leads to more constant bitrate
  /// than inserting a key frame. This key is recommended for video streaming applications
  /// as it provides low-delay and good error-resilience. This key is ignored if the
  /// video encoder does not support the intra refresh feature. Use the output format to
  /// verify that this feature was enabled.
  /// The associated value is an integer.
  static const KEY_INTRA_REFRESH_PERIOD = "intra-refresh-period";

  /// from: static public final java.lang.String KEY_IS_ADTS
  ///
  /// A key mapping to a value of 1 if the content is AAC audio and
  /// audio frames are prefixed with an ADTS header.
  /// The associated value is an integer (0 or 1).
  /// This key is only supported when _decoding_ content, it cannot
  /// be used to configure an encoder to emit ADTS output.
  static const KEY_IS_ADTS = "is-adts";

  /// from: static public final java.lang.String KEY_IS_AUTOSELECT
  ///
  /// A key for boolean AUTOSELECT behavior for the track. Tracks with AUTOSELECT=true
  /// are considered when automatically selecting a track without specific user
  /// choice, based on the current locale.
  /// This is currently only used for subtitle tracks, when the user selected
  /// 'Default' for the captioning locale.
  /// The associated value is an integer, where non-0 means TRUE.  This is an optional
  /// field; if not specified, AUTOSELECT defaults to TRUE.
  static const KEY_IS_AUTOSELECT = "is-autoselect";

  /// from: static public final java.lang.String KEY_IS_DEFAULT
  ///
  /// A key for boolean DEFAULT behavior for the track. The track with DEFAULT=true is
  /// selected in the absence of a specific user choice.
  /// This is currently used in two scenarios:
  /// 1) for subtitle tracks, when the user selected 'Default' for the captioning locale.
  /// 2) for a \#MIMETYPE_IMAGE_ANDROID_HEIC track, indicating the image is the
  /// primary item in the file.
  ///
  /// The associated value is an integer, where non-0 means TRUE.  This is an optional
  /// field; if not specified, DEFAULT is considered to be FALSE.
  static const KEY_IS_DEFAULT = "is-default";

  /// from: static public final java.lang.String KEY_IS_FORCED_SUBTITLE
  ///
  /// A key for the FORCED field for subtitle tracks. True if it is a
  /// forced subtitle track.  Forced subtitle tracks are essential for the
  /// content and are shown even when the user turns off Captions.  They
  /// are used for example to translate foreign/alien dialogs or signs.
  /// The associated value is an integer, where non-0 means TRUE.  This is an
  /// optional field; if not specified, FORCED defaults to FALSE.
  static const KEY_IS_FORCED_SUBTITLE = "is-forced-subtitle";

  /// from: static public final java.lang.String KEY_I_FRAME_INTERVAL
  ///
  /// A key describing the frequency of key frames expressed in seconds between key frames.
  ///
  /// This key is used by video encoders.
  /// A negative value means no key frames are requested after the first frame.
  /// A zero value means a stream containing all key frames is requested.
  /// <p class=note>
  /// Most video encoders will convert this value of the number of non-key-frames between
  /// key-frames, using the {@linkplain \#KEY_FRAME_RATE frame rate} information; therefore,
  /// if the actual frame rate differs (e.g. input frames are dropped or the frame rate
  /// changes), the <strong>time interval</strong> between key frames will not be the
  /// configured value.
  ///
  /// The associated value is an integer (or float since
  /// android.os.Build.VERSION_CODES\#N_MR1).
  static const KEY_I_FRAME_INTERVAL = "i-frame-interval";

  /// from: static public final java.lang.String KEY_LANGUAGE
  ///
  /// A key describing the language of the content, using either ISO 639-1
  /// or 639-2/T codes.  The associated value is a string.
  static const KEY_LANGUAGE = "language";

  /// from: static public final java.lang.String KEY_LATENCY
  ///
  /// An optional key describing the desired encoder latency in frames. This is an optional
  /// parameter that applies only to video encoders. If encoder supports it, it should ouput
  /// at least one output frame after being queued the specified number of frames. This key
  /// is ignored if the video encoder does not support the latency feature. Use the output
  /// format to verify that this feature was enabled and the actual value used by the encoder.
  ///
  /// If the key is not specified, the default latency will be implenmentation specific.
  /// The associated value is an integer.
  static const KEY_LATENCY = "latency";

  /// from: static public final java.lang.String KEY_LEVEL
  ///
  /// A key describing the desired profile to be used by an encoder.
  /// The associated value is an integer.
  /// Constants are declared in MediaCodecInfo.CodecProfileLevel.
  /// This key is used as a further hint when specifying a desired profile,
  /// and is only supported for codecs that specify a level.
  ///
  /// This key is ignored if the \#KEY_PROFILE profile is not specified.
  ///@see MediaCodecInfo.CodecCapabilities\#profileLevels
  static const KEY_LEVEL = "level";

  /// from: static public final java.lang.String KEY_MAX_HEIGHT
  ///
  /// A key describing the maximum expected height of the content in a video
  /// decoder format, in case there are resolution changes in the video content.
  /// The associated value is an integer
  static const KEY_MAX_HEIGHT = "max-height";

  /// from: static public final java.lang.String KEY_MAX_INPUT_SIZE
  ///
  /// A key describing the maximum size in bytes of a buffer of data
  /// described by this MediaFormat.
  /// The associated value is an integer
  static const KEY_MAX_INPUT_SIZE = "max-input-size";

  /// from: static public final java.lang.String KEY_MAX_WIDTH
  ///
  /// A key describing the maximum expected width of the content in a video
  /// decoder format, in case there are resolution changes in the video content.
  /// The associated value is an integer
  static const KEY_MAX_WIDTH = "max-width";

  /// from: static public final java.lang.String KEY_MIME
  ///
  /// A key describing the mime type of the MediaFormat.
  /// The associated value is a string.
  static const KEY_MIME = "mime";

  /// from: static public final java.lang.String KEY_OPERATING_RATE
  ///
  /// A key describing the desired operating frame rate for video or sample rate for audio
  /// that the codec will need to operate at.
  ///
  /// The associated value is an integer or a float representing frames-per-second or
  /// samples-per-second
  ///
  /// This is used for cases like high-speed/slow-motion video capture, where the video encoder
  /// format contains the target playback rate (e.g. 30fps), but the component must be able to
  /// handle the high operating capture rate (e.g. 240fps).
  ///
  /// This rate will be used by codec for resource planning and setting the operating points.
  static const KEY_OPERATING_RATE = "operating-rate";

  /// from: static public final java.lang.String KEY_OUTPUT_REORDER_DEPTH
  ///
  /// An optional key describing the maximum number of non-display-order coded frames.
  /// This is an optional parameter that applies only to video encoders. Application should
  /// check the value for this key in the output format to see if codec will produce
  /// non-display-order coded frames. If encoder supports it, the output frames' order will be
  /// different from the display order and each frame's display order could be retrived from
  /// MediaCodec.BufferInfo\#presentationTimeUs. Before API level 27, application may
  /// receive non-display-order coded frames even though the application did not request it.
  /// Note: Application should not rearrange the frames to display order before feeding them
  /// to MediaMuxer\#writeSampleData.
  ///
  /// The default value is 0.
  static const KEY_OUTPUT_REORDER_DEPTH = "output-reorder-depth";

  /// from: static public final java.lang.String KEY_PCM_ENCODING
  ///
  /// A key describing the raw audio sample encoding/format.
  ///
  /// The associated value is an integer, using one of the
  /// AudioFormat.ENCODING_PCM_ values.
  ///
  ///
  /// This is an optional key for audio decoders and encoders specifying the
  /// desired raw audio sample format during MediaCodec\#configure MediaCodec.configure(&hellip;) call. Use MediaCodec\#getInputFormat MediaCodec.getInput/MediaCodec\#getOutputFormat OutputFormat(&hellip;)
  /// to confirm the actual format. For the PCM decoder this key specifies both
  /// input and output sample encodings.
  ///
  ///
  /// This key is also used by MediaExtractor to specify the sample
  /// format of audio data, if it is specified.
  ///
  ///
  /// If this key is missing, the raw audio sample format is signed 16-bit short.
  ///
  static const KEY_PCM_ENCODING = "pcm-encoding";

  /// from: static public final java.lang.String KEY_PRIORITY
  ///
  /// A key describing the desired codec priority.
  ///
  /// The associated value is an integer. Higher value means lower priority.
  ///
  /// Currently, only two levels are supported:<br>
  /// 0: realtime priority - meaning that the codec shall support the given
  ///    performance configuration (e.g. framerate) at realtime. This should
  ///    only be used by media playback, capture, and possibly by realtime
  ///    communication scenarios if best effort performance is not suitable.<br>
  /// 1: non-realtime priority (best effort).
  ///
  /// This is a hint used at codec configuration and resource planning - to understand
  /// the realtime requirements of the application; however, due to the nature of
  /// media components, performance is not guaranteed.
  static const KEY_PRIORITY = "priority";

  /// from: static public final java.lang.String KEY_PROFILE
  ///
  /// A key describing the desired profile to be used by an encoder.
  /// The associated value is an integer.
  /// Constants are declared in MediaCodecInfo.CodecProfileLevel.
  /// This key is used as a hint, and is only supported for codecs
  /// that specify a profile. Note: Codecs are free to use all the available
  /// coding tools at the specified profile.
  ///@see MediaCodecInfo.CodecCapabilities\#profileLevels
  static const KEY_PROFILE = "profile";

  /// from: static public final java.lang.String KEY_PUSH_BLANK_BUFFERS_ON_STOP
  ///
  /// If specified when configuring a video decoder rendering to a surface,
  /// causes the decoder to output "blank", i.e. black frames to the surface
  /// when stopped to clear out any previously displayed contents.
  /// The associated value is an integer of value 1.
  static const KEY_PUSH_BLANK_BUFFERS_ON_STOP =
      "push-blank-buffers-on-shutdown";

  /// from: static public final java.lang.String KEY_QUALITY
  ///
  /// A key describing the desired encoding quality.
  /// The associated value is an integer.  This key is only supported for encoders
  /// that are configured in constant-quality mode.  These values are device and
  /// codec specific, but lower values generally result in more efficient
  /// (smaller-sized) encoding.
  ///@see MediaCodecInfo.EncoderCapabilities\#getQualityRange()
  static const KEY_QUALITY = "quality";

  /// from: static public final java.lang.String KEY_REPEAT_PREVIOUS_FRAME_AFTER
  ///
  /// Applies only when configuring a video encoder in "surface-input" mode.
  /// The associated value is a long and gives the time in microseconds
  /// after which the frame previously submitted to the encoder will be
  /// repeated (once) if no new frame became available since.
  static const KEY_REPEAT_PREVIOUS_FRAME_AFTER = "repeat-previous-frame-after";

  /// from: static public final java.lang.String KEY_ROTATION
  ///
  /// A key describing the desired clockwise rotation on an output surface.
  /// This key is only used when the codec is configured using an output surface.
  /// The associated value is an integer, representing degrees. Supported values
  /// are 0, 90, 180 or 270. This is an optional field; if not specified, rotation
  /// defaults to 0.
  ///@see MediaCodecInfo.CodecCapabilities\#profileLevels
  static const KEY_ROTATION = "rotation-degrees";

  /// from: static public final java.lang.String KEY_SAMPLE_RATE
  ///
  /// A key describing the sample rate of an audio format.
  /// The associated value is an integer
  static const KEY_SAMPLE_RATE = "sample-rate";

  /// from: static public final java.lang.String KEY_SLICE_HEIGHT
  ///
  /// A key describing the plane height of a multi-planar (YUV) video bytebuffer layout.
  /// Slice height (or plane height/vertical stride) is the number of rows that must be skipped
  /// to get from the top of the Y plane to the top of the U plane in the bytebuffer. In essence
  /// the offset of the U plane is sliceHeight * stride. The height of the U/V planes
  /// can be calculated based on the color format, though it is generally undefined
  /// and depends on the device and release.
  /// The associated value is an integer, representing number of rows.
  static const KEY_SLICE_HEIGHT = "slice-height";

  /// from: static public final java.lang.String KEY_STRIDE
  ///
  /// A key describing the stride of the video bytebuffer layout.
  /// Stride (or row increment) is the difference between the index of a pixel
  /// and that of the pixel directly underneath. For YUV 420 formats, the
  /// stride corresponds to the Y plane; the stride of the U and V planes can
  /// be calculated based on the color format, though it is generally undefined
  /// and depends on the device and release.
  /// The associated value is an integer, representing number of bytes.
  static const KEY_STRIDE = "stride";

  /// from: static public final java.lang.String KEY_TEMPORAL_LAYERING
  ///
  /// A key describing the temporal layering schema.  This is an optional parameter
  /// that applies only to video encoders.  Use MediaCodec\#getOutputFormat
  /// after MediaCodec\#configure configure to query if the encoder supports
  /// the desired schema. Supported values are {@code webrtc.vp8.N-layer},
  /// {@code android.generic.N}, {@code android.generic.N+M} and {@code none}, where
  /// {@code N} denotes the total number of non-bidirectional layers (which must be at least 1)
  /// and {@code M} denotes the total number of bidirectional layers (which must be non-negative).
  /// <p class=note>{@code android.generic.*} schemas have been added in android.os.Build.VERSION_CODES\#N_MR1.
  ///
  /// The encoder may support fewer temporal layers, in which case the output format
  /// will contain the configured schema. If the encoder does not support temporal
  /// layering, the output format will not have an entry with this key.
  /// The associated value is a string.
  static const KEY_TEMPORAL_LAYERING = "ts-schema";

  /// from: static public final java.lang.String KEY_TILE_HEIGHT
  ///
  /// A key describing the height (in pixels) of each tile of the content in a
  /// \#MIMETYPE_IMAGE_ANDROID_HEIC track. The associated value is an integer.
  ///
  /// Refer to \#MIMETYPE_IMAGE_ANDROID_HEIC on decoding instructions of such tracks.
  ///@see \#KEY_TILE_WIDTH
  ///@see \#KEY_GRID_ROWS
  ///@see \#KEY_GRID_COLUMNS
  static const KEY_TILE_HEIGHT = "tile-height";

  /// from: static public final java.lang.String KEY_TILE_WIDTH
  ///
  /// A key describing the width (in pixels) of each tile of the content in a
  /// \#MIMETYPE_IMAGE_ANDROID_HEIC track. The associated value is an integer.
  ///
  /// Refer to \#MIMETYPE_IMAGE_ANDROID_HEIC on decoding instructions of such tracks.
  ///@see \#KEY_TILE_HEIGHT
  ///@see \#KEY_GRID_ROWS
  ///@see \#KEY_GRID_COLUMNS
  static const KEY_TILE_WIDTH = "tile-width";

  /// from: static public final java.lang.String KEY_TRACK_ID
  ///
  /// A key describing a unique ID for the content of a media track.
  ///
  /// This key is used by MediaExtractor. Some extractors provide multiple encodings
  /// of the same track (e.g. float audio tracks for FLAC and WAV may be expressed as two
  /// tracks via MediaExtractor: a normal PCM track for backward compatibility, and a float PCM
  /// track for added fidelity. Similarly, Dolby Vision extractor may provide a baseline SDR
  /// version of a DV track.) This key can be used to identify which MediaExtractor tracks refer
  /// to the same underlying content.
  ///
  ///
  ///
  /// The associated value is an integer.
  static const KEY_TRACK_ID = "track-id";

  /// from: static public final java.lang.String KEY_WIDTH
  ///
  /// A key describing the width of the content in a video format.
  /// The associated value is an integer
  static const KEY_WIDTH = "width";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_AAC
  static const MIMETYPE_AUDIO_AAC = "audio/mp4a-latm";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_AC3
  static const MIMETYPE_AUDIO_AC3 = "audio/ac3";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_AMR_NB
  static const MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_AMR_WB
  static const MIMETYPE_AUDIO_AMR_WB = "audio/amr-wb";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_EAC3
  static const MIMETYPE_AUDIO_EAC3 = "audio/eac3";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_FLAC
  static const MIMETYPE_AUDIO_FLAC = "audio/flac";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_G711_ALAW
  static const MIMETYPE_AUDIO_G711_ALAW = "audio/g711-alaw";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_G711_MLAW
  static const MIMETYPE_AUDIO_G711_MLAW = "audio/g711-mlaw";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_MPEG
  static const MIMETYPE_AUDIO_MPEG = "audio/mpeg";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_MSGSM
  static const MIMETYPE_AUDIO_MSGSM = "audio/gsm";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_OPUS
  static const MIMETYPE_AUDIO_OPUS = "audio/opus";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_QCELP
  static const MIMETYPE_AUDIO_QCELP = "audio/qcelp";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_RAW
  static const MIMETYPE_AUDIO_RAW = "audio/raw";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_SCRAMBLED
  static const MIMETYPE_AUDIO_SCRAMBLED = "audio/scrambled";

  /// from: static public final java.lang.String MIMETYPE_AUDIO_VORBIS
  static const MIMETYPE_AUDIO_VORBIS = "audio/vorbis";

  /// from: static public final java.lang.String MIMETYPE_IMAGE_ANDROID_HEIC
  ///
  /// MIME type for HEIF still image data encoded in HEVC.
  ///
  /// To decode such an image, MediaCodec decoder for
  /// \#MIMETYPE_VIDEO_HEVC shall be used. The client needs to form
  /// the correct \#MediaFormat based on additional information in
  /// the track format, and send it to MediaCodec\#configure.
  ///
  /// The track's MediaFormat will come with \#KEY_WIDTH and
  /// \#KEY_HEIGHT keys, which describes the width and height
  /// of the image. If the image doesn't contain grid (i.e. none of
  /// \#KEY_TILE_WIDTH, \#KEY_TILE_HEIGHT,
  /// \#KEY_GRID_ROWS, \#KEY_GRID_COLUMNS are present}), the
  /// track will contain a single sample of coded data for the entire image,
  /// and the image width and height should be used to set up the decoder.
  ///
  /// If the image does come with grid, each sample from the track will
  /// contain one tile in the grid, of which the size is described by
  /// \#KEY_TILE_WIDTH and \#KEY_TILE_HEIGHT. This size
  /// (instead of \#KEY_WIDTH and \#KEY_HEIGHT) should be
  /// used to set up the decoder. The track contains \#KEY_GRID_ROWS
  /// by \#KEY_GRID_COLUMNS samples in row-major, top-row first,
  /// left-to-right order. The output image should be reconstructed by
  /// first tiling the decoding results of the tiles in the correct order,
  /// then trimming (before rotation is applied) on the bottom and right
  /// side, if the tiled area is larger than the image width and height.
  static const MIMETYPE_IMAGE_ANDROID_HEIC = "image/vnd.android.heic";

  /// from: static public final java.lang.String MIMETYPE_TEXT_CEA_608
  ///
  /// MIME type for CEA-608 closed caption data.
  static const MIMETYPE_TEXT_CEA_608 = "text/cea-608";

  /// from: static public final java.lang.String MIMETYPE_TEXT_CEA_708
  ///
  /// MIME type for CEA-708 closed caption data.
  static const MIMETYPE_TEXT_CEA_708 = "text/cea-708";

  /// from: static public final java.lang.String MIMETYPE_TEXT_SUBRIP
  ///
  /// MIME type for SubRip (SRT) container.
  static const MIMETYPE_TEXT_SUBRIP = "application/x-subrip";

  /// from: static public final java.lang.String MIMETYPE_TEXT_VTT
  ///
  /// MIME type for WebVTT subtitle data.
  static const MIMETYPE_TEXT_VTT = "text/vtt";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_AVC
  static const MIMETYPE_VIDEO_AVC = "video/avc";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_DOLBY_VISION
  static const MIMETYPE_VIDEO_DOLBY_VISION = "video/dolby-vision";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_H263
  static const MIMETYPE_VIDEO_H263 = "video/3gpp";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_HEVC
  static const MIMETYPE_VIDEO_HEVC = "video/hevc";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_MPEG2
  static const MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_MPEG4
  static const MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_RAW
  static const MIMETYPE_VIDEO_RAW = "video/raw";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_SCRAMBLED
  static const MIMETYPE_VIDEO_SCRAMBLED = "video/scrambled";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_VP8
  static const MIMETYPE_VIDEO_VP8 = "video/x-vnd.on2.vp8";

  /// from: static public final java.lang.String MIMETYPE_VIDEO_VP9
  static const MIMETYPE_VIDEO_VP9 = "video/x-vnd.on2.vp9";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an empty MediaFormat
  MediaFormat()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_containsKey = jniAccessors.getMethodIDOf(
      _classRef, "containsKey", "(Ljava/lang/String;)Z");

  /// from: public boolean containsKey(java.lang.String name)
  ///
  /// Returns true iff a key of the given name exists in the format.
  bool containsKey(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsKey,
      jni.JniType.booleanType,
      [name.reference]).boolean;

  static final _id_getInteger = jniAccessors.getMethodIDOf(
      _classRef, "getInteger", "(Ljava/lang/String;)I");

  /// from: public int getInteger(java.lang.String name)
  ///
  /// Returns the value of an integer key.
  int getInteger(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference, _id_getInteger, jni.JniType.intType, [name.reference]).integer;

  static final _id_getLong =
      jniAccessors.getMethodIDOf(_classRef, "getLong", "(Ljava/lang/String;)J");

  /// from: public long getLong(java.lang.String name)
  ///
  /// Returns the value of a long key.
  int getLong(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference, _id_getLong, jni.JniType.longType, [name.reference]).long;

  static final _id_getFloat = jniAccessors.getMethodIDOf(
      _classRef, "getFloat", "(Ljava/lang/String;)F");

  /// from: public float getFloat(java.lang.String name)
  ///
  /// Returns the value of a float key.
  double getFloat(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference, _id_getFloat, jni.JniType.floatType, [name.reference]).float;

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getString(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value of a string key.
  jni.JniString getString(jni.JniString name) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getString, jni.JniType.objectType, [name.reference]).object);

  static final _id_getByteBuffer = jniAccessors.getMethodIDOf(
      _classRef, "getByteBuffer", "(Ljava/lang/String;)Ljava/nio/ByteBuffer;");

  /// from: public java.nio.ByteBuffer getByteBuffer(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value of a ByteBuffer key.
  jni.JniObject getByteBuffer(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getByteBuffer, jni.JniType.objectType, [name.reference]).object);

  static final _id_getFeatureEnabled = jniAccessors.getMethodIDOf(
      _classRef, "getFeatureEnabled", "(Ljava/lang/String;)Z");

  /// from: public boolean getFeatureEnabled(java.lang.String feature)
  ///
  /// Returns whether a feature is to be enabled ({@code true}) or disabled
  /// ({@code false}).
  ///@param feature the name of a MediaCodecInfo.CodecCapabilities feature.
  ///@throws IllegalArgumentException if the feature was neither set to be enabled
  ///        nor to be disabled.
  bool getFeatureEnabled(jni.JniString feature) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFeatureEnabled,
          jni.JniType.booleanType, [feature.reference]).boolean;

  static final _id_setInteger = jniAccessors.getMethodIDOf(
      _classRef, "setInteger", "(Ljava/lang/String;I)V");

  /// from: public void setInteger(java.lang.String name, int value)
  ///
  /// Sets the value of an integer key.
  void setInteger(jni.JniString name, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInteger,
          jni.JniType.voidType, [name.reference, value]).check();

  static final _id_setLong = jniAccessors.getMethodIDOf(
      _classRef, "setLong", "(Ljava/lang/String;J)V");

  /// from: public void setLong(java.lang.String name, long value)
  ///
  /// Sets the value of a long key.
  void setLong(jni.JniString name, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLong,
          jni.JniType.voidType, [name.reference, value]).check();

  static final _id_setFloat = jniAccessors.getMethodIDOf(
      _classRef, "setFloat", "(Ljava/lang/String;F)V");

  /// from: public void setFloat(java.lang.String name, float value)
  ///
  /// Sets the value of a float key.
  void setFloat(jni.JniString name, double value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFloat,
          jni.JniType.voidType, [name.reference, value]).check();

  static final _id_setString = jniAccessors.getMethodIDOf(
      _classRef, "setString", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void setString(java.lang.String name, java.lang.String value)
  ///
  /// Sets the value of a string key.
  void setString(jni.JniString name, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setString,
          jni.JniType.voidType, [name.reference, value.reference]).check();

  static final _id_setByteBuffer = jniAccessors.getMethodIDOf(
      _classRef, "setByteBuffer", "(Ljava/lang/String;Ljava/nio/ByteBuffer;)V");

  /// from: public void setByteBuffer(java.lang.String name, java.nio.ByteBuffer bytes)
  ///
  /// Sets the value of a ByteBuffer key.
  void setByteBuffer(jni.JniString name, jni.JniObject bytes) =>
      jniAccessors.callMethodWithArgs(reference, _id_setByteBuffer,
          jni.JniType.voidType, [name.reference, bytes.reference]).check();

  static final _id_setFeatureEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setFeatureEnabled", "(Ljava/lang/String;Z)V");

  /// from: public void setFeatureEnabled(java.lang.String feature, boolean enabled)
  ///
  /// Sets whether a feature is to be enabled ({@code true}) or disabled
  /// ({@code false}).
  ///
  /// If {@code enabled} is {@code true}, the feature is requested to be present.
  /// Otherwise, the feature is requested to be not present.
  ///@param feature the name of a MediaCodecInfo.CodecCapabilities feature.
  ///@see MediaCodecList\#findDecoderForFormat
  ///@see MediaCodecList\#findEncoderForFormat
  ///@see MediaCodecInfo.CodecCapabilities\#isFormatSupported
  void setFeatureEnabled(jni.JniString feature, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureEnabled,
          jni.JniType.voidType, [feature.reference, enabled]).check();

  static final _id_createAudioFormat = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createAudioFormat",
      "(Ljava/lang/String;II)Landroid/media/MediaFormat;");

  /// from: static public android.media.MediaFormat createAudioFormat(java.lang.String mime, int sampleRate, int channelCount)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a minimal audio format.
  ///@param mime The mime type of the content.
  ///@param sampleRate The sampling rate of the content.
  ///@param channelCount The number of audio channels in the content.
  static MediaFormat createAudioFormat(
          jni.JniString mime, int sampleRate, int channelCount) =>
      MediaFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createAudioFormat,
          jni.JniType.objectType,
          [mime.reference, sampleRate, channelCount]).object);

  static final _id_createSubtitleFormat = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createSubtitleFormat",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/media/MediaFormat;");

  /// from: static public android.media.MediaFormat createSubtitleFormat(java.lang.String mime, java.lang.String language)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a minimal subtitle format.
  ///@param mime The mime type of the content.
  ///@param language The language of the content, using either ISO 639-1 or 639-2/T
  ///        codes.  Specify null or "und" if language information is only included
  ///        in the content.  (This will also work if there are multiple language
  ///        tracks in the content.)
  static MediaFormat createSubtitleFormat(
          jni.JniString mime, jni.JniString language) =>
      MediaFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createSubtitleFormat,
          jni.JniType.objectType,
          [mime.reference, language.reference]).object);

  static final _id_createVideoFormat = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createVideoFormat",
      "(Ljava/lang/String;II)Landroid/media/MediaFormat;");

  /// from: static public android.media.MediaFormat createVideoFormat(java.lang.String mime, int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a minimal video format.
  ///@param mime The mime type of the content.
  ///@param width The width of the content (in pixels)
  ///@param height The height of the content (in pixels)
  static MediaFormat createVideoFormat(
          jni.JniString mime, int width, int height) =>
      MediaFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createVideoFormat,
          jni.JniType.objectType,
          [mime.reference, width, height]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
