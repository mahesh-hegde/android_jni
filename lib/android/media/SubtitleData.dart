// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.SubtitleData
///
/// Class encapsulating subtitle data, as received through the
/// MediaPlayer.OnSubtitleDataListener interface.
/// The subtitle data includes:
/// <ul>
/// <li> the track index</li>
/// <li> the start time (in microseconds) of the data</li>
/// <li> the duration (in microseconds) of the data</li>
/// <li> the actual data.</li>
/// </ul>
/// The data is stored in a byte-array, and is encoded in one of the supported in-band
/// subtitle formats. The subtitle encoding is determined by the MIME type of the
/// MediaPlayer.TrackInfo of the subtitle track, one of
/// MediaFormat\#MIMETYPE_TEXT_CEA_608, MediaFormat\#MIMETYPE_TEXT_CEA_708,
/// MediaFormat\#MIMETYPE_TEXT_VTT.
///
/// Here is an example of iterating over the tracks of a MediaPlayer, and checking which
/// encoding is used for the subtitle tracks:
///
/// <pre class="prettyprint">
/// MediaPlayer mp = new MediaPlayer();
/// mp.setDataSource(myContentLocation);
/// mp.prepare(); // synchronous prepare, ready to use when method returns
/// final TrackInfo[] trackInfos = mp.getTrackInfo();
/// for (TrackInfo info : trackInfo) {
///     if (info.getTrackType() == TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE) {
///         final String mime = info.getFormat().getString(MediaFormat.KEY_MIME);
///         if (MediaFormat.MIMETYPE_TEXT_CEA_608.equals(mime) {
///             // subtitle encoding is CEA 608
///         } else if (MediaFormat.MIMETYPE_TEXT_CEA_708.equals(mime) {
///             // subtitle encoding is CEA 708
///         } else if (MediaFormat.MIMETYPE_TEXT_VTT.equals(mime) {
///             // subtitle encoding is WebVTT
///         }
///     }
/// }
/// </pre>
///
/// See
/// MediaPlayer\#setOnSubtitleDataListener(android.media.MediaPlayer.OnSubtitleDataListener, android.os.Handler)
/// to receive subtitle data from a MediaPlayer object.
///@see android.media.MediaPlayer
class SubtitleData extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/SubtitleData");
  SubtitleData.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getTrackIndex =
      jniAccessors.getMethodIDOf(_classRef, "getTrackIndex", "()I");

  /// from: public int getTrackIndex()
  ///
  /// Returns the index of the MediaPlayer track which contains this subtitle data.
  ///@return an index in the array returned by MediaPlayer\#getTrackInfo().
  int getTrackIndex() => jniAccessors.callMethodWithArgs(
      reference, _id_getTrackIndex, jni.JniType.intType, []).integer;

  static final _id_getStartTimeUs =
      jniAccessors.getMethodIDOf(_classRef, "getStartTimeUs", "()J");

  /// from: public long getStartTimeUs()
  ///
  /// Returns the media time at which the subtitle should be displayed, expressed in microseconds.
  ///@return the display start time for the subtitle
  int getStartTimeUs() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartTimeUs, jni.JniType.longType, []).long;

  static final _id_getDurationUs =
      jniAccessors.getMethodIDOf(_classRef, "getDurationUs", "()J");

  /// from: public long getDurationUs()
  ///
  /// Returns the duration in microsecond during which the subtitle should be displayed.
  ///@return the display duration for the subtitle
  int getDurationUs() => jniAccessors.callMethodWithArgs(
      reference, _id_getDurationUs, jni.JniType.longType, []).long;

  static final _id_getData =
      jniAccessors.getMethodIDOf(_classRef, "getData", "()[B");

  /// from: public byte[] getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the encoded data for the subtitle content.
  /// Encoding format depends on the subtitle type, refer to
  /// <a href="https://en.wikipedia.org/wiki/CEA-708">CEA 708</a>,
  /// <a href="https://en.wikipedia.org/wiki/EIA-608">CEA/EIA 608</a> and
  /// <a href="https://www.w3.org/TR/webvtt1/">WebVTT</a>, defined by the MIME type
  /// of the subtitle track.
  ///@return the encoded subtitle data
  ///
  /// This value will never be {@code null}.
  jni.JniObject getData() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getData, jni.JniType.objectType, []).object);
}
