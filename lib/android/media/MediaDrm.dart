// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Handler.dart" as handler_;

import "../os/PersistableBundle.dart" as persistablebundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaDrm
///
/// MediaDrm can be used to obtain keys for decrypting protected media streams, in
/// conjunction with android.media.MediaCrypto.  The MediaDrm APIs
/// are designed to support the ISO/IEC 23001-7: Common Encryption standard, but
/// may also be used to implement other encryption schemes.
///
/// Encrypted content is prepared using an encryption server and stored in a content
/// library. The encrypted content is streamed or downloaded from the content library to
/// client devices via content servers.  Licenses to view the content are obtained from
/// a License Server.
///
/// <img src="../../../images/mediadrm_overview.png"alt="MediaDrm Overview diagram"border="0"/>
///
///
/// Keys are requested from the license server using a key request. The key
/// response is delivered to the client app, which provides the response to the
/// MediaDrm API.
///
/// A Provisioning server may be required to distribute device-unique credentials to
/// the devices.
///
/// Enforcing requirements related to the number of devices that may play content
/// simultaneously can be performed either through key renewal or using the secure
/// stop methods.
///
/// The following sequence diagram shows the interactions between the objects
/// involved while playing back encrypted content:
///
/// <img src="../../../images/mediadrm_decryption_sequence.png"alt="MediaDrm Overview diagram"border="0"/>
///
///
/// The app first constructs android.media.MediaExtractor and
/// android.media.MediaCodec objects. It accesses the DRM-scheme-identifying UUID,
/// typically from metadata in the content, and uses this UUID to construct an instance
/// of a MediaDrm object that is able to support the DRM scheme required by the content.
/// Crypto schemes are assigned 16 byte UUIDs.  The method \#isCryptoSchemeSupported
/// can be used to query if a given scheme is supported on the device.
///
/// The app calls \#openSession to generate a sessionId that will uniquely identify
/// the session in subsequent interactions. The app next uses the MediaDrm object to
/// obtain a key request message and send it to the license server, then provide
/// the server's response to the MediaDrm object.
///
/// Once the app has a sessionId, it can construct a MediaCrypto object from the UUID and
/// sessionId.  The MediaCrypto object is registered with the MediaCodec in the
/// MediaCodec\#configure method to enable the codec to decrypt content.
///
/// When the app has constructed android.media.MediaExtractor,
/// android.media.MediaCodec and android.media.MediaCrypto objects,
/// it proceeds to pull samples from the extractor and queue them into the decoder.  For
/// encrypted content, the samples returned from the extractor remain encrypted, they
/// are only decrypted when the samples are delivered to the decoder.
///
/// MediaDrm methods throw android.media.MediaDrm.MediaDrmStateException
/// when a method is called on a MediaDrm object that has had an unrecoverable failure
/// in the DRM plugin or security hardware.
/// android.media.MediaDrm.MediaDrmStateException extends
/// java.lang.IllegalStateException with the addition of a developer-readable
/// diagnostic information string associated with the exception.
///
/// In the event of a mediaserver process crash or restart while a MediaDrm object
/// is active, MediaDrm methods may throw android.media.MediaDrmResetException.
/// To recover, the app must release the MediaDrm object, then create and initialize
/// a new one.
///
/// As android.media.MediaDrmResetException and
/// android.media.MediaDrm.MediaDrmStateException both extend
/// java.lang.IllegalStateException, they should be in an earlier catch()
/// block than java.lang.IllegalStateException if handled separately.
///
/// <a name="Callbacks"></a>
/// <h3>Callbacks</h3>
/// Applications should register for informational events in order
/// to be informed of key state updates during playback or streaming.
/// Registration for these events is done via a call to
/// \#setOnEventListener. In order to receive the respective
/// callback associated with this listener, applications are required to create
/// MediaDrm objects on a thread with its own Looper running (main UI
/// thread by default has a Looper running).
class MediaDrm extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/MediaDrm");
  MediaDrm.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int EVENT_KEY_EXPIRED
  ///
  /// This event type indicates that the licensed usage duration for keys in a session
  /// has expired.  The keys are no longer valid.
  ///@deprecated Use OnKeyStatusChangeListener\#onKeyStatusChange
  /// and check for MediaDrm.KeyStatus\#STATUS_EXPIRED in the MediaDrm.KeyStatus
  /// instead.
  static const EVENT_KEY_EXPIRED = 3;

  /// from: static public final int EVENT_KEY_REQUIRED
  ///
  /// This event type indicates that the app needs to request keys from a license
  /// server.  The request message data is obtained using \#getKeyRequest.
  static const EVENT_KEY_REQUIRED = 2;

  /// from: static public final int EVENT_PROVISION_REQUIRED
  ///
  /// This event type indicates that the app needs to request a certificate from
  /// the provisioning server.  The request message data is obtained using
  /// \#getProvisionRequest
  ///@deprecated Handle provisioning via android.media.NotProvisionedException
  /// instead.
  static const EVENT_PROVISION_REQUIRED = 1;

  /// from: static public final int EVENT_SESSION_RECLAIMED
  ///
  /// This event indicates that a session opened by the app has been reclaimed by the resource
  /// manager.
  static const EVENT_SESSION_RECLAIMED = 5;

  /// from: static public final int EVENT_VENDOR_DEFINED
  ///
  /// This event may indicate some specific vendor-defined condition, see your
  /// DRM provider documentation for details
  static const EVENT_VENDOR_DEFINED = 4;

  /// from: static public final int HDCP_LEVEL_UNKNOWN
  ///
  /// The DRM plugin did not report an HDCP level, or an error
  /// occurred accessing it
  static const HDCP_LEVEL_UNKNOWN = 0;

  /// from: static public final int HDCP_NONE
  ///
  /// HDCP is not supported on this device, content is unprotected
  static const HDCP_NONE = 1;

  /// from: static public final int HDCP_NO_DIGITAL_OUTPUT
  ///
  /// No digital output, implicitly secure
  static const HDCP_NO_DIGITAL_OUTPUT = 2147483647;

  /// from: static public final int HDCP_V1
  ///
  /// HDCP version 1.0
  static const HDCP_V1 = 2;

  /// from: static public final int HDCP_V2
  ///
  /// HDCP version 2.0 Type 1.
  static const HDCP_V2 = 3;

  /// from: static public final int HDCP_V2_1
  ///
  /// HDCP version 2.1 Type 1.
  static const HDCP_V2_1 = 4;

  /// from: static public final int HDCP_V2_2
  ///
  /// HDCP version 2.2 Type 1.
  static const HDCP_V2_2 = 5;

  /// from: static public final int KEY_TYPE_OFFLINE
  ///
  /// This key request type specifies that the keys will be for offline use, they
  /// will be saved to the device for use when the device is not connected to a network.
  static const KEY_TYPE_OFFLINE = 2;

  /// from: static public final int KEY_TYPE_RELEASE
  ///
  /// This key request type specifies that previously saved offline keys should be released.
  static const KEY_TYPE_RELEASE = 3;

  /// from: static public final int KEY_TYPE_STREAMING
  ///
  /// This key request type species that the keys will be for online use, they will
  /// not be saved to the device for subsequent use when the device is not connected
  /// to a network.
  static const KEY_TYPE_STREAMING = 1;

  /// from: static public final java.lang.String PROPERTY_ALGORITHMS
  ///
  /// String property name: a comma-separated list of cipher and mac algorithms
  /// supported by CryptoSession.  The list may be empty if the DRM
  /// plugin does not support CryptoSession operations.
  static const PROPERTY_ALGORITHMS = "algorithms";

  /// from: static public final java.lang.String PROPERTY_DESCRIPTION
  ///
  /// String property name: describes the DRM plugin
  static const PROPERTY_DESCRIPTION = "description";

  /// from: static public final java.lang.String PROPERTY_DEVICE_UNIQUE_ID
  ///
  /// Byte array property name: the device unique identifier is established during
  /// device provisioning and provides a means of uniquely identifying each device.
  static const PROPERTY_DEVICE_UNIQUE_ID = "deviceUniqueId";

  /// from: static public final java.lang.String PROPERTY_VENDOR
  ///
  /// String property name: identifies the maker of the DRM plugin
  static const PROPERTY_VENDOR = "vendor";

  /// from: static public final java.lang.String PROPERTY_VERSION
  ///
  /// String property name: identifies the version of the DRM plugin
  static const PROPERTY_VERSION = "version";

  /// from: static public final int SECURITY_LEVEL_HW_SECURE_ALL
  ///
  /// DRM key management, crypto operations, decoding of content and all
  /// handling of the media (compressed and uncompressed) is handled within a
  /// hardware backed trusted execution environment.
  static const SECURITY_LEVEL_HW_SECURE_ALL = 5;

  /// from: static public final int SECURITY_LEVEL_HW_SECURE_CRYPTO
  ///
  /// DRM key management and crypto operations are performed within a hardware
  /// backed trusted execution environment.
  static const SECURITY_LEVEL_HW_SECURE_CRYPTO = 3;

  /// from: static public final int SECURITY_LEVEL_HW_SECURE_DECODE
  ///
  /// DRM key management, crypto operations and decoding of content are
  /// performed within a hardware backed trusted execution environment.
  static const SECURITY_LEVEL_HW_SECURE_DECODE = 4;

  /// from: static public final int SECURITY_LEVEL_SW_SECURE_CRYPTO
  ///
  /// DRM key management uses software-based whitebox crypto.
  static const SECURITY_LEVEL_SW_SECURE_CRYPTO = 1;

  /// from: static public final int SECURITY_LEVEL_SW_SECURE_DECODE
  ///
  /// DRM key management and decoding use software-based whitebox crypto.
  static const SECURITY_LEVEL_SW_SECURE_DECODE = 2;

  /// from: static public final int SECURITY_LEVEL_UNKNOWN
  ///
  /// The DRM plugin did not report a security level, or an error occurred
  /// accessing it
  static const SECURITY_LEVEL_UNKNOWN = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/util/UUID;)V");

  /// from: public void <init>(java.util.UUID uuid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiate a MediaDrm object
  ///@param uuid The UUID of the crypto scheme.
  ///
  /// This value must never be {@code null}.
  ///@throws UnsupportedSchemeException if the device does not support the
  /// specified scheme UUID
  MediaDrm(jni.JniObject uuid)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [uuid.reference]).object);

  static final _id_isCryptoSchemeSupported = jniAccessors.getStaticMethodIDOf(
      _classRef, "isCryptoSchemeSupported", "(Ljava/util/UUID;)Z");

  /// from: static public boolean isCryptoSchemeSupported(java.util.UUID uuid)
  ///
  /// Query if the given scheme identified by its UUID is supported on
  /// this device.
  ///@param uuid The UUID of the crypto scheme.
  ///
  /// This value must never be {@code null}.
  static bool isCryptoSchemeSupported(jni.JniObject uuid) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isCryptoSchemeSupported,
          jni.JniType.booleanType,
          [uuid.reference]).boolean;

  static final _id_isCryptoSchemeSupported1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "isCryptoSchemeSupported",
      "(Ljava/util/UUID;Ljava/lang/String;)Z");

  /// from: static public boolean isCryptoSchemeSupported(java.util.UUID uuid, java.lang.String mimeType)
  ///
  /// Query if the given scheme identified by its UUID is supported on
  /// this device, and whether the DRM plugin is able to handle the
  /// media container format specified by mimeType.
  ///@param uuid The UUID of the crypto scheme.
  /// This value must never be {@code null}.
  ///@param mimeType The MIME type of the media container, e.g. "video/mp4"
  ///   or "video/webm"
  ///
  /// This value must never be {@code null}.
  static bool isCryptoSchemeSupported1(
          jni.JniObject uuid, jni.JniString mimeType) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isCryptoSchemeSupported1,
          jni.JniType.booleanType,
          [uuid.reference, mimeType.reference]).boolean;

  static final _id_setOnExpirationUpdateListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnExpirationUpdateListener",
      "(Landroid/media/MediaDrm\$OnExpirationUpdateListener;Landroid/os/Handler;)V");

  /// from: public void setOnExpirationUpdateListener(android.media.MediaDrm.OnExpirationUpdateListener listener, android.os.Handler handler)
  ///
  /// Register a callback to be invoked when a session expiration update
  /// occurs.  The app's OnExpirationUpdateListener will be notified
  /// when the expiration time of the keys in the session have changed.
  ///@param listener the callback that will be run, or {@code null} to unregister the
  ///     previously registered callback.
  /// This value may be {@code null}.
  ///@param handler the handler on which the listener should be invoked, or
  ///     {@code null} if the listener should be invoked on the calling thread's looper.
  ///
  /// This value may be {@code null}.
  void setOnExpirationUpdateListener(
          MediaDrm_OnExpirationUpdateListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnExpirationUpdateListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_setOnKeyStatusChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnKeyStatusChangeListener",
      "(Landroid/media/MediaDrm\$OnKeyStatusChangeListener;Landroid/os/Handler;)V");

  /// from: public void setOnKeyStatusChangeListener(android.media.MediaDrm.OnKeyStatusChangeListener listener, android.os.Handler handler)
  ///
  /// Register a callback to be invoked when the state of keys in a session
  /// change, e.g.&nbsp;when a license update occurs or when a license expires.
  ///@param listener the callback that will be run when key status changes, or
  ///     {@code null} to unregister the previously registered callback.
  /// This value may be {@code null}.
  ///@param handler the handler on which the listener should be invoked, or
  ///     null if the listener should be invoked on the calling thread's looper.
  ///
  /// This value may be {@code null}.
  void setOnKeyStatusChangeListener(MediaDrm_OnKeyStatusChangeListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnKeyStatusChangeListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_setOnEventListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnEventListener", "(Landroid/media/MediaDrm\$OnEventListener;)V");

  /// from: public void setOnEventListener(android.media.MediaDrm.OnEventListener listener)
  ///
  /// Register a callback to be invoked when an event occurs
  ///@param listener the callback that will be run.  Use {@code null} to
  ///        stop receiving event callbacks.
  ///
  /// This value may be {@code null}.
  void setOnEventListener(MediaDrm_OnEventListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnEventListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_openSession =
      jniAccessors.getMethodIDOf(_classRef, "openSession", "()[B");

  /// from: public byte[] openSession()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a new session with the MediaDrm object. A session ID is returned.
  /// By default, sessions are opened at the native security level of the device.
  ///@throws NotProvisionedException if provisioning is needed
  ///@throws ResourceBusyException if required resources are in use
  ///@return This value will never be {@code null}.
  jni.JniObject openSession() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_openSession, jni.JniType.objectType, []).object);

  static final _id_openSession1 =
      jniAccessors.getMethodIDOf(_classRef, "openSession", "(I)[B");

  /// from: public native byte[] openSession(int level)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a new session at a requested security level. The security level
  /// represents the robustness of the device's DRM implementation. By default,
  /// sessions are opened at the native security level of the device.
  /// Overriding the security level is necessary when the decrypted frames need
  /// to be manipulated, such as for image compositing. The security level
  /// parameter must be lower than the native level. Reducing the security
  /// level will typically limit the content to lower resolutions, as
  /// determined by the license policy. If the requested level is not
  /// supported, the next lower supported security level will be set. The level
  /// can be queried using \#getSecurityLevel. A session
  /// ID is returned.
  ///@param level the new security level, one of
  /// \#SECURITY_LEVEL_SW_SECURE_CRYPTO,
  /// \#SECURITY_LEVEL_SW_SECURE_DECODE,
  /// \#SECURITY_LEVEL_HW_SECURE_CRYPTO,
  /// \#SECURITY_LEVEL_HW_SECURE_DECODE or
  /// \#SECURITY_LEVEL_HW_SECURE_ALL.
  ///
  /// Value is android.media.MediaDrm\#SECURITY_LEVEL_UNKNOWN, android.media.MediaDrm\#SECURITY_LEVEL_SW_SECURE_CRYPTO, android.media.MediaDrm\#SECURITY_LEVEL_SW_SECURE_DECODE, android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_CRYPTO, android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_DECODE, or android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_ALL
  ///@throws NotProvisionedException if provisioning is needed
  ///@throws ResourceBusyException if required resources are in use
  ///@throws IllegalArgumentException if the requested security level is
  /// higher than the native level or lower than the lowest supported level or
  /// if the device does not support specifying the security level when opening
  /// a session
  ///@return This value will never be {@code null}.
  jni.JniObject openSession1(int level) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_openSession1, jni.JniType.objectType, [level]).object);

  static final _id_closeSession =
      jniAccessors.getMethodIDOf(_classRef, "closeSession", "([B)V");

  /// from: public native void closeSession(byte[] sessionId)
  ///
  /// Close a session on the MediaDrm object that was previously opened
  /// with \#openSession.
  ///@param sessionId This value must never be {@code null}.
  void closeSession(jni.JniObject sessionId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_closeSession,
      jni.JniType.voidType,
      [sessionId.reference]).check();

  static final _id_getKeyRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "getKeyRequest",
      "([B[BLjava/lang/String;ILjava/util/HashMap;)Landroid/media/MediaDrm\$KeyRequest;");

  /// from: public native android.media.MediaDrm.KeyRequest getKeyRequest(byte[] scope, byte[] init, java.lang.String mimeType, int keyType, java.util.HashMap<java.lang.String,java.lang.String> optionalParameters)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A key request/response exchange occurs between the app and a license server
  /// to obtain or release keys used to decrypt encrypted content.
  ///
  /// getKeyRequest() is used to obtain an opaque key request byte array that is
  /// delivered to the license server.  The opaque key request byte array is returned
  /// in KeyRequest.data.  The recommended URL to deliver the key request to is
  /// returned in KeyRequest.defaultUrl.
  ///
  /// After the app has received the key request response from the server,
  /// it should deliver to the response to the MediaDrm instance using the method
  /// \#provideKeyResponse.
  ///@param scope may be a sessionId or a keySetId, depending on the specified keyType.
  /// When the keyType is KEY_TYPE_STREAMING or KEY_TYPE_OFFLINE,
  /// scope should be set to the sessionId the keys will be provided to.  When the keyType
  /// is KEY_TYPE_RELEASE, scope should be set to the keySetId of the keys
  /// being released. Releasing keys from a device invalidates them for all sessions.
  /// This value must never be {@code null}.
  ///@param init container-specific data, its meaning is interpreted based on the
  /// mime type provided in the mimeType parameter.  It could contain, for example,
  /// the content ID, key ID or other data obtained from the content metadata that is
  /// required in generating the key request. May be null when keyType is
  /// KEY_TYPE_RELEASE or if the request is a renewal, i.e. not the first key
  /// request for the session.
  /// This value may be {@code null}.
  ///@param mimeType identifies the mime type of the content. May be null if the
  /// keyType is KEY_TYPE_RELEASE or if the request is a renewal, i.e. not the
  /// first key request for the session.
  /// This value may be {@code null}.
  ///@param keyType specifes the type of the request. The request may be to acquire
  /// keys for streaming or offline content, or to release previously acquired
  /// keys, which are identified by a keySetId.
  /// Value is android.media.MediaDrm\#KEY_TYPE_STREAMING, android.media.MediaDrm\#KEY_TYPE_OFFLINE, or android.media.MediaDrm\#KEY_TYPE_RELEASE
  ///@param optionalParameters are included in the key request message to
  /// allow a client application to provide additional message parameters to the server.
  /// This may be {@code null} if no additional parameters are to be sent.
  /// This value may be {@code null}.
  ///@throws NotProvisionedException if reprovisioning is needed, due to a
  /// problem with the certifcate
  MediaDrm_KeyRequest getKeyRequest(
          jni.JniObject scope,
          jni.JniObject init,
          jni.JniString mimeType,
          int keyType,
          jni.JniObject optionalParameters) =>
      MediaDrm_KeyRequest.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeyRequest, jni.JniType.objectType, [
        scope.reference,
        init.reference,
        mimeType.reference,
        keyType,
        optionalParameters.reference
      ]).object);

  static final _id_provideKeyResponse =
      jniAccessors.getMethodIDOf(_classRef, "provideKeyResponse", "([B[B)[B");

  /// from: public native byte[] provideKeyResponse(byte[] scope, byte[] response)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A key response is received from the license server by the app, then it is
  /// provided to the MediaDrm instance using provideKeyResponse.  When the
  /// response is for an offline key request, a keySetId is returned that can be
  /// used to later restore the keys to a new session with the method
  /// \#restoreKeys.
  /// When the response is for a streaming or release request, an empty byte array
  /// is returned.
  ///@param scope may be a sessionId or keySetId depending on the type of the
  /// response.  Scope should be set to the sessionId when the response is for either
  /// streaming or offline key requests.  Scope should be set to the keySetId when
  /// the response is for a release request.
  /// This value must never be {@code null}.
  ///@param response the byte array response from the server
  /// This value must never be {@code null}.
  ///@return If the response is for an offline request, the keySetId for the offline
  /// keys will be returned. If the response is for a streaming or release request
  /// an empty byte array will be returned.
  ///
  /// This value may be {@code null}.
  ///@throws NotProvisionedException if the response indicates that
  /// reprovisioning is required
  ///@throws DeniedByServerException if the response indicates that the
  /// server rejected the request
  jni.JniObject provideKeyResponse(
          jni.JniObject scope, jni.JniObject response) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_provideKeyResponse,
          jni.JniType.objectType,
          [scope.reference, response.reference]).object);

  static final _id_restoreKeys =
      jniAccessors.getMethodIDOf(_classRef, "restoreKeys", "([B[B)V");

  /// from: public native void restoreKeys(byte[] sessionId, byte[] keySetId)
  ///
  /// Restore persisted offline keys into a new session.  keySetId identifies the
  /// keys to load, obtained from a prior call to \#provideKeyResponse.
  ///@param sessionId the session ID for the DRM session
  /// This value must never be {@code null}.
  ///@param keySetId identifies the saved key set to restore
  ///
  /// This value must never be {@code null}.
  void restoreKeys(jni.JniObject sessionId, jni.JniObject keySetId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_restoreKeys,
          jni.JniType.voidType,
          [sessionId.reference, keySetId.reference]).check();

  static final _id_removeKeys =
      jniAccessors.getMethodIDOf(_classRef, "removeKeys", "([B)V");

  /// from: public native void removeKeys(byte[] sessionId)
  ///
  /// Remove the current keys from a session.
  ///@param sessionId the session ID for the DRM session
  ///
  /// This value must never be {@code null}.
  void removeKeys(jni.JniObject sessionId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeKeys,
      jni.JniType.voidType,
      [sessionId.reference]).check();

  static final _id_queryKeyStatus = jniAccessors.getMethodIDOf(
      _classRef, "queryKeyStatus", "([B)Ljava/util/HashMap;");

  /// from: public native java.util.HashMap<java.lang.String,java.lang.String> queryKeyStatus(byte[] sessionId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request an informative description of the key status for the session.  The status is
  /// in the form of {name, value} pairs.  Since DRM license policies vary by vendor,
  /// the specific status field names are determined by each DRM vendor.  Refer to your
  /// DRM provider documentation for definitions of the field names for a particular
  /// DRM plugin.
  ///@param sessionId the session ID for the DRM session
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject queryKeyStatus(jni.JniObject sessionId) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryKeyStatus,
          jni.JniType.objectType,
          [sessionId.reference]).object);

  static final _id_getProvisionRequest = jniAccessors.getMethodIDOf(_classRef,
      "getProvisionRequest", "()Landroid/media/MediaDrm\$ProvisionRequest;");

  /// from: public android.media.MediaDrm.ProvisionRequest getProvisionRequest()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A provision request/response exchange occurs between the app and a provisioning
  /// server to retrieve a device certificate.  If provisionining is required, the
  /// EVENT_PROVISION_REQUIRED event will be sent to the event handler.
  /// getProvisionRequest is used to obtain the opaque provision request byte array that
  /// should be delivered to the provisioning server. The provision request byte array
  /// is returned in ProvisionRequest.data. The recommended URL to deliver the provision
  /// request to is returned in ProvisionRequest.defaultUrl.
  ///@return This value will never be {@code null}.
  MediaDrm_ProvisionRequest getProvisionRequest() =>
      MediaDrm_ProvisionRequest.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getProvisionRequest,
          jni.JniType.objectType, []).object);

  static final _id_provideProvisionResponse = jniAccessors.getMethodIDOf(
      _classRef, "provideProvisionResponse", "([B)V");

  /// from: public void provideProvisionResponse(byte[] response)
  ///
  /// After a provision response is received by the app, it is provided to the
  /// MediaDrm instance using this method.
  ///@param response the opaque provisioning response byte array to provide to the
  /// MediaDrm instance.
  ///
  /// This value must never be {@code null}.
  ///@throws DeniedByServerException if the response indicates that the
  /// server rejected the request
  void provideProvisionResponse(jni.JniObject response) =>
      jniAccessors.callMethodWithArgs(reference, _id_provideProvisionResponse,
          jni.JniType.voidType, [response.reference]).check();

  static final _id_getSecureStops = jniAccessors.getMethodIDOf(
      _classRef, "getSecureStops", "()Ljava/util/List;");

  /// from: public native java.util.List<byte[]> getSecureStops()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Secure stops are a way to enforce limits on the number of concurrent
  /// streams per subscriber across devices. They provide secure monitoring of
  /// the lifetime of content decryption keys in MediaDrm sessions.
  ///
  /// A secure stop is written to secure persistent memory when keys are loaded
  /// into a MediaDrm session. The secure stop state indicates that the keys
  /// are available for use. When playback completes and the keys are removed
  /// or the session is destroyed, the secure stop state is updated to indicate
  /// that keys are no longer usable.
  ///
  /// After playback, the app can query the secure stop and send it in a
  /// message to the license server confirming that the keys are no longer
  /// active. The license server returns a secure stop release response
  /// message to the app which then deletes the secure stop from persistent
  /// memory using \#releaseSecureStops.
  ///
  /// Each secure stop has a unique ID that can be used to identify it during
  /// enumeration, access and removal.
  ///@return a list of all secure stops from secure persistent memory
  ///
  /// This value will never be {@code null}.
  jni.JniObject getSecureStops() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSecureStops, jni.JniType.objectType, []).object);

  static final _id_getSecureStopIds = jniAccessors.getMethodIDOf(
      _classRef, "getSecureStopIds", "()Ljava/util/List;");

  /// from: public native java.util.List<byte[]> getSecureStopIds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of all secure stop IDs currently in persistent memory.
  /// The secure stop ID can be used to access or remove the corresponding
  /// secure stop.
  ///@return a list of secure stop IDs
  ///
  /// This value will never be {@code null}.
  jni.JniObject getSecureStopIds() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSecureStopIds, jni.JniType.objectType, []).object);

  static final _id_getSecureStop =
      jniAccessors.getMethodIDOf(_classRef, "getSecureStop", "([B)[B");

  /// from: public native byte[] getSecureStop(byte[] ssid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Access a specific secure stop given its secure stop ID.
  /// Each secure stop has a unique ID.
  ///@param ssid the ID of the secure stop to return
  /// This value must never be {@code null}.
  ///@return the secure stop identified by ssid
  ///
  /// This value will never be {@code null}.
  jni.JniObject getSecureStop(jni.JniObject ssid) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSecureStop, jni.JniType.objectType, [ssid.reference]).object);

  static final _id_releaseSecureStops =
      jniAccessors.getMethodIDOf(_classRef, "releaseSecureStops", "([B)V");

  /// from: public native void releaseSecureStops(byte[] ssRelease)
  ///
  /// Process the secure stop server response message ssRelease.  After
  /// authenticating the message, remove the secure stops identified in the
  /// response.
  ///@param ssRelease the server response indicating which secure stops to release
  ///
  /// This value must never be {@code null}.
  void releaseSecureStops(jni.JniObject ssRelease) =>
      jniAccessors.callMethodWithArgs(reference, _id_releaseSecureStops,
          jni.JniType.voidType, [ssRelease.reference]).check();

  static final _id_removeSecureStop =
      jniAccessors.getMethodIDOf(_classRef, "removeSecureStop", "([B)V");

  /// from: public native void removeSecureStop(byte[] ssid)
  ///
  /// Remove a specific secure stop without requiring a secure stop release message
  /// from the license server.
  ///@param ssid the ID of the secure stop to remove
  ///
  /// This value must never be {@code null}.
  void removeSecureStop(jni.JniObject ssid) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeSecureStop,
      jni.JniType.voidType,
      [ssid.reference]).check();

  static final _id_removeAllSecureStops =
      jniAccessors.getMethodIDOf(_classRef, "removeAllSecureStops", "()V");

  /// from: public native void removeAllSecureStops()
  ///
  /// Remove all secure stops without requiring a secure stop release message from
  /// the license server.
  ///
  /// This method was added in API 28. In API versions 18 through 27,
  /// \#releaseAllSecureStops should be called instead. There is no need to
  /// do anything for API versions prior to 18.
  void removeAllSecureStops() => jniAccessors.callMethodWithArgs(
      reference, _id_removeAllSecureStops, jni.JniType.voidType, []).check();

  static final _id_releaseAllSecureStops =
      jniAccessors.getMethodIDOf(_classRef, "releaseAllSecureStops", "()V");

  /// from: public void releaseAllSecureStops()
  ///
  /// Remove all secure stops without requiring a secure stop release message from
  /// the license server.
  ///@deprecated Remove all secure stops using \#removeAllSecureStops instead.
  void releaseAllSecureStops() => jniAccessors.callMethodWithArgs(
      reference, _id_releaseAllSecureStops, jni.JniType.voidType, []).check();

  static final _id_getConnectedHdcpLevel =
      jniAccessors.getMethodIDOf(_classRef, "getConnectedHdcpLevel", "()I");

  /// from: public native int getConnectedHdcpLevel()
  ///
  /// Return the HDCP level negotiated with downstream receivers the
  /// device is connected to. If multiple HDCP-capable displays are
  /// simultaneously connected to separate interfaces, this method
  /// returns the lowest negotiated level of all interfaces.
  ///
  /// This method should only be used for informational purposes, not for
  /// enforcing compliance with HDCP requirements. Trusted enforcement of
  /// HDCP policies must be handled by the DRM system.
  ///
  ///@return one of \#HDCP_LEVEL_UNKNOWN, \#HDCP_NONE,
  /// \#HDCP_V1, \#HDCP_V2, \#HDCP_V2_1, \#HDCP_V2_2
  /// or \#HDCP_NO_DIGITAL_OUTPUT.
  ///
  /// Value is android.media.MediaDrm\#HDCP_LEVEL_UNKNOWN, android.media.MediaDrm\#HDCP_NONE, android.media.MediaDrm\#HDCP_V1, android.media.MediaDrm\#HDCP_V2, android.media.MediaDrm\#HDCP_V2_1, android.media.MediaDrm\#HDCP_V2_2, or android.media.MediaDrm\#HDCP_NO_DIGITAL_OUTPUT
  int getConnectedHdcpLevel() => jniAccessors.callMethodWithArgs(
      reference, _id_getConnectedHdcpLevel, jni.JniType.intType, []).integer;

  static final _id_getMaxHdcpLevel =
      jniAccessors.getMethodIDOf(_classRef, "getMaxHdcpLevel", "()I");

  /// from: public native int getMaxHdcpLevel()
  ///
  /// Return the maximum supported HDCP level. The maximum HDCP level is a
  /// constant for a given device, it does not depend on downstream receivers
  /// that may be connected. If multiple HDCP-capable interfaces are present,
  /// it indicates the highest of the maximum HDCP levels of all interfaces.
  ///
  ///@return one of \#HDCP_LEVEL_UNKNOWN, \#HDCP_NONE,
  /// \#HDCP_V1, \#HDCP_V2, \#HDCP_V2_1, \#HDCP_V2_2
  /// or \#HDCP_NO_DIGITAL_OUTPUT.
  ///
  /// Value is android.media.MediaDrm\#HDCP_LEVEL_UNKNOWN, android.media.MediaDrm\#HDCP_NONE, android.media.MediaDrm\#HDCP_V1, android.media.MediaDrm\#HDCP_V2, android.media.MediaDrm\#HDCP_V2_1, android.media.MediaDrm\#HDCP_V2_2, or android.media.MediaDrm\#HDCP_NO_DIGITAL_OUTPUT
  int getMaxHdcpLevel() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxHdcpLevel, jni.JniType.intType, []).integer;

  static final _id_getOpenSessionCount =
      jniAccessors.getMethodIDOf(_classRef, "getOpenSessionCount", "()I");

  /// from: public native int getOpenSessionCount()
  ///
  /// Return the number of MediaDrm sessions that are currently opened
  /// simultaneously among all MediaDrm instances for the active DRM scheme.
  ///@return the number of open sessions.
  int getOpenSessionCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpenSessionCount, jni.JniType.intType, []).integer;

  static final _id_getMaxSessionCount =
      jniAccessors.getMethodIDOf(_classRef, "getMaxSessionCount", "()I");

  /// from: public native int getMaxSessionCount()
  ///
  /// Return the maximum number of MediaDrm sessions that may be opened
  /// simultaneosly among all MediaDrm instances for the active DRM
  /// scheme. The maximum number of sessions is not affected by any
  /// sessions that may have already been opened.
  ///@return maximum sessions.
  int getMaxSessionCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxSessionCount, jni.JniType.intType, []).integer;

  static final _id_getMaxSecurityLevel =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMaxSecurityLevel", "()I");

  /// from: static public int getMaxSecurityLevel()
  ///
  /// The maximum security level supported by the device. This is the default
  /// security level when a session is opened.
  ///@return Value is android.media.MediaDrm\#SECURITY_LEVEL_UNKNOWN, android.media.MediaDrm\#SECURITY_LEVEL_SW_SECURE_CRYPTO, android.media.MediaDrm\#SECURITY_LEVEL_SW_SECURE_DECODE, android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_CRYPTO, android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_DECODE, or android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_ALL
  static int getMaxSecurityLevel() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMaxSecurityLevel, jni.JniType.intType, []).integer;

  static final _id_getSecurityLevel =
      jniAccessors.getMethodIDOf(_classRef, "getSecurityLevel", "([B)I");

  /// from: public native int getSecurityLevel(byte[] sessionId)
  ///
  /// Return the current security level of a session. A session has an initial
  /// security level determined by the robustness of the DRM system's
  /// implementation on the device. The security level may be changed at the
  /// time a session is opened using \#openSession.
  ///@param sessionId the session to query.
  ///
  /// This value must never be {@code null}.
  ///@return one of \#SECURITY_LEVEL_UNKNOWN,
  /// \#SECURITY_LEVEL_SW_SECURE_CRYPTO, \#SECURITY_LEVEL_SW_SECURE_DECODE,
  /// \#SECURITY_LEVEL_HW_SECURE_CRYPTO, \#SECURITY_LEVEL_HW_SECURE_DECODE or
  /// \#SECURITY_LEVEL_HW_SECURE_ALL.
  ///
  /// Value is android.media.MediaDrm\#SECURITY_LEVEL_UNKNOWN, android.media.MediaDrm\#SECURITY_LEVEL_SW_SECURE_CRYPTO, android.media.MediaDrm\#SECURITY_LEVEL_SW_SECURE_DECODE, android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_CRYPTO, android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_DECODE, or android.media.MediaDrm\#SECURITY_LEVEL_HW_SECURE_ALL
  int getSecurityLevel(jni.JniObject sessionId) =>
      jniAccessors.callMethodWithArgs(reference, _id_getSecurityLevel,
          jni.JniType.intType, [sessionId.reference]).integer;

  static final _id_getPropertyString = jniAccessors.getMethodIDOf(
      _classRef, "getPropertyString", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public native java.lang.String getPropertyString(java.lang.String propertyName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a MediaDrm String property value, given the property name string.
  ///
  /// Standard fields names are:
  /// \#PROPERTY_VENDOR, \#PROPERTY_VERSION,
  /// \#PROPERTY_DESCRIPTION, \#PROPERTY_ALGORITHMS
  ///@param propertyName This value must never be {@code null}.
  /// Value is android.media.MediaDrm\#PROPERTY_VENDOR, android.media.MediaDrm\#PROPERTY_VERSION, android.media.MediaDrm\#PROPERTY_DESCRIPTION, or android.media.MediaDrm\#PROPERTY_ALGORITHMS
  ///@return This value will never be {@code null}.
  jni.JniString getPropertyString(jni.JniString propertyName) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPropertyString,
          jni.JniType.objectType,
          [propertyName.reference]).object);

  static final _id_setPropertyString = jniAccessors.getMethodIDOf(_classRef,
      "setPropertyString", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public native void setPropertyString(java.lang.String propertyName, java.lang.String value)
  ///
  /// Set a MediaDrm String property value, given the property name string
  /// and new value for the property.
  ///@param propertyName This value must never be {@code null}.
  ///
  /// Value is android.media.MediaDrm\#PROPERTY_VENDOR, android.media.MediaDrm\#PROPERTY_VERSION, android.media.MediaDrm\#PROPERTY_DESCRIPTION, or android.media.MediaDrm\#PROPERTY_ALGORITHMS
  ///@param value This value must never be {@code null}.
  void setPropertyString(jni.JniString propertyName, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPropertyString,
          jni.JniType.voidType,
          [propertyName.reference, value.reference]).check();

  static final _id_getPropertyByteArray = jniAccessors.getMethodIDOf(
      _classRef, "getPropertyByteArray", "(Ljava/lang/String;)[B");

  /// from: public native byte[] getPropertyByteArray(java.lang.String propertyName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a MediaDrm byte array property value, given the property name string.
  ///
  /// Standard fields names are \#PROPERTY_DEVICE_UNIQUE_ID
  ///@param propertyName Value is android.media.MediaDrm\#PROPERTY_DEVICE_UNIQUE_ID
  ///@return This value will never be {@code null}.
  jni.JniObject getPropertyByteArray(jni.JniString propertyName) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPropertyByteArray,
          jni.JniType.objectType,
          [propertyName.reference]).object);

  static final _id_setPropertyByteArray = jniAccessors.getMethodIDOf(
      _classRef, "setPropertyByteArray", "(Ljava/lang/String;[B)V");

  /// from: public native void setPropertyByteArray(java.lang.String propertyName, byte[] value)
  ///
  /// Set a MediaDrm byte array property value, given the property name string
  /// and new value for the property.
  ///@param propertyName This value must never be {@code null}.
  ///
  /// Value is android.media.MediaDrm\#PROPERTY_DEVICE_UNIQUE_ID
  ///@param value This value must never be {@code null}.
  void setPropertyByteArray(jni.JniString propertyName, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPropertyByteArray,
          jni.JniType.voidType,
          [propertyName.reference, value.reference]).check();

  static final _id_getMetrics = jniAccessors.getMethodIDOf(
      _classRef, "getMetrics", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getMetrics()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return Metrics data about the current MediaDrm instance.
  ///@return a PersistableBundle containing the set of attributes and values
  /// available for this instance of MediaDrm.
  /// The attributes are described in MetricsConstants.
  ///
  /// Additional vendor-specific fields may also be present in
  /// the return value.
  persistablebundle_.PersistableBundle getMetrics() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getMetrics, jni.JniType.objectType, []).object);

  static final _id_getCryptoSession = jniAccessors.getMethodIDOf(
      _classRef,
      "getCryptoSession",
      "([BLjava/lang/String;Ljava/lang/String;)Landroid/media/MediaDrm\$CryptoSession;");

  /// from: public android.media.MediaDrm.CryptoSession getCryptoSession(byte[] sessionId, java.lang.String cipherAlgorithm, java.lang.String macAlgorithm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a CryptoSession object which can be used to encrypt, decrypt,
  /// sign and verify messages or data using the session keys established
  /// for the session using methods \#getKeyRequest and
  /// \#provideKeyResponse using a session key server.
  ///@param sessionId the session ID for the session containing keys
  /// to be used for encrypt, decrypt, sign and/or verify
  /// This value must never be {@code null}.
  ///@param cipherAlgorithm the algorithm to use for encryption and
  /// decryption ciphers. The algorithm string conforms to JCA Standard
  /// Names for Cipher Transforms and is case insensitive.  For example
  /// "AES/CBC/NoPadding".
  /// This value must never be {@code null}.
  ///@param macAlgorithm the algorithm to use for sign and verify
  /// The algorithm string conforms to JCA Standard Names for Mac
  /// Algorithms and is case insensitive.  For example "HmacSHA256".
  ///
  /// The list of supported algorithms for a DRM plugin can be obtained
  /// using the method \#getPropertyString with the property name
  /// "algorithms".
  ///
  /// This value must never be {@code null}.
  MediaDrm_CryptoSession getCryptoSession(jni.JniObject sessionId,
          jni.JniString cipherAlgorithm, jni.JniString macAlgorithm) =>
      MediaDrm_CryptoSession.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCryptoSession, jni.JniType.objectType, [
        sessionId.reference,
        cipherAlgorithm.reference,
        macAlgorithm.reference
      ]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Releases resources associated with the current session of
  /// MediaDrm. It is considered good practice to call this method when
  /// the MediaDrm object is no longer needed in your
  /// application. After this method is called, MediaDrm is no
  /// longer usable since it has lost all of its required resource.
  ///
  /// This method was added in API 28. In API versions 18 through 27, release()
  /// should be called instead. There is no need to do anything for API
  /// versions prior to 18.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// @deprecated replaced by \#close().
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();
}

/// from: android.media.MediaDrm$ProvisionRequest
///
/// Contains the opaque data an app uses to request a certificate from a provisioning
/// server
class MediaDrm_ProvisionRequest extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaDrm\$ProvisionRequest");
  MediaDrm_ProvisionRequest.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getData =
      jniAccessors.getMethodIDOf(_classRef, "getData", "()[B");

  /// from: public byte[] getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the opaque message data
  ///@return This value will never be {@code null}.
  jni.JniObject getData() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getData, jni.JniType.objectType, []).object);

  static final _id_getDefaultUrl = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultUrl", "()Ljava/lang/String;");

  /// from: public java.lang.String getDefaultUrl()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the default URL to use when sending the provision request
  /// message to a server, if known. The app may prefer to use a different
  /// provisioning server URL obtained from other sources.
  /// This method returns an empty string if the default URL is not known.
  ///@return This value will never be {@code null}.
  jni.JniString getDefaultUrl() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDefaultUrl, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaDrm$OnKeyStatusChangeListener
///
/// Interface definition for a callback to be invoked when the keys in a drm
/// session change states.
class MediaDrm_OnKeyStatusChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaDrm\$OnKeyStatusChangeListener");
  MediaDrm_OnKeyStatusChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onKeyStatusChange = jniAccessors.getMethodIDOf(_classRef,
      "onKeyStatusChange", "(Landroid/media/MediaDrm;[BLjava/util/List;Z)V");

  /// from: public abstract void onKeyStatusChange(android.media.MediaDrm md, byte[] sessionId, java.util.List<android.media.MediaDrm.KeyStatus> keyInformation, boolean hasNewUsableKey)
  ///
  /// Called when the keys in a session change status, such as when the license
  /// is renewed or expires.
  ///@param md the MediaDrm object on which the event occurred
  /// This value must never be {@code null}.
  ///@param sessionId the DRM session ID on which the event occurred
  /// This value must never be {@code null}.
  ///@param keyInformation a list of MediaDrm.KeyStatus
  ///     instances indicating the status for each key in the session
  /// This value must never be {@code null}.
  ///@param hasNewUsableKey indicates if a key has been added that is usable,
  ///     which may trigger an attempt to resume playback on the media stream
  ///     if it is currently blocked waiting for a key.
  void onKeyStatusChange(MediaDrm md, jni.JniObject sessionId,
          jni.JniObject keyInformation, bool hasNewUsableKey) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onKeyStatusChange, jni.JniType.voidType, [
        md.reference,
        sessionId.reference,
        keyInformation.reference,
        hasNewUsableKey
      ]).check();
}

/// from: android.media.MediaDrm$OnExpirationUpdateListener
///
/// Interface definition for a callback to be invoked when a drm session
/// expiration update occurs
class MediaDrm_OnExpirationUpdateListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaDrm\$OnExpirationUpdateListener");
  MediaDrm_OnExpirationUpdateListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onExpirationUpdate = jniAccessors.getMethodIDOf(
      _classRef, "onExpirationUpdate", "(Landroid/media/MediaDrm;[BJ)V");

  /// from: public abstract void onExpirationUpdate(android.media.MediaDrm md, byte[] sessionId, long expirationTime)
  ///
  /// Called when a session expiration update occurs, to inform the app
  /// about the change in expiration time
  ///@param md the MediaDrm object on which the event occurred
  /// This value must never be {@code null}.
  ///@param sessionId the DRM session ID on which the event occurred
  /// This value must never be {@code null}.
  ///@param expirationTime the new expiration time for the keys in the session.
  ///     The time is in milliseconds, relative to the Unix epoch.  A time of
  ///     0 indicates that the keys never expire.
  void onExpirationUpdate(
          MediaDrm md, jni.JniObject sessionId, int expirationTime) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onExpirationUpdate,
          jni.JniType.voidType,
          [md.reference, sessionId.reference, expirationTime]).check();
}

/// from: android.media.MediaDrm$OnEventListener
///
/// Interface definition for a callback to be invoked when a drm event
/// occurs
class MediaDrm_OnEventListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaDrm\$OnEventListener");
  MediaDrm_OnEventListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onEvent = jniAccessors.getMethodIDOf(
      _classRef, "onEvent", "(Landroid/media/MediaDrm;[BII[B)V");

  /// from: public abstract void onEvent(android.media.MediaDrm md, byte[] sessionId, int event, int extra, byte[] data)
  ///
  /// Called when an event occurs that requires the app to be notified
  ///@param md the MediaDrm object on which the event occurred
  /// This value must never be {@code null}.
  ///@param sessionId the DRM session ID on which the event occurred,
  ///        or {@code null} if there is no session ID associated with the event.
  /// This value may be {@code null}.
  ///@param event indicates the event type
  /// Value is android.media.MediaDrm\#EVENT_PROVISION_REQUIRED, android.media.MediaDrm\#EVENT_KEY_REQUIRED, android.media.MediaDrm\#EVENT_KEY_EXPIRED, android.media.MediaDrm\#EVENT_VENDOR_DEFINED, or android.media.MediaDrm\#EVENT_SESSION_RECLAIMED
  ///@param extra an secondary error code
  ///@param data optional byte array of data that may be associated with the event
  ///
  /// This value may be {@code null}.
  void onEvent(MediaDrm md, jni.JniObject sessionId, int event, int extra,
          jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onEvent, jni.JniType.voidType, [
        md.reference,
        sessionId.reference,
        event,
        extra,
        data.reference
      ]).check();
}

/// from: android.media.MediaDrm$MetricsConstants
///
/// Definitions for the metrics that are reported via the
/// \#getMetrics call.
class MediaDrm_MetricsConstants extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaDrm\$MetricsConstants");
  MediaDrm_MetricsConstants.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CLOSE_SESSION_ERROR_COUNT
  ///
  /// Key to extract the number of failed \#closeSession calls
  /// from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const CLOSE_SESSION_ERROR_COUNT =
      "drm.mediadrm.close_session.error.count";

  /// from: static public final java.lang.String CLOSE_SESSION_ERROR_LIST
  ///
  /// Key to extract the list of error codes that were returned from
  /// \#closeSession calls. The key is used to lookup the list
  /// in the PersistableBundle returned by a \#getMetrics
  /// call.
  /// The list is an array of Long values
  /// (android.os.BaseBundle\#getLongArray).
  static const CLOSE_SESSION_ERROR_LIST =
      "drm.mediadrm.close_session.error.list";

  /// from: static public final java.lang.String CLOSE_SESSION_OK_COUNT
  ///
  /// Key to extract the number of successful \#closeSession calls
  /// from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const CLOSE_SESSION_OK_COUNT = "drm.mediadrm.close_session.ok.count";

  /// from: static public final java.lang.String EVENT_KEY_EXPIRED_COUNT
  ///
  /// Key to extract the count of OnEventListener\#onEvent
  /// calls of type KEY_EXPIRED occured. The count is
  /// extracted from the PersistableBundle returned from a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const EVENT_KEY_EXPIRED_COUNT = "drm.mediadrm.event.KEY_EXPIRED.count";

  /// from: static public final java.lang.String EVENT_KEY_NEEDED_COUNT
  ///
  /// Key to extract the count of OnEventListener\#onEvent
  /// calls of type KEY_NEEDED occured. The count is
  /// extracted from the PersistableBundle returned from a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const EVENT_KEY_NEEDED_COUNT = "drm.mediadrm.event.KEY_NEEDED.count";

  /// from: static public final java.lang.String EVENT_PROVISION_REQUIRED_COUNT
  ///
  /// Key to extract the count of OnEventListener\#onEvent
  /// calls of type PROVISION_REQUIRED occured. The count is
  /// extracted from the PersistableBundle returned from a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const EVENT_PROVISION_REQUIRED_COUNT =
      "drm.mediadrm.event.PROVISION_REQUIRED.count";

  /// from: static public final java.lang.String EVENT_SESSION_RECLAIMED_COUNT
  ///
  /// Key to extract the count of OnEventListener\#onEvent
  /// calls of type SESSION_RECLAIMED. The count is
  /// extracted from the PersistableBundle returned from a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const EVENT_SESSION_RECLAIMED_COUNT =
      "drm.mediadrm.event.SESSION_RECLAIMED.count";

  /// from: static public final java.lang.String EVENT_VENDOR_DEFINED_COUNT
  ///
  /// Key to extract the count of OnEventListener\#onEvent
  /// calls of type VENDOR_DEFINED. The count is
  /// extracted from the PersistableBundle returned from a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const EVENT_VENDOR_DEFINED_COUNT =
      "drm.mediadrm.event.VENDOR_DEFINED.count";

  /// from: static public final java.lang.String GET_DEVICE_UNIQUE_ID_ERROR_COUNT
  ///
  /// Key to extract the number of failed
  /// \#getPropertyByteArray calls were made with the
  /// \#PROPERTY_DEVICE_UNIQUE_ID value. The key is used to lookup
  /// the value in the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const GET_DEVICE_UNIQUE_ID_ERROR_COUNT =
      "drm.mediadrm.get_device_unique_id.error.count";

  /// from: static public final java.lang.String GET_DEVICE_UNIQUE_ID_ERROR_LIST
  ///
  /// Key to extract the list of error codes that were returned from
  /// \#getPropertyByteArray calls with the
  /// \#PROPERTY_DEVICE_UNIQUE_ID value. The key is used to lookup
  /// the list in the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The list is an array of Long values
  /// (android.os.BaseBundle\#getLongArray).
  static const GET_DEVICE_UNIQUE_ID_ERROR_LIST =
      "drm.mediadrm.get_device_unique_id.error.list";

  /// from: static public final java.lang.String GET_DEVICE_UNIQUE_ID_OK_COUNT
  ///
  /// Key to extract the number of successful
  /// \#getPropertyByteArray calls were made with the
  /// \#PROPERTY_DEVICE_UNIQUE_ID value. The key is used to lookup
  /// the value in the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const GET_DEVICE_UNIQUE_ID_OK_COUNT =
      "drm.mediadrm.get_device_unique_id.ok.count";

  /// from: static public final java.lang.String GET_KEY_REQUEST_ERROR_COUNT
  ///
  /// Key to extract the number of failed \#getKeyRequest
  /// calls from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const GET_KEY_REQUEST_ERROR_COUNT =
      "drm.mediadrm.get_key_request.error.count";

  /// from: static public final java.lang.String GET_KEY_REQUEST_ERROR_LIST
  ///
  /// Key to extract the list of error codes that were returned from
  /// \#getKeyRequest calls. The key is used to lookup the list
  /// in the PersistableBundle returned by a \#getMetrics
  /// call.
  /// The list is an array of Long values
  /// (android.os.BaseBundle\#getLongArray).
  static const GET_KEY_REQUEST_ERROR_LIST =
      "drm.mediadrm.get_key_request.error.list";

  /// from: static public final java.lang.String GET_KEY_REQUEST_OK_COUNT
  ///
  /// Key to extract the number of successful \#getKeyRequest calls
  /// from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const GET_KEY_REQUEST_OK_COUNT =
      "drm.mediadrm.get_key_request.ok.count";

  /// from: static public final java.lang.String GET_KEY_REQUEST_OK_TIME_MICROS
  ///
  /// Key to extract the average time in microseconds of calls to
  /// \#getKeyRequest. The value is retrieved from the
  /// PersistableBundle returned from \#getMetrics.
  /// The time is a Long value (android.os.BaseBundle\#getLong).
  static const GET_KEY_REQUEST_OK_TIME_MICROS =
      "drm.mediadrm.get_key_request.ok.average_time_micros";

  /// from: static public final java.lang.String GET_PROVISION_REQUEST_ERROR_COUNT
  ///
  /// Key to extract the number of failed \#getProvisionRequest
  /// calls from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const GET_PROVISION_REQUEST_ERROR_COUNT =
      "drm.mediadrm.get_provision_request.error.count";

  /// from: static public final java.lang.String GET_PROVISION_REQUEST_ERROR_LIST
  ///
  /// Key to extract the list of error codes that were returned from
  /// \#getProvisionRequest calls. The key is used to lookup the
  /// list in the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The list is an array of Long values
  /// (android.os.BaseBundle\#getLongArray).
  static const GET_PROVISION_REQUEST_ERROR_LIST =
      "drm.mediadrm.get_provision_request.error.list";

  /// from: static public final java.lang.String GET_PROVISION_REQUEST_OK_COUNT
  ///
  /// Key to extract the number of successful \#getProvisionRequest
  /// calls from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const GET_PROVISION_REQUEST_OK_COUNT =
      "drm.mediadrm.get_provision_request.ok.count";

  /// from: static public final java.lang.String KEY_STATUS_EXPIRED_COUNT
  ///
  /// Key to extraact the count of KeyStatus\#STATUS_EXPIRED events
  /// that occured. The count is extracted from the
  /// PersistableBundle returned from a \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const KEY_STATUS_EXPIRED_COUNT =
      "drm.mediadrm.key_status.EXPIRED.count";

  /// from: static public final java.lang.String KEY_STATUS_INTERNAL_ERROR_COUNT
  ///
  /// Key to extract the count of KeyStatus\#STATUS_INTERNAL_ERROR
  /// events that occured. The count is extracted from the
  /// PersistableBundle returned from a \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const KEY_STATUS_INTERNAL_ERROR_COUNT =
      "drm.mediadrm.key_status.INTERNAL_ERROR.count";

  /// from: static public final java.lang.String KEY_STATUS_OUTPUT_NOT_ALLOWED_COUNT
  ///
  /// Key to extract the count of
  /// KeyStatus\#STATUS_OUTPUT_NOT_ALLOWED events that occured.
  /// The count is extracted from the
  /// PersistableBundle returned from a \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const KEY_STATUS_OUTPUT_NOT_ALLOWED_COUNT =
      "drm.mediadrm.key_status_change.OUTPUT_NOT_ALLOWED.count";

  /// from: static public final java.lang.String KEY_STATUS_PENDING_COUNT
  ///
  /// Key to extract the count of KeyStatus\#STATUS_PENDING
  /// events that occured. The count is extracted from the
  /// PersistableBundle returned from a \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const KEY_STATUS_PENDING_COUNT =
      "drm.mediadrm.key_status_change.PENDING.count";

  /// from: static public final java.lang.String KEY_STATUS_USABLE_COUNT
  ///
  /// Key to extract the count of KeyStatus\#STATUS_USABLE
  /// events that occured. The count is extracted from the
  /// PersistableBundle returned from a \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const KEY_STATUS_USABLE_COUNT =
      "drm.mediadrm.key_status_change.USABLE.count";

  /// from: static public final java.lang.String OPEN_SESSION_ERROR_COUNT
  ///
  /// Key to extract the number of failed \#openSession calls
  /// from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const OPEN_SESSION_ERROR_COUNT =
      "drm.mediadrm.open_session.error.count";

  /// from: static public final java.lang.String OPEN_SESSION_ERROR_LIST
  ///
  /// Key to extract the list of error codes that were returned from
  /// \#openSession calls. The key is used to lookup the list
  /// in the PersistableBundle returned by a \#getMetrics
  /// call.
  /// The list is an array of Long values
  /// (android.os.BaseBundle\#getLongArray).
  static const OPEN_SESSION_ERROR_LIST = "drm.mediadrm.open_session.error.list";

  /// from: static public final java.lang.String OPEN_SESSION_OK_COUNT
  ///
  /// Key to extract the number of successful \#openSession calls
  /// from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const OPEN_SESSION_OK_COUNT = "drm.mediadrm.open_session.ok.count";

  /// from: static public final java.lang.String PROVIDE_KEY_RESPONSE_ERROR_COUNT
  ///
  /// Key to extract the number of failed \#provideKeyResponse
  /// calls from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const PROVIDE_KEY_RESPONSE_ERROR_COUNT =
      "drm.mediadrm.provide_key_response.error.count";

  /// from: static public final java.lang.String PROVIDE_KEY_RESPONSE_ERROR_LIST
  ///
  /// Key to extract the list of error codes that were returned from
  /// \#provideKeyResponse calls. The key is used to lookup the
  /// list in the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The list is an array of Long values
  /// (android.os.BaseBundle\#getLongArray).
  static const PROVIDE_KEY_RESPONSE_ERROR_LIST =
      "drm.mediadrm.provide_key_response.error.list";

  /// from: static public final java.lang.String PROVIDE_KEY_RESPONSE_OK_COUNT
  ///
  /// Key to extract the number of successful \#provideKeyResponse
  /// calls from the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const PROVIDE_KEY_RESPONSE_OK_COUNT =
      "drm.mediadrm.provide_key_response.ok.count";

  /// from: static public final java.lang.String PROVIDE_KEY_RESPONSE_OK_TIME_MICROS
  ///
  /// Key to extract the average time in microseconds of calls to
  /// \#provideKeyResponse. The valus is retrieved from the
  /// PersistableBundle returned from \#getMetrics.
  /// The time is a Long value (android.os.BaseBundle\#getLong).
  static const PROVIDE_KEY_RESPONSE_OK_TIME_MICROS =
      "drm.mediadrm.provide_key_response.ok.average_time_micros";

  /// from: static public final java.lang.String PROVIDE_PROVISION_RESPONSE_ERROR_COUNT
  ///
  /// Key to extract the number of failed
  /// \#provideProvisionResponse calls from the
  /// PersistableBundle returned by a \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const PROVIDE_PROVISION_RESPONSE_ERROR_COUNT =
      "drm.mediadrm.provide_provision_response.error.count";

  /// from: static public final java.lang.String PROVIDE_PROVISION_RESPONSE_ERROR_LIST
  ///
  /// Key to extract the list of error codes that were returned from
  /// \#provideProvisionResponse calls. The key is used to lookup
  /// the list in the PersistableBundle returned by a
  /// \#getMetrics call.
  /// The list is an array of Long values
  /// (android.os.BaseBundle\#getLongArray).
  static const PROVIDE_PROVISION_RESPONSE_ERROR_LIST =
      "drm.mediadrm.provide_provision_response.error.list";

  /// from: static public final java.lang.String PROVIDE_PROVISION_RESPONSE_OK_COUNT
  ///
  /// Key to extract the number of successful
  /// \#provideProvisionResponse calls from the
  /// PersistableBundle returned by a \#getMetrics call.
  /// The count is a Long value (android.os.BaseBundle\#getLong).
  static const PROVIDE_PROVISION_RESPONSE_OK_COUNT =
      "drm.mediadrm.provide_provision_response.ok.count";

  /// from: static public final java.lang.String SESSION_END_TIMES_MS
  ///
  /// Key to extract the end times of sessions. Times are
  /// represented as milliseconds since epoch (1970-01-01T00:00:00Z).
  /// The end times are returned from the PersistableBundle
  /// from a \#getMetrics call.
  /// The end times are returned as another PersistableBundle
  /// containing the session ids as keys and the end times as long
  /// values. Use android.os.BaseBundle\#keySet to get the list of
  /// session ids, and then android.os.BaseBundle\#getLong to get
  /// the end time for each session.
  static const SESSION_END_TIMES_MS = "drm.mediadrm.session_end_times_ms";

  /// from: static public final java.lang.String SESSION_START_TIMES_MS
  ///
  /// Key to extract the start times of sessions. Times are
  /// represented as milliseconds since epoch (1970-01-01T00:00:00Z).
  /// The start times are returned from the PersistableBundle
  /// from a \#getMetrics call.
  /// The start times are returned as another PersistableBundle
  /// containing the session ids as keys and the start times as long
  /// values. Use android.os.BaseBundle\#keySet to get the list of
  /// session ids, and then android.os.BaseBundle\#getLong to get
  /// the start time for each session.
  static const SESSION_START_TIMES_MS = "drm.mediadrm.session_start_times_ms";
}

/// from: android.media.MediaDrm$MediaDrmStateException
///
/// Thrown when an unrecoverable failure occurs during a MediaDrm operation.
/// Extends java.lang.IllegalStateException with the addition of an error
/// code that may be useful in diagnosing the failure.
class MediaDrm_MediaDrmStateException extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaDrm\$MediaDrmStateException");
  MediaDrm_MediaDrmStateException.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getDiagnosticInfo = jniAccessors.getMethodIDOf(
      _classRef, "getDiagnosticInfo", "()Ljava/lang/String;");

  /// from: public java.lang.String getDiagnosticInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a developer-readable diagnostic information string
  /// associated with the exception. Do not show this to end-users,
  /// since this string will not be localized or generally comprehensible
  /// to end-users.
  ///@return This value will never be {@code null}.
  jni.JniString getDiagnosticInfo() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDiagnosticInfo, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaDrm$KeyStatus
///
/// Defines the status of a key.
/// A KeyStatus for each key in a session is provided to the
/// OnKeyStatusChangeListener\#onKeyStatusChange
/// listener.
class MediaDrm_KeyStatus extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaDrm\$KeyStatus");
  MediaDrm_KeyStatus.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int STATUS_EXPIRED
  ///
  /// The key is no longer usable to decrypt media data because its
  /// expiration time has passed.
  static const STATUS_EXPIRED = 1;

  /// from: static public final int STATUS_INTERNAL_ERROR
  ///
  /// The key is not currently usable to decrypt media data because of an
  /// internal error in processing unrelated to input parameters.  This error
  /// is not actionable by an app.
  static const STATUS_INTERNAL_ERROR = 4;

  /// from: static public final int STATUS_OUTPUT_NOT_ALLOWED
  ///
  /// The key is not currently usable to decrypt media data because its
  /// output requirements cannot currently be met.
  static const STATUS_OUTPUT_NOT_ALLOWED = 2;

  /// from: static public final int STATUS_PENDING
  ///
  /// The status of the key is not yet known and is being determined.
  /// The status will be updated with the actual status when it has
  /// been determined.
  static const STATUS_PENDING = 3;

  /// from: static public final int STATUS_USABLE
  ///
  /// The key is currently usable to decrypt media data
  static const STATUS_USABLE = 0;

  static final _id_getStatusCode =
      jniAccessors.getMethodIDOf(_classRef, "getStatusCode", "()I");

  /// from: public int getStatusCode()
  ///
  /// Returns the status code for the key
  ///@return one of \#STATUS_USABLE, \#STATUS_EXPIRED,
  /// \#STATUS_OUTPUT_NOT_ALLOWED, \#STATUS_PENDING
  /// or \#STATUS_INTERNAL_ERROR.
  ///
  /// Value is android.media.MediaDrm.KeyStatus\#STATUS_USABLE, android.media.MediaDrm.KeyStatus\#STATUS_EXPIRED, android.media.MediaDrm.KeyStatus\#STATUS_OUTPUT_NOT_ALLOWED, android.media.MediaDrm.KeyStatus\#STATUS_PENDING, or android.media.MediaDrm.KeyStatus\#STATUS_INTERNAL_ERROR
  int getStatusCode() => jniAccessors.callMethodWithArgs(
      reference, _id_getStatusCode, jni.JniType.intType, []).integer;

  static final _id_getKeyId =
      jniAccessors.getMethodIDOf(_classRef, "getKeyId", "()[B");

  /// from: public byte[] getKeyId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the id for the key
  ///@return This value will never be {@code null}.
  jni.JniObject getKeyId() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeyId, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaDrm$KeyRequest
///
/// Contains the opaque data an app uses to request keys from a license server.
/// These request types may or may not be generated by a given plugin. Refer
/// to plugin vendor documentation for more information.
class MediaDrm_KeyRequest extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaDrm\$KeyRequest");
  MediaDrm_KeyRequest.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int REQUEST_TYPE_INITIAL
  ///
  /// Key request type is initial license request. A license request
  /// is necessary to load keys.
  static const REQUEST_TYPE_INITIAL = 0;

  /// from: static public final int REQUEST_TYPE_NONE
  ///
  /// Keys are already loaded and are available for use. No license request is necessary, and
  /// no key request data is returned.
  static const REQUEST_TYPE_NONE = 3;

  /// from: static public final int REQUEST_TYPE_RELEASE
  ///
  /// Key request type is license release
  static const REQUEST_TYPE_RELEASE = 2;

  /// from: static public final int REQUEST_TYPE_RENEWAL
  ///
  /// Key request type is license renewal. A license request is
  /// necessary to prevent the keys from expiring.
  static const REQUEST_TYPE_RENEWAL = 1;

  /// from: static public final int REQUEST_TYPE_UPDATE
  ///
  /// Keys have been loaded but an additional license request is needed
  /// to update their values.
  static const REQUEST_TYPE_UPDATE = 4;

  static final _id_getData =
      jniAccessors.getMethodIDOf(_classRef, "getData", "()[B");

  /// from: public byte[] getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the opaque message data
  ///@return This value will never be {@code null}.
  jni.JniObject getData() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getData, jni.JniType.objectType, []).object);

  static final _id_getDefaultUrl = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultUrl", "()Ljava/lang/String;");

  /// from: public java.lang.String getDefaultUrl()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the default URL to use when sending the key request message to a
  /// server, if known.  The app may prefer to use a different license
  /// server URL from other sources.
  /// This method returns an empty string if the default URL is not known.
  ///@return This value will never be {@code null}.
  jni.JniString getDefaultUrl() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDefaultUrl, jni.JniType.objectType, []).object);

  static final _id_getRequestType =
      jniAccessors.getMethodIDOf(_classRef, "getRequestType", "()I");

  /// from: public int getRequestType()
  ///
  /// Get the type of the request
  ///@return one of \#REQUEST_TYPE_INITIAL,
  /// \#REQUEST_TYPE_RENEWAL, \#REQUEST_TYPE_RELEASE,
  /// \#REQUEST_TYPE_NONE or \#REQUEST_TYPE_UPDATE
  ///
  /// Value is android.media.MediaDrm.KeyRequest\#REQUEST_TYPE_INITIAL, android.media.MediaDrm.KeyRequest\#REQUEST_TYPE_RENEWAL, android.media.MediaDrm.KeyRequest\#REQUEST_TYPE_RELEASE, android.media.MediaDrm.KeyRequest\#REQUEST_TYPE_NONE, or android.media.MediaDrm.KeyRequest\#REQUEST_TYPE_UPDATE
  int getRequestType() => jniAccessors.callMethodWithArgs(
      reference, _id_getRequestType, jni.JniType.intType, []).integer;
}

/// from: android.media.MediaDrm$CryptoSession
///
/// In addition to supporting decryption of DASH Common Encrypted Media, the
/// MediaDrm APIs provide the ability to securely deliver session keys from
/// an operator's session key server to a client device, based on the factory-installed
/// root of trust, and then perform encrypt, decrypt, sign and verify operations
/// with the session key on arbitrary user data.
///
/// The CryptoSession class implements generic encrypt/decrypt/sign/verify methods
/// based on the established session keys.  These keys are exchanged using the
/// getKeyRequest/provideKeyResponse methods.
///
/// Applications of this capability could include securing various types of
/// purchased or private content, such as applications, books and other media,
/// photos or media delivery protocols.
///
/// Operators can create session key servers that are functionally similar to a
/// license key server, except that instead of receiving license key requests and
/// providing encrypted content keys which are used specifically to decrypt A/V media
/// content, the session key server receives session key requests and provides
/// encrypted session keys which can be used for general purpose crypto operations.
///
/// A CryptoSession is obtained using \#getCryptoSession
class MediaDrm_CryptoSession extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaDrm\$CryptoSession");
  MediaDrm_CryptoSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_encrypt =
      jniAccessors.getMethodIDOf(_classRef, "encrypt", "([B[B[B)[B");

  /// from: public byte[] encrypt(byte[] keyid, byte[] input, byte[] iv)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Encrypt data using the CryptoSession's cipher algorithm
  ///@param keyid specifies which key to use
  /// This value must never be {@code null}.
  ///@param input the data to encrypt
  /// This value must never be {@code null}.
  ///@param iv the initialization vector to use for the cipher
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject encrypt(
          jni.JniObject keyid, jni.JniObject input, jni.JniObject iv) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_encrypt,
          jni.JniType.objectType,
          [keyid.reference, input.reference, iv.reference]).object);

  static final _id_decrypt =
      jniAccessors.getMethodIDOf(_classRef, "decrypt", "([B[B[B)[B");

  /// from: public byte[] decrypt(byte[] keyid, byte[] input, byte[] iv)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Decrypt data using the CryptoSessions's cipher algorithm
  ///@param keyid specifies which key to use
  /// This value must never be {@code null}.
  ///@param input the data to encrypt
  /// This value must never be {@code null}.
  ///@param iv the initialization vector to use for the cipher
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject decrypt(
          jni.JniObject keyid, jni.JniObject input, jni.JniObject iv) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_decrypt,
          jni.JniType.objectType,
          [keyid.reference, input.reference, iv.reference]).object);

  static final _id_sign =
      jniAccessors.getMethodIDOf(_classRef, "sign", "([B[B)[B");

  /// from: public byte[] sign(byte[] keyid, byte[] message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sign data using the CryptoSessions's mac algorithm.
  ///@param keyid specifies which key to use
  /// This value must never be {@code null}.
  ///@param message the data for which a signature is to be computed
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject sign(jni.JniObject keyid, jni.JniObject message) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference, _id_sign,
          jni.JniType.objectType, [keyid.reference, message.reference]).object);

  static final _id_verify =
      jniAccessors.getMethodIDOf(_classRef, "verify", "([B[B[B)Z");

  /// from: public boolean verify(byte[] keyid, byte[] message, byte[] signature)
  ///
  /// Verify a signature using the CryptoSessions's mac algorithm. Return true
  /// if the signatures match, false if they do no.
  ///@param keyid specifies which key to use
  /// This value must never be {@code null}.
  ///@param message the data to verify
  /// This value must never be {@code null}.
  ///@param signature the reference signature which will be compared with the
  ///        computed signature
  ///
  /// This value must never be {@code null}.
  bool verify(jni.JniObject keyid, jni.JniObject message,
          jni.JniObject signature) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_verify,
          jni.JniType.booleanType,
          [keyid.reference, message.reference, signature.reference]).boolean;
}
