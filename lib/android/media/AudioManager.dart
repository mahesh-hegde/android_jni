// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/KeyEvent.dart" as keyevent_;

import "AudioFocusRequest.dart" as audiofocusrequest_;

import "../content/ComponentName.dart" as componentname_;

import "../app/PendingIntent.dart" as pendingintent_;

import "RemoteControlClient.dart" as remotecontrolclient_;

import "RemoteController.dart" as remotecontroller_;

import "../os/Handler.dart" as handler_;

import "AudioDeviceCallback.dart" as audiodevicecallback_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.AudioManager
///
/// AudioManager provides access to volume and ringer mode control.
class AudioManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/AudioManager");
  AudioManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_AUDIO_BECOMING_NOISY
  ///
  /// Broadcast intent, a hint for applications that audio is about to become
  /// 'noisy' due to a change in audio outputs. For example, this intent may
  /// be sent when a wired headset is unplugged, or when an A2DP audio
  /// sink is disconnected, and the audio system is about to automatically
  /// switch audio route to the speaker. Applications that are controlling
  /// audio streams may consider pausing, reducing volume or some other action
  /// on receipt of this intent so as not to surprise the user with audio
  /// from the speaker.
  static const ACTION_AUDIO_BECOMING_NOISY =
      "android.media.AUDIO_BECOMING_NOISY";

  /// from: static public final java.lang.String ACTION_HDMI_AUDIO_PLUG
  ///
  /// Broadcast Action: A sticky broadcast indicating an HDMI cable was plugged or unplugged.
  ///
  /// The intent will have the following extra values: \#EXTRA_AUDIO_PLUG_STATE,
  /// \#EXTRA_MAX_CHANNEL_COUNT, \#EXTRA_ENCODINGS.
  /// It can only be received by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter).
  static const ACTION_HDMI_AUDIO_PLUG = "android.media.action.HDMI_AUDIO_PLUG";

  /// from: static public final java.lang.String ACTION_HEADSET_PLUG
  ///
  /// Broadcast Action: Wired Headset plugged in or unplugged.
  ///
  /// You _cannot_ receive this through components declared
  /// in manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// The intent will have the following extra values:
  /// <ul>
  ///   <li>_state_ - 0 for unplugged, 1 for plugged. </li>
  ///   <li>_name_ - Headset type, human readable string </li>
  ///   <li>_microphone_ - 1 if headset has a microphone, 0 otherwise </li>
  /// </ul>
  /// </ul>
  static const ACTION_HEADSET_PLUG = "android.intent.action.HEADSET_PLUG";

  /// from: static public final java.lang.String ACTION_MICROPHONE_MUTE_CHANGED
  ///
  /// Broadcast Action: microphone muting state changed.
  ///
  /// You _cannot_ receive this through components declared
  /// in manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// The intent has no extra values, use \#isMicrophoneMute to check whether the
  /// microphone is muted.
  static const ACTION_MICROPHONE_MUTE_CHANGED =
      "android.media.action.MICROPHONE_MUTE_CHANGED";

  /// from: static public final java.lang.String ACTION_SCO_AUDIO_STATE_CHANGED
  ///
  /// Sticky broadcast intent action indicating that the Bluetooth SCO audio
  /// connection state has changed. The intent contains on extra \#EXTRA_SCO_AUDIO_STATE
  /// indicating the new state which is either \#SCO_AUDIO_STATE_DISCONNECTED
  /// or \#SCO_AUDIO_STATE_CONNECTED
  ///@see \#startBluetoothSco()
  ///@deprecated Use  \#ACTION_SCO_AUDIO_STATE_UPDATED instead
  static const ACTION_SCO_AUDIO_STATE_CHANGED =
      "android.media.SCO_AUDIO_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_SCO_AUDIO_STATE_UPDATED
  ///
  /// Sticky broadcast intent action indicating that the Bluetooth SCO audio
  /// connection state has been updated.
  /// This intent has two extras:
  /// <ul>
  ///   <li> \#EXTRA_SCO_AUDIO_STATE - The new SCO audio state. </li>
  ///   <li> \#EXTRA_SCO_AUDIO_PREVIOUS_STATE- The previous SCO audio state. </li>
  /// </ul>
  ///  EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE can be any of:
  /// <ul>
  ///   <li> \#SCO_AUDIO_STATE_DISCONNECTED, </li>
  ///   <li> \#SCO_AUDIO_STATE_CONNECTING or </li>
  ///   <li> \#SCO_AUDIO_STATE_CONNECTED, </li>
  /// </ul>
  ///@see \#startBluetoothSco()
  static const ACTION_SCO_AUDIO_STATE_UPDATED =
      "android.media.ACTION_SCO_AUDIO_STATE_UPDATED";

  /// from: static public final int ADJUST_LOWER
  ///
  /// Decrease the ringer volume.
  ///@see \#adjustVolume(int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  static const ADJUST_LOWER = -1;

  /// from: static public final int ADJUST_MUTE
  ///
  /// Mute the volume. Has no effect if the stream is already muted.
  ///@see \#adjustVolume(int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  static const ADJUST_MUTE = -100;

  /// from: static public final int ADJUST_RAISE
  ///
  /// Increase the ringer volume.
  ///@see \#adjustVolume(int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  static const ADJUST_RAISE = 1;

  /// from: static public final int ADJUST_SAME
  ///
  /// Maintain the previous ringer volume. This may be useful when needing to
  /// show the volume toast without actually modifying the volume.
  ///@see \#adjustVolume(int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  static const ADJUST_SAME = 0;

  /// from: static public final int ADJUST_TOGGLE_MUTE
  ///
  /// Toggle the mute state. If muted the stream will be unmuted. If not muted
  /// the stream will be muted.
  ///@see \#adjustVolume(int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  static const ADJUST_TOGGLE_MUTE = 101;

  /// from: static public final int ADJUST_UNMUTE
  ///
  /// Unmute the volume. Has no effect if the stream is not muted.
  ///@see \#adjustVolume(int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  static const ADJUST_UNMUTE = 100;

  /// from: static public final int AUDIOFOCUS_GAIN
  ///
  /// Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.
  ///@see OnAudioFocusChangeListener\#onAudioFocusChange(int)
  ///@see \#requestAudioFocus(OnAudioFocusChangeListener, int, int)
  static const AUDIOFOCUS_GAIN = 1;

  /// from: static public final int AUDIOFOCUS_GAIN_TRANSIENT
  ///
  /// Used to indicate a temporary gain or request of audio focus, anticipated to last a short
  /// amount of time. Examples of temporary changes are the playback of driving directions, or an
  /// event notification.
  ///@see OnAudioFocusChangeListener\#onAudioFocusChange(int)
  ///@see \#requestAudioFocus(OnAudioFocusChangeListener, int, int)
  static const AUDIOFOCUS_GAIN_TRANSIENT = 2;

  /// from: static public final int AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE
  ///
  /// Used to indicate a temporary request of audio focus, anticipated to last a short
  /// amount of time, during which no other applications, or system components, should play
  /// anything. Examples of exclusive and transient audio focus requests are voice
  /// memo recording and speech recognition, during which the system shouldn't play any
  /// notifications, and media playback should have paused.
  ///@see \#requestAudioFocus(OnAudioFocusChangeListener, int, int)
  static const AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE = 4;

  /// from: static public final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK
  ///
  /// Used to indicate a temporary request of audio focus, anticipated to last a short
  /// amount of time, and where it is acceptable for other audio applications to keep playing
  /// after having lowered their output level (also referred to as "ducking").
  /// Examples of temporary changes are the playback of driving directions where playback of music
  /// in the background is acceptable.
  ///@see OnAudioFocusChangeListener\#onAudioFocusChange(int)
  ///@see \#requestAudioFocus(OnAudioFocusChangeListener, int, int)
  static const AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK = 3;

  /// from: static public final int AUDIOFOCUS_LOSS
  ///
  /// Used to indicate a loss of audio focus of unknown duration.
  ///@see OnAudioFocusChangeListener\#onAudioFocusChange(int)
  static const AUDIOFOCUS_LOSS = -1;

  /// from: static public final int AUDIOFOCUS_LOSS_TRANSIENT
  ///
  /// Used to indicate a transient loss of audio focus.
  ///@see OnAudioFocusChangeListener\#onAudioFocusChange(int)
  static const AUDIOFOCUS_LOSS_TRANSIENT = -2;

  /// from: static public final int AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK
  ///
  /// Used to indicate a transient loss of audio focus where the loser of the audio focus can
  /// lower its output volume if it wants to continue playing (also referred to as "ducking"), as
  /// the new focus owner doesn't require others to be silent.
  ///@see OnAudioFocusChangeListener\#onAudioFocusChange(int)
  static const AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK = -3;

  /// from: static public final int AUDIOFOCUS_NONE
  ///
  /// Used to indicate no audio focus has been gained or lost, or requested.
  static const AUDIOFOCUS_NONE = 0;

  /// from: static public final int AUDIOFOCUS_REQUEST_DELAYED
  ///
  /// A focus change request whose granting is delayed: the request was successful, but the
  /// requester will only be granted audio focus once the condition that prevented immediate
  /// granting has ended.
  /// See \#requestAudioFocus(AudioFocusRequest) and
  /// AudioFocusRequest.Builder\#setAcceptsDelayedFocusGain(boolean)
  static const AUDIOFOCUS_REQUEST_DELAYED = 2;

  /// from: static public final int AUDIOFOCUS_REQUEST_FAILED
  ///
  /// A failed focus change request.
  static const AUDIOFOCUS_REQUEST_FAILED = 0;

  /// from: static public final int AUDIOFOCUS_REQUEST_GRANTED
  ///
  /// A successful focus change request.
  static const AUDIOFOCUS_REQUEST_GRANTED = 1;

  /// from: static public final int AUDIO_SESSION_ID_GENERATE
  ///
  /// A special audio session ID to indicate that the audio session ID isn't known and the
  /// framework should generate a new value. This can be used when building a new
  /// AudioTrack instance with
  /// AudioTrack\#AudioTrack(AudioAttributes, AudioFormat, int, int, int).
  static const AUDIO_SESSION_ID_GENERATE = 0;

  /// from: static public final int ERROR
  ///
  /// A default error code.
  static const ERROR = -1;

  /// from: static public final int ERROR_DEAD_OBJECT
  ///
  /// An error code indicating that the object reporting it is no longer valid and needs to
  /// be recreated.
  static const ERROR_DEAD_OBJECT = -6;

  /// from: static public final java.lang.String EXTRA_AUDIO_PLUG_STATE
  ///
  /// Extra used in \#ACTION_HDMI_AUDIO_PLUG to communicate whether HDMI is plugged in
  /// or unplugged.
  /// An integer value of 1 indicates a plugged-in state, 0 is unplugged.
  static const EXTRA_AUDIO_PLUG_STATE = "android.media.extra.AUDIO_PLUG_STATE";

  /// from: static public final java.lang.String EXTRA_ENCODINGS
  ///
  /// Extra used in \#ACTION_HDMI_AUDIO_PLUG to define the audio encodings supported by
  /// the connected HDMI device.
  /// The corresponding array of encoding values is only available when the device is plugged in
  /// (as expressed by \#EXTRA_AUDIO_PLUG_STATE). Encoding values are defined in
  /// AudioFormat (for instance see AudioFormat\#ENCODING_PCM_16BIT). Use
  /// android.content.Intent\#getIntArrayExtra(String) to retrieve the encoding values.
  static const EXTRA_ENCODINGS = "android.media.extra.ENCODINGS";

  /// from: static public final java.lang.String EXTRA_MAX_CHANNEL_COUNT
  ///
  /// Extra used in \#ACTION_HDMI_AUDIO_PLUG to define the maximum number of channels
  /// supported by the HDMI device.
  /// The corresponding integer value is only available when the device is plugged in (as expressed
  /// by \#EXTRA_AUDIO_PLUG_STATE).
  static const EXTRA_MAX_CHANNEL_COUNT =
      "android.media.extra.MAX_CHANNEL_COUNT";

  /// from: static public final java.lang.String EXTRA_RINGER_MODE
  ///
  /// The new ringer mode.
  ///@see \#RINGER_MODE_CHANGED_ACTION
  ///@see \#RINGER_MODE_NORMAL
  ///@see \#RINGER_MODE_SILENT
  ///@see \#RINGER_MODE_VIBRATE
  static const EXTRA_RINGER_MODE = "android.media.EXTRA_RINGER_MODE";

  /// from: static public final java.lang.String EXTRA_SCO_AUDIO_PREVIOUS_STATE
  ///
  /// Extra for intent \#ACTION_SCO_AUDIO_STATE_UPDATED containing the previous
  /// bluetooth SCO connection state.
  static const EXTRA_SCO_AUDIO_PREVIOUS_STATE =
      "android.media.extra.SCO_AUDIO_PREVIOUS_STATE";

  /// from: static public final java.lang.String EXTRA_SCO_AUDIO_STATE
  ///
  /// Extra for intent \#ACTION_SCO_AUDIO_STATE_CHANGED or
  /// \#ACTION_SCO_AUDIO_STATE_UPDATED containing the new bluetooth SCO connection state.
  static const EXTRA_SCO_AUDIO_STATE = "android.media.extra.SCO_AUDIO_STATE";

  /// from: static public final java.lang.String EXTRA_VIBRATE_SETTING
  ///
  /// The new vibrate setting for a particular type.
  ///@see \#VIBRATE_SETTING_CHANGED_ACTION
  ///@see \#EXTRA_VIBRATE_TYPE
  ///@see \#VIBRATE_SETTING_ON
  ///@see \#VIBRATE_SETTING_OFF
  ///@see \#VIBRATE_SETTING_ONLY_SILENT
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode and listen to \#RINGER_MODE_CHANGED_ACTION instead.
  static const EXTRA_VIBRATE_SETTING = "android.media.EXTRA_VIBRATE_SETTING";

  /// from: static public final java.lang.String EXTRA_VIBRATE_TYPE
  ///
  /// The vibrate type whose setting has changed.
  ///@see \#VIBRATE_SETTING_CHANGED_ACTION
  ///@see \#VIBRATE_TYPE_NOTIFICATION
  ///@see \#VIBRATE_TYPE_RINGER
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode and listen to \#RINGER_MODE_CHANGED_ACTION instead.
  static const EXTRA_VIBRATE_TYPE = "android.media.EXTRA_VIBRATE_TYPE";

  /// from: static public final int FLAG_ALLOW_RINGER_MODES
  ///
  /// Whether to include ringer modes as possible options when changing volume.
  /// For example, if true and volume level is 0 and the volume is adjusted
  /// with \#ADJUST_LOWER, then the ringer mode may switch the silent or
  /// vibrate mode.
  ///
  /// By default this is on for the ring stream. If this flag is included,
  /// this behavior will be present regardless of the stream type being
  /// affected by the ringer mode.
  ///@see \#adjustVolume(int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  static const FLAG_ALLOW_RINGER_MODES = 2;

  /// from: static public final int FLAG_PLAY_SOUND
  ///
  /// Whether to play a sound when changing the volume.
  ///
  /// If this is given to \#adjustVolume(int, int) or
  /// \#adjustSuggestedStreamVolume(int, int, int), it may be ignored
  /// in some cases (for example, the decided stream type is not
  /// AudioManager\#STREAM_RING, or the volume is being adjusted
  /// downward).
  ///@see \#adjustStreamVolume(int, int, int)
  ///@see \#adjustVolume(int, int)
  ///@see \#setStreamVolume(int, int, int)
  static const FLAG_PLAY_SOUND = 4;

  /// from: static public final int FLAG_REMOVE_SOUND_AND_VIBRATE
  ///
  /// Removes any sounds/vibrate that may be in the queue, or are playing (related to
  /// changing volume).
  static const FLAG_REMOVE_SOUND_AND_VIBRATE = 8;

  /// from: static public final int FLAG_SHOW_UI
  ///
  /// Show a toast containing the current volume.
  ///@see \#adjustStreamVolume(int, int, int)
  ///@see \#adjustVolume(int, int)
  ///@see \#setStreamVolume(int, int, int)
  ///@see \#setRingerMode(int)
  static const FLAG_SHOW_UI = 1;

  /// from: static public final int FLAG_VIBRATE
  ///
  /// Whether to vibrate if going into the vibrate ringer mode.
  static const FLAG_VIBRATE = 16;

  /// from: static public final int FX_FOCUS_NAVIGATION_DOWN
  ///
  /// Focus has moved down
  ///@see \#playSoundEffect(int)
  static const FX_FOCUS_NAVIGATION_DOWN = 2;

  /// from: static public final int FX_FOCUS_NAVIGATION_LEFT
  ///
  /// Focus has moved left
  ///@see \#playSoundEffect(int)
  static const FX_FOCUS_NAVIGATION_LEFT = 3;

  /// from: static public final int FX_FOCUS_NAVIGATION_RIGHT
  ///
  /// Focus has moved right
  ///@see \#playSoundEffect(int)
  static const FX_FOCUS_NAVIGATION_RIGHT = 4;

  /// from: static public final int FX_FOCUS_NAVIGATION_UP
  ///
  /// Focus has moved up
  ///@see \#playSoundEffect(int)
  static const FX_FOCUS_NAVIGATION_UP = 1;

  /// from: static public final int FX_KEYPRESS_DELETE
  ///
  /// IME delete keypress sound
  ///@see \#playSoundEffect(int)
  static const FX_KEYPRESS_DELETE = 7;

  /// from: static public final int FX_KEYPRESS_INVALID
  ///
  /// Invalid keypress sound
  ///@see \#playSoundEffect(int)
  static const FX_KEYPRESS_INVALID = 9;

  /// from: static public final int FX_KEYPRESS_RETURN
  ///
  /// IME return_keypress sound
  ///@see \#playSoundEffect(int)
  static const FX_KEYPRESS_RETURN = 8;

  /// from: static public final int FX_KEYPRESS_SPACEBAR
  ///
  /// IME spacebar keypress sound
  ///@see \#playSoundEffect(int)
  static const FX_KEYPRESS_SPACEBAR = 6;

  /// from: static public final int FX_KEYPRESS_STANDARD
  ///
  /// IME standard keypress sound
  ///@see \#playSoundEffect(int)
  static const FX_KEYPRESS_STANDARD = 5;

  /// from: static public final int FX_KEY_CLICK
  ///
  /// Keyboard and direction pad click sound
  ///@see \#playSoundEffect(int)
  static const FX_KEY_CLICK = 0;

  /// from: static public final int GET_DEVICES_ALL
  ///
  /// Specifies to the AudioManager\#getDevices(int) method to include both
  /// source and sink devices.
  static const GET_DEVICES_ALL = 3;

  /// from: static public final int GET_DEVICES_INPUTS
  ///
  /// Specifies to the AudioManager\#getDevices(int) method to include
  /// source (i.e. input) audio devices.
  static const GET_DEVICES_INPUTS = 1;

  /// from: static public final int GET_DEVICES_OUTPUTS
  ///
  /// Specifies to the AudioManager\#getDevices(int) method to include
  /// sink (i.e. output) audio devices.
  static const GET_DEVICES_OUTPUTS = 2;

  /// from: static public final int MODE_CURRENT
  ///
  /// Current audio mode. Used to apply audio routing to current mode.
  static const MODE_CURRENT = -1;

  /// from: static public final int MODE_INVALID
  ///
  /// Invalid audio mode.
  static const MODE_INVALID = -2;

  /// from: static public final int MODE_IN_CALL
  ///
  /// In call audio mode. A telephony call is established.
  static const MODE_IN_CALL = 2;

  /// from: static public final int MODE_IN_COMMUNICATION
  ///
  /// In communication audio mode. An audio/video chat or VoIP call is established.
  static const MODE_IN_COMMUNICATION = 3;

  /// from: static public final int MODE_NORMAL
  ///
  /// Normal audio mode: not ringing and no call established.
  static const MODE_NORMAL = 0;

  /// from: static public final int MODE_RINGTONE
  ///
  /// Ringing audio mode. An incoming is being signaled.
  static const MODE_RINGTONE = 1;

  /// from: static public final int NUM_STREAMS
  ///
  /// @deprecated Do not iterate on volume stream type values.
  static const NUM_STREAMS = 5;

  /// from: static public final java.lang.String PROPERTY_OUTPUT_FRAMES_PER_BUFFER
  ///
  /// Used as a key for \#getProperty to request the native or optimal output buffer size
  /// for this device's low latency output stream, in decimal PCM frames.  Latency-sensitive apps
  /// should use this value as a minimum, and offer the user the option to override it.
  /// The low latency output stream is typically either the device's primary output stream,
  /// or another output stream with smaller buffers.
  static const PROPERTY_OUTPUT_FRAMES_PER_BUFFER =
      "android.media.property.OUTPUT_FRAMES_PER_BUFFER";

  /// from: static public final java.lang.String PROPERTY_OUTPUT_SAMPLE_RATE
  ///
  /// Used as a key for \#getProperty to request the native or optimal output sample rate
  /// for this device's low latency output stream, in decimal Hz.  Latency-sensitive apps
  /// should use this value as a default, and offer the user the option to override it.
  /// The low latency output stream is typically either the device's primary output stream,
  /// or another output stream with smaller buffers.
  static const PROPERTY_OUTPUT_SAMPLE_RATE =
      "android.media.property.OUTPUT_SAMPLE_RATE";

  /// from: static public final java.lang.String PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED
  ///
  /// Used as a key for \#getProperty to determine if the unprocessed audio source is
  /// available and supported with the expected frequency range and level response.
  static const PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED =
      "android.media.property.SUPPORT_AUDIO_SOURCE_UNPROCESSED";

  /// from: static public final java.lang.String PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND
  ///
  /// Used as a key for \#getProperty to determine if the default microphone audio source
  /// supports near-ultrasound frequencies (range of 18 - 21 kHz).
  static const PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND =
      "android.media.property.SUPPORT_MIC_NEAR_ULTRASOUND";

  /// from: static public final java.lang.String PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND
  ///
  /// Used as a key for \#getProperty to determine if the default speaker audio path
  /// supports near-ultrasound frequencies (range of 18 - 21 kHz).
  static const PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND =
      "android.media.property.SUPPORT_SPEAKER_NEAR_ULTRASOUND";

  /// from: static public final java.lang.String RINGER_MODE_CHANGED_ACTION
  ///
  /// Sticky broadcast intent action indicating that the ringer mode has
  /// changed. Includes the new ringer mode.
  ///@see \#EXTRA_RINGER_MODE
  static const RINGER_MODE_CHANGED_ACTION = "android.media.RINGER_MODE_CHANGED";

  /// from: static public final int RINGER_MODE_NORMAL
  ///
  /// Ringer mode that may be audible and may vibrate. It will be audible if
  /// the volume before changing out of this mode was audible. It will vibrate
  /// if the vibrate setting is on.
  ///@see \#setRingerMode(int)
  ///@see \#getRingerMode()
  static const RINGER_MODE_NORMAL = 2;

  /// from: static public final int RINGER_MODE_SILENT
  ///
  /// Ringer mode that will be silent and will not vibrate. (This overrides the
  /// vibrate setting.)
  ///@see \#setRingerMode(int)
  ///@see \#getRingerMode()
  static const RINGER_MODE_SILENT = 0;

  /// from: static public final int RINGER_MODE_VIBRATE
  ///
  /// Ringer mode that will be silent and will vibrate. (This will cause the
  /// phone ringer to always vibrate, but the notification vibrate to only
  /// vibrate if set.)
  ///@see \#setRingerMode(int)
  ///@see \#getRingerMode()
  static const RINGER_MODE_VIBRATE = 1;

  /// from: static public final int ROUTE_ALL
  ///
  /// Used for mask parameter of \#setRouting(int,int,int).
  ///@deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
  /// setBluetoothScoOn() methods instead.
  static const ROUTE_ALL = -1;

  /// from: static public final int ROUTE_BLUETOOTH
  ///
  /// @deprecated use \#ROUTE_BLUETOOTH_SCO
  ///@deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
  /// setBluetoothScoOn() methods instead.
  static const ROUTE_BLUETOOTH = 4;

  /// from: static public final int ROUTE_BLUETOOTH_A2DP
  ///
  /// Routing audio output to bluetooth A2DP
  ///@deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
  /// setBluetoothScoOn() methods instead.
  static const ROUTE_BLUETOOTH_A2DP = 16;

  /// from: static public final int ROUTE_BLUETOOTH_SCO
  ///
  /// Routing audio output to bluetooth SCO
  ///@deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
  /// setBluetoothScoOn() methods instead.
  static const ROUTE_BLUETOOTH_SCO = 4;

  /// from: static public final int ROUTE_EARPIECE
  ///
  /// Routing audio output to earpiece
  ///@deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
  /// setBluetoothScoOn() methods instead.
  static const ROUTE_EARPIECE = 1;

  /// from: static public final int ROUTE_HEADSET
  ///
  /// Routing audio output to headset
  ///@deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
  /// setBluetoothScoOn() methods instead.
  static const ROUTE_HEADSET = 8;

  /// from: static public final int ROUTE_SPEAKER
  ///
  /// Routing audio output to speaker
  ///@deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
  /// setBluetoothScoOn() methods instead.
  static const ROUTE_SPEAKER = 2;

  /// from: static public final int SCO_AUDIO_STATE_CONNECTED
  ///
  /// Value for extra \#EXTRA_SCO_AUDIO_STATE or \#EXTRA_SCO_AUDIO_PREVIOUS_STATE
  /// indicating that the SCO audio channel is established
  static const SCO_AUDIO_STATE_CONNECTED = 1;

  /// from: static public final int SCO_AUDIO_STATE_CONNECTING
  ///
  /// Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
  /// indicating that the SCO audio channel is being established
  static const SCO_AUDIO_STATE_CONNECTING = 2;

  /// from: static public final int SCO_AUDIO_STATE_DISCONNECTED
  ///
  /// Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
  /// indicating that the SCO audio channel is not established
  static const SCO_AUDIO_STATE_DISCONNECTED = 0;

  /// from: static public final int SCO_AUDIO_STATE_ERROR
  ///
  /// Value for extra EXTRA_SCO_AUDIO_STATE indicating that
  /// there was an error trying to obtain the state
  static const SCO_AUDIO_STATE_ERROR = -1;

  /// from: static public final int STREAM_ACCESSIBILITY
  ///
  /// Used to identify the volume of audio streams for accessibility prompts
  static const STREAM_ACCESSIBILITY = 10;

  /// from: static public final int STREAM_ALARM
  ///
  /// Used to identify the volume of audio streams for alarms
  static const STREAM_ALARM = 4;

  /// from: static public final int STREAM_DTMF
  ///
  /// Used to identify the volume of audio streams for DTMF Tones
  static const STREAM_DTMF = 8;

  /// from: static public final int STREAM_MUSIC
  ///
  /// Used to identify the volume of audio streams for music playback
  static const STREAM_MUSIC = 3;

  /// from: static public final int STREAM_NOTIFICATION
  ///
  /// Used to identify the volume of audio streams for notifications
  static const STREAM_NOTIFICATION = 5;

  /// from: static public final int STREAM_RING
  ///
  /// Used to identify the volume of audio streams for the phone ring
  static const STREAM_RING = 2;

  /// from: static public final int STREAM_SYSTEM
  ///
  /// Used to identify the volume of audio streams for system sounds
  static const STREAM_SYSTEM = 1;

  /// from: static public final int STREAM_VOICE_CALL
  ///
  /// Used to identify the volume of audio streams for phone calls
  static const STREAM_VOICE_CALL = 0;

  /// from: static public final int USE_DEFAULT_STREAM_TYPE
  ///
  /// Suggests using the default stream type. This may not be used in all
  /// places a stream type is needed.
  static const USE_DEFAULT_STREAM_TYPE = -2147483648;

  /// from: static public final java.lang.String VIBRATE_SETTING_CHANGED_ACTION
  ///
  /// Broadcast intent action indicating that the vibrate setting has
  /// changed. Includes the vibrate type and its new setting.
  ///@see \#EXTRA_VIBRATE_TYPE
  ///@see \#EXTRA_VIBRATE_SETTING
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode and listen to \#RINGER_MODE_CHANGED_ACTION instead.
  static const VIBRATE_SETTING_CHANGED_ACTION =
      "android.media.VIBRATE_SETTING_CHANGED";

  /// from: static public final int VIBRATE_SETTING_OFF
  ///
  /// Vibrate setting that suggests to never vibrate.
  ///@see \#setVibrateSetting(int, int)
  ///@see \#getVibrateSetting(int)
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode that can be queried via \#getRingerMode().
  static const VIBRATE_SETTING_OFF = 0;

  /// from: static public final int VIBRATE_SETTING_ON
  ///
  /// Vibrate setting that suggests to vibrate when possible.
  ///@see \#setVibrateSetting(int, int)
  ///@see \#getVibrateSetting(int)
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode that can be queried via \#getRingerMode().
  static const VIBRATE_SETTING_ON = 1;

  /// from: static public final int VIBRATE_SETTING_ONLY_SILENT
  ///
  /// Vibrate setting that suggests to only vibrate when in the vibrate ringer
  /// mode.
  ///@see \#setVibrateSetting(int, int)
  ///@see \#getVibrateSetting(int)
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode that can be queried via \#getRingerMode().
  static const VIBRATE_SETTING_ONLY_SILENT = 2;

  /// from: static public final int VIBRATE_TYPE_NOTIFICATION
  ///
  /// Vibrate type that corresponds to notifications.
  ///@see \#setVibrateSetting(int, int)
  ///@see \#getVibrateSetting(int)
  ///@see \#shouldVibrate(int)
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode that can be queried via \#getRingerMode().
  static const VIBRATE_TYPE_NOTIFICATION = 1;

  /// from: static public final int VIBRATE_TYPE_RINGER
  ///
  /// Vibrate type that corresponds to the ringer.
  ///@see \#setVibrateSetting(int, int)
  ///@see \#getVibrateSetting(int)
  ///@see \#shouldVibrate(int)
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode that can be queried via \#getRingerMode().
  static const VIBRATE_TYPE_RINGER = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide For test purposes only, will throw NPE with some methods that require a Context.
  AudioManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_dispatchMediaKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchMediaKeyEvent", "(Landroid/view/KeyEvent;)V");

  /// from: public void dispatchMediaKeyEvent(android.view.KeyEvent keyEvent)
  ///
  /// Sends a simulated key event for a media button.
  /// To simulate a key press, you must first send a KeyEvent built with a
  /// KeyEvent\#ACTION_DOWN action, then another event with the KeyEvent\#ACTION_UP
  /// action.
  /// The key event will be sent to the current media key event consumer which registered with
  /// AudioManager\#registerMediaButtonEventReceiver(PendingIntent).
  ///@param keyEvent a KeyEvent instance whose key code is one of
  ///     KeyEvent\#KEYCODE_MUTE,
  ///     KeyEvent\#KEYCODE_HEADSETHOOK,
  ///     KeyEvent\#KEYCODE_MEDIA_PLAY,
  ///     KeyEvent\#KEYCODE_MEDIA_PAUSE,
  ///     KeyEvent\#KEYCODE_MEDIA_PLAY_PAUSE,
  ///     KeyEvent\#KEYCODE_MEDIA_STOP,
  ///     KeyEvent\#KEYCODE_MEDIA_NEXT,
  ///     KeyEvent\#KEYCODE_MEDIA_PREVIOUS,
  ///     KeyEvent\#KEYCODE_MEDIA_REWIND,
  ///     KeyEvent\#KEYCODE_MEDIA_RECORD,
  ///     KeyEvent\#KEYCODE_MEDIA_FAST_FORWARD,
  ///     KeyEvent\#KEYCODE_MEDIA_CLOSE,
  ///     KeyEvent\#KEYCODE_MEDIA_EJECT,
  ///     or KeyEvent\#KEYCODE_MEDIA_AUDIO_TRACK.
  void dispatchMediaKeyEvent(keyevent_.KeyEvent keyEvent) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchMediaKeyEvent,
          jni.JniType.voidType, [keyEvent.reference]).check();

  static final _id_isVolumeFixed =
      jniAccessors.getMethodIDOf(_classRef, "isVolumeFixed", "()Z");

  /// from: public boolean isVolumeFixed()
  ///
  /// Indicates if the device implements a fixed volume policy.
  /// Some devices may not have volume control and may operate at a fixed volume,
  /// and may not enable muting or changing the volume of audio streams.
  /// This method will return true on such devices.
  /// The following APIs have no effect when volume is fixed:
  /// <ul>
  ///   <li> \#adjustVolume(int, int)
  ///   <li> \#adjustSuggestedStreamVolume(int, int, int)
  ///   <li> \#adjustStreamVolume(int, int, int)
  ///   <li> \#setStreamVolume(int, int, int)
  ///   <li> \#setRingerMode(int)
  ///   <li> \#setStreamSolo(int, boolean)
  ///   <li> \#setStreamMute(int, boolean)
  /// </ul>
  bool isVolumeFixed() => jniAccessors.callMethodWithArgs(
      reference, _id_isVolumeFixed, jni.JniType.booleanType, []).boolean;

  static final _id_adjustStreamVolume =
      jniAccessors.getMethodIDOf(_classRef, "adjustStreamVolume", "(III)V");

  /// from: public void adjustStreamVolume(int streamType, int direction, int flags)
  ///
  /// Adjusts the volume of a particular stream by one step in a direction.
  ///
  /// This method should only be used by applications that replace the platform-wide
  /// management of audio settings or the main telephony application.
  ///@param streamType The stream type to adjust. One of \#STREAM_VOICE_CALL,
  /// \#STREAM_SYSTEM, \#STREAM_RING, \#STREAM_MUSIC,
  /// \#STREAM_ALARM or \#STREAM_ACCESSIBILITY.
  ///@param direction The direction to adjust the volume. One of
  ///            \#ADJUST_LOWER, \#ADJUST_RAISE, or
  ///            \#ADJUST_SAME.
  ///@param flags One or more flags.
  ///@see \#adjustVolume(int, int)
  ///@see \#setStreamVolume(int, int, int)
  void adjustStreamVolume(int streamType, int direction, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_adjustStreamVolume,
          jni.JniType.voidType, [streamType, direction, flags]).check();

  static final _id_adjustVolume =
      jniAccessors.getMethodIDOf(_classRef, "adjustVolume", "(II)V");

  /// from: public void adjustVolume(int direction, int flags)
  ///
  /// Adjusts the volume of the most relevant stream. For example, if a call is
  /// active, it will have the highest priority regardless of if the in-call
  /// screen is showing. Another example, if music is playing in the background
  /// and a call is not active, the music stream will be adjusted.
  ///
  /// This method should only be used by applications that replace the
  /// platform-wide management of audio settings or the main telephony
  /// application.
  ///
  /// This method has no effect if the device implements a fixed volume policy
  /// as indicated by \#isVolumeFixed().
  ///@param direction The direction to adjust the volume. One of
  ///            \#ADJUST_LOWER, \#ADJUST_RAISE,
  ///            \#ADJUST_SAME, \#ADJUST_MUTE,
  ///            \#ADJUST_UNMUTE, or \#ADJUST_TOGGLE_MUTE.
  ///@param flags One or more flags.
  ///@see \#adjustSuggestedStreamVolume(int, int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  ///@see \#setStreamVolume(int, int, int)
  ///@see \#isVolumeFixed()
  void adjustVolume(int direction, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_adjustVolume,
          jni.JniType.voidType, [direction, flags]).check();

  static final _id_adjustSuggestedStreamVolume = jniAccessors.getMethodIDOf(
      _classRef, "adjustSuggestedStreamVolume", "(III)V");

  /// from: public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags)
  ///
  /// Adjusts the volume of the most relevant stream, or the given fallback
  /// stream.
  ///
  /// This method should only be used by applications that replace the
  /// platform-wide management of audio settings or the main telephony
  /// application.
  ///
  /// This method has no effect if the device implements a fixed volume policy
  /// as indicated by \#isVolumeFixed().
  ///@param direction The direction to adjust the volume. One of
  ///            \#ADJUST_LOWER, \#ADJUST_RAISE,
  ///            \#ADJUST_SAME, \#ADJUST_MUTE,
  ///            \#ADJUST_UNMUTE, or \#ADJUST_TOGGLE_MUTE.
  ///@param suggestedStreamType The stream type that will be used if there
  ///            isn't a relevant stream. \#USE_DEFAULT_STREAM_TYPE is
  ///            valid here.
  ///@param flags One or more flags.
  ///@see \#adjustVolume(int, int)
  ///@see \#adjustStreamVolume(int, int, int)
  ///@see \#setStreamVolume(int, int, int)
  ///@see \#isVolumeFixed()
  void adjustSuggestedStreamVolume(
          int direction, int suggestedStreamType, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_adjustSuggestedStreamVolume,
          jni.JniType.voidType,
          [direction, suggestedStreamType, flags]).check();

  static final _id_getRingerMode =
      jniAccessors.getMethodIDOf(_classRef, "getRingerMode", "()I");

  /// from: public int getRingerMode()
  ///
  /// Returns the current ringtone mode.
  ///@return The current ringtone mode, one of \#RINGER_MODE_NORMAL,
  ///         \#RINGER_MODE_SILENT, or \#RINGER_MODE_VIBRATE.
  ///@see \#setRingerMode(int)
  int getRingerMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getRingerMode, jni.JniType.intType, []).integer;

  static final _id_getStreamMaxVolume =
      jniAccessors.getMethodIDOf(_classRef, "getStreamMaxVolume", "(I)I");

  /// from: public int getStreamMaxVolume(int streamType)
  ///
  /// Returns the maximum volume index for a particular stream.
  ///@param streamType The stream type whose maximum volume index is returned.
  ///@return The maximum valid volume index for the stream.
  ///@see \#getStreamVolume(int)
  int getStreamMaxVolume(int streamType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getStreamMaxVolume,
      jni.JniType.intType,
      [streamType]).integer;

  static final _id_getStreamMinVolume =
      jniAccessors.getMethodIDOf(_classRef, "getStreamMinVolume", "(I)I");

  /// from: public int getStreamMinVolume(int streamType)
  ///
  /// Returns the minimum volume index for a particular stream.
  ///@param streamType The stream type whose minimum volume index is returned. Must be one of
  ///     \#STREAM_VOICE_CALL, \#STREAM_SYSTEM,
  ///     \#STREAM_RING, \#STREAM_MUSIC, \#STREAM_ALARM,
  ///     \#STREAM_NOTIFICATION, \#STREAM_DTMF or \#STREAM_ACCESSIBILITY.
  ///@return The minimum valid volume index for the stream.
  ///@see \#getStreamVolume(int)
  int getStreamMinVolume(int streamType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getStreamMinVolume,
      jni.JniType.intType,
      [streamType]).integer;

  static final _id_getStreamVolume =
      jniAccessors.getMethodIDOf(_classRef, "getStreamVolume", "(I)I");

  /// from: public int getStreamVolume(int streamType)
  ///
  /// Returns the current volume index for a particular stream.
  ///@param streamType The stream type whose volume index is returned.
  ///@return The current volume index for the stream.
  ///@see \#getStreamMaxVolume(int)
  ///@see \#setStreamVolume(int, int, int)
  int getStreamVolume(int streamType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getStreamVolume,
      jni.JniType.intType,
      [streamType]).integer;

  static final _id_getStreamVolumeDb =
      jniAccessors.getMethodIDOf(_classRef, "getStreamVolumeDb", "(III)F");

  /// from: public float getStreamVolumeDb(int streamType, int index, int deviceType)
  ///
  /// Returns the volume in dB (decibel) for the given stream type at the given volume index, on
  /// the given type of audio output device.
  ///@param streamType stream type for which the volume is queried.
  /// Value is android.media.AudioManager\#STREAM_VOICE_CALL, android.media.AudioManager\#STREAM_SYSTEM, android.media.AudioManager\#STREAM_RING, android.media.AudioManager\#STREAM_MUSIC, android.media.AudioManager\#STREAM_ALARM, android.media.AudioManager\#STREAM_NOTIFICATION, android.media.AudioManager\#STREAM_DTMF, or android.media.AudioManager\#STREAM_ACCESSIBILITY
  ///@param index the volume index for which the volume is queried. The index value must be
  ///     between the minimum and maximum index values for the given stream type (see
  ///     \#getStreamMinVolume(int) and \#getStreamMaxVolume(int)).
  ///@param deviceType the type of audio output device for which volume is queried.
  /// Value is android.media.AudioDeviceInfo\#TYPE_BUILTIN_EARPIECE, android.media.AudioDeviceInfo\#TYPE_BUILTIN_SPEAKER, android.media.AudioDeviceInfo\#TYPE_WIRED_HEADSET, android.media.AudioDeviceInfo\#TYPE_WIRED_HEADPHONES, android.media.AudioDeviceInfo\#TYPE_BLUETOOTH_SCO, android.media.AudioDeviceInfo\#TYPE_BLUETOOTH_A2DP, android.media.AudioDeviceInfo\#TYPE_HDMI, android.media.AudioDeviceInfo\#TYPE_DOCK, android.media.AudioDeviceInfo\#TYPE_USB_ACCESSORY, android.media.AudioDeviceInfo\#TYPE_USB_DEVICE, android.media.AudioDeviceInfo\#TYPE_USB_HEADSET, android.media.AudioDeviceInfo\#TYPE_TELEPHONY, android.media.AudioDeviceInfo\#TYPE_LINE_ANALOG, android.media.AudioDeviceInfo\#TYPE_HDMI_ARC, android.media.AudioDeviceInfo\#TYPE_LINE_DIGITAL, android.media.AudioDeviceInfo\#TYPE_FM, android.media.AudioDeviceInfo\#TYPE_AUX_LINE, android.media.AudioDeviceInfo\#TYPE_IP, android.media.AudioDeviceInfo\#TYPE_BUS, or android.media.AudioDeviceInfo\#TYPE_HEARING_AID
  ///@return a volume expressed in dB.
  ///     A negative value indicates the audio signal is attenuated. A typical maximum value
  ///     at the maximum volume index is 0 dB (no attenuation nor amplification). Muting is
  ///     reflected by a value of Float\#NEGATIVE_INFINITY.
  double getStreamVolumeDb(int streamType, int index, int deviceType) =>
      jniAccessors.callMethodWithArgs(reference, _id_getStreamVolumeDb,
          jni.JniType.floatType, [streamType, index, deviceType]).float;

  static final _id_setRingerMode =
      jniAccessors.getMethodIDOf(_classRef, "setRingerMode", "(I)V");

  /// from: public void setRingerMode(int ringerMode)
  ///
  /// Sets the ringer mode.
  ///
  /// Silent mode will mute the volume and will not vibrate. Vibrate mode will
  /// mute the volume and vibrate. Normal mode will be audible and may vibrate
  /// according to user settings.
  /// This method has no effect if the device implements a fixed volume policy
  /// as indicated by \#isVolumeFixed().
  /// * From N onward, ringer mode adjustments that would toggle Do Not Disturb are not allowed
  /// unless the app has been granted Do Not Disturb Access.
  /// See NotificationManager\#isNotificationPolicyAccessGranted().
  ///@param ringerMode The ringer mode, one of \#RINGER_MODE_NORMAL,
  ///            \#RINGER_MODE_SILENT, or \#RINGER_MODE_VIBRATE.
  ///@see \#getRingerMode()
  ///@see \#isVolumeFixed()
  void setRingerMode(int ringerMode) => jniAccessors.callMethodWithArgs(
      reference, _id_setRingerMode, jni.JniType.voidType, [ringerMode]).check();

  static final _id_setStreamVolume =
      jniAccessors.getMethodIDOf(_classRef, "setStreamVolume", "(III)V");

  /// from: public void setStreamVolume(int streamType, int index, int flags)
  ///
  /// Sets the volume index for a particular stream.
  /// This method has no effect if the device implements a fixed volume policy
  /// as indicated by \#isVolumeFixed().
  /// From N onward, volume adjustments that would toggle Do Not Disturb are not allowed unless
  /// the app has been granted Do Not Disturb Access.
  /// See NotificationManager\#isNotificationPolicyAccessGranted().
  ///@param streamType The stream whose volume index should be set.
  ///@param index The volume index to set. See
  ///            \#getStreamMaxVolume(int) for the largest valid value.
  ///@param flags One or more flags.
  ///@see \#getStreamMaxVolume(int)
  ///@see \#getStreamVolume(int)
  ///@see \#isVolumeFixed()
  void setStreamVolume(int streamType, int index, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStreamVolume,
          jni.JniType.voidType, [streamType, index, flags]).check();

  static final _id_setStreamSolo =
      jniAccessors.getMethodIDOf(_classRef, "setStreamSolo", "(IZ)V");

  /// from: public void setStreamSolo(int streamType, boolean state)
  ///
  /// Solo or unsolo a particular stream.
  ///
  /// Do not use. This method has been deprecated and is now a no-op.
  /// \#requestAudioFocus should be used for exclusive audio playback.
  ///@param streamType The stream to be soloed/unsoloed.
  ///@param state The required solo state: true for solo ON, false for solo
  ///            OFF
  ///@see \#isVolumeFixed()
  ///@deprecated Do not use. If you need exclusive audio playback use
  ///             \#requestAudioFocus.
  void setStreamSolo(int streamType, bool state) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStreamSolo,
          jni.JniType.voidType, [streamType, state]).check();

  static final _id_setStreamMute =
      jniAccessors.getMethodIDOf(_classRef, "setStreamMute", "(IZ)V");

  /// from: public void setStreamMute(int streamType, boolean state)
  ///
  /// Mute or unmute an audio stream.
  ///
  /// This method should only be used by applications that replace the
  /// platform-wide management of audio settings or the main telephony
  /// application.
  ///
  /// This method has no effect if the device implements a fixed volume policy
  /// as indicated by \#isVolumeFixed().
  ///
  /// This method was deprecated in API level 22. Prior to API level 22 this
  /// method had significantly different behavior and should be used carefully.
  /// The following applies only to pre-22 platforms:
  /// <ul>
  /// <li>The mute command is protected against client process death: if a
  /// process with an active mute request on a stream dies, this stream will be
  /// unmuted automatically.</li>
  /// <li>The mute requests for a given stream are cumulative: the AudioManager
  /// can receive several mute requests from one or more clients and the stream
  /// will be unmuted only when the same number of unmute requests are
  /// received.</li>
  /// <li>For a better user experience, applications MUST unmute a muted stream
  /// in onPause() and mute is again in onResume() if appropriate.</li>
  /// </ul>
  ///@param streamType The stream to be muted/unmuted.
  ///@param state The required mute state: true for mute ON, false for mute
  ///            OFF
  ///@see \#isVolumeFixed()
  ///@deprecated Use \#adjustStreamVolume(int, int, int) with
  ///             \#ADJUST_MUTE or \#ADJUST_UNMUTE instead.
  void setStreamMute(int streamType, bool state) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStreamMute,
          jni.JniType.voidType, [streamType, state]).check();

  static final _id_isStreamMute =
      jniAccessors.getMethodIDOf(_classRef, "isStreamMute", "(I)Z");

  /// from: public boolean isStreamMute(int streamType)
  ///
  /// Returns the current mute state for a particular stream.
  ///@param streamType The stream to get mute state for.
  ///@return The mute state for the given stream.
  ///@see \#adjustStreamVolume(int, int, int)
  bool isStreamMute(int streamType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isStreamMute,
      jni.JniType.booleanType,
      [streamType]).boolean;

  static final _id_shouldVibrate =
      jniAccessors.getMethodIDOf(_classRef, "shouldVibrate", "(I)Z");

  /// from: public boolean shouldVibrate(int vibrateType)
  ///
  /// Returns whether a particular type should vibrate according to user
  /// settings and the current ringer mode.
  ///
  /// This shouldn't be needed by most clients that use notifications to
  /// vibrate. The notification manager will not vibrate if the policy doesn't
  /// allow it, so the client should always set a vibrate pattern and let the
  /// notification manager control whether or not to actually vibrate.
  ///@param vibrateType The type of vibrate. One of
  ///            \#VIBRATE_TYPE_NOTIFICATION or
  ///            \#VIBRATE_TYPE_RINGER.
  ///@return Whether the type should vibrate at the instant this method is
  ///         called.
  ///@see \#setVibrateSetting(int, int)
  ///@see \#getVibrateSetting(int)
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode that can be queried via \#getRingerMode().
  bool shouldVibrate(int vibrateType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_shouldVibrate,
      jni.JniType.booleanType,
      [vibrateType]).boolean;

  static final _id_getVibrateSetting =
      jniAccessors.getMethodIDOf(_classRef, "getVibrateSetting", "(I)I");

  /// from: public int getVibrateSetting(int vibrateType)
  ///
  /// Returns whether the user's vibrate setting for a vibrate type.
  ///
  /// This shouldn't be needed by most clients that want to vibrate, instead
  /// see \#shouldVibrate(int).
  ///@param vibrateType The type of vibrate. One of
  ///            \#VIBRATE_TYPE_NOTIFICATION or
  ///            \#VIBRATE_TYPE_RINGER.
  ///@return The vibrate setting, one of \#VIBRATE_SETTING_ON,
  ///         \#VIBRATE_SETTING_OFF, or
  ///         \#VIBRATE_SETTING_ONLY_SILENT.
  ///@see \#setVibrateSetting(int, int)
  ///@see \#shouldVibrate(int)
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode that can be queried via \#getRingerMode().
  int getVibrateSetting(int vibrateType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getVibrateSetting,
      jni.JniType.intType,
      [vibrateType]).integer;

  static final _id_setVibrateSetting =
      jniAccessors.getMethodIDOf(_classRef, "setVibrateSetting", "(II)V");

  /// from: public void setVibrateSetting(int vibrateType, int vibrateSetting)
  ///
  /// Sets the setting for when the vibrate type should vibrate.
  ///
  /// This method should only be used by applications that replace the platform-wide
  /// management of audio settings or the main telephony application.
  ///@param vibrateType The type of vibrate. One of
  ///            \#VIBRATE_TYPE_NOTIFICATION or
  ///            \#VIBRATE_TYPE_RINGER.
  ///@param vibrateSetting The vibrate setting, one of
  ///            \#VIBRATE_SETTING_ON,
  ///            \#VIBRATE_SETTING_OFF, or
  ///            \#VIBRATE_SETTING_ONLY_SILENT.
  ///@see \#getVibrateSetting(int)
  ///@see \#shouldVibrate(int)
  ///@deprecated Applications should maintain their own vibrate policy based on
  /// current ringer mode that can be queried via \#getRingerMode().
  void setVibrateSetting(int vibrateType, int vibrateSetting) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVibrateSetting,
          jni.JniType.voidType, [vibrateType, vibrateSetting]).check();

  static final _id_setSpeakerphoneOn =
      jniAccessors.getMethodIDOf(_classRef, "setSpeakerphoneOn", "(Z)V");

  /// from: public void setSpeakerphoneOn(boolean on)
  ///
  /// Sets the speakerphone on or off.
  ///
  /// This method should only be used by applications that replace the platform-wide
  /// management of audio settings or the main telephony application.
  ///@param on set <var>true</var> to turn on speakerphone;
  ///           <var>false</var> to turn it off
  void setSpeakerphoneOn(bool on0) => jniAccessors.callMethodWithArgs(
      reference, _id_setSpeakerphoneOn, jni.JniType.voidType, [on0]).check();

  static final _id_isSpeakerphoneOn =
      jniAccessors.getMethodIDOf(_classRef, "isSpeakerphoneOn", "()Z");

  /// from: public boolean isSpeakerphoneOn()
  ///
  /// Checks whether the speakerphone is on or off.
  ///@return true if speakerphone is on, false if it's off
  bool isSpeakerphoneOn() => jniAccessors.callMethodWithArgs(
      reference, _id_isSpeakerphoneOn, jni.JniType.booleanType, []).boolean;

  static final _id_isBluetoothScoAvailableOffCall = jniAccessors.getMethodIDOf(
      _classRef, "isBluetoothScoAvailableOffCall", "()Z");

  /// from: public boolean isBluetoothScoAvailableOffCall()
  ///
  /// Indicates if current platform supports use of SCO for off call use cases.
  /// Application wanted to use bluetooth SCO audio when the phone is not in call
  /// must first call this method to make sure that the platform supports this
  /// feature.
  ///@return true if bluetooth SCO can be used for audio when not in call
  ///         false otherwise
  ///@see \#startBluetoothSco()
  bool isBluetoothScoAvailableOffCall() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isBluetoothScoAvailableOffCall,
      jni.JniType.booleanType, []).boolean;

  static final _id_startBluetoothSco =
      jniAccessors.getMethodIDOf(_classRef, "startBluetoothSco", "()V");

  /// from: public void startBluetoothSco()
  ///
  /// Start bluetooth SCO audio connection.
  /// Requires Permission:
  ///   android.Manifest.permission\#MODIFY_AUDIO_SETTINGS.
  /// This method can be used by applications wanting to send and received audio
  /// to/from a bluetooth SCO headset while the phone is not in call.
  /// As the SCO connection establishment can take several seconds,
  /// applications should not rely on the connection to be available when the method
  /// returns but instead register to receive the intent \#ACTION_SCO_AUDIO_STATE_UPDATED
  /// and wait for the state to be \#SCO_AUDIO_STATE_CONNECTED.
  /// As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
  /// audio state before calling startBluetoothSco() by reading the intent returned by the receiver
  /// registration. If the state is already CONNECTED, no state change will be received via the
  /// intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
  /// so that the connection stays active in case the current initiator stops the connection.
  /// Unless the connection is already active as described above, the state will always
  /// transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
  /// succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
  /// When finished with the SCO connection or if the establishment fails, the application must
  /// call \#stopBluetoothSco() to clear the request and turn down the bluetooth connection.
  /// Even if a SCO connection is established, the following restrictions apply on audio
  /// output streams so that they can be routed to SCO headset:
  /// <ul>
  ///   <li> the stream type must be \#STREAM_VOICE_CALL </li>
  ///   <li> the format must be mono </li>
  ///   <li> the sampling must be 16kHz or 8kHz </li>
  /// </ul>
  /// The following restrictions apply on input streams:
  /// <ul>
  ///   <li> the format must be mono </li>
  ///   <li> the sampling must be 8kHz </li>
  /// </ul>
  /// Note that the phone application always has the priority on the usage of the SCO
  /// connection for telephony. If this method is called while the phone is in call
  /// it will be ignored. Similarly, if a call is received or sent while an application
  /// is using the SCO connection, the connection will be lost for the application and NOT
  /// returned automatically when the call ends.
  /// NOTE: up to and including API version
  /// android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1, this method initiates a virtual
  /// voice call to the bluetooth headset.
  /// After API version android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2 only a raw SCO audio
  /// connection is established.
  ///@see \#stopBluetoothSco()
  ///@see \#ACTION_SCO_AUDIO_STATE_UPDATED
  void startBluetoothSco() => jniAccessors.callMethodWithArgs(
      reference, _id_startBluetoothSco, jni.JniType.voidType, []).check();

  static final _id_stopBluetoothSco =
      jniAccessors.getMethodIDOf(_classRef, "stopBluetoothSco", "()V");

  /// from: public void stopBluetoothSco()
  ///
  /// Stop bluetooth SCO audio connection.
  /// Requires Permission:
  ///   android.Manifest.permission\#MODIFY_AUDIO_SETTINGS.
  /// This method must be called by applications having requested the use of
  /// bluetooth SCO audio with \#startBluetoothSco() when finished with the SCO
  /// connection or if connection fails.
  ///@see \#startBluetoothSco()
  void stopBluetoothSco() => jniAccessors.callMethodWithArgs(
      reference, _id_stopBluetoothSco, jni.JniType.voidType, []).check();

  static final _id_setBluetoothScoOn =
      jniAccessors.getMethodIDOf(_classRef, "setBluetoothScoOn", "(Z)V");

  /// from: public void setBluetoothScoOn(boolean on)
  ///
  /// Request use of Bluetooth SCO headset for communications.
  ///
  /// This method should only be used by applications that replace the platform-wide
  /// management of audio settings or the main telephony application.
  ///@param on set <var>true</var> to use bluetooth SCO for communications;
  ///               <var>false</var> to not use bluetooth SCO for communications
  void setBluetoothScoOn(bool on0) => jniAccessors.callMethodWithArgs(
      reference, _id_setBluetoothScoOn, jni.JniType.voidType, [on0]).check();

  static final _id_isBluetoothScoOn =
      jniAccessors.getMethodIDOf(_classRef, "isBluetoothScoOn", "()Z");

  /// from: public boolean isBluetoothScoOn()
  ///
  /// Checks whether communications use Bluetooth SCO.
  ///@return true if SCO is used for communications;
  ///         false if otherwise
  bool isBluetoothScoOn() => jniAccessors.callMethodWithArgs(
      reference, _id_isBluetoothScoOn, jni.JniType.booleanType, []).boolean;

  static final _id_setBluetoothA2dpOn =
      jniAccessors.getMethodIDOf(_classRef, "setBluetoothA2dpOn", "(Z)V");

  /// from: public void setBluetoothA2dpOn(boolean on)
  ///
  /// @param on set <var>true</var> to route A2DP audio to/from Bluetooth
  ///           headset; <var>false</var> disable A2DP audio
  ///@deprecated Do not use.
  void setBluetoothA2dpOn(bool on0) => jniAccessors.callMethodWithArgs(
      reference, _id_setBluetoothA2dpOn, jni.JniType.voidType, [on0]).check();

  static final _id_isBluetoothA2dpOn =
      jniAccessors.getMethodIDOf(_classRef, "isBluetoothA2dpOn", "()Z");

  /// from: public boolean isBluetoothA2dpOn()
  ///
  /// Checks whether a Bluetooth A2DP audio peripheral is connected or not.
  ///@return true if a Bluetooth A2DP peripheral is connected
  ///         false if otherwise
  ///@deprecated Use AudioManager\#getDevices(int) instead to list available audio devices.
  bool isBluetoothA2dpOn() => jniAccessors.callMethodWithArgs(
      reference, _id_isBluetoothA2dpOn, jni.JniType.booleanType, []).boolean;

  static final _id_setWiredHeadsetOn =
      jniAccessors.getMethodIDOf(_classRef, "setWiredHeadsetOn", "(Z)V");

  /// from: public void setWiredHeadsetOn(boolean on)
  ///
  /// Sets audio routing to the wired headset on or off.
  ///@param on set <var>true</var> to route audio to/from wired
  ///           headset; <var>false</var> disable wired headset audio
  ///@deprecated Do not use.
  void setWiredHeadsetOn(bool on0) => jniAccessors.callMethodWithArgs(
      reference, _id_setWiredHeadsetOn, jni.JniType.voidType, [on0]).check();

  static final _id_isWiredHeadsetOn =
      jniAccessors.getMethodIDOf(_classRef, "isWiredHeadsetOn", "()Z");

  /// from: public boolean isWiredHeadsetOn()
  ///
  /// Checks whether a wired headset is connected or not.
  /// This is not a valid indication that audio playback is
  /// actually over the wired headset as audio routing depends on other conditions.
  ///@return true if a wired headset is connected.
  ///         false if otherwise
  ///@deprecated Use AudioManager\#getDevices(int) instead to list available audio devices.
  bool isWiredHeadsetOn() => jniAccessors.callMethodWithArgs(
      reference, _id_isWiredHeadsetOn, jni.JniType.booleanType, []).boolean;

  static final _id_setMicrophoneMute =
      jniAccessors.getMethodIDOf(_classRef, "setMicrophoneMute", "(Z)V");

  /// from: public void setMicrophoneMute(boolean on)
  ///
  /// Sets the microphone mute on or off.
  ///
  /// This method should only be used by applications that replace the platform-wide
  /// management of audio settings or the main telephony application.
  ///@param on set <var>true</var> to mute the microphone;
  ///           <var>false</var> to turn mute off
  void setMicrophoneMute(bool on0) => jniAccessors.callMethodWithArgs(
      reference, _id_setMicrophoneMute, jni.JniType.voidType, [on0]).check();

  static final _id_isMicrophoneMute =
      jniAccessors.getMethodIDOf(_classRef, "isMicrophoneMute", "()Z");

  /// from: public boolean isMicrophoneMute()
  ///
  /// Checks whether the microphone mute is on or off.
  ///@return true if microphone is muted, false if it's not
  bool isMicrophoneMute() => jniAccessors.callMethodWithArgs(
      reference, _id_isMicrophoneMute, jni.JniType.booleanType, []).boolean;

  static final _id_setMode =
      jniAccessors.getMethodIDOf(_classRef, "setMode", "(I)V");

  /// from: public void setMode(int mode)
  ///
  /// Sets the audio mode.
  ///
  /// The audio mode encompasses audio routing AND the behavior of
  /// the telephony layer. Therefore this method should only be used by applications that
  /// replace the platform-wide management of audio settings or the main telephony application.
  /// In particular, the \#MODE_IN_CALL mode should only be used by the telephony
  /// application when it places a phone call, as it will cause signals from the radio layer
  /// to feed the platform mixer.
  ///@param mode the requested audio mode (\#MODE_NORMAL, \#MODE_RINGTONE,
  ///              \#MODE_IN_CALL or \#MODE_IN_COMMUNICATION).
  ///              Informs the HAL about the current audio state so that
  ///              it can route the audio appropriately.
  void setMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setMode, jni.JniType.voidType, [mode]).check();

  static final _id_getMode =
      jniAccessors.getMethodIDOf(_classRef, "getMode", "()I");

  /// from: public int getMode()
  ///
  /// Returns the current audio mode.
  ///@return the current audio mode (\#MODE_NORMAL, \#MODE_RINGTONE,
  ///              \#MODE_IN_CALL or \#MODE_IN_COMMUNICATION).
  ///              Returns the current current audio state from the HAL.
  int getMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getMode, jni.JniType.intType, []).integer;

  static final _id_setRouting =
      jniAccessors.getMethodIDOf(_classRef, "setRouting", "(III)V");

  /// from: public void setRouting(int mode, int routes, int mask)
  ///
  /// Sets the audio routing for a specified mode
  ///@param mode audio mode to change route. E.g., MODE_RINGTONE.
  ///@param routes bit vector of routes requested, created from one or
  ///               more of ROUTE_xxx types. Set bits indicate that route should be on
  ///@param mask bit vector of routes to change, created from one or more of
  /// ROUTE_xxx types. Unset bits indicate the route should be left unchanged
  ///@deprecated Do not set audio routing directly, use setSpeakerphoneOn(),
  /// setBluetoothScoOn() methods instead.
  void setRouting(int mode, int routes, int mask) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRouting,
          jni.JniType.voidType, [mode, routes, mask]).check();

  static final _id_getRouting =
      jniAccessors.getMethodIDOf(_classRef, "getRouting", "(I)I");

  /// from: public int getRouting(int mode)
  ///
  /// Returns the current audio routing bit vector for a specified mode.
  ///@param mode audio mode to get route (e.g., MODE_RINGTONE)
  ///@return an audio route bit vector that can be compared with ROUTE_xxx
  /// bits
  ///@deprecated Do not query audio routing directly, use isSpeakerphoneOn(),
  /// isBluetoothScoOn(), isBluetoothA2dpOn() and isWiredHeadsetOn() methods instead.
  int getRouting(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_getRouting, jni.JniType.intType, [mode]).integer;

  static final _id_isMusicActive =
      jniAccessors.getMethodIDOf(_classRef, "isMusicActive", "()Z");

  /// from: public boolean isMusicActive()
  ///
  /// Checks whether any music is active.
  ///@return true if any music tracks are active.
  bool isMusicActive() => jniAccessors.callMethodWithArgs(
      reference, _id_isMusicActive, jni.JniType.booleanType, []).boolean;

  static final _id_generateAudioSessionId =
      jniAccessors.getMethodIDOf(_classRef, "generateAudioSessionId", "()I");

  /// from: public int generateAudioSessionId()
  ///
  /// Return a new audio session identifier not associated with any player or effect.
  /// An audio session identifier is a system wide unique identifier for a set of audio streams
  /// (one or more mixed together).
  /// The primary use of the audio session ID is to associate audio effects to audio players,
  /// such as MediaPlayer or AudioTrack: all audio effects sharing the same audio
  /// session ID will be applied to the mixed audio content of the players that share the same
  /// audio session.
  /// This method can for instance be used when creating one of the
  /// android.media.audiofx.AudioEffect objects to define the audio session of the effect,
  /// or to specify a session for a speech synthesis utterance
  /// in android.speech.tts.TextToSpeech.Engine.
  ///@return a new unclaimed and unused audio session identifier, or \#ERROR when the
  ///   system failed to generate a new session, a condition in which audio playback or recording
  ///   will subsequently fail as well.
  int generateAudioSessionId() => jniAccessors.callMethodWithArgs(
      reference, _id_generateAudioSessionId, jni.JniType.intType, []).integer;

  static final _id_setParameters = jniAccessors.getMethodIDOf(
      _classRef, "setParameters", "(Ljava/lang/String;)V");

  /// from: public void setParameters(java.lang.String keyValuePairs)
  ///
  /// Sets a variable number of parameter values to audio hardware.
  ///@param keyValuePairs list of parameters key value pairs in the form:
  ///    key1=value1;key2=value2;...
  void setParameters(jni.JniString keyValuePairs) =>
      jniAccessors.callMethodWithArgs(reference, _id_setParameters,
          jni.JniType.voidType, [keyValuePairs.reference]).check();

  static final _id_getParameters = jniAccessors.getMethodIDOf(
      _classRef, "getParameters", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getParameters(java.lang.String keys)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a variable number of parameter values from audio hardware.
  ///@param keys list of parameters
  ///@return list of parameters key value pairs in the form:
  ///    key1=value1;key2=value2;...
  jni.JniString getParameters(jni.JniString keys) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getParameters, jni.JniType.objectType, [keys.reference]).object);

  static final _id_playSoundEffect =
      jniAccessors.getMethodIDOf(_classRef, "playSoundEffect", "(I)V");

  /// from: public void playSoundEffect(int effectType)
  ///
  /// Plays a sound effect (Key clicks, lid open/close...)
  ///@param effectType The type of sound effect. One of
  ///            \#FX_KEY_CLICK,
  ///            \#FX_FOCUS_NAVIGATION_UP,
  ///            \#FX_FOCUS_NAVIGATION_DOWN,
  ///            \#FX_FOCUS_NAVIGATION_LEFT,
  ///            \#FX_FOCUS_NAVIGATION_RIGHT,
  ///            \#FX_KEYPRESS_STANDARD,
  ///            \#FX_KEYPRESS_SPACEBAR,
  ///            \#FX_KEYPRESS_DELETE,
  ///            \#FX_KEYPRESS_RETURN,
  ///            \#FX_KEYPRESS_INVALID,
  /// NOTE: This version uses the UI settings to determine
  /// whether sounds are heard or not.
  void playSoundEffect(int effectType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_playSoundEffect,
      jni.JniType.voidType,
      [effectType]).check();

  static final _id_playSoundEffect1 =
      jniAccessors.getMethodIDOf(_classRef, "playSoundEffect", "(IF)V");

  /// from: public void playSoundEffect(int effectType, float volume)
  ///
  /// Plays a sound effect (Key clicks, lid open/close...)
  ///@param effectType The type of sound effect. One of
  ///            \#FX_KEY_CLICK,
  ///            \#FX_FOCUS_NAVIGATION_UP,
  ///            \#FX_FOCUS_NAVIGATION_DOWN,
  ///            \#FX_FOCUS_NAVIGATION_LEFT,
  ///            \#FX_FOCUS_NAVIGATION_RIGHT,
  ///            \#FX_KEYPRESS_STANDARD,
  ///            \#FX_KEYPRESS_SPACEBAR,
  ///            \#FX_KEYPRESS_DELETE,
  ///            \#FX_KEYPRESS_RETURN,
  ///            \#FX_KEYPRESS_INVALID,
  ///@param volume Sound effect volume.
  /// The volume value is a raw scalar so UI controls should be scaled logarithmically.
  /// If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.
  /// NOTE: This version is for applications that have their own
  /// settings panel for enabling and controlling volume.
  void playSoundEffect1(int effectType, double volume) =>
      jniAccessors.callMethodWithArgs(reference, _id_playSoundEffect1,
          jni.JniType.voidType, [effectType, volume]).check();

  static final _id_loadSoundEffects =
      jniAccessors.getMethodIDOf(_classRef, "loadSoundEffects", "()V");

  /// from: public void loadSoundEffects()
  ///
  /// Load Sound effects.
  ///  This method must be called when sound effects are enabled.
  void loadSoundEffects() => jniAccessors.callMethodWithArgs(
      reference, _id_loadSoundEffects, jni.JniType.voidType, []).check();

  static final _id_unloadSoundEffects =
      jniAccessors.getMethodIDOf(_classRef, "unloadSoundEffects", "()V");

  /// from: public void unloadSoundEffects()
  ///
  /// Unload Sound effects.
  ///  This method can be called to free some memory when
  ///  sound effects are disabled.
  void unloadSoundEffects() => jniAccessors.callMethodWithArgs(
      reference, _id_unloadSoundEffects, jni.JniType.voidType, []).check();

  static final _id_requestAudioFocus = jniAccessors.getMethodIDOf(
      _classRef,
      "requestAudioFocus",
      "(Landroid/media/AudioManager\$OnAudioFocusChangeListener;II)I");

  /// from: public int requestAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener l, int streamType, int durationHint)
  ///
  /// Request audio focus.
  ///  Send a request to obtain the audio focus
  ///@param l the listener to be notified of audio focus changes
  ///@param streamType the main audio stream type affected by the focus request
  ///@param durationHint use \#AUDIOFOCUS_GAIN_TRANSIENT to indicate this focus request
  ///      is temporary, and focus will be abandonned shortly. Examples of transient requests are
  ///      for the playback of driving directions, or notifications sounds.
  ///      Use \#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK to indicate also that it's ok for
  ///      the previous focus owner to keep playing if it ducks its audio output.
  ///      Alternatively use \#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE for a temporary request
  ///      that benefits from the system not playing disruptive sounds like notifications, for
  ///      usecases such as voice memo recording, or speech recognition.
  ///      Use \#AUDIOFOCUS_GAIN for a focus request of unknown duration such
  ///      as the playback of a song or a video.
  ///@return \#AUDIOFOCUS_REQUEST_FAILED or \#AUDIOFOCUS_REQUEST_GRANTED
  ///@deprecated use \#requestAudioFocus(AudioFocusRequest)
  int requestAudioFocus(AudioManager_OnAudioFocusChangeListener l,
          int streamType, int durationHint) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestAudioFocus,
          jni.JniType.intType, [l.reference, streamType, durationHint]).integer;

  static final _id_requestAudioFocus1 = jniAccessors.getMethodIDOf(
      _classRef, "requestAudioFocus", "(Landroid/media/AudioFocusRequest;)I");

  /// from: public int requestAudioFocus(android.media.AudioFocusRequest focusRequest)
  ///
  /// Request audio focus.
  /// See the AudioFocusRequest for information about the options available to configure
  /// your request, and notification of focus gain and loss.
  ///@param focusRequest a AudioFocusRequest instance used to configure how focus is
  ///   requested.
  /// This value must never be {@code null}.
  ///@return \#AUDIOFOCUS_REQUEST_FAILED, \#AUDIOFOCUS_REQUEST_GRANTED
  ///     or \#AUDIOFOCUS_REQUEST_DELAYED.
  ///     <br>Note that the return value is never \#AUDIOFOCUS_REQUEST_DELAYED when focus
  ///     is requested without building the AudioFocusRequest with
  ///     AudioFocusRequest.Builder\#setAcceptsDelayedFocusGain(boolean) set to
  ///     {@code true}.
  ///@throws NullPointerException if passed a null argument
  int requestAudioFocus1(audiofocusrequest_.AudioFocusRequest focusRequest) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestAudioFocus1,
          jni.JniType.intType, [focusRequest.reference]).integer;

  static final _id_abandonAudioFocusRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "abandonAudioFocusRequest",
      "(Landroid/media/AudioFocusRequest;)I");

  /// from: public int abandonAudioFocusRequest(android.media.AudioFocusRequest focusRequest)
  ///
  /// Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
  ///@param focusRequest the AudioFocusRequest that was used when requesting focus
  ///      with \#requestAudioFocus(AudioFocusRequest).
  ///
  /// This value must never be {@code null}.
  ///@return \#AUDIOFOCUS_REQUEST_FAILED or \#AUDIOFOCUS_REQUEST_GRANTED
  ///@throws IllegalArgumentException if passed a null argument
  int abandonAudioFocusRequest(
          audiofocusrequest_.AudioFocusRequest focusRequest) =>
      jniAccessors.callMethodWithArgs(reference, _id_abandonAudioFocusRequest,
          jni.JniType.intType, [focusRequest.reference]).integer;

  static final _id_abandonAudioFocus = jniAccessors.getMethodIDOf(
      _classRef,
      "abandonAudioFocus",
      "(Landroid/media/AudioManager\$OnAudioFocusChangeListener;)I");

  /// from: public int abandonAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener l)
  ///
  /// Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
  ///@param l the listener with which focus was requested.
  ///@return \#AUDIOFOCUS_REQUEST_FAILED or \#AUDIOFOCUS_REQUEST_GRANTED
  ///@deprecated use \#abandonAudioFocusRequest(AudioFocusRequest)
  int abandonAudioFocus(AudioManager_OnAudioFocusChangeListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_abandonAudioFocus,
          jni.JniType.intType, [l.reference]).integer;

  static final _id_registerMediaButtonEventReceiver =
      jniAccessors.getMethodIDOf(_classRef, "registerMediaButtonEventReceiver",
          "(Landroid/content/ComponentName;)V");

  /// from: public void registerMediaButtonEventReceiver(android.content.ComponentName eventReceiver)
  ///
  /// Register a component to be the sole receiver of MEDIA_BUTTON intents.
  ///@param eventReceiver identifier of a android.content.BroadcastReceiver
  ///      that will receive the media button intent. This broadcast receiver must be declared
  ///      in the application manifest. The package of the component must match that of
  ///      the context you're registering from.
  ///@deprecated Use MediaSession\#setMediaButtonReceiver(PendingIntent) instead.
  void registerMediaButtonEventReceiver(
          componentname_.ComponentName eventReceiver) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerMediaButtonEventReceiver,
          jni.JniType.voidType,
          [eventReceiver.reference]).check();

  static final _id_registerMediaButtonEventReceiver1 =
      jniAccessors.getMethodIDOf(_classRef, "registerMediaButtonEventReceiver",
          "(Landroid/app/PendingIntent;)V");

  /// from: public void registerMediaButtonEventReceiver(android.app.PendingIntent eventReceiver)
  ///
  /// Register a component to be the sole receiver of MEDIA_BUTTON intents.  This is like
  /// \#registerMediaButtonEventReceiver(android.content.ComponentName), but allows
  /// the buttons to go to any PendingIntent.  Note that you should only use this form if
  /// you know you will continue running for the full time until unregistering the
  /// PendingIntent.
  ///@param eventReceiver target that will receive media button intents.  The PendingIntent
  /// will be sent an Intent\#ACTION_MEDIA_BUTTON event when a media button action
  /// occurs, with Intent\#EXTRA_KEY_EVENT added and holding the key code of the
  /// media button that was pressed.
  ///@deprecated Use MediaSession\#setMediaButtonReceiver(PendingIntent) instead.
  void registerMediaButtonEventReceiver1(
          pendingintent_.PendingIntent eventReceiver) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerMediaButtonEventReceiver1,
          jni.JniType.voidType,
          [eventReceiver.reference]).check();

  static final _id_unregisterMediaButtonEventReceiver =
      jniAccessors.getMethodIDOf(
          _classRef,
          "unregisterMediaButtonEventReceiver",
          "(Landroid/content/ComponentName;)V");

  /// from: public void unregisterMediaButtonEventReceiver(android.content.ComponentName eventReceiver)
  ///
  /// Unregister the receiver of MEDIA_BUTTON intents.
  ///@param eventReceiver identifier of a android.content.BroadcastReceiver
  ///      that was registered with \#registerMediaButtonEventReceiver(ComponentName).
  ///@deprecated Use MediaSession instead.
  void unregisterMediaButtonEventReceiver(
          componentname_.ComponentName eventReceiver) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterMediaButtonEventReceiver,
          jni.JniType.voidType,
          [eventReceiver.reference]).check();

  static final _id_unregisterMediaButtonEventReceiver1 =
      jniAccessors.getMethodIDOf(
          _classRef,
          "unregisterMediaButtonEventReceiver",
          "(Landroid/app/PendingIntent;)V");

  /// from: public void unregisterMediaButtonEventReceiver(android.app.PendingIntent eventReceiver)
  ///
  /// Unregister the receiver of MEDIA_BUTTON intents.
  ///@param eventReceiver same PendingIntent that was registed with
  ///      \#registerMediaButtonEventReceiver(PendingIntent).
  ///@deprecated Use MediaSession instead.
  void unregisterMediaButtonEventReceiver1(
          pendingintent_.PendingIntent eventReceiver) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterMediaButtonEventReceiver1,
          jni.JniType.voidType,
          [eventReceiver.reference]).check();

  static final _id_registerRemoteControlClient = jniAccessors.getMethodIDOf(
      _classRef,
      "registerRemoteControlClient",
      "(Landroid/media/RemoteControlClient;)V");

  /// from: public void registerRemoteControlClient(android.media.RemoteControlClient rcClient)
  ///
  /// Registers the remote control client for providing information to display on the remote
  /// controls.
  ///@param rcClient The remote control client from which remote controls will receive
  ///      information to display.
  ///@see RemoteControlClient
  ///@deprecated Use MediaSession instead.
  void registerRemoteControlClient(
          remotecontrolclient_.RemoteControlClient rcClient) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerRemoteControlClient,
          jni.JniType.voidType,
          [rcClient.reference]).check();

  static final _id_unregisterRemoteControlClient = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterRemoteControlClient",
      "(Landroid/media/RemoteControlClient;)V");

  /// from: public void unregisterRemoteControlClient(android.media.RemoteControlClient rcClient)
  ///
  /// Unregisters the remote control client that was providing information to display on the
  /// remote controls.
  ///@param rcClient The remote control client to unregister.
  ///@see \#registerRemoteControlClient(RemoteControlClient)
  ///@deprecated Use MediaSession instead.
  void unregisterRemoteControlClient(
          remotecontrolclient_.RemoteControlClient rcClient) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterRemoteControlClient,
          jni.JniType.voidType,
          [rcClient.reference]).check();

  static final _id_registerRemoteController = jniAccessors.getMethodIDOf(
      _classRef,
      "registerRemoteController",
      "(Landroid/media/RemoteController;)Z");

  /// from: public boolean registerRemoteController(android.media.RemoteController rctlr)
  ///
  /// Registers a RemoteController instance for it to receive media
  /// metadata updates and playback state information from applications using
  /// RemoteControlClient, and control their playback.
  ///
  /// Registration requires the RemoteController.OnClientUpdateListener listener to be
  /// one of the enabled notification listeners (see
  /// android.service.notification.NotificationListenerService).
  ///@param rctlr the object to register.
  ///@return true if the RemoteController was successfully registered,
  ///         false if an error occurred, due to an internal system error, or
  ///         insufficient permissions.
  ///@deprecated Use
  ///             MediaSessionManager\#addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener, ComponentName)
  ///             and MediaController instead.
  bool registerRemoteController(remotecontroller_.RemoteController rctlr) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerRemoteController,
          jni.JniType.booleanType, [rctlr.reference]).boolean;

  static final _id_unregisterRemoteController = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterRemoteController",
      "(Landroid/media/RemoteController;)V");

  /// from: public void unregisterRemoteController(android.media.RemoteController rctlr)
  ///
  /// Unregisters a RemoteController, causing it to no longer receive
  /// media metadata and playback state information, and no longer be capable
  /// of controlling playback.
  ///@param rctlr the object to unregister.
  ///@deprecated Use
  ///             MediaSessionManager\#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)
  ///             instead.
  void unregisterRemoteController(remotecontroller_.RemoteController rctlr) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterRemoteController,
          jni.JniType.voidType, [rctlr.reference]).check();

  static final _id_registerAudioPlaybackCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerAudioPlaybackCallback",
      "(Landroid/media/AudioManager\$AudioPlaybackCallback;Landroid/os/Handler;)V");

  /// from: public void registerAudioPlaybackCallback(android.media.AudioManager.AudioPlaybackCallback cb, android.os.Handler handler)
  ///
  /// Register a callback to be notified of audio playback changes through
  /// AudioPlaybackCallback
  ///@param cb non-null callback to register
  /// This value must never be {@code null}.
  ///@param handler the Handler object for the thread on which to execute
  /// the callback. If <code>null</code>, the Handler associated with the main
  /// Looper will be used.
  void registerAudioPlaybackCallback(
          AudioManager_AudioPlaybackCallback cb, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerAudioPlaybackCallback,
          jni.JniType.voidType,
          [cb.reference, handler.reference]).check();

  static final _id_unregisterAudioPlaybackCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterAudioPlaybackCallback",
      "(Landroid/media/AudioManager\$AudioPlaybackCallback;)V");

  /// from: public void unregisterAudioPlaybackCallback(android.media.AudioManager.AudioPlaybackCallback cb)
  ///
  /// Unregister an audio playback callback previously registered with
  /// \#registerAudioPlaybackCallback(AudioPlaybackCallback, Handler).
  ///@param cb non-null callback to unregister
  ///
  /// This value must never be {@code null}.
  void unregisterAudioPlaybackCallback(AudioManager_AudioPlaybackCallback cb) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterAudioPlaybackCallback,
          jni.JniType.voidType,
          [cb.reference]).check();

  static final _id_getActivePlaybackConfigurations = jniAccessors.getMethodIDOf(
      _classRef, "getActivePlaybackConfigurations", "()Ljava/util/List;");

  /// from: public java.util.List<android.media.AudioPlaybackConfiguration> getActivePlaybackConfigurations()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current active audio playback configurations of the device
  ///@return a non-null list of playback configurations. An empty list indicates there is no
  ///     playback active when queried.
  ///@see AudioPlaybackConfiguration
  jni.JniObject getActivePlaybackConfigurations() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivePlaybackConfigurations,
          jni.JniType.objectType, []).object);

  static final _id_registerAudioRecordingCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerAudioRecordingCallback",
      "(Landroid/media/AudioManager\$AudioRecordingCallback;Landroid/os/Handler;)V");

  /// from: public void registerAudioRecordingCallback(android.media.AudioManager.AudioRecordingCallback cb, android.os.Handler handler)
  ///
  /// Register a callback to be notified of audio recording changes through
  /// AudioRecordingCallback
  ///@param cb non-null callback to register
  /// This value must never be {@code null}.
  ///@param handler the Handler object for the thread on which to execute
  /// the callback. If <code>null</code>, the Handler associated with the main
  /// Looper will be used.
  void registerAudioRecordingCallback(
          AudioManager_AudioRecordingCallback cb, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerAudioRecordingCallback,
          jni.JniType.voidType,
          [cb.reference, handler.reference]).check();

  static final _id_unregisterAudioRecordingCallback =
      jniAccessors.getMethodIDOf(_classRef, "unregisterAudioRecordingCallback",
          "(Landroid/media/AudioManager\$AudioRecordingCallback;)V");

  /// from: public void unregisterAudioRecordingCallback(android.media.AudioManager.AudioRecordingCallback cb)
  ///
  /// Unregister an audio recording callback previously registered with
  /// \#registerAudioRecordingCallback(AudioRecordingCallback, Handler).
  ///@param cb non-null callback to unregister
  ///
  /// This value must never be {@code null}.
  void unregisterAudioRecordingCallback(
          AudioManager_AudioRecordingCallback cb) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterAudioRecordingCallback,
          jni.JniType.voidType,
          [cb.reference]).check();

  static final _id_getActiveRecordingConfigurations =
      jniAccessors.getMethodIDOf(
          _classRef, "getActiveRecordingConfigurations", "()Ljava/util/List;");

  /// from: public java.util.List<android.media.AudioRecordingConfiguration> getActiveRecordingConfigurations()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current active audio recording configurations of the device.
  ///@return a non-null list of recording configurations. An empty list indicates there is
  ///     no recording active when queried.
  ///@see AudioRecordingConfiguration
  jni.JniObject getActiveRecordingConfigurations() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActiveRecordingConfigurations,
          jni.JniType.objectType, []).object);

  static final _id_getProperty = jniAccessors.getMethodIDOf(
      _classRef, "getProperty", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getProperty(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value of the property with the specified key.
  ///@param key One of the strings corresponding to a property key: either
  ///            \#PROPERTY_OUTPUT_SAMPLE_RATE,
  ///            \#PROPERTY_OUTPUT_FRAMES_PER_BUFFER,
  ///            \#PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND,
  ///            \#PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND, or
  ///            \#PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED.
  ///@return A string representing the associated value for that property key,
  ///         or null if there is no value for that key.
  jni.JniString getProperty(jni.JniString key) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getProperty, jni.JniType.objectType, [key.reference]).object);

  static final _id_getDevices = jniAccessors.getMethodIDOf(
      _classRef, "getDevices", "(I)[Landroid/media/AudioDeviceInfo;");

  /// from: public android.media.AudioDeviceInfo[] getDevices(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of AudioDeviceInfo objects corresponding to the audio devices
  /// currently connected to the system and meeting the criteria specified in the
  /// <code>flags</code> parameter.
  ///@param flags A set of bitflags specifying the criteria to test.
  ///@see \#GET_DEVICES_OUTPUTS
  ///@see \#GET_DEVICES_INPUTS
  ///@see \#GET_DEVICES_ALL
  ///@return A (possibly zero-length) array of AudioDeviceInfo objects.
  jni.JniObject getDevices(int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDevices, jni.JniType.objectType, [flags]).object);

  static final _id_registerAudioDeviceCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerAudioDeviceCallback",
      "(Landroid/media/AudioDeviceCallback;Landroid/os/Handler;)V");

  /// from: public void registerAudioDeviceCallback(android.media.AudioDeviceCallback callback, android.os.Handler handler)
  ///
  /// Registers an AudioDeviceCallback object to receive notifications of changes
  /// to the set of connected audio devices.
  ///@param callback The AudioDeviceCallback object to receive connect/disconnect
  /// notifications.
  ///@param handler Specifies the Handler object for the thread on which to execute
  /// the callback. If <code>null</code>, the Handler associated with the main
  /// Looper will be used.
  void registerAudioDeviceCallback(
          audiodevicecallback_.AudioDeviceCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerAudioDeviceCallback,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterAudioDeviceCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterAudioDeviceCallback",
      "(Landroid/media/AudioDeviceCallback;)V");

  /// from: public void unregisterAudioDeviceCallback(android.media.AudioDeviceCallback callback)
  ///
  /// Unregisters an AudioDeviceCallback object which has been previously registered
  /// to receive notifications of changes to the set of connected audio devices.
  ///@param callback The AudioDeviceCallback object that was previously registered
  /// with AudioManager\#registerAudioDeviceCallback to be unregistered.
  void unregisterAudioDeviceCallback(
          audiodevicecallback_.AudioDeviceCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterAudioDeviceCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_getMicrophones = jniAccessors.getMethodIDOf(
      _classRef, "getMicrophones", "()Ljava/util/List;");

  /// from: public java.util.List<android.media.MicrophoneInfo> getMicrophones()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of MicrophoneInfo that corresponds to the characteristics
  /// of all available microphones. The list is empty when no microphones are available
  /// on the device. An error during the query will result in an IOException being thrown.
  ///@return a list that contains all microphones' characteristics
  ///@throws IOException if an error occurs.
  jni.JniObject getMicrophones() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMicrophones, jni.JniType.objectType, []).object);
}

/// from: android.media.AudioManager$OnAudioFocusChangeListener
///
/// Interface definition for a callback to be invoked when the audio focus of the system is
/// updated.
class AudioManager_OnAudioFocusChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/AudioManager\$OnAudioFocusChangeListener");
  AudioManager_OnAudioFocusChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onAudioFocusChange =
      jniAccessors.getMethodIDOf(_classRef, "onAudioFocusChange", "(I)V");

  /// from: public abstract void onAudioFocusChange(int focusChange)
  ///
  /// Called on the listener to notify it the audio focus for this listener has been changed.
  /// The focusChange value indicates whether the focus was gained,
  /// whether the focus was lost, and whether that loss is transient, or whether the new focus
  /// holder will hold it for an unknown amount of time.
  /// When losing focus, listeners can use the focus change information to decide what
  /// behavior to adopt when losing focus. A music player could for instance elect to lower
  /// the volume of its music stream (duck) for transient focus losses, and pause otherwise.
  ///@param focusChange the type of focus change, one of AudioManager\#AUDIOFOCUS_GAIN,
  ///   AudioManager\#AUDIOFOCUS_LOSS, AudioManager\#AUDIOFOCUS_LOSS_TRANSIENT
  ///   and AudioManager\#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK.
  void onAudioFocusChange(int focusChange) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onAudioFocusChange,
      jni.JniType.voidType,
      [focusChange]).check();
}

/// from: android.media.AudioManager$AudioRecordingCallback
///
/// Interface for receiving update notifications about the recording configuration. Extend
/// this abstract class and register it with
/// AudioManager\#registerAudioRecordingCallback(AudioRecordingCallback, Handler)
/// to be notified.
/// Use AudioManager\#getActiveRecordingConfigurations() to query the current
/// configuration.
///@see AudioRecordingConfiguration
class AudioManager_AudioRecordingCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/AudioManager\$AudioRecordingCallback");
  AudioManager_AudioRecordingCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AudioManager_AudioRecordingCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onRecordingConfigChanged = jniAccessors.getMethodIDOf(
      _classRef, "onRecordingConfigChanged", "(Ljava/util/List;)V");

  /// from: public void onRecordingConfigChanged(java.util.List<android.media.AudioRecordingConfiguration> configs)
  ///
  /// Called whenever the device recording configuration has changed.
  ///@param configs list containing the results of
  ///      AudioManager\#getActiveRecordingConfigurations().
  void onRecordingConfigChanged(jni.JniObject configs) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRecordingConfigChanged,
          jni.JniType.voidType, [configs.reference]).check();
}

/// from: android.media.AudioManager$AudioPlaybackCallback
///
/// Interface for receiving update notifications about the playback activity on the system.
/// Extend this abstract class and register it with
/// AudioManager\#registerAudioPlaybackCallback(AudioPlaybackCallback, Handler)
/// to be notified.
/// Use AudioManager\#getActivePlaybackConfigurations() to query the current
/// configuration.
///@see AudioPlaybackConfiguration
class AudioManager_AudioPlaybackCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/AudioManager\$AudioPlaybackCallback");
  AudioManager_AudioPlaybackCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AudioManager_AudioPlaybackCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onPlaybackConfigChanged = jniAccessors.getMethodIDOf(
      _classRef, "onPlaybackConfigChanged", "(Ljava/util/List;)V");

  /// from: public void onPlaybackConfigChanged(java.util.List<android.media.AudioPlaybackConfiguration> configs)
  ///
  /// Called whenever the playback activity and configuration has changed.
  ///@param configs list containing the results of
  ///      AudioManager\#getActivePlaybackConfigurations().
  void onPlaybackConfigChanged(jni.JniObject configs) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPlaybackConfigChanged,
          jni.JniType.voidType, [configs.reference]).check();
}
