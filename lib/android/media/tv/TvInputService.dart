// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;

import "../../content/Context.dart" as context_;

import "../../net/Uri.dart" as uri_;

import "TvContentRating.dart" as tvcontentrating_;

import "../../view/Surface.dart" as surface_;

import "../../os/Bundle.dart" as bundle_;

import "../../view/View.dart" as view_;

import "../PlaybackParams.dart" as playbackparams_;

import "../../view/KeyEvent.dart" as keyevent_;

import "../../view/MotionEvent.dart" as motionevent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.tv.TvInputService
///
/// The TvInputService class represents a TV input or source such as HDMI or built-in tuner which
/// provides pass-through video or broadcast TV programs.
///
/// Applications will not normally use this service themselves, instead relying on the standard
/// interaction provided by TvView. Those implementing TV input services should normally do
/// so by deriving from this class and providing their own session implementation based on
/// TvInputService.Session. All TV input services must require that clients hold the
/// android.Manifest.permission\#BIND_TV_INPUT in order to interact with the service; if this
/// permission is not specified in the manifest, the system will refuse to bind to that TV input
/// service.
class TvInputService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/media/tv/TvInputService");
  TvInputService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// This is the interface name that a service implementing a TV input should say that it support
  /// -- that is, this is the action it uses for its intent filter. To be supported, the service
  /// must also require the android.Manifest.permission\#BIND_TV_INPUT permission so that
  /// other applications cannot abuse it.
  static const SERVICE_INTERFACE = "android.media.tv.TvInputService";

  /// from: static public final java.lang.String SERVICE_META_DATA
  ///
  /// Name under which a TvInputService component publishes information about itself.
  /// This meta-data must reference an XML resource containing an
  /// <code>&lt;android.R.styleable\#TvInputService tv-input&gt;</code>
  /// tag.
  static const SERVICE_META_DATA = "android.media.tv.input";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TvInputService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_onCreateSession = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateSession",
      "(Ljava/lang/String;)Landroid/media/tv/TvInputService\$Session;");

  /// from: public abstract android.media.tv.TvInputService.Session onCreateSession(java.lang.String inputId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a concrete implementation of Session.
  ///
  /// May return {@code null} if this TV input service fails to create a session for some
  /// reason. If TV input represents an external device connected to a hardware TV input,
  /// HardwareSession should be returned.
  ///@param inputId The ID of the TV input associated with the session.
  TvInputService_Session onCreateSession(jni.JniString inputId) =>
      TvInputService_Session.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateSession,
          jni.JniType.objectType,
          [inputId.reference]).object);

  static final _id_onCreateRecordingSession = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateRecordingSession",
      "(Ljava/lang/String;)Landroid/media/tv/TvInputService\$RecordingSession;");

  /// from: public android.media.tv.TvInputService.RecordingSession onCreateRecordingSession(java.lang.String inputId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a concrete implementation of RecordingSession.
  ///
  /// May return {@code null} if this TV input service fails to create a recording session for
  /// some reason.
  ///@param inputId The ID of the TV input associated with the recording session.
  TvInputService_RecordingSession onCreateRecordingSession(
          jni.JniString inputId) =>
      TvInputService_RecordingSession.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateRecordingSession,
          jni.JniType.objectType,
          [inputId.reference]).object);
}

/// from: android.media.tv.TvInputService$Session
///
/// Base class for derived classes to implement to provide a TV input session.
class TvInputService_Session extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/tv/TvInputService\$Session");
  TvInputService_Session.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new Session.
  ///@param context The context of the application
  TvInputService_Session(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_setOverlayViewEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setOverlayViewEnabled", "(Z)V");

  /// from: public void setOverlayViewEnabled(boolean enable)
  ///
  /// Enables or disables the overlay view.
  ///
  /// By default, the overlay view is disabled. Must be called explicitly after the
  /// session is created to enable the overlay view.
  ///
  /// The TV input service can disable its overlay view when the size of the overlay view is
  /// insufficient to display the whole information, such as when used in Picture-in-picture.
  /// Override \#onOverlayViewSizeChanged to get the size of the overlay view, which
  /// then can be used to determine whether to enable/disable the overlay view.
  ///@param enable {@code true} if you want to enable the overlay view. {@code false}
  ///            otherwise.
  void setOverlayViewEnabled(bool enable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOverlayViewEnabled,
      jni.JniType.voidType,
      [enable]).check();

  static final _id_notifyChannelRetuned = jniAccessors.getMethodIDOf(
      _classRef, "notifyChannelRetuned", "(Landroid/net/Uri;)V");

  /// from: public void notifyChannelRetuned(android.net.Uri channelUri)
  ///
  /// Informs the application that the current channel is re-tuned for some reason and the
  /// session now displays the content from a new channel. This is used to handle special cases
  /// such as when the current channel becomes unavailable, it is necessary to send the user to
  /// a certain channel or the user changes channel in some other way (e.g. by using a
  /// dedicated remote).
  ///@param channelUri The URI of the new channel.
  void notifyChannelRetuned(uri_.Uri channelUri) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyChannelRetuned,
          jni.JniType.voidType, [channelUri.reference]).check();

  static final _id_notifyTracksChanged = jniAccessors.getMethodIDOf(
      _classRef, "notifyTracksChanged", "(Ljava/util/List;)V");

  /// from: public void notifyTracksChanged(java.util.List<android.media.tv.TvTrackInfo> tracks)
  ///
  /// Sends the list of all audio/video/subtitle tracks. The is used by the framework to
  /// maintain the track information for a given session, which in turn is used by
  /// TvView\#getTracks for the application to retrieve metadata for a given track type.
  /// The TV input service must call this method as soon as the track information becomes
  /// available or is updated. Note that in a case where a part of the information for a
  /// certain track is updated, it is not necessary to create a new TvTrackInfo object
  /// with a different track ID.
  ///@param tracks A list which includes track information.
  void notifyTracksChanged(jni.JniObject tracks) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyTracksChanged,
          jni.JniType.voidType, [tracks.reference]).check();

  static final _id_notifyTrackSelected = jniAccessors.getMethodIDOf(
      _classRef, "notifyTrackSelected", "(ILjava/lang/String;)V");

  /// from: public void notifyTrackSelected(int type, java.lang.String trackId)
  ///
  /// Sends the type and ID of a selected track. This is used to inform the application that a
  /// specific track is selected. The TV input service must call this method as soon as a track
  /// is selected either by default or in response to a call to \#onSelectTrack. The
  /// selected track ID for a given type is maintained in the framework until the next call to
  /// this method even after the entire track list is updated (but is reset when the session is
  /// tuned to a new channel), so care must be taken not to result in an obsolete track ID.
  ///@param type The type of the selected track. The type can be
  ///            TvTrackInfo\#TYPE_AUDIO, TvTrackInfo\#TYPE_VIDEO or
  ///            TvTrackInfo\#TYPE_SUBTITLE.
  ///@param trackId The ID of the selected track.
  ///@see \#onSelectTrack
  void notifyTrackSelected(int type, jni.JniString trackId) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyTrackSelected,
          jni.JniType.voidType, [type, trackId.reference]).check();

  static final _id_notifyVideoAvailable =
      jniAccessors.getMethodIDOf(_classRef, "notifyVideoAvailable", "()V");

  /// from: public void notifyVideoAvailable()
  ///
  /// Informs the application that the video is now available for watching. Video is blocked
  /// until this method is called.
  ///
  /// The TV input service must call this method as soon as the content rendered onto its
  /// surface is ready for viewing. This method must be called each time \#onTune
  /// is called.
  ///@see \#notifyVideoUnavailable
  void notifyVideoAvailable() => jniAccessors.callMethodWithArgs(
      reference, _id_notifyVideoAvailable, jni.JniType.voidType, []).check();

  static final _id_notifyVideoUnavailable =
      jniAccessors.getMethodIDOf(_classRef, "notifyVideoUnavailable", "(I)V");

  /// from: public void notifyVideoUnavailable(int reason)
  ///
  /// Informs the application that the video became unavailable for some reason. This is
  /// primarily used to signal the application to block the screen not to show any intermittent
  /// video artifacts.
  ///@param reason The reason why the video became unavailable:
  ///            <ul>
  ///            <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_UNKNOWN
  ///            <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_TUNING
  ///            <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL
  ///            <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_BUFFERING
  ///            <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY
  ///            </ul>
  /// Value is android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_UNKNOWN, android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_TUNING, android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL, android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_BUFFERING, or android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY
  ///@see \#notifyVideoAvailable
  void notifyVideoUnavailable(int reason) => jniAccessors.callMethodWithArgs(
      reference,
      _id_notifyVideoUnavailable,
      jni.JniType.voidType,
      [reason]).check();

  static final _id_notifyContentAllowed =
      jniAccessors.getMethodIDOf(_classRef, "notifyContentAllowed", "()V");

  /// from: public void notifyContentAllowed()
  ///
  /// Informs the application that the user is allowed to watch the current program content.
  ///
  /// Each TV input service is required to query the system whether the user is allowed to
  /// watch the current program before showing it to the user if the parental controls is
  /// enabled (i.e. TvInputManager\#isParentalControlsEnabled TvInputManager.isParentalControlsEnabled() returns {@code true}). Whether the TV input
  /// service should block the content or not is determined by invoking
  /// TvInputManager\#isRatingBlocked TvInputManager.isRatingBlocked(TvContentRating)
  /// with the content rating for the current program. Then the TvInputManager makes a
  /// judgment based on the user blocked ratings stored in the secure settings and returns the
  /// result. If the rating in question turns out to be allowed by the user, the TV input
  /// service must call this method to notify the application that is permitted to show the
  /// content.
  ///
  /// Each TV input service also needs to continuously listen to any changes made to the
  /// parental controls settings by registering a broadcast receiver to receive
  /// TvInputManager\#ACTION_BLOCKED_RATINGS_CHANGED and
  /// TvInputManager\#ACTION_PARENTAL_CONTROLS_ENABLED_CHANGED and immediately
  /// reevaluate the current program with the new parental controls settings.
  ///@see \#notifyContentBlocked
  ///@see TvInputManager
  void notifyContentAllowed() => jniAccessors.callMethodWithArgs(
      reference, _id_notifyContentAllowed, jni.JniType.voidType, []).check();

  static final _id_notifyContentBlocked = jniAccessors.getMethodIDOf(_classRef,
      "notifyContentBlocked", "(Landroid/media/tv/TvContentRating;)V");

  /// from: public void notifyContentBlocked(android.media.tv.TvContentRating rating)
  ///
  /// Informs the application that the current program content is blocked by parent controls.
  ///
  /// Each TV input service is required to query the system whether the user is allowed to
  /// watch the current program before showing it to the user if the parental controls is
  /// enabled (i.e. TvInputManager\#isParentalControlsEnabled TvInputManager.isParentalControlsEnabled() returns {@code true}). Whether the TV input
  /// service should block the content or not is determined by invoking
  /// TvInputManager\#isRatingBlocked TvInputManager.isRatingBlocked(TvContentRating)
  /// with the content rating for the current program or TvContentRating\#UNRATED in
  /// case the rating information is missing. Then the TvInputManager makes a judgment
  /// based on the user blocked ratings stored in the secure settings and returns the result.
  /// If the rating in question turns out to be blocked, the TV input service must immediately
  /// block the content and call this method with the content rating of the current program to
  /// prompt the PIN verification screen.
  ///
  /// Each TV input service also needs to continuously listen to any changes made to the
  /// parental controls settings by registering a broadcast receiver to receive
  /// TvInputManager\#ACTION_BLOCKED_RATINGS_CHANGED and
  /// TvInputManager\#ACTION_PARENTAL_CONTROLS_ENABLED_CHANGED and immediately
  /// reevaluate the current program with the new parental controls settings.
  ///@param rating The content rating for the current TV program. Can be
  ///            TvContentRating\#UNRATED.
  /// This value must never be {@code null}.
  ///@see \#notifyContentAllowed
  ///@see TvInputManager
  void notifyContentBlocked(tvcontentrating_.TvContentRating rating) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyContentBlocked,
          jni.JniType.voidType, [rating.reference]).check();

  static final _id_notifyTimeShiftStatusChanged = jniAccessors.getMethodIDOf(
      _classRef, "notifyTimeShiftStatusChanged", "(I)V");

  /// from: public void notifyTimeShiftStatusChanged(int status)
  ///
  /// Informs the application that the time shift status is changed.
  ///
  /// Prior to calling this method, the application assumes the status
  /// TvInputManager\#TIME_SHIFT_STATUS_UNKNOWN. Right after the session is created, it
  /// is important to invoke the method with the status
  /// TvInputManager\#TIME_SHIFT_STATUS_AVAILABLE if the implementation does support
  /// time shifting, or TvInputManager\#TIME_SHIFT_STATUS_UNSUPPORTED otherwise. Failure
  /// to notifying the current status change immediately might result in an undesirable
  /// behavior in the application such as hiding the play controls.
  ///
  /// If the status TvInputManager\#TIME_SHIFT_STATUS_AVAILABLE is reported, the
  /// application assumes it can pause/resume playback, seek to a specified time position and
  /// set playback rate and audio mode. The implementation should override
  /// \#onTimeShiftPause, \#onTimeShiftResume, \#onTimeShiftSeekTo,
  /// \#onTimeShiftGetStartPosition, \#onTimeShiftGetCurrentPosition and
  /// \#onTimeShiftSetPlaybackParams.
  ///@param status The current time shift status. Should be one of the followings.
  /// <ul>
  /// <li>TvInputManager\#TIME_SHIFT_STATUS_UNSUPPORTED
  /// <li>TvInputManager\#TIME_SHIFT_STATUS_UNAVAILABLE
  /// <li>TvInputManager\#TIME_SHIFT_STATUS_AVAILABLE
  /// </ul>
  ///
  /// Value is android.media.tv.TvInputManager\#TIME_SHIFT_STATUS_UNKNOWN, android.media.tv.TvInputManager\#TIME_SHIFT_STATUS_UNSUPPORTED, android.media.tv.TvInputManager\#TIME_SHIFT_STATUS_UNAVAILABLE, or android.media.tv.TvInputManager\#TIME_SHIFT_STATUS_AVAILABLE
  void notifyTimeShiftStatusChanged(int status) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyTimeShiftStatusChanged,
          jni.JniType.voidType,
          [status]).check();

  static final _id_layoutSurface =
      jniAccessors.getMethodIDOf(_classRef, "layoutSurface", "(IIII)V");

  /// from: public void layoutSurface(int left, int top, int right, int bottom)
  ///
  /// Assigns a size and position to the surface passed in \#onSetSurface. The position
  /// is relative to the overlay view that sits on top of this surface.
  ///@param left Left position in pixels, relative to the overlay view.
  ///@param top Top position in pixels, relative to the overlay view.
  ///@param right Right position in pixels, relative to the overlay view.
  ///@param bottom Bottom position in pixels, relative to the overlay view.
  ///@see \#onOverlayViewSizeChanged
  void layoutSurface(int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_layoutSurface,
          jni.JniType.voidType, [left, top, right, bottom]).check();

  static final _id_onRelease =
      jniAccessors.getMethodIDOf(_classRef, "onRelease", "()V");

  /// from: public abstract void onRelease()
  ///
  /// Called when the session is released.
  void onRelease() => jniAccessors.callMethodWithArgs(
      reference, _id_onRelease, jni.JniType.voidType, []).check();

  static final _id_onSetSurface = jniAccessors.getMethodIDOf(
      _classRef, "onSetSurface", "(Landroid/view/Surface;)Z");

  /// from: public abstract boolean onSetSurface(android.view.Surface surface)
  ///
  /// Called when the application sets the surface.
  ///
  /// The TV input service should render video onto the given surface. When called with
  /// {@code null}, the input service should immediately free any references to the
  /// currently set surface and stop using it.
  ///@param surface The surface to be used for video rendering. Can be {@code null}.
  /// This value may be {@code null}.
  ///@return {@code true} if the surface was set successfully, {@code false} otherwise.
  bool onSetSurface(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSetSurface,
          jni.JniType.booleanType, [surface.reference]).boolean;

  static final _id_onSurfaceChanged =
      jniAccessors.getMethodIDOf(_classRef, "onSurfaceChanged", "(III)V");

  /// from: public void onSurfaceChanged(int format, int width, int height)
  ///
  /// Called after any structural changes (format or size) have been made to the surface passed
  /// in \#onSetSurface. This method is always called at least once, after
  /// \#onSetSurface is called with non-null surface.
  ///@param format The new PixelFormat of the surface.
  ///@param width The new width of the surface.
  ///@param height The new height of the surface.
  void onSurfaceChanged(int format, int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSurfaceChanged,
          jni.JniType.voidType, [format, width, height]).check();

  static final _id_onOverlayViewSizeChanged = jniAccessors.getMethodIDOf(
      _classRef, "onOverlayViewSizeChanged", "(II)V");

  /// from: public void onOverlayViewSizeChanged(int width, int height)
  ///
  /// Called when the size of the overlay view is changed by the application.
  ///
  /// This is always called at least once when the session is created regardless of whether
  /// the overlay view is enabled or not. The overlay view size is the same as the containing
  /// TvView. Note that the size of the underlying surface can be different if the
  /// surface was changed by calling \#layoutSurface.
  ///@param width The width of the overlay view.
  ///@param height The height of the overlay view.
  void onOverlayViewSizeChanged(int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_onOverlayViewSizeChanged,
          jni.JniType.voidType, [width, height]).check();

  static final _id_onSetStreamVolume =
      jniAccessors.getMethodIDOf(_classRef, "onSetStreamVolume", "(F)V");

  /// from: public abstract void onSetStreamVolume(float volume)
  ///
  /// Sets the relative stream volume of the current TV input session.
  ///
  /// The implementation should honor this request in order to handle audio focus changes or
  /// mute the current session when multiple sessions, possibly from different inputs are
  /// active. If the method has not yet been called, the implementation should assume the
  /// default value of {@code 1.0f}.
  ///@param volume A volume value between {@code 0.0f} to {@code 1.0f}.
  ///
  /// Value is between 0.0 and 1.0 inclusive
  void onSetStreamVolume(double volume) => jniAccessors.callMethodWithArgs(
      reference, _id_onSetStreamVolume, jni.JniType.voidType, [volume]).check();

  static final _id_onTune =
      jniAccessors.getMethodIDOf(_classRef, "onTune", "(Landroid/net/Uri;)Z");

  /// from: public abstract boolean onTune(android.net.Uri channelUri)
  ///
  /// Tunes to a given channel.
  ///
  /// No video will be displayed until \#notifyVideoAvailable() is called.
  /// Also, \#notifyVideoUnavailable(int) should be called when the TV input cannot
  /// continue playing the given channel.
  ///@param channelUri The URI of the channel.
  ///@return {@code true} if the tuning was successful, {@code false} otherwise.
  bool onTune(uri_.Uri channelUri) => jniAccessors.callMethodWithArgs(reference,
      _id_onTune, jni.JniType.booleanType, [channelUri.reference]).boolean;

  static final _id_onTune1 = jniAccessors.getMethodIDOf(
      _classRef, "onTune", "(Landroid/net/Uri;Landroid/os/Bundle;)Z");

  /// from: public boolean onTune(android.net.Uri channelUri, android.os.Bundle params)
  ///
  /// Tunes to a given channel. Override this method in order to handle domain-specific
  /// features that are only known between certain TV inputs and their clients.
  ///
  /// The default implementation calls \#onTune(Uri).
  ///@param channelUri The URI of the channel.
  ///@param params Domain-specific data for this tune request. Keys _must_ be a scoped
  ///            name, i.e. prefixed with a package name you own, so that different developers
  ///            will not create conflicting keys.
  ///@return {@code true} if the tuning was successful, {@code false} otherwise.
  bool onTune1(uri_.Uri channelUri, bundle_.Bundle params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTune1,
          jni.JniType.booleanType,
          [channelUri.reference, params.reference]).boolean;

  static final _id_onSetCaptionEnabled =
      jniAccessors.getMethodIDOf(_classRef, "onSetCaptionEnabled", "(Z)V");

  /// from: public abstract void onSetCaptionEnabled(boolean enabled)
  ///
  /// Enables or disables the caption.
  ///
  /// The locale for the user's preferred captioning language can be obtained by calling
  /// CaptioningManager\#getLocale CaptioningManager.getLocale().
  ///@param enabled {@code true} to enable, {@code false} to disable.
  ///@see CaptioningManager
  void onSetCaptionEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSetCaptionEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_onUnblockContent = jniAccessors.getMethodIDOf(
      _classRef, "onUnblockContent", "(Landroid/media/tv/TvContentRating;)V");

  /// from: public void onUnblockContent(android.media.tv.TvContentRating unblockedRating)
  ///
  /// Requests to unblock the content according to the given rating.
  ///
  /// The implementation should unblock the content.
  /// TV input service has responsibility to decide when/how the unblock expires
  /// while it can keep previously unblocked ratings in order not to ask a user
  /// to unblock whenever a content rating is changed.
  /// Therefore an unblocked rating can be valid for a channel, a program,
  /// or certain amount of time depending on the implementation.
  ///@param unblockedRating An unblocked content rating
  void onUnblockContent(tvcontentrating_.TvContentRating unblockedRating) =>
      jniAccessors.callMethodWithArgs(reference, _id_onUnblockContent,
          jni.JniType.voidType, [unblockedRating.reference]).check();

  static final _id_onSelectTrack = jniAccessors.getMethodIDOf(
      _classRef, "onSelectTrack", "(ILjava/lang/String;)Z");

  /// from: public boolean onSelectTrack(int type, java.lang.String trackId)
  ///
  /// Selects a given track.
  ///
  /// If this is done successfully, the implementation should call
  /// \#notifyTrackSelected to help applications maintain the up-to-date list of the
  /// selected tracks.
  ///@param trackId The ID of the track to select. {@code null} means to unselect the current
  ///            track for a given type.
  /// This value may be {@code null}.
  ///@param type The type of the track to select. The type can be
  ///            TvTrackInfo\#TYPE_AUDIO, TvTrackInfo\#TYPE_VIDEO or
  ///            TvTrackInfo\#TYPE_SUBTITLE.
  ///@return {@code true} if the track selection was successful, {@code false} otherwise.
  ///@see \#notifyTrackSelected
  bool onSelectTrack(int type, jni.JniString trackId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSelectTrack,
          jni.JniType.booleanType, [type, trackId.reference]).boolean;

  static final _id_onAppPrivateCommand = jniAccessors.getMethodIDOf(_classRef,
      "onAppPrivateCommand", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onAppPrivateCommand(java.lang.String action, android.os.Bundle data)
  ///
  /// Processes a private command sent from the application to the TV input. This can be used
  /// to provide domain-specific features that are only known between certain TV inputs and
  /// their clients.
  ///@param action Name of the command to be performed. This _must_ be a scoped name,
  ///            i.e. prefixed with a package name you own, so that different developers will
  ///            not create conflicting commands.
  /// This value must never be {@code null}.
  ///@param data Any data to include with the command.
  void onAppPrivateCommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAppPrivateCommand,
          jni.JniType.voidType, [action.reference, data.reference]).check();

  static final _id_onCreateOverlayView = jniAccessors.getMethodIDOf(
      _classRef, "onCreateOverlayView", "()Landroid/view/View;");

  /// from: public android.view.View onCreateOverlayView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when the application requests to create an overlay view. Each session
  /// implementation can override this method and return its own view.
  ///@return a view attached to the overlay window
  view_.View onCreateOverlayView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreateOverlayView, jni.JniType.objectType, []).object);

  static final _id_onTimeShiftPlay = jniAccessors.getMethodIDOf(
      _classRef, "onTimeShiftPlay", "(Landroid/net/Uri;)V");

  /// from: public void onTimeShiftPlay(android.net.Uri recordedProgramUri)
  ///
  /// Called when the application requests to play a given recorded TV program.
  ///@param recordedProgramUri The URI of a recorded TV program.
  ///@see \#onTimeShiftResume()
  ///@see \#onTimeShiftPause()
  ///@see \#onTimeShiftSeekTo(long)
  ///@see \#onTimeShiftSetPlaybackParams(PlaybackParams)
  ///@see \#onTimeShiftGetStartPosition()
  ///@see \#onTimeShiftGetCurrentPosition()
  void onTimeShiftPlay(uri_.Uri recordedProgramUri) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTimeShiftPlay,
          jni.JniType.voidType, [recordedProgramUri.reference]).check();

  static final _id_onTimeShiftPause =
      jniAccessors.getMethodIDOf(_classRef, "onTimeShiftPause", "()V");

  /// from: public void onTimeShiftPause()
  ///
  /// Called when the application requests to pause playback.
  ///@see \#onTimeShiftPlay(Uri)
  ///@see \#onTimeShiftResume()
  ///@see \#onTimeShiftSeekTo(long)
  ///@see \#onTimeShiftSetPlaybackParams(PlaybackParams)
  ///@see \#onTimeShiftGetStartPosition()
  ///@see \#onTimeShiftGetCurrentPosition()
  void onTimeShiftPause() => jniAccessors.callMethodWithArgs(
      reference, _id_onTimeShiftPause, jni.JniType.voidType, []).check();

  static final _id_onTimeShiftResume =
      jniAccessors.getMethodIDOf(_classRef, "onTimeShiftResume", "()V");

  /// from: public void onTimeShiftResume()
  ///
  /// Called when the application requests to resume playback.
  ///@see \#onTimeShiftPlay(Uri)
  ///@see \#onTimeShiftPause()
  ///@see \#onTimeShiftSeekTo(long)
  ///@see \#onTimeShiftSetPlaybackParams(PlaybackParams)
  ///@see \#onTimeShiftGetStartPosition()
  ///@see \#onTimeShiftGetCurrentPosition()
  void onTimeShiftResume() => jniAccessors.callMethodWithArgs(
      reference, _id_onTimeShiftResume, jni.JniType.voidType, []).check();

  static final _id_onTimeShiftSeekTo =
      jniAccessors.getMethodIDOf(_classRef, "onTimeShiftSeekTo", "(J)V");

  /// from: public void onTimeShiftSeekTo(long timeMs)
  ///
  /// Called when the application requests to seek to a specified time position. Normally, the
  /// position is given within range between the start and the current time, inclusively. The
  /// implementation is expected to seek to the nearest time position if the given position is
  /// not in the range.
  ///@param timeMs The time position to seek to, in milliseconds since the epoch.
  ///@see \#onTimeShiftPlay(Uri)
  ///@see \#onTimeShiftResume()
  ///@see \#onTimeShiftPause()
  ///@see \#onTimeShiftSetPlaybackParams(PlaybackParams)
  ///@see \#onTimeShiftGetStartPosition()
  ///@see \#onTimeShiftGetCurrentPosition()
  void onTimeShiftSeekTo(int timeMs) => jniAccessors.callMethodWithArgs(
      reference, _id_onTimeShiftSeekTo, jni.JniType.voidType, [timeMs]).check();

  static final _id_onTimeShiftSetPlaybackParams = jniAccessors.getMethodIDOf(
      _classRef,
      "onTimeShiftSetPlaybackParams",
      "(Landroid/media/PlaybackParams;)V");

  /// from: public void onTimeShiftSetPlaybackParams(android.media.PlaybackParams params)
  ///
  /// Called when the application sets playback parameters containing the speed and audio mode.
  ///
  /// Once the playback parameters are set, the implementation should honor the current
  /// settings until the next tune request. Pause/resume/seek request does not reset the
  /// parameters previously set.
  ///@param params The playback params.
  ///@see \#onTimeShiftPlay(Uri)
  ///@see \#onTimeShiftResume()
  ///@see \#onTimeShiftPause()
  ///@see \#onTimeShiftSeekTo(long)
  ///@see \#onTimeShiftGetStartPosition()
  ///@see \#onTimeShiftGetCurrentPosition()
  void onTimeShiftSetPlaybackParams(playbackparams_.PlaybackParams params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTimeShiftSetPlaybackParams,
          jni.JniType.voidType,
          [params.reference]).check();

  static final _id_onTimeShiftGetStartPosition = jniAccessors.getMethodIDOf(
      _classRef, "onTimeShiftGetStartPosition", "()J");

  /// from: public long onTimeShiftGetStartPosition()
  ///
  /// Returns the start position for time shifting, in milliseconds since the epoch.
  /// Returns TvInputManager\#TIME_SHIFT_INVALID_TIME if the position is unknown at the
  /// moment.
  ///
  /// The start position for time shifting indicates the earliest possible time the user can
  /// seek to. Initially this is equivalent to the time when the implementation starts
  /// recording. Later it may be adjusted because there is insufficient space or the duration
  /// of recording is limited by the implementation. The application does not allow the user to
  /// seek to a position earlier than the start position.
  ///
  /// For playback of a recorded program initiated by \#onTimeShiftPlay(Uri), the
  /// start position should be 0 and does not change.
  ///@see \#onTimeShiftPlay(Uri)
  ///@see \#onTimeShiftResume()
  ///@see \#onTimeShiftPause()
  ///@see \#onTimeShiftSeekTo(long)
  ///@see \#onTimeShiftSetPlaybackParams(PlaybackParams)
  ///@see \#onTimeShiftGetCurrentPosition()
  int onTimeShiftGetStartPosition() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onTimeShiftGetStartPosition,
      jni.JniType.longType, []).long;

  static final _id_onTimeShiftGetCurrentPosition = jniAccessors.getMethodIDOf(
      _classRef, "onTimeShiftGetCurrentPosition", "()J");

  /// from: public long onTimeShiftGetCurrentPosition()
  ///
  /// Returns the current position for time shifting, in milliseconds since the epoch.
  /// Returns TvInputManager\#TIME_SHIFT_INVALID_TIME if the position is unknown at the
  /// moment.
  ///
  /// The current position for time shifting is the same as the current position of
  /// playback. It should be equal to or greater than the start position reported by
  /// \#onTimeShiftGetStartPosition(). When playback is completed, the current position
  /// should stay where the playback ends, in other words, the returned value of this mehtod
  /// should be equal to the start position plus the duration of the program.
  ///@see \#onTimeShiftPlay(Uri)
  ///@see \#onTimeShiftResume()
  ///@see \#onTimeShiftPause()
  ///@see \#onTimeShiftSeekTo(long)
  ///@see \#onTimeShiftSetPlaybackParams(PlaybackParams)
  ///@see \#onTimeShiftGetStartPosition()
  int onTimeShiftGetCurrentPosition() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onTimeShiftGetCurrentPosition,
      jni.JniType.longType, []).long;

  static final _id_onKeyDown = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of android.view.KeyEvent.Callback\#onKeyDown(int, KeyEvent) KeyEvent.Callback.onKeyDown(): always returns false (doesn't handle the event).
  ///
  /// Override this to intercept key down events before they are processed by the
  /// application. If you return true, the application will not process the event itself. If
  /// you return false, the normal application processing will occur as if the TV input had not
  /// seen the event at all.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to
  ///         be handled by the next receiver, return {@code false}.
  bool onKeyDown(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyLongPress = jniAccessors.getMethodIDOf(
      _classRef, "onKeyLongPress", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of
  /// android.view.KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle the event).
  ///
  /// Override this to intercept key long press events before they are processed by the
  /// application. If you return true, the application will not process the event itself. If
  /// you return false, the normal application processing will occur as if the TV input had not
  /// seen the event at all.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to
  ///         be handled by the next receiver, return {@code false}.
  bool onKeyLongPress(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyLongPress,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyMultiple = jniAccessors.getMethodIDOf(
      _classRef, "onKeyMultiple", "(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int keyCode, int count, android.view.KeyEvent event)
  ///
  /// Default implementation of
  /// android.view.KeyEvent.Callback\#onKeyMultiple(int, int, KeyEvent) KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle the event).
  ///
  /// Override this to intercept special key multiple events before they are processed by
  /// the application. If you return true, the application will not itself process the event.
  /// If you return false, the normal application processing will occur as if the TV input had
  /// not seen the event at all.
  ///@param keyCode The value in event.getKeyCode().
  ///@param count The number of times the action was made.
  ///@param event Description of the key event.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to
  ///         be handled by the next receiver, return {@code false}.
  bool onKeyMultiple(int keyCode, int count, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyMultiple,
          jni.JniType.booleanType, [keyCode, count, event.reference]).boolean;

  static final _id_onKeyUp = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of android.view.KeyEvent.Callback\#onKeyUp(int, KeyEvent) KeyEvent.Callback.onKeyUp(): always returns false (doesn't handle the event).
  ///
  /// Override this to intercept key up events before they are processed by the application.
  /// If you return true, the application will not itself process the event. If you return false,
  /// the normal application processing will occur as if the TV input had not seen the event at
  /// all.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to
  ///         be handled by the next receiver, return {@code false}.
  bool onKeyUp(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to handle touch screen motion events on the current input session.
  ///@param event The motion event being received.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to
  ///         be handled by the next receiver, return {@code false}.
  ///@see View\#onTouchEvent
  bool onTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to handle trackball events on the current input session.
  ///@param event The motion event being received.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to
  ///         be handled by the next receiver, return {@code false}.
  ///@see View\#onTrackballEvent
  bool onTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Implement this method to handle generic motion events on the current input session.
  ///@param event The motion event being received.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to
  ///         be handled by the next receiver, return {@code false}.
  ///@see View\#onGenericMotionEvent
  bool onGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;
}

/// from: android.media.tv.TvInputService$RecordingSession
///
/// Base class for derived classes to implement to provide a TV input recording session.
class TvInputService_RecordingSession extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/tv/TvInputService\$RecordingSession");
  TvInputService_RecordingSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new RecordingSession.
  ///@param context The context of the application
  TvInputService_RecordingSession(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_notifyTuned = jniAccessors.getMethodIDOf(
      _classRef, "notifyTuned", "(Landroid/net/Uri;)V");

  /// from: public void notifyTuned(android.net.Uri channelUri)
  ///
  /// Informs the application that this recording session has been tuned to the given channel
  /// and is ready to start recording.
  ///
  /// Upon receiving a call to \#onTune(Uri), the session is expected to tune to the
  /// passed channel and call this method to indicate that it is now available for immediate
  /// recording. When \#onStartRecording(Uri) is called, recording must start with
  /// minimal delay.
  ///@param channelUri The URI of a channel.
  void notifyTuned(uri_.Uri channelUri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_notifyTuned,
      jni.JniType.voidType,
      [channelUri.reference]).check();

  static final _id_notifyRecordingStopped = jniAccessors.getMethodIDOf(
      _classRef, "notifyRecordingStopped", "(Landroid/net/Uri;)V");

  /// from: public void notifyRecordingStopped(android.net.Uri recordedProgramUri)
  ///
  /// Informs the application that this recording session has stopped recording and created a
  /// new data entry in the TvContract.RecordedPrograms table that describes the newly
  /// recorded program.
  ///
  /// The recording session must call this method in response to \#onStopRecording().
  /// The session may call it even before receiving a call to \#onStopRecording() if a
  /// partially recorded program is available when there is an error.
  ///@param recordedProgramUri The URI of the newly recorded program.
  void notifyRecordingStopped(uri_.Uri recordedProgramUri) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyRecordingStopped,
          jni.JniType.voidType, [recordedProgramUri.reference]).check();

  static final _id_notifyError =
      jniAccessors.getMethodIDOf(_classRef, "notifyError", "(I)V");

  /// from: public void notifyError(int error)
  ///
  /// Informs the application that there is an error and this recording session is no longer
  /// able to start or continue recording. It may be called at any time after the recording
  /// session is created until \#onRelease() is called.
  ///
  /// The application may release the current session upon receiving the error code through
  /// TvRecordingClient.RecordingCallback\#onError(int). The session may call
  /// \#notifyRecordingStopped(Uri) if a partially recorded but still playable program
  /// is available, before calling this method.
  ///@param error The error code. Should be one of the followings.
  /// <ul>
  /// <li>TvInputManager\#RECORDING_ERROR_UNKNOWN
  /// <li>TvInputManager\#RECORDING_ERROR_INSUFFICIENT_SPACE
  /// <li>TvInputManager\#RECORDING_ERROR_RESOURCE_BUSY
  /// </ul>
  ///
  /// Value is android.media.tv.TvInputManager\#RECORDING_ERROR_UNKNOWN, android.media.tv.TvInputManager\#RECORDING_ERROR_INSUFFICIENT_SPACE, or android.media.tv.TvInputManager\#RECORDING_ERROR_RESOURCE_BUSY
  void notifyError(int error) => jniAccessors.callMethodWithArgs(
      reference, _id_notifyError, jni.JniType.voidType, [error]).check();

  static final _id_onTune =
      jniAccessors.getMethodIDOf(_classRef, "onTune", "(Landroid/net/Uri;)V");

  /// from: public abstract void onTune(android.net.Uri channelUri)
  ///
  /// Called when the application requests to tune to a given channel for TV program recording.
  ///
  /// The application may call this method before starting or after stopping recording, but
  /// not during recording.
  ///
  /// The session must call \#notifyTuned(Uri) if the tune request was fulfilled, or
  /// \#notifyError(int) otherwise.
  ///@param channelUri The URI of a channel.
  void onTune(uri_.Uri channelUri) => jniAccessors.callMethodWithArgs(reference,
      _id_onTune, jni.JniType.voidType, [channelUri.reference]).check();

  static final _id_onTune1 = jniAccessors.getMethodIDOf(
      _classRef, "onTune", "(Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void onTune(android.net.Uri channelUri, android.os.Bundle params)
  ///
  /// Called when the application requests to tune to a given channel for TV program recording.
  /// Override this method in order to handle domain-specific features that are only known
  /// between certain TV inputs and their clients.
  ///
  /// The application may call this method before starting or after stopping recording, but
  /// not during recording. The default implementation calls \#onTune(Uri).
  ///
  /// The session must call \#notifyTuned(Uri) if the tune request was fulfilled, or
  /// \#notifyError(int) otherwise.
  ///@param channelUri The URI of a channel.
  ///@param params Domain-specific data for this tune request. Keys _must_ be a scoped
  ///            name, i.e. prefixed with a package name you own, so that different developers
  ///            will not create conflicting keys.
  void onTune1(uri_.Uri channelUri, bundle_.Bundle params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTune1,
          jni.JniType.voidType,
          [channelUri.reference, params.reference]).check();

  static final _id_onStartRecording = jniAccessors.getMethodIDOf(
      _classRef, "onStartRecording", "(Landroid/net/Uri;)V");

  /// from: public abstract void onStartRecording(android.net.Uri programUri)
  ///
  /// Called when the application requests to start TV program recording. Recording must start
  /// immediately when this method is called.
  ///
  /// The application may supply the URI for a TV program for filling in program specific
  /// data fields in the android.media.tv.TvContract.RecordedPrograms table.
  /// A non-null {@code programUri} implies the started recording should be of that specific
  /// program, whereas null {@code programUri} does not impose such a requirement and the
  /// recording can span across multiple TV programs. In either case, the application must call
  /// TvRecordingClient\#stopRecording() to stop the recording.
  ///
  /// The session must call \#notifyError(int) if the start request cannot be
  /// fulfilled.
  ///@param programUri The URI for the TV program to record, built by
  ///            TvContract\#buildProgramUri(long). Can be {@code null}.
  ///
  /// This value may be {@code null}.
  void onStartRecording(uri_.Uri programUri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onStartRecording,
      jni.JniType.voidType,
      [programUri.reference]).check();

  static final _id_onStopRecording =
      jniAccessors.getMethodIDOf(_classRef, "onStopRecording", "()V");

  /// from: public abstract void onStopRecording()
  ///
  /// Called when the application requests to stop TV program recording. Recording must stop
  /// immediately when this method is called.
  ///
  /// The session must create a new data entry in the
  /// android.media.tv.TvContract.RecordedPrograms table that describes the newly
  /// recorded program and call \#notifyRecordingStopped(Uri) with the URI to that
  /// entry.
  /// If the stop request cannot be fulfilled, the session must call \#notifyError(int).
  void onStopRecording() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopRecording, jni.JniType.voidType, []).check();

  static final _id_onRelease =
      jniAccessors.getMethodIDOf(_classRef, "onRelease", "()V");

  /// from: public abstract void onRelease()
  ///
  /// Called when the application requests to release all the resources held by this recording
  /// session.
  void onRelease() => jniAccessors.callMethodWithArgs(
      reference, _id_onRelease, jni.JniType.voidType, []).check();

  static final _id_onAppPrivateCommand = jniAccessors.getMethodIDOf(_classRef,
      "onAppPrivateCommand", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onAppPrivateCommand(java.lang.String action, android.os.Bundle data)
  ///
  /// Processes a private command sent from the application to the TV input. This can be used
  /// to provide domain-specific features that are only known between certain TV inputs and
  /// their clients.
  ///@param action Name of the command to be performed. This _must_ be a scoped name,
  ///            i.e. prefixed with a package name you own, so that different developers will
  ///            not create conflicting commands.
  /// This value must never be {@code null}.
  ///@param data Any data to include with the command.
  void onAppPrivateCommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAppPrivateCommand,
          jni.JniType.voidType, [action.reference, data.reference]).check();
}

/// from: android.media.tv.TvInputService$HardwareSession
///
/// Base class for a TV input session which represents an external device connected to a
/// hardware TV input.
///
/// This class is for an input which provides channels for the external set-top box to the
/// application. Once a TV input returns an implementation of this class on
/// \#onCreateSession(String), the framework will create a separate session for
/// a hardware TV Input (e.g. HDMI 1) and forward the application's surface to the session so
/// that the user can see the screen of the hardware TV Input when she tunes to a channel from
/// this TV input. The implementation of this class is expected to change the channel of the
/// external set-top box via a proprietary protocol when HardwareSession\#onTune is
/// requested by the application.
///
/// Note that this class is not for inputs for internal hardware like built-in tuner and HDMI
/// 1.
///@see \#onCreateSession(String)
class TvInputService_HardwareSession extends TvInputService_Session {
  static final _classRef = jniAccessors
      .getClassOf("android/media/tv/TvInputService\$HardwareSession");
  TvInputService_HardwareSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new HardwareSession.
  ///@param context The context of the application
  TvInputService_HardwareSession(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_getHardwareInputId = jniAccessors.getMethodIDOf(
      _classRef, "getHardwareInputId", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getHardwareInputId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the hardware TV input ID the external device is connected to.
  ///
  /// TV input is expected to provide android.R.attr\#setupActivity so that
  /// the application can launch it before using this TV input. The setup activity may let
  /// the user select the hardware TV input to which the external device is connected. The ID
  /// of the selected one should be stored in the TV input so that it can be returned here.
  jni.JniString getHardwareInputId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getHardwareInputId, jni.JniType.objectType, []).object);

  static final _id_onSetSurface = jniAccessors.getMethodIDOf(
      _classRef, "onSetSurface", "(Landroid/view/Surface;)Z");

  /// from: public final boolean onSetSurface(android.view.Surface surface)
  ///
  /// This method will not be called in HardwareSession. Framework will
  /// forward the application's surface to the hardware TV input.
  bool onSetSurface(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSetSurface,
          jni.JniType.booleanType, [surface.reference]).boolean;

  static final _id_onHardwareVideoAvailable =
      jniAccessors.getMethodIDOf(_classRef, "onHardwareVideoAvailable", "()V");

  /// from: public void onHardwareVideoAvailable()
  ///
  /// Called when the underlying hardware TV input session calls
  /// TvInputService.Session\#notifyVideoAvailable().
  void onHardwareVideoAvailable() => jniAccessors.callMethodWithArgs(reference,
      _id_onHardwareVideoAvailable, jni.JniType.voidType, []).check();

  static final _id_onHardwareVideoUnavailable = jniAccessors.getMethodIDOf(
      _classRef, "onHardwareVideoUnavailable", "(I)V");

  /// from: public void onHardwareVideoUnavailable(int reason)
  ///
  /// Called when the underlying hardware TV input session calls
  /// TvInputService.Session\#notifyVideoUnavailable(int).
  ///@param reason The reason that the hardware TV input stopped the playback:
  /// <ul>
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_UNKNOWN
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_TUNING
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_BUFFERING
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY
  /// </ul>
  void onHardwareVideoUnavailable(int reason) =>
      jniAccessors.callMethodWithArgs(reference, _id_onHardwareVideoUnavailable,
          jni.JniType.voidType, [reason]).check();
}
