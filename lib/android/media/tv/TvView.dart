// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../view/ViewGroup.dart" as viewgroup_;

import "../../content/Context.dart" as context_;

import "../../util/AttributeSet.dart" as attributeset_;

import "../../net/Uri.dart" as uri_;

import "../../os/Bundle.dart" as bundle_;

import "../PlaybackParams.dart" as playbackparams_;

import "../../view/InputEvent.dart" as inputevent_;

import "../../view/KeyEvent.dart" as keyevent_;

import "../../view/MotionEvent.dart" as motionevent_;

import "../../graphics/Region.dart" as region_;

import "../../graphics/Canvas.dart" as canvas_;

import "../../view/View.dart" as view_;

import "TvContentRating.dart" as tvcontentrating_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.tv.TvView
///
/// Displays TV contents. The TvView class provides a high level interface for applications to show
/// TV programs from various TV sources that implement TvInputService. (Note that the list of
/// TV inputs available on the system can be obtained by calling
/// TvInputManager\#getTvInputList() TvInputManager.getTvInputList().)
///
/// Once the application supplies the URI for a specific TV channel to \#tune
/// method, it takes care of underlying service binding (and unbinding if the current TvView is
/// already bound to a service) and automatically allocates/deallocates resources needed. In addition
/// to a few essential methods to control how the contents are presented, it also provides a way to
/// dispatch input events to the connected TvInputService in order to enable custom key actions for
/// the TV input.
class TvView extends viewgroup_.ViewGroup {
  static final _classRef = jniAccessors.getClassOf("android/media/tv/TvView");
  TvView.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TvView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TvView.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TvView.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_setCallback = jniAccessors.getMethodIDOf(_classRef,
      "setCallback", "(Landroid/media/tv/TvView\$TvInputCallback;)V");

  /// from: public void setCallback(android.media.tv.TvView.TvInputCallback callback)
  ///
  /// Sets the callback to be invoked when an event is dispatched to this TvView.
  ///@param callback The callback to receive events. A value of {@code null} removes the existing
  ///            callback.
  ///
  /// This value may be {@code null}.
  void setCallback(TvView_TvInputCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_setZOrderMediaOverlay =
      jniAccessors.getMethodIDOf(_classRef, "setZOrderMediaOverlay", "(Z)V");

  /// from: public void setZOrderMediaOverlay(boolean isMediaOverlay)
  ///
  /// Controls whether the TvView's surface is placed on top of another regular surface view in the
  /// window (but still behind the window itself).
  /// This is typically used to place overlays on top of an underlying TvView.
  ///
  /// Note that this must be set before the TvView's containing window is attached to the
  /// window manager.
  ///
  /// Calling this overrides any previous call to \#setZOrderOnTop.
  ///@param isMediaOverlay {@code true} to be on top of another regular surface, {@code false}
  ///            otherwise.
  void setZOrderMediaOverlay(bool isMediaOverlay) =>
      jniAccessors.callMethodWithArgs(reference, _id_setZOrderMediaOverlay,
          jni.JniType.voidType, [isMediaOverlay]).check();

  static final _id_setZOrderOnTop =
      jniAccessors.getMethodIDOf(_classRef, "setZOrderOnTop", "(Z)V");

  /// from: public void setZOrderOnTop(boolean onTop)
  ///
  /// Controls whether the TvView's surface is placed on top of its window. Normally it is placed
  /// behind the window, to allow it to (for the most part) appear to composite with the views in
  /// the hierarchy.  By setting this, you cause it to be placed above the window. This means that
  /// none of the contents of the window this TvView is in will be visible on top of its surface.
  ///
  /// Note that this must be set before the TvView's containing window is attached to the window
  /// manager.
  ///
  /// Calling this overrides any previous call to \#setZOrderMediaOverlay.
  ///@param onTop {@code true} to be on top of its window, {@code false} otherwise.
  void setZOrderOnTop(bool onTop) => jniAccessors.callMethodWithArgs(
      reference, _id_setZOrderOnTop, jni.JniType.voidType, [onTop]).check();

  static final _id_setStreamVolume =
      jniAccessors.getMethodIDOf(_classRef, "setStreamVolume", "(F)V");

  /// from: public void setStreamVolume(float volume)
  ///
  /// Sets the relative stream volume of this TvView.
  ///
  /// This method is primarily used to handle audio focus changes or mute a specific TvView when
  /// multiple views are displayed. If the method has not yet been called, the TvView assumes the
  /// default value of {@code 1.0f}.
  ///@param volume A volume value between {@code 0.0f} to {@code 1.0f}.
  ///
  /// Value is between 0.0 and 1.0 inclusive
  void setStreamVolume(double volume) => jniAccessors.callMethodWithArgs(
      reference, _id_setStreamVolume, jni.JniType.voidType, [volume]).check();

  static final _id_tune = jniAccessors.getMethodIDOf(
      _classRef, "tune", "(Ljava/lang/String;Landroid/net/Uri;)V");

  /// from: public void tune(java.lang.String inputId, android.net.Uri channelUri)
  ///
  /// Tunes to a given channel.
  ///@param inputId The ID of the TV input for the given channel.
  /// This value must never be {@code null}.
  ///@param channelUri The URI of a channel.
  void tune(jni.JniString inputId, uri_.Uri channelUri) =>
      jniAccessors.callMethodWithArgs(reference, _id_tune, jni.JniType.voidType,
          [inputId.reference, channelUri.reference]).check();

  static final _id_tune1 = jniAccessors.getMethodIDOf(_classRef, "tune",
      "(Ljava/lang/String;Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void tune(java.lang.String inputId, android.net.Uri channelUri, android.os.Bundle params)
  ///
  /// Tunes to a given channel. This can be used to provide domain-specific features that are only
  /// known between certain clients and their TV inputs.
  ///@param inputId The ID of TV input for the given channel.
  ///@param channelUri The URI of a channel.
  ///@param params Domain-specific data for this tune request. Keys _must_ be a scoped
  ///            name, i.e. prefixed with a package name you own, so that different developers will
  ///            not create conflicting keys.
  void tune1(
          jni.JniString inputId, uri_.Uri channelUri, bundle_.Bundle params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_tune1,
          jni.JniType.voidType,
          [inputId.reference, channelUri.reference, params.reference]).check();

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Resets this TvView.
  ///
  /// This method is primarily used to un-tune the current TvView.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_setCaptionEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setCaptionEnabled", "(Z)V");

  /// from: public void setCaptionEnabled(boolean enabled)
  ///
  /// Enables or disables the caption in this TvView.
  ///
  /// Note that this method does not take any effect unless the current TvView is tuned.
  ///@param enabled {@code true} to enable, {@code false} to disable.
  void setCaptionEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCaptionEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_selectTrack = jniAccessors.getMethodIDOf(
      _classRef, "selectTrack", "(ILjava/lang/String;)V");

  /// from: public void selectTrack(int type, java.lang.String trackId)
  ///
  /// Selects a track.
  ///@param type The type of the track to select. The type can be TvTrackInfo\#TYPE_AUDIO,
  ///            TvTrackInfo\#TYPE_VIDEO or TvTrackInfo\#TYPE_SUBTITLE.
  ///@param trackId The ID of the track to select. {@code null} means to unselect the current
  ///            track for a given type.
  ///@see \#getTracks
  ///@see \#getSelectedTrack
  void selectTrack(int type, jni.JniString trackId) =>
      jniAccessors.callMethodWithArgs(reference, _id_selectTrack,
          jni.JniType.voidType, [type, trackId.reference]).check();

  static final _id_getTracks =
      jniAccessors.getMethodIDOf(_classRef, "getTracks", "(I)Ljava/util/List;");

  /// from: public java.util.List<android.media.tv.TvTrackInfo> getTracks(int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of tracks. Returns {@code null} if the information is not available.
  ///@param type The type of the tracks. The type can be TvTrackInfo\#TYPE_AUDIO,
  ///            TvTrackInfo\#TYPE_VIDEO or TvTrackInfo\#TYPE_SUBTITLE.
  ///@see \#selectTrack
  ///@see \#getSelectedTrack
  jni.JniObject getTracks(int type) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTracks, jni.JniType.objectType, [type]).object);

  static final _id_getSelectedTrack = jniAccessors.getMethodIDOf(
      _classRef, "getSelectedTrack", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getSelectedTrack(int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ID of the selected track for a given type. Returns {@code null} if the
  /// information is not available or the track is not selected.
  ///@param type The type of the selected tracks. The type can be TvTrackInfo\#TYPE_AUDIO,
  ///            TvTrackInfo\#TYPE_VIDEO or TvTrackInfo\#TYPE_SUBTITLE.
  ///@see \#selectTrack
  ///@see \#getTracks
  jni.JniString getSelectedTrack(int type) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSelectedTrack, jni.JniType.objectType, [type]).object);

  static final _id_timeShiftPlay = jniAccessors.getMethodIDOf(
      _classRef, "timeShiftPlay", "(Ljava/lang/String;Landroid/net/Uri;)V");

  /// from: public void timeShiftPlay(java.lang.String inputId, android.net.Uri recordedProgramUri)
  ///
  /// Plays a given recorded TV program.
  ///@param inputId The ID of the TV input that created the given recorded program.
  ///@param recordedProgramUri The URI of a recorded program.
  void timeShiftPlay(jni.JniString inputId, uri_.Uri recordedProgramUri) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_timeShiftPlay,
          jni.JniType.voidType,
          [inputId.reference, recordedProgramUri.reference]).check();

  static final _id_timeShiftPause =
      jniAccessors.getMethodIDOf(_classRef, "timeShiftPause", "()V");

  /// from: public void timeShiftPause()
  ///
  /// Pauses playback. No-op if it is already paused. Call \#timeShiftResume to resume.
  void timeShiftPause() => jniAccessors.callMethodWithArgs(
      reference, _id_timeShiftPause, jni.JniType.voidType, []).check();

  static final _id_timeShiftResume =
      jniAccessors.getMethodIDOf(_classRef, "timeShiftResume", "()V");

  /// from: public void timeShiftResume()
  ///
  /// Resumes playback. No-op if it is already resumed. Call \#timeShiftPause to pause.
  void timeShiftResume() => jniAccessors.callMethodWithArgs(
      reference, _id_timeShiftResume, jni.JniType.voidType, []).check();

  static final _id_timeShiftSeekTo =
      jniAccessors.getMethodIDOf(_classRef, "timeShiftSeekTo", "(J)V");

  /// from: public void timeShiftSeekTo(long timeMs)
  ///
  /// Seeks to a specified time position. {@code timeMs} must be equal to or greater than the start
  /// position returned by TimeShiftPositionCallback\#onTimeShiftStartPositionChanged and
  /// equal to or less than the current time.
  ///@param timeMs The time position to seek to, in milliseconds since the epoch.
  void timeShiftSeekTo(int timeMs) => jniAccessors.callMethodWithArgs(
      reference, _id_timeShiftSeekTo, jni.JniType.voidType, [timeMs]).check();

  static final _id_timeShiftSetPlaybackParams = jniAccessors.getMethodIDOf(
      _classRef,
      "timeShiftSetPlaybackParams",
      "(Landroid/media/PlaybackParams;)V");

  /// from: public void timeShiftSetPlaybackParams(android.media.PlaybackParams params)
  ///
  /// Sets playback rate using android.media.PlaybackParams.
  ///@param params The playback params.
  ///
  /// This value must never be {@code null}.
  void timeShiftSetPlaybackParams(playbackparams_.PlaybackParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_timeShiftSetPlaybackParams,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_setTimeShiftPositionCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setTimeShiftPositionCallback",
      "(Landroid/media/tv/TvView\$TimeShiftPositionCallback;)V");

  /// from: public void setTimeShiftPositionCallback(android.media.tv.TvView.TimeShiftPositionCallback callback)
  ///
  /// Sets the callback to be invoked when the time shift position is changed.
  ///@param callback The callback to receive time shift position changes. A value of {@code null}
  ///            removes the existing callback.
  ///
  /// This value may be {@code null}.
  void setTimeShiftPositionCallback(
          TvView_TimeShiftPositionCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTimeShiftPositionCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_sendAppPrivateCommand = jniAccessors.getMethodIDOf(_classRef,
      "sendAppPrivateCommand", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void sendAppPrivateCommand(java.lang.String action, android.os.Bundle data)
  ///
  /// Sends a private command to the underlying TV input. This can be used to provide
  /// domain-specific features that are only known between certain clients and their TV inputs.
  ///@param action The name of the private command to send. This _must_ be a scoped name,
  ///            i.e. prefixed with a package name you own, so that different developers will not
  ///            create conflicting commands.
  /// This value must never be {@code null}.
  ///@param data An optional bundle to send with the command.
  void sendAppPrivateCommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendAppPrivateCommand,
          jni.JniType.voidType, [action.reference, data.reference]).check();

  static final _id_dispatchUnhandledInputEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchUnhandledInputEvent", "(Landroid/view/InputEvent;)Z");

  /// from: public boolean dispatchUnhandledInputEvent(android.view.InputEvent event)
  ///
  /// Dispatches an unhandled input event to the next receiver.
  ///
  /// Except system keys, TvView always consumes input events in the normal flow. This is called
  /// asynchronously from where the event is dispatched. It gives the host application a chance to
  /// dispatch the unhandled input events.
  ///@param event The input event.
  ///@return {@code true} if the event was handled by the view, {@code false} otherwise.
  bool dispatchUnhandledInputEvent(inputevent_.InputEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchUnhandledInputEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_onUnhandledInputEvent = jniAccessors.getMethodIDOf(
      _classRef, "onUnhandledInputEvent", "(Landroid/view/InputEvent;)Z");

  /// from: public boolean onUnhandledInputEvent(android.view.InputEvent event)
  ///
  /// Called when an unhandled input event also has not been handled by the user provided
  /// callback. This is the last chance to handle the unhandled input event in the TvView.
  ///@param event The input event.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to be
  ///         handled by the next receiver, return {@code false}.
  bool onUnhandledInputEvent(inputevent_.InputEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onUnhandledInputEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_setOnUnhandledInputEventListener =
      jniAccessors.getMethodIDOf(_classRef, "setOnUnhandledInputEventListener",
          "(Landroid/media/tv/TvView\$OnUnhandledInputEventListener;)V");

  /// from: public void setOnUnhandledInputEventListener(android.media.tv.TvView.OnUnhandledInputEventListener listener)
  ///
  /// Registers a callback to be invoked when an input event is not handled by the bound TV input.
  ///@param listener The callback to be invoked when the unhandled input event is received.
  void setOnUnhandledInputEventListener(
          TvView_OnUnhandledInputEventListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnUnhandledInputEventListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_dispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  bool dispatchKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent event)
  bool dispatchTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent event)
  bool dispatchTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchGenericMotionEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "dispatchGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent event)
  bool dispatchGenericMotionEvent1(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchGenericMotionEvent1,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_dispatchWindowFocusChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchWindowFocusChanged", "(Z)V");

  /// from: public void dispatchWindowFocusChanged(boolean hasFocus)
  void dispatchWindowFocusChanged(bool hasFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchWindowFocusChanged,
          jni.JniType.voidType, [hasFocus]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_onLayout =
      jniAccessors.getMethodIDOf(_classRef, "onLayout", "(ZIIII)V");

  /// from: protected void onLayout(boolean changed, int left, int top, int right, int bottom)
  void onLayout(bool changed, int left, int top, int right, int bottom) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLayout,
          jni.JniType.voidType, [changed, left, top, right, bottom]).check();

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_gatherTransparentRegion = jniAccessors.getMethodIDOf(
      _classRef, "gatherTransparentRegion", "(Landroid/graphics/Region;)Z");

  /// from: public boolean gatherTransparentRegion(android.graphics.Region region)
  bool gatherTransparentRegion(region_.Region region) =>
      jniAccessors.callMethodWithArgs(reference, _id_gatherTransparentRegion,
          jni.JniType.booleanType, [region.reference]).boolean;

  static final _id_draw1 = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas canvas)
  void draw1(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_draw1, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_dispatchDraw = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_onVisibilityChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "onVisibilityChanged", "(Landroid/view/View;I)V");

  /// from: protected void onVisibilityChanged(android.view.View changedView, int visibility)
  void onVisibilityChanged1(view_.View changedView, int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVisibilityChanged1,
          jni.JniType.voidType, [changedView.reference, visibility]).check();
}

/// from: android.media.tv.TvView$TvInputCallback
///
/// Callback used to receive various status updates on the TvView.
class TvView_TvInputCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/tv/TvView\$TvInputCallback");
  TvView_TvInputCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TvView_TvInputCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onConnectionFailed = jniAccessors.getMethodIDOf(
      _classRef, "onConnectionFailed", "(Ljava/lang/String;)V");

  /// from: public void onConnectionFailed(java.lang.String inputId)
  ///
  /// This is invoked when an error occurred while establishing a connection to the underlying
  /// TV input.
  ///@param inputId The ID of the TV input bound to this view.
  void onConnectionFailed(jni.JniString inputId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConnectionFailed,
          jni.JniType.voidType, [inputId.reference]).check();

  static final _id_onDisconnected = jniAccessors.getMethodIDOf(
      _classRef, "onDisconnected", "(Ljava/lang/String;)V");

  /// from: public void onDisconnected(java.lang.String inputId)
  ///
  /// This is invoked when the existing connection to the underlying TV input is lost.
  ///@param inputId The ID of the TV input bound to this view.
  void onDisconnected(jni.JniString inputId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onDisconnected,
      jni.JniType.voidType,
      [inputId.reference]).check();

  static final _id_onChannelRetuned = jniAccessors.getMethodIDOf(
      _classRef, "onChannelRetuned", "(Ljava/lang/String;Landroid/net/Uri;)V");

  /// from: public void onChannelRetuned(java.lang.String inputId, android.net.Uri channelUri)
  ///
  /// This is invoked when the channel of this TvView is changed by the underlying TV input
  /// without any TvView\#tune request.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param channelUri The URI of a channel.
  void onChannelRetuned(jni.JniString inputId, uri_.Uri channelUri) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onChannelRetuned,
          jni.JniType.voidType,
          [inputId.reference, channelUri.reference]).check();

  static final _id_onTracksChanged = jniAccessors.getMethodIDOf(
      _classRef, "onTracksChanged", "(Ljava/lang/String;Ljava/util/List;)V");

  /// from: public void onTracksChanged(java.lang.String inputId, java.util.List<android.media.tv.TvTrackInfo> tracks)
  ///
  /// This is called when the track information has been changed.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param tracks A list which includes track information.
  void onTracksChanged(jni.JniString inputId, jni.JniObject tracks) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTracksChanged,
          jni.JniType.voidType, [inputId.reference, tracks.reference]).check();

  static final _id_onTrackSelected = jniAccessors.getMethodIDOf(
      _classRef, "onTrackSelected", "(Ljava/lang/String;ILjava/lang/String;)V");

  /// from: public void onTrackSelected(java.lang.String inputId, int type, java.lang.String trackId)
  ///
  /// This is called when there is a change on the selected tracks.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param type The type of the track selected. The type can be
  ///            TvTrackInfo\#TYPE_AUDIO, TvTrackInfo\#TYPE_VIDEO or
  ///            TvTrackInfo\#TYPE_SUBTITLE.
  ///@param trackId The ID of the track selected.
  void onTrackSelected(
          jni.JniString inputId, int type, jni.JniString trackId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTrackSelected,
          jni.JniType.voidType,
          [inputId.reference, type, trackId.reference]).check();

  static final _id_onVideoSizeChanged = jniAccessors.getMethodIDOf(
      _classRef, "onVideoSizeChanged", "(Ljava/lang/String;II)V");

  /// from: public void onVideoSizeChanged(java.lang.String inputId, int width, int height)
  ///
  /// This is invoked when the video size has been changed. It is also called when the first
  /// time video size information becomes available after this view is tuned to a specific
  /// channel.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param width The width of the video.
  ///@param height The height of the video.
  void onVideoSizeChanged(jni.JniString inputId, int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVideoSizeChanged,
          jni.JniType.voidType, [inputId.reference, width, height]).check();

  static final _id_onVideoAvailable = jniAccessors.getMethodIDOf(
      _classRef, "onVideoAvailable", "(Ljava/lang/String;)V");

  /// from: public void onVideoAvailable(java.lang.String inputId)
  ///
  /// This is called when the video is available, so the TV input starts the playback.
  ///@param inputId The ID of the TV input bound to this view.
  void onVideoAvailable(jni.JniString inputId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVideoAvailable,
          jni.JniType.voidType, [inputId.reference]).check();

  static final _id_onVideoUnavailable = jniAccessors.getMethodIDOf(
      _classRef, "onVideoUnavailable", "(Ljava/lang/String;I)V");

  /// from: public void onVideoUnavailable(java.lang.String inputId, int reason)
  ///
  /// This is called when the video is not available, so the TV input stops the playback.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param reason The reason why the TV input stopped the playback:
  /// <ul>
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_UNKNOWN
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_TUNING
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_BUFFERING
  /// <li>TvInputManager\#VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY
  /// </ul>
  ///
  /// Value is android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_UNKNOWN, android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_TUNING, android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL, android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_BUFFERING, or android.media.tv.TvInputManager\#VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY
  void onVideoUnavailable(jni.JniString inputId, int reason) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVideoUnavailable,
          jni.JniType.voidType, [inputId.reference, reason]).check();

  static final _id_onContentAllowed = jniAccessors.getMethodIDOf(
      _classRef, "onContentAllowed", "(Ljava/lang/String;)V");

  /// from: public void onContentAllowed(java.lang.String inputId)
  ///
  /// This is called when the current program content turns out to be allowed to watch since
  /// its content rating is not blocked by parental controls.
  ///@param inputId The ID of the TV input bound to this view.
  void onContentAllowed(jni.JniString inputId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onContentAllowed,
          jni.JniType.voidType, [inputId.reference]).check();

  static final _id_onContentBlocked = jniAccessors.getMethodIDOf(
      _classRef,
      "onContentBlocked",
      "(Ljava/lang/String;Landroid/media/tv/TvContentRating;)V");

  /// from: public void onContentBlocked(java.lang.String inputId, android.media.tv.TvContentRating rating)
  ///
  /// This is called when the current program content turns out to be not allowed to watch
  /// since its content rating is blocked by parental controls.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param rating The content rating of the blocked program.
  void onContentBlocked(
          jni.JniString inputId, tvcontentrating_.TvContentRating rating) =>
      jniAccessors.callMethodWithArgs(reference, _id_onContentBlocked,
          jni.JniType.voidType, [inputId.reference, rating.reference]).check();

  static final _id_onTimeShiftStatusChanged = jniAccessors.getMethodIDOf(
      _classRef, "onTimeShiftStatusChanged", "(Ljava/lang/String;I)V");

  /// from: public void onTimeShiftStatusChanged(java.lang.String inputId, int status)
  ///
  /// This is called when the time shift status is changed.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param status The current time shift status. Should be one of the followings.
  /// <ul>
  /// <li>TvInputManager\#TIME_SHIFT_STATUS_UNSUPPORTED
  /// <li>TvInputManager\#TIME_SHIFT_STATUS_UNAVAILABLE
  /// <li>TvInputManager\#TIME_SHIFT_STATUS_AVAILABLE
  /// </ul>
  ///
  /// Value is android.media.tv.TvInputManager\#TIME_SHIFT_STATUS_UNKNOWN, android.media.tv.TvInputManager\#TIME_SHIFT_STATUS_UNSUPPORTED, android.media.tv.TvInputManager\#TIME_SHIFT_STATUS_UNAVAILABLE, or android.media.tv.TvInputManager\#TIME_SHIFT_STATUS_AVAILABLE
  void onTimeShiftStatusChanged(jni.JniString inputId, int status) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTimeShiftStatusChanged,
          jni.JniType.voidType, [inputId.reference, status]).check();
}

/// from: android.media.tv.TvView$TimeShiftPositionCallback
///
/// Callback used to receive time shift position changes.
class TvView_TimeShiftPositionCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/tv/TvView\$TimeShiftPositionCallback");
  TvView_TimeShiftPositionCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TvView_TimeShiftPositionCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onTimeShiftStartPositionChanged = jniAccessors.getMethodIDOf(
      _classRef, "onTimeShiftStartPositionChanged", "(Ljava/lang/String;J)V");

  /// from: public void onTimeShiftStartPositionChanged(java.lang.String inputId, long timeMs)
  ///
  /// This is called when the start position for time shifting has changed.
  ///
  /// The start position for time shifting indicates the earliest possible time the user can
  /// seek to. Initially this is equivalent to the time when the underlying TV input starts
  /// recording. Later it may be adjusted because there is insufficient space or the duration
  /// of recording is limited. The application must not allow the user to seek to a position
  /// earlier than the start position.
  ///
  /// For playback of a recorded program initiated by \#timeShiftPlay(String, Uri),
  /// the start position is the time when playback starts. It does not change.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param timeMs The start position for time shifting, in milliseconds since the epoch.
  void onTimeShiftStartPositionChanged(jni.JniString inputId, int timeMs) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTimeShiftStartPositionChanged,
          jni.JniType.voidType,
          [inputId.reference, timeMs]).check();

  static final _id_onTimeShiftCurrentPositionChanged =
      jniAccessors.getMethodIDOf(_classRef, "onTimeShiftCurrentPositionChanged",
          "(Ljava/lang/String;J)V");

  /// from: public void onTimeShiftCurrentPositionChanged(java.lang.String inputId, long timeMs)
  ///
  /// This is called when the current position for time shifting has changed.
  ///
  /// The current position for time shifting is the same as the current position of
  /// playback. During playback, the current position changes continuously. When paused, it
  /// does not change.
  ///
  /// Note that {@code timeMs} is wall-clock time.
  ///@param inputId The ID of the TV input bound to this view.
  ///@param timeMs The current position for time shifting, in milliseconds since the epoch.
  void onTimeShiftCurrentPositionChanged(jni.JniString inputId, int timeMs) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTimeShiftCurrentPositionChanged,
          jni.JniType.voidType,
          [inputId.reference, timeMs]).check();
}

/// from: android.media.tv.TvView$OnUnhandledInputEventListener
///
/// Interface definition for a callback to be invoked when the unhandled input event is received.
class TvView_OnUnhandledInputEventListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/tv/TvView\$OnUnhandledInputEventListener");
  TvView_OnUnhandledInputEventListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onUnhandledInputEvent = jniAccessors.getMethodIDOf(
      _classRef, "onUnhandledInputEvent", "(Landroid/view/InputEvent;)Z");

  /// from: public abstract boolean onUnhandledInputEvent(android.view.InputEvent event)
  ///
  /// Called when an input event was not handled by the bound TV input.
  ///
  /// This is called asynchronously from where the event is dispatched. It gives the host
  /// application a chance to handle the unhandled input events.
  ///@param event The input event.
  ///@return If you handled the event, return {@code true}. If you want to allow the event to
  ///         be handled by the next receiver, return {@code false}.
  bool onUnhandledInputEvent(inputevent_.InputEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onUnhandledInputEvent,
          jni.JniType.booleanType, [event.reference]).boolean;
}
