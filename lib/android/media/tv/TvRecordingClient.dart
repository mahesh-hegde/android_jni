// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;

import "../../os/Handler.dart" as handler_;

import "../../net/Uri.dart" as uri_;

import "../../os/Bundle.dart" as bundle_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.tv.TvRecordingClient
///
/// The public interface object used to interact with a specific TV input service for TV program
/// recording.
class TvRecordingClient extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/tv/TvRecordingClient");
  TvRecordingClient.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Ljava/lang/String;Landroid/media/tv/TvRecordingClient\$RecordingCallback;Landroid/os/Handler;)V");

  /// from: public void <init>(android.content.Context context, java.lang.String tag, android.media.tv.TvRecordingClient.RecordingCallback callback, android.os.Handler handler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new TvRecordingClient object.
  ///@param context The application context to create a TvRecordingClient with.
  ///@param tag A short name for debugging purposes.
  ///@param callback The callback to receive recording status changes.
  /// This value must never be {@code null}.
  ///@param handler The handler to invoke the callback on.
  TvRecordingClient(context_.Context context, jni.JniString tag,
      TvRecordingClient_RecordingCallback callback, handler_.Handler handler)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          context.reference,
          tag.reference,
          callback.reference,
          handler.reference
        ]).object);

  static final _id_tune = jniAccessors.getMethodIDOf(
      _classRef, "tune", "(Ljava/lang/String;Landroid/net/Uri;)V");

  /// from: public void tune(java.lang.String inputId, android.net.Uri channelUri)
  ///
  /// Tunes to a given channel for TV program recording. The first tune request will create a new
  /// recording session for the corresponding TV input and establish a connection between the
  /// application and the session. If recording has already started in the current recording
  /// session, this method throws an exception.
  ///
  /// The application may call this method before starting or after stopping recording, but not
  /// during recording.
  ///
  /// The recording session will respond by calling
  /// RecordingCallback\#onTuned(Uri) if the tune request was fulfilled, or
  /// RecordingCallback\#onError(int) otherwise.
  ///@param inputId The ID of the TV input for the given channel.
  ///@param channelUri The URI of a channel.
  ///@throws IllegalStateException If recording is already started.
  void tune(jni.JniString inputId, uri_.Uri channelUri) =>
      jniAccessors.callMethodWithArgs(reference, _id_tune, jni.JniType.voidType,
          [inputId.reference, channelUri.reference]).check();

  static final _id_tune1 = jniAccessors.getMethodIDOf(_classRef, "tune",
      "(Ljava/lang/String;Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void tune(java.lang.String inputId, android.net.Uri channelUri, android.os.Bundle params)
  ///
  /// Tunes to a given channel for TV program recording. The first tune request will create a new
  /// recording session for the corresponding TV input and establish a connection between the
  /// application and the session. If recording has already started in the current recording
  /// session, this method throws an exception. This can be used to provide domain-specific
  /// features that are only known between certain client and their TV inputs.
  ///
  /// The application may call this method before starting or after stopping recording, but not
  /// during recording.
  ///
  /// The recording session will respond by calling
  /// RecordingCallback\#onTuned(Uri) if the tune request was fulfilled, or
  /// RecordingCallback\#onError(int) otherwise.
  ///@param inputId The ID of the TV input for the given channel.
  ///@param channelUri The URI of a channel.
  ///@param params Domain-specific data for this tune request. Keys _must_ be a scoped
  ///            name, i.e. prefixed with a package name you own, so that different developers will
  ///            not create conflicting keys.
  ///@throws IllegalStateException If recording is already started.
  void tune1(
          jni.JniString inputId, uri_.Uri channelUri, bundle_.Bundle params) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_tune1,
          jni.JniType.voidType,
          [inputId.reference, channelUri.reference, params.reference]).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Releases the resources in the current recording session immediately. This may be called at
  /// any time, however if the session is already released, it does nothing.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_startRecording = jniAccessors.getMethodIDOf(
      _classRef, "startRecording", "(Landroid/net/Uri;)V");

  /// from: public void startRecording(android.net.Uri programUri)
  ///
  /// Starts TV program recording in the current recording session. Recording is expected to start
  /// immediately when this method is called. If the current recording session has not yet tuned to
  /// any channel, this method throws an exception.
  ///
  /// The application may supply the URI for a TV program for filling in program specific data
  /// fields in the android.media.tv.TvContract.RecordedPrograms table.
  /// A non-null {@code programUri} implies the started recording should be of that specific
  /// program, whereas null {@code programUri} does not impose such a requirement and the
  /// recording can span across multiple TV programs. In either case, the application must call
  /// TvRecordingClient\#stopRecording() to stop the recording.
  ///
  /// The recording session will respond by calling RecordingCallback\#onError(int) if
  /// the start request cannot be fulfilled.
  ///@param programUri The URI for the TV program to record, built by
  ///            TvContract\#buildProgramUri(long). Can be {@code null}.
  /// This value may be {@code null}.
  ///@throws IllegalStateException If \#tune request hasn't been handled yet.
  void startRecording(uri_.Uri programUri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_startRecording,
      jni.JniType.voidType,
      [programUri.reference]).check();

  static final _id_stopRecording =
      jniAccessors.getMethodIDOf(_classRef, "stopRecording", "()V");

  /// from: public void stopRecording()
  ///
  /// Stops TV program recording in the current recording session. Recording is expected to stop
  /// immediately when this method is called. If recording has not yet started in the current
  /// recording session, this method does nothing.
  ///
  /// The recording session is expected to create a new data entry in the
  /// android.media.tv.TvContract.RecordedPrograms table that describes the newly
  /// recorded program and pass the URI to that entry through to
  /// RecordingCallback\#onRecordingStopped(Uri).
  /// If the stop request cannot be fulfilled, the recording session will respond by calling
  /// RecordingCallback\#onError(int).
  void stopRecording() => jniAccessors.callMethodWithArgs(
      reference, _id_stopRecording, jni.JniType.voidType, []).check();

  static final _id_sendAppPrivateCommand = jniAccessors.getMethodIDOf(_classRef,
      "sendAppPrivateCommand", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void sendAppPrivateCommand(java.lang.String action, android.os.Bundle data)
  ///
  /// Sends a private command to the underlying TV input. This can be used to provide
  /// domain-specific features that are only known between certain clients and their TV inputs.
  ///@param action The name of the private command to send. This _must_ be a scoped name,
  ///            i.e. prefixed with a package name you own, so that different developers will not
  ///            create conflicting commands.
  /// This value must never be {@code null}.
  ///@param data An optional bundle to send with the command.
  void sendAppPrivateCommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendAppPrivateCommand,
          jni.JniType.voidType, [action.reference, data.reference]).check();
}

/// from: android.media.tv.TvRecordingClient$RecordingCallback
///
/// Callback used to receive various status updates on the
/// android.media.tv.TvInputService.RecordingSession
class TvRecordingClient_RecordingCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/tv/TvRecordingClient\$RecordingCallback");
  TvRecordingClient_RecordingCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TvRecordingClient_RecordingCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onConnectionFailed = jniAccessors.getMethodIDOf(
      _classRef, "onConnectionFailed", "(Ljava/lang/String;)V");

  /// from: public void onConnectionFailed(java.lang.String inputId)
  ///
  /// This is called when an error occurred while establishing a connection to the recording
  /// session for the corresponding TV input.
  ///@param inputId The ID of the TV input bound to the current TvRecordingClient.
  void onConnectionFailed(jni.JniString inputId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConnectionFailed,
          jni.JniType.voidType, [inputId.reference]).check();

  static final _id_onDisconnected = jniAccessors.getMethodIDOf(
      _classRef, "onDisconnected", "(Ljava/lang/String;)V");

  /// from: public void onDisconnected(java.lang.String inputId)
  ///
  /// This is called when the connection to the current recording session is lost.
  ///@param inputId The ID of the TV input bound to the current TvRecordingClient.
  void onDisconnected(jni.JniString inputId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onDisconnected,
      jni.JniType.voidType,
      [inputId.reference]).check();

  static final _id_onTuned =
      jniAccessors.getMethodIDOf(_classRef, "onTuned", "(Landroid/net/Uri;)V");

  /// from: public void onTuned(android.net.Uri channelUri)
  ///
  /// This is called when the recording session has been tuned to the given channel and is
  /// ready to start recording.
  ///@param channelUri The URI of a channel.
  void onTuned(uri_.Uri channelUri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onTuned,
      jni.JniType.voidType,
      [channelUri.reference]).check();

  static final _id_onRecordingStopped = jniAccessors.getMethodIDOf(
      _classRef, "onRecordingStopped", "(Landroid/net/Uri;)V");

  /// from: public void onRecordingStopped(android.net.Uri recordedProgramUri)
  ///
  /// This is called when the current recording session has stopped recording and created a
  /// new data entry in the TvContract.RecordedPrograms table that describes the newly
  /// recorded program.
  ///@param recordedProgramUri The URI for the newly recorded program.
  void onRecordingStopped(uri_.Uri recordedProgramUri) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRecordingStopped,
          jni.JniType.voidType, [recordedProgramUri.reference]).check();

  static final _id_onError =
      jniAccessors.getMethodIDOf(_classRef, "onError", "(I)V");

  /// from: public void onError(int error)
  ///
  /// This is called when an issue has occurred. It may be called at any time after the current
  /// recording session is created until it is released.
  ///@param error The error code. Should be one of the followings.
  /// <ul>
  /// <li>TvInputManager\#RECORDING_ERROR_UNKNOWN
  /// <li>TvInputManager\#RECORDING_ERROR_INSUFFICIENT_SPACE
  /// <li>TvInputManager\#RECORDING_ERROR_RESOURCE_BUSY
  /// </ul>
  ///
  /// Value is android.media.tv.TvInputManager\#RECORDING_ERROR_UNKNOWN, android.media.tv.TvInputManager\#RECORDING_ERROR_INSUFFICIENT_SPACE, or android.media.tv.TvInputManager\#RECORDING_ERROR_RESOURCE_BUSY
  void onError(int error) => jniAccessors.callMethodWithArgs(
      reference, _id_onError, jni.JniType.voidType, [error]).check();
}
