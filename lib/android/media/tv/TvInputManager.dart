// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "TvInputInfo.dart" as tvinputinfo_;

import "../../os/Handler.dart" as handler_;

import "TvContentRating.dart" as tvcontentrating_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.tv.TvInputManager
///
/// Central system API to the overall TV input framework (TIF) architecture, which arbitrates
/// interaction between applications and the selected TV inputs.
///
/// There are three primary parties involved in the TV input framework (TIF) architecture:
///
/// <ul>
/// <li>The <strong>TV input manager</strong> as expressed by this class is the central point of the
/// system that manages interaction between all other parts. It is expressed as the client-side API
/// here which exists in each application context and communicates with a global system service that
/// manages the interaction across all processes.
/// <li>A <strong>TV input</strong> implemented by TvInputService represents an input source
/// of TV, which can be a pass-through input such as HDMI, or a tuner input which provides broadcast
/// TV programs. The system binds to the TV input per application\u2019s request.
/// on implementing TV inputs.
/// <li><strong>Applications</strong> talk to the TV input manager to list TV inputs and check their
/// status. Once an application find the input to use, it uses TvView or
/// TvRecordingClient for further interaction such as watching and recording broadcast TV
/// programs.
/// </ul>
class TvInputManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/tv/TvInputManager");
  TvInputManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_BLOCKED_RATINGS_CHANGED
  ///
  /// Broadcast intent action when the user blocked content ratings change. For use with the
  /// \#isRatingBlocked.
  static const ACTION_BLOCKED_RATINGS_CHANGED =
      "android.media.tv.action.BLOCKED_RATINGS_CHANGED";

  /// from: static public final java.lang.String ACTION_PARENTAL_CONTROLS_ENABLED_CHANGED
  ///
  /// Broadcast intent action when the parental controls enabled state changes. For use with the
  /// \#isParentalControlsEnabled.
  static const ACTION_PARENTAL_CONTROLS_ENABLED_CHANGED =
      "android.media.tv.action.PARENTAL_CONTROLS_ENABLED_CHANGED";

  /// from: static public final java.lang.String ACTION_QUERY_CONTENT_RATING_SYSTEMS
  ///
  /// Broadcast intent action used to query available content rating systems.
  ///
  /// The TV input manager service locates available content rating systems by querying
  /// broadcast receivers that are registered for this action. An application can offer additional
  /// content rating systems to the user by declaring a suitable broadcast receiver in its
  /// manifest.
  ///
  /// Here is an example broadcast receiver declaration that an application might include in its
  /// AndroidManifest.xml to advertise custom content rating systems. The meta-data specifies a
  /// resource that contains a description of each content rating system that is provided by the
  /// application.
  ///
  /// <pre class="prettyprint">
  /// {@literal
  /// <receiver android:name=".TvInputReceiver">
  ///     <intent-filter>
  ///         <action android:name=
  ///                 "android.media.tv.action.QUERY_CONTENT_RATING_SYSTEMS" />
  ///     </intent-filter>
  ///     <meta-data
  ///             android:name="android.media.tv.metadata.CONTENT_RATING_SYSTEMS"
  ///             android:resource="@xml/tv_content_rating_systems" />
  /// </receiver>}</pre>
  ///
  /// In the above example, the <code>@xml/tv_content_rating_systems</code> resource refers to an
  /// XML resource whose root element is <code>&lt;rating-system-definitions&gt;</code> that
  /// contains zero or more <code>&lt;rating-system-definition&gt;</code> elements. Each <code>
  /// &lt;rating-system-definition&gt;</code> element specifies the ratings, sub-ratings and rating
  /// orders of a particular content rating system.
  ///@see TvContentRating
  static const ACTION_QUERY_CONTENT_RATING_SYSTEMS =
      "android.media.tv.action.QUERY_CONTENT_RATING_SYSTEMS";

  /// from: static public final java.lang.String ACTION_SETUP_INPUTS
  ///
  /// Activity action to set up channel sources i.e.&nbsp;TV inputs of type
  /// TvInputInfo\#TYPE_TUNER. When invoked, the system will display an appropriate UI for
  /// the user to initiate the individual setup flow provided by
  /// android.R.attr\#setupActivity of each TV input service.
  static const ACTION_SETUP_INPUTS = "android.media.tv.action.SETUP_INPUTS";

  /// from: static public final java.lang.String ACTION_VIEW_RECORDING_SCHEDULES
  ///
  /// Activity action to display the recording schedules. When invoked, the system will display an
  /// appropriate UI to browse the schedules.
  static const ACTION_VIEW_RECORDING_SCHEDULES =
      "android.media.tv.action.VIEW_RECORDING_SCHEDULES";

  /// from: static public final int INPUT_STATE_CONNECTED
  ///
  /// State for \#getInputState(String) and
  /// TvInputCallback\#onInputStateChanged(String, int): The input source is connected.
  ///
  /// This state indicates that a source device is connected to the input port and is in the
  /// normal operation mode. It is mostly relevant to hardware inputs such as HDMI input.
  /// Non-hardware inputs are considered connected all the time.
  static const INPUT_STATE_CONNECTED = 0;

  /// from: static public final int INPUT_STATE_CONNECTED_STANDBY
  ///
  /// State for \#getInputState(String) and
  /// TvInputCallback\#onInputStateChanged(String, int): The input source is connected but
  /// in standby mode.
  ///
  /// This state indicates that a source device is connected to the input port but is in standby
  /// or low power mode. It is mostly relevant to hardware inputs such as HDMI input and Component
  /// inputs.
  static const INPUT_STATE_CONNECTED_STANDBY = 1;

  /// from: static public final int INPUT_STATE_DISCONNECTED
  ///
  /// State for \#getInputState(String) and
  /// TvInputCallback\#onInputStateChanged(String, int): The input source is disconnected.
  ///
  /// This state indicates that a source device is disconnected from the input port. It is
  /// mostly relevant to hardware inputs such as HDMI input.
  static const INPUT_STATE_DISCONNECTED = 2;

  /// from: static public final java.lang.String META_DATA_CONTENT_RATING_SYSTEMS
  ///
  /// Content rating systems metadata associated with \#ACTION_QUERY_CONTENT_RATING_SYSTEMS.
  ///
  /// Specifies the resource ID of an XML resource that describes the content rating systems
  /// that are provided by the application.
  static const META_DATA_CONTENT_RATING_SYSTEMS =
      "android.media.tv.metadata.CONTENT_RATING_SYSTEMS";

  /// from: static public final int RECORDING_ERROR_INSUFFICIENT_SPACE
  ///
  /// Error for TvInputService.RecordingSession\#notifyError(int) and
  /// TvRecordingClient.RecordingCallback\#onError(int): Recording cannot proceed due to
  /// insufficient storage space.
  static const RECORDING_ERROR_INSUFFICIENT_SPACE = 1;

  /// from: static public final int RECORDING_ERROR_RESOURCE_BUSY
  ///
  /// Error for TvInputService.RecordingSession\#notifyError(int) and
  /// TvRecordingClient.RecordingCallback\#onError(int): Recording cannot proceed because
  /// a required recording resource was not able to be allocated.
  static const RECORDING_ERROR_RESOURCE_BUSY = 2;

  /// from: static public final int RECORDING_ERROR_UNKNOWN
  ///
  /// Error for TvInputService.RecordingSession\#notifyError(int) and
  /// TvRecordingClient.RecordingCallback\#onError(int): The requested operation cannot be
  /// completed due to a problem that does not fit under any other error codes, or the error code
  /// for the problem is defined on the higher version than application's
  /// <code>android:targetSdkVersion</code>.
  static const RECORDING_ERROR_UNKNOWN = 0;

  /// from: static public final long TIME_SHIFT_INVALID_TIME
  ///
  /// Value returned by TvInputService.Session\#onTimeShiftGetCurrentPosition() and
  /// TvInputService.Session\#onTimeShiftGetStartPosition() when time shifting has not
  /// yet started.
  static const TIME_SHIFT_INVALID_TIME = -9223372036854775808;

  /// from: static public final int TIME_SHIFT_STATUS_AVAILABLE
  ///
  /// Status for TvInputService.Session\#notifyTimeShiftStatusChanged(int) and
  /// TvView.TvInputCallback\#onTimeShiftStatusChanged(String, int): Time shifting is
  /// currently available. In this status, the application assumes it can pause/resume playback,
  /// seek to a specified time position and set playback rate and audio mode.
  static const TIME_SHIFT_STATUS_AVAILABLE = 3;

  /// from: static public final int TIME_SHIFT_STATUS_UNAVAILABLE
  ///
  /// Status for TvInputService.Session\#notifyTimeShiftStatusChanged(int) and
  /// TvView.TvInputCallback\#onTimeShiftStatusChanged(String, int): Time shifting is
  /// currently unavailable but might work again later.
  static const TIME_SHIFT_STATUS_UNAVAILABLE = 2;

  /// from: static public final int TIME_SHIFT_STATUS_UNKNOWN
  ///
  /// Status for TvInputService.Session\#notifyTimeShiftStatusChanged(int) and
  /// TvView.TvInputCallback\#onTimeShiftStatusChanged(String, int): Unknown status. Also
  /// the status prior to calling {@code notifyTimeShiftStatusChanged}.
  static const TIME_SHIFT_STATUS_UNKNOWN = 0;

  /// from: static public final int TIME_SHIFT_STATUS_UNSUPPORTED
  ///
  /// Status for TvInputService.Session\#notifyTimeShiftStatusChanged(int) and
  /// TvView.TvInputCallback\#onTimeShiftStatusChanged(String, int): The current TV input
  /// does not support time shifting.
  static const TIME_SHIFT_STATUS_UNSUPPORTED = 1;

  /// from: static public final int VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY
  ///
  /// Reason for TvInputService.Session\#notifyVideoUnavailable(int) and
  /// TvView.TvInputCallback\#onVideoUnavailable(String, int): Video is unavailable because
  /// the current TV program is audio-only.
  static const VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY = 4;

  /// from: static public final int VIDEO_UNAVAILABLE_REASON_BUFFERING
  ///
  /// Reason for TvInputService.Session\#notifyVideoUnavailable(int) and
  /// TvView.TvInputCallback\#onVideoUnavailable(String, int): Video is unavailable because
  /// the corresponding TV input has stopped playback temporarily to buffer more data.
  static const VIDEO_UNAVAILABLE_REASON_BUFFERING = 3;

  /// from: static public final int VIDEO_UNAVAILABLE_REASON_TUNING
  ///
  /// Reason for TvInputService.Session\#notifyVideoUnavailable(int) and
  /// TvView.TvInputCallback\#onVideoUnavailable(String, int): Video is unavailable because
  /// the corresponding TV input is in the middle of tuning to a new channel.
  static const VIDEO_UNAVAILABLE_REASON_TUNING = 1;

  /// from: static public final int VIDEO_UNAVAILABLE_REASON_UNKNOWN
  ///
  /// Reason for TvInputService.Session\#notifyVideoUnavailable(int) and
  /// TvView.TvInputCallback\#onVideoUnavailable(String, int): Video is unavailable due to
  /// an unspecified error.
  static const VIDEO_UNAVAILABLE_REASON_UNKNOWN = 0;

  /// from: static public final int VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL
  ///
  /// Reason for TvInputService.Session\#notifyVideoUnavailable(int) and
  /// TvView.TvInputCallback\#onVideoUnavailable(String, int): Video is unavailable due to
  /// weak TV signal.
  static const VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL = 2;

  static final _id_getTvInputList = jniAccessors.getMethodIDOf(
      _classRef, "getTvInputList", "()Ljava/util/List;");

  /// from: public java.util.List<android.media.tv.TvInputInfo> getTvInputList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the complete list of TV inputs on the system.
  ///@return List of TvInputInfo for each TV input that describes its meta information.
  jni.JniObject getTvInputList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTvInputList, jni.JniType.objectType, []).object);

  static final _id_getTvInputInfo = jniAccessors.getMethodIDOf(_classRef,
      "getTvInputInfo", "(Ljava/lang/String;)Landroid/media/tv/TvInputInfo;");

  /// from: public android.media.tv.TvInputInfo getTvInputInfo(java.lang.String inputId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the TvInputInfo for a given TV input.
  ///@param inputId The ID of the TV input.
  /// This value must never be {@code null}.
  ///@return the TvInputInfo for a given TV input. {@code null} if not found.
  tvinputinfo_.TvInputInfo getTvInputInfo(jni.JniString inputId) =>
      tvinputinfo_.TvInputInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTvInputInfo,
          jni.JniType.objectType,
          [inputId.reference]).object);

  static final _id_updateTvInputInfo = jniAccessors.getMethodIDOf(
      _classRef, "updateTvInputInfo", "(Landroid/media/tv/TvInputInfo;)V");

  /// from: public void updateTvInputInfo(android.media.tv.TvInputInfo inputInfo)
  ///
  /// Updates the <code>TvInputInfo</code> for an existing TV input. A TV input service
  /// implementation may call this method to pass the application and system an up-to-date
  /// <code>TvInputInfo</code> object that describes itself.
  ///
  /// The system automatically creates a <code>TvInputInfo</code> object for each TV input,
  /// based on the information collected from the <code>AndroidManifest.xml</code>, thus it is not
  /// necessary to call this method unless such information has changed dynamically.
  /// Use TvInputInfo.Builder to build a new <code>TvInputInfo</code> object.
  ///
  /// Attempting to change information about a TV input that the calling package does not own
  /// does nothing.
  ///@param inputInfo The <code>TvInputInfo</code> object that contains new information.
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the argument is {@code null}.
  ///@see TvInputCallback\#onTvInputInfoUpdated(TvInputInfo)
  void updateTvInputInfo(tvinputinfo_.TvInputInfo inputInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateTvInputInfo,
          jni.JniType.voidType, [inputInfo.reference]).check();

  static final _id_getInputState = jniAccessors.getMethodIDOf(
      _classRef, "getInputState", "(Ljava/lang/String;)I");

  /// from: public int getInputState(java.lang.String inputId)
  ///
  /// Returns the state of a given TV input.
  ///
  /// The state is one of the following:
  /// <ul>
  /// <li>\#INPUT_STATE_CONNECTED
  /// <li>\#INPUT_STATE_CONNECTED_STANDBY
  /// <li>\#INPUT_STATE_DISCONNECTED
  /// </ul>
  ///@param inputId The ID of the TV input.
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the argument is {@code null}.
  ///@return Value is android.media.tv.TvInputManager\#INPUT_STATE_CONNECTED, android.media.tv.TvInputManager\#INPUT_STATE_CONNECTED_STANDBY, or android.media.tv.TvInputManager\#INPUT_STATE_DISCONNECTED
  int getInputState(jni.JniString inputId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getInputState,
      jni.JniType.intType,
      [inputId.reference]).integer;

  static final _id_registerCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerCallback",
      "(Landroid/media/tv/TvInputManager\$TvInputCallback;Landroid/os/Handler;)V");

  /// from: public void registerCallback(android.media.tv.TvInputManager.TvInputCallback callback, android.os.Handler handler)
  ///
  /// Registers a TvInputCallback.
  ///@param callback A callback used to monitor status of the TV inputs.
  /// This value must never be {@code null}.
  ///@param handler A Handler that the status change will be delivered to.
  ///
  /// This value must never be {@code null}.
  void registerCallback(
          TvInputManager_TvInputCallback callback, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerCallback,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterCallback",
      "(Landroid/media/tv/TvInputManager\$TvInputCallback;)V");

  /// from: public void unregisterCallback(android.media.tv.TvInputManager.TvInputCallback callback)
  ///
  /// Unregisters the existing TvInputCallback.
  ///@param callback The existing callback to remove.
  ///
  /// This value must never be {@code null}.
  void unregisterCallback(TvInputManager_TvInputCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_isParentalControlsEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isParentalControlsEnabled", "()Z");

  /// from: public boolean isParentalControlsEnabled()
  ///
  /// Returns the user's parental controls enabled state.
  ///@return {@code true} if the user enabled the parental controls, {@code false} otherwise.
  bool isParentalControlsEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isParentalControlsEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_isRatingBlocked = jniAccessors.getMethodIDOf(
      _classRef, "isRatingBlocked", "(Landroid/media/tv/TvContentRating;)Z");

  /// from: public boolean isRatingBlocked(android.media.tv.TvContentRating rating)
  ///
  /// Checks whether a given TV content rating is blocked by the user.
  ///@param rating The TV content rating to check. Can be TvContentRating\#UNRATED.
  /// This value must never be {@code null}.
  ///@return {@code true} if the given TV content rating is blocked, {@code false} otherwise.
  bool isRatingBlocked(tvcontentrating_.TvContentRating rating) =>
      jniAccessors.callMethodWithArgs(reference, _id_isRatingBlocked,
          jni.JniType.booleanType, [rating.reference]).boolean;

  static final _id_getBlockedRatings = jniAccessors.getMethodIDOf(
      _classRef, "getBlockedRatings", "()Ljava/util/List;");

  /// from: public java.util.List<android.media.tv.TvContentRating> getBlockedRatings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of blocked content ratings.
  ///@return the list of content ratings blocked by the user.
  jni.JniObject getBlockedRatings() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBlockedRatings, jni.JniType.objectType, []).object);
}

/// from: android.media.tv.TvInputManager$TvInputCallback
///
/// Callback used to monitor status of the TV inputs.
class TvInputManager_TvInputCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/tv/TvInputManager\$TvInputCallback");
  TvInputManager_TvInputCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TvInputManager_TvInputCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onInputStateChanged = jniAccessors.getMethodIDOf(
      _classRef, "onInputStateChanged", "(Ljava/lang/String;I)V");

  /// from: public void onInputStateChanged(java.lang.String inputId, int state)
  ///
  /// This is called when the state of a given TV input is changed.
  ///@param inputId The ID of the TV input.
  ///@param state State of the TV input. The value is one of the following:
  /// <ul>
  /// <li>TvInputManager\#INPUT_STATE_CONNECTED
  /// <li>TvInputManager\#INPUT_STATE_CONNECTED_STANDBY
  /// <li>TvInputManager\#INPUT_STATE_DISCONNECTED
  /// </ul>
  ///
  /// Value is android.media.tv.TvInputManager\#INPUT_STATE_CONNECTED, android.media.tv.TvInputManager\#INPUT_STATE_CONNECTED_STANDBY, or android.media.tv.TvInputManager\#INPUT_STATE_DISCONNECTED
  void onInputStateChanged(jni.JniString inputId, int state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onInputStateChanged,
          jni.JniType.voidType, [inputId.reference, state]).check();

  static final _id_onInputAdded = jniAccessors.getMethodIDOf(
      _classRef, "onInputAdded", "(Ljava/lang/String;)V");

  /// from: public void onInputAdded(java.lang.String inputId)
  ///
  /// This is called when a TV input is added to the system.
  ///
  /// Normally it happens when the user installs a new TV input package that implements
  /// TvInputService interface.
  ///@param inputId The ID of the TV input.
  void onInputAdded(jni.JniString inputId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onInputAdded,
      jni.JniType.voidType,
      [inputId.reference]).check();

  static final _id_onInputRemoved = jniAccessors.getMethodIDOf(
      _classRef, "onInputRemoved", "(Ljava/lang/String;)V");

  /// from: public void onInputRemoved(java.lang.String inputId)
  ///
  /// This is called when a TV input is removed from the system.
  ///
  /// Normally it happens when the user uninstalls the previously installed TV input
  /// package.
  ///@param inputId The ID of the TV input.
  void onInputRemoved(jni.JniString inputId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onInputRemoved,
      jni.JniType.voidType,
      [inputId.reference]).check();

  static final _id_onInputUpdated = jniAccessors.getMethodIDOf(
      _classRef, "onInputUpdated", "(Ljava/lang/String;)V");

  /// from: public void onInputUpdated(java.lang.String inputId)
  ///
  /// This is called when a TV input is updated on the system.
  ///
  /// Normally it happens when a previously installed TV input package is re-installed or
  /// the media on which a newer version of the package exists becomes available/unavailable.
  ///@param inputId The ID of the TV input.
  void onInputUpdated(jni.JniString inputId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onInputUpdated,
      jni.JniType.voidType,
      [inputId.reference]).check();

  static final _id_onTvInputInfoUpdated = jniAccessors.getMethodIDOf(
      _classRef, "onTvInputInfoUpdated", "(Landroid/media/tv/TvInputInfo;)V");

  /// from: public void onTvInputInfoUpdated(android.media.tv.TvInputInfo inputInfo)
  ///
  /// This is called when the information about an existing TV input has been updated.
  ///
  /// Because the system automatically creates a <code>TvInputInfo</code> object for each TV
  /// input based on the information collected from the <code>AndroidManifest.xml</code>, this
  /// method is only called back when such information has changed dynamically.
  ///@param inputInfo The <code>TvInputInfo</code> object that contains new information.
  void onTvInputInfoUpdated(tvinputinfo_.TvInputInfo inputInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTvInputInfoUpdated,
          jni.JniType.voidType, [inputInfo.reference]).check();
}
