// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Handler.dart" as handler_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaCas
///
/// MediaCas can be used to obtain keys for descrambling protected media streams, in
/// conjunction with android.media.MediaDescrambler. The MediaCas APIs are
/// designed to support conditional access such as those in the ISO/IEC13818-1.
/// The CA system is identified by a 16-bit integer CA_system_id. The scrambling
/// algorithms are usually proprietary and implemented by vendor-specific CA plugins
/// installed on the device.
///
/// The app is responsible for constructing a MediaCas object for the CA system it
/// intends to use. The app can query if a certain CA system is supported using static
/// method \#isSystemIdSupported. It can also obtain the entire list of supported
/// CA systems using static method \#enumeratePlugins.
///
/// Once the MediaCas object is constructed, the app should properly provision it by
/// using method \#provision and/or \#processEmm. The EMMs (Entitlement
/// management messages) can be distributed out-of-band, or in-band with the stream.
///
/// To descramble elementary streams, the app first calls \#openSession to
/// generate a Session object that will uniquely identify a session. A session
/// provides a context for subsequent key updates and descrambling activities. The ECMs
/// (Entitlement control messages) are sent to the session via method
/// Session\#processEcm.
///
/// The app next constructs a MediaDescrambler object, and initializes it with the
/// session using MediaDescrambler\#setMediaCasSession. This ties the
/// descrambler to the session, and the descrambler can then be used to descramble
/// content secured with the session's key, either during extraction, or during decoding
/// with android.media.MediaCodec.
///
/// If the app handles sample extraction using its own extractor, it can use
/// MediaDescrambler to descramble samples into clear buffers (if the session's license
/// doesn't require secure decoders), or descramble a small amount of data to retrieve
/// information necessary for the downstream pipeline to process the sample (if the
/// session's license requires secure decoders).
///
/// If the session requires a secure decoder, a MediaDescrambler needs to be provided to
/// MediaCodec to descramble samples queued by MediaCodec\#queueSecureInputBuffer
/// into protected buffers. The app should use MediaCodec\#configure(MediaFormat,
/// android.view.Surface, int, MediaDescrambler) instead of the normal MediaCodec\#configure(MediaFormat, android.view.Surface, MediaCrypto, int) method
/// to configure MediaCodec.
///
/// <h3>Using Android's MediaExtractor</h3>
///
/// If the app uses MediaExtractor, it can delegate the CAS session
/// management to MediaExtractor by calling MediaExtractor\#setMediaCas.
/// MediaExtractor will take over and call \#openSession, \#processEmm
/// and/or Session\#processEcm, etc.. if necessary.
///
/// When using MediaExtractor, the app would still need a MediaDescrambler
/// to use with MediaCodec if the licensing requires a secure decoder. The
/// session associated with the descrambler of a track can be retrieved by calling
/// MediaExtractor\#getCasInfo, and used to initialize a MediaDescrambler
/// object for MediaCodec.
///
/// <h3>Listeners</h3>
/// The app may register a listener to receive events from the CA system using
/// method \#setEventListener. The exact format of the event is scheme-specific
/// and is not specified by this API.
class MediaCas extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/MediaCas");
  MediaCas.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int CA_system_id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiate a CA system of the specified system id.
  ///@param CA_system_id The system id of the CA system.
  ///@throws UnsupportedCasException if the device does not support the
  /// specified CA system.
  MediaCas(int CA_system_id)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [CA_system_id]).object);

  static final _id_isSystemIdSupported = jniAccessors.getStaticMethodIDOf(
      _classRef, "isSystemIdSupported", "(I)Z");

  /// from: static public boolean isSystemIdSupported(int CA_system_id)
  ///
  /// Query if a certain CA system is supported on this device.
  ///@param CA_system_id the id of the CA system.
  ///@return Whether the specified CA system is supported on this device.
  static bool isSystemIdSupported(int CA_system_id) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isSystemIdSupported,
          jni.JniType.booleanType, [CA_system_id]).boolean;

  static final _id_enumeratePlugins = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "enumeratePlugins",
      "()[Landroid/media/MediaCas\$PluginDescriptor;");

  /// from: static public android.media.MediaCas.PluginDescriptor[] enumeratePlugins()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List all available CA plugins on the device.
  ///@return an array of descriptors for the available CA plugins.
  static jni.JniObject enumeratePlugins() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_enumeratePlugins, jni.JniType.objectType, []).object);

  static final _id_setEventListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setEventListener",
      "(Landroid/media/MediaCas\$EventListener;Landroid/os/Handler;)V");

  /// from: public void setEventListener(android.media.MediaCas.EventListener listener, android.os.Handler handler)
  ///
  /// Set an event listener to receive notifications from the MediaCas instance.
  ///@param listener the event listener to be set.
  /// This value may be {@code null}.
  ///@param handler the handler whose looper the event listener will be called on.
  /// If handler is null, we'll try to use current thread's looper, or the main
  /// looper. If neither are available, an internal thread will be created instead.
  ///
  /// This value may be {@code null}.
  void setEventListener(
          MediaCas_EventListener listener, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setEventListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_setPrivateData =
      jniAccessors.getMethodIDOf(_classRef, "setPrivateData", "([B)V");

  /// from: public void setPrivateData(byte[] data)
  ///
  /// Send the private data for the CA system.
  ///@param data byte array of the private data.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void setPrivateData(jni.JniObject data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPrivateData,
      jni.JniType.voidType,
      [data.reference]).check();

  static final _id_openSession = jniAccessors.getMethodIDOf(
      _classRef, "openSession", "()Landroid/media/MediaCas\$Session;");

  /// from: public android.media.MediaCas.Session openSession()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a session to descramble one or more streams scrambled by the
  /// conditional access system.
  ///@return session the newly opened session.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  MediaCas_Session openSession() =>
      MediaCas_Session.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_openSession, jni.JniType.objectType, []).object);

  static final _id_processEmm =
      jniAccessors.getMethodIDOf(_classRef, "processEmm", "([BII)V");

  /// from: public void processEmm(byte[] data, int offset, int length)
  ///
  /// Send a received EMM packet to the CA system.
  ///@param data byte array of the EMM data.
  /// This value must never be {@code null}.
  ///@param offset position within data where the EMM data begins.
  ///@param length length of the data (starting from offset).
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void processEmm(jni.JniObject data, int offset, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_processEmm,
          jni.JniType.voidType, [data.reference, offset, length]).check();

  static final _id_processEmm1 =
      jniAccessors.getMethodIDOf(_classRef, "processEmm", "([B)V");

  /// from: public void processEmm(byte[] data)
  ///
  /// Send a received EMM packet to the CA system. This is similar to
  /// \#processEmm(byte[], int, int) except that the entire byte
  /// array is sent.
  ///@param data byte array of the EMM data.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void processEmm1(jni.JniObject data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_processEmm1,
      jni.JniType.voidType,
      [data.reference]).check();

  static final _id_sendEvent =
      jniAccessors.getMethodIDOf(_classRef, "sendEvent", "(II[B)V");

  /// from: public void sendEvent(int event, int arg, byte[] data)
  ///
  /// Send an event to a CA system. The format of the event is scheme-specific
  /// and is opaque to the framework.
  ///@param event an integer denoting a scheme-specific event to be sent.
  ///@param arg a scheme-specific integer argument for the event.
  ///@param data a byte array containing scheme-specific data for the event.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void sendEvent(int event, int arg, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendEvent,
          jni.JniType.voidType, [event, arg, data.reference]).check();

  static final _id_provision = jniAccessors.getMethodIDOf(
      _classRef, "provision", "(Ljava/lang/String;)V");

  /// from: public void provision(java.lang.String provisionString)
  ///
  /// Initiate a provisioning operation for a CA system.
  ///@param provisionString string containing information needed for the
  /// provisioning operation, the format of which is scheme and implementation
  /// specific.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void provision(jni.JniString provisionString) =>
      jniAccessors.callMethodWithArgs(reference, _id_provision,
          jni.JniType.voidType, [provisionString.reference]).check();

  static final _id_refreshEntitlements =
      jniAccessors.getMethodIDOf(_classRef, "refreshEntitlements", "(I[B)V");

  /// from: public void refreshEntitlements(int refreshType, byte[] refreshData)
  ///
  /// Notify the CA system to refresh entitlement keys.
  ///@param refreshType the type of the refreshment.
  ///@param refreshData private data associated with the refreshment.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void refreshEntitlements(int refreshType, jni.JniObject refreshData) =>
      jniAccessors.callMethodWithArgs(reference, _id_refreshEntitlements,
          jni.JniType.voidType, [refreshType, refreshData.reference]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.media.MediaCas$Session
///
/// Class for an open session with the CA system.
class MediaCas_Session extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaCas\$Session");
  MediaCas_Session.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/util/ArrayList;)V");

  /// from: void <init>(java.util.ArrayList<java.lang.Byte> sessionId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaCas_Session(jni.JniObject sessionId)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [sessionId.reference]).object);

  static final _id_setPrivateData =
      jniAccessors.getMethodIDOf(_classRef, "setPrivateData", "([B)V");

  /// from: public void setPrivateData(byte[] data)
  ///
  /// Set the private data for a session.
  ///@param data byte array of the private data.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void setPrivateData(jni.JniObject data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPrivateData,
      jni.JniType.voidType,
      [data.reference]).check();

  static final _id_processEcm =
      jniAccessors.getMethodIDOf(_classRef, "processEcm", "([BII)V");

  /// from: public void processEcm(byte[] data, int offset, int length)
  ///
  /// Send a received ECM packet to the specified session of the CA system.
  ///@param data byte array of the ECM data.
  /// This value must never be {@code null}.
  ///@param offset position within data where the ECM data begins.
  ///@param length length of the data (starting from offset).
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void processEcm(jni.JniObject data, int offset, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_processEcm,
          jni.JniType.voidType, [data.reference, offset, length]).check();

  static final _id_processEcm1 =
      jniAccessors.getMethodIDOf(_classRef, "processEcm", "([B)V");

  /// from: public void processEcm(byte[] data)
  ///
  /// Send a received ECM packet to the specified session of the CA system.
  /// This is similar to Session\#processEcm(byte[], int, int)
  /// except that the entire byte array is sent.
  ///@param data byte array of the ECM data.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasException for CAS-specific errors.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void processEcm1(jni.JniObject data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_processEcm1,
      jni.JniType.voidType,
      [data.reference]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close the session.
  ///@throws IllegalStateException if the MediaCas instance is not valid.
  ///@throws MediaCasStateException for CAS-specific state exceptions.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();
}

/// from: android.media.MediaCas$PluginDescriptor
///
/// Describe a CAS plugin with its CA_system_ID and string name.
///
/// Returned as results of \#enumeratePlugins.
class MediaCas_PluginDescriptor extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaCas\$PluginDescriptor");
  MediaCas_PluginDescriptor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaCas_PluginDescriptor()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getSystemId =
      jniAccessors.getMethodIDOf(_classRef, "getSystemId", "()I");

  /// from: public int getSystemId()
  int getSystemId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSystemId, jni.JniType.intType, []).integer;

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This value will never be {@code null}.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaCas$EventListener
///
/// An interface registered by the caller to \#setEventListener
/// to receives scheme-specific notifications from a MediaCas instance.
class MediaCas_EventListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaCas\$EventListener");
  MediaCas_EventListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onEvent = jniAccessors.getMethodIDOf(
      _classRef, "onEvent", "(Landroid/media/MediaCas;II[B)V");

  /// from: public abstract void onEvent(android.media.MediaCas MediaCas, int event, int arg, byte[] data)
  ///
  /// Notify the listener of a scheme-specific event from the CA system.
  ///@param MediaCas the MediaCas object to receive this event.
  ///@param event an integer whose meaning is scheme-specific.
  ///@param arg an integer whose meaning is scheme-specific.
  ///@param data a byte array of data whose format and meaning are
  /// scheme-specific.
  ///
  /// This value may be {@code null}.
  void onEvent(MediaCas MediaCas, int event, int arg, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onEvent,
          jni.JniType.voidType,
          [MediaCas.reference, event, arg, data.reference]).check();
}
