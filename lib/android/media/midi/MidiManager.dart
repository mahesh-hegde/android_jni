// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Handler.dart" as handler_;

import "MidiDeviceInfo.dart" as midideviceinfo_;

import "../../bluetooth/BluetoothDevice.dart" as bluetoothdevice_;

import "MidiDevice.dart" as mididevice_;

import "MidiDeviceStatus.dart" as mididevicestatus_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.midi.MidiManager
///
/// This class is the public application interface to the MIDI service.
///
/// Requires the android.content.pm.PackageManager\#FEATURE_MIDI PackageManager\#FEATURE_MIDI feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
class MidiManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/midi/MidiManager");
  MidiManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MidiManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_registerDeviceCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDeviceCallback",
      "(Landroid/media/midi/MidiManager\$DeviceCallback;Landroid/os/Handler;)V");

  /// from: public void registerDeviceCallback(android.media.midi.MidiManager.DeviceCallback callback, android.os.Handler handler)
  ///
  /// Registers a callback to receive notifications when MIDI devices are added and removed.
  ///
  /// The DeviceCallback\#onDeviceStatusChanged method will be called immediately
  /// for any devices that have open ports. This allows applications to know which input
  /// ports are already in use and, therefore, unavailable.
  ///
  /// Applications should call \#getDevices before registering the callback
  /// to get a list of devices already added.
  ///@param callback a DeviceCallback for MIDI device notifications
  ///@param handler The android.os.Handler Handler that will be used for delivering the
  ///                device notifications. If handler is null, then the thread used for the
  ///                callback is unspecified.
  void registerDeviceCallback(
          MidiManager_DeviceCallback callback, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerDeviceCallback,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterDeviceCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterDeviceCallback",
      "(Landroid/media/midi/MidiManager\$DeviceCallback;)V");

  /// from: public void unregisterDeviceCallback(android.media.midi.MidiManager.DeviceCallback callback)
  ///
  /// Unregisters a DeviceCallback.
  ///@param callback a DeviceCallback to unregister
  void unregisterDeviceCallback(MidiManager_DeviceCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterDeviceCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_getDevices = jniAccessors.getMethodIDOf(
      _classRef, "getDevices", "()[Landroid/media/midi/MidiDeviceInfo;");

  /// from: public android.media.midi.MidiDeviceInfo[] getDevices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of all connected MIDI devices.
  ///@return an array of all MIDI devices
  jni.JniObject getDevices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDevices, jni.JniType.objectType, []).object);

  static final _id_openDevice = jniAccessors.getMethodIDOf(
      _classRef,
      "openDevice",
      "(Landroid/media/midi/MidiDeviceInfo;Landroid/media/midi/MidiManager\$OnDeviceOpenedListener;Landroid/os/Handler;)V");

  /// from: public void openDevice(android.media.midi.MidiDeviceInfo deviceInfo, android.media.midi.MidiManager.OnDeviceOpenedListener listener, android.os.Handler handler)
  ///
  /// Opens a MIDI device for reading and writing.
  ///@param deviceInfo a android.media.midi.MidiDeviceInfo to open
  ///@param listener a MidiManager.OnDeviceOpenedListener to be called
  ///                 to receive the result
  ///@param handler the android.os.Handler Handler that will be used for delivering
  ///                the result. If handler is null, then the thread used for the
  ///                listener is unspecified.
  void openDevice(
          midideviceinfo_.MidiDeviceInfo deviceInfo,
          MidiManager_OnDeviceOpenedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_openDevice, jni.JniType.voidType, [
        deviceInfo.reference,
        listener.reference,
        handler.reference
      ]).check();

  static final _id_openBluetoothDevice = jniAccessors.getMethodIDOf(
      _classRef,
      "openBluetoothDevice",
      "(Landroid/bluetooth/BluetoothDevice;Landroid/media/midi/MidiManager\$OnDeviceOpenedListener;Landroid/os/Handler;)V");

  /// from: public void openBluetoothDevice(android.bluetooth.BluetoothDevice bluetoothDevice, android.media.midi.MidiManager.OnDeviceOpenedListener listener, android.os.Handler handler)
  ///
  /// Opens a Bluetooth MIDI device for reading and writing.
  ///@param bluetoothDevice a android.bluetooth.BluetoothDevice to open as a MIDI device
  ///@param listener a MidiManager.OnDeviceOpenedListener to be called to receive the
  /// result
  ///@param handler the android.os.Handler Handler that will be used for delivering
  ///                the result. If handler is null, then the thread used for the
  ///                listener is unspecified.
  void openBluetoothDevice(
          bluetoothdevice_.BluetoothDevice bluetoothDevice,
          MidiManager_OnDeviceOpenedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_openBluetoothDevice, jni.JniType.voidType, [
        bluetoothDevice.reference,
        listener.reference,
        handler.reference
      ]).check();
}

/// from: android.media.midi.MidiManager$OnDeviceOpenedListener
///
/// Listener class used for receiving the results of \#openDevice and
/// \#openBluetoothDevice
class MidiManager_OnDeviceOpenedListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/midi/MidiManager\$OnDeviceOpenedListener");
  MidiManager_OnDeviceOpenedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onDeviceOpened = jniAccessors.getMethodIDOf(
      _classRef, "onDeviceOpened", "(Landroid/media/midi/MidiDevice;)V");

  /// from: public abstract void onDeviceOpened(android.media.midi.MidiDevice device)
  ///
  /// Called to respond to a \#openDevice request
  ///@param device a MidiDevice for opened device, or null if opening failed
  void onDeviceOpened(mididevice_.MidiDevice device) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDeviceOpened,
          jni.JniType.voidType, [device.reference]).check();
}

/// from: android.media.midi.MidiManager$DeviceCallback
///
/// Callback class used for clients to receive MIDI device added and removed notifications
class MidiManager_DeviceCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/midi/MidiManager\$DeviceCallback");
  MidiManager_DeviceCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MidiManager_DeviceCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onDeviceAdded = jniAccessors.getMethodIDOf(
      _classRef, "onDeviceAdded", "(Landroid/media/midi/MidiDeviceInfo;)V");

  /// from: public void onDeviceAdded(android.media.midi.MidiDeviceInfo device)
  ///
  /// Called to notify when a new MIDI device has been added
  ///@param device a MidiDeviceInfo for the newly added device
  void onDeviceAdded(midideviceinfo_.MidiDeviceInfo device) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDeviceAdded,
          jni.JniType.voidType, [device.reference]).check();

  static final _id_onDeviceRemoved = jniAccessors.getMethodIDOf(
      _classRef, "onDeviceRemoved", "(Landroid/media/midi/MidiDeviceInfo;)V");

  /// from: public void onDeviceRemoved(android.media.midi.MidiDeviceInfo device)
  ///
  /// Called to notify when a MIDI device has been removed
  ///@param device a MidiDeviceInfo for the removed device
  void onDeviceRemoved(midideviceinfo_.MidiDeviceInfo device) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDeviceRemoved,
          jni.JniType.voidType, [device.reference]).check();

  static final _id_onDeviceStatusChanged = jniAccessors.getMethodIDOf(_classRef,
      "onDeviceStatusChanged", "(Landroid/media/midi/MidiDeviceStatus;)V");

  /// from: public void onDeviceStatusChanged(android.media.midi.MidiDeviceStatus status)
  ///
  /// Called to notify when the status of a MIDI device has changed
  ///@param status a MidiDeviceStatus for the changed device
  void onDeviceStatusChanged(mididevicestatus_.MidiDeviceStatus status) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDeviceStatusChanged,
          jni.JniType.voidType, [status.reference]).check();
}
