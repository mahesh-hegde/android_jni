// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.midi.MidiReceiver
///
/// Interface for sending and receiving data to and from a MIDI device.
class MidiReceiver extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/midi/MidiReceiver");
  MidiReceiver.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default MidiReceiver constructor. Maximum message size is set to
  /// java.lang.Integer\#MAX_VALUE
  MidiReceiver()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int maxMessageSize)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// MidiReceiver constructor.
  ///@param maxMessageSize the maximum size of a message this receiver can receive
  MidiReceiver.ctor1(int maxMessageSize)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [maxMessageSize]).object);

  static final _id_onSend =
      jniAccessors.getMethodIDOf(_classRef, "onSend", "([BIIJ)V");

  /// from: public abstract void onSend(byte[] msg, int offset, int count, long timestamp)
  ///
  /// Called whenever the receiver is passed new MIDI data.
  /// Subclasses override this method to receive MIDI data.
  /// May fail if count exceeds \#getMaxMessageSize.
  ///
  /// NOTE: the msg array parameter is only valid within the context of this call.
  /// The msg bytes should be copied by the receiver rather than retaining a reference
  /// to this parameter.
  /// Also, modifying the contents of the msg array parameter may result in other receivers
  /// in the same application receiving incorrect values in their {link \#onSend} method.
  ///@param msg a byte array containing the MIDI data
  ///@param offset the offset of the first byte of the data in the array to be processed
  ///@param count the number of bytes of MIDI data in the array to be processed
  ///@param timestamp the timestamp of the message (based on java.lang.System\#nanoTime
  ///@throws IOException
  void onSend(jni.JniObject msg, int offset, int count, int timestamp) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSend,
          jni.JniType.voidType,
          [msg.reference, offset, count, timestamp]).check();

  static final _id_flush =
      jniAccessors.getMethodIDOf(_classRef, "flush", "()V");

  /// from: public void flush()
  ///
  /// Instructs the receiver to discard all pending MIDI data.
  ///@throws IOException
  void flush() => jniAccessors.callMethodWithArgs(
      reference, _id_flush, jni.JniType.voidType, []).check();

  static final _id_onFlush =
      jniAccessors.getMethodIDOf(_classRef, "onFlush", "()V");

  /// from: public void onFlush()
  ///
  /// Called when the receiver is instructed to discard all pending MIDI data.
  /// Subclasses should override this method if they maintain a list or queue of MIDI data
  /// to be processed in the future.
  ///@throws IOException
  void onFlush() => jniAccessors.callMethodWithArgs(
      reference, _id_onFlush, jni.JniType.voidType, []).check();

  static final _id_getMaxMessageSize =
      jniAccessors.getMethodIDOf(_classRef, "getMaxMessageSize", "()I");

  /// from: public final int getMaxMessageSize()
  ///
  /// Returns the maximum size of a message this receiver can receive.
  ///@return maximum message size
  int getMaxMessageSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxMessageSize, jni.JniType.intType, []).integer;

  static final _id_send =
      jniAccessors.getMethodIDOf(_classRef, "send", "([BII)V");

  /// from: public void send(byte[] msg, int offset, int count)
  ///
  /// Called to send MIDI data to the receiver without a timestamp.
  /// Data will be processed by receiver in the order sent.
  /// Data will get split into multiple calls to \#onSend if count exceeds
  /// \#getMaxMessageSize.  Blocks until all the data is sent or an exception occurs.
  /// In the latter case, the amount of data sent prior to the exception is not provided to caller.
  /// The communication should be considered corrupt.  The sender should reestablish
  /// communication, reset all controllers and send all notes off.
  ///@param msg a byte array containing the MIDI data
  ///@param offset the offset of the first byte of the data in the array to be sent
  ///@param count the number of bytes of MIDI data in the array to be sent
  ///@throws IOException if the data could not be sent in entirety
  void send(jni.JniObject msg, int offset, int count) =>
      jniAccessors.callMethodWithArgs(reference, _id_send, jni.JniType.voidType,
          [msg.reference, offset, count]).check();

  static final _id_send1 =
      jniAccessors.getMethodIDOf(_classRef, "send", "([BIIJ)V");

  /// from: public void send(byte[] msg, int offset, int count, long timestamp)
  ///
  /// Called to send MIDI data to the receiver with a specified timestamp.
  /// Data will be processed by receiver in order first by timestamp, then in the order sent.
  /// Data will get split into multiple calls to \#onSend if count exceeds
  /// \#getMaxMessageSize.  Blocks until all the data is sent or an exception occurs.
  /// In the latter case, the amount of data sent prior to the exception is not provided to caller.
  /// The communication should be considered corrupt.  The sender should reestablish
  /// communication, reset all controllers and send all notes off.
  ///@param msg a byte array containing the MIDI data
  ///@param offset the offset of the first byte of the data in the array to be sent
  ///@param count the number of bytes of MIDI data in the array to be sent
  ///@param timestamp the timestamp of the message, based on java.lang.System\#nanoTime
  ///@throws IOException if the data could not be sent in entirety
  void send1(jni.JniObject msg, int offset, int count, int timestamp) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_send1,
          jni.JniType.voidType,
          [msg.reference, offset, count, timestamp]).check();
}
