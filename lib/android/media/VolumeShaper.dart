// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.VolumeShaper
///
/// The {@code VolumeShaper} class is used to automatically control audio volume during media
/// playback, allowing simple implementation of transition effects and ducking.
/// It is created from implementations of {@code VolumeAutomation},
/// such as {@code MediaPlayer} and {@code AudioTrack} (referred to as "players" below),
/// by MediaPlayer\#createVolumeShaper or AudioTrack\#createVolumeShaper.
///
/// A {@code VolumeShaper} is intended for short volume changes.
/// If the audio output sink changes during
/// a {@code VolumeShaper} transition, the precise curve position may be lost, and the
/// {@code VolumeShaper} may advance to the end of the curve for the new audio output sink.
///
/// The {@code VolumeShaper} appears as an additional scaling on the audio output,
/// and adjusts independently of track or stream volume controls.
class VolumeShaper extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/VolumeShaper");
  VolumeShaper.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_apply = jniAccessors.getMethodIDOf(
      _classRef, "apply", "(Landroid/media/VolumeShaper\$Operation;)V");

  /// from: public void apply(android.media.VolumeShaper.Operation operation)
  ///
  /// Applies the VolumeShaper.Operation to the {@code VolumeShaper}.
  ///
  /// Applying VolumeShaper.Operation\#PLAY after {@code PLAY}
  /// or VolumeShaper.Operation\#REVERSE after
  /// {@code REVERSE} has no effect.
  ///
  /// Applying VolumeShaper.Operation\#PLAY when the player
  /// hasn't started will synchronously start the {@code VolumeShaper} when
  /// playback begins.
  ///@param operation the {@code operation} to apply.
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the player is uninitialized or if there
  ///         is a critical failure. In that case, the {@code VolumeShaper} should be
  ///         recreated.
  void apply(VolumeShaper_Operation operation) =>
      jniAccessors.callMethodWithArgs(reference, _id_apply,
          jni.JniType.voidType, [operation.reference]).check();

  static final _id_replace = jniAccessors.getMethodIDOf(_classRef, "replace",
      "(Landroid/media/VolumeShaper\$Configuration;Landroid/media/VolumeShaper\$Operation;Z)V");

  /// from: public void replace(android.media.VolumeShaper.Configuration configuration, android.media.VolumeShaper.Operation operation, boolean join)
  ///
  /// Replaces the current {@code VolumeShaper}
  /// {@code configuration} with a new {@code configuration}.
  ///
  /// This allows the user to change the volume shape
  /// while the existing {@code VolumeShaper} is in effect.
  ///
  /// The effect of {@code replace()} is similar to an atomic close of
  /// the existing {@code VolumeShaper} and creation of a new {@code VolumeShaper}.
  ///
  /// If the {@code operation} is VolumeShaper.Operation\#PLAY then the
  /// new curve starts immediately.
  ///
  /// If the {@code operation} is
  /// VolumeShaper.Operation\#REVERSE, then the new curve will
  /// be delayed until {@code PLAY} is applied.
  ///@param configuration the new {@code configuration} to use.
  /// This value must never be {@code null}.
  ///@param operation the {@code operation} to apply to the {@code VolumeShaper}
  /// This value must never be {@code null}.
  ///@param join if true, match the start volume of the
  ///             new {@code configuration} to the current volume of the existing
  ///             {@code VolumeShaper}, to avoid discontinuity.
  ///@throws IllegalStateException if the player is uninitialized or if there
  ///         is a critical failure. In that case, the {@code VolumeShaper} should be
  ///         recreated.
  void replace(VolumeShaper_Configuration configuration,
          VolumeShaper_Operation operation, bool join) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_replace,
          jni.JniType.voidType,
          [configuration.reference, operation.reference, join]).check();

  static final _id_getVolume =
      jniAccessors.getMethodIDOf(_classRef, "getVolume", "()F");

  /// from: public float getVolume()
  ///
  /// Returns the current volume scale attributable to the {@code VolumeShaper}.
  ///
  /// This is the last volume from the {@code VolumeShaper} used for the player,
  /// or the initial volume if the {@code VolumeShaper} hasn't been started with
  /// VolumeShaper.Operation\#PLAY.
  ///@return the volume, linearly represented as a value between 0.f and 1.f.
  ///@throws IllegalStateException if the player is uninitialized or if there
  ///         is a critical failure.  In that case, the {@code VolumeShaper} should be
  ///         recreated.
  double getVolume() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolume, jni.JniType.floatType, []).float;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Releases the {@code VolumeShaper} object; any volume scale due to the
  /// {@code VolumeShaper} is removed after closing.
  ///
  /// If the volume does not reach 1.f when the {@code VolumeShaper} is closed
  /// (or finalized), there may be an abrupt change of volume.
  ///
  /// {@code close()} may be safely called after a prior {@code close()}.
  /// This class implements the Java {@code AutoClosable} interface and
  /// may be used with try-with-resources.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.media.VolumeShaper$Operation
///
/// The {@code VolumeShaper.Operation} class is used to specify operations
/// to the {@code VolumeShaper} that affect the volume change.
class VolumeShaper_Operation extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/VolumeShaper\$Operation");
  VolumeShaper_Operation.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.media.VolumeShaper.Operation> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_PLAY = jniAccessors.getStaticFieldIDOf(
      _classRef, "PLAY", "Landroid/media/VolumeShaper\$Operation;");

  /// from: static public final android.media.VolumeShaper.Operation PLAY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Forward playback from current volume time position.
  /// At the end of the {@code VolumeShaper} curve,
  /// the last volume value persists.
  static VolumeShaper_Operation get PLAY =>
      VolumeShaper_Operation.fromRef(jniAccessors
          .getStaticField(_classRef, _id_PLAY, jni.JniType.objectType)
          .object);

  static final _id_REVERSE = jniAccessors.getStaticFieldIDOf(
      _classRef, "REVERSE", "Landroid/media/VolumeShaper\$Operation;");

  /// from: static public final android.media.VolumeShaper.Operation REVERSE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reverse playback from current volume time position.
  /// When the position reaches the start of the {@code VolumeShaper} curve,
  /// the first volume value persists.
  static VolumeShaper_Operation get REVERSE =>
      VolumeShaper_Operation.fromRef(jniAccessors
          .getStaticField(_classRef, _id_REVERSE, jni.JniType.objectType)
          .object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.media.VolumeShaper$Configuration
///
/// The {@code VolumeShaper.Configuration} class contains curve
/// and duration information.
/// It is constructed by the VolumeShaper.Configuration.Builder.
///
/// A {@code VolumeShaper.Configuration} is used by
/// VolumeAutomation\#createVolumeShaper(Configuration) VolumeAutomation.createVolumeShaper(Configuration) to create
/// a {@code VolumeShaper} and
/// by VolumeShaper\#replace(Configuration, Operation, boolean) VolumeShaper.replace(Configuration, Operation, boolean)
/// to replace an existing {@code configuration}.
///
/// The AudioTrack and MediaPlayer classes implement
/// the VolumeAutomation interface.
class VolumeShaper_Configuration extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/VolumeShaper\$Configuration");
  VolumeShaper_Configuration.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.media.VolumeShaper.Configuration> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_CUBIC_RAMP = jniAccessors.getStaticFieldIDOf(
      _classRef, "CUBIC_RAMP", "Landroid/media/VolumeShaper\$Configuration;");

  /// from: static public final android.media.VolumeShaper.Configuration CUBIC_RAMP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A one second cubic ramp from silence to full volume.
  /// Use VolumeShaper.Builder\#reflectTimes()
  /// or VolumeShaper.Builder\#invertVolumes() to generate
  /// the matching cubic duck.
  static VolumeShaper_Configuration get CUBIC_RAMP =>
      VolumeShaper_Configuration.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CUBIC_RAMP, jni.JniType.objectType)
          .object);

  /// from: static public final int INTERPOLATOR_TYPE_CUBIC
  ///
  /// Cubic interpolated volume curve.
  /// This is default if unspecified.
  static const INTERPOLATOR_TYPE_CUBIC = 2;

  /// from: static public final int INTERPOLATOR_TYPE_CUBIC_MONOTONIC
  ///
  /// Cubic interpolated volume curve
  /// that preserves local monotonicity.
  /// So long as the control points are locally monotonic,
  /// the curve interpolation between those points are monotonic.
  /// This is useful for cubic spline interpolated
  /// volume ramps and ducks.
  static const INTERPOLATOR_TYPE_CUBIC_MONOTONIC = 3;

  /// from: static public final int INTERPOLATOR_TYPE_LINEAR
  ///
  /// Linear interpolated volume curve.
  static const INTERPOLATOR_TYPE_LINEAR = 1;

  /// from: static public final int INTERPOLATOR_TYPE_STEP
  ///
  /// Stepwise volume curve.
  static const INTERPOLATOR_TYPE_STEP = 0;

  static final _id_LINEAR_RAMP = jniAccessors.getStaticFieldIDOf(
      _classRef, "LINEAR_RAMP", "Landroid/media/VolumeShaper\$Configuration;");

  /// from: static public final android.media.VolumeShaper.Configuration LINEAR_RAMP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A one second linear ramp from silence to full volume.
  /// Use VolumeShaper.Builder\#reflectTimes()
  /// or VolumeShaper.Builder\#invertVolumes() to generate
  /// the matching linear duck.
  static VolumeShaper_Configuration get LINEAR_RAMP =>
      VolumeShaper_Configuration.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LINEAR_RAMP, jni.JniType.objectType)
          .object);

  static final _id_SCURVE_RAMP = jniAccessors.getStaticFieldIDOf(
      _classRef, "SCURVE_RAMP", "Landroid/media/VolumeShaper\$Configuration;");

  /// from: static public final android.media.VolumeShaper.Configuration SCURVE_RAMP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A one second sine-squared s-curve ramp
  /// from silence to full volume.
  /// Use VolumeShaper.Builder\#reflectTimes()
  /// or VolumeShaper.Builder\#invertVolumes() to generate
  /// the matching sine-squared s-curve duck.
  static VolumeShaper_Configuration get SCURVE_RAMP =>
      VolumeShaper_Configuration.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SCURVE_RAMP, jni.JniType.objectType)
          .object);

  static final _id_SINE_RAMP = jniAccessors.getStaticFieldIDOf(
      _classRef, "SINE_RAMP", "Landroid/media/VolumeShaper\$Configuration;");

  /// from: static public final android.media.VolumeShaper.Configuration SINE_RAMP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A one second sine curve
  /// from silence to full volume for energy preserving cross fades.
  /// Use VolumeShaper.Builder\#reflectTimes() to generate
  /// the matching cosine duck.
  static VolumeShaper_Configuration get SINE_RAMP =>
      VolumeShaper_Configuration.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SINE_RAMP, jni.JniType.objectType)
          .object);

  static final _id_getMaximumCurvePoints = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMaximumCurvePoints", "()I");

  /// from: static public int getMaximumCurvePoints()
  ///
  /// Returns the maximum number of curve points allowed for
  /// VolumeShaper.Builder\#setCurve(float[], float[]).
  static int getMaximumCurvePoints() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMaximumCurvePoints, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_getInterpolatorType =
      jniAccessors.getMethodIDOf(_classRef, "getInterpolatorType", "()I");

  /// from: public int getInterpolatorType()
  ///
  /// Returns the interpolator type.
  ///@return Value is android.media.VolumeShaper.Configuration\#INTERPOLATOR_TYPE_STEP, android.media.VolumeShaper.Configuration\#INTERPOLATOR_TYPE_LINEAR, android.media.VolumeShaper.Configuration\#INTERPOLATOR_TYPE_CUBIC, or android.media.VolumeShaper.Configuration\#INTERPOLATOR_TYPE_CUBIC_MONOTONIC
  int getInterpolatorType() => jniAccessors.callMethodWithArgs(
      reference, _id_getInterpolatorType, jni.JniType.intType, []).integer;

  static final _id_getDuration =
      jniAccessors.getMethodIDOf(_classRef, "getDuration", "()J");

  /// from: public long getDuration()
  ///
  /// Returns the duration of the volume shape in milliseconds.
  int getDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getDuration, jni.JniType.longType, []).long;

  static final _id_getTimes =
      jniAccessors.getMethodIDOf(_classRef, "getTimes", "()[F");

  /// from: public float[] getTimes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the times (x) coordinate array of the volume curve points.
  jni.JniObject getTimes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTimes, jni.JniType.objectType, []).object);

  static final _id_getVolumes =
      jniAccessors.getMethodIDOf(_classRef, "getVolumes", "()[F");

  /// from: public float[] getVolumes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the volumes (y) coordinate array of the volume curve points.
  jni.JniObject getVolumes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getVolumes, jni.JniType.objectType, []).object);
}

/// from: android.media.VolumeShaper$Configuration$Builder
///
/// Builder class for a VolumeShaper.Configuration object.
///  Here is an example where {@code Builder} is used to define the
/// VolumeShaper.Configuration.
///
/// <pre class="prettyprint">
/// VolumeShaper.Configuration LINEAR_RAMP =
///         new VolumeShaper.Configuration.Builder()
///             .setInterpolatorType(VolumeShaper.Configuration.INTERPOLATOR_TYPE_LINEAR)
///             .setCurve(new float[] { 0.f, 1.f }, // times
///                       new float[] { 0.f, 1.f }) // volumes
///             .setDuration(1000)
///             .build();
/// </pre>
///
class VolumeShaper_Configuration_Builder extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/VolumeShaper\$Configuration\$Builder");
  VolumeShaper_Configuration_Builder.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new {@code Builder} with the defaults.
  VolumeShaper_Configuration_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/media/VolumeShaper\$Configuration;)V");

  /// from: public void <init>(android.media.VolumeShaper.Configuration configuration)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new {@code Builder} with settings
  /// copied from a given {@code VolumeShaper.Configuration}.
  ///@param configuration prototypical configuration
  ///        which will be reused in the new {@code Builder}.
  ///
  /// This value must never be {@code null}.
  VolumeShaper_Configuration_Builder.ctor1(
      VolumeShaper_Configuration configuration)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [configuration.reference]).object);

  static final _id_setInterpolatorType = jniAccessors.getMethodIDOf(
      _classRef,
      "setInterpolatorType",
      "(I)Landroid/media/VolumeShaper\$Configuration\$Builder;");

  /// from: public android.media.VolumeShaper.Configuration.Builder setInterpolatorType(int interpolatorType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the interpolator type.
  ///
  /// If omitted the default interpolator type is \#INTERPOLATOR_TYPE_CUBIC.
  ///@param interpolatorType method of interpolation used for the volume curve.
  ///        One of \#INTERPOLATOR_TYPE_STEP,
  ///        \#INTERPOLATOR_TYPE_LINEAR,
  ///        \#INTERPOLATOR_TYPE_CUBIC,
  ///        \#INTERPOLATOR_TYPE_CUBIC_MONOTONIC.
  /// Value is android.media.VolumeShaper.Configuration\#INTERPOLATOR_TYPE_STEP, android.media.VolumeShaper.Configuration\#INTERPOLATOR_TYPE_LINEAR, android.media.VolumeShaper.Configuration\#INTERPOLATOR_TYPE_CUBIC, or android.media.VolumeShaper.Configuration\#INTERPOLATOR_TYPE_CUBIC_MONOTONIC
  ///@return the same {@code Builder} instance.
  /// This value will never be {@code null}.
  ///@throws IllegalArgumentException if {@code interpolatorType} is not valid.
  VolumeShaper_Configuration_Builder setInterpolatorType(
          int interpolatorType) =>
      VolumeShaper_Configuration_Builder.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setInterpolatorType,
              jni.JniType.objectType, [interpolatorType]).object);

  static final _id_setDuration = jniAccessors.getMethodIDOf(_classRef,
      "setDuration", "(J)Landroid/media/VolumeShaper\$Configuration\$Builder;");

  /// from: public android.media.VolumeShaper.Configuration.Builder setDuration(long durationMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the {@code VolumeShaper} duration in milliseconds.
  ///
  /// If omitted, the default duration is 1 second.
  ///@param durationMillis
  ///@return the same {@code Builder} instance.
  /// This value will never be {@code null}.
  ///@throws IllegalArgumentException if {@code durationMillis}
  ///         is not strictly positive.
  VolumeShaper_Configuration_Builder setDuration(int durationMillis) =>
      VolumeShaper_Configuration_Builder.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setDuration,
              jni.JniType.objectType, [durationMillis]).object);

  static final _id_setCurve = jniAccessors.getMethodIDOf(_classRef, "setCurve",
      "([F[F)Landroid/media/VolumeShaper\$Configuration\$Builder;");

  /// from: public android.media.VolumeShaper.Configuration.Builder setCurve(float[] times, float[] volumes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the volume curve.
  ///
  /// The volume curve is represented by a set of control points given by
  /// two float arrays of equal length,
  /// one representing the time (x) coordinates
  /// and one corresponding to the volume (y) coordinates.
  /// The length must be at least 2
  /// and no greater than VolumeShaper.Configuration\#getMaximumCurvePoints().
  ///
  /// The volume curve is normalized as follows:
  /// time (x) coordinates should be monotonically increasing, from 0.f to 1.f;
  /// volume (y) coordinates must be within 0.f to 1.f.
  ///
  /// The time scale is set by \#setDuration.
  ///
  ///@param times an array of float values representing
  ///        the time line of the volume curve.
  /// This value must never be {@code null}.
  ///@param volumes an array of float values representing
  ///        the amplitude of the volume curve.
  /// This value must never be {@code null}.
  ///@return the same {@code Builder} instance.
  /// This value will never be {@code null}.
  ///@throws IllegalArgumentException if {@code times} or {@code volumes} is invalid.
  VolumeShaper_Configuration_Builder setCurve(
          jni.JniObject times, jni.JniObject volumes) =>
      VolumeShaper_Configuration_Builder.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setCurve, jni.JniType.objectType,
              [times.reference, volumes.reference]).object);

  static final _id_reflectTimes = jniAccessors.getMethodIDOf(_classRef,
      "reflectTimes", "()Landroid/media/VolumeShaper\$Configuration\$Builder;");

  /// from: public android.media.VolumeShaper.Configuration.Builder reflectTimes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reflects the volume curve so that
  /// the shaper changes volume from the end
  /// to the start.
  ///@return the same {@code Builder} instance.
  /// This value will never be {@code null}.
  ///@throws IllegalStateException if curve has not been set.
  VolumeShaper_Configuration_Builder reflectTimes() =>
      VolumeShaper_Configuration_Builder.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_reflectTimes, jni.JniType.objectType, []).object);

  static final _id_invertVolumes = jniAccessors.getMethodIDOf(
      _classRef,
      "invertVolumes",
      "()Landroid/media/VolumeShaper\$Configuration\$Builder;");

  /// from: public android.media.VolumeShaper.Configuration.Builder invertVolumes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inverts the volume curve so that the max volume
  /// becomes the min volume and vice versa.
  ///@return the same {@code Builder} instance.
  /// This value will never be {@code null}.
  ///@throws IllegalStateException if curve has not been set.
  VolumeShaper_Configuration_Builder invertVolumes() =>
      VolumeShaper_Configuration_Builder.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_invertVolumes, jni.JniType.objectType, []).object);

  static final _id_scaleToEndVolume = jniAccessors.getMethodIDOf(
      _classRef,
      "scaleToEndVolume",
      "(F)Landroid/media/VolumeShaper\$Configuration\$Builder;");

  /// from: public android.media.VolumeShaper.Configuration.Builder scaleToEndVolume(float volume)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Scale the curve end volume to a target value.
  ///
  /// Keeps the start volume the same.
  /// This works best if the volume curve is monotonic.
  ///@param volume the target end volume to use.
  ///@return the same {@code Builder} instance.
  /// This value will never be {@code null}.
  ///@throws IllegalArgumentException if {@code volume} is not valid.
  ///@throws IllegalStateException if curve has not been set.
  VolumeShaper_Configuration_Builder scaleToEndVolume(double volume) =>
      VolumeShaper_Configuration_Builder.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_scaleToEndVolume,
              jni.JniType.objectType, [volume]).object);

  static final _id_scaleToStartVolume = jniAccessors.getMethodIDOf(
      _classRef,
      "scaleToStartVolume",
      "(F)Landroid/media/VolumeShaper\$Configuration\$Builder;");

  /// from: public android.media.VolumeShaper.Configuration.Builder scaleToStartVolume(float volume)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Scale the curve start volume to a target value.
  ///
  /// Keeps the end volume the same.
  /// This works best if the volume curve is monotonic.
  ///@param volume the target start volume to use.
  ///@return the same {@code Builder} instance.
  /// This value will never be {@code null}.
  ///@throws IllegalArgumentException if {@code volume} is not valid.
  ///@throws IllegalStateException if curve has not been set.
  VolumeShaper_Configuration_Builder scaleToStartVolume(double volume) =>
      VolumeShaper_Configuration_Builder.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_scaleToStartVolume,
              jni.JniType.objectType, [volume]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/media/VolumeShaper\$Configuration;");

  /// from: public android.media.VolumeShaper.Configuration build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds a new VolumeShaper object.
  ///@return a new VolumeShaper object.
  /// This value will never be {@code null}.
  ///@throws IllegalStateException if curve is not properly set.
  VolumeShaper_Configuration build() =>
      VolumeShaper_Configuration.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}
