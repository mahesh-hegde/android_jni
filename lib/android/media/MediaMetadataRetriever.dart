// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../net/Uri.dart" as uri_;

import "MediaDataSource.dart" as mediadatasource_;

import "../graphics/Bitmap.dart" as bitmap_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaMetadataRetriever
///
/// MediaMetadataRetriever class provides a unified interface for retrieving
/// frame and meta data from an input media file.
class MediaMetadataRetriever extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaMetadataRetriever");
  MediaMetadataRetriever.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int METADATA_KEY_ALBUM
  ///
  /// The metadata key to retrieve the information about the album title
  /// of the data source.
  static const METADATA_KEY_ALBUM = 1;

  /// from: static public final int METADATA_KEY_ALBUMARTIST
  ///
  /// The metadata key to retrieve the information about the performers or
  /// artist associated with the data source.
  static const METADATA_KEY_ALBUMARTIST = 13;

  /// from: static public final int METADATA_KEY_ARTIST
  ///
  /// The metadata key to retrieve the information about the artist of
  /// the data source.
  static const METADATA_KEY_ARTIST = 2;

  /// from: static public final int METADATA_KEY_AUTHOR
  ///
  /// The metadata key to retrieve the information about the author of
  /// the data source.
  static const METADATA_KEY_AUTHOR = 3;

  /// from: static public final int METADATA_KEY_BITRATE
  ///
  /// This key retrieves the average bitrate (in bits/sec), if available.
  static const METADATA_KEY_BITRATE = 20;

  /// from: static public final int METADATA_KEY_CAPTURE_FRAMERATE
  ///
  /// This key retrieves the original capture framerate, if it's
  /// available. The capture framerate will be a floating point
  /// number.
  static const METADATA_KEY_CAPTURE_FRAMERATE = 25;

  /// from: static public final int METADATA_KEY_CD_TRACK_NUMBER
  ///
  /// The metadata key to retrieve the numeric string describing the
  /// order of the audio data source on its original recording.
  static const METADATA_KEY_CD_TRACK_NUMBER = 0;

  /// from: static public final int METADATA_KEY_COMPILATION
  ///
  /// The metadata key to retrieve the music album compilation status.
  static const METADATA_KEY_COMPILATION = 15;

  /// from: static public final int METADATA_KEY_COMPOSER
  ///
  /// The metadata key to retrieve the information about the composer of
  /// the data source.
  static const METADATA_KEY_COMPOSER = 4;

  /// from: static public final int METADATA_KEY_DATE
  ///
  /// The metadata key to retrieve the date when the data source was created
  /// or modified.
  static const METADATA_KEY_DATE = 5;

  /// from: static public final int METADATA_KEY_DISC_NUMBER
  ///
  /// The metadata key to retrieve the numberic string that describes which
  /// part of a set the audio data source comes from.
  static const METADATA_KEY_DISC_NUMBER = 14;

  /// from: static public final int METADATA_KEY_DURATION
  ///
  /// The metadata key to retrieve the playback duration of the data source.
  static const METADATA_KEY_DURATION = 9;

  /// from: static public final int METADATA_KEY_GENRE
  ///
  /// The metadata key to retrieve the content type or genre of the data
  /// source.
  static const METADATA_KEY_GENRE = 6;

  /// from: static public final int METADATA_KEY_HAS_AUDIO
  ///
  /// If this key exists the media contains audio content.
  static const METADATA_KEY_HAS_AUDIO = 16;

  /// from: static public final int METADATA_KEY_HAS_IMAGE
  ///
  /// If this key exists the media contains still image content.
  static const METADATA_KEY_HAS_IMAGE = 26;

  /// from: static public final int METADATA_KEY_HAS_VIDEO
  ///
  /// If this key exists the media contains video content.
  static const METADATA_KEY_HAS_VIDEO = 17;

  /// from: static public final int METADATA_KEY_IMAGE_COUNT
  ///
  /// If the media contains still images, this key retrieves the number
  /// of still images.
  static const METADATA_KEY_IMAGE_COUNT = 27;

  /// from: static public final int METADATA_KEY_IMAGE_HEIGHT
  ///
  /// If the media contains still images, this key retrieves the height
  /// of the primary image.
  static const METADATA_KEY_IMAGE_HEIGHT = 30;

  /// from: static public final int METADATA_KEY_IMAGE_PRIMARY
  ///
  /// If the media contains still images, this key retrieves the image
  /// index of the primary image.
  static const METADATA_KEY_IMAGE_PRIMARY = 28;

  /// from: static public final int METADATA_KEY_IMAGE_ROTATION
  ///
  /// If the media contains still images, this key retrieves the rotation
  /// angle (in degrees clockwise) of the primary image. The image rotation
  /// angle must be one of 0, 90, 180, or 270 degrees.
  static const METADATA_KEY_IMAGE_ROTATION = 31;

  /// from: static public final int METADATA_KEY_IMAGE_WIDTH
  ///
  /// If the media contains still images, this key retrieves the width
  /// of the primary image.
  static const METADATA_KEY_IMAGE_WIDTH = 29;

  /// from: static public final int METADATA_KEY_LOCATION
  ///
  /// This key retrieves the location information, if available.
  /// The location should be specified according to ISO-6709 standard, under
  /// a mp4/3gp box "@xyz". Location with longitude of -90 degrees and latitude
  /// of 180 degrees will be retrieved as "-90.0000+180.0000", for instance.
  static const METADATA_KEY_LOCATION = 23;

  /// from: static public final int METADATA_KEY_MIMETYPE
  ///
  /// The metadata key to retrieve the mime type of the data source. Some
  /// example mime types include: "video/mp4", "audio/mp4", "audio/amr-wb",
  /// etc.
  static const METADATA_KEY_MIMETYPE = 12;

  /// from: static public final int METADATA_KEY_NUM_TRACKS
  ///
  /// The metadata key to retrieve the number of tracks, such as audio, video,
  /// text, in the data source, such as a mp4 or 3gpp file.
  static const METADATA_KEY_NUM_TRACKS = 10;

  /// from: static public final int METADATA_KEY_TITLE
  ///
  /// The metadata key to retrieve the data source title.
  static const METADATA_KEY_TITLE = 7;

  /// from: static public final int METADATA_KEY_VIDEO_FRAME_COUNT
  ///
  /// If the media contains video and this key exists, it retrieves the
  /// total number of frames in the video sequence.
  static const METADATA_KEY_VIDEO_FRAME_COUNT = 32;

  /// from: static public final int METADATA_KEY_VIDEO_HEIGHT
  ///
  /// If the media contains video, this key retrieves its height.
  static const METADATA_KEY_VIDEO_HEIGHT = 19;

  /// from: static public final int METADATA_KEY_VIDEO_ROTATION
  ///
  /// This key retrieves the video rotation angle in degrees, if available.
  /// The video rotation angle may be 0, 90, 180, or 270 degrees.
  static const METADATA_KEY_VIDEO_ROTATION = 24;

  /// from: static public final int METADATA_KEY_VIDEO_WIDTH
  ///
  /// If the media contains video, this key retrieves its width.
  static const METADATA_KEY_VIDEO_WIDTH = 18;

  /// from: static public final int METADATA_KEY_WRITER
  ///
  /// The metadata key to retrieve the information of the writer (such as
  /// lyricist) of the data source.
  static const METADATA_KEY_WRITER = 11;

  /// from: static public final int METADATA_KEY_YEAR
  ///
  /// The metadata key to retrieve the year when the data source was created
  /// or modified.
  static const METADATA_KEY_YEAR = 8;

  /// from: static public final int OPTION_CLOSEST
  ///
  /// This option is used with \#getFrameAtTime(long, int) to retrieve
  /// a frame (not necessarily a key frame) associated with a data source that
  /// is located closest to or at the given time.
  ///@see \#getFrameAtTime(long, int)
  static const OPTION_CLOSEST = 3;

  /// from: static public final int OPTION_CLOSEST_SYNC
  ///
  /// This option is used with \#getFrameAtTime(long, int) to retrieve
  /// a sync (or key) frame associated with a data source that is located
  /// closest to (in time) or at the given time.
  ///@see \#getFrameAtTime(long, int)
  static const OPTION_CLOSEST_SYNC = 2;

  /// from: static public final int OPTION_NEXT_SYNC
  ///
  /// This option is used with \#getFrameAtTime(long, int) to retrieve
  /// a sync (or key) frame associated with a data source that is located
  /// right after or at the given time.
  ///@see \#getFrameAtTime(long, int)
  static const OPTION_NEXT_SYNC = 1;

  /// from: static public final int OPTION_PREVIOUS_SYNC
  ///
  /// This option is used with \#getFrameAtTime(long, int) to retrieve
  /// a sync (or key) frame associated with a data source that is located
  /// right before or at the given time.
  ///@see \#getFrameAtTime(long, int)
  static const OPTION_PREVIOUS_SYNC = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaMetadataRetriever()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setDataSource = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/lang/String;)V");

  /// from: public void setDataSource(java.lang.String path)
  ///
  /// Sets the data source (file pathname) to use. Call this
  /// method before the rest of the methods in this class. This method may be
  /// time-consuming.
  ///@param path The path of the input media file.
  ///@throws IllegalArgumentException If the path is invalid.
  void setDataSource(jni.JniString path) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDataSource,
      jni.JniType.voidType,
      [path.reference]).check();

  static final _id_setDataSource1 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/lang/String;Ljava/util/Map;)V");

  /// from: public void setDataSource(java.lang.String uri, java.util.Map<java.lang.String,java.lang.String> headers)
  ///
  /// Sets the data source (URI) to use. Call this
  /// method before the rest of the methods in this class. This method may be
  /// time-consuming.
  ///@param uri The URI of the input media.
  ///@param headers the headers to be sent together with the request for the data
  ///@throws IllegalArgumentException If the URI is invalid.
  void setDataSource1(jni.JniString uri, jni.JniObject headers) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource1,
          jni.JniType.voidType, [uri.reference, headers.reference]).check();

  static final _id_setDataSource2 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/io/FileDescriptor;JJ)V");

  /// from: public native void setDataSource(java.io.FileDescriptor fd, long offset, long length)
  ///
  /// Sets the data source (FileDescriptor) to use.  It is the caller's
  /// responsibility to close the file descriptor. It is safe to do so as soon
  /// as this call returns. Call this method before the rest of the methods in
  /// this class. This method may be time-consuming.
  ///@param fd the FileDescriptor for the file you want to play
  ///@param offset the offset into the file where the data to be played starts,
  /// in bytes. It must be non-negative
  ///@param length the length in bytes of the data to be played. It must be
  /// non-negative.
  ///@throws IllegalArgumentException if the arguments are invalid
  void setDataSource2(jni.JniObject fd, int offset, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource2,
          jni.JniType.voidType, [fd.reference, offset, length]).check();

  static final _id_setDataSource3 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/io/FileDescriptor;)V");

  /// from: public void setDataSource(java.io.FileDescriptor fd)
  ///
  /// Sets the data source (FileDescriptor) to use. It is the caller's
  /// responsibility to close the file descriptor. It is safe to do so as soon
  /// as this call returns. Call this method before the rest of the methods in
  /// this class. This method may be time-consuming.
  ///@param fd the FileDescriptor for the file you want to play
  ///@throws IllegalArgumentException if the FileDescriptor is invalid
  void setDataSource3(jni.JniObject fd) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDataSource3,
      jni.JniType.voidType,
      [fd.reference]).check();

  static final _id_setDataSource4 = jniAccessors.getMethodIDOf(_classRef,
      "setDataSource", "(Landroid/content/Context;Landroid/net/Uri;)V");

  /// from: public void setDataSource(android.content.Context context, android.net.Uri uri)
  ///
  /// Sets the data source as a content Uri. Call this method before
  /// the rest of the methods in this class. This method may be time-consuming.
  ///@param context the Context to use when resolving the Uri
  ///@param uri the Content URI of the data you want to play
  ///@throws IllegalArgumentException if the Uri is invalid
  ///@throws SecurityException if the Uri cannot be used due to lack of
  /// permission.
  void setDataSource4(context_.Context context, uri_.Uri uri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource4,
          jni.JniType.voidType, [context.reference, uri.reference]).check();

  static final _id_setDataSource5 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Landroid/media/MediaDataSource;)V");

  /// from: public void setDataSource(android.media.MediaDataSource dataSource)
  ///
  /// Sets the data source (MediaDataSource) to use.
  ///@param dataSource the MediaDataSource for the media you want to play
  void setDataSource5(mediadatasource_.MediaDataSource dataSource) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource5,
          jni.JniType.voidType, [dataSource.reference]).check();

  static final _id_extractMetadata = jniAccessors.getMethodIDOf(
      _classRef, "extractMetadata", "(I)Ljava/lang/String;");

  /// from: public native java.lang.String extractMetadata(int keyCode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call this method after setDataSource(). This method retrieves the
  /// meta data value associated with the keyCode.
  ///
  /// The keyCode currently supported is listed below as METADATA_XXX
  /// constants. With any other value, it returns a null pointer.
  ///@param keyCode One of the constants listed below at the end of the class.
  ///@return The meta data value associate with the given keyCode on success;
  /// null on failure.
  jni.JniString extractMetadata(int keyCode) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_extractMetadata, jni.JniType.objectType, [keyCode]).object);

  static final _id_getFrameAtTime = jniAccessors.getMethodIDOf(
      _classRef, "getFrameAtTime", "(JI)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getFrameAtTime(long timeUs, int option)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call this method after setDataSource(). This method finds a
  /// representative frame close to the given time position by considering
  /// the given option if possible, and returns it as a bitmap.
  ///
  /// If you don't need a full-resolution
  /// frame (for example, because you need a thumbnail image), use
  /// \#getScaledFrameAtTime getScaledFrameAtTime() instead of this
  /// method.
  ///
  ///@param timeUs The time position where the frame will be retrieved.
  /// When retrieving the frame at the given time position, there is no
  /// guarantee that the data source has a frame located at the position.
  /// When this happens, a frame nearby will be returned. If timeUs is
  /// negative, time position and option will ignored, and any frame
  /// that the implementation considers as representative may be returned.
  ///@param option a hint on how the frame is found. Use
  /// \#OPTION_PREVIOUS_SYNC if one wants to retrieve a sync frame
  /// that has a timestamp earlier than or the same as timeUs. Use
  /// \#OPTION_NEXT_SYNC if one wants to retrieve a sync frame
  /// that has a timestamp later than or the same as timeUs. Use
  /// \#OPTION_CLOSEST_SYNC if one wants to retrieve a sync frame
  /// that has a timestamp closest to or the same as timeUs. Use
  /// \#OPTION_CLOSEST if one wants to retrieve a frame that may
  /// or may not be a sync frame but is closest to or the same as timeUs.
  /// \#OPTION_CLOSEST often has larger performance overhead compared
  /// to the other options if there is no sync frame located at timeUs.
  ///
  /// Value is either <code>0</code> or a combination of android.media.MediaMetadataRetriever\#OPTION_PREVIOUS_SYNC, android.media.MediaMetadataRetriever\#OPTION_NEXT_SYNC, android.media.MediaMetadataRetriever\#OPTION_CLOSEST_SYNC, and android.media.MediaMetadataRetriever\#OPTION_CLOSEST
  ///@return A Bitmap containing a representative video frame, which
  ///         can be null, if such a frame cannot be retrieved.
  bitmap_.Bitmap getFrameAtTime(int timeUs, int option) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFrameAtTime, jni.JniType.objectType, [timeUs, option]).object);

  static final _id_getScaledFrameAtTime = jniAccessors.getMethodIDOf(
      _classRef, "getScaledFrameAtTime", "(JIII)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getScaledFrameAtTime(long timeUs, int option, int dstWidth, int dstHeight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a video frame near a given timestamp scaled to a desired size.
  /// Call this method after setDataSource(). This method finds a representative
  /// frame close to the given time position by considering the given option
  /// if possible, and returns it as a bitmap with same aspect ratio as the source
  /// while scaling it so that it fits into the desired size of dst_width by dst_height.
  /// This is useful for generating a thumbnail for an input data source or just to
  /// obtain a scaled frame at the given time position.
  ///@param timeUs The time position in microseconds where the frame will be retrieved.
  /// When retrieving the frame at the given time position, there is no
  /// guarantee that the data source has a frame located at the position.
  /// When this happens, a frame nearby will be returned. If timeUs is
  /// negative, time position and option will ignored, and any frame
  /// that the implementation considers as representative may be returned.
  ///@param option a hint on how the frame is found. Use
  /// \#OPTION_PREVIOUS_SYNC if one wants to retrieve a sync frame
  /// that has a timestamp earlier than or the same as timeUs. Use
  /// \#OPTION_NEXT_SYNC if one wants to retrieve a sync frame
  /// that has a timestamp later than or the same as timeUs. Use
  /// \#OPTION_CLOSEST_SYNC if one wants to retrieve a sync frame
  /// that has a timestamp closest to or the same as timeUs. Use
  /// \#OPTION_CLOSEST if one wants to retrieve a frame that may
  /// or may not be a sync frame but is closest to or the same as timeUs.
  /// \#OPTION_CLOSEST often has larger performance overhead compared
  /// to the other options if there is no sync frame located at timeUs.
  ///
  /// Value is either <code>0</code> or a combination of android.media.MediaMetadataRetriever\#OPTION_PREVIOUS_SYNC, android.media.MediaMetadataRetriever\#OPTION_NEXT_SYNC, android.media.MediaMetadataRetriever\#OPTION_CLOSEST_SYNC, and android.media.MediaMetadataRetriever\#OPTION_CLOSEST
  ///@param dstWidth expected output bitmap width
  ///@param dstHeight expected output bitmap height
  ///@return A Bitmap of size not larger than dstWidth by dstHeight containing a
  ///         scaled video frame, which can be null, if such a frame cannot be retrieved.
  ///@throws IllegalArgumentException if passed in invalid option or width by height
  ///         is less than or equal to 0.
  bitmap_.Bitmap getScaledFrameAtTime(
          int timeUs, int option, int dstWidth, int dstHeight) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getScaledFrameAtTime,
          jni.JniType.objectType,
          [timeUs, option, dstWidth, dstHeight]).object);

  static final _id_getFrameAtTime1 = jniAccessors.getMethodIDOf(
      _classRef, "getFrameAtTime", "(J)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getFrameAtTime(long timeUs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call this method after setDataSource(). This method finds a
  /// representative frame close to the given time position if possible,
  /// and returns it as a bitmap. Call this method if one does not care
  /// how the frame is found as long as it is close to the given time;
  /// otherwise, please call \#getFrameAtTime(long, int).
  ///
  /// If you don't need a full-resolution
  /// frame (for example, because you need a thumbnail image), use
  /// \#getScaledFrameAtTime getScaledFrameAtTime() instead of this
  /// method.
  ///
  ///@param timeUs The time position where the frame will be retrieved.
  /// When retrieving the frame at the given time position, there is no
  /// guarentee that the data source has a frame located at the position.
  /// When this happens, a frame nearby will be returned. If timeUs is
  /// negative, time position and option will ignored, and any frame
  /// that the implementation considers as representative may be returned.
  ///@return A Bitmap of size dst_widthxdst_height containing a representative
  ///         video frame, which can be null, if such a frame cannot be retrieved.
  ///@see \#getFrameAtTime(long, int)
  bitmap_.Bitmap getFrameAtTime1(int timeUs) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFrameAtTime1, jni.JniType.objectType, [timeUs]).object);

  static final _id_getFrameAtTime2 = jniAccessors.getMethodIDOf(
      _classRef, "getFrameAtTime", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getFrameAtTime()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call this method after setDataSource(). This method finds a
  /// representative frame at any time position if possible,
  /// and returns it as a bitmap. Call this method if one does not
  /// care about where the frame is located; otherwise, please call
  /// \#getFrameAtTime(long) or \#getFrameAtTime(long, int)
  ///
  /// If you don't need a full-resolution
  /// frame (for example, because you need a thumbnail image), use
  /// \#getScaledFrameAtTime getScaledFrameAtTime() instead of this
  /// method.
  ///
  ///@return A Bitmap containing a representative video frame, which
  ///         can be null, if such a frame cannot be retrieved.
  ///@see \#getFrameAtTime(long)
  ///@see \#getFrameAtTime(long, int)
  bitmap_.Bitmap getFrameAtTime2() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFrameAtTime2, jni.JniType.objectType, []).object);

  static final _id_getFrameAtIndex = jniAccessors.getMethodIDOf(
      _classRef,
      "getFrameAtIndex",
      "(ILandroid/media/MediaMetadataRetriever\$BitmapParams;)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getFrameAtIndex(int frameIndex, android.media.MediaMetadataRetriever.BitmapParams params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method retrieves a video frame by its index. It should only be called
  /// after \#setDataSource.
  ///
  /// After the bitmap is returned, you can query the actual parameters that were
  /// used to create the bitmap from the {@code BitmapParams} argument, for instance
  /// to query the bitmap config used for the bitmap with BitmapParams\#getActualConfig.
  ///@param frameIndex 0-based index of the video frame. The frame index must be that of
  ///        a valid frame. The total number of frames available for retrieval can be queried
  ///        via the \#METADATA_KEY_VIDEO_FRAME_COUNT key.
  ///@param params BitmapParams that controls the returned bitmap config (such as pixel formats).
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the container doesn't contain video or image sequences.
  ///@throws IllegalArgumentException if the requested frame index does not exist.
  ///@return A Bitmap containing the requested video frame, or null if the retrieval fails.
  ///@see \#getFrameAtIndex(int)
  ///@see \#getFramesAtIndex(int, int, BitmapParams)
  ///@see \#getFramesAtIndex(int, int)
  bitmap_.Bitmap getFrameAtIndex(
          int frameIndex, MediaMetadataRetriever_BitmapParams params) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFrameAtIndex,
          jni.JniType.objectType,
          [frameIndex, params.reference]).object);

  static final _id_getFrameAtIndex1 = jniAccessors.getMethodIDOf(
      _classRef, "getFrameAtIndex", "(I)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getFrameAtIndex(int frameIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is similar to \#getFrameAtIndex(int, BitmapParams) except that
  /// the default for BitmapParams will be used.
  ///@param frameIndex 0-based index of the video frame. The frame index must be that of
  ///        a valid frame. The total number of frames available for retrieval can be queried
  ///        via the \#METADATA_KEY_VIDEO_FRAME_COUNT key.
  ///@throws IllegalStateException if the container doesn't contain video or image sequences.
  ///@throws IllegalArgumentException if the requested frame index does not exist.
  ///@return A Bitmap containing the requested video frame, or null if the retrieval fails.
  ///@see \#getFrameAtIndex(int, BitmapParams)
  ///@see \#getFramesAtIndex(int, int, BitmapParams)
  ///@see \#getFramesAtIndex(int, int)
  bitmap_.Bitmap getFrameAtIndex1(int frameIndex) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFrameAtIndex1, jni.JniType.objectType, [frameIndex]).object);

  static final _id_getFramesAtIndex = jniAccessors.getMethodIDOf(
      _classRef,
      "getFramesAtIndex",
      "(IILandroid/media/MediaMetadataRetriever\$BitmapParams;)Ljava/util/List;");

  /// from: public java.util.List<android.graphics.Bitmap> getFramesAtIndex(int frameIndex, int numFrames, android.media.MediaMetadataRetriever.BitmapParams params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method retrieves a consecutive set of video frames starting at the
  /// specified index. It should only be called after \#setDataSource.
  ///
  /// If the caller intends to retrieve more than one consecutive video frames,
  /// this method is preferred over \#getFrameAtIndex(int, BitmapParams) for efficiency.
  ///
  /// After the bitmaps are returned, you can query the actual parameters that were
  /// used to create the bitmaps from the {@code BitmapParams} argument, for instance
  /// to query the bitmap config used for the bitmaps with BitmapParams\#getActualConfig.
  ///@param frameIndex 0-based index of the first video frame to retrieve. The frame index
  ///        must be that of a valid frame. The total number of frames available for retrieval
  ///        can be queried via the \#METADATA_KEY_VIDEO_FRAME_COUNT key.
  ///@param numFrames number of consecutive video frames to retrieve. Must be a positive
  ///        value. The stream must contain at least numFrames frames starting at frameIndex.
  ///@param params BitmapParams that controls the returned bitmap config (such as pixel formats).
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the container doesn't contain video or image sequences.
  ///@throws IllegalArgumentException if the frameIndex or numFrames is invalid, or the
  ///         stream doesn't contain at least numFrames starting at frameIndex.
  ///@return An list of Bitmaps containing the requested video frames. The returned
  ///         array could contain less frames than requested if the retrieval fails.
  ///
  /// This value will never be {@code null}.
  ///@see \#getFrameAtIndex(int, BitmapParams)
  ///@see \#getFrameAtIndex(int)
  ///@see \#getFramesAtIndex(int, int)
  jni.JniObject getFramesAtIndex(int frameIndex, int numFrames,
          MediaMetadataRetriever_BitmapParams params) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFramesAtIndex,
          jni.JniType.objectType,
          [frameIndex, numFrames, params.reference]).object);

  static final _id_getFramesAtIndex1 = jniAccessors.getMethodIDOf(
      _classRef, "getFramesAtIndex", "(II)Ljava/util/List;");

  /// from: public java.util.List<android.graphics.Bitmap> getFramesAtIndex(int frameIndex, int numFrames)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is similar to \#getFramesAtIndex(int, int, BitmapParams) except that
  /// the default for BitmapParams will be used.
  ///@param frameIndex 0-based index of the first video frame to retrieve. The frame index
  ///        must be that of a valid frame. The total number of frames available for retrieval
  ///        can be queried via the \#METADATA_KEY_VIDEO_FRAME_COUNT key.
  ///@param numFrames number of consecutive video frames to retrieve. Must be a positive
  ///        value. The stream must contain at least numFrames frames starting at frameIndex.
  ///@throws IllegalStateException if the container doesn't contain video or image sequences.
  ///@throws IllegalArgumentException if the frameIndex or numFrames is invalid, or the
  ///         stream doesn't contain at least numFrames starting at frameIndex.
  ///@return An list of Bitmaps containing the requested video frames. The returned
  ///         array could contain less frames than requested if the retrieval fails.
  ///
  /// This value will never be {@code null}.
  ///@see \#getFrameAtIndex(int, BitmapParams)
  ///@see \#getFrameAtIndex(int)
  ///@see \#getFramesAtIndex(int, int, BitmapParams)
  jni.JniObject getFramesAtIndex1(int frameIndex, int numFrames) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFramesAtIndex1,
          jni.JniType.objectType,
          [frameIndex, numFrames]).object);

  static final _id_getImageAtIndex = jniAccessors.getMethodIDOf(
      _classRef,
      "getImageAtIndex",
      "(ILandroid/media/MediaMetadataRetriever\$BitmapParams;)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getImageAtIndex(int imageIndex, android.media.MediaMetadataRetriever.BitmapParams params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method retrieves a still image by its index. It should only be called
  /// after \#setDataSource.
  ///
  /// After the bitmap is returned, you can query the actual parameters that were
  /// used to create the bitmap from the {@code BitmapParams} argument, for instance
  /// to query the bitmap config used for the bitmap with BitmapParams\#getActualConfig.
  ///@param imageIndex 0-based index of the image.
  ///@param params BitmapParams that controls the returned bitmap config (such as pixel formats).
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the container doesn't contain still images.
  ///@throws IllegalArgumentException if the requested image does not exist.
  ///@return the requested still image, or null if the image cannot be retrieved.
  ///@see \#getImageAtIndex(int)
  ///@see \#getPrimaryImage(BitmapParams)
  ///@see \#getPrimaryImage()
  bitmap_.Bitmap getImageAtIndex(
          int imageIndex, MediaMetadataRetriever_BitmapParams params) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getImageAtIndex,
          jni.JniType.objectType,
          [imageIndex, params.reference]).object);

  static final _id_getImageAtIndex1 = jniAccessors.getMethodIDOf(
      _classRef, "getImageAtIndex", "(I)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getImageAtIndex(int imageIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is similar to \#getImageAtIndex(int, BitmapParams) except that
  /// the default for BitmapParams will be used.
  ///@param imageIndex 0-based index of the image.
  ///@throws IllegalStateException if the container doesn't contain still images.
  ///@throws IllegalArgumentException if the requested image does not exist.
  ///@return the requested still image, or null if the image cannot be retrieved.
  ///@see \#getImageAtIndex(int, BitmapParams)
  ///@see \#getPrimaryImage(BitmapParams)
  ///@see \#getPrimaryImage()
  bitmap_.Bitmap getImageAtIndex1(int imageIndex) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getImageAtIndex1, jni.JniType.objectType, [imageIndex]).object);

  static final _id_getPrimaryImage = jniAccessors.getMethodIDOf(
      _classRef,
      "getPrimaryImage",
      "(Landroid/media/MediaMetadataRetriever\$BitmapParams;)Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getPrimaryImage(android.media.MediaMetadataRetriever.BitmapParams params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method retrieves the primary image of the media content. It should only
  /// be called after \#setDataSource.
  ///
  /// After the bitmap is returned, you can query the actual parameters that were
  /// used to create the bitmap from the {@code BitmapParams} argument, for instance
  /// to query the bitmap config used for the bitmap with BitmapParams\#getActualConfig.
  ///@param params BitmapParams that controls the returned bitmap config (such as pixel formats).
  ///
  /// This value must never be {@code null}.
  ///@return the primary image, or null if it cannot be retrieved.
  ///@throws IllegalStateException if the container doesn't contain still images.
  ///@see \#getImageAtIndex(int, BitmapParams)
  ///@see \#getImageAtIndex(int)
  ///@see \#getPrimaryImage()
  bitmap_.Bitmap getPrimaryImage(MediaMetadataRetriever_BitmapParams params) =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPrimaryImage,
          jni.JniType.objectType,
          [params.reference]).object);

  static final _id_getPrimaryImage1 = jniAccessors.getMethodIDOf(
      _classRef, "getPrimaryImage", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getPrimaryImage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is similar to \#getPrimaryImage(BitmapParams) except that
  /// the default for BitmapParams will be used.
  ///@return the primary image, or null if it cannot be retrieved.
  ///@throws IllegalStateException if the container doesn't contain still images.
  ///@see \#getImageAtIndex(int, BitmapParams)
  ///@see \#getImageAtIndex(int)
  ///@see \#getPrimaryImage(BitmapParams)
  bitmap_.Bitmap getPrimaryImage1() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPrimaryImage1, jni.JniType.objectType, []).object);

  static final _id_getEmbeddedPicture =
      jniAccessors.getMethodIDOf(_classRef, "getEmbeddedPicture", "()[B");

  /// from: public byte[] getEmbeddedPicture()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call this method after setDataSource(). This method finds the optional
  /// graphic or album/cover art associated associated with the data source. If
  /// there are more than one pictures, (any) one of them is returned.
  ///@return null if no such graphic is found.
  jni.JniObject getEmbeddedPicture() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getEmbeddedPicture, jni.JniType.objectType, []).object);

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public native void release()
  ///
  /// Call it when one is done with the object. This method releases the memory
  /// allocated internally.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.media.MediaMetadataRetriever$BitmapParams
class MediaMetadataRetriever_BitmapParams extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaMetadataRetriever\$BitmapParams");
  MediaMetadataRetriever_BitmapParams.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a default BitmapParams object. By default, it uses Bitmap.Config\#ARGB_8888
  /// as the preferred bitmap config.
  MediaMetadataRetriever_BitmapParams()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setPreferredConfig = jniAccessors.getMethodIDOf(
      _classRef, "setPreferredConfig", "(Landroid/graphics/Bitmap\$Config;)V");

  /// from: public void setPreferredConfig(android.graphics.Bitmap.Config config)
  ///
  /// Set the preferred bitmap config for the decoder to decode into.
  ///
  /// If not set, or the request cannot be met, the decoder will output
  /// in Bitmap.Config\#ARGB_8888 config by default.
  ///
  /// After decode, the actual config used can be retrieved by \#getActualConfig().
  ///@param config the preferred bitmap config to use.
  ///
  /// This value must never be {@code null}.
  void setPreferredConfig(bitmap_.Bitmap_Config config) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreferredConfig,
          jni.JniType.voidType, [config.reference]).check();

  static final _id_getPreferredConfig = jniAccessors.getMethodIDOf(
      _classRef, "getPreferredConfig", "()Landroid/graphics/Bitmap\$Config;");

  /// from: public android.graphics.Bitmap.Config getPreferredConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the preferred bitmap config in the params.
  ///@return the preferred bitmap config.
  ///
  /// This value will never be {@code null}.
  bitmap_.Bitmap_Config getPreferredConfig() =>
      bitmap_.Bitmap_Config.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPreferredConfig, jni.JniType.objectType, []).object);

  static final _id_getActualConfig = jniAccessors.getMethodIDOf(
      _classRef, "getActualConfig", "()Landroid/graphics/Bitmap\$Config;");

  /// from: public android.graphics.Bitmap.Config getActualConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the actual bitmap config used to decode the bitmap after the decoding.
  ///@return the actual bitmap config used.
  ///
  /// This value will never be {@code null}.
  bitmap_.Bitmap_Config getActualConfig() =>
      bitmap_.Bitmap_Config.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActualConfig, jni.JniType.objectType, []).object);
}
