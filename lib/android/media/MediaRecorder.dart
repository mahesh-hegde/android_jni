// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../hardware/Camera.dart" as camera_;

import "../view/Surface.dart" as surface_;

import "CamcorderProfile.dart" as camcorderprofile_;

import "AudioDeviceInfo.dart" as audiodeviceinfo_;

import "AudioRouting.dart" as audiorouting_;

import "../os/Handler.dart" as handler_;

import "../os/PersistableBundle.dart" as persistablebundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaRecorder
///
/// Used to record audio and video. The recording control is based on a
/// simple state machine (see below).
///
/// <img src="{@docRoot}images/mediarecorder_state_diagram.gif"border="0"/>
///
///
///
/// A common case of using MediaRecorder to record audio works as follows:
///
/// <pre>MediaRecorder recorder = new MediaRecorder();
/// recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
/// recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
/// recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
/// recorder.setOutputFile(PATH_NAME);
/// recorder.prepare();
/// recorder.start();   // Recording is now started
/// ...
/// recorder.stop();
/// recorder.reset();   // You can reuse the object by going back to setAudioSource() step
/// recorder.release(); // Now the object cannot be reused
/// </pre>
///
/// Applications may want to register for informational and error
/// events in order to be informed of some internal update and possible
/// runtime errors during recording. Registration for such events is
/// done by setting the appropriate listeners (via calls
/// (to \#setOnInfoListener(OnInfoListener)setOnInfoListener and/or
/// \#setOnErrorListener(OnErrorListener)setOnErrorListener).
/// In order to receive the respective callback associated with these listeners,
/// applications are required to create MediaRecorder objects on threads with a
/// Looper running (the main UI thread by default already has a Looper running).
///
/// <strong>Note:</strong> Currently, MediaRecorder does not work on the emulator.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about how to use MediaRecorder for recording video, read the
/// <a href="{@docRoot}guide/topics/media/camera.html\#capture-video">Camera</a> developer guide.
/// For more information about how to use MediaRecorder for recording sound, read the
/// <a href="{@docRoot}guide/topics/media/audio-capture.html">Audio Capture</a> developer guide.
///
/// </div>
class MediaRecorder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder");
  MediaRecorder.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MEDIA_ERROR_SERVER_DIED
  ///
  /// Media server died. In this case, the application must release the
  /// MediaRecorder object and instantiate a new one.
  ///@see android.media.MediaRecorder.OnErrorListener
  static const MEDIA_ERROR_SERVER_DIED = 100;

  /// from: static public final int MEDIA_RECORDER_ERROR_UNKNOWN
  ///
  /// Unspecified media recorder error.
  ///@see android.media.MediaRecorder.OnErrorListener
  static const MEDIA_RECORDER_ERROR_UNKNOWN = 1;

  /// from: static public final int MEDIA_RECORDER_INFO_MAX_DURATION_REACHED
  ///
  /// A maximum duration had been setup and has now been reached.
  ///@see android.media.MediaRecorder.OnInfoListener
  static const MEDIA_RECORDER_INFO_MAX_DURATION_REACHED = 800;

  /// from: static public final int MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING
  ///
  /// A maximum filesize had been setup and current recorded file size
  /// has reached 90% of the limit. This is sent once per file upon
  /// reaching/passing the 90% limit. To continue the recording, applicaiton
  /// should use \#setNextOutputFile to set the next output file.
  /// Otherwise, recording will stop when reaching maximum file size.
  ///@see android.media.MediaRecorder.OnInfoListener
  static const MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING = 802;

  /// from: static public final int MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED
  ///
  /// A maximum filesize had been setup and has now been reached.
  /// Note: This event will not be sent if application already set
  /// next output file through \#setNextOutputFile.
  ///@see android.media.MediaRecorder.OnInfoListener
  static const MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED = 801;

  /// from: static public final int MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED
  ///
  /// A maximum filesize had been reached and MediaRecorder has switched
  /// output to a new file set by application \#setNextOutputFile.
  /// For best practice, application should use this event to keep track
  /// of whether the file previously set has been used or not.
  ///@see android.media.MediaRecorder.OnInfoListener
  static const MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED = 803;

  /// from: static public final int MEDIA_RECORDER_INFO_UNKNOWN
  ///
  /// Unspecified media recorder info.
  ///@see android.media.MediaRecorder.OnInfoListener
  static const MEDIA_RECORDER_INFO_UNKNOWN = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default constructor.
  MediaRecorder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setCamera = jniAccessors.getMethodIDOf(
      _classRef, "setCamera", "(Landroid/hardware/Camera;)V");

  /// from: public native void setCamera(android.hardware.Camera c)
  ///
  /// Sets a android.hardware.Camera to use for recording.
  ///
  /// Use this function to switch quickly between preview and capture mode without a teardown of
  /// the camera object. android.hardware.Camera\#unlock() should be called before
  /// this. Must call before \#prepare.
  ///
  ///@param c the Camera to use for recording
  ///@deprecated Use \#getSurface and the android.hardware.camera2 API instead.
  void setCamera(camera_.Camera c) => jniAccessors.callMethodWithArgs(
      reference, _id_setCamera, jni.JniType.voidType, [c.reference]).check();

  static final _id_getSurface = jniAccessors.getMethodIDOf(
      _classRef, "getSurface", "()Landroid/view/Surface;");

  /// from: public native android.view.Surface getSurface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the surface to record from when using SURFACE video source.
  ///
  ///  May only be called after \#prepare. Frames rendered to the Surface before
  /// \#start will be discarded.
  ///
  ///@throws IllegalStateException if it is called before \#prepare, after
  /// \#stop, or is called when VideoSource is not set to SURFACE.
  ///@see android.media.MediaRecorder.VideoSource
  surface_.Surface getSurface() =>
      surface_.Surface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurface, jni.JniType.objectType, []).object);

  static final _id_setInputSurface = jniAccessors.getMethodIDOf(
      _classRef, "setInputSurface", "(Landroid/view/Surface;)V");

  /// from: public void setInputSurface(android.view.Surface surface)
  ///
  /// Configures the recorder to use a persistent surface when using SURFACE video source.
  ///  May only be called before \#prepare. If called, \#getSurface should
  /// not be used and will throw IllegalStateException. Frames rendered to the Surface
  /// before \#start will be discarded.
  ///
  ///@param surface a persistent input surface created by
  ///           MediaCodec\#createPersistentInputSurface
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if it is called after \#prepare and before
  /// \#stop.
  ///@throws IllegalArgumentException if the surface was not created by
  ///           MediaCodec\#createPersistentInputSurface.
  ///@see MediaCodec\#createPersistentInputSurface
  ///@see MediaRecorder.VideoSource
  void setInputSurface(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInputSurface,
          jni.JniType.voidType, [surface.reference]).check();

  static final _id_setPreviewDisplay = jniAccessors.getMethodIDOf(
      _classRef, "setPreviewDisplay", "(Landroid/view/Surface;)V");

  /// from: public void setPreviewDisplay(android.view.Surface sv)
  ///
  /// Sets a Surface to show a preview of recorded media (video). Calls this
  /// before prepare() to make sure that the desirable preview display is
  /// set. If \#setCamera(Camera) is used and the surface has been
  /// already set to the camera, application do not need to call this. If
  /// this is called with non-null surface, the preview surface of the camera
  /// will be replaced by the new surface. If this method is called with null
  /// surface or not called at all, media recorder will not change the preview
  /// surface of the camera.
  ///@param sv the Surface to use for the preview
  ///@see android.hardware.Camera\#setPreviewDisplay(android.view.SurfaceHolder)
  void setPreviewDisplay(surface_.Surface sv) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreviewDisplay,
          jni.JniType.voidType, [sv.reference]).check();

  static final _id_setAudioSource =
      jniAccessors.getMethodIDOf(_classRef, "setAudioSource", "(I)V");

  /// from: public native void setAudioSource(int audio_source)
  ///
  /// Sets the audio source to be used for recording. If this method is not
  /// called, the output file will not contain an audio track. The source needs
  /// to be specified before setting recording-parameters or encoders. Call
  /// this only before setOutputFormat().
  ///@param audio_source the audio source to use
  ///@throws IllegalStateException if it is called after setOutputFormat()
  ///@see android.media.MediaRecorder.AudioSource
  void setAudioSource(int audio_source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAudioSource,
      jni.JniType.voidType,
      [audio_source]).check();

  static final _id_getAudioSourceMax =
      jniAccessors.getStaticMethodIDOf(_classRef, "getAudioSourceMax", "()I");

  /// from: static public final int getAudioSourceMax()
  ///
  /// Gets the maximum value for audio sources.
  ///@see android.media.MediaRecorder.AudioSource
  static int getAudioSourceMax() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getAudioSourceMax, jni.JniType.intType, []).integer;

  static final _id_setVideoSource =
      jniAccessors.getMethodIDOf(_classRef, "setVideoSource", "(I)V");

  /// from: public native void setVideoSource(int video_source)
  ///
  /// Sets the video source to be used for recording. If this method is not
  /// called, the output file will not contain an video track. The source needs
  /// to be specified before setting recording-parameters or encoders. Call
  /// this only before setOutputFormat().
  ///@param video_source the video source to use
  ///@throws IllegalStateException if it is called after setOutputFormat()
  ///@see android.media.MediaRecorder.VideoSource
  void setVideoSource(int video_source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVideoSource,
      jni.JniType.voidType,
      [video_source]).check();

  static final _id_setProfile = jniAccessors.getMethodIDOf(
      _classRef, "setProfile", "(Landroid/media/CamcorderProfile;)V");

  /// from: public void setProfile(android.media.CamcorderProfile profile)
  ///
  /// Uses the settings from a CamcorderProfile object for recording. This method should
  /// be called after the video AND audio sources are set, and before setOutputFile().
  /// If a time lapse CamcorderProfile is used, audio related source or recording
  /// parameters are ignored.
  ///@param profile the CamcorderProfile to use
  ///@see android.media.CamcorderProfile
  void setProfile(camcorderprofile_.CamcorderProfile profile) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProfile,
          jni.JniType.voidType, [profile.reference]).check();

  static final _id_setCaptureRate =
      jniAccessors.getMethodIDOf(_classRef, "setCaptureRate", "(D)V");

  /// from: public void setCaptureRate(double fps)
  ///
  /// Set video frame capture rate. This can be used to set a different video frame capture
  /// rate than the recorded video's playback rate. This method also sets the recording mode
  /// to time lapse. In time lapse video recording, only video is recorded. Audio related
  /// parameters are ignored when a time lapse recording session starts, if an application
  /// sets them.
  ///@param fps Rate at which frames should be captured in frames per second.
  /// The fps can go as low as desired. However the fastest fps will be limited by the hardware.
  /// For resolutions that can be captured by the video camera, the fastest fps can be computed using
  /// android.hardware.Camera.Parameters\#getPreviewFpsRange(int[]). For higher
  /// resolutions the fastest fps may be more restrictive.
  /// Note that the recorder cannot guarantee that frames will be captured at the
  /// given rate due to camera/encoder limitations. However it tries to be as close as
  /// possible.
  void setCaptureRate(double fps) => jniAccessors.callMethodWithArgs(
      reference, _id_setCaptureRate, jni.JniType.voidType, [fps]).check();

  static final _id_setOrientationHint =
      jniAccessors.getMethodIDOf(_classRef, "setOrientationHint", "(I)V");

  /// from: public void setOrientationHint(int degrees)
  ///
  /// Sets the orientation hint for output video playback.
  /// This method should be called before prepare(). This method will not
  /// trigger the source video frame to rotate during video recording, but to
  /// add a composition matrix containing the rotation angle in the output
  /// video if the output format is OutputFormat.THREE_GPP or
  /// OutputFormat.MPEG_4 so that a video player can choose the proper
  /// orientation for playback. Note that some video players may choose
  /// to ignore the compostion matrix in a video during playback.
  ///@param degrees the angle to be rotated clockwise in degrees.
  /// The supported angles are 0, 90, 180, and 270 degrees.
  ///@throws IllegalArgumentException if the angle is not supported.
  void setOrientationHint(int degrees) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOrientationHint,
      jni.JniType.voidType,
      [degrees]).check();

  static final _id_setLocation =
      jniAccessors.getMethodIDOf(_classRef, "setLocation", "(FF)V");

  /// from: public void setLocation(float latitude, float longitude)
  ///
  /// Set and store the geodata (latitude and longitude) in the output file.
  /// This method should be called before prepare(). The geodata is
  /// stored in udta box if the output format is OutputFormat.THREE_GPP
  /// or OutputFormat.MPEG_4, and is ignored for other output formats.
  /// The geodata is stored according to ISO-6709 standard.
  ///@param latitude latitude in degrees. Its value must be in the
  /// range [-90, 90].
  ///@param longitude longitude in degrees. Its value must be in the
  /// range [-180, 180].
  ///@throws IllegalArgumentException if the given latitude or
  /// longitude is out of range.
  void setLocation(double latitude, double longitude) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLocation,
          jni.JniType.voidType, [latitude, longitude]).check();

  static final _id_setOutputFormat =
      jniAccessors.getMethodIDOf(_classRef, "setOutputFormat", "(I)V");

  /// from: public native void setOutputFormat(int output_format)
  ///
  /// Sets the format of the output file produced during recording. Call this
  /// after setAudioSource()/setVideoSource() but before prepare().
  ///
  /// It is recommended to always use 3GP format when using the H.263
  /// video encoder and AMR audio encoder. Using an MPEG-4 container format
  /// may confuse some desktop players.
  ///
  ///@param output_format the output format to use. The output format
  /// needs to be specified before setting recording-parameters or encoders.
  ///@throws IllegalStateException if it is called after prepare() or before
  /// setAudioSource()/setVideoSource().
  ///@see android.media.MediaRecorder.OutputFormat
  void setOutputFormat(int output_format) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOutputFormat,
      jni.JniType.voidType,
      [output_format]).check();

  static final _id_setVideoSize =
      jniAccessors.getMethodIDOf(_classRef, "setVideoSize", "(II)V");

  /// from: public native void setVideoSize(int width, int height)
  ///
  /// Sets the width and height of the video to be captured.  Must be called
  /// after setVideoSource(). Call this after setOutFormat() but before
  /// prepare().
  ///@param width the width of the video to be captured
  ///@param height the height of the video to be captured
  ///@throws IllegalStateException if it is called after
  /// prepare() or before setOutputFormat()
  void setVideoSize(int width, int height) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVideoSize,
      jni.JniType.voidType,
      [width, height]).check();

  static final _id_setVideoFrameRate =
      jniAccessors.getMethodIDOf(_classRef, "setVideoFrameRate", "(I)V");

  /// from: public native void setVideoFrameRate(int rate)
  ///
  /// Sets the frame rate of the video to be captured.  Must be called
  /// after setVideoSource(). Call this after setOutFormat() but before
  /// prepare().
  ///@param rate the number of frames per second of video to capture
  ///@throws IllegalStateException if it is called after
  /// prepare() or before setOutputFormat().
  ///
  /// NOTE: On some devices that have auto-frame rate, this sets the
  /// maximum frame rate, not a constant frame rate. Actual frame rate
  /// will vary according to lighting conditions.
  void setVideoFrameRate(int rate) => jniAccessors.callMethodWithArgs(
      reference, _id_setVideoFrameRate, jni.JniType.voidType, [rate]).check();

  static final _id_setMaxDuration =
      jniAccessors.getMethodIDOf(_classRef, "setMaxDuration", "(I)V");

  /// from: public native void setMaxDuration(int max_duration_ms)
  ///
  /// Sets the maximum duration (in ms) of the recording session.
  /// Call this after setOutFormat() but before prepare().
  /// After recording reaches the specified duration, a notification
  /// will be sent to the android.media.MediaRecorder.OnInfoListener
  /// with a "what" code of \#MEDIA_RECORDER_INFO_MAX_DURATION_REACHED
  /// and recording will be stopped. Stopping happens asynchronously, there
  /// is no guarantee that the recorder will have stopped by the time the
  /// listener is notified.
  ///@param max_duration_ms the maximum duration in ms (if zero or negative, disables the duration limit)
  void setMaxDuration(int max_duration_ms) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMaxDuration,
      jni.JniType.voidType,
      [max_duration_ms]).check();

  static final _id_setMaxFileSize =
      jniAccessors.getMethodIDOf(_classRef, "setMaxFileSize", "(J)V");

  /// from: public native void setMaxFileSize(long max_filesize_bytes)
  ///
  /// Sets the maximum filesize (in bytes) of the recording session.
  /// Call this after setOutFormat() but before prepare().
  /// After recording reaches the specified filesize, a notification
  /// will be sent to the android.media.MediaRecorder.OnInfoListener
  /// with a "what" code of \#MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED
  /// and recording will be stopped. Stopping happens asynchronously, there
  /// is no guarantee that the recorder will have stopped by the time the
  /// listener is notified.
  ///@param max_filesize_bytes the maximum filesize in bytes (if zero or negative, disables the limit)
  void setMaxFileSize(int max_filesize_bytes) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMaxFileSize,
          jni.JniType.voidType, [max_filesize_bytes]).check();

  static final _id_setAudioEncoder =
      jniAccessors.getMethodIDOf(_classRef, "setAudioEncoder", "(I)V");

  /// from: public native void setAudioEncoder(int audio_encoder)
  ///
  /// Sets the audio encoder to be used for recording. If this method is not
  /// called, the output file will not contain an audio track. Call this after
  /// setOutputFormat() but before prepare().
  ///@param audio_encoder the audio encoder to use.
  ///@throws IllegalStateException if it is called before
  /// setOutputFormat() or after prepare().
  ///@see android.media.MediaRecorder.AudioEncoder
  void setAudioEncoder(int audio_encoder) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAudioEncoder,
      jni.JniType.voidType,
      [audio_encoder]).check();

  static final _id_setVideoEncoder =
      jniAccessors.getMethodIDOf(_classRef, "setVideoEncoder", "(I)V");

  /// from: public native void setVideoEncoder(int video_encoder)
  ///
  /// Sets the video encoder to be used for recording. If this method is not
  /// called, the output file will not contain an video track. Call this after
  /// setOutputFormat() and before prepare().
  ///@param video_encoder the video encoder to use.
  ///@throws IllegalStateException if it is called before
  /// setOutputFormat() or after prepare()
  ///@see android.media.MediaRecorder.VideoEncoder
  void setVideoEncoder(int video_encoder) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVideoEncoder,
      jni.JniType.voidType,
      [video_encoder]).check();

  static final _id_setAudioSamplingRate =
      jniAccessors.getMethodIDOf(_classRef, "setAudioSamplingRate", "(I)V");

  /// from: public void setAudioSamplingRate(int samplingRate)
  ///
  /// Sets the audio sampling rate for recording. Call this method before prepare().
  /// Prepare() may perform additional checks on the parameter to make sure whether
  /// the specified audio sampling rate is applicable. The sampling rate really depends
  /// on the format for the audio recording, as well as the capabilities of the platform.
  /// For instance, the sampling rate supported by AAC audio coding standard ranges
  /// from 8 to 96 kHz, the sampling rate supported by AMRNB is 8kHz, and the sampling
  /// rate supported by AMRWB is 16kHz. Please consult with the related audio coding
  /// standard for the supported audio sampling rate.
  ///@param samplingRate the sampling rate for audio in samples per second.
  void setAudioSamplingRate(int samplingRate) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAudioSamplingRate,
          jni.JniType.voidType, [samplingRate]).check();

  static final _id_setAudioChannels =
      jniAccessors.getMethodIDOf(_classRef, "setAudioChannels", "(I)V");

  /// from: public void setAudioChannels(int numChannels)
  ///
  /// Sets the number of audio channels for recording. Call this method before prepare().
  /// Prepare() may perform additional checks on the parameter to make sure whether the
  /// specified number of audio channels are applicable.
  ///@param numChannels the number of audio channels. Usually it is either 1 (mono) or 2
  /// (stereo).
  void setAudioChannels(int numChannels) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAudioChannels,
      jni.JniType.voidType,
      [numChannels]).check();

  static final _id_setAudioEncodingBitRate =
      jniAccessors.getMethodIDOf(_classRef, "setAudioEncodingBitRate", "(I)V");

  /// from: public void setAudioEncodingBitRate(int bitRate)
  ///
  /// Sets the audio encoding bit rate for recording. Call this method before prepare().
  /// Prepare() may perform additional checks on the parameter to make sure whether the
  /// specified bit rate is applicable, and sometimes the passed bitRate will be clipped
  /// internally to ensure the audio recording can proceed smoothly based on the
  /// capabilities of the platform.
  ///@param bitRate the audio encoding bit rate in bits per second.
  void setAudioEncodingBitRate(int bitRate) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAudioEncodingBitRate,
      jni.JniType.voidType,
      [bitRate]).check();

  static final _id_setVideoEncodingBitRate =
      jniAccessors.getMethodIDOf(_classRef, "setVideoEncodingBitRate", "(I)V");

  /// from: public void setVideoEncodingBitRate(int bitRate)
  ///
  /// Sets the video encoding bit rate for recording. Call this method before prepare().
  /// Prepare() may perform additional checks on the parameter to make sure whether the
  /// specified bit rate is applicable, and sometimes the passed bitRate will be
  /// clipped internally to ensure the video recording can proceed smoothly based on
  /// the capabilities of the platform.
  ///@param bitRate the video encoding bit rate in bits per second.
  void setVideoEncodingBitRate(int bitRate) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVideoEncodingBitRate,
      jni.JniType.voidType,
      [bitRate]).check();

  static final _id_setVideoEncodingProfileLevel = jniAccessors.getMethodIDOf(
      _classRef, "setVideoEncodingProfileLevel", "(II)V");

  /// from: public void setVideoEncodingProfileLevel(int profile, int level)
  ///
  /// Sets the desired video encoding profile and level for recording. The profile and level
  /// must be valid for the video encoder set by \#setVideoEncoder. This method can
  /// called before or after \#setVideoEncoder but it must be called before \#prepare.
  /// {@code prepare()} may perform additional checks on the parameter to make sure that the specified
  /// profile and level are applicable, and sometimes the passed profile or level will be
  /// discarded due to codec capablity or to ensure the video recording can proceed smoothly
  /// based on the capabilities of the platform. <br>Application can also use the
  /// MediaCodecInfo.CodecCapabilities\#profileLevels to query applicable combination of profile
  /// and level for the corresponding format. Note that the requested profile/level may not be supported by
  /// the codec that is actually being used by this MediaRecorder instance.
  ///@param profile declared in MediaCodecInfo.CodecProfileLevel.
  ///@param level declared in MediaCodecInfo.CodecProfileLevel.
  ///@throws IllegalArgumentException when an invalid profile or level value is used.
  void setVideoEncodingProfileLevel(int profile, int level) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVideoEncodingProfileLevel,
          jni.JniType.voidType,
          [profile, level]).check();

  static final _id_setOutputFile = jniAccessors.getMethodIDOf(
      _classRef, "setOutputFile", "(Ljava/io/FileDescriptor;)V");

  /// from: public void setOutputFile(java.io.FileDescriptor fd)
  ///
  /// Pass in the file descriptor of the file to be written. Call this after
  /// setOutputFormat() but before prepare().
  ///@param fd an open file descriptor to be written into.
  ///@throws IllegalStateException if it is called before
  /// setOutputFormat() or after prepare()
  void setOutputFile(jni.JniObject fd) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOutputFile,
      jni.JniType.voidType,
      [fd.reference]).check();

  static final _id_setOutputFile1 = jniAccessors.getMethodIDOf(
      _classRef, "setOutputFile", "(Ljava/io/File;)V");

  /// from: public void setOutputFile(java.io.File file)
  ///
  /// Pass in the file object to be written. Call this after setOutputFormat() but before prepare().
  /// File should be seekable. After setting the next output file, application should not use the
  /// file until \#stop. Application is responsible for cleaning up unused files after
  /// \#stop is called.
  ///@param file the file object to be written into.
  void setOutputFile1(jni.JniObject file) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOutputFile1,
      jni.JniType.voidType,
      [file.reference]).check();

  static final _id_setNextOutputFile = jniAccessors.getMethodIDOf(
      _classRef, "setNextOutputFile", "(Ljava/io/FileDescriptor;)V");

  /// from: public void setNextOutputFile(java.io.FileDescriptor fd)
  ///
  /// Sets the next output file descriptor to be used when the maximum filesize is reached
  /// on the prior output \#setOutputFile or \#setNextOutputFile). File descriptor
  /// must be seekable and writable. After setting the next output file, application should not
  /// use the file referenced by this file descriptor until \#stop. It is the application's
  /// responsibility to close the file descriptor. It is safe to do so as soon as this call returns.
  /// Application must call this after receiving on the
  /// android.media.MediaRecorder.OnInfoListener a "what" code of
  /// \#MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING and before receiving a "what" code of
  /// \#MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED. The file is not used until switching to
  /// that output. Application will receive\#MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED
  /// when the next output file is used. Application will not be able to set a new output file if
  /// the previous one has not been used. Application is responsible for cleaning up unused files
  /// after \#stop is called.
  ///@param fd an open file descriptor to be written into.
  ///@throws IllegalStateException if it is called before prepare().
  ///@throws IOException if setNextOutputFile fails otherwise.
  void setNextOutputFile(jni.JniObject fd) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setNextOutputFile,
      jni.JniType.voidType,
      [fd.reference]).check();

  static final _id_setOutputFile2 = jniAccessors.getMethodIDOf(
      _classRef, "setOutputFile", "(Ljava/lang/String;)V");

  /// from: public void setOutputFile(java.lang.String path)
  ///
  /// Sets the path of the output file to be produced. Call this after
  /// setOutputFormat() but before prepare().
  ///@param path The pathname to use.
  ///@throws IllegalStateException if it is called before
  /// setOutputFormat() or after prepare()
  void setOutputFile2(jni.JniString path) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOutputFile2,
      jni.JniType.voidType,
      [path.reference]).check();

  static final _id_setNextOutputFile1 = jniAccessors.getMethodIDOf(
      _classRef, "setNextOutputFile", "(Ljava/io/File;)V");

  /// from: public void setNextOutputFile(java.io.File file)
  ///
  /// Sets the next output file to be used when the maximum filesize is reached on the prior
  /// output \#setOutputFile or \#setNextOutputFile). File should be seekable.
  /// After setting the next output file, application should not use the file until \#stop.
  /// Application must call this after receiving on the
  /// android.media.MediaRecorder.OnInfoListener a "what" code of
  /// \#MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING and before receiving a "what" code of
  /// \#MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED. The file is not used until switching to
  /// that output. Application will receive \#MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED
  /// when the next output file is used. Application will not be able to set a new output file if
  /// the previous one has not been used. Application is responsible for cleaning up unused files
  /// after \#stop is called.
  ///@param file The file to use.
  ///@throws IllegalStateException if it is called before prepare().
  ///@throws IOException if setNextOutputFile fails otherwise.
  void setNextOutputFile1(jni.JniObject file) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNextOutputFile1,
          jni.JniType.voidType, [file.reference]).check();

  static final _id_prepare =
      jniAccessors.getMethodIDOf(_classRef, "prepare", "()V");

  /// from: public void prepare()
  ///
  /// Prepares the recorder to begin capturing and encoding data. This method
  /// must be called after setting up the desired audio and video sources,
  /// encoders, file format, etc., but before start().
  ///@throws IllegalStateException if it is called after
  /// start() or before setOutputFormat().
  ///@throws IOException if prepare fails otherwise.
  void prepare() => jniAccessors.callMethodWithArgs(
      reference, _id_prepare, jni.JniType.voidType, []).check();

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "()V");

  /// from: public native void start()
  ///
  /// Begins capturing and encoding data to the file specified with
  /// setOutputFile(). Call this after prepare().
  ///
  /// Since API level 13, if applications set a camera via
  /// \#setCamera(Camera), the apps can use the camera after this method
  /// call. The apps do not need to lock the camera again. However, if this
  /// method fails, the apps should still lock the camera back. The apps should
  /// not start another recording session during recording.
  ///@throws IllegalStateException if it is called before
  /// prepare() or when the camera is already in use by another app.
  void start() => jniAccessors.callMethodWithArgs(
      reference, _id_start, jni.JniType.voidType, []).check();

  static final _id_stop = jniAccessors.getMethodIDOf(_classRef, "stop", "()V");

  /// from: public native void stop()
  ///
  /// Stops recording. Call this after start(). Once recording is stopped,
  /// you will have to configure it again as if it has just been constructed.
  /// Note that a RuntimeException is intentionally thrown to the
  /// application, if no valid audio/video data has been received when stop()
  /// is called. This happens if stop() is called immediately after
  /// start(). The failure lets the application take action accordingly to
  /// clean up the output file (delete the output file, for instance), since
  /// the output file is not properly constructed when this happens.
  ///@throws IllegalStateException if it is called before start()
  void stop() => jniAccessors.callMethodWithArgs(
      reference, _id_stop, jni.JniType.voidType, []).check();

  static final _id_pause =
      jniAccessors.getMethodIDOf(_classRef, "pause", "()V");

  /// from: public native void pause()
  ///
  /// Pauses recording. Call this after start(). You may resume recording
  /// with resume() without reconfiguration, as opposed to stop(). It does
  /// nothing if the recording is already paused.
  ///
  /// When the recording is paused and resumed, the resulting output would
  /// be as if nothing happend during paused period, immediately switching
  /// to the resumed scene.
  ///@throws IllegalStateException if it is called before start() or after
  /// stop()
  void pause() => jniAccessors.callMethodWithArgs(
      reference, _id_pause, jni.JniType.voidType, []).check();

  static final _id_resume =
      jniAccessors.getMethodIDOf(_classRef, "resume", "()V");

  /// from: public native void resume()
  ///
  /// Resumes recording. Call this after start(). It does nothing if the
  /// recording is not paused.
  ///@throws IllegalStateException if it is called before start() or after
  /// stop()
  ///@see android.media.MediaRecorder\#pause
  void resume() => jniAccessors.callMethodWithArgs(
      reference, _id_resume, jni.JniType.voidType, []).check();

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Restarts the MediaRecorder to its idle state. After calling
  /// this method, you will have to configure it again as if it had just been
  /// constructed.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_getMaxAmplitude =
      jniAccessors.getMethodIDOf(_classRef, "getMaxAmplitude", "()I");

  /// from: public native int getMaxAmplitude()
  ///
  /// Returns the maximum absolute amplitude that was sampled since the last
  /// call to this method. Call this only after the setAudioSource().
  ///@return the maximum absolute amplitude measured since the last call, or
  /// 0 when called for the first time
  ///@throws IllegalStateException if it is called before
  /// the audio source has been set.
  int getMaxAmplitude() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxAmplitude, jni.JniType.intType, []).integer;

  static final _id_setOnErrorListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnErrorListener",
      "(Landroid/media/MediaRecorder\$OnErrorListener;)V");

  /// from: public void setOnErrorListener(android.media.MediaRecorder.OnErrorListener l)
  ///
  /// Register a callback to be invoked when an error occurs while
  /// recording.
  ///@param l the callback that will be run
  void setOnErrorListener(MediaRecorder_OnErrorListener l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnErrorListener,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_setOnInfoListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnInfoListener", "(Landroid/media/MediaRecorder\$OnInfoListener;)V");

  /// from: public void setOnInfoListener(android.media.MediaRecorder.OnInfoListener listener)
  ///
  /// Register a callback to be invoked when an informational event occurs while
  /// recording.
  ///@param listener the callback that will be run
  void setOnInfoListener(MediaRecorder_OnInfoListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnInfoListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setPreferredDevice = jniAccessors.getMethodIDOf(
      _classRef, "setPreferredDevice", "(Landroid/media/AudioDeviceInfo;)Z");

  /// from: public boolean setPreferredDevice(android.media.AudioDeviceInfo deviceInfo)
  ///
  /// Specifies an audio device (via an AudioDeviceInfo object) to route
  /// the input from this MediaRecorder.
  ///@param deviceInfo The AudioDeviceInfo specifying the audio source.
  ///  If deviceInfo is null, default routing is restored.
  ///@return true if succesful, false if the specified AudioDeviceInfo is non-null and
  /// does not correspond to a valid audio input device.
  bool setPreferredDevice(audiodeviceinfo_.AudioDeviceInfo deviceInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreferredDevice,
          jni.JniType.booleanType, [deviceInfo.reference]).boolean;

  static final _id_getPreferredDevice = jniAccessors.getMethodIDOf(
      _classRef, "getPreferredDevice", "()Landroid/media/AudioDeviceInfo;");

  /// from: public android.media.AudioDeviceInfo getPreferredDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the selected input device specified by \#setPreferredDevice. Note that this
  /// is not guaranteed to correspond to the actual device being used for recording.
  audiodeviceinfo_.AudioDeviceInfo getPreferredDevice() =>
      audiodeviceinfo_.AudioDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPreferredDevice,
          jni.JniType.objectType, []).object);

  static final _id_getRoutedDevice = jniAccessors.getMethodIDOf(
      _classRef, "getRoutedDevice", "()Landroid/media/AudioDeviceInfo;");

  /// from: public android.media.AudioDeviceInfo getRoutedDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an AudioDeviceInfo identifying the current routing of this MediaRecorder
  /// Note: The query is only valid if the MediaRecorder is currently recording.
  /// If the recorder is not recording, the returned device can be null or correspond to previously
  /// selected device when the recorder was last active.
  audiodeviceinfo_.AudioDeviceInfo getRoutedDevice() =>
      audiodeviceinfo_.AudioDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRoutedDevice, jni.JniType.objectType, []).object);

  static final _id_addOnRoutingChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnRoutingChangedListener",
      "(Landroid/media/AudioRouting\$OnRoutingChangedListener;Landroid/os/Handler;)V");

  /// from: public void addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener listener, android.os.Handler handler)
  ///
  /// Adds an AudioRouting.OnRoutingChangedListener to receive notifications of routing
  /// changes on this MediaRecorder.
  ///@param listener The AudioRouting.OnRoutingChangedListener interface to receive
  /// notifications of rerouting events.
  ///@param handler Specifies the Handler object for the thread on which to execute
  /// the callback. If <code>null</code>, the handler on the main looper will be used.
  void addOnRoutingChangedListener(
          audiorouting_.AudioRouting_OnRoutingChangedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnRoutingChangedListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeOnRoutingChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnRoutingChangedListener",
      "(Landroid/media/AudioRouting\$OnRoutingChangedListener;)V");

  /// from: public void removeOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener listener)
  ///
  /// Removes an AudioRouting.OnRoutingChangedListener which has been previously added
  /// to receive rerouting notifications.
  ///@param listener The previously added AudioRouting.OnRoutingChangedListener interface
  /// to remove.
  void removeOnRoutingChangedListener(
          audiorouting_.AudioRouting_OnRoutingChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnRoutingChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_getActiveMicrophones = jniAccessors.getMethodIDOf(
      _classRef, "getActiveMicrophones", "()Ljava/util/List;");

  /// from: public java.util.List<android.media.MicrophoneInfo> getActiveMicrophones()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return A lists of MicrophoneInfo representing the active microphones.
  /// By querying channel mapping for each active microphone, developer can know how
  /// the microphone is used by each channels or a capture stream.
  ///@return a lists of MicrophoneInfo representing the active microphones
  ///@throws IOException if an error occurs
  jni.JniObject getActiveMicrophones() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getActiveMicrophones, jni.JniType.objectType, []).object);

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public native void release()
  ///
  /// Releases resources associated with this MediaRecorder object.
  /// It is good practice to call this method when you're done
  /// using the MediaRecorder. In particular, whenever an Activity
  /// of an application is paused (its onPause() method is called),
  /// or stopped (its onStop() method is called), this method should be
  /// invoked to release the MediaRecorder object, unless the application
  /// has a special need to keep the object around. In addition to
  /// unnecessary resources (such as memory and instances of codecs)
  /// being held, failure to call this method immediately if a
  /// MediaRecorder object is no longer needed may also lead to
  /// continuous battery consumption for mobile devices, and recording
  /// failure for other applications if no multiple instances of the
  /// same codec are supported on a device. Even if multiple instances
  /// of the same codec are supported, some performance degradation
  /// may be expected when unnecessary multiple instances are used
  /// at the same time.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_getMetrics = jniAccessors.getMethodIDOf(
      _classRef, "getMetrics", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getMetrics()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return Metrics data about the current Mediarecorder instance.
  ///@return a PersistableBundle containing the set of attributes and values
  /// available for the media being generated by this instance of
  /// MediaRecorder.
  /// The attributes are descibed in MetricsConstants.
  ///
  ///  Additional vendor-specific fields may also be present in
  ///  the return value.
  persistablebundle_.PersistableBundle getMetrics() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getMetrics, jni.JniType.objectType, []).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.media.MediaRecorder$VideoSource
///
/// Defines the video source. These constants are used with
/// MediaRecorder\#setVideoSource(int).
class MediaRecorder_VideoSource extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder\$VideoSource");
  MediaRecorder_VideoSource.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CAMERA
  ///
  /// Camera video source
  ///
  /// Using the android.hardware.Camera API as video source.
  ///
  ///
  static const CAMERA = 1;

  /// from: static public final int DEFAULT
  static const DEFAULT = 0;

  /// from: static public final int SURFACE
  ///
  /// Surface video source
  ///
  /// Using a Surface as video source.
  ///
  ///
  /// This flag must be used when recording from an
  /// android.hardware.camera2 API source.
  ///
  ///
  /// When using this video source type, use MediaRecorder\#getSurface()
  /// to retrieve the surface created by MediaRecorder.
  static const SURFACE = 2;
}

/// from: android.media.MediaRecorder$VideoEncoder
///
/// Defines the video encoding. These constants are used with
/// MediaRecorder\#setVideoEncoder(int).
class MediaRecorder_VideoEncoder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder\$VideoEncoder");
  MediaRecorder_VideoEncoder.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DEFAULT
  static const DEFAULT = 0;

  /// from: static public final int H263
  static const H263 = 1;

  /// from: static public final int H264
  static const H264 = 2;

  /// from: static public final int HEVC
  static const HEVC = 5;

  /// from: static public final int MPEG_4_SP
  static const MPEG_4_SP = 3;

  /// from: static public final int VP8
  static const VP8 = 4;
}

/// from: android.media.MediaRecorder$OutputFormat
///
/// Defines the output format. These constants are used with
/// MediaRecorder\#setOutputFormat(int).
class MediaRecorder_OutputFormat extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder\$OutputFormat");
  MediaRecorder_OutputFormat.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AAC_ADTS
  ///
  /// AAC ADTS file format
  static const AAC_ADTS = 6;

  /// from: static public final int AMR_NB
  ///
  /// AMR NB file format
  static const AMR_NB = 3;

  /// from: static public final int AMR_WB
  ///
  /// AMR WB file format
  static const AMR_WB = 4;

  /// from: static public final int DEFAULT
  static const DEFAULT = 0;

  /// from: static public final int MPEG_2_TS
  ///
  /// H.264/AAC data encapsulated in MPEG2/TS
  static const MPEG_2_TS = 8;

  /// from: static public final int MPEG_4
  ///
  /// MPEG4 media file format
  static const MPEG_4 = 2;

  /// from: static public final int RAW_AMR
  ///
  /// AMR NB file format
  ///@deprecated Deprecated in favor of MediaRecorder.OutputFormat.AMR_NB
  static const RAW_AMR = 3;

  /// from: static public final int THREE_GPP
  ///
  /// 3GPP media file format
  static const THREE_GPP = 1;

  /// from: static public final int WEBM
  ///
  /// VP8/VORBIS data in a WEBM container
  static const WEBM = 9;
}

/// from: android.media.MediaRecorder$OnInfoListener
///
/// Interface definition of a callback to be invoked to communicate some
/// info and/or warning about the recording.
class MediaRecorder_OnInfoListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder\$OnInfoListener");
  MediaRecorder_OnInfoListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onInfo = jniAccessors.getMethodIDOf(
      _classRef, "onInfo", "(Landroid/media/MediaRecorder;II)V");

  /// from: public abstract void onInfo(android.media.MediaRecorder mr, int what, int extra)
  ///
  /// Called to indicate an info or a warning during recording.
  ///@param mr the MediaRecorder the info pertains to
  ///@param what the type of info or warning that has occurred
  /// <ul>
  /// <li>\#MEDIA_RECORDER_INFO_UNKNOWN
  /// <li>\#MEDIA_RECORDER_INFO_MAX_DURATION_REACHED
  /// <li>\#MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED
  /// </ul>
  ///@param extra an extra code, specific to the info type
  void onInfo(MediaRecorder mr, int what, int extra) =>
      jniAccessors.callMethodWithArgs(reference, _id_onInfo,
          jni.JniType.voidType, [mr.reference, what, extra]).check();
}

/// from: android.media.MediaRecorder$OnErrorListener
///
/// Interface definition for a callback to be invoked when an error
/// occurs while recording.
class MediaRecorder_OnErrorListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder\$OnErrorListener");
  MediaRecorder_OnErrorListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onError = jniAccessors.getMethodIDOf(
      _classRef, "onError", "(Landroid/media/MediaRecorder;II)V");

  /// from: public abstract void onError(android.media.MediaRecorder mr, int what, int extra)
  ///
  /// Called when an error occurs while recording.
  ///@param mr the MediaRecorder that encountered the error
  ///@param what the type of error that has occurred:
  /// <ul>
  /// <li>\#MEDIA_RECORDER_ERROR_UNKNOWN
  /// <li>\#MEDIA_ERROR_SERVER_DIED
  /// </ul>
  ///@param extra an extra code, specific to the error type
  void onError(MediaRecorder mr, int what, int extra) =>
      jniAccessors.callMethodWithArgs(reference, _id_onError,
          jni.JniType.voidType, [mr.reference, what, extra]).check();
}

/// from: android.media.MediaRecorder$MetricsConstants
class MediaRecorder_MetricsConstants extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder\$MetricsConstants");
  MediaRecorder_MetricsConstants.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String AUDIO_BITRATE
  ///
  /// Key to extract the audio bitrate
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const AUDIO_BITRATE = "android.media.mediarecorder.audio-bitrate";

  /// from: static public final java.lang.String AUDIO_CHANNELS
  ///
  /// Key to extract the number of audio channels
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const AUDIO_CHANNELS = "android.media.mediarecorder.audio-channels";

  /// from: static public final java.lang.String AUDIO_SAMPLERATE
  ///
  /// Key to extract the audio samplerate
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const AUDIO_SAMPLERATE =
      "android.media.mediarecorder.audio-samplerate";

  /// from: static public final java.lang.String AUDIO_TIMESCALE
  ///
  /// Key to extract the audio timescale
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const AUDIO_TIMESCALE = "android.media.mediarecorder.audio-timescale";

  /// from: static public final java.lang.String CAPTURE_FPS
  ///
  /// Key to extract the video capture frame rate
  /// from the MediaRecorder\#getMetrics return.
  /// The value is a double.
  static const CAPTURE_FPS = "android.media.mediarecorder.capture-fps";

  /// from: static public final java.lang.String CAPTURE_FPS_ENABLE
  ///
  /// Key to extract the video capture framerate enable value
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const CAPTURE_FPS_ENABLE =
      "android.media.mediarecorder.capture-fpsenable";

  /// from: static public final java.lang.String FRAMERATE
  ///
  /// Key to extract the intended playback frame rate
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const FRAMERATE = "android.media.mediarecorder.frame-rate";

  /// from: static public final java.lang.String HEIGHT
  ///
  /// Key to extract the height (in pixels) of the captured video
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const HEIGHT = "android.media.mediarecorder.height";

  /// from: static public final java.lang.String MOVIE_TIMESCALE
  ///
  /// Key to extract the recorded movies time units
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  /// A value of 1000 indicates that the movie's timing is in milliseconds.
  static const MOVIE_TIMESCALE = "android.media.mediarecorder.movie-timescale";

  /// from: static public final java.lang.String ROTATION
  ///
  /// Key to extract the rotation (in degrees) to properly orient the video
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const ROTATION = "android.media.mediarecorder.rotation";

  /// from: static public final java.lang.String VIDEO_BITRATE
  ///
  /// Key to extract the video bitrate from being used
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const VIDEO_BITRATE = "android.media.mediarecorder.video-bitrate";

  /// from: static public final java.lang.String VIDEO_IFRAME_INTERVAL
  ///
  /// Key to extract the value for how often video iframes are generated
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const VIDEO_IFRAME_INTERVAL =
      "android.media.mediarecorder.video-iframe-interval";

  /// from: static public final java.lang.String VIDEO_LEVEL
  ///
  /// Key to extract the video encoding level
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const VIDEO_LEVEL = "android.media.mediarecorder.video-encoder-level";

  /// from: static public final java.lang.String VIDEO_PROFILE
  ///
  /// Key to extract the video encoding profile
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const VIDEO_PROFILE =
      "android.media.mediarecorder.video-encoder-profile";

  /// from: static public final java.lang.String VIDEO_TIMESCALE
  ///
  /// Key to extract the recorded video time units
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  /// A value of 1000 indicates that the video's timing is in milliseconds.
  static const VIDEO_TIMESCALE = "android.media.mediarecorder.video-timescale";

  /// from: static public final java.lang.String WIDTH
  ///
  /// Key to extract the width (in pixels) of the captured video
  /// from the MediaRecorder\#getMetrics return.
  /// The value is an integer.
  static const WIDTH = "android.media.mediarecorder.width";
}

/// from: android.media.MediaRecorder$AudioSource
///
/// Defines the audio source.
/// An audio source defines both a default physical source of audio signal, and a recording
/// configuration. These constants are for instance used
/// in MediaRecorder\#setAudioSource(int) or
/// AudioRecord.Builder\#setAudioSource(int).
class MediaRecorder_AudioSource extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder\$AudioSource");
  MediaRecorder_AudioSource.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CAMCORDER
  ///
  /// Microphone audio source tuned for video recording, with the same orientation
  ///  as the camera if available.
  static const CAMCORDER = 5;

  /// from: static public final int DEFAULT
  ///
  /// Default audio source
  static const DEFAULT = 0;

  /// from: static public final int MIC
  ///
  /// Microphone audio source
  static const MIC = 1;

  /// from: static public final int REMOTE_SUBMIX
  ///
  /// Audio source for a submix of audio streams to be presented remotely.
  ///
  /// An application can use this audio source to capture a mix of audio streams
  /// that should be transmitted to a remote receiver such as a Wifi display.
  /// While recording is active, these audio streams are redirected to the remote
  /// submix instead of being played on the device speaker or headset.
  ///
  ///
  /// Certain streams are excluded from the remote submix, including
  /// AudioManager\#STREAM_RING, AudioManager\#STREAM_ALARM,
  /// and AudioManager\#STREAM_NOTIFICATION.  These streams will continue
  /// to be presented locally as usual.
  ///
  ///
  /// Capturing the remote submix audio requires the
  /// android.Manifest.permission\#CAPTURE_AUDIO_OUTPUT permission.
  /// This permission is reserved for use by system components and is not available to
  /// third-party applications.
  ///
  ///
  ///
  /// Requires android.Manifest.permission\#CAPTURE_AUDIO_OUTPUT
  static const REMOTE_SUBMIX = 8;

  /// from: static public final int UNPROCESSED
  ///
  /// Microphone audio source tuned for unprocessed (raw) sound if available, behaves like
  ///  \#DEFAULT otherwise.
  static const UNPROCESSED = 9;

  /// from: static public final int VOICE_CALL
  ///
  /// Voice call uplink + downlink audio source
  ///
  /// Capturing from <code>VOICE_CALL</code> source requires the
  /// android.Manifest.permission\#CAPTURE_AUDIO_OUTPUT permission.
  /// This permission is reserved for use by system components and is not available to
  /// third-party applications.
  ///
  ///
  static const VOICE_CALL = 4;

  /// from: static public final int VOICE_COMMUNICATION
  ///
  /// Microphone audio source tuned for voice communications such as VoIP. It
  ///  will for instance take advantage of echo cancellation or automatic gain control
  ///  if available.
  static const VOICE_COMMUNICATION = 7;

  /// from: static public final int VOICE_DOWNLINK
  ///
  /// Voice call downlink (Rx) audio source.
  ///
  /// Capturing from <code>VOICE_DOWNLINK</code> source requires the
  /// android.Manifest.permission\#CAPTURE_AUDIO_OUTPUT permission.
  /// This permission is reserved for use by system components and is not available to
  /// third-party applications.
  ///
  ///
  static const VOICE_DOWNLINK = 3;

  /// from: static public final int VOICE_RECOGNITION
  ///
  /// Microphone audio source tuned for voice recognition.
  static const VOICE_RECOGNITION = 6;

  /// from: static public final int VOICE_UPLINK
  ///
  /// Voice call uplink (Tx) audio source.
  ///
  /// Capturing from <code>VOICE_UPLINK</code> source requires the
  /// android.Manifest.permission\#CAPTURE_AUDIO_OUTPUT permission.
  /// This permission is reserved for use by system components and is not available to
  /// third-party applications.
  ///
  ///
  static const VOICE_UPLINK = 2;
}

/// from: android.media.MediaRecorder$AudioEncoder
///
/// Defines the audio encoding. These constants are used with
/// MediaRecorder\#setAudioEncoder(int).
class MediaRecorder_AudioEncoder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaRecorder\$AudioEncoder");
  MediaRecorder_AudioEncoder.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AAC
  ///
  /// AAC Low Complexity (AAC-LC) audio codec
  static const AAC = 3;

  /// from: static public final int AAC_ELD
  ///
  /// Enhanced Low Delay AAC (AAC-ELD) audio codec
  static const AAC_ELD = 5;

  /// from: static public final int AMR_NB
  ///
  /// AMR (Narrowband) audio codec
  static const AMR_NB = 1;

  /// from: static public final int AMR_WB
  ///
  /// AMR (Wideband) audio codec
  static const AMR_WB = 2;

  /// from: static public final int DEFAULT
  static const DEFAULT = 0;

  /// from: static public final int HE_AAC
  ///
  /// High Efficiency AAC (HE-AAC) audio codec
  static const HE_AAC = 4;

  /// from: static public final int VORBIS
  ///
  /// Ogg Vorbis audio codec
  static const VORBIS = 6;
}
