// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.AudioAttributes
///
/// A class to encapsulate a collection of attributes describing information about an audio
/// stream.
/// <code>AudioAttributes</code> supersede the notion of stream types (see for instance
/// AudioManager\#STREAM_MUSIC or AudioManager\#STREAM_ALARM) for defining the
/// behavior of audio playback. Attributes allow an application to specify more information than is
/// conveyed in a stream type by allowing the application to define:
/// <ul>
/// <li>usage: "why" you are playing a sound, what is this sound used for. This is achieved with
///     the "usage" information. Examples of usage are \#USAGE_MEDIA and \#USAGE_ALARM.
///     These two examples are the closest to stream types, but more detailed use cases are
///     available. Usage information is more expressive than a stream type, and allows certain
///     platforms or routing policies to use this information for more refined volume or routing
///     decisions. Usage is the most important information to supply in <code>AudioAttributes</code>
///     and it is recommended to build any instance with this information supplied, see
///     AudioAttributes.Builder for exceptions.</li>
/// <li>content type: "what" you are playing. The content type expresses the general category of
///     the content. This information is optional. But in case it is known (for instance
///     \#CONTENT_TYPE_MOVIE for a movie streaming service or \#CONTENT_TYPE_MUSIC for
///     a music playback application) this information might be used by the audio framework to
///     selectively configure some audio post-processing blocks.</li>
/// <li>flags: "how" is playback to be affected, see the flag definitions for the specific playback
///     behaviors they control. </li>
/// </ul>
/// <code>AudioAttributes</code> are used for example in one of the AudioTrack
/// constructors (see AudioTrack\#AudioTrack(AudioAttributes, AudioFormat, int, int, int)),
/// to configure a MediaPlayer
/// (see MediaPlayer\#setAudioAttributes(AudioAttributes) or a
/// android.app.Notification (see android.app.Notification\#audioAttributes). An
/// <code>AudioAttributes</code> instance is built through its builder,
/// AudioAttributes.Builder.
class AudioAttributes extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/AudioAttributes");
  AudioAttributes.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CONTENT_TYPE_MOVIE
  ///
  /// Content type value to use when the content type is a soundtrack, typically accompanying
  /// a movie or TV program.
  static const CONTENT_TYPE_MOVIE = 3;

  /// from: static public final int CONTENT_TYPE_MUSIC
  ///
  /// Content type value to use when the content type is music.
  static const CONTENT_TYPE_MUSIC = 2;

  /// from: static public final int CONTENT_TYPE_SONIFICATION
  ///
  /// Content type value to use when the content type is a sound used to accompany a user
  /// action, such as a beep or sound effect expressing a key click, or event, such as the
  /// type of a sound for a bonus being received in a game. These sounds are mostly synthesized
  /// or short Foley sounds.
  static const CONTENT_TYPE_SONIFICATION = 4;

  /// from: static public final int CONTENT_TYPE_SPEECH
  ///
  /// Content type value to use when the content type is speech.
  static const CONTENT_TYPE_SPEECH = 1;

  /// from: static public final int CONTENT_TYPE_UNKNOWN
  ///
  /// Content type value to use when the content type is unknown, or other than the ones defined.
  static const CONTENT_TYPE_UNKNOWN = 0;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.media.AudioAttributes> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int FLAG_AUDIBILITY_ENFORCED
  ///
  /// Flag defining a behavior where the audibility of the sound will be ensured by the system.
  static const FLAG_AUDIBILITY_ENFORCED = 1;

  /// from: static public final int FLAG_HW_AV_SYNC
  ///
  /// Flag requesting the use of an output stream supporting hardware A/V synchronization.
  static const FLAG_HW_AV_SYNC = 16;

  /// from: static public final int FLAG_LOW_LATENCY
  ///
  /// Flag requesting a low latency path when creating an AudioTrack.
  /// When using this flag, the sample rate must match the native sample rate
  /// of the device. Effects processing is also unavailable.
  ///
  /// Note that if this flag is used without specifying a bufferSizeInBytes then the
  /// AudioTrack's actual buffer size may be too small. It is recommended that a fairly
  /// large buffer should be specified when the AudioTrack is created.
  /// Then the actual size can be reduced by calling
  /// AudioTrack\#setBufferSizeInFrames(int). The buffer size can be optimized
  /// by lowering it after each write() call until the audio glitches, which is detected by calling
  /// AudioTrack\#getUnderrunCount(). Then the buffer size can be increased
  /// until there are no glitches.
  /// This tuning step should be done while playing silence.
  /// This technique provides a compromise between latency and glitch rate.
  ///@deprecated Use AudioTrack.Builder\#setPerformanceMode(int) with
  /// AudioTrack\#PERFORMANCE_MODE_LOW_LATENCY to control performance.
  static const FLAG_LOW_LATENCY = 256;

  /// from: static public final int USAGE_ALARM
  ///
  /// Usage value to use when the usage is an alarm (e.g.&nbsp;wake-up alarm).
  static const USAGE_ALARM = 4;

  /// from: static public final int USAGE_ASSISTANCE_ACCESSIBILITY
  ///
  /// Usage value to use when the usage is for accessibility, such as with
  /// a screen reader.
  static const USAGE_ASSISTANCE_ACCESSIBILITY = 11;

  /// from: static public final int USAGE_ASSISTANCE_NAVIGATION_GUIDANCE
  ///
  /// Usage value to use when the usage is driving or navigation directions.
  static const USAGE_ASSISTANCE_NAVIGATION_GUIDANCE = 12;

  /// from: static public final int USAGE_ASSISTANCE_SONIFICATION
  ///
  /// Usage value to use when the usage is sonification, such as  with user
  /// interface sounds.
  static const USAGE_ASSISTANCE_SONIFICATION = 13;

  /// from: static public final int USAGE_ASSISTANT
  ///
  /// Usage value to use for audio responses to user queries, audio instructions or help
  /// utterances.
  static const USAGE_ASSISTANT = 16;

  /// from: static public final int USAGE_GAME
  ///
  /// Usage value to use when the usage is for game audio.
  static const USAGE_GAME = 14;

  /// from: static public final int USAGE_MEDIA
  ///
  /// Usage value to use when the usage is media, such as music, or movie
  /// soundtracks.
  static const USAGE_MEDIA = 1;

  /// from: static public final int USAGE_NOTIFICATION
  ///
  /// Usage value to use when the usage is notification. See other
  /// notification usages for more specialized uses.
  static const USAGE_NOTIFICATION = 5;

  /// from: static public final int USAGE_NOTIFICATION_COMMUNICATION_DELAYED
  ///
  /// Usage value to use when the usage is notification for a
  /// non-immediate type of communication such as e-mail.
  static const USAGE_NOTIFICATION_COMMUNICATION_DELAYED = 9;

  /// from: static public final int USAGE_NOTIFICATION_COMMUNICATION_INSTANT
  ///
  /// Usage value to use when the usage is notification for an "instant"
  /// communication such as a chat, or SMS.
  static const USAGE_NOTIFICATION_COMMUNICATION_INSTANT = 8;

  /// from: static public final int USAGE_NOTIFICATION_COMMUNICATION_REQUEST
  ///
  /// Usage value to use when the usage is a request to enter/end a
  /// communication, such as a VoIP communication or video-conference.
  static const USAGE_NOTIFICATION_COMMUNICATION_REQUEST = 7;

  /// from: static public final int USAGE_NOTIFICATION_EVENT
  ///
  /// Usage value to use when the usage is to attract the user's attention,
  /// such as a reminder or low battery warning.
  static const USAGE_NOTIFICATION_EVENT = 10;

  /// from: static public final int USAGE_NOTIFICATION_RINGTONE
  ///
  /// Usage value to use when the usage is telephony ringtone.
  static const USAGE_NOTIFICATION_RINGTONE = 6;

  /// from: static public final int USAGE_UNKNOWN
  ///
  /// Usage value to use when the usage is unknown.
  static const USAGE_UNKNOWN = 0;

  /// from: static public final int USAGE_VOICE_COMMUNICATION
  ///
  /// Usage value to use when the usage is voice communications, such as telephony
  /// or VoIP.
  static const USAGE_VOICE_COMMUNICATION = 2;

  /// from: static public final int USAGE_VOICE_COMMUNICATION_SIGNALLING
  ///
  /// Usage value to use when the usage is in-call signalling, such as with
  /// a "busy" beep, or DTMF tones.
  static const USAGE_VOICE_COMMUNICATION_SIGNALLING = 3;

  static final _id_getContentType =
      jniAccessors.getMethodIDOf(_classRef, "getContentType", "()I");

  /// from: public int getContentType()
  ///
  /// Return the content type.
  ///@return one of the values that can be set in Builder\#setContentType(int)
  int getContentType() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentType, jni.JniType.intType, []).integer;

  static final _id_getUsage =
      jniAccessors.getMethodIDOf(_classRef, "getUsage", "()I");

  /// from: public int getUsage()
  ///
  /// Return the usage.
  ///@return one of the values that can be set in Builder\#setUsage(int)
  int getUsage() => jniAccessors.callMethodWithArgs(
      reference, _id_getUsage, jni.JniType.intType, []).integer;

  static final _id_getFlags =
      jniAccessors.getMethodIDOf(_classRef, "getFlags", "()I");

  /// from: public int getFlags()
  ///
  /// Return the flags.
  ///@return a combined mask of all flags
  int getFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getFlags, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_getVolumeControlStream =
      jniAccessors.getMethodIDOf(_classRef, "getVolumeControlStream", "()I");

  /// from: public int getVolumeControlStream()
  ///
  /// Returns the stream type matching this {@code AudioAttributes} instance for volume control.
  /// Use this method to derive the stream type needed to configure the volume
  /// control slider in an android.app.Activity with
  /// android.app.Activity\#setVolumeControlStream(int) for playback conducted with these
  /// attributes.
  /// <BR>Do not use this method to set the stream type on an audio player object
  /// (e.g. AudioTrack, MediaPlayer) as this is deprecated,
  /// use {@code AudioAttributes} instead.
  ///@return a valid stream type for {@code Activity} or stream volume control that matches
  ///     the attributes, or AudioManager\#USE_DEFAULT_STREAM_TYPE if there isn't a direct
  ///     match. Note that {@code USE_DEFAULT_STREAM_TYPE} is not a valid value
  ///     for AudioManager\#setStreamVolume(int, int, int).
  int getVolumeControlStream() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolumeControlStream, jni.JniType.intType, []).integer;
}

/// from: android.media.AudioAttributes$Builder
///
/// Builder class for AudioAttributes objects.
///  Here is an example where <code>Builder</code> is used to define the
/// AudioAttributes to be used by a new <code>AudioTrack</code> instance:
///
/// <pre class="prettyprint">
/// AudioTrack myTrack = new AudioTrack(
///         new AudioAttributes.Builder()
///             .setUsage(AudioAttributes.USAGE_MEDIA)
///             .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
///             .build(),
///         myFormat, myBuffSize, AudioTrack.MODE_STREAM, mySession);
/// </pre>
///
/// By default all types of information (usage, content type, flags) conveyed by an
/// <code>AudioAttributes</code> instance are set to "unknown". Unknown information will be
/// interpreted as a default value that is dependent on the context of use, for instance a
/// MediaPlayer will use a default usage of AudioAttributes\#USAGE_MEDIA.
class AudioAttributes_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/AudioAttributes\$Builder");
  AudioAttributes_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new Builder with the defaults.
  /// By default, usage and content type are respectively AudioAttributes\#USAGE_UNKNOWN
  /// and AudioAttributes\#CONTENT_TYPE_UNKNOWN, and flags are 0. It is recommended to
  /// configure the usage (with \#setUsage(int)) or deriving attributes from a legacy
  /// stream type (with \#setLegacyStreamType(int)) before calling \#build()
  /// to override any default playback behavior in terms of routing and volume management.
  AudioAttributes_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/media/AudioAttributes;)V");

  /// from: public void <init>(android.media.AudioAttributes aa)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new Builder from a given AudioAttributes
  ///@param aa the AudioAttributes object whose data will be reused in the new Builder.
  AudioAttributes_Builder.ctor1(AudioAttributes aa)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [aa.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/media/AudioAttributes;");

  /// from: public android.media.AudioAttributes build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Combines all of the attributes that have been set and return a new
  /// AudioAttributes object.
  ///@return a new AudioAttributes object
  AudioAttributes build() =>
      AudioAttributes.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);

  static final _id_setUsage = jniAccessors.getMethodIDOf(
      _classRef, "setUsage", "(I)Landroid/media/AudioAttributes\$Builder;");

  /// from: public android.media.AudioAttributes.Builder setUsage(int usage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the attribute describing what is the intended use of the the audio signal,
  /// such as alarm or ringtone.
  ///@param usage one of AudioAttributes\#USAGE_UNKNOWN,
  ///     AudioAttributes\#USAGE_MEDIA,
  ///     AudioAttributes\#USAGE_VOICE_COMMUNICATION,
  ///     AudioAttributes\#USAGE_VOICE_COMMUNICATION_SIGNALLING,
  ///     AudioAttributes\#USAGE_ALARM, AudioAttributes\#USAGE_NOTIFICATION,
  ///     AudioAttributes\#USAGE_NOTIFICATION_RINGTONE,
  ///     AudioAttributes\#USAGE_NOTIFICATION_COMMUNICATION_REQUEST,
  ///     AudioAttributes\#USAGE_NOTIFICATION_COMMUNICATION_INSTANT,
  ///     AudioAttributes\#USAGE_NOTIFICATION_COMMUNICATION_DELAYED,
  ///     AudioAttributes\#USAGE_NOTIFICATION_EVENT,
  ///     AudioAttributes\#USAGE_ASSISTANT,
  ///     AudioAttributes\#USAGE_ASSISTANCE_ACCESSIBILITY,
  ///     AudioAttributes\#USAGE_ASSISTANCE_NAVIGATION_GUIDANCE,
  ///     AudioAttributes\#USAGE_ASSISTANCE_SONIFICATION,
  ///     AudioAttributes\#USAGE_GAME.
  /// Value is android.media.AudioAttributes\#USAGE_UNKNOWN, android.media.AudioAttributes\#USAGE_MEDIA, android.media.AudioAttributes\#USAGE_VOICE_COMMUNICATION, android.media.AudioAttributes\#USAGE_VOICE_COMMUNICATION_SIGNALLING, android.media.AudioAttributes\#USAGE_ALARM, android.media.AudioAttributes\#USAGE_NOTIFICATION, android.media.AudioAttributes\#USAGE_NOTIFICATION_RINGTONE, android.media.AudioAttributes\#USAGE_NOTIFICATION_COMMUNICATION_REQUEST, android.media.AudioAttributes\#USAGE_NOTIFICATION_COMMUNICATION_INSTANT, android.media.AudioAttributes\#USAGE_NOTIFICATION_COMMUNICATION_DELAYED, android.media.AudioAttributes\#USAGE_NOTIFICATION_EVENT, android.media.AudioAttributes\#USAGE_ASSISTANCE_ACCESSIBILITY, android.media.AudioAttributes\#USAGE_ASSISTANCE_NAVIGATION_GUIDANCE, android.media.AudioAttributes\#USAGE_ASSISTANCE_SONIFICATION, android.media.AudioAttributes\#USAGE_GAME, or android.media.AudioAttributes\#USAGE_ASSISTANT
  ///@return the same Builder instance.
  AudioAttributes_Builder setUsage(int usage) =>
      AudioAttributes_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setUsage, jni.JniType.objectType, [usage]).object);

  static final _id_setContentType = jniAccessors.getMethodIDOf(_classRef,
      "setContentType", "(I)Landroid/media/AudioAttributes\$Builder;");

  /// from: public android.media.AudioAttributes.Builder setContentType(int contentType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the attribute describing the content type of the audio signal, such as speech,
  /// or music.
  ///@param contentType the content type values, one of
  ///     AudioAttributes\#CONTENT_TYPE_MOVIE,
  ///     AudioAttributes\#CONTENT_TYPE_MUSIC,
  ///     AudioAttributes\#CONTENT_TYPE_SONIFICATION,
  ///     AudioAttributes\#CONTENT_TYPE_SPEECH,
  ///     AudioAttributes\#CONTENT_TYPE_UNKNOWN.
  /// Value is android.media.AudioAttributes\#CONTENT_TYPE_UNKNOWN, android.media.AudioAttributes\#CONTENT_TYPE_SPEECH, android.media.AudioAttributes\#CONTENT_TYPE_MUSIC, android.media.AudioAttributes\#CONTENT_TYPE_MOVIE, or android.media.AudioAttributes\#CONTENT_TYPE_SONIFICATION
  ///@return the same Builder instance.
  AudioAttributes_Builder setContentType(int contentType) =>
      AudioAttributes_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setContentType, jni.JniType.objectType, [contentType]).object);

  static final _id_setFlags = jniAccessors.getMethodIDOf(
      _classRef, "setFlags", "(I)Landroid/media/AudioAttributes\$Builder;");

  /// from: public android.media.AudioAttributes.Builder setFlags(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the combination of flags.
  ///
  /// This is a bitwise OR with the existing flags.
  ///@param flags a combination of AudioAttributes\#FLAG_AUDIBILITY_ENFORCED,
  ///    AudioAttributes\#FLAG_HW_AV_SYNC.
  ///@return the same Builder instance.
  AudioAttributes_Builder setFlags(int flags) =>
      AudioAttributes_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setFlags, jni.JniType.objectType, [flags]).object);

  static final _id_setLegacyStreamType = jniAccessors.getMethodIDOf(_classRef,
      "setLegacyStreamType", "(I)Landroid/media/AudioAttributes\$Builder;");

  /// from: public android.media.AudioAttributes.Builder setLegacyStreamType(int streamType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets attributes as inferred from the legacy stream types.
  /// Use this method when building an AudioAttributes instance to initialize some of
  /// the attributes by information derived from a legacy stream type.
  ///@param streamType one of AudioManager\#STREAM_VOICE_CALL,
  ///   AudioManager\#STREAM_SYSTEM, AudioManager\#STREAM_RING,
  ///   AudioManager\#STREAM_MUSIC, AudioManager\#STREAM_ALARM,
  ///    or AudioManager\#STREAM_NOTIFICATION.
  ///@return the same Builder instance.
  AudioAttributes_Builder setLegacyStreamType(int streamType) =>
      AudioAttributes_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setLegacyStreamType,
          jni.JniType.objectType,
          [streamType]).object);
}
