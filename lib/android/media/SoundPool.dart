// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../content/res/AssetFileDescriptor.dart" as assetfiledescriptor_;

import "AudioAttributes.dart" as audioattributes_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.SoundPool
///
/// The SoundPool class manages and plays audio resources for applications.
///
/// A SoundPool is a collection of samples that can be loaded into memory
/// from a resource inside the APK or from a file in the file system. The
/// SoundPool library uses the MediaPlayer service to decode the audio
/// into a raw 16-bit PCM mono or stereo stream. This allows applications
/// to ship with compressed streams without having to suffer the CPU load
/// and latency of decompressing during playback.
///
///
/// In addition to low-latency playback, SoundPool can also manage the number
/// of audio streams being rendered at once. When the SoundPool object is
/// constructed, the maxStreams parameter sets the maximum number of streams
/// that can be played at a time from this single SoundPool. SoundPool tracks
/// the number of active streams. If the maximum number of streams is exceeded,
/// SoundPool will automatically stop a previously playing stream based first
/// on priority and then by age within that priority. Limiting the maximum
/// number of streams helps to cap CPU loading and reducing the likelihood that
/// audio mixing will impact visuals or UI performance.
///
///
/// Sounds can be looped by setting a non-zero loop value. A value of -1
/// causes the sound to loop forever. In this case, the application must
/// explicitly call the stop() function to stop the sound. Any other non-zero
/// value will cause the sound to repeat the specified number of times, e.g.
/// a value of 3 causes the sound to play a total of 4 times.
///
///
/// The playback rate can also be changed. A playback rate of 1.0 causes
/// the sound to play at its original frequency (resampled, if necessary,
/// to the hardware output frequency). A playback rate of 2.0 causes the
/// sound to play at twice its original frequency, and a playback rate of
/// 0.5 causes it to play at half its original frequency. The playback
/// rate range is 0.5 to 2.0.
///
///
/// Priority runs low to high, i.e. higher numbers are higher priority.
/// Priority is used when a call to play() would cause the number of active
/// streams to exceed the value established by the maxStreams parameter when
/// the SoundPool was created. In this case, the stream allocator will stop
/// the lowest priority stream. If there are multiple streams with the same
/// low priority, it will choose the oldest stream to stop. In the case
/// where the priority of the new stream is lower than all the active
/// streams, the new sound will not play and the play() function will return
/// a streamID of zero.
///
///
/// Let's examine a typical use case: A game consists of several levels of
/// play. For each level, there is a set of unique sounds that are used only
/// by that level. In this case, the game logic should create a new SoundPool
/// object when the first level is loaded. The level data itself might contain
/// the list of sounds to be used by this level. The loading logic iterates
/// through the list of sounds calling the appropriate SoundPool.load()
/// function. This should typically be done early in the process to allow time
/// for decompressing the audio to raw PCM format before they are needed for
/// playback.
///
///
/// Once the sounds are loaded and play has started, the application can
/// trigger sounds by calling SoundPool.play(). Playing streams can be
/// paused or resumed, and the application can also alter the pitch by
/// adjusting the playback rate in real-time for doppler or synthesis
/// effects.
///
///
/// Note that since streams can be stopped due to resource constraints, the
/// streamID is a reference to a particular instance of a stream. If the stream
/// is stopped to allow a higher priority stream to play, the stream is no
/// longer valid. However, the application is allowed to call methods on
/// the streamID without error. This may help simplify program logic since
/// the application need not concern itself with the stream lifecycle.
///
///
/// In our example, when the player has completed the level, the game
/// logic should call SoundPool.release() to release all the native resources
/// in use and then set the SoundPool reference to null. If the player starts
/// another level, a new SoundPool is created, sounds are loaded, and play
/// resumes.
///
class SoundPool extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/SoundPool");
  SoundPool.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(III)V");

  /// from: public void <init>(int maxStreams, int streamType, int srcQuality)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor. Constructs a SoundPool object with the following
  /// characteristics:
  ///@param maxStreams the maximum number of simultaneous streams for this
  ///                   SoundPool object
  ///@param streamType the audio stream type as described in AudioManager
  ///                   For example, game applications will normally use
  ///                   AudioManager\#STREAM_MUSIC.
  ///@param srcQuality the sample-rate converter quality. Currently has no
  ///                   effect. Use 0 for the default.
  ///@return a SoundPool object, or null if creation failed
  ///@deprecated use SoundPool.Builder instead to create and configure a
  ///     SoundPool instance
  SoundPool(int maxStreams, int streamType, int srcQuality)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [maxStreams, streamType, srcQuality]).object);

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public final void release()
  ///
  /// Release the SoundPool resources.
  ///
  /// Release all memory and native resources used by the SoundPool
  /// object. The SoundPool can no longer be used and the reference
  /// should be set to null.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_load =
      jniAccessors.getMethodIDOf(_classRef, "load", "(Ljava/lang/String;I)I");

  /// from: public int load(java.lang.String path, int priority)
  ///
  /// Load the sound from the specified path.
  ///@param path the path to the audio file
  ///@param priority the priority of the sound. Currently has no effect. Use
  ///                 a value of 1 for future compatibility.
  ///@return a sound ID. This value can be used to play or unload the sound.
  int load(jni.JniString path, int priority) => jniAccessors.callMethodWithArgs(
      reference,
      _id_load,
      jni.JniType.intType,
      [path.reference, priority]).integer;

  static final _id_load1 = jniAccessors.getMethodIDOf(
      _classRef, "load", "(Landroid/content/Context;II)I");

  /// from: public int load(android.content.Context context, int resId, int priority)
  ///
  /// Load the sound from the specified APK resource.
  ///
  /// Note that the extension is dropped. For example, if you want to load
  /// a sound from the raw resource file "explosion.mp3", you would specify
  /// "R.raw.explosion" as the resource ID. Note that this means you cannot
  /// have both an "explosion.wav" and an "explosion.mp3" in the res/raw
  /// directory.
  ///@param context the application context
  ///@param resId the resource ID
  ///@param priority the priority of the sound. Currently has no effect. Use
  ///                 a value of 1 for future compatibility.
  ///@return a sound ID. This value can be used to play or unload the sound.
  int load1(context_.Context context, int resId, int priority) =>
      jniAccessors.callMethodWithArgs(reference, _id_load1, jni.JniType.intType,
          [context.reference, resId, priority]).integer;

  static final _id_load2 = jniAccessors.getMethodIDOf(
      _classRef, "load", "(Landroid/content/res/AssetFileDescriptor;I)I");

  /// from: public int load(android.content.res.AssetFileDescriptor afd, int priority)
  ///
  /// Load the sound from an asset file descriptor.
  ///@param afd an asset file descriptor
  ///@param priority the priority of the sound. Currently has no effect. Use
  ///                 a value of 1 for future compatibility.
  ///@return a sound ID. This value can be used to play or unload the sound.
  int load2(assetfiledescriptor_.AssetFileDescriptor afd, int priority) =>
      jniAccessors.callMethodWithArgs(reference, _id_load2, jni.JniType.intType,
          [afd.reference, priority]).integer;

  static final _id_load3 = jniAccessors.getMethodIDOf(
      _classRef, "load", "(Ljava/io/FileDescriptor;JJI)I");

  /// from: public int load(java.io.FileDescriptor fd, long offset, long length, int priority)
  ///
  /// Load the sound from a FileDescriptor.
  ///
  /// This version is useful if you store multiple sounds in a single
  /// binary. The offset specifies the offset from the start of the file
  /// and the length specifies the length of the sound within the file.
  ///@param fd a FileDescriptor object
  ///@param offset offset to the start of the sound
  ///@param length length of the sound
  ///@param priority the priority of the sound. Currently has no effect. Use
  ///                 a value of 1 for future compatibility.
  ///@return a sound ID. This value can be used to play or unload the sound.
  int load3(jni.JniObject fd, int offset, int length, int priority) =>
      jniAccessors.callMethodWithArgs(reference, _id_load3, jni.JniType.intType,
          [fd.reference, offset, length, priority]).integer;

  static final _id_unload =
      jniAccessors.getMethodIDOf(_classRef, "unload", "(I)Z");

  /// from: public native final boolean unload(int soundID)
  ///
  /// Unload a sound from a sound ID.
  ///
  /// Unloads the sound specified by the soundID. This is the value
  /// returned by the load() function. Returns true if the sound is
  /// successfully unloaded, false if the sound was already unloaded.
  ///@param soundID a soundID returned by the load() function
  ///@return true if just unloaded, false if previously unloaded
  bool unload(int soundID) => jniAccessors.callMethodWithArgs(
      reference, _id_unload, jni.JniType.booleanType, [soundID]).boolean;

  static final _id_play =
      jniAccessors.getMethodIDOf(_classRef, "play", "(IFFIIF)I");

  /// from: public final int play(int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate)
  ///
  /// Play a sound from a sound ID.
  ///
  /// Play the sound specified by the soundID. This is the value
  /// returned by the load() function. Returns a non-zero streamID
  /// if successful, zero if it fails. The streamID can be used to
  /// further control playback. Note that calling play() may cause
  /// another sound to stop playing if the maximum number of active
  /// streams is exceeded. A loop value of -1 means loop forever,
  /// a value of 0 means don't loop, other values indicate the
  /// number of repeats, e.g. a value of 1 plays the audio twice.
  /// The playback rate allows the application to vary the playback
  /// rate (pitch) of the sound. A value of 1.0 means play back at
  /// the original frequency. A value of 2.0 means play back twice
  /// as fast, and a value of 0.5 means playback at half speed.
  ///@param soundID a soundID returned by the load() function
  ///@param leftVolume left volume value (range = 0.0 to 1.0)
  ///@param rightVolume right volume value (range = 0.0 to 1.0)
  ///@param priority stream priority (0 = lowest priority)
  ///@param loop loop mode (0 = no loop, -1 = loop forever)
  ///@param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
  ///@return non-zero streamID if successful, zero if failed
  int play(int soundID, double leftVolume, double rightVolume, int priority,
          int loop, double rate) =>
      jniAccessors.callMethodWithArgs(reference, _id_play, jni.JniType.intType,
          [soundID, leftVolume, rightVolume, priority, loop, rate]).integer;

  static final _id_pause =
      jniAccessors.getMethodIDOf(_classRef, "pause", "(I)V");

  /// from: public native final void pause(int streamID)
  ///
  /// Pause a playback stream.
  ///
  /// Pause the stream specified by the streamID. This is the
  /// value returned by the play() function. If the stream is
  /// playing, it will be paused. If the stream is not playing
  /// (e.g. is stopped or was previously paused), calling this
  /// function will have no effect.
  ///@param streamID a streamID returned by the play() function
  void pause(int streamID) => jniAccessors.callMethodWithArgs(
      reference, _id_pause, jni.JniType.voidType, [streamID]).check();

  static final _id_resume =
      jniAccessors.getMethodIDOf(_classRef, "resume", "(I)V");

  /// from: public native final void resume(int streamID)
  ///
  /// Resume a playback stream.
  ///
  /// Resume the stream specified by the streamID. This
  /// is the value returned by the play() function. If the stream
  /// is paused, this will resume playback. If the stream was not
  /// previously paused, calling this function will have no effect.
  ///@param streamID a streamID returned by the play() function
  void resume(int streamID) => jniAccessors.callMethodWithArgs(
      reference, _id_resume, jni.JniType.voidType, [streamID]).check();

  static final _id_autoPause =
      jniAccessors.getMethodIDOf(_classRef, "autoPause", "()V");

  /// from: public native final void autoPause()
  ///
  /// Pause all active streams.
  ///
  /// Pause all streams that are currently playing. This function
  /// iterates through all the active streams and pauses any that
  /// are playing. It also sets a flag so that any streams that
  /// are playing can be resumed by calling autoResume().
  void autoPause() => jniAccessors.callMethodWithArgs(
      reference, _id_autoPause, jni.JniType.voidType, []).check();

  static final _id_autoResume =
      jniAccessors.getMethodIDOf(_classRef, "autoResume", "()V");

  /// from: public native final void autoResume()
  ///
  /// Resume all previously active streams.
  ///
  /// Automatically resumes all streams that were paused in previous
  /// calls to autoPause().
  void autoResume() => jniAccessors.callMethodWithArgs(
      reference, _id_autoResume, jni.JniType.voidType, []).check();

  static final _id_stop = jniAccessors.getMethodIDOf(_classRef, "stop", "(I)V");

  /// from: public native final void stop(int streamID)
  ///
  /// Stop a playback stream.
  ///
  /// Stop the stream specified by the streamID. This
  /// is the value returned by the play() function. If the stream
  /// is playing, it will be stopped. It also releases any native
  /// resources associated with this stream. If the stream is not
  /// playing, it will have no effect.
  ///@param streamID a streamID returned by the play() function
  void stop(int streamID) => jniAccessors.callMethodWithArgs(
      reference, _id_stop, jni.JniType.voidType, [streamID]).check();

  static final _id_setVolume =
      jniAccessors.getMethodIDOf(_classRef, "setVolume", "(IFF)V");

  /// from: public final void setVolume(int streamID, float leftVolume, float rightVolume)
  ///
  /// Set stream volume.
  ///
  /// Sets the volume on the stream specified by the streamID.
  /// This is the value returned by the play() function. The
  /// value must be in the range of 0.0 to 1.0. If the stream does
  /// not exist, it will have no effect.
  ///@param streamID a streamID returned by the play() function
  ///@param leftVolume left volume value (range = 0.0 to 1.0)
  ///@param rightVolume right volume value (range = 0.0 to 1.0)
  void setVolume(int streamID, double leftVolume, double rightVolume) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVolume,
          jni.JniType.voidType, [streamID, leftVolume, rightVolume]).check();

  static final _id_setPriority =
      jniAccessors.getMethodIDOf(_classRef, "setPriority", "(II)V");

  /// from: public native final void setPriority(int streamID, int priority)
  ///
  /// Change stream priority.
  ///
  /// Change the priority of the stream specified by the streamID.
  /// This is the value returned by the play() function. Affects the
  /// order in which streams are re-used to play new sounds. If the
  /// stream does not exist, it will have no effect.
  ///@param streamID a streamID returned by the play() function
  void setPriority(int streamID, int priority) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPriority,
          jni.JniType.voidType, [streamID, priority]).check();

  static final _id_setLoop =
      jniAccessors.getMethodIDOf(_classRef, "setLoop", "(II)V");

  /// from: public native final void setLoop(int streamID, int loop)
  ///
  /// Set loop mode.
  ///
  /// Change the loop mode. A loop value of -1 means loop forever,
  /// a value of 0 means don't loop, other values indicate the
  /// number of repeats, e.g. a value of 1 plays the audio twice.
  /// If the stream does not exist, it will have no effect.
  ///@param streamID a streamID returned by the play() function
  ///@param loop loop mode (0 = no loop, -1 = loop forever)
  void setLoop(int streamID, int loop) => jniAccessors.callMethodWithArgs(
      reference, _id_setLoop, jni.JniType.voidType, [streamID, loop]).check();

  static final _id_setRate =
      jniAccessors.getMethodIDOf(_classRef, "setRate", "(IF)V");

  /// from: public native final void setRate(int streamID, float rate)
  ///
  /// Change playback rate.
  ///
  /// The playback rate allows the application to vary the playback
  /// rate (pitch) of the sound. A value of 1.0 means playback at
  /// the original frequency. A value of 2.0 means playback twice
  /// as fast, and a value of 0.5 means playback at half speed.
  /// If the stream does not exist, it will have no effect.
  ///@param streamID a streamID returned by the play() function
  ///@param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
  void setRate(int streamID, double rate) => jniAccessors.callMethodWithArgs(
      reference, _id_setRate, jni.JniType.voidType, [streamID, rate]).check();

  static final _id_setOnLoadCompleteListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnLoadCompleteListener",
      "(Landroid/media/SoundPool\$OnLoadCompleteListener;)V");

  /// from: public void setOnLoadCompleteListener(android.media.SoundPool.OnLoadCompleteListener listener)
  ///
  /// Sets the callback hook for the OnLoadCompleteListener.
  void setOnLoadCompleteListener(SoundPool_OnLoadCompleteListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnLoadCompleteListener,
          jni.JniType.voidType, [listener.reference]).check();
}

/// from: android.media.SoundPool$OnLoadCompleteListener
class SoundPool_OnLoadCompleteListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/SoundPool\$OnLoadCompleteListener");
  SoundPool_OnLoadCompleteListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onLoadComplete = jniAccessors.getMethodIDOf(
      _classRef, "onLoadComplete", "(Landroid/media/SoundPool;II)V");

  /// from: public abstract void onLoadComplete(android.media.SoundPool soundPool, int sampleId, int status)
  ///
  /// Called when a sound has completed loading.
  ///@param soundPool SoundPool object from the load() method
  ///@param sampleId the sample ID of the sound loaded.
  ///@param status the status of the load operation (0 = success)
  void onLoadComplete(SoundPool soundPool, int sampleId, int status) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onLoadComplete,
          jni.JniType.voidType,
          [soundPool.reference, sampleId, status]).check();
}

/// from: android.media.SoundPool$Builder
///
/// Builder class for SoundPool objects.
class SoundPool_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/SoundPool\$Builder");
  SoundPool_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new Builder with the defaults format values.
  /// If not provided, the maximum number of streams is 1 (see \#setMaxStreams(int) to
  /// change it), and the audio attributes have a usage value of
  /// AudioAttributes\#USAGE_MEDIA (see \#setAudioAttributes(AudioAttributes) to
  /// change them).
  SoundPool_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setMaxStreams = jniAccessors.getMethodIDOf(
      _classRef, "setMaxStreams", "(I)Landroid/media/SoundPool\$Builder;");

  /// from: public android.media.SoundPool.Builder setMaxStreams(int maxStreams)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the maximum of number of simultaneous streams that can be played simultaneously.
  ///@param maxStreams a value equal to 1 or greater.
  ///@return the same Builder instance
  ///@throws IllegalArgumentException
  SoundPool_Builder setMaxStreams(int maxStreams) =>
      SoundPool_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setMaxStreams, jni.JniType.objectType, [maxStreams]).object);

  static final _id_setAudioAttributes = jniAccessors.getMethodIDOf(
      _classRef,
      "setAudioAttributes",
      "(Landroid/media/AudioAttributes;)Landroid/media/SoundPool\$Builder;");

  /// from: public android.media.SoundPool.Builder setAudioAttributes(android.media.AudioAttributes attributes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the AudioAttributes. For examples, game applications will use attributes
  /// built with usage information set to AudioAttributes\#USAGE_GAME.
  ///@param attributes a non-null
  ///@return
  SoundPool_Builder setAudioAttributes(
          audioattributes_.AudioAttributes attributes) =>
      SoundPool_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setAudioAttributes,
          jni.JniType.objectType,
          [attributes.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/media/SoundPool;");

  /// from: public android.media.SoundPool build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SoundPool build() => SoundPool.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_build, jni.JniType.objectType, []).object);
}
