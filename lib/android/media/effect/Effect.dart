// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "EffectUpdateListener.dart" as effectupdatelistener_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.effect.Effect
///
/// Effects are high-performance transformations that can be applied to image frames. These are
/// passed in the form of OpenGL ES 2.0 texture names. Typical frames could be images loaded from
/// disk, or frames from the camera or other video streams.
///
///
/// To create an Effect you must first create an EffectContext. You can obtain an instance of the
/// context's EffectFactory by calling
/// android.media.effect.EffectContext\#getFactory() getFactory(). The EffectFactory allows
/// you to instantiate specific Effects.
///
///
/// The application is responsible for creating an EGL context, and making it current before
/// applying an effect. An effect is bound to a single EffectContext, which in turn is bound to a
/// single EGL context. If your EGL context is destroyed, the EffectContext becomes invalid and any
/// effects bound to this context can no longer be used.
///
class Effect extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/effect/Effect");
  Effect.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Effect()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the effect name.
  ///
  /// Returns the unique name of the effect, which matches the name used for instantiating this
  /// effect by the EffectFactory.
  ///@return The name of the effect.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_apply =
      jniAccessors.getMethodIDOf(_classRef, "apply", "(IIII)V");

  /// from: public abstract void apply(int inputTexId, int width, int height, int outputTexId)
  ///
  /// Apply an effect to GL textures.
  ///
  /// Apply the Effect on the specified input GL texture, and write the result into the
  /// output GL texture. The texture names passed must be valid in the current GL context.
  ///
  ///
  /// The input texture must be a valid texture name with the given width and height and must be
  /// bound to a GL_TEXTURE_2D texture image (usually done by calling the glTexImage2D() function).
  /// Multiple mipmap levels may be provided.
  ///
  ///
  /// If the output texture has not been bound to a texture image, it will be automatically
  /// bound by the effect as a GL_TEXTURE_2D. It will contain one mipmap level (0), which will have
  /// the same size as the input. No other mipmap levels are defined. If the output texture was
  /// bound already, and its size does not match the input texture size, the result may be clipped
  /// or only partially fill the texture.
  ///
  ///
  /// Note, that regardless of whether a texture image was originally provided or not, both the
  /// input and output textures are owned by the caller. That is, the caller is responsible for
  /// calling glDeleteTextures() to deallocate the input and output textures.
  ///
  ///@param inputTexId The GL texture name of a valid and bound input texture.
  ///@param width The width of the input texture in pixels.
  ///@param height The height of the input texture in pixels.
  ///@param outputTexId The GL texture name of the output texture.
  void apply(int inputTexId, int width, int height, int outputTexId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_apply,
          jni.JniType.voidType,
          [inputTexId, width, height, outputTexId]).check();

  static final _id_setParameter = jniAccessors.getMethodIDOf(
      _classRef, "setParameter", "(Ljava/lang/String;Ljava/lang/Object;)V");

  /// from: public abstract void setParameter(java.lang.String parameterKey, java.lang.Object value)
  ///
  /// Set a filter parameter.
  ///
  /// Consult the effect documentation for a list of supported parameter keys for each effect.
  ///@param parameterKey The name of the parameter to adjust.
  ///@param value The new value to set the parameter to.
  ///@throws InvalidArgumentException if parameterName is not a recognized name, or the value is
  ///         not a valid value for this parameter.
  void setParameter(jni.JniString parameterKey, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setParameter,
          jni.JniType.voidType,
          [parameterKey.reference, value.reference]).check();

  static final _id_setUpdateListener = jniAccessors.getMethodIDOf(_classRef,
      "setUpdateListener", "(Landroid/media/effect/EffectUpdateListener;)V");

  /// from: public void setUpdateListener(android.media.effect.EffectUpdateListener listener)
  ///
  /// Set an effect listener.
  ///
  /// Some effects may report state changes back to the host, if a listener is set. Consult the
  /// individual effect documentation for more details.
  ///@param listener The listener to receive update callbacks on.
  void setUpdateListener(effectupdatelistener_.EffectUpdateListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUpdateListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public abstract void release()
  ///
  /// Release an effect.
  ///
  /// Releases the effect and any resources associated with it. You may call this if you need to
  /// make sure acquired resources are no longer held by the effect. Releasing an effect makes it
  /// invalid for reuse.
  ///
  ///
  /// Note that this method must be called with the EffectContext and EGL context current, as
  /// the effect may release internal GL resources.
  ///
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();
}
