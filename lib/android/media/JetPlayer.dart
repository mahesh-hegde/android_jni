// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/res/AssetFileDescriptor.dart" as assetfiledescriptor_;

import "../os/Handler.dart" as handler_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.JetPlayer
///
/// JetPlayer provides access to JET content playback and control.
///
/// Please refer to the JET Creator User Manual for a presentation of the JET interactive
/// music concept and how to use the JetCreator tool to create content to be player by JetPlayer.
///
/// Use of the JetPlayer class is based around the playback of a number of JET segments
/// sequentially added to a playback FIFO queue. The rendering of the MIDI content stored in each
/// segment can be dynamically affected by two mechanisms:
/// <ul>
/// <li>tracks in a segment can be muted or unmuted at any moment, individually or through
///    a mask (to change the mute state of multiple tracks at once)</li>
/// <li>parts of tracks in a segment can be played at predefined points in the segment, in order
///    to maintain synchronization with the other tracks in the segment. This is achieved through
///    the notion of "clips", which can be triggered at any time, but that will play only at the
///    right time, as authored in the corresponding JET file.</li>
/// </ul>
/// As a result of the rendering and playback of the JET segments, the user of the JetPlayer instance
/// can receive notifications from the JET engine relative to:
/// <ul>
/// <li>the playback state,</li>
/// <li>the number of segments left to play in the queue,</li>
/// <li>application controller events (CC80-83) to mark points in the MIDI segments.</li>
/// </ul>
/// Use \#getJetPlayer() to construct a JetPlayer instance. JetPlayer is a singleton class.
///
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about how to use JetPlayer, read the
/// <a href="{@docRoot}guide/topics/media/jetplayer.html">JetPlayer</a> developer guide.
///</div>
class JetPlayer extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/JetPlayer");
  JetPlayer.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  JetPlayer()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getJetPlayer = jniAccessors.getStaticMethodIDOf(
      _classRef, "getJetPlayer", "()Landroid/media/JetPlayer;");

  /// from: static public android.media.JetPlayer getJetPlayer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Factory method for the JetPlayer class.
  ///@return the singleton JetPlayer instance
  static JetPlayer getJetPlayer() =>
      JetPlayer.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getJetPlayer, jni.JniType.objectType, []).object);

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Cloning a JetPlayer instance is not supported. Calling clone() will generate an exception.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Stops the current JET playback, and releases all associated native resources.
  /// The object can no longer be used and the reference should be set to null
  /// after a call to release().
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_getMaxTracks =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMaxTracks", "()I");

  /// from: static public int getMaxTracks()
  ///
  /// Returns the maximum number of simultaneous MIDI tracks supported by JetPlayer
  static int getMaxTracks() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMaxTracks, jni.JniType.intType, []).integer;

  static final _id_loadJetFile = jniAccessors.getMethodIDOf(
      _classRef, "loadJetFile", "(Ljava/lang/String;)Z");

  /// from: public boolean loadJetFile(java.lang.String path)
  ///
  /// Loads a .jet file from a given path.
  ///@param path the path to the .jet file, for instance "/sdcard/mygame/music.jet".
  ///@return true if loading the .jet file was successful, false if loading failed.
  bool loadJetFile(jni.JniString path) => jniAccessors.callMethodWithArgs(
      reference,
      _id_loadJetFile,
      jni.JniType.booleanType,
      [path.reference]).boolean;

  static final _id_loadJetFile1 = jniAccessors.getMethodIDOf(
      _classRef, "loadJetFile", "(Landroid/content/res/AssetFileDescriptor;)Z");

  /// from: public boolean loadJetFile(android.content.res.AssetFileDescriptor afd)
  ///
  /// Loads a .jet file from an asset file descriptor.
  ///@param afd the asset file descriptor.
  ///@return true if loading the .jet file was successful, false if loading failed.
  bool loadJetFile1(assetfiledescriptor_.AssetFileDescriptor afd) =>
      jniAccessors.callMethodWithArgs(reference, _id_loadJetFile1,
          jni.JniType.booleanType, [afd.reference]).boolean;

  static final _id_closeJetFile =
      jniAccessors.getMethodIDOf(_classRef, "closeJetFile", "()Z");

  /// from: public boolean closeJetFile()
  ///
  /// Closes the resource containing the JET content.
  ///@return true if successfully closed, false otherwise.
  bool closeJetFile() => jniAccessors.callMethodWithArgs(
      reference, _id_closeJetFile, jni.JniType.booleanType, []).boolean;

  static final _id_play = jniAccessors.getMethodIDOf(_classRef, "play", "()Z");

  /// from: public boolean play()
  ///
  /// Starts playing the JET segment queue.
  ///@return true if rendering and playback is successfully started, false otherwise.
  bool play() => jniAccessors.callMethodWithArgs(
      reference, _id_play, jni.JniType.booleanType, []).boolean;

  static final _id_pause =
      jniAccessors.getMethodIDOf(_classRef, "pause", "()Z");

  /// from: public boolean pause()
  ///
  /// Pauses the playback of the JET segment queue.
  ///@return true if rendering and playback is successfully paused, false otherwise.
  bool pause() => jniAccessors.callMethodWithArgs(
      reference, _id_pause, jni.JniType.booleanType, []).boolean;

  static final _id_queueJetSegment =
      jniAccessors.getMethodIDOf(_classRef, "queueJetSegment", "(IIIIIB)Z");

  /// from: public boolean queueJetSegment(int segmentNum, int libNum, int repeatCount, int transpose, int muteFlags, byte userID)
  ///
  /// Queues the specified segment in the JET queue.
  ///@param segmentNum the identifier of the segment.
  ///@param libNum the index of the sound bank associated with the segment. Use -1 to indicate
  ///    that no sound bank (DLS file) is associated with this segment, in which case JET will use
  ///    the General MIDI library.
  ///@param repeatCount the number of times the segment will be repeated. 0 means the segment will
  ///    only play once. -1 means the segment will repeat indefinitely.
  ///@param transpose the amount of pitch transposition. Set to 0 for normal playback.
  ///    Range is -12 to +12.
  ///@param muteFlags a bitmask to specify which MIDI tracks will be muted during playback. Bit 0
  ///    affects track 0, bit 1 affects track 1 etc.
  ///@param userID a value specified by the application that uniquely identifies the segment.
  ///    this value is received in the
  ///    OnJetEventListener\#onJetUserIdUpdate(JetPlayer, int, int) event listener method.
  ///    Normally, the application will keep a byte value that is incremented each time a new
  ///    segment is queued up. This can be used to look up any special characteristics of that
  ///    track including trigger clips and mute flags.
  ///@return true if the segment was successfully queued, false if the queue is full or if the
  ///    parameters are invalid.
  bool queueJetSegment(int segmentNum, int libNum, int repeatCount,
          int transpose, int muteFlags, int userID) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_queueJetSegment, jni.JniType.booleanType, [
        segmentNum,
        libNum,
        repeatCount,
        transpose,
        muteFlags,
        userID
      ]).boolean;

  static final _id_queueJetSegmentMuteArray = jniAccessors.getMethodIDOf(
      _classRef, "queueJetSegmentMuteArray", "(IIII[ZB)Z");

  /// from: public boolean queueJetSegmentMuteArray(int segmentNum, int libNum, int repeatCount, int transpose, boolean[] muteArray, byte userID)
  ///
  /// Queues the specified segment in the JET queue.
  ///@param segmentNum the identifier of the segment.
  ///@param libNum the index of the soundbank associated with the segment. Use -1 to indicate that
  ///    no sound bank (DLS file) is associated with this segment, in which case JET will use
  ///    the General MIDI library.
  ///@param repeatCount the number of times the segment will be repeated. 0 means the segment will
  ///    only play once. -1 means the segment will repeat indefinitely.
  ///@param transpose the amount of pitch transposition. Set to 0 for normal playback.
  ///    Range is -12 to +12.
  ///@param muteArray an array of booleans to specify which MIDI tracks will be muted during
  ///    playback. The value at index 0 affects track 0, value at index 1 affects track 1 etc.
  ///    The length of the array must be \#getMaxTracks() for the call to succeed.
  ///@param userID a value specified by the application that uniquely identifies the segment.
  ///    this value is received in the
  ///    OnJetEventListener\#onJetUserIdUpdate(JetPlayer, int, int) event listener method.
  ///    Normally, the application will keep a byte value that is incremented each time a new
  ///    segment is queued up. This can be used to look up any special characteristics of that
  ///    track including trigger clips and mute flags.
  ///@return true if the segment was successfully queued, false if the queue is full or if the
  ///    parameters are invalid.
  bool queueJetSegmentMuteArray(int segmentNum, int libNum, int repeatCount,
          int transpose, jni.JniObject muteArray, int userID) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_queueJetSegmentMuteArray, jni.JniType.booleanType, [
        segmentNum,
        libNum,
        repeatCount,
        transpose,
        muteArray.reference,
        userID
      ]).boolean;

  static final _id_setMuteFlags =
      jniAccessors.getMethodIDOf(_classRef, "setMuteFlags", "(IZ)Z");

  /// from: public boolean setMuteFlags(int muteFlags, boolean sync)
  ///
  /// Modifies the mute flags.
  ///@param muteFlags a bitmask to specify which MIDI tracks are muted. Bit 0 affects track 0,
  ///    bit 1 affects track 1 etc.
  ///@param sync if false, the new mute flags will be applied as soon as possible by the JET
  ///    render and playback engine. If true, the mute flags will be updated at the start of the
  ///    next segment. If the segment is repeated, the flags will take effect the next time
  ///    segment is repeated.
  ///@return true if the mute flags were successfully updated, false otherwise.
  bool setMuteFlags(int muteFlags, bool sync0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMuteFlags,
          jni.JniType.booleanType, [muteFlags, sync0]).boolean;

  static final _id_setMuteArray =
      jniAccessors.getMethodIDOf(_classRef, "setMuteArray", "([ZZ)Z");

  /// from: public boolean setMuteArray(boolean[] muteArray, boolean sync)
  ///
  /// Modifies the mute flags for the current active segment.
  ///@param muteArray an array of booleans to specify which MIDI tracks are muted. The value at
  ///    index 0 affects track 0, value at index 1 affects track 1 etc.
  ///    The length of the array must be \#getMaxTracks() for the call to succeed.
  ///@param sync if false, the new mute flags will be applied as soon as possible by the JET
  ///    render and playback engine. If true, the mute flags will be updated at the start of the
  ///    next segment. If the segment is repeated, the flags will take effect the next time
  ///    segment is repeated.
  ///@return true if the mute flags were successfully updated, false otherwise.
  bool setMuteArray(jni.JniObject muteArray, bool sync0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMuteArray,
          jni.JniType.booleanType, [muteArray.reference, sync0]).boolean;

  static final _id_setMuteFlag =
      jniAccessors.getMethodIDOf(_classRef, "setMuteFlag", "(IZZ)Z");

  /// from: public boolean setMuteFlag(int trackId, boolean muteFlag, boolean sync)
  ///
  /// Mutes or unmutes a single track.
  ///@param trackId the index of the track to mute.
  ///@param muteFlag set to true to mute, false to unmute.
  ///@param sync if false, the new mute flags will be applied as soon as possible by the JET
  ///    render and playback engine. If true, the mute flag will be updated at the start of the
  ///    next segment. If the segment is repeated, the flag will take effect the next time
  ///    segment is repeated.
  ///@return true if the mute flag was successfully updated, false otherwise.
  bool setMuteFlag(int trackId, bool muteFlag, bool sync0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMuteFlag,
          jni.JniType.booleanType, [trackId, muteFlag, sync0]).boolean;

  static final _id_triggerClip =
      jniAccessors.getMethodIDOf(_classRef, "triggerClip", "(I)Z");

  /// from: public boolean triggerClip(int clipId)
  ///
  /// Schedules the playback of a clip.
  /// This will automatically update the mute flags in sync with the JET Clip Marker (controller
  /// 103). The parameter clipID must be in the range of 0-63. After the call to triggerClip, when
  /// JET next encounters a controller event 103 with bits 0-5 of the value equal to clipID and
  /// bit 6 set to 1, it will automatically unmute the track containing the controller event.
  /// When JET encounters the complementary controller event 103 with bits 0-5 of the value equal
  /// to clipID and bit 6 set to 0, it will mute the track again.
  ///@param clipId the identifier of the clip to trigger.
  ///@return true if the clip was successfully triggered, false otherwise.
  bool triggerClip(int clipId) => jniAccessors.callMethodWithArgs(
      reference, _id_triggerClip, jni.JniType.booleanType, [clipId]).boolean;

  static final _id_clearQueue =
      jniAccessors.getMethodIDOf(_classRef, "clearQueue", "()Z");

  /// from: public boolean clearQueue()
  ///
  /// Empties the segment queue, and clears all clips that are scheduled for playback.
  ///@return true if the queue was successfully cleared, false otherwise.
  bool clearQueue() => jniAccessors.callMethodWithArgs(
      reference, _id_clearQueue, jni.JniType.booleanType, []).boolean;

  static final _id_setEventListener = jniAccessors.getMethodIDOf(_classRef,
      "setEventListener", "(Landroid/media/JetPlayer\$OnJetEventListener;)V");

  /// from: public void setEventListener(android.media.JetPlayer.OnJetEventListener listener)
  ///
  /// Sets the listener JetPlayer notifies when a JET event is generated by the rendering and
  /// playback engine.
  /// Notifications will be received in the same thread as the one in which the JetPlayer
  /// instance was created.
  ///@param listener
  void setEventListener(JetPlayer_OnJetEventListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEventListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setEventListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setEventListener",
      "(Landroid/media/JetPlayer\$OnJetEventListener;Landroid/os/Handler;)V");

  /// from: public void setEventListener(android.media.JetPlayer.OnJetEventListener listener, android.os.Handler handler)
  ///
  /// Sets the listener JetPlayer notifies when a JET event is generated by the rendering and
  /// playback engine.
  /// Use this method to receive JET events in the Handler associated with another
  /// thread than the one in which you created the JetPlayer instance.
  ///@param listener
  ///@param handler the Handler that will receive the event notification messages.
  void setEventListener1(
          JetPlayer_OnJetEventListener listener, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setEventListener1,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();
}

/// from: android.media.JetPlayer$OnJetEventListener
///
/// Handles the notification when the JET engine generates an event.
class JetPlayer_OnJetEventListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/JetPlayer\$OnJetEventListener");
  JetPlayer_OnJetEventListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onJetEvent = jniAccessors.getMethodIDOf(
      _classRef, "onJetEvent", "(Landroid/media/JetPlayer;SBBBB)V");

  /// from: public abstract void onJetEvent(android.media.JetPlayer player, short segment, byte track, byte channel, byte controller, byte value)
  ///
  /// Callback for when the JET engine generates a new event.
  ///@param player the JET player the event is coming from
  ///@param segment 8 bit unsigned value
  ///@param track 6 bit unsigned value
  ///@param channel 4 bit unsigned value
  ///@param controller 7 bit unsigned value
  ///@param value 7 bit unsigned value
  void onJetEvent(JetPlayer player, int segment, int track, int channel,
          int controller, int value) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onJetEvent, jni.JniType.voidType, [
        player.reference,
        segment,
        track,
        channel,
        controller,
        value
      ]).check();

  static final _id_onJetUserIdUpdate = jniAccessors.getMethodIDOf(
      _classRef, "onJetUserIdUpdate", "(Landroid/media/JetPlayer;II)V");

  /// from: public abstract void onJetUserIdUpdate(android.media.JetPlayer player, int userId, int repeatCount)
  ///
  /// Callback for when JET's currently playing segment's userID is updated.
  ///@param player the JET player the status update is coming from
  ///@param userId the ID of the currently playing segment
  ///@param repeatCount the repetition count for the segment (0 means it plays once)
  void onJetUserIdUpdate(JetPlayer player, int userId, int repeatCount) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onJetUserIdUpdate,
          jni.JniType.voidType,
          [player.reference, userId, repeatCount]).check();

  static final _id_onJetNumQueuedSegmentUpdate = jniAccessors.getMethodIDOf(
      _classRef,
      "onJetNumQueuedSegmentUpdate",
      "(Landroid/media/JetPlayer;I)V");

  /// from: public abstract void onJetNumQueuedSegmentUpdate(android.media.JetPlayer player, int nbSegments)
  ///
  /// Callback for when JET's number of queued segments is updated.
  ///@param player the JET player the status update is coming from
  ///@param nbSegments the number of segments in the JET queue
  void onJetNumQueuedSegmentUpdate(JetPlayer player, int nbSegments) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onJetNumQueuedSegmentUpdate,
          jni.JniType.voidType,
          [player.reference, nbSegments]).check();

  static final _id_onJetPauseUpdate = jniAccessors.getMethodIDOf(
      _classRef, "onJetPauseUpdate", "(Landroid/media/JetPlayer;I)V");

  /// from: public abstract void onJetPauseUpdate(android.media.JetPlayer player, int paused)
  ///
  /// Callback for when JET pause state is updated.
  ///@param player the JET player the status update is coming from
  ///@param paused indicates whether JET is paused (1) or not (0)
  void onJetPauseUpdate(JetPlayer player, int paused) =>
      jniAccessors.callMethodWithArgs(reference, _id_onJetPauseUpdate,
          jni.JniType.voidType, [player.reference, paused]).check();
}
