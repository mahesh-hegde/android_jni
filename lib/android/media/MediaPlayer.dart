// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/SurfaceHolder.dart" as surfaceholder_;

import "../view/Surface.dart" as surface_;

import "../content/Context.dart" as context_;

import "../net/Uri.dart" as uri_;

import "AudioAttributes.dart" as audioattributes_;

import "../content/res/AssetFileDescriptor.dart" as assetfiledescriptor_;

import "MediaDataSource.dart" as mediadatasource_;

import "VolumeShaper.dart" as volumeshaper_;

import "AudioDeviceInfo.dart" as audiodeviceinfo_;

import "AudioRouting.dart" as audiorouting_;

import "../os/Handler.dart" as handler_;

import "../os/PersistableBundle.dart" as persistablebundle_;

import "PlaybackParams.dart" as playbackparams_;

import "SyncParams.dart" as syncparams_;

import "MediaTimestamp.dart" as mediatimestamp_;

import "MediaDrm.dart" as mediadrm_;

import "MediaFormat.dart" as mediaformat_;

import "../os/Parcel.dart" as parcel_;

import "MediaDrmException.dart" as mediadrmexception_;

import "TimedText.dart" as timedtext_;

import "TimedMetaData.dart" as timedmetadata_;

import "SubtitleData.dart" as subtitledata_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaPlayer
///
/// MediaPlayer class can be used to control playback
/// of audio/video files and streams. An example on how to use the methods in
/// this class can be found in android.widget.VideoView.
///
/// Topics covered here are:
/// <ol>
/// <li><a href="\#StateDiagram">State Diagram</a>
/// <li><a href="\#Valid_and_Invalid_States">Valid and Invalid States</a>
/// <li><a href="\#Permissions">Permissions</a>
/// <li><a href="\#Callbacks">Register informational and error callbacks</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about how to use MediaPlayer, read the
/// <a href="{@docRoot}guide/topics/media/mediaplayer.html">Media Playback</a> developer guide.
///
/// </div>
///
/// <a name="StateDiagram"></a>
/// <h3>State Diagram</h3>
///
/// Playback control of audio/video files and streams is managed as a state
/// machine. The following diagram shows the life cycle and the states of a
/// MediaPlayer object driven by the supported playback control operations.
/// The ovals represent the states a MediaPlayer object may reside
/// in. The arcs represent the playback control operations that drive the object
/// state transition. There are two types of arcs. The arcs with a single arrow
/// head represent synchronous method calls, while those with
/// a double arrow head represent asynchronous method calls.
///
///
/// <img src="../../../images/mediaplayer_state_diagram.gif"alt="MediaPlayer State diagram"border="0"/>
///
///
/// From this state diagram, one can see that a MediaPlayer object has the
///    following states:
///
/// <ul>
///     <li>When a MediaPlayer object is just created using <code>new</code> or
///         after \#reset() is called, it is in the _Idle_ state; and after
///         \#release() is called, it is in the _End_ state. Between these
///         two states is the life cycle of the MediaPlayer object.
///         <ul>
///         <li>There is a subtle but important difference between a newly constructed
///         MediaPlayer object and the MediaPlayer object after \#reset()
///         is called. It is a programming error to invoke methods such
///         as \#getCurrentPosition(),
///         \#getDuration(), \#getVideoHeight(),
///         \#getVideoWidth(), \#setAudioAttributes(AudioAttributes),
///         \#setLooping(boolean),
///         \#setVolume(float, float), \#pause(), \#start(),
///         \#stop(), \#seekTo(long, int), \#prepare() or
///         \#prepareAsync() in the _Idle_ state for both cases. If any of these
///         methods is called right after a MediaPlayer object is constructed,
///         the user supplied callback method OnErrorListener.onError() won't be
///         called by the internal player engine and the object state remains
///         unchanged; but if these methods are called right after \#reset(),
///         the user supplied callback method OnErrorListener.onError() will be
///         invoked by the internal player engine and the object will be
///         transfered to the _Error_ state. </li>
///         <li>It is also recommended that once
///         a MediaPlayer object is no longer being used, call \#release() immediately
///         so that resources used by the internal player engine associated with the
///         MediaPlayer object can be released immediately. Resource may include
///         singleton resources such as hardware acceleration components and
///         failure to call \#release() may cause subsequent instances of
///         MediaPlayer objects to fallback to software implementations or fail
///         altogether. Once the MediaPlayer
///         object is in the _End_ state, it can no longer be used and
///         there is no way to bring it back to any other state. </li>
///         <li>Furthermore,
///         the MediaPlayer objects created using <code>new</code> is in the
///         _Idle_ state, while those created with one
///         of the overloaded convenient <code>create</code> methods are _NOT_
///         in the _Idle_ state. In fact, the objects are in the _Prepared_
///         state if the creation using <code>create</code> method is successful.
///         </li>
///         </ul>
///         </li>
///     <li>In general, some playback control operation may fail due to various
///         reasons, such as unsupported audio/video format, poorly interleaved
///         audio/video, resolution too high, streaming timeout, and the like.
///         Thus, error reporting and recovery is an important concern under
///         these circumstances. Sometimes, due to programming errors, invoking a playback
///         control operation in an invalid state may also occur. Under all these
///         error conditions, the internal player engine invokes a user supplied
///         OnErrorListener.onError() method if an OnErrorListener has been
///         registered beforehand via
///         \#setOnErrorListener(android.media.MediaPlayer.OnErrorListener).
///         <ul>
///         <li>It is important to note that once an error occurs, the
///         MediaPlayer object enters the _Error_ state (except as noted
///         above), even if an error listener has not been registered by the application.</li>
///         <li>In order to reuse a MediaPlayer object that is in the _
///         Error_ state and recover from the error,
///         \#reset() can be called to restore the object to its _Idle_
///         state.</li>
///         <li>It is good programming practice to have your application
///         register a OnErrorListener to look out for error notifications from
///         the internal player engine.</li>
///         <li>IllegalStateException is
///         thrown to prevent programming errors such as calling \#prepare(),
///         \#prepareAsync(), or one of the overloaded <code>setDataSource
///         </code> methods in an invalid state. </li>
///         </ul>
///         </li>
///     <li>Calling
///         \#setDataSource(FileDescriptor), or
///         \#setDataSource(String), or
///         \#setDataSource(Context, Uri), or
///         \#setDataSource(FileDescriptor, long, long), or
///         \#setDataSource(MediaDataSource) transfers a
///         MediaPlayer object in the _Idle_ state to the
///         _Initialized_ state.
///         <ul>
///         <li>An IllegalStateException is thrown if
///         setDataSource() is called in any other state.</li>
///         <li>It is good programming
///         practice to always look out for <code>IllegalArgumentException</code>
///         and <code>IOException</code> that may be thrown from the overloaded
///         <code>setDataSource</code> methods.</li>
///         </ul>
///         </li>
///     <li>A MediaPlayer object must first enter the _Prepared_ state
///         before playback can be started.
///         <ul>
///         <li>There are two ways (synchronous vs.
///         asynchronous) that the _Prepared_ state can be reached:
///         either a call to \#prepare() (synchronous) which
///         transfers the object to the _Prepared_ state once the method call
///         returns, or a call to \#prepareAsync() (asynchronous) which
///         first transfers the object to the _Preparing_ state after the
///         call returns (which occurs almost right way) while the internal
///         player engine continues working on the rest of preparation work
///         until the preparation work completes. When the preparation completes or when \#prepare() call returns,
///         the internal player engine then calls a user supplied callback method,
///         onPrepared() of the OnPreparedListener interface, if an
///         OnPreparedListener is registered beforehand via \#setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener).</li>
///         <li>It is important to note that
///         the _Preparing_ state is a transient state, and the behavior
///         of calling any method with side effect while a MediaPlayer object is
///         in the _Preparing_ state is undefined.</li>
///         <li>An IllegalStateException is
///         thrown if \#prepare() or \#prepareAsync() is called in
///         any other state.</li>
///         <li>While in the _Prepared_ state, properties
///         such as audio/sound volume, screenOnWhilePlaying, looping can be
///         adjusted by invoking the corresponding set methods.</li>
///         </ul>
///         </li>
///     <li>To start the playback, \#start() must be called. After
///         \#start() returns successfully, the MediaPlayer object is in the
///         _Started_ state. \#isPlaying() can be called to test
///         whether the MediaPlayer object is in the _Started_ state.
///         <ul>
///         <li>While in the _Started_ state, the internal player engine calls
///         a user supplied OnBufferingUpdateListener.onBufferingUpdate() callback
///         method if a OnBufferingUpdateListener has been registered beforehand
///         via \#setOnBufferingUpdateListener(OnBufferingUpdateListener).
///         This callback allows applications to keep track of the buffering status
///         while streaming audio/video.</li>
///         <li>Calling \#start() has not effect
///         on a MediaPlayer object that is already in the _Started_ state.</li>
///         </ul>
///         </li>
///     <li>Playback can be paused and stopped, and the current playback position
///         can be adjusted. Playback can be paused via \#pause(). When the call to
///         \#pause() returns, the MediaPlayer object enters the
///         _Paused_ state. Note that the transition from the _Started_
///         state to the _Paused_ state and vice versa happens
///         asynchronously in the player engine. It may take some time before
///         the state is updated in calls to \#isPlaying(), and it can be
///         a number of seconds in the case of streamed content.
///         <ul>
///         <li>Calling \#start() to resume playback for a paused
///         MediaPlayer object, and the resumed playback
///         position is the same as where it was paused. When the call to
///         \#start() returns, the paused MediaPlayer object goes back to
///         the _Started_ state.</li>
///         <li>Calling \#pause() has no effect on
///         a MediaPlayer object that is already in the _Paused_ state.</li>
///         </ul>
///         </li>
///     <li>Calling  \#stop() stops playback and causes a
///         MediaPlayer in the _Started_, _Paused_, _Prepared
///         _ or _PlaybackCompleted_ state to enter the
///         _Stopped_ state.
///         <ul>
///         <li>Once in the _Stopped_ state, playback cannot be started
///         until \#prepare() or \#prepareAsync() are called to set
///         the MediaPlayer object to the _Prepared_ state again.</li>
///         <li>Calling \#stop() has no effect on a MediaPlayer
///         object that is already in the _Stopped_ state.</li>
///         </ul>
///         </li>
///     <li>The playback position can be adjusted with a call to
///         \#seekTo(long, int).
///         <ul>
///         <li>Although the asynchronuous \#seekTo(long, int)
///         call returns right away, the actual seek operation may take a while to
///         finish, especially for audio/video being streamed. When the actual
///         seek operation completes, the internal player engine calls a user
///         supplied OnSeekComplete.onSeekComplete() if an OnSeekCompleteListener
///         has been registered beforehand via
///         \#setOnSeekCompleteListener(OnSeekCompleteListener).</li>
///         <li>Please
///         note that \#seekTo(long, int) can also be called in the other states,
///         such as _Prepared_, _Paused_ and _PlaybackCompleted
///         _ state. When \#seekTo(long, int) is called in those states,
///         one video frame will be displayed if the stream has video and the requested
///         position is valid.
///         </li>
///         <li>Furthermore, the actual current playback position
///         can be retrieved with a call to \#getCurrentPosition(), which
///         is helpful for applications such as a Music player that need to keep
///         track of the playback progress.</li>
///         </ul>
///         </li>
///     <li>When the playback reaches the end of stream, the playback completes.
///         <ul>
///         <li>If the looping mode was being set to <var>true</var>with
///         \#setLooping(boolean), the MediaPlayer object shall remain in
///         the _Started_ state.</li>
///         <li>If the looping mode was set to <var>false
///         </var>, the player engine calls a user supplied callback method,
///         OnCompletion.onCompletion(), if a OnCompletionListener is registered
///         beforehand via \#setOnCompletionListener(OnCompletionListener).
///         The invoke of the callback signals that the object is now in the _
///         PlaybackCompleted_ state.</li>
///         <li>While in the _PlaybackCompleted_
///         state, calling \#start() can restart the playback from the
///         beginning of the audio/video source.</li>
/// </ul>
///
///
/// <a name="Valid_and_Invalid_States"></a>
/// <h3>Valid and invalid states</h3>
///
/// <table border="0"cellspacing="0"cellpadding="0">
/// <tr><td>Method Name
///</td>
///     <td>Valid Sates
///</td>
///     <td>Invalid States
///</td>
///     <td>Comments
///</td></tr>
/// <tr><td>attachAuxEffect
///</td>
///     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted}
///</td>
///     <td>{Idle, Error}
///</td>
///     <td>This method must be called after setDataSource.
///     Calling it does not change the object state.
///</td></tr>
/// <tr><td>getAudioSessionId
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>getCurrentPosition
///</td>
///     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
///         PlaybackCompleted}
///</td>
///     <td>{Error}
///</td>
///     <td>Successful invoke of this method in a valid state does not change the
///         state. Calling this method in an invalid state transfers the object
///         to the _Error_ state.
///</td></tr>
/// <tr><td>getDuration
///</td>
///     <td>{Prepared, Started, Paused, Stopped, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Error}
///</td>
///     <td>Successful invoke of this method in a valid state does not change the
///         state. Calling this method in an invalid state transfers the object
///         to the _Error_ state.
///</td></tr>
/// <tr><td>getVideoHeight
///</td>
///     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
///         PlaybackCompleted}
///</td>
///     <td>{Error}
///</td>
///     <td>Successful invoke of this method in a valid state does not change the
///         state. Calling this method in an invalid state transfers the object
///         to the _Error_ state.
///</td></tr>
/// <tr><td>getVideoWidth
///</td>
///     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
///         PlaybackCompleted}
///</td>
///     <td>{Error}
///</td>
///     <td>Successful invoke of this method in a valid state does not change
///         the state. Calling this method in an invalid state transfers the
///         object to the _Error_ state.
///</td></tr>
/// <tr><td>isPlaying
///</td>
///     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
///          PlaybackCompleted}
///</td>
///     <td>{Error}
///</td>
///     <td>Successful invoke of this method in a valid state does not change
///         the state. Calling this method in an invalid state transfers the
///         object to the _Error_ state.
///</td></tr>
/// <tr><td>pause
///</td>
///     <td>{Started, Paused, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Prepared, Stopped, Error}
///</td>
///     <td>Successful invoke of this method in a valid state transfers the
///         object to the _Paused_ state. Calling this method in an
///         invalid state transfers the object to the _Error_ state.
///</td></tr>
/// <tr><td>prepare
///</td>
///     <td>{Initialized, Stopped}
///</td>
///     <td>{Idle, Prepared, Started, Paused, PlaybackCompleted, Error}
///</td>
///     <td>Successful invoke of this method in a valid state transfers the
///         object to the _Prepared_ state. Calling this method in an
///         invalid state throws an IllegalStateException.
///</td></tr>
/// <tr><td>prepareAsync
///</td>
///     <td>{Initialized, Stopped}
///</td>
///     <td>{Idle, Prepared, Started, Paused, PlaybackCompleted, Error}
///</td>
///     <td>Successful invoke of this method in a valid state transfers the
///         object to the _Preparing_ state. Calling this method in an
///         invalid state throws an IllegalStateException.
///</td></tr>
/// <tr><td>release
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>After \#release(), the object is no longer available.
///</td></tr>
/// <tr><td>reset
///</td>
///     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
///         PlaybackCompleted, Error}
///</td>
///     <td>{}
///</td>
///     <td>After \#reset(), the object is like being just created.
///</td></tr>
/// <tr><td>seekTo
///</td>
///     <td>{Prepared, Started, Paused, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Stopped, Error}
///</td>
///     <td>Successful invoke of this method in a valid state does not change
///         the state. Calling this method in an invalid state transfers the
///         object to the _Error_ state.
///</td></tr>
/// <tr><td>setAudioAttributes
///</td>
///     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,
///          PlaybackCompleted}
///</td>
///     <td>{Error}
///</td>
///     <td>Successful invoke of this method does not change the state. In order for the
///         target audio attributes type to become effective, this method must be called before
///         prepare() or prepareAsync().
///</td></tr>
/// <tr><td>setAudioSessionId
///</td>
///     <td>{Idle}
///</td>
///     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted,
///          Error}
///</td>
///     <td>This method must be called in idle state as the audio session ID must be known before
///         calling setDataSource. Calling it does not change the object state.
///</td></tr>
/// <tr><td>setAudioStreamType (deprecated)
///</td>
///     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,
///          PlaybackCompleted}
///</td>
///     <td>{Error}
///</td>
///     <td>Successful invoke of this method does not change the state. In order for the
///         target audio stream type to become effective, this method must be called before
///         prepare() or prepareAsync().
///</td></tr>
/// <tr><td>setAuxEffectSendLevel
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>Calling this method does not change the object state.
///</td></tr>
/// <tr><td>setDataSource
///</td>
///     <td>{Idle}
///</td>
///     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted,
///          Error}
///</td>
///     <td>Successful invoke of this method in a valid state transfers the
///         object to the _Initialized_ state. Calling this method in an
///         invalid state throws an IllegalStateException.
///</td></tr>
/// <tr><td>setDisplay
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setSurface
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setVideoScalingMode
///</td>
///     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted}
///</td>
///     <td>{Idle, Error}
///</td>
///     <td>Successful invoke of this method does not change the state.
///</td></tr>
/// <tr><td>setLooping
///</td>
///     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,
///         PlaybackCompleted}
///</td>
///     <td>{Error}
///</td>
///     <td>Successful invoke of this method in a valid state does not change
///         the state. Calling this method in an
///         invalid state transfers the object to the _Error_ state.
///</td></tr>
/// <tr><td>isLooping
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setOnBufferingUpdateListener
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setOnCompletionListener
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setOnErrorListener
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setOnPreparedListener
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setOnSeekCompleteListener
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setPlaybackParams
///</td>
///     <td>{Initialized, Prepared, Started, Paused, PlaybackCompleted, Error}
///</td>
///     <td>{Idle, Stopped}
///</td>
///     <td>This method will change state in some cases, depending on when it's called.
///
///</td></tr>
/// <tr><td>setScreenOnWhilePlaying</></td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>setVolume
///</td>
///     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,
///          PlaybackCompleted}
///</td>
///     <td>{Error}
///</td>
///     <td>Successful invoke of this method does not change the state.
/// <tr><td>setWakeMode
///</td>
///     <td>any
///</td>
///     <td>{}
///</td>
///     <td>This method can be called in any state and calling it does not change
///         the object state.
///</td></tr>
/// <tr><td>start
///</td>
///     <td>{Prepared, Started, Paused, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Stopped, Error}
///</td>
///     <td>Successful invoke of this method in a valid state transfers the
///         object to the _Started_ state. Calling this method in an
///         invalid state transfers the object to the _Error_ state.
///</td></tr>
/// <tr><td>stop
///</td>
///     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Error}
///</td>
///     <td>Successful invoke of this method in a valid state transfers the
///         object to the _Stopped_ state. Calling this method in an
///         invalid state transfers the object to the _Error_ state.
///</td></tr>
/// <tr><td>getTrackInfo
///</td>
///     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Error}
///</td>
///     <td>Successful invoke of this method does not change the state.
///</td></tr>
/// <tr><td>addTimedTextSource
///</td>
///     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Error}
///</td>
///     <td>Successful invoke of this method does not change the state.
///</td></tr>
/// <tr><td>selectTrack
///</td>
///     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Error}
///</td>
///     <td>Successful invoke of this method does not change the state.
///</td></tr>
/// <tr><td>deselectTrack
///</td>
///     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}
///</td>
///     <td>{Idle, Initialized, Error}
///</td>
///     <td>Successful invoke of this method does not change the state.
///</td></tr>
///
/// </table>
///
/// <a name="Permissions"></a>
/// <h3>Permissions</h3>
/// One may need to declare a corresponding WAKE_LOCK permission android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt;
/// element.
///
/// This class requires the android.Manifest.permission\#INTERNET permission
/// when used with network-based content.
///
/// <a name="Callbacks"></a>
/// <h3>Callbacks</h3>
/// Applications may want to register for informational and error
/// events in order to be informed of some internal state update and
/// possible runtime errors during playback or streaming. Registration for
/// these events is done by properly setting the appropriate listeners (via calls
/// to
/// \#setOnPreparedListener(OnPreparedListener)setOnPreparedListener,
/// \#setOnVideoSizeChangedListener(OnVideoSizeChangedListener)setOnVideoSizeChangedListener,
/// \#setOnSeekCompleteListener(OnSeekCompleteListener)setOnSeekCompleteListener,
/// \#setOnCompletionListener(OnCompletionListener)setOnCompletionListener,
/// \#setOnBufferingUpdateListener(OnBufferingUpdateListener)setOnBufferingUpdateListener,
/// \#setOnInfoListener(OnInfoListener)setOnInfoListener,
/// \#setOnErrorListener(OnErrorListener)setOnErrorListener, etc).
/// In order to receive the respective callback
/// associated with these listeners, applications are required to create
/// MediaPlayer objects on a thread with its own Looper running (main UI
/// thread by default has a Looper running).
class MediaPlayer extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/media/MediaPlayer");
  MediaPlayer.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MEDIA_ERROR_IO
  ///
  /// File or network related operation errors.
  static const MEDIA_ERROR_IO = -1004;

  /// from: static public final int MEDIA_ERROR_MALFORMED
  ///
  /// Bitstream is not conforming to the related coding standard or file spec.
  static const MEDIA_ERROR_MALFORMED = -1007;

  /// from: static public final int MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK
  ///
  /// The video is streamed and its container is not valid for progressive
  /// playback i.e the video's index (e.g moov atom) is not at the start of the
  /// file.
  ///@see android.media.MediaPlayer.OnErrorListener
  static const MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = 200;

  /// from: static public final int MEDIA_ERROR_SERVER_DIED
  ///
  /// Media server died. In this case, the application must release the
  /// MediaPlayer object and instantiate a new one.
  ///@see android.media.MediaPlayer.OnErrorListener
  static const MEDIA_ERROR_SERVER_DIED = 100;

  /// from: static public final int MEDIA_ERROR_TIMED_OUT
  ///
  /// Some operation takes too long to complete, usually more than 3-5 seconds.
  static const MEDIA_ERROR_TIMED_OUT = -110;

  /// from: static public final int MEDIA_ERROR_UNKNOWN
  ///
  /// Unspecified media player error.
  ///@see android.media.MediaPlayer.OnErrorListener
  static const MEDIA_ERROR_UNKNOWN = 1;

  /// from: static public final int MEDIA_ERROR_UNSUPPORTED
  ///
  /// Bitstream is conforming to the related coding standard or file spec, but
  /// the media framework does not support the feature.
  static const MEDIA_ERROR_UNSUPPORTED = -1010;

  /// from: static public final int MEDIA_INFO_AUDIO_NOT_PLAYING
  ///
  /// Informs that audio is not playing. Note that playback of the video
  /// is not interrupted.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_AUDIO_NOT_PLAYING = 804;

  /// from: static public final int MEDIA_INFO_BAD_INTERLEAVING
  ///
  /// Bad interleaving means that a media has been improperly interleaved or
  /// not interleaved at all, e.g has all the video samples first then all the
  /// audio ones. Video is playing but a lot of disk seeks may be happening.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_BAD_INTERLEAVING = 800;

  /// from: static public final int MEDIA_INFO_BUFFERING_END
  ///
  /// MediaPlayer is resuming playback after filling buffers.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_BUFFERING_END = 702;

  /// from: static public final int MEDIA_INFO_BUFFERING_START
  ///
  /// MediaPlayer is temporarily pausing playback internally in order to
  /// buffer more data.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_BUFFERING_START = 701;

  /// from: static public final int MEDIA_INFO_METADATA_UPDATE
  ///
  /// A new set of metadata is available.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_METADATA_UPDATE = 802;

  /// from: static public final int MEDIA_INFO_NOT_SEEKABLE
  ///
  /// The media cannot be seeked (e.g live stream)
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_NOT_SEEKABLE = 801;

  /// from: static public final int MEDIA_INFO_STARTED_AS_NEXT
  ///
  /// The player was started because it was used as the next player for another
  /// player, which just completed playback.
  ///@see android.media.MediaPlayer\#setNextMediaPlayer(MediaPlayer)
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_STARTED_AS_NEXT = 2;

  /// from: static public final int MEDIA_INFO_SUBTITLE_TIMED_OUT
  ///
  /// Reading the subtitle track takes too long.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_SUBTITLE_TIMED_OUT = 902;

  /// from: static public final int MEDIA_INFO_UNKNOWN
  ///
  /// Unspecified media player info.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_UNKNOWN = 1;

  /// from: static public final int MEDIA_INFO_UNSUPPORTED_SUBTITLE
  ///
  /// Subtitle track was not supported by the media framework.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_UNSUPPORTED_SUBTITLE = 901;

  /// from: static public final int MEDIA_INFO_VIDEO_NOT_PLAYING
  ///
  /// Informs that video is not playing. Note that playback of the audio
  /// is not interrupted.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_VIDEO_NOT_PLAYING = 805;

  /// from: static public final int MEDIA_INFO_VIDEO_RENDERING_START
  ///
  /// The player just pushed the very first video frame for rendering.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_VIDEO_RENDERING_START = 3;

  /// from: static public final int MEDIA_INFO_VIDEO_TRACK_LAGGING
  ///
  /// The video is too complex for the decoder: it can't decode frames fast
  ///  enough. Possibly only the audio plays fine at this stage.
  ///@see android.media.MediaPlayer.OnInfoListener
  static const MEDIA_INFO_VIDEO_TRACK_LAGGING = 700;

  /// from: static public final java.lang.String MEDIA_MIMETYPE_TEXT_SUBRIP
  ///
  /// MIME type for SubRip (SRT) container. Used in addTimedTextSource APIs.
  ///@deprecated use MediaFormat\#MIMETYPE_TEXT_SUBRIP
  static const MEDIA_MIMETYPE_TEXT_SUBRIP = "application/x-subrip";

  /// from: static public final int PREPARE_DRM_STATUS_PREPARATION_ERROR
  ///
  /// The DRM preparation has failed .
  static const PREPARE_DRM_STATUS_PREPARATION_ERROR = 3;

  /// from: static public final int PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR
  ///
  /// The device required DRM provisioning but couldn't reach the provisioning server.
  static const PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR = 1;

  /// from: static public final int PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR
  ///
  /// The device required DRM provisioning but the provisioning server denied the request.
  static const PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR = 2;

  /// from: static public final int PREPARE_DRM_STATUS_SUCCESS
  ///
  /// The status codes for OnDrmPreparedListener\#onDrmPrepared listener.
  ///
  ///
  /// DRM preparation has succeeded.
  static const PREPARE_DRM_STATUS_SUCCESS = 0;

  /// from: static public final int SEEK_CLOSEST
  ///
  /// This mode is used with \#seekTo(long, int) to move media position to
  /// a frame (not necessarily a key frame) associated with a data source that
  /// is located closest to or at the given time.
  ///@see \#seekTo(long, int)
  static const SEEK_CLOSEST = 3;

  /// from: static public final int SEEK_CLOSEST_SYNC
  ///
  /// This mode is used with \#seekTo(long, int) to move media position to
  /// a sync (or key) frame associated with a data source that is located
  /// closest to (in time) or at the given time.
  ///@see \#seekTo(long, int)
  static const SEEK_CLOSEST_SYNC = 2;

  /// from: static public final int SEEK_NEXT_SYNC
  ///
  /// This mode is used with \#seekTo(long, int) to move media position to
  /// a sync (or key) frame associated with a data source that is located
  /// right after or at the given time.
  ///@see \#seekTo(long, int)
  static const SEEK_NEXT_SYNC = 1;

  /// from: static public final int SEEK_PREVIOUS_SYNC
  ///
  /// This mode is used with \#seekTo(long, int) to move media position to
  /// a sync (or key) frame associated with a data source that is located
  /// right before or at the given time.
  ///@see \#seekTo(long, int)
  static const SEEK_PREVIOUS_SYNC = 0;

  /// from: static public final int VIDEO_SCALING_MODE_SCALE_TO_FIT
  ///
  /// Specifies a video scaling mode. The content is stretched to the
  /// surface rendering area. When the surface has the same aspect ratio
  /// as the content, the aspect ratio of the content is maintained;
  /// otherwise, the aspect ratio of the content is not maintained when video
  /// is being rendered. Unlike \#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING,
  /// there is no content cropping with this video scaling mode.
  static const VIDEO_SCALING_MODE_SCALE_TO_FIT = 1;

  /// from: static public final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING
  ///
  /// Specifies a video scaling mode. The content is scaled, maintaining
  /// its aspect ratio. The whole surface area is always used. When the
  /// aspect ratio of the content is the same as the surface, no content
  /// is cropped; otherwise, content is cropped to fit the surface.
  static const VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default constructor. Consider using one of the create() methods for
  /// synchronously instantiating a MediaPlayer from a Uri or resource.
  /// When done with the MediaPlayer, you should call  \#release(),
  /// to free the resources. If not released, too many MediaPlayer instances may
  /// result in an exception.
  ///
  MediaPlayer()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setDisplay = jniAccessors.getMethodIDOf(
      _classRef, "setDisplay", "(Landroid/view/SurfaceHolder;)V");

  /// from: public void setDisplay(android.view.SurfaceHolder sh)
  ///
  /// Sets the SurfaceHolder to use for displaying the video
  /// portion of the media.
  ///
  /// Either a surface holder or surface must be set if a display or video sink
  /// is needed.  Not calling this method or \#setSurface(Surface)
  /// when playing back a video will result in only the audio track being played.
  /// A null surface holder or surface will result in only the audio track being
  /// played.
  ///@param sh the SurfaceHolder to use for video display
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized or has been released.
  void setDisplay(surfaceholder_.SurfaceHolder sh) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisplay,
          jni.JniType.voidType, [sh.reference]).check();

  static final _id_setSurface = jniAccessors.getMethodIDOf(
      _classRef, "setSurface", "(Landroid/view/Surface;)V");

  /// from: public void setSurface(android.view.Surface surface)
  ///
  /// Sets the Surface to be used as the sink for the video portion of
  /// the media. This is similar to \#setDisplay(SurfaceHolder), but
  /// does not support \#setScreenOnWhilePlaying(boolean).  Setting a
  /// Surface will un-set any Surface or SurfaceHolder that was previously set.
  /// A null surface will result in only the audio track being played.
  ///
  /// If the Surface sends frames to a SurfaceTexture, the timestamps
  /// returned from SurfaceTexture\#getTimestamp() will have an
  /// unspecified zero point.  These timestamps cannot be directly compared
  /// between different media sources, different instances of the same media
  /// source, or multiple runs of the same program.  The timestamp is normally
  /// monotonically increasing and is unaffected by time-of-day adjustments,
  /// but it is reset when the position is set.
  ///@param surface The Surface to be used for the video portion of
  /// the media.
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized or has been released.
  void setSurface(surface_.Surface surface) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSurface,
      jni.JniType.voidType,
      [surface.reference]).check();

  static final _id_setVideoScalingMode =
      jniAccessors.getMethodIDOf(_classRef, "setVideoScalingMode", "(I)V");

  /// from: public void setVideoScalingMode(int mode)
  ///
  /// Sets video scaling mode. To make the target video scaling mode
  /// effective during playback, this method must be called after
  /// data source is set. If not called, the default video
  /// scaling mode is \#VIDEO_SCALING_MODE_SCALE_TO_FIT.
  ///
  ///  The supported video scaling modes are:
  /// <ul>
  /// <li> \#VIDEO_SCALING_MODE_SCALE_TO_FIT
  /// <li> \#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING
  /// </ul>
  ///@param mode target video scaling mode. Must be one of the supported
  /// video scaling modes; otherwise, IllegalArgumentException will be thrown.
  ///@see MediaPlayer\#VIDEO_SCALING_MODE_SCALE_TO_FIT
  ///@see MediaPlayer\#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING
  void setVideoScalingMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setVideoScalingMode, jni.JniType.voidType, [mode]).check();

  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/content/Context;Landroid/net/Uri;)Landroid/media/MediaPlayer;");

  /// from: static public android.media.MediaPlayer create(android.content.Context context, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience method to create a MediaPlayer for a given Uri.
  /// On success, \#prepare() will already have been called and must not be called again.
  /// When done with the MediaPlayer, you should call  \#release(),
  /// to free the resources. If not released, too many MediaPlayer instances will
  /// result in an exception.
  ///
  /// Note that since \#prepare() is called automatically in this method,
  /// you cannot change the audio
  /// session ID (see \#setAudioSessionId(int)) or audio attributes
  /// (see \#setAudioAttributes(AudioAttributes) of the new MediaPlayer.
  ///
  ///@param context the Context to use
  ///@param uri the Uri from which to get the datasource
  ///@return a MediaPlayer object, or null if creation failed
  static MediaPlayer create(context_.Context context, uri_.Uri uri) =>
      MediaPlayer.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create,
          jni.JniType.objectType,
          [context.reference, uri.reference]).object);

  static final _id_create1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/content/Context;Landroid/net/Uri;Landroid/view/SurfaceHolder;)Landroid/media/MediaPlayer;");

  /// from: static public android.media.MediaPlayer create(android.content.Context context, android.net.Uri uri, android.view.SurfaceHolder holder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience method to create a MediaPlayer for a given Uri.
  /// On success, \#prepare() will already have been called and must not be called again.
  /// When done with the MediaPlayer, you should call  \#release(),
  /// to free the resources. If not released, too many MediaPlayer instances will
  /// result in an exception.
  ///
  /// Note that since \#prepare() is called automatically in this method,
  /// you cannot change the audio
  /// session ID (see \#setAudioSessionId(int)) or audio attributes
  /// (see \#setAudioAttributes(AudioAttributes) of the new MediaPlayer.
  ///
  ///@param context the Context to use
  ///@param uri the Uri from which to get the datasource
  ///@param holder the SurfaceHolder to use for displaying the video
  ///@return a MediaPlayer object, or null if creation failed
  static MediaPlayer create1(context_.Context context, uri_.Uri uri,
          surfaceholder_.SurfaceHolder holder) =>
      MediaPlayer.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create1,
          jni.JniType.objectType,
          [context.reference, uri.reference, holder.reference]).object);

  static final _id_create2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/content/Context;Landroid/net/Uri;Landroid/view/SurfaceHolder;Landroid/media/AudioAttributes;I)Landroid/media/MediaPlayer;");

  /// from: static public android.media.MediaPlayer create(android.content.Context context, android.net.Uri uri, android.view.SurfaceHolder holder, android.media.AudioAttributes audioAttributes, int audioSessionId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same factory method as \#create(Context, Uri, SurfaceHolder) but that lets you specify
  /// the audio attributes and session ID to be used by the new MediaPlayer instance.
  ///@param context the Context to use
  ///@param uri the Uri from which to get the datasource
  ///@param holder the SurfaceHolder to use for displaying the video, may be null.
  ///@param audioAttributes the AudioAttributes to be used by the media player.
  ///@param audioSessionId the audio session ID to be used by the media player,
  ///     see AudioManager\#generateAudioSessionId() to obtain a new session.
  ///@return a MediaPlayer object, or null if creation failed
  static MediaPlayer create2(
          context_.Context context,
          uri_.Uri uri,
          surfaceholder_.SurfaceHolder holder,
          audioattributes_.AudioAttributes audioAttributes,
          int audioSessionId) =>
      MediaPlayer.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_create2, jni.JniType.objectType, [
        context.reference,
        uri.reference,
        holder.reference,
        audioAttributes.reference,
        audioSessionId
      ]).object);

  static final _id_create3 = jniAccessors.getStaticMethodIDOf(_classRef,
      "create", "(Landroid/content/Context;I)Landroid/media/MediaPlayer;");

  /// from: static public android.media.MediaPlayer create(android.content.Context context, int resid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience method to create a MediaPlayer for a given resource id.
  /// On success, \#prepare() will already have been called and must not be called again.
  /// When done with the MediaPlayer, you should call  \#release(),
  /// to free the resources. If not released, too many MediaPlayer instances will
  /// result in an exception.
  ///
  /// Note that since \#prepare() is called automatically in this method,
  /// you cannot change the audio
  /// session ID (see \#setAudioSessionId(int)) or audio attributes
  /// (see \#setAudioAttributes(AudioAttributes) of the new MediaPlayer.
  ///
  ///@param context the Context to use
  ///@param resid the raw resource id (<var>R.raw.&lt;something></var>) for
  ///              the resource to use as the datasource
  ///@return a MediaPlayer object, or null if creation failed
  static MediaPlayer create3(context_.Context context, int resid) =>
      MediaPlayer.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create3,
          jni.JniType.objectType,
          [context.reference, resid]).object);

  static final _id_create4 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/content/Context;ILandroid/media/AudioAttributes;I)Landroid/media/MediaPlayer;");

  /// from: static public android.media.MediaPlayer create(android.content.Context context, int resid, android.media.AudioAttributes audioAttributes, int audioSessionId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same factory method as \#create(Context, int) but that lets you specify the audio
  /// attributes and session ID to be used by the new MediaPlayer instance.
  ///@param context the Context to use
  ///@param resid the raw resource id (<var>R.raw.&lt;something></var>) for
  ///              the resource to use as the datasource
  ///@param audioAttributes the AudioAttributes to be used by the media player.
  ///@param audioSessionId the audio session ID to be used by the media player,
  ///     see AudioManager\#generateAudioSessionId() to obtain a new session.
  ///@return a MediaPlayer object, or null if creation failed
  static MediaPlayer create4(
          context_.Context context,
          int resid,
          audioattributes_.AudioAttributes audioAttributes,
          int audioSessionId) =>
      MediaPlayer.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_create4, jni.JniType.objectType, [
        context.reference,
        resid,
        audioAttributes.reference,
        audioSessionId
      ]).object);

  static final _id_setDataSource = jniAccessors.getMethodIDOf(_classRef,
      "setDataSource", "(Landroid/content/Context;Landroid/net/Uri;)V");

  /// from: public void setDataSource(android.content.Context context, android.net.Uri uri)
  ///
  /// Sets the data source as a content Uri.
  ///@param context the Context to use when resolving the Uri
  /// This value must never be {@code null}.
  ///@param uri the Content URI of the data you want to play
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if it is called in an invalid state
  void setDataSource(context_.Context context, uri_.Uri uri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource,
          jni.JniType.voidType, [context.reference, uri.reference]).check();

  static final _id_setDataSource1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setDataSource",
      "(Landroid/content/Context;Landroid/net/Uri;Ljava/util/Map;Ljava/util/List;)V");

  /// from: public void setDataSource(android.content.Context context, android.net.Uri uri, java.util.Map<java.lang.String,java.lang.String> headers, java.util.List<java.net.HttpCookie> cookies)
  ///
  /// Sets the data source as a content Uri.
  ///
  /// To provide cookies for the subsequent HTTP requests, you can install your own default cookie
  /// handler and use other variants of setDataSource APIs instead. Alternatively, you can use
  /// this API to pass the cookies as a list of HttpCookie. If the app has not installed
  /// a CookieHandler already, this API creates a CookieManager and populates its CookieStore with
  /// the provided cookies. If the app has installed its own handler already, this API requires the
  /// handler to be of CookieManager type such that the API can update the manager\u2019s CookieStore.
  ///
  /// <strong>Note</strong> that the cross domain redirection is allowed by default,
  /// but that can be changed with key/value pairs through the headers parameter with
  /// "android-allow-cross-domain-redirect" as the key and "0" or "1" as the value to
  /// disallow or allow cross domain redirection.
  ///@param context the Context to use when resolving the Uri
  /// This value must never be {@code null}.
  ///@param uri the Content URI of the data you want to play
  /// This value must never be {@code null}.
  ///@param headers the headers to be sent together with the request for the data
  ///                The headers must not include cookies. Instead, use the cookies param.
  /// This value may be {@code null}.
  ///@param cookies the cookies to be sent together with the request
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if cookies are provided and the installed handler is not
  ///                                  a CookieManager
  ///@throws IllegalStateException if it is called in an invalid state
  ///@throws NullPointerException if context or uri is null
  ///@throws IOException if uri has a file scheme and an I/O error occurs
  void setDataSource1(context_.Context context, uri_.Uri uri,
          jni.JniObject headers, jni.JniObject cookies) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setDataSource1, jni.JniType.voidType, [
        context.reference,
        uri.reference,
        headers.reference,
        cookies.reference
      ]).check();

  static final _id_setDataSource2 = jniAccessors.getMethodIDOf(
      _classRef,
      "setDataSource",
      "(Landroid/content/Context;Landroid/net/Uri;Ljava/util/Map;)V");

  /// from: public void setDataSource(android.content.Context context, android.net.Uri uri, java.util.Map<java.lang.String,java.lang.String> headers)
  ///
  /// Sets the data source as a content Uri.
  ///
  /// <strong>Note</strong> that the cross domain redirection is allowed by default,
  /// but that can be changed with key/value pairs through the headers parameter with
  /// "android-allow-cross-domain-redirect" as the key and "0" or "1" as the value to
  /// disallow or allow cross domain redirection.
  ///@param context the Context to use when resolving the Uri
  /// This value must never be {@code null}.
  ///@param uri the Content URI of the data you want to play
  /// This value must never be {@code null}.
  ///@param headers the headers to be sent together with the request for the data
  /// This value may be {@code null}.
  ///@throws IllegalStateException if it is called in an invalid state
  void setDataSource2(
          context_.Context context, uri_.Uri uri, jni.JniObject headers) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDataSource2,
          jni.JniType.voidType,
          [context.reference, uri.reference, headers.reference]).check();

  static final _id_setDataSource3 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/lang/String;)V");

  /// from: public void setDataSource(java.lang.String path)
  ///
  /// Sets the data source (file-path or http/rtsp URL) to use.
  ///
  /// When <code>path</code> refers to a local file, the file may actually be opened by a
  /// process other than the calling application.  This implies that the pathname
  /// should be an absolute path (as any other process runs with unspecified current working
  /// directory), and that the pathname should reference a world-readable file.
  /// As an alternative, the application could first open the file for reading,
  /// and then use the file descriptor form \#setDataSource(FileDescriptor).
  ///@param path the path of the file, or the http/rtsp URL of the stream you want to play
  ///@throws IllegalStateException if it is called in an invalid state
  void setDataSource3(jni.JniString path) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDataSource3,
      jni.JniType.voidType,
      [path.reference]).check();

  static final _id_setDataSource4 = jniAccessors.getMethodIDOf(_classRef,
      "setDataSource", "(Landroid/content/res/AssetFileDescriptor;)V");

  /// from: public void setDataSource(android.content.res.AssetFileDescriptor afd)
  ///
  /// Sets the data source (AssetFileDescriptor) to use. It is the caller's
  /// responsibility to close the file descriptor. It is safe to do so as soon
  /// as this call returns.
  ///@param afd the AssetFileDescriptor for the file you want to play
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if it is called in an invalid state
  ///@throws IllegalArgumentException if afd is not a valid AssetFileDescriptor
  ///@throws IOException if afd can not be read
  void setDataSource4(assetfiledescriptor_.AssetFileDescriptor afd) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource4,
          jni.JniType.voidType, [afd.reference]).check();

  static final _id_setDataSource5 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/io/FileDescriptor;)V");

  /// from: public void setDataSource(java.io.FileDescriptor fd)
  ///
  /// Sets the data source (FileDescriptor) to use. It is the caller's responsibility
  /// to close the file descriptor. It is safe to do so as soon as this call returns.
  ///@param fd the FileDescriptor for the file you want to play
  ///@throws IllegalStateException if it is called in an invalid state
  ///@throws IllegalArgumentException if fd is not a valid FileDescriptor
  ///@throws IOException if fd can not be read
  void setDataSource5(jni.JniObject fd) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDataSource5,
      jni.JniType.voidType,
      [fd.reference]).check();

  static final _id_setDataSource6 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Ljava/io/FileDescriptor;JJ)V");

  /// from: public void setDataSource(java.io.FileDescriptor fd, long offset, long length)
  ///
  /// Sets the data source (FileDescriptor) to use.  The FileDescriptor must be
  /// seekable (N.B. a LocalSocket is not seekable). It is the caller's responsibility
  /// to close the file descriptor. It is safe to do so as soon as this call returns.
  ///@param fd the FileDescriptor for the file you want to play
  ///@param offset the offset into the file where the data to be played starts, in bytes
  ///@param length the length in bytes of the data to be played
  ///@throws IllegalStateException if it is called in an invalid state
  ///@throws IllegalArgumentException if fd is not a valid FileDescriptor
  ///@throws IOException if fd can not be read
  void setDataSource6(jni.JniObject fd, int offset, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource6,
          jni.JniType.voidType, [fd.reference, offset, length]).check();

  static final _id_setDataSource7 = jniAccessors.getMethodIDOf(
      _classRef, "setDataSource", "(Landroid/media/MediaDataSource;)V");

  /// from: public void setDataSource(android.media.MediaDataSource dataSource)
  ///
  /// Sets the data source (MediaDataSource) to use.
  ///@param dataSource the MediaDataSource for the media you want to play
  ///@throws IllegalStateException if it is called in an invalid state
  ///@throws IllegalArgumentException if dataSource is not a valid MediaDataSource
  void setDataSource7(mediadatasource_.MediaDataSource dataSource) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDataSource7,
          jni.JniType.voidType, [dataSource.reference]).check();

  static final _id_prepare =
      jniAccessors.getMethodIDOf(_classRef, "prepare", "()V");

  /// from: public void prepare()
  ///
  /// Prepares the player for playback, synchronously.
  ///
  /// After setting the datasource and the display surface, you need to either
  /// call prepare() or prepareAsync(). For files, it is OK to call prepare(),
  /// which blocks until MediaPlayer is ready for playback.
  ///@throws IllegalStateException if it is called in an invalid state
  void prepare() => jniAccessors.callMethodWithArgs(
      reference, _id_prepare, jni.JniType.voidType, []).check();

  static final _id_prepareAsync =
      jniAccessors.getMethodIDOf(_classRef, "prepareAsync", "()V");

  /// from: public native void prepareAsync()
  ///
  /// Prepares the player for playback, asynchronously.
  ///
  /// After setting the datasource and the display surface, you need to either
  /// call prepare() or prepareAsync(). For streams, you should call prepareAsync(),
  /// which returns immediately, rather than blocking until enough data has been
  /// buffered.
  ///@throws IllegalStateException if it is called in an invalid state
  void prepareAsync() => jniAccessors.callMethodWithArgs(
      reference, _id_prepareAsync, jni.JniType.voidType, []).check();

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "()V");

  /// from: public void start()
  ///
  /// Starts or resumes playback. If playback had previously been paused,
  /// playback will continue from where it was paused. If playback had
  /// been stopped, or never started before, playback will start at the
  /// beginning.
  ///@throws IllegalStateException if it is called in an invalid state
  void start() => jniAccessors.callMethodWithArgs(
      reference, _id_start, jni.JniType.voidType, []).check();

  static final _id_stop = jniAccessors.getMethodIDOf(_classRef, "stop", "()V");

  /// from: public void stop()
  ///
  /// Stops playback after playback has been started or paused.
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized.
  void stop() => jniAccessors.callMethodWithArgs(
      reference, _id_stop, jni.JniType.voidType, []).check();

  static final _id_pause =
      jniAccessors.getMethodIDOf(_classRef, "pause", "()V");

  /// from: public void pause()
  ///
  /// Pauses playback. Call start() to resume.
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized.
  void pause() => jniAccessors.callMethodWithArgs(
      reference, _id_pause, jni.JniType.voidType, []).check();

  static final _id_createVolumeShaper = jniAccessors.getMethodIDOf(
      _classRef,
      "createVolumeShaper",
      "(Landroid/media/VolumeShaper\$Configuration;)Landroid/media/VolumeShaper;");

  /// from: public android.media.VolumeShaper createVolumeShaper(android.media.VolumeShaper.Configuration configuration)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param configuration This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  volumeshaper_.VolumeShaper createVolumeShaper(
          volumeshaper_.VolumeShaper_Configuration configuration) =>
      volumeshaper_.VolumeShaper.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createVolumeShaper,
          jni.JniType.objectType,
          [configuration.reference]).object);

  static final _id_setPreferredDevice = jniAccessors.getMethodIDOf(
      _classRef, "setPreferredDevice", "(Landroid/media/AudioDeviceInfo;)Z");

  /// from: public boolean setPreferredDevice(android.media.AudioDeviceInfo deviceInfo)
  ///
  /// Specifies an audio device (via an AudioDeviceInfo object) to route
  /// the output from this MediaPlayer.
  ///@param deviceInfo The AudioDeviceInfo specifying the audio sink or source.
  ///  If deviceInfo is null, default routing is restored.
  ///@return true if succesful, false if the specified AudioDeviceInfo is non-null and
  /// does not correspond to a valid audio device.
  bool setPreferredDevice(audiodeviceinfo_.AudioDeviceInfo deviceInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreferredDevice,
          jni.JniType.booleanType, [deviceInfo.reference]).boolean;

  static final _id_getPreferredDevice = jniAccessors.getMethodIDOf(
      _classRef, "getPreferredDevice", "()Landroid/media/AudioDeviceInfo;");

  /// from: public android.media.AudioDeviceInfo getPreferredDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the selected output specified by \#setPreferredDevice. Note that this
  /// is not guaranteed to correspond to the actual device being used for playback.
  audiodeviceinfo_.AudioDeviceInfo getPreferredDevice() =>
      audiodeviceinfo_.AudioDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPreferredDevice,
          jni.JniType.objectType, []).object);

  static final _id_getRoutedDevice = jniAccessors.getMethodIDOf(
      _classRef, "getRoutedDevice", "()Landroid/media/AudioDeviceInfo;");

  /// from: public android.media.AudioDeviceInfo getRoutedDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an AudioDeviceInfo identifying the current routing of this MediaPlayer
  /// Note: The query is only valid if the MediaPlayer is currently playing.
  /// If the player is not playing, the returned device can be null or correspond to previously
  /// selected device when the player was last active.
  audiodeviceinfo_.AudioDeviceInfo getRoutedDevice() =>
      audiodeviceinfo_.AudioDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRoutedDevice, jni.JniType.objectType, []).object);

  static final _id_addOnRoutingChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnRoutingChangedListener",
      "(Landroid/media/AudioRouting\$OnRoutingChangedListener;Landroid/os/Handler;)V");

  /// from: public void addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener listener, android.os.Handler handler)
  ///
  /// Adds an AudioRouting.OnRoutingChangedListener to receive notifications of routing
  /// changes on this MediaPlayer.
  ///@param listener The AudioRouting.OnRoutingChangedListener interface to receive
  /// notifications of rerouting events.
  ///@param handler Specifies the Handler object for the thread on which to execute
  /// the callback. If <code>null</code>, the handler on the main looper will be used.
  void addOnRoutingChangedListener(
          audiorouting_.AudioRouting_OnRoutingChangedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnRoutingChangedListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeOnRoutingChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnRoutingChangedListener",
      "(Landroid/media/AudioRouting\$OnRoutingChangedListener;)V");

  /// from: public void removeOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener listener)
  ///
  /// Removes an AudioRouting.OnRoutingChangedListener which has been previously added
  /// to receive rerouting notifications.
  ///@param listener The previously added AudioRouting.OnRoutingChangedListener interface
  /// to remove.
  void removeOnRoutingChangedListener(
          audiorouting_.AudioRouting_OnRoutingChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnRoutingChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setWakeMode = jniAccessors.getMethodIDOf(
      _classRef, "setWakeMode", "(Landroid/content/Context;I)V");

  /// from: public void setWakeMode(android.content.Context context, int mode)
  ///
  /// Set the low-level power management behavior for this MediaPlayer.  This
  /// can be used when the MediaPlayer is not playing through a SurfaceHolder
  /// set with \#setDisplay(SurfaceHolder) and thus can use the
  /// high-level \#setScreenOnWhilePlaying(boolean) feature.
  ///
  /// This function has the MediaPlayer access the low-level power manager
  /// service to control the device's power usage while playing is occurring.
  /// The parameter is a combination of android.os.PowerManager wake flags.
  /// Use of this method requires android.Manifest.permission\#WAKE_LOCK
  /// permission.
  /// By default, no attempt is made to keep the device awake during playback.
  ///@param context the Context to use
  ///@param mode the power/wake mode to set
  ///@see android.os.PowerManager
  void setWakeMode(context_.Context context, int mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWakeMode,
          jni.JniType.voidType, [context.reference, mode]).check();

  static final _id_setScreenOnWhilePlaying =
      jniAccessors.getMethodIDOf(_classRef, "setScreenOnWhilePlaying", "(Z)V");

  /// from: public void setScreenOnWhilePlaying(boolean screenOn)
  ///
  /// Control whether we should use the attached SurfaceHolder to keep the
  /// screen on while video playback is occurring.  This is the preferred
  /// method over \#setWakeMode where possible, since it doesn't
  /// require that the application have permission for low-level wake lock
  /// access.
  ///@param screenOn Supply true to keep the screen on, false to allow it
  /// to turn off.
  void setScreenOnWhilePlaying(bool screenOn) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScreenOnWhilePlaying,
          jni.JniType.voidType, [screenOn]).check();

  static final _id_getVideoWidth =
      jniAccessors.getMethodIDOf(_classRef, "getVideoWidth", "()I");

  /// from: public native int getVideoWidth()
  ///
  /// Returns the width of the video.
  ///@return the width of the video, or 0 if there is no video,
  /// no display surface was set, or the width has not been determined
  /// yet. The OnVideoSizeChangedListener can be registered via
  /// \#setOnVideoSizeChangedListener(OnVideoSizeChangedListener)
  /// to provide a notification when the width is available.
  int getVideoWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getVideoWidth, jni.JniType.intType, []).integer;

  static final _id_getVideoHeight =
      jniAccessors.getMethodIDOf(_classRef, "getVideoHeight", "()I");

  /// from: public native int getVideoHeight()
  ///
  /// Returns the height of the video.
  ///@return the height of the video, or 0 if there is no video,
  /// no display surface was set, or the height has not been determined
  /// yet. The OnVideoSizeChangedListener can be registered via
  /// \#setOnVideoSizeChangedListener(OnVideoSizeChangedListener)
  /// to provide a notification when the height is available.
  int getVideoHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getVideoHeight, jni.JniType.intType, []).integer;

  static final _id_getMetrics = jniAccessors.getMethodIDOf(
      _classRef, "getMetrics", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getMetrics()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return Metrics data about the current player.
  ///@return a PersistableBundle containing the set of attributes and values
  /// available for the media being handled by this instance of MediaPlayer
  /// The attributes are descibed in MetricsConstants.
  ///
  ///  Additional vendor-specific fields may also be present in
  ///  the return value.
  persistablebundle_.PersistableBundle getMetrics() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getMetrics, jni.JniType.objectType, []).object);

  static final _id_isPlaying =
      jniAccessors.getMethodIDOf(_classRef, "isPlaying", "()Z");

  /// from: public native boolean isPlaying()
  ///
  /// Checks whether the MediaPlayer is playing.
  ///@return true if currently playing, false otherwise
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized or has been released.
  bool isPlaying() => jniAccessors.callMethodWithArgs(
      reference, _id_isPlaying, jni.JniType.booleanType, []).boolean;

  static final _id_setPlaybackParams = jniAccessors.getMethodIDOf(
      _classRef, "setPlaybackParams", "(Landroid/media/PlaybackParams;)V");

  /// from: public native void setPlaybackParams(android.media.PlaybackParams params)
  ///
  /// Sets playback rate using PlaybackParams. The object sets its internal
  /// PlaybackParams to the input, except that the object remembers previous speed
  /// when input speed is zero. This allows the object to resume at previous speed
  /// when start() is called. Calling it before the object is prepared does not change
  /// the object state. After the object is prepared, calling it with zero speed is
  /// equivalent to calling pause(). After the object is prepared, calling it with
  /// non-zero speed is equivalent to calling start().
  ///@param params the playback params.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized or has been released.
  ///@throws IllegalArgumentException if params is not supported.
  void setPlaybackParams(playbackparams_.PlaybackParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPlaybackParams,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_getPlaybackParams = jniAccessors.getMethodIDOf(
      _classRef, "getPlaybackParams", "()Landroid/media/PlaybackParams;");

  /// from: public native android.media.PlaybackParams getPlaybackParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the playback params, containing the current playback rate.
  ///@return the playback params.
  /// This value will never be {@code null}.
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized.
  playbackparams_.PlaybackParams getPlaybackParams() =>
      playbackparams_.PlaybackParams.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPlaybackParams, jni.JniType.objectType, []).object);

  static final _id_setSyncParams = jniAccessors.getMethodIDOf(
      _classRef, "setSyncParams", "(Landroid/media/SyncParams;)V");

  /// from: public native void setSyncParams(android.media.SyncParams params)
  ///
  /// Sets A/V sync mode.
  ///@param params the A/V sync params to apply
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized.
  ///@throws IllegalArgumentException if params are not supported.
  void setSyncParams(syncparams_.SyncParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSyncParams,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_getSyncParams = jniAccessors.getMethodIDOf(
      _classRef, "getSyncParams", "()Landroid/media/SyncParams;");

  /// from: public native android.media.SyncParams getSyncParams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the A/V sync mode.
  ///@return the A/V sync params
  ///
  /// This value will never be {@code null}.
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized.
  syncparams_.SyncParams getSyncParams() =>
      syncparams_.SyncParams.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSyncParams, jni.JniType.objectType, []).object);

  static final _id_seekTo =
      jniAccessors.getMethodIDOf(_classRef, "seekTo", "(JI)V");

  /// from: public void seekTo(long msec, int mode)
  ///
  /// Moves the media to specified time position by considering the given mode.
  ///
  /// When seekTo is finished, the user will be notified via OnSeekComplete supplied by the user.
  /// There is at most one active seekTo processed at any time. If there is a to-be-completed
  /// seekTo, new seekTo requests will be queued in such a way that only the last request
  /// is kept. When current seekTo is completed, the queued request will be processed if
  /// that request is different from just-finished seekTo operation, i.e., the requested
  /// position or mode is different.
  ///@param msec the offset in milliseconds from the start to seek to.
  /// When seeking to the given time position, there is no guarantee that the data source
  /// has a frame located at the position. When this happens, a frame nearby will be rendered.
  /// If msec is negative, time position zero will be used.
  /// If msec is larger than duration, duration will be used.
  ///@param mode the mode indicating where exactly to seek to.
  /// Use \#SEEK_PREVIOUS_SYNC if one wants to seek to a sync frame
  /// that has a timestamp earlier than or the same as msec. Use
  /// \#SEEK_NEXT_SYNC if one wants to seek to a sync frame
  /// that has a timestamp later than or the same as msec. Use
  /// \#SEEK_CLOSEST_SYNC if one wants to seek to a sync frame
  /// that has a timestamp closest to or the same as msec. Use
  /// \#SEEK_CLOSEST if one wants to seek to a frame that may
  /// or may not be a sync frame but is closest to or the same as msec.
  /// \#SEEK_CLOSEST often has larger performance overhead compared
  /// to the other options if there is no sync frame located at msec.
  /// Value is android.media.MediaPlayer\#SEEK_PREVIOUS_SYNC, android.media.MediaPlayer\#SEEK_NEXT_SYNC, android.media.MediaPlayer\#SEEK_CLOSEST_SYNC, or android.media.MediaPlayer\#SEEK_CLOSEST
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized
  ///@throws IllegalArgumentException if the mode is invalid.
  void seekTo(int msec, int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_seekTo, jni.JniType.voidType, [msec, mode]).check();

  static final _id_seekTo1 =
      jniAccessors.getMethodIDOf(_classRef, "seekTo", "(I)V");

  /// from: public void seekTo(int msec)
  ///
  /// Seeks to specified time position.
  /// Same as \#seekTo(long, int) with {@code mode = SEEK_PREVIOUS_SYNC}.
  ///@param msec the offset in milliseconds from the start to seek to
  ///@throws IllegalStateException if the internal player engine has not been
  /// initialized
  void seekTo1(int msec) => jniAccessors.callMethodWithArgs(
      reference, _id_seekTo1, jni.JniType.voidType, [msec]).check();

  static final _id_getTimestamp = jniAccessors.getMethodIDOf(
      _classRef, "getTimestamp", "()Landroid/media/MediaTimestamp;");

  /// from: public android.media.MediaTimestamp getTimestamp()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get current playback position as a MediaTimestamp.
  ///
  /// The MediaTimestamp represents how the media time correlates to the system time in
  /// a linear fashion using an anchor and a clock rate. During regular playback, the media
  /// time moves fairly constantly (though the anchor frame may be rebased to a current
  /// system time, the linear correlation stays steady). Therefore, this method does not
  /// need to be called often.
  ///
  /// To help users get current playback position, this method always anchors the timestamp
  /// to the current System\#nanoTime system time, so
  /// MediaTimestamp\#getAnchorMediaTimeUs can be used as current playback position.
  ///@return a MediaTimestamp object if a timestamp is available, or {@code null} if no timestamp
  ///         is available, e.g. because the media player has not been initialized.
  ///@see MediaTimestamp
  mediatimestamp_.MediaTimestamp getTimestamp() =>
      mediatimestamp_.MediaTimestamp.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTimestamp, jni.JniType.objectType, []).object);

  static final _id_getCurrentPosition =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentPosition", "()I");

  /// from: public native int getCurrentPosition()
  ///
  /// Gets the current playback position.
  ///@return the current position in milliseconds
  int getCurrentPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentPosition, jni.JniType.intType, []).integer;

  static final _id_getDuration =
      jniAccessors.getMethodIDOf(_classRef, "getDuration", "()I");

  /// from: public native int getDuration()
  ///
  /// Gets the duration of the file.
  ///@return the duration in milliseconds, if no duration is available
  ///         (for example, if streaming live content), -1 is returned.
  int getDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getDuration, jni.JniType.intType, []).integer;

  static final _id_setNextMediaPlayer = jniAccessors.getMethodIDOf(
      _classRef, "setNextMediaPlayer", "(Landroid/media/MediaPlayer;)V");

  /// from: public native void setNextMediaPlayer(android.media.MediaPlayer next)
  ///
  /// Set the MediaPlayer to start when this MediaPlayer finishes playback
  /// (i.e. reaches the end of the stream).
  /// The media framework will attempt to transition from this player to
  /// the next as seamlessly as possible. The next player can be set at
  /// any time before completion, but shall be after setDataSource has been
  /// called successfully. The next player must be prepared by the
  /// app, and the application should not call start() on it.
  /// The next MediaPlayer must be different from 'this'. An exception
  /// will be thrown if next == this.
  /// The application may call setNextMediaPlayer(null) to indicate no
  /// next player should be started at the end of playback.
  /// If the current player is looping, it will keep looping and the next
  /// player will not be started.
  ///@param next the player to start after this one completes playback.
  void setNextMediaPlayer(MediaPlayer next) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setNextMediaPlayer,
      jni.JniType.voidType,
      [next.reference]).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Releases resources associated with this MediaPlayer object.
  /// It is considered good practice to call this method when you're
  /// done using the MediaPlayer. In particular, whenever an Activity
  /// of an application is paused (its onPause() method is called),
  /// or stopped (its onStop() method is called), this method should be
  /// invoked to release the MediaPlayer object, unless the application
  /// has a special need to keep the object around. In addition to
  /// unnecessary resources (such as memory and instances of codecs)
  /// being held, failure to call this method immediately if a
  /// MediaPlayer object is no longer needed may also lead to
  /// continuous battery consumption for mobile devices, and playback
  /// failure for other applications if no multiple instances of the
  /// same codec are supported on a device. Even if multiple instances
  /// of the same codec are supported, some performance degradation
  /// may be expected when unnecessary multiple instances are used
  /// at the same time.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Resets the MediaPlayer to its uninitialized state. After calling
  /// this method, you will have to initialize it again by setting the
  /// data source and calling prepare().
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_setAudioStreamType =
      jniAccessors.getMethodIDOf(_classRef, "setAudioStreamType", "(I)V");

  /// from: public void setAudioStreamType(int streamtype)
  ///
  /// Sets the audio stream type for this MediaPlayer. See AudioManager
  /// for a list of stream types. Must call this method before prepare() or
  /// prepareAsync() in order for the target stream type to become effective
  /// thereafter.
  ///@param streamtype the audio stream type
  ///@deprecated use \#setAudioAttributes(AudioAttributes)
  ///@see android.media.AudioManager
  void setAudioStreamType(int streamtype) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAudioStreamType,
      jni.JniType.voidType,
      [streamtype]).check();

  static final _id_setAudioAttributes = jniAccessors.getMethodIDOf(
      _classRef, "setAudioAttributes", "(Landroid/media/AudioAttributes;)V");

  /// from: public void setAudioAttributes(android.media.AudioAttributes attributes)
  ///
  /// Sets the audio attributes for this MediaPlayer.
  /// See AudioAttributes for how to build and configure an instance of this class.
  /// You must call this method before \#prepare() or \#prepareAsync() in order
  /// for the audio attributes to become effective thereafter.
  ///@param attributes a non-null set of audio attributes
  void setAudioAttributes(audioattributes_.AudioAttributes attributes) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAudioAttributes,
          jni.JniType.voidType, [attributes.reference]).check();

  static final _id_setLooping =
      jniAccessors.getMethodIDOf(_classRef, "setLooping", "(Z)V");

  /// from: public native void setLooping(boolean looping)
  ///
  /// Sets the player to be looping or non-looping.
  ///@param looping whether to loop or not
  void setLooping(bool looping) => jniAccessors.callMethodWithArgs(
      reference, _id_setLooping, jni.JniType.voidType, [looping]).check();

  static final _id_isLooping =
      jniAccessors.getMethodIDOf(_classRef, "isLooping", "()Z");

  /// from: public native boolean isLooping()
  ///
  /// Checks whether the MediaPlayer is looping or non-looping.
  ///@return true if the MediaPlayer is currently looping, false otherwise
  bool isLooping() => jniAccessors.callMethodWithArgs(
      reference, _id_isLooping, jni.JniType.booleanType, []).boolean;

  static final _id_setVolume =
      jniAccessors.getMethodIDOf(_classRef, "setVolume", "(FF)V");

  /// from: public void setVolume(float leftVolume, float rightVolume)
  ///
  /// Sets the volume on this player.
  /// This API is recommended for balancing the output of audio streams
  /// within an application. Unless you are writing an application to
  /// control user settings, this API should be used in preference to
  /// AudioManager\#setStreamVolume(int, int, int) which sets the volume of ALL streams of
  /// a particular type. Note that the passed volume values are raw scalars in range 0.0 to 1.0.
  /// UI controls should be scaled logarithmically.
  ///@param leftVolume left volume scalar
  ///@param rightVolume right volume scalar
  void setVolume(double leftVolume, double rightVolume) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVolume,
          jni.JniType.voidType, [leftVolume, rightVolume]).check();

  static final _id_setAudioSessionId =
      jniAccessors.getMethodIDOf(_classRef, "setAudioSessionId", "(I)V");

  /// from: public native void setAudioSessionId(int sessionId)
  ///
  /// Sets the audio session ID.
  ///@param sessionId the audio session ID.
  /// The audio session ID is a system wide unique identifier for the audio stream played by
  /// this MediaPlayer instance.
  /// The primary use of the audio session ID  is to associate audio effects to a particular
  /// instance of MediaPlayer: if an audio session ID is provided when creating an audio effect,
  /// this effect will be applied only to the audio content of media players within the same
  /// audio session and not to the output mix.
  /// When created, a MediaPlayer instance automatically generates its own audio session ID.
  /// However, it is possible to force this player to be part of an already existing audio session
  /// by calling this method.
  /// This method must be called before one of the overloaded <code> setDataSource </code> methods.
  ///@throws IllegalStateException if it is called in an invalid state
  void setAudioSessionId(int sessionId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAudioSessionId,
      jni.JniType.voidType,
      [sessionId]).check();

  static final _id_getAudioSessionId =
      jniAccessors.getMethodIDOf(_classRef, "getAudioSessionId", "()I");

  /// from: public native int getAudioSessionId()
  ///
  /// Returns the audio session ID.
  ///@return the audio session ID. {@see \#setAudioSessionId(int)}
  /// Note that the audio session ID is 0 only if a problem occured when the MediaPlayer was contructed.
  int getAudioSessionId() => jniAccessors.callMethodWithArgs(
      reference, _id_getAudioSessionId, jni.JniType.intType, []).integer;

  static final _id_attachAuxEffect =
      jniAccessors.getMethodIDOf(_classRef, "attachAuxEffect", "(I)V");

  /// from: public native void attachAuxEffect(int effectId)
  ///
  /// Attaches an auxiliary effect to the player. A typical auxiliary effect is a reverberation
  /// effect which can be applied on any sound source that directs a certain amount of its
  /// energy to this effect. This amount is defined by setAuxEffectSendLevel().
  /// See \#setAuxEffectSendLevel(float).
  /// After creating an auxiliary effect (e.g.
  /// android.media.audiofx.EnvironmentalReverb), retrieve its ID with
  /// android.media.audiofx.AudioEffect\#getId() and use it when calling this method
  /// to attach the player to the effect.
  /// To detach the effect from the player, call this method with a null effect id.
  /// This method must be called after one of the overloaded <code> setDataSource </code>
  /// methods.
  ///@param effectId system wide unique id of the effect to attach
  void attachAuxEffect(int effectId) => jniAccessors.callMethodWithArgs(
      reference, _id_attachAuxEffect, jni.JniType.voidType, [effectId]).check();

  static final _id_setAuxEffectSendLevel =
      jniAccessors.getMethodIDOf(_classRef, "setAuxEffectSendLevel", "(F)V");

  /// from: public void setAuxEffectSendLevel(float level)
  ///
  /// Sets the send level of the player to the attached auxiliary effect.
  /// See \#attachAuxEffect(int). The level value range is 0 to 1.0.
  /// By default the send level is 0, so even if an effect is attached to the player
  /// this method must be called for the effect to be applied.
  /// Note that the passed level value is a raw scalar. UI controls should be scaled
  /// logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
  /// so an appropriate conversion from linear UI input x to level is:
  /// x == 0 -> level = 0
  /// 0 < x <= R -> level = 10^(72*(x-R)/20/R)
  ///@param level send level scalar
  void setAuxEffectSendLevel(double level) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAuxEffectSendLevel,
      jni.JniType.voidType,
      [level]).check();

  static final _id_getTrackInfo = jniAccessors.getMethodIDOf(
      _classRef, "getTrackInfo", "()[Landroid/media/MediaPlayer\$TrackInfo;");

  /// from: public android.media.MediaPlayer.TrackInfo[] getTrackInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of track information.
  ///@return Array of track info. The total number of tracks is the array length.
  /// Must be called again if an external timed text source has been added after any of the
  /// addTimedTextSource methods are called.
  ///@throws IllegalStateException if it is called in an invalid state.
  jni.JniObject getTrackInfo() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTrackInfo, jni.JniType.objectType, []).object);

  static final _id_addTimedTextSource = jniAccessors.getMethodIDOf(_classRef,
      "addTimedTextSource", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void addTimedTextSource(java.lang.String path, java.lang.String mimeType)
  ///
  /// Adds an external timed text source file.
  ///
  /// Currently supported format is SubRip with the file extension .srt, case insensitive.
  /// Note that a single external timed text source may contain multiple tracks in it.
  /// One can find the total number of available tracks using \#getTrackInfo() to see what
  /// additional tracks become available after this method call.
  ///@param path The file path of external timed text source file.
  ///@param mimeType The mime type of the file. Must be one of the mime types listed above.
  ///@throws IOException if the file cannot be accessed or is corrupted.
  ///@throws IllegalArgumentException if the mimeType is not supported.
  ///@throws IllegalStateException if called in an invalid state.
  void addTimedTextSource(jni.JniString path, jni.JniString mimeType) =>
      jniAccessors.callMethodWithArgs(reference, _id_addTimedTextSource,
          jni.JniType.voidType, [path.reference, mimeType.reference]).check();

  static final _id_addTimedTextSource1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addTimedTextSource",
      "(Landroid/content/Context;Landroid/net/Uri;Ljava/lang/String;)V");

  /// from: public void addTimedTextSource(android.content.Context context, android.net.Uri uri, java.lang.String mimeType)
  ///
  /// Adds an external timed text source file (Uri).
  ///
  /// Currently supported format is SubRip with the file extension .srt, case insensitive.
  /// Note that a single external timed text source may contain multiple tracks in it.
  /// One can find the total number of available tracks using \#getTrackInfo() to see what
  /// additional tracks become available after this method call.
  ///@param context the Context to use when resolving the Uri
  ///@param uri the Content URI of the data you want to play
  ///@param mimeType The mime type of the file. Must be one of the mime types listed above.
  ///@throws IOException if the file cannot be accessed or is corrupted.
  ///@throws IllegalArgumentException if the mimeType is not supported.
  ///@throws IllegalStateException if called in an invalid state.
  void addTimedTextSource1(
          context_.Context context, uri_.Uri uri, jni.JniString mimeType) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addTimedTextSource1,
          jni.JniType.voidType,
          [context.reference, uri.reference, mimeType.reference]).check();

  static final _id_addTimedTextSource2 = jniAccessors.getMethodIDOf(_classRef,
      "addTimedTextSource", "(Ljava/io/FileDescriptor;Ljava/lang/String;)V");

  /// from: public void addTimedTextSource(java.io.FileDescriptor fd, java.lang.String mimeType)
  ///
  /// Adds an external timed text source file (FileDescriptor).
  ///
  /// It is the caller's responsibility to close the file descriptor.
  /// It is safe to do so as soon as this call returns.
  ///
  /// Currently supported format is SubRip. Note that a single external timed text source may
  /// contain multiple tracks in it. One can find the total number of available tracks
  /// using \#getTrackInfo() to see what additional tracks become available
  /// after this method call.
  ///@param fd the FileDescriptor for the file you want to play
  ///@param mimeType The mime type of the file. Must be one of the mime types listed above.
  ///@throws IllegalArgumentException if the mimeType is not supported.
  ///@throws IllegalStateException if called in an invalid state.
  void addTimedTextSource2(jni.JniObject fd, jni.JniString mimeType) =>
      jniAccessors.callMethodWithArgs(reference, _id_addTimedTextSource2,
          jni.JniType.voidType, [fd.reference, mimeType.reference]).check();

  static final _id_addTimedTextSource3 = jniAccessors.getMethodIDOf(_classRef,
      "addTimedTextSource", "(Ljava/io/FileDescriptor;JJLjava/lang/String;)V");

  /// from: public void addTimedTextSource(java.io.FileDescriptor fd, long offset, long length, java.lang.String mime)
  ///
  /// Adds an external timed text file (FileDescriptor).
  ///
  /// It is the caller's responsibility to close the file descriptor.
  /// It is safe to do so as soon as this call returns.
  ///
  /// Currently supported format is SubRip. Note that a single external timed text source may
  /// contain multiple tracks in it. One can find the total number of available tracks
  /// using \#getTrackInfo() to see what additional tracks become available
  /// after this method call.
  ///@param fd the FileDescriptor for the file you want to play
  ///@param offset the offset into the file where the data to be played starts, in bytes
  ///@param length the length in bytes of the data to be played
  ///@param mime The mime type of the file. Must be one of the mime types listed above.
  ///@throws IllegalArgumentException if the mimeType is not supported.
  ///@throws IllegalStateException if called in an invalid state.
  void addTimedTextSource3(
          jni.JniObject fd, int offset, int length, jni.JniString mime) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addTimedTextSource3,
          jni.JniType.voidType,
          [fd.reference, offset, length, mime.reference]).check();

  static final _id_getSelectedTrack =
      jniAccessors.getMethodIDOf(_classRef, "getSelectedTrack", "(I)I");

  /// from: public int getSelectedTrack(int trackType)
  ///
  /// Returns the index of the audio, video, or subtitle track currently selected for playback,
  /// The return value is an index into the array returned by \#getTrackInfo(), and can
  /// be used in calls to \#selectTrack(int) or \#deselectTrack(int).
  ///@param trackType should be one of TrackInfo\#MEDIA_TRACK_TYPE_VIDEO,
  /// TrackInfo\#MEDIA_TRACK_TYPE_AUDIO, or
  /// TrackInfo\#MEDIA_TRACK_TYPE_SUBTITLE
  ///@return index of the audio, video, or subtitle track currently selected for playback;
  /// a negative integer is returned when there is no selected track for {@code trackType} or
  /// when {@code trackType} is not one of audio, video, or subtitle.
  ///@throws IllegalStateException if called after \#release()
  ///@see \#getTrackInfo()
  ///@see \#selectTrack(int)
  ///@see \#deselectTrack(int)
  int getSelectedTrack(int trackType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getSelectedTrack,
      jni.JniType.intType,
      [trackType]).integer;

  static final _id_selectTrack =
      jniAccessors.getMethodIDOf(_classRef, "selectTrack", "(I)V");

  /// from: public void selectTrack(int index)
  ///
  /// Selects a track.
  ///
  /// If a MediaPlayer is in invalid state, it throws an IllegalStateException exception.
  /// If a MediaPlayer is in _Started_ state, the selected track is presented immediately.
  /// If a MediaPlayer is not in Started state, it just marks the track to be played.
  ///
  ///
  ///
  /// In any valid state, if it is called multiple times on the same type of track (ie. Video,
  /// Audio, Timed Text), the most recent one will be chosen.
  ///
  ///
  ///
  /// The first audio and video tracks are selected by default if available, even though
  /// this method is not called. However, no timed text track will be selected until
  /// this function is called.
  ///
  ///
  ///
  /// Currently, only timed text, subtitle or audio tracks can be selected via this method.
  /// In addition, the support for selecting an audio track at runtime is pretty limited
  /// in that an audio track can only be selected in the _Prepared_ state.
  ///
  ///
  ///@param index the index of the track to be selected. The valid range of the index
  /// is 0..total number of track - 1. The total number of tracks as well as the type of
  /// each individual track can be found by calling \#getTrackInfo() method.
  ///@throws IllegalStateException if called in an invalid state.
  ///@see android.media.MediaPlayer\#getTrackInfo
  void selectTrack(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_selectTrack, jni.JniType.voidType, [index]).check();

  static final _id_deselectTrack =
      jniAccessors.getMethodIDOf(_classRef, "deselectTrack", "(I)V");

  /// from: public void deselectTrack(int index)
  ///
  /// Deselect a track.
  ///
  /// Currently, the track must be a timed text track and no audio or video tracks can be
  /// deselected. If the timed text track identified by index has not been
  /// selected before, it throws an exception.
  ///
  ///
  ///@param index the index of the track to be deselected. The valid range of the index
  /// is 0..total number of tracks - 1. The total number of tracks as well as the type of
  /// each individual track can be found by calling \#getTrackInfo() method.
  ///@throws IllegalStateException if called in an invalid state.
  ///@see android.media.MediaPlayer\#getTrackInfo
  void deselectTrack(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_deselectTrack, jni.JniType.voidType, [index]).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_setOnPreparedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnPreparedListener",
      "(Landroid/media/MediaPlayer\$OnPreparedListener;)V");

  /// from: public void setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener listener)
  ///
  /// Register a callback to be invoked when the media source is ready
  /// for playback.
  ///@param listener the callback that will be run
  void setOnPreparedListener(MediaPlayer_OnPreparedListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnPreparedListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnCompletionListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnCompletionListener",
      "(Landroid/media/MediaPlayer\$OnCompletionListener;)V");

  /// from: public void setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener listener)
  ///
  /// Register a callback to be invoked when the end of a media source
  /// has been reached during playback.
  ///@param listener the callback that will be run
  void setOnCompletionListener(MediaPlayer_OnCompletionListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnCompletionListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnBufferingUpdateListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnBufferingUpdateListener",
      "(Landroid/media/MediaPlayer\$OnBufferingUpdateListener;)V");

  /// from: public void setOnBufferingUpdateListener(android.media.MediaPlayer.OnBufferingUpdateListener listener)
  ///
  /// Register a callback to be invoked when the status of a network
  /// stream's buffer has changed.
  ///@param listener the callback that will be run.
  void setOnBufferingUpdateListener(
          MediaPlayer_OnBufferingUpdateListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnBufferingUpdateListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setOnSeekCompleteListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnSeekCompleteListener",
      "(Landroid/media/MediaPlayer\$OnSeekCompleteListener;)V");

  /// from: public void setOnSeekCompleteListener(android.media.MediaPlayer.OnSeekCompleteListener listener)
  ///
  /// Register a callback to be invoked when a seek operation has been
  /// completed.
  ///@param listener the callback that will be run
  void setOnSeekCompleteListener(MediaPlayer_OnSeekCompleteListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnSeekCompleteListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnVideoSizeChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnVideoSizeChangedListener",
      "(Landroid/media/MediaPlayer\$OnVideoSizeChangedListener;)V");

  /// from: public void setOnVideoSizeChangedListener(android.media.MediaPlayer.OnVideoSizeChangedListener listener)
  ///
  /// Register a callback to be invoked when the video size is
  /// known or updated.
  ///@param listener the callback that will be run
  void setOnVideoSizeChangedListener(
          MediaPlayer_OnVideoSizeChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnVideoSizeChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setOnTimedTextListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnTimedTextListener",
      "(Landroid/media/MediaPlayer\$OnTimedTextListener;)V");

  /// from: public void setOnTimedTextListener(android.media.MediaPlayer.OnTimedTextListener listener)
  ///
  /// Register a callback to be invoked when a timed text is available
  /// for display.
  ///@param listener the callback that will be run
  void setOnTimedTextListener(MediaPlayer_OnTimedTextListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnTimedTextListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnSubtitleDataListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnSubtitleDataListener",
      "(Landroid/media/MediaPlayer\$OnSubtitleDataListener;Landroid/os/Handler;)V");

  /// from: public void setOnSubtitleDataListener(android.media.MediaPlayer.OnSubtitleDataListener listener, android.os.Handler handler)
  ///
  /// Sets the listener to be invoked when a subtitle track has new data available.
  /// The subtitle data comes from a subtitle track previously selected with
  /// \#selectTrack(int). Use \#getTrackInfo() to determine which tracks are
  /// subtitles (of type TrackInfo\#MEDIA_TRACK_TYPE_SUBTITLE), Subtitle track encodings
  /// can be determined by TrackInfo\#getFormat()).<br>
  /// See SubtitleData for an example of querying subtitle encoding.
  ///@param listener the listener called when new data is available
  /// This value must never be {@code null}.
  ///@param handler the Handler that receives the listener events
  ///
  /// This value must never be {@code null}.
  void setOnSubtitleDataListener(MediaPlayer_OnSubtitleDataListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnSubtitleDataListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_setOnSubtitleDataListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnSubtitleDataListener",
      "(Landroid/media/MediaPlayer\$OnSubtitleDataListener;)V");

  /// from: public void setOnSubtitleDataListener(android.media.MediaPlayer.OnSubtitleDataListener listener)
  ///
  /// Sets the listener to be invoked when a subtitle track has new data available.
  /// The subtitle data comes from a subtitle track previously selected with
  /// \#selectTrack(int). Use \#getTrackInfo() to determine which tracks are
  /// subtitles (of type TrackInfo\#MEDIA_TRACK_TYPE_SUBTITLE), Subtitle track encodings
  /// can be determined by TrackInfo\#getFormat()).<br>
  /// See SubtitleData for an example of querying subtitle encoding.<br>
  /// The listener will be called on the same thread as the one in which the MediaPlayer was
  /// created.
  ///@param listener the listener called when new data is available
  ///
  /// This value must never be {@code null}.
  void setOnSubtitleDataListener1(
          MediaPlayer_OnSubtitleDataListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnSubtitleDataListener1,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_clearOnSubtitleDataListener = jniAccessors.getMethodIDOf(
      _classRef, "clearOnSubtitleDataListener", "()V");

  /// from: public void clearOnSubtitleDataListener()
  ///
  /// Clears the listener previously set with
  /// \#setOnSubtitleDataListener(OnSubtitleDataListener) or
  /// \#setOnSubtitleDataListener(OnSubtitleDataListener, Handler).
  void clearOnSubtitleDataListener() => jniAccessors.callMethodWithArgs(
      reference,
      _id_clearOnSubtitleDataListener,
      jni.JniType.voidType, []).check();

  static final _id_setOnMediaTimeDiscontinuityListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnMediaTimeDiscontinuityListener",
      "(Landroid/media/MediaPlayer\$OnMediaTimeDiscontinuityListener;Landroid/os/Handler;)V");

  /// from: public void setOnMediaTimeDiscontinuityListener(android.media.MediaPlayer.OnMediaTimeDiscontinuityListener listener, android.os.Handler handler)
  ///
  /// Sets the listener to be invoked when a media time discontinuity is encountered.
  ///@param listener the listener called after a discontinuity
  /// This value must never be {@code null}.
  ///@param handler the Handler that receives the listener events
  ///
  /// This value must never be {@code null}.
  void setOnMediaTimeDiscontinuityListener(
          MediaPlayer_OnMediaTimeDiscontinuityListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnMediaTimeDiscontinuityListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_setOnMediaTimeDiscontinuityListener1 =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setOnMediaTimeDiscontinuityListener",
          "(Landroid/media/MediaPlayer\$OnMediaTimeDiscontinuityListener;)V");

  /// from: public void setOnMediaTimeDiscontinuityListener(android.media.MediaPlayer.OnMediaTimeDiscontinuityListener listener)
  ///
  /// Sets the listener to be invoked when a media time discontinuity is encountered.
  /// The listener will be called on the same thread as the one in which the MediaPlayer was
  /// created.
  ///@param listener the listener called after a discontinuity
  ///
  /// This value must never be {@code null}.
  void setOnMediaTimeDiscontinuityListener1(
          MediaPlayer_OnMediaTimeDiscontinuityListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnMediaTimeDiscontinuityListener1,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_clearOnMediaTimeDiscontinuityListener = jniAccessors
      .getMethodIDOf(_classRef, "clearOnMediaTimeDiscontinuityListener", "()V");

  /// from: public void clearOnMediaTimeDiscontinuityListener()
  ///
  /// Clears the listener previously set with
  /// \#setOnMediaTimeDiscontinuityListener(OnMediaTimeDiscontinuityListener)
  /// or \#setOnMediaTimeDiscontinuityListener(OnMediaTimeDiscontinuityListener, Handler)
  void clearOnMediaTimeDiscontinuityListener() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_clearOnMediaTimeDiscontinuityListener,
          jni.JniType.voidType, []).check();

  static final _id_setOnTimedMetaDataAvailableListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setOnTimedMetaDataAvailableListener",
          "(Landroid/media/MediaPlayer\$OnTimedMetaDataAvailableListener;)V");

  /// from: public void setOnTimedMetaDataAvailableListener(android.media.MediaPlayer.OnTimedMetaDataAvailableListener listener)
  ///
  /// Register a callback to be invoked when a selected track has timed metadata available.
  ///
  /// Currently only HTTP live streaming data URI's embedded with timed ID3 tags generates
  /// TimedMetaData.
  ///@see MediaPlayer\#selectTrack(int)
  ///@see MediaPlayer.OnTimedMetaDataAvailableListener
  ///@see TimedMetaData
  ///@param listener the callback that will be run
  void setOnTimedMetaDataAvailableListener(
          MediaPlayer_OnTimedMetaDataAvailableListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnTimedMetaDataAvailableListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setOnErrorListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnErrorListener", "(Landroid/media/MediaPlayer\$OnErrorListener;)V");

  /// from: public void setOnErrorListener(android.media.MediaPlayer.OnErrorListener listener)
  ///
  /// Register a callback to be invoked when an error has happened
  /// during an asynchronous operation.
  ///@param listener the callback that will be run
  void setOnErrorListener(MediaPlayer_OnErrorListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnErrorListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnInfoListener = jniAccessors.getMethodIDOf(_classRef,
      "setOnInfoListener", "(Landroid/media/MediaPlayer\$OnInfoListener;)V");

  /// from: public void setOnInfoListener(android.media.MediaPlayer.OnInfoListener listener)
  ///
  /// Register a callback to be invoked when an info/warning is available.
  ///@param listener the callback that will be run
  void setOnInfoListener(MediaPlayer_OnInfoListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnInfoListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnDrmConfigHelper = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDrmConfigHelper",
      "(Landroid/media/MediaPlayer\$OnDrmConfigHelper;)V");

  /// from: public void setOnDrmConfigHelper(android.media.MediaPlayer.OnDrmConfigHelper listener)
  ///
  /// Register a callback to be invoked for configuration of the DRM object before
  /// the session is created.
  /// The callback will be invoked synchronously during the execution
  /// of \#prepareDrm(UUID uuid).
  ///@param listener the callback that will be run
  void setOnDrmConfigHelper(MediaPlayer_OnDrmConfigHelper listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDrmConfigHelper,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnDrmInfoListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDrmInfoListener",
      "(Landroid/media/MediaPlayer\$OnDrmInfoListener;)V");

  /// from: public void setOnDrmInfoListener(android.media.MediaPlayer.OnDrmInfoListener listener)
  ///
  /// Register a callback to be invoked when the DRM info is
  /// known.
  ///@param listener the callback that will be run
  void setOnDrmInfoListener(MediaPlayer_OnDrmInfoListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDrmInfoListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnDrmInfoListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDrmInfoListener",
      "(Landroid/media/MediaPlayer\$OnDrmInfoListener;Landroid/os/Handler;)V");

  /// from: public void setOnDrmInfoListener(android.media.MediaPlayer.OnDrmInfoListener listener, android.os.Handler handler)
  ///
  /// Register a callback to be invoked when the DRM info is
  /// known.
  ///@param listener the callback that will be run
  void setOnDrmInfoListener1(
          MediaPlayer_OnDrmInfoListener listener, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnDrmInfoListener1,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_setOnDrmPreparedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDrmPreparedListener",
      "(Landroid/media/MediaPlayer\$OnDrmPreparedListener;)V");

  /// from: public void setOnDrmPreparedListener(android.media.MediaPlayer.OnDrmPreparedListener listener)
  ///
  /// Register a callback to be invoked when the DRM object is prepared.
  ///@param listener the callback that will be run
  void setOnDrmPreparedListener(MediaPlayer_OnDrmPreparedListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDrmPreparedListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnDrmPreparedListener1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDrmPreparedListener",
      "(Landroid/media/MediaPlayer\$OnDrmPreparedListener;Landroid/os/Handler;)V");

  /// from: public void setOnDrmPreparedListener(android.media.MediaPlayer.OnDrmPreparedListener listener, android.os.Handler handler)
  ///
  /// Register a callback to be invoked when the DRM object is prepared.
  ///@param listener the callback that will be run
  ///@param handler the Handler that will receive the callback
  void setOnDrmPreparedListener1(MediaPlayer_OnDrmPreparedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnDrmPreparedListener1,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_getDrmInfo = jniAccessors.getMethodIDOf(
      _classRef, "getDrmInfo", "()Landroid/media/MediaPlayer\$DrmInfo;");

  /// from: public android.media.MediaPlayer.DrmInfo getDrmInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the DRM Info associated with the current source
  ///@throws IllegalStateException if called before prepare()
  MediaPlayer_DrmInfo getDrmInfo() =>
      MediaPlayer_DrmInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrmInfo, jni.JniType.objectType, []).object);

  static final _id_prepareDrm = jniAccessors.getMethodIDOf(
      _classRef, "prepareDrm", "(Ljava/util/UUID;)V");

  /// from: public void prepareDrm(java.util.UUID uuid)
  ///
  /// Prepares the DRM for the current source
  ///
  /// If {@code OnDrmConfigHelper} is registered, it will be called during
  /// preparation to allow configuration of the DRM properties before opening the
  /// DRM session. Note that the callback is called synchronously in the thread that called
  /// {@code prepareDrm}. It should be used only for a series of {@code getDrmPropertyString}
  /// and {@code setDrmPropertyString} calls and refrain from any lengthy operation.
  ///
  /// If the device has not been provisioned before, this call also provisions the device
  /// which involves accessing the provisioning server and can take a variable time to
  /// complete depending on the network connectivity.
  /// If {@code OnDrmPreparedListener} is registered, prepareDrm() runs in non-blocking
  /// mode by launching the provisioning in the background and returning. The listener
  /// will be called when provisioning and preparation has finished. If a
  /// {@code OnDrmPreparedListener} is not registered, prepareDrm() waits till provisioning
  /// and preparation has finished, i.e., runs in blocking mode.
  ///
  /// If {@code OnDrmPreparedListener} is registered, it is called to indicate the DRM
  /// session being ready. The application should not make any assumption about its call
  /// sequence (e.g., before or after prepareDrm returns), or the thread context that will
  /// execute the listener (unless the listener is registered with a handler thread).
  ///
  ///@param uuid The UUID of the crypto scheme. If not known beforehand, it can be retrieved
  /// from the source through {@code getDrmInfo} or registering a {@code onDrmInfoListener}.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if called before prepare(), or the DRM was
  ///                                            prepared already
  ///@throws UnsupportedSchemeException if the crypto scheme is not supported
  ///@throws ResourceBusyException if required DRM resources are in use
  ///@throws ProvisioningNetworkErrorException if provisioning is required but failed due to a
  ///                                            network error
  ///@throws ProvisioningServerErrorException if provisioning is required but failed due to
  ///                                            the request denied by the provisioning server
  void prepareDrm(jni.JniObject uuid) => jniAccessors.callMethodWithArgs(
      reference,
      _id_prepareDrm,
      jni.JniType.voidType,
      [uuid.reference]).check();

  static final _id_releaseDrm =
      jniAccessors.getMethodIDOf(_classRef, "releaseDrm", "()V");

  /// from: public void releaseDrm()
  ///
  /// Releases the DRM session
  ///
  /// The player has to have an active DRM session and be in stopped, or prepared
  /// state before this call is made.
  /// A {@code reset()} call will release the DRM session implicitly.
  ///@throws NoDrmSchemeException if there is no active DRM session to release
  void releaseDrm() => jniAccessors.callMethodWithArgs(
      reference, _id_releaseDrm, jni.JniType.voidType, []).check();

  static final _id_getKeyRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "getKeyRequest",
      "([B[BLjava/lang/String;ILjava/util/Map;)Landroid/media/MediaDrm\$KeyRequest;");

  /// from: public android.media.MediaDrm.KeyRequest getKeyRequest(byte[] keySetId, byte[] initData, java.lang.String mimeType, int keyType, java.util.Map<java.lang.String,java.lang.String> optionalParameters)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A key request/response exchange occurs between the app and a license server
  /// to obtain or release keys used to decrypt encrypted content.
  ///
  /// getKeyRequest() is used to obtain an opaque key request byte array that is
  /// delivered to the license server.  The opaque key request byte array is returned
  /// in KeyRequest.data.  The recommended URL to deliver the key request to is
  /// returned in KeyRequest.defaultUrl.
  ///
  /// After the app has received the key request response from the server,
  /// it should deliver to the response to the DRM engine plugin using the method
  /// \#provideKeyResponse.
  ///@param keySetId is the key-set identifier of the offline keys being released when keyType is
  /// MediaDrm\#KEY_TYPE_RELEASE. It should be set to null for other key requests, when
  /// keyType is MediaDrm\#KEY_TYPE_STREAMING or MediaDrm\#KEY_TYPE_OFFLINE.
  ///
  /// This value may be {@code null}.
  ///@param initData is the container-specific initialization data when the keyType is
  /// MediaDrm\#KEY_TYPE_STREAMING or MediaDrm\#KEY_TYPE_OFFLINE. Its meaning is
  /// interpreted based on the mime type provided in the mimeType parameter.  It could
  /// contain, for example, the content ID, key ID or other data obtained from the content
  /// metadata that is required in generating the key request.
  /// When the keyType is MediaDrm\#KEY_TYPE_RELEASE, it should be set to null.
  ///
  /// This value may be {@code null}.
  ///@param mimeType identifies the mime type of the content
  ///
  /// This value may be {@code null}.
  ///@param keyType specifies the type of the request. The request may be to acquire
  /// keys for streaming, MediaDrm\#KEY_TYPE_STREAMING, or for offline content
  /// MediaDrm\#KEY_TYPE_OFFLINE, or to release previously acquired
  /// keys (MediaDrm\#KEY_TYPE_RELEASE), which are identified by a keySetId.
  ///
  /// Value is android.media.MediaDrm\#KEY_TYPE_STREAMING, android.media.MediaDrm\#KEY_TYPE_OFFLINE, or android.media.MediaDrm\#KEY_TYPE_RELEASE
  ///@param optionalParameters are included in the key request message to
  /// allow a client application to provide additional message parameters to the server.
  /// This may be {@code null} if no additional parameters are to be sent.
  ///
  /// This value may be {@code null}.
  ///@throws NoDrmSchemeException if there is no active DRM session
  mediadrm_.MediaDrm_KeyRequest getKeyRequest(
          jni.JniObject keySetId,
          jni.JniObject initData,
          jni.JniString mimeType,
          int keyType,
          jni.JniObject optionalParameters) =>
      mediadrm_.MediaDrm_KeyRequest.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeyRequest, jni.JniType.objectType, [
        keySetId.reference,
        initData.reference,
        mimeType.reference,
        keyType,
        optionalParameters.reference
      ]).object);

  static final _id_provideKeyResponse =
      jniAccessors.getMethodIDOf(_classRef, "provideKeyResponse", "([B[B)[B");

  /// from: public byte[] provideKeyResponse(byte[] keySetId, byte[] response)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A key response is received from the license server by the app, then it is
  /// provided to the DRM engine plugin using provideKeyResponse. When the
  /// response is for an offline key request, a key-set identifier is returned that
  /// can be used to later restore the keys to a new session with the method
  /// {@ link \# restoreKeys}.
  /// When the response is for a streaming or release request, null is returned.
  ///@param keySetId When the response is for a release request, keySetId identifies
  /// the saved key associated with the release request (i.e., the same keySetId
  /// passed to the earlier {@ link \# getKeyRequest} call. It MUST be null when the
  /// response is for either streaming or offline key requests.
  ///@param response the byte array response from the server
  ///@throws NoDrmSchemeException if there is no active DRM session
  ///@throws DeniedByServerException if the response indicates that the
  /// server rejected the request
  ///@param keySetId This value may be {@code null}.
  ///@param response This value must never be {@code null}.
  jni.JniObject provideKeyResponse(
          jni.JniObject keySetId, jni.JniObject response) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_provideKeyResponse,
          jni.JniType.objectType,
          [keySetId.reference, response.reference]).object);

  static final _id_restoreKeys =
      jniAccessors.getMethodIDOf(_classRef, "restoreKeys", "([B)V");

  /// from: public void restoreKeys(byte[] keySetId)
  ///
  /// Restore persisted offline keys into a new session.  keySetId identifies the
  /// keys to load, obtained from a prior call to \#provideKeyResponse.
  ///@param keySetId identifies the saved key set to restore
  ///
  /// This value must never be {@code null}.
  void restoreKeys(jni.JniObject keySetId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_restoreKeys,
      jni.JniType.voidType,
      [keySetId.reference]).check();

  static final _id_getDrmPropertyString = jniAccessors.getMethodIDOf(_classRef,
      "getDrmPropertyString", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getDrmPropertyString(java.lang.String propertyName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a DRM engine plugin String property value, given the property name string.
  ///
  ///@param propertyName the property name
  ///
  /// Standard fields names are:
  /// MediaDrm\#PROPERTY_VENDOR, MediaDrm\#PROPERTY_VERSION,
  /// MediaDrm\#PROPERTY_DESCRIPTION, MediaDrm\#PROPERTY_ALGORITHMS
  ///
  /// This value must never be {@code null}.
  /// Value is android.media.MediaDrm\#PROPERTY_VENDOR, android.media.MediaDrm\#PROPERTY_VERSION, android.media.MediaDrm\#PROPERTY_DESCRIPTION, or android.media.MediaDrm\#PROPERTY_ALGORITHMS
  ///@return This value will never be {@code null}.
  jni.JniString getDrmPropertyString(jni.JniString propertyName) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDrmPropertyString,
          jni.JniType.objectType,
          [propertyName.reference]).object);

  static final _id_setDrmPropertyString = jniAccessors.getMethodIDOf(_classRef,
      "setDrmPropertyString", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void setDrmPropertyString(java.lang.String propertyName, java.lang.String value)
  ///
  /// Set a DRM engine plugin String property value.
  ///
  ///@param propertyName the property name
  /// This value must never be {@code null}.
  /// Value is android.media.MediaDrm\#PROPERTY_VENDOR, android.media.MediaDrm\#PROPERTY_VERSION, android.media.MediaDrm\#PROPERTY_DESCRIPTION, or android.media.MediaDrm\#PROPERTY_ALGORITHMS
  ///@param value the property value
  ///
  /// Standard fields names are:
  /// MediaDrm\#PROPERTY_VENDOR, MediaDrm\#PROPERTY_VERSION,
  /// MediaDrm\#PROPERTY_DESCRIPTION, MediaDrm\#PROPERTY_ALGORITHMS
  ///
  /// This value must never be {@code null}.
  void setDrmPropertyString(jni.JniString propertyName, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDrmPropertyString,
          jni.JniType.voidType,
          [propertyName.reference, value.reference]).check();
}

/// from: android.media.MediaPlayer$TrackInfo
///
/// Class for MediaPlayer to return each audio/video/subtitle track's metadata.
///@see android.media.MediaPlayer\#getTrackInfo
class MediaPlayer_TrackInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$TrackInfo");
  MediaPlayer_TrackInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MEDIA_TRACK_TYPE_AUDIO
  static const MEDIA_TRACK_TYPE_AUDIO = 2;

  /// from: static public final int MEDIA_TRACK_TYPE_METADATA
  static const MEDIA_TRACK_TYPE_METADATA = 5;

  /// from: static public final int MEDIA_TRACK_TYPE_SUBTITLE
  static const MEDIA_TRACK_TYPE_SUBTITLE = 4;

  /// from: static public final int MEDIA_TRACK_TYPE_TIMEDTEXT
  static const MEDIA_TRACK_TYPE_TIMEDTEXT = 3;

  /// from: static public final int MEDIA_TRACK_TYPE_UNKNOWN
  static const MEDIA_TRACK_TYPE_UNKNOWN = 0;

  /// from: static public final int MEDIA_TRACK_TYPE_VIDEO
  static const MEDIA_TRACK_TYPE_VIDEO = 1;

  static final _id_getTrackType =
      jniAccessors.getMethodIDOf(_classRef, "getTrackType", "()I");

  /// from: public int getTrackType()
  ///
  /// Gets the track type.
  ///@return TrackType which indicates if the track is video, audio, timed text.
  ///
  /// Value is android.media.MediaPlayer.TrackInfo\#MEDIA_TRACK_TYPE_UNKNOWN, android.media.MediaPlayer.TrackInfo\#MEDIA_TRACK_TYPE_VIDEO, android.media.MediaPlayer.TrackInfo\#MEDIA_TRACK_TYPE_AUDIO, android.media.MediaPlayer.TrackInfo\#MEDIA_TRACK_TYPE_TIMEDTEXT, android.media.MediaPlayer.TrackInfo\#MEDIA_TRACK_TYPE_SUBTITLE, or android.media.MediaPlayer.TrackInfo\#MEDIA_TRACK_TYPE_METADATA
  int getTrackType() => jniAccessors.callMethodWithArgs(
      reference, _id_getTrackType, jni.JniType.intType, []).integer;

  static final _id_getLanguage = jniAccessors.getMethodIDOf(
      _classRef, "getLanguage", "()Ljava/lang/String;");

  /// from: public java.lang.String getLanguage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the language code of the track.
  ///@return a language code in either way of ISO-639-1 or ISO-639-2.
  /// When the language is unknown or could not be determined,
  /// ISO-639-2 language code, "und", is returned.
  jni.JniString getLanguage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLanguage, jni.JniType.objectType, []).object);

  static final _id_getFormat = jniAccessors.getMethodIDOf(
      _classRef, "getFormat", "()Landroid/media/MediaFormat;");

  /// from: public android.media.MediaFormat getFormat()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the MediaFormat of the track.  If the format is
  /// unknown or could not be determined, null is returned.
  mediaformat_.MediaFormat getFormat() =>
      mediaformat_.MediaFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFormat, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  ///
  /// {@inheritDoc}
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// {@inheritDoc}
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.media.MediaPlayer$ProvisioningServerErrorException
///
/// Thrown when the device requires DRM provisioning but the provisioning attempt has
/// failed due to the provisioning server denying the request.
/// Extends MediaDrm.MediaDrmException
class MediaPlayer_ProvisioningServerErrorException
    extends mediadrmexception_.MediaDrmException {
  static final _classRef = jniAccessors.getClassOf(
      "android/media/MediaPlayer\$ProvisioningServerErrorException");
  MediaPlayer_ProvisioningServerErrorException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String detailMessage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaPlayer_ProvisioningServerErrorException(jni.JniString detailMessage)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [detailMessage.reference]).object);
}

/// from: android.media.MediaPlayer$ProvisioningNetworkErrorException
///
/// Thrown when the device requires DRM provisioning but the provisioning attempt has
/// failed due to a network error (Internet reachability, timeout, etc.).
/// Extends MediaDrm.MediaDrmException
class MediaPlayer_ProvisioningNetworkErrorException
    extends mediadrmexception_.MediaDrmException {
  static final _classRef = jniAccessors.getClassOf(
      "android/media/MediaPlayer\$ProvisioningNetworkErrorException");
  MediaPlayer_ProvisioningNetworkErrorException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String detailMessage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaPlayer_ProvisioningNetworkErrorException(jni.JniString detailMessage)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [detailMessage.reference]).object);
}

/// from: android.media.MediaPlayer$OnVideoSizeChangedListener
///
/// Interface definition of a callback to be invoked when the
/// video size is first known or updated
class MediaPlayer_OnVideoSizeChangedListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaPlayer\$OnVideoSizeChangedListener");
  MediaPlayer_OnVideoSizeChangedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onVideoSizeChanged = jniAccessors.getMethodIDOf(
      _classRef, "onVideoSizeChanged", "(Landroid/media/MediaPlayer;II)V");

  /// from: public abstract void onVideoSizeChanged(android.media.MediaPlayer mp, int width, int height)
  ///
  /// Called to indicate the video size
  ///
  /// The video size (width and height) could be 0 if there was no video,
  /// no display surface was set, or the value was not determined yet.
  ///@param mp the MediaPlayer associated with this callback
  ///@param width the width of the video
  ///@param height the height of the video
  void onVideoSizeChanged(MediaPlayer mp, int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVideoSizeChanged,
          jni.JniType.voidType, [mp.reference, width, height]).check();
}

/// from: android.media.MediaPlayer$OnTimedTextListener
///
/// Interface definition of a callback to be invoked when a
/// timed text is available for display.
class MediaPlayer_OnTimedTextListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$OnTimedTextListener");
  MediaPlayer_OnTimedTextListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onTimedText = jniAccessors.getMethodIDOf(_classRef,
      "onTimedText", "(Landroid/media/MediaPlayer;Landroid/media/TimedText;)V");

  /// from: public abstract void onTimedText(android.media.MediaPlayer mp, android.media.TimedText text)
  ///
  /// Called to indicate an avaliable timed text
  ///@param mp the MediaPlayer associated with this callback
  ///@param text the timed text sample which contains the text
  ///                       needed to be displayed and the display format.
  void onTimedText(MediaPlayer mp, timedtext_.TimedText text) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTimedText,
          jni.JniType.voidType, [mp.reference, text.reference]).check();
}

/// from: android.media.MediaPlayer$OnTimedMetaDataAvailableListener
///
/// Interface definition of a callback to be invoked when a
/// track has timed metadata available.
///@see MediaPlayer\#setOnTimedMetaDataAvailableListener(OnTimedMetaDataAvailableListener)
class MediaPlayer_OnTimedMetaDataAvailableListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/media/MediaPlayer\$OnTimedMetaDataAvailableListener");
  MediaPlayer_OnTimedMetaDataAvailableListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onTimedMetaDataAvailable = jniAccessors.getMethodIDOf(
      _classRef,
      "onTimedMetaDataAvailable",
      "(Landroid/media/MediaPlayer;Landroid/media/TimedMetaData;)V");

  /// from: public abstract void onTimedMetaDataAvailable(android.media.MediaPlayer mp, android.media.TimedMetaData data)
  ///
  /// Called to indicate avaliable timed metadata
  ///
  /// This method will be called as timed metadata is extracted from the media,
  /// in the same order as it occurs in the media. The timing of this event is
  /// not controlled by the associated timestamp.
  ///@param mp the MediaPlayer associated with this callback
  ///@param data the timed metadata sample associated with this event
  void onTimedMetaDataAvailable(
          MediaPlayer mp, timedmetadata_.TimedMetaData data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTimedMetaDataAvailable,
          jni.JniType.voidType, [mp.reference, data.reference]).check();
}

/// from: android.media.MediaPlayer$OnSubtitleDataListener
///
/// Interface definition of a callback to be invoked when a player subtitle track has new
/// subtitle data available.
/// See the MediaPlayer\#setOnSubtitleDataListener(OnSubtitleDataListener, Handler)
/// method for the description of which track will report data through this listener.
class MediaPlayer_OnSubtitleDataListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaPlayer\$OnSubtitleDataListener");
  MediaPlayer_OnSubtitleDataListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onSubtitleData = jniAccessors.getMethodIDOf(
      _classRef,
      "onSubtitleData",
      "(Landroid/media/MediaPlayer;Landroid/media/SubtitleData;)V");

  /// from: public abstract void onSubtitleData(android.media.MediaPlayer mp, android.media.SubtitleData data)
  ///
  /// Method called when new subtitle data is available
  ///@param mp the player that reports the new subtitle data
  /// This value must never be {@code null}.
  ///@param data the subtitle data
  ///
  /// This value must never be {@code null}.
  void onSubtitleData(MediaPlayer mp, subtitledata_.SubtitleData data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSubtitleData,
          jni.JniType.voidType, [mp.reference, data.reference]).check();
}

/// from: android.media.MediaPlayer$OnSeekCompleteListener
///
/// Interface definition of a callback to be invoked indicating
/// the completion of a seek operation.
class MediaPlayer_OnSeekCompleteListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaPlayer\$OnSeekCompleteListener");
  MediaPlayer_OnSeekCompleteListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onSeekComplete = jniAccessors.getMethodIDOf(
      _classRef, "onSeekComplete", "(Landroid/media/MediaPlayer;)V");

  /// from: public abstract void onSeekComplete(android.media.MediaPlayer mp)
  ///
  /// Called to indicate the completion of a seek operation.
  ///@param mp the MediaPlayer that issued the seek operation
  void onSeekComplete(MediaPlayer mp) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSeekComplete,
      jni.JniType.voidType,
      [mp.reference]).check();
}

/// from: android.media.MediaPlayer$OnPreparedListener
///
/// Interface definition for a callback to be invoked when the media
/// source is ready for playback.
class MediaPlayer_OnPreparedListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$OnPreparedListener");
  MediaPlayer_OnPreparedListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onPrepared = jniAccessors.getMethodIDOf(
      _classRef, "onPrepared", "(Landroid/media/MediaPlayer;)V");

  /// from: public abstract void onPrepared(android.media.MediaPlayer mp)
  ///
  /// Called when the media file is ready for playback.
  ///@param mp the MediaPlayer that is ready for playback
  void onPrepared(MediaPlayer mp) => jniAccessors.callMethodWithArgs(
      reference, _id_onPrepared, jni.JniType.voidType, [mp.reference]).check();
}

/// from: android.media.MediaPlayer$OnMediaTimeDiscontinuityListener
///
/// Interface definition of a callback to be invoked when discontinuity in the normal progression
/// of the media time is detected.
/// The "normal progression" of media time is defined as the expected increase of the playback
/// position when playing media, relative to the playback speed (for instance every second, media
/// time increases by two seconds when playing at 2x).<br>
/// Discontinuities are encountered in the following cases:
/// <ul>
/// <li>when the player is starved for data and cannot play anymore</li>
/// <li>when the player encounters a playback error</li>
/// <li>when the a seek operation starts, and when it's completed</li>
/// <li>when the playback speed changes</li>
/// <li>when the playback state changes</li>
/// <li>when the player is reset</li>
/// </ul>
/// See the
/// MediaPlayer\#setOnMediaTimeDiscontinuityListener(OnMediaTimeDiscontinuityListener, Handler)
/// method to set a listener for these events.
class MediaPlayer_OnMediaTimeDiscontinuityListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/media/MediaPlayer\$OnMediaTimeDiscontinuityListener");
  MediaPlayer_OnMediaTimeDiscontinuityListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onMediaTimeDiscontinuity = jniAccessors.getMethodIDOf(
      _classRef,
      "onMediaTimeDiscontinuity",
      "(Landroid/media/MediaPlayer;Landroid/media/MediaTimestamp;)V");

  /// from: public abstract void onMediaTimeDiscontinuity(android.media.MediaPlayer mp, android.media.MediaTimestamp mts)
  ///
  /// Called to indicate a time discontinuity has occured.
  ///@param mp the MediaPlayer for which the discontinuity has occured.
  /// This value must never be {@code null}.
  ///@param mts the timestamp that correlates media time, system time and clock rate,
  ///     or MediaTimestamp\#TIMESTAMP_UNKNOWN in an error case.
  ///
  /// This value must never be {@code null}.
  void onMediaTimeDiscontinuity(
          MediaPlayer mp, mediatimestamp_.MediaTimestamp mts) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMediaTimeDiscontinuity,
          jni.JniType.voidType, [mp.reference, mts.reference]).check();
}

/// from: android.media.MediaPlayer$OnInfoListener
///
/// Interface definition of a callback to be invoked to communicate some
/// info and/or warning about the media or its playback.
class MediaPlayer_OnInfoListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$OnInfoListener");
  MediaPlayer_OnInfoListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onInfo = jniAccessors.getMethodIDOf(
      _classRef, "onInfo", "(Landroid/media/MediaPlayer;II)Z");

  /// from: public abstract boolean onInfo(android.media.MediaPlayer mp, int what, int extra)
  ///
  /// Called to indicate an info or a warning.
  ///@param mp the MediaPlayer the info pertains to.
  ///@param what the type of info or warning.
  /// <ul>
  /// <li>\#MEDIA_INFO_UNKNOWN
  /// <li>\#MEDIA_INFO_VIDEO_TRACK_LAGGING
  /// <li>\#MEDIA_INFO_VIDEO_RENDERING_START
  /// <li>\#MEDIA_INFO_BUFFERING_START
  /// <li>\#MEDIA_INFO_BUFFERING_END
  /// <li><code>MEDIA_INFO_NETWORK_BANDWIDTH (703)</code> -
  ///     bandwidth information is available (as <code>extra</code> kbps)
  /// <li>\#MEDIA_INFO_BAD_INTERLEAVING
  /// <li>\#MEDIA_INFO_NOT_SEEKABLE
  /// <li>\#MEDIA_INFO_METADATA_UPDATE
  /// <li>\#MEDIA_INFO_UNSUPPORTED_SUBTITLE
  /// <li>\#MEDIA_INFO_SUBTITLE_TIMED_OUT
  /// </ul>
  ///@param extra an extra code, specific to the info. Typically
  /// implementation dependent.
  ///@return True if the method handled the info, false if it didn't.
  /// Returning false, or not having an OnInfoListener at all, will
  /// cause the info to be discarded.
  bool onInfo(MediaPlayer mp, int what, int extra) =>
      jniAccessors.callMethodWithArgs(reference, _id_onInfo,
          jni.JniType.booleanType, [mp.reference, what, extra]).boolean;
}

/// from: android.media.MediaPlayer$OnErrorListener
///
/// Interface definition of a callback to be invoked when there
/// has been an error during an asynchronous operation (other errors
/// will throw exceptions at method call time).
class MediaPlayer_OnErrorListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$OnErrorListener");
  MediaPlayer_OnErrorListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onError = jniAccessors.getMethodIDOf(
      _classRef, "onError", "(Landroid/media/MediaPlayer;II)Z");

  /// from: public abstract boolean onError(android.media.MediaPlayer mp, int what, int extra)
  ///
  /// Called to indicate an error.
  ///@param mp the MediaPlayer the error pertains to
  ///@param what the type of error that has occurred:
  /// <ul>
  /// <li>\#MEDIA_ERROR_UNKNOWN
  /// <li>\#MEDIA_ERROR_SERVER_DIED
  /// </ul>
  ///@param extra an extra code, specific to the error. Typically
  /// implementation dependent.
  /// <ul>
  /// <li>\#MEDIA_ERROR_IO
  /// <li>\#MEDIA_ERROR_MALFORMED
  /// <li>\#MEDIA_ERROR_UNSUPPORTED
  /// <li>\#MEDIA_ERROR_TIMED_OUT
  /// <li><code>MEDIA_ERROR_SYSTEM (-2147483648)</code> - low-level system error.
  /// </ul>
  ///@return True if the method handled the error, false if it didn't.
  /// Returning false, or not having an OnErrorListener at all, will
  /// cause the OnCompletionListener to be called.
  bool onError(MediaPlayer mp, int what, int extra) =>
      jniAccessors.callMethodWithArgs(reference, _id_onError,
          jni.JniType.booleanType, [mp.reference, what, extra]).boolean;
}

/// from: android.media.MediaPlayer$OnDrmPreparedListener
///
/// Interface definition of a callback to notify the app when the
/// DRM is ready for key request/response
class MediaPlayer_OnDrmPreparedListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaPlayer\$OnDrmPreparedListener");
  MediaPlayer_OnDrmPreparedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onDrmPrepared = jniAccessors.getMethodIDOf(
      _classRef, "onDrmPrepared", "(Landroid/media/MediaPlayer;I)V");

  /// from: public abstract void onDrmPrepared(android.media.MediaPlayer mp, int status)
  ///
  /// Called to notify the app that prepareDrm is finished and ready for key request/response
  ///@param mp the {@code MediaPlayer} associated with this callback
  ///@param status the result of DRM preparation which can be
  /// \#PREPARE_DRM_STATUS_SUCCESS,
  /// \#PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR,
  /// \#PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR, or
  /// \#PREPARE_DRM_STATUS_PREPARATION_ERROR.
  ///
  /// Value is android.media.MediaPlayer\#PREPARE_DRM_STATUS_SUCCESS, android.media.MediaPlayer\#PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR, android.media.MediaPlayer\#PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR, or android.media.MediaPlayer\#PREPARE_DRM_STATUS_PREPARATION_ERROR
  void onDrmPrepared(MediaPlayer mp, int status) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDrmPrepared,
          jni.JniType.voidType, [mp.reference, status]).check();
}

/// from: android.media.MediaPlayer$OnDrmInfoListener
///
/// Interface definition of a callback to be invoked when the
/// DRM info becomes available
class MediaPlayer_OnDrmInfoListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$OnDrmInfoListener");
  MediaPlayer_OnDrmInfoListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onDrmInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "onDrmInfo",
      "(Landroid/media/MediaPlayer;Landroid/media/MediaPlayer\$DrmInfo;)V");

  /// from: public abstract void onDrmInfo(android.media.MediaPlayer mp, android.media.MediaPlayer.DrmInfo drmInfo)
  ///
  /// Called to indicate DRM info is available
  ///@param mp the {@code MediaPlayer} associated with this callback
  ///@param drmInfo DRM info of the source including PSSH, and subset
  ///                of crypto schemes supported by this device
  void onDrmInfo(MediaPlayer mp, MediaPlayer_DrmInfo drmInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDrmInfo,
          jni.JniType.voidType, [mp.reference, drmInfo.reference]).check();
}

/// from: android.media.MediaPlayer$OnDrmConfigHelper
///
/// Interface definition of a callback to be invoked when the app
/// can do DRM configuration (get/set properties) before the session
/// is opened. This facilitates configuration of the properties, like
/// 'securityLevel', which has to be set after DRM scheme creation but
/// before the DRM session is opened.
///
/// The only allowed DRM calls in this listener are {@code getDrmPropertyString}
/// and {@code setDrmPropertyString}.
class MediaPlayer_OnDrmConfigHelper extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$OnDrmConfigHelper");
  MediaPlayer_OnDrmConfigHelper.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onDrmConfig = jniAccessors.getMethodIDOf(
      _classRef, "onDrmConfig", "(Landroid/media/MediaPlayer;)V");

  /// from: public abstract void onDrmConfig(android.media.MediaPlayer mp)
  ///
  /// Called to give the app the opportunity to configure DRM before the session is created
  ///@param mp the {@code MediaPlayer} associated with this callback
  void onDrmConfig(MediaPlayer mp) => jniAccessors.callMethodWithArgs(
      reference, _id_onDrmConfig, jni.JniType.voidType, [mp.reference]).check();
}

/// from: android.media.MediaPlayer$OnCompletionListener
///
/// Interface definition for a callback to be invoked when playback of
/// a media source has completed.
class MediaPlayer_OnCompletionListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaPlayer\$OnCompletionListener");
  MediaPlayer_OnCompletionListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onCompletion = jniAccessors.getMethodIDOf(
      _classRef, "onCompletion", "(Landroid/media/MediaPlayer;)V");

  /// from: public abstract void onCompletion(android.media.MediaPlayer mp)
  ///
  /// Called when the end of a media source is reached during playback.
  ///@param mp the MediaPlayer that reached the end of the file
  void onCompletion(MediaPlayer mp) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCompletion,
      jni.JniType.voidType,
      [mp.reference]).check();
}

/// from: android.media.MediaPlayer$OnBufferingUpdateListener
///
/// Interface definition of a callback to be invoked indicating buffering
/// status of a media resource being streamed over the network.
class MediaPlayer_OnBufferingUpdateListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaPlayer\$OnBufferingUpdateListener");
  MediaPlayer_OnBufferingUpdateListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onBufferingUpdate = jniAccessors.getMethodIDOf(
      _classRef, "onBufferingUpdate", "(Landroid/media/MediaPlayer;I)V");

  /// from: public abstract void onBufferingUpdate(android.media.MediaPlayer mp, int percent)
  ///
  /// Called to update status in buffering a media stream received through
  /// progressive HTTP download. The received buffering percentage
  /// indicates how much of the content has been buffered or played.
  /// For example a buffering update of 80 percent when half the content
  /// has already been played indicates that the next 30 percent of the
  /// content to play has been buffered.
  ///@param mp the MediaPlayer the update pertains to
  ///@param percent the percentage (0-100) of the content
  ///                that has been buffered or played thus far
  void onBufferingUpdate(MediaPlayer mp, int percent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onBufferingUpdate,
          jni.JniType.voidType, [mp.reference, percent]).check();
}

/// from: android.media.MediaPlayer$NoDrmSchemeException
///
/// Thrown when a DRM method is called before preparing a DRM scheme through prepareDrm().
/// Extends MediaDrm.MediaDrmException
class MediaPlayer_NoDrmSchemeException
    extends mediadrmexception_.MediaDrmException {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaPlayer\$NoDrmSchemeException");
  MediaPlayer_NoDrmSchemeException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String detailMessage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaPlayer_NoDrmSchemeException(jni.JniString detailMessage)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [detailMessage.reference]).object);
}

/// from: android.media.MediaPlayer$MetricsConstants
class MediaPlayer_MetricsConstants extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$MetricsConstants");
  MediaPlayer_MetricsConstants.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CODEC_AUDIO
  ///
  /// Key to extract the codec being used to decode the audio track
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is a String.
  static const CODEC_AUDIO = "android.media.mediaplayer.audio.codec";

  /// from: static public final java.lang.String CODEC_VIDEO
  ///
  /// Key to extract the codec being used to decode the video track
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is a String.
  static const CODEC_VIDEO = "android.media.mediaplayer.video.codec";

  /// from: static public final java.lang.String DURATION
  ///
  /// Key to extract the duration (in milliseconds) of the
  /// media being played
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is a long.
  static const DURATION = "android.media.mediaplayer.durationMs";

  /// from: static public final java.lang.String ERRORS
  ///
  /// Key to extract the count of errors encountered while
  /// playing the media
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is an integer.
  static const ERRORS = "android.media.mediaplayer.err";

  /// from: static public final java.lang.String ERROR_CODE
  ///
  /// Key to extract an (optional) error code detected while
  /// playing the media
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is an integer.
  static const ERROR_CODE = "android.media.mediaplayer.errcode";

  /// from: static public final java.lang.String FRAMES
  ///
  /// Key to extract the count of video frames played
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is an integer.
  static const FRAMES = "android.media.mediaplayer.frames";

  /// from: static public final java.lang.String FRAMES_DROPPED
  ///
  /// Key to extract the count of video frames dropped
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is an integer.
  static const FRAMES_DROPPED = "android.media.mediaplayer.dropped";

  /// from: static public final java.lang.String HEIGHT
  ///
  /// Key to extract the height (in pixels) of the video track
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is an integer.
  static const HEIGHT = "android.media.mediaplayer.height";

  /// from: static public final java.lang.String MIME_TYPE_AUDIO
  ///
  /// Key to extract the MIME type of the audio track
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is a String.
  static const MIME_TYPE_AUDIO = "android.media.mediaplayer.audio.mime";

  /// from: static public final java.lang.String MIME_TYPE_VIDEO
  ///
  /// Key to extract the MIME type of the video track
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is a String.
  static const MIME_TYPE_VIDEO = "android.media.mediaplayer.video.mime";

  /// from: static public final java.lang.String PLAYING
  ///
  /// Key to extract the playing time (in milliseconds) of the
  /// media being played
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is a long.
  static const PLAYING = "android.media.mediaplayer.playingMs";

  /// from: static public final java.lang.String WIDTH
  ///
  /// Key to extract the width (in pixels) of the video track
  /// from the MediaPlayer\#getMetrics return value.
  /// The value is an integer.
  static const WIDTH = "android.media.mediaplayer.width";
}

/// from: android.media.MediaPlayer$DrmInfo
///
/// Encapsulates the DRM properties of the source.
class MediaPlayer_DrmInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaPlayer\$DrmInfo");
  MediaPlayer_DrmInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getPssh =
      jniAccessors.getMethodIDOf(_classRef, "getPssh", "()Ljava/util/Map;");

  /// from: public java.util.Map<java.util.UUID,byte[]> getPssh()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the PSSH info of the data source for each supported DRM scheme.
  jni.JniObject getPssh() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPssh, jni.JniType.objectType, []).object);

  static final _id_getSupportedSchemes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedSchemes", "()[Ljava/util/UUID;");

  /// from: public java.util.UUID[] getSupportedSchemes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the intersection of the data source and the device DRM schemes.
  /// It effectively identifies the subset of the source's DRM schemes which
  /// are supported by the device too.
  jni.JniObject getSupportedSchemes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedSchemes, jni.JniType.objectType, []).object);
}
