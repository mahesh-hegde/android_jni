// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../util/Range.dart" as range_;

import "MediaFormat.dart" as mediaformat_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.media.MediaCodecInfo
///
/// Provides information about a given media codec available on the device. You can
/// iterate through all codecs available by querying MediaCodecList. For example,
/// here's how to find an encoder that supports a given MIME type:
/// <pre>
/// private static MediaCodecInfo selectCodec(String mimeType) {
///     int numCodecs = MediaCodecList.getCodecCount();
///     for (int i = 0; i &lt; numCodecs; i++) {
///         MediaCodecInfo codecInfo = MediaCodecList.getCodecInfoAt(i);
///
///         if (!codecInfo.isEncoder()) {
///             continue;
///         }
///
///         String[] types = codecInfo.getSupportedTypes();
///         for (int j = 0; j &lt; types.length; j++) {
///             if (types[j].equalsIgnoreCase(mimeType)) {
///                 return codecInfo;
///             }
///         }
///     }
///     return null;
/// }</pre>
class MediaCodecInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/media/MediaCodecInfo");
  MediaCodecInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the codec name.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_isEncoder =
      jniAccessors.getMethodIDOf(_classRef, "isEncoder", "()Z");

  /// from: public boolean isEncoder()
  ///
  /// Query if the codec is an encoder.
  bool isEncoder() => jniAccessors.callMethodWithArgs(
      reference, _id_isEncoder, jni.JniType.booleanType, []).boolean;

  static final _id_getSupportedTypes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedTypes", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getSupportedTypes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the media types supported by the codec.
  jni.JniObject getSupportedTypes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSupportedTypes, jni.JniType.objectType, []).object);

  static final _id_getCapabilitiesForType = jniAccessors.getMethodIDOf(
      _classRef,
      "getCapabilitiesForType",
      "(Ljava/lang/String;)Landroid/media/MediaCodecInfo\$CodecCapabilities;");

  /// from: public android.media.MediaCodecInfo.CodecCapabilities getCapabilitiesForType(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enumerates the capabilities of the codec component. Since a single
  /// component can support data of a variety of types, the type has to be
  /// specified to yield a meaningful result.
  ///@param type The MIME type to query
  MediaCodecInfo_CodecCapabilities getCapabilitiesForType(jni.JniString type) =>
      MediaCodecInfo_CodecCapabilities.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCapabilitiesForType,
          jni.JniType.objectType,
          [type.reference]).object);
}

/// from: android.media.MediaCodecInfo$VideoCapabilities
///
/// A class that supports querying the video capabilities of a codec.
class MediaCodecInfo_VideoCapabilities extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaCodecInfo\$VideoCapabilities");
  MediaCodecInfo_VideoCapabilities.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_getBitrateRange = jniAccessors.getMethodIDOf(
      _classRef, "getBitrateRange", "()Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getBitrateRange()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of supported bitrates in bits/second.
  range_.Range getBitrateRange() =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBitrateRange, jni.JniType.objectType, []).object);

  static final _id_getSupportedWidths = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedWidths", "()Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getSupportedWidths()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of supported video widths.
  range_.Range getSupportedWidths() =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedWidths, jni.JniType.objectType, []).object);

  static final _id_getSupportedHeights = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedHeights", "()Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getSupportedHeights()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of supported video heights.
  range_.Range getSupportedHeights() =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedHeights, jni.JniType.objectType, []).object);

  static final _id_getWidthAlignment =
      jniAccessors.getMethodIDOf(_classRef, "getWidthAlignment", "()I");

  /// from: public int getWidthAlignment()
  ///
  /// Returns the alignment requirement for video width (in pixels).
  ///
  /// This is a power-of-2 value that video width must be a
  /// multiple of.
  int getWidthAlignment() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidthAlignment, jni.JniType.intType, []).integer;

  static final _id_getHeightAlignment =
      jniAccessors.getMethodIDOf(_classRef, "getHeightAlignment", "()I");

  /// from: public int getHeightAlignment()
  ///
  /// Returns the alignment requirement for video height (in pixels).
  ///
  /// This is a power-of-2 value that video height must be a
  /// multiple of.
  int getHeightAlignment() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeightAlignment, jni.JniType.intType, []).integer;

  static final _id_getSupportedFrameRates = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedFrameRates", "()Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getSupportedFrameRates()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of supported frame rates.
  ///
  /// This is not a performance indicator.  Rather, it expresses the
  /// limits specified in the coding standard, based on the complexities
  /// of encoding material for later playback at a certain frame rate,
  /// or the decoding of such material in non-realtime.
  range_.Range getSupportedFrameRates() =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedFrameRates, jni.JniType.objectType, []).object);

  static final _id_getSupportedWidthsFor = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedWidthsFor", "(I)Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getSupportedWidthsFor(int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of supported video widths for a video height.
  ///@param height the height of the video
  range_.Range getSupportedWidthsFor(int height) =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedWidthsFor, jni.JniType.objectType, [height]).object);

  static final _id_getSupportedHeightsFor = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedHeightsFor", "(I)Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getSupportedHeightsFor(int width)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of supported video heights for a video width
  ///@param width the width of the video
  range_.Range getSupportedHeightsFor(int width) =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedHeightsFor, jni.JniType.objectType, [width]).object);

  static final _id_getSupportedFrameRatesFor = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedFrameRatesFor", "(II)Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Double> getSupportedFrameRatesFor(int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of supported video frame rates for a video size.
  ///
  /// This is not a performance indicator.  Rather, it expresses the limits specified in
  /// the coding standard, based on the complexities of encoding material of a given
  /// size for later playback at a certain frame rate, or the decoding of such material
  /// in non-realtime.
  ///@param width the width of the video
  ///@param height the height of the video
  range_.Range getSupportedFrameRatesFor(int width, int height) =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSupportedFrameRatesFor,
          jni.JniType.objectType,
          [width, height]).object);

  static final _id_getAchievableFrameRatesFor = jniAccessors.getMethodIDOf(
      _classRef, "getAchievableFrameRatesFor", "(II)Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Double> getAchievableFrameRatesFor(int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of achievable video frame rates for a video size.
  /// May return {@code null}, if the codec did not publish any measurement
  /// data.
  ///
  /// This is a performance estimate provided by the device manufacturer based on statistical
  /// sampling of full-speed decoding and encoding measurements in various configurations
  /// of common video sizes supported by the codec. As such it should only be used to
  /// compare individual codecs on the device. The value is not suitable for comparing
  /// different devices or even different android releases for the same device.
  ///
  /// _On android.os.Build.VERSION_CODES\#M release_ the returned range
  /// corresponds to the fastest frame rates achieved in the tested configurations. As
  /// such, it should not be used to gauge guaranteed or even average codec performance
  /// on the device.
  ///
  /// _On android.os.Build.VERSION_CODES\#N release_ the returned range
  /// corresponds closer to sustained performance _in tested configurations_.
  /// One can expect to achieve sustained performance higher than the lower limit more than
  /// 50% of the time, and higher than half of the lower limit at least 90% of the time
  /// _in tested configurations_.
  /// Conversely, one can expect performance lower than twice the upper limit at least
  /// 90% of the time.
  /// <p class=note>
  /// Tested configurations use a single active codec. For use cases where multiple
  /// codecs are active, applications can expect lower and in most cases significantly lower
  /// performance.
  /// <p class=note>
  /// The returned range value is interpolated from the nearest frame size(s) tested.
  /// Codec performance is severely impacted by other activity on the device as well
  /// as environmental factors (such as battery level, temperature or power source), and can
  /// vary significantly even in a steady environment.
  /// <p class=note>
  /// Use this method in cases where only codec performance matters, e.g. to evaluate if
  /// a codec has any chance of meeting a performance target. Codecs are listed
  /// in MediaCodecList in the preferred order as defined by the device
  /// manufacturer. As such, applications should use the first suitable codec in the
  /// list to achieve the best balance between power use and performance.
  ///@param width the width of the video
  ///@param height the height of the video
  ///@throws IllegalArgumentException if the video size is not supported.
  range_.Range getAchievableFrameRatesFor(int width, int height) =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAchievableFrameRatesFor,
          jni.JniType.objectType,
          [width, height]).object);

  static final _id_areSizeAndRateSupported = jniAccessors.getMethodIDOf(
      _classRef, "areSizeAndRateSupported", "(IID)Z");

  /// from: public boolean areSizeAndRateSupported(int width, int height, double frameRate)
  ///
  /// Returns whether a given video size ({@code width} and
  /// {@code height}) and {@code frameRate} combination is supported.
  bool areSizeAndRateSupported(int width, int height, double frameRate) =>
      jniAccessors.callMethodWithArgs(reference, _id_areSizeAndRateSupported,
          jni.JniType.booleanType, [width, height, frameRate]).boolean;

  static final _id_isSizeSupported =
      jniAccessors.getMethodIDOf(_classRef, "isSizeSupported", "(II)Z");

  /// from: public boolean isSizeSupported(int width, int height)
  ///
  /// Returns whether a given video size ({@code width} and
  /// {@code height}) is supported.
  bool isSizeSupported(int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_isSizeSupported,
          jni.JniType.booleanType, [width, height]).boolean;
}

/// from: android.media.MediaCodecInfo$EncoderCapabilities
///
/// A class that supports querying the encoding capabilities of a codec.
class MediaCodecInfo_EncoderCapabilities extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaCodecInfo\$EncoderCapabilities");
  MediaCodecInfo_EncoderCapabilities.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int BITRATE_MODE_CBR
  ///
  /// Constant bitrate mode
  static const BITRATE_MODE_CBR = 2;

  /// from: static public final int BITRATE_MODE_CQ
  ///
  /// Constant quality mode
  static const BITRATE_MODE_CQ = 0;

  /// from: static public final int BITRATE_MODE_VBR
  ///
  /// Variable bitrate mode
  static const BITRATE_MODE_VBR = 1;

  static final _id_getQualityRange = jniAccessors.getMethodIDOf(
      _classRef, "getQualityRange", "()Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getQualityRange()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the supported range of quality values.
  ///
  /// Quality is implementation-specific. As a general rule, a higher quality
  /// setting results in a better image quality and a lower compression ratio.
  range_.Range getQualityRange() =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getQualityRange, jni.JniType.objectType, []).object);

  static final _id_getComplexityRange = jniAccessors.getMethodIDOf(
      _classRef, "getComplexityRange", "()Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getComplexityRange()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the supported range of encoder complexity values.
  ///
  /// Some codecs may support multiple complexity levels, where higher
  /// complexity values use more encoder tools (e.g. perform more
  /// intensive calculations) to improve the quality or the compression
  /// ratio.  Use a lower value to save power and/or time.
  range_.Range getComplexityRange() =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getComplexityRange, jni.JniType.objectType, []).object);

  static final _id_isBitrateModeSupported =
      jniAccessors.getMethodIDOf(_classRef, "isBitrateModeSupported", "(I)Z");

  /// from: public boolean isBitrateModeSupported(int mode)
  ///
  /// Query whether a bitrate mode is supported.
  bool isBitrateModeSupported(int mode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isBitrateModeSupported,
      jni.JniType.booleanType,
      [mode]).boolean;
}

/// from: android.media.MediaCodecInfo$CodecProfileLevel
///
/// Encapsulates the profiles available for a codec component.
/// You can get a set of MediaCodecInfo.CodecProfileLevel objects for a given
/// MediaCodecInfo object from the
/// MediaCodecInfo.CodecCapabilities\#profileLevels field.
class MediaCodecInfo_CodecProfileLevel extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaCodecInfo\$CodecProfileLevel");
  MediaCodecInfo_CodecProfileLevel.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int AACObjectELD
  static const AACObjectELD = 39;

  /// from: static public final int AACObjectERLC
  static const AACObjectERLC = 17;

  /// from: static public final int AACObjectERScalable
  static const AACObjectERScalable = 20;

  /// from: static public final int AACObjectHE
  static const AACObjectHE = 5;

  /// from: static public final int AACObjectHE_PS
  static const AACObjectHE_PS = 29;

  /// from: static public final int AACObjectLC
  static const AACObjectLC = 2;

  /// from: static public final int AACObjectLD
  static const AACObjectLD = 23;

  /// from: static public final int AACObjectLTP
  static const AACObjectLTP = 4;

  /// from: static public final int AACObjectMain
  static const AACObjectMain = 1;

  /// from: static public final int AACObjectSSR
  static const AACObjectSSR = 3;

  /// from: static public final int AACObjectScalable
  static const AACObjectScalable = 6;

  /// from: static public final int AACObjectXHE
  ///
  /// xHE-AAC (includes USAC)
  static const AACObjectXHE = 42;

  /// from: static public final int AVCLevel1
  static const AVCLevel1 = 1;

  /// from: static public final int AVCLevel11
  static const AVCLevel11 = 4;

  /// from: static public final int AVCLevel12
  static const AVCLevel12 = 8;

  /// from: static public final int AVCLevel13
  static const AVCLevel13 = 16;

  /// from: static public final int AVCLevel1b
  static const AVCLevel1b = 2;

  /// from: static public final int AVCLevel2
  static const AVCLevel2 = 32;

  /// from: static public final int AVCLevel21
  static const AVCLevel21 = 64;

  /// from: static public final int AVCLevel22
  static const AVCLevel22 = 128;

  /// from: static public final int AVCLevel3
  static const AVCLevel3 = 256;

  /// from: static public final int AVCLevel31
  static const AVCLevel31 = 512;

  /// from: static public final int AVCLevel32
  static const AVCLevel32 = 1024;

  /// from: static public final int AVCLevel4
  static const AVCLevel4 = 2048;

  /// from: static public final int AVCLevel41
  static const AVCLevel41 = 4096;

  /// from: static public final int AVCLevel42
  static const AVCLevel42 = 8192;

  /// from: static public final int AVCLevel5
  static const AVCLevel5 = 16384;

  /// from: static public final int AVCLevel51
  static const AVCLevel51 = 32768;

  /// from: static public final int AVCLevel52
  static const AVCLevel52 = 65536;

  /// from: static public final int AVCProfileBaseline
  static const AVCProfileBaseline = 1;

  /// from: static public final int AVCProfileConstrainedBaseline
  static const AVCProfileConstrainedBaseline = 65536;

  /// from: static public final int AVCProfileConstrainedHigh
  static const AVCProfileConstrainedHigh = 524288;

  /// from: static public final int AVCProfileExtended
  static const AVCProfileExtended = 4;

  /// from: static public final int AVCProfileHigh
  static const AVCProfileHigh = 8;

  /// from: static public final int AVCProfileHigh10
  static const AVCProfileHigh10 = 16;

  /// from: static public final int AVCProfileHigh422
  static const AVCProfileHigh422 = 32;

  /// from: static public final int AVCProfileHigh444
  static const AVCProfileHigh444 = 64;

  /// from: static public final int AVCProfileMain
  static const AVCProfileMain = 2;

  /// from: static public final int DolbyVisionLevelFhd24
  static const DolbyVisionLevelFhd24 = 4;

  /// from: static public final int DolbyVisionLevelFhd30
  static const DolbyVisionLevelFhd30 = 8;

  /// from: static public final int DolbyVisionLevelFhd60
  static const DolbyVisionLevelFhd60 = 16;

  /// from: static public final int DolbyVisionLevelHd24
  static const DolbyVisionLevelHd24 = 1;

  /// from: static public final int DolbyVisionLevelHd30
  static const DolbyVisionLevelHd30 = 2;

  /// from: static public final int DolbyVisionLevelUhd24
  static const DolbyVisionLevelUhd24 = 32;

  /// from: static public final int DolbyVisionLevelUhd30
  static const DolbyVisionLevelUhd30 = 64;

  /// from: static public final int DolbyVisionLevelUhd48
  static const DolbyVisionLevelUhd48 = 128;

  /// from: static public final int DolbyVisionLevelUhd60
  static const DolbyVisionLevelUhd60 = 256;

  /// from: static public final int DolbyVisionProfileDvavPen
  static const DolbyVisionProfileDvavPen = 2;

  /// from: static public final int DolbyVisionProfileDvavPer
  static const DolbyVisionProfileDvavPer = 1;

  /// from: static public final int DolbyVisionProfileDvavSe
  static const DolbyVisionProfileDvavSe = 512;

  /// from: static public final int DolbyVisionProfileDvheDen
  static const DolbyVisionProfileDvheDen = 8;

  /// from: static public final int DolbyVisionProfileDvheDer
  static const DolbyVisionProfileDvheDer = 4;

  /// from: static public final int DolbyVisionProfileDvheDtb
  static const DolbyVisionProfileDvheDtb = 128;

  /// from: static public final int DolbyVisionProfileDvheDth
  static const DolbyVisionProfileDvheDth = 64;

  /// from: static public final int DolbyVisionProfileDvheDtr
  static const DolbyVisionProfileDvheDtr = 16;

  /// from: static public final int DolbyVisionProfileDvheSt
  static const DolbyVisionProfileDvheSt = 256;

  /// from: static public final int DolbyVisionProfileDvheStn
  static const DolbyVisionProfileDvheStn = 32;

  /// from: static public final int H263Level10
  static const H263Level10 = 1;

  /// from: static public final int H263Level20
  static const H263Level20 = 2;

  /// from: static public final int H263Level30
  static const H263Level30 = 4;

  /// from: static public final int H263Level40
  static const H263Level40 = 8;

  /// from: static public final int H263Level45
  static const H263Level45 = 16;

  /// from: static public final int H263Level50
  static const H263Level50 = 32;

  /// from: static public final int H263Level60
  static const H263Level60 = 64;

  /// from: static public final int H263Level70
  static const H263Level70 = 128;

  /// from: static public final int H263ProfileBackwardCompatible
  static const H263ProfileBackwardCompatible = 4;

  /// from: static public final int H263ProfileBaseline
  static const H263ProfileBaseline = 1;

  /// from: static public final int H263ProfileH320Coding
  static const H263ProfileH320Coding = 2;

  /// from: static public final int H263ProfileHighCompression
  static const H263ProfileHighCompression = 32;

  /// from: static public final int H263ProfileHighLatency
  static const H263ProfileHighLatency = 256;

  /// from: static public final int H263ProfileISWV2
  static const H263ProfileISWV2 = 8;

  /// from: static public final int H263ProfileISWV3
  static const H263ProfileISWV3 = 16;

  /// from: static public final int H263ProfileInterlace
  static const H263ProfileInterlace = 128;

  /// from: static public final int H263ProfileInternet
  static const H263ProfileInternet = 64;

  /// from: static public final int HEVCHighTierLevel1
  static const HEVCHighTierLevel1 = 2;

  /// from: static public final int HEVCHighTierLevel2
  static const HEVCHighTierLevel2 = 8;

  /// from: static public final int HEVCHighTierLevel21
  static const HEVCHighTierLevel21 = 32;

  /// from: static public final int HEVCHighTierLevel3
  static const HEVCHighTierLevel3 = 128;

  /// from: static public final int HEVCHighTierLevel31
  static const HEVCHighTierLevel31 = 512;

  /// from: static public final int HEVCHighTierLevel4
  static const HEVCHighTierLevel4 = 2048;

  /// from: static public final int HEVCHighTierLevel41
  static const HEVCHighTierLevel41 = 8192;

  /// from: static public final int HEVCHighTierLevel5
  static const HEVCHighTierLevel5 = 32768;

  /// from: static public final int HEVCHighTierLevel51
  static const HEVCHighTierLevel51 = 131072;

  /// from: static public final int HEVCHighTierLevel52
  static const HEVCHighTierLevel52 = 524288;

  /// from: static public final int HEVCHighTierLevel6
  static const HEVCHighTierLevel6 = 2097152;

  /// from: static public final int HEVCHighTierLevel61
  static const HEVCHighTierLevel61 = 8388608;

  /// from: static public final int HEVCHighTierLevel62
  static const HEVCHighTierLevel62 = 33554432;

  /// from: static public final int HEVCMainTierLevel1
  static const HEVCMainTierLevel1 = 1;

  /// from: static public final int HEVCMainTierLevel2
  static const HEVCMainTierLevel2 = 4;

  /// from: static public final int HEVCMainTierLevel21
  static const HEVCMainTierLevel21 = 16;

  /// from: static public final int HEVCMainTierLevel3
  static const HEVCMainTierLevel3 = 64;

  /// from: static public final int HEVCMainTierLevel31
  static const HEVCMainTierLevel31 = 256;

  /// from: static public final int HEVCMainTierLevel4
  static const HEVCMainTierLevel4 = 1024;

  /// from: static public final int HEVCMainTierLevel41
  static const HEVCMainTierLevel41 = 4096;

  /// from: static public final int HEVCMainTierLevel5
  static const HEVCMainTierLevel5 = 16384;

  /// from: static public final int HEVCMainTierLevel51
  static const HEVCMainTierLevel51 = 65536;

  /// from: static public final int HEVCMainTierLevel52
  static const HEVCMainTierLevel52 = 262144;

  /// from: static public final int HEVCMainTierLevel6
  static const HEVCMainTierLevel6 = 1048576;

  /// from: static public final int HEVCMainTierLevel61
  static const HEVCMainTierLevel61 = 4194304;

  /// from: static public final int HEVCMainTierLevel62
  static const HEVCMainTierLevel62 = 16777216;

  /// from: static public final int HEVCProfileMain
  static const HEVCProfileMain = 1;

  /// from: static public final int HEVCProfileMain10
  static const HEVCProfileMain10 = 2;

  /// from: static public final int HEVCProfileMain10HDR10
  static const HEVCProfileMain10HDR10 = 4096;

  /// from: static public final int HEVCProfileMainStill
  static const HEVCProfileMainStill = 4;

  /// from: static public final int MPEG2LevelH14
  static const MPEG2LevelH14 = 2;

  /// from: static public final int MPEG2LevelHL
  static const MPEG2LevelHL = 3;

  /// from: static public final int MPEG2LevelHP
  static const MPEG2LevelHP = 4;

  /// from: static public final int MPEG2LevelLL
  static const MPEG2LevelLL = 0;

  /// from: static public final int MPEG2LevelML
  static const MPEG2LevelML = 1;

  /// from: static public final int MPEG2Profile422
  static const MPEG2Profile422 = 2;

  /// from: static public final int MPEG2ProfileHigh
  static const MPEG2ProfileHigh = 5;

  /// from: static public final int MPEG2ProfileMain
  static const MPEG2ProfileMain = 1;

  /// from: static public final int MPEG2ProfileSNR
  static const MPEG2ProfileSNR = 3;

  /// from: static public final int MPEG2ProfileSimple
  static const MPEG2ProfileSimple = 0;

  /// from: static public final int MPEG2ProfileSpatial
  static const MPEG2ProfileSpatial = 4;

  /// from: static public final int MPEG4Level0
  static const MPEG4Level0 = 1;

  /// from: static public final int MPEG4Level0b
  static const MPEG4Level0b = 2;

  /// from: static public final int MPEG4Level1
  static const MPEG4Level1 = 4;

  /// from: static public final int MPEG4Level2
  static const MPEG4Level2 = 8;

  /// from: static public final int MPEG4Level3
  static const MPEG4Level3 = 16;

  /// from: static public final int MPEG4Level3b
  static const MPEG4Level3b = 24;

  /// from: static public final int MPEG4Level4
  static const MPEG4Level4 = 32;

  /// from: static public final int MPEG4Level4a
  static const MPEG4Level4a = 64;

  /// from: static public final int MPEG4Level5
  static const MPEG4Level5 = 128;

  /// from: static public final int MPEG4Level6
  static const MPEG4Level6 = 256;

  /// from: static public final int MPEG4ProfileAdvancedCoding
  static const MPEG4ProfileAdvancedCoding = 4096;

  /// from: static public final int MPEG4ProfileAdvancedCore
  static const MPEG4ProfileAdvancedCore = 8192;

  /// from: static public final int MPEG4ProfileAdvancedRealTime
  static const MPEG4ProfileAdvancedRealTime = 1024;

  /// from: static public final int MPEG4ProfileAdvancedScalable
  static const MPEG4ProfileAdvancedScalable = 16384;

  /// from: static public final int MPEG4ProfileAdvancedSimple
  static const MPEG4ProfileAdvancedSimple = 32768;

  /// from: static public final int MPEG4ProfileBasicAnimated
  static const MPEG4ProfileBasicAnimated = 256;

  /// from: static public final int MPEG4ProfileCore
  static const MPEG4ProfileCore = 4;

  /// from: static public final int MPEG4ProfileCoreScalable
  static const MPEG4ProfileCoreScalable = 2048;

  /// from: static public final int MPEG4ProfileHybrid
  static const MPEG4ProfileHybrid = 512;

  /// from: static public final int MPEG4ProfileMain
  static const MPEG4ProfileMain = 8;

  /// from: static public final int MPEG4ProfileNbit
  static const MPEG4ProfileNbit = 16;

  /// from: static public final int MPEG4ProfileScalableTexture
  static const MPEG4ProfileScalableTexture = 32;

  /// from: static public final int MPEG4ProfileSimple
  static const MPEG4ProfileSimple = 1;

  /// from: static public final int MPEG4ProfileSimpleFBA
  static const MPEG4ProfileSimpleFBA = 128;

  /// from: static public final int MPEG4ProfileSimpleFace
  static const MPEG4ProfileSimpleFace = 64;

  /// from: static public final int MPEG4ProfileSimpleScalable
  static const MPEG4ProfileSimpleScalable = 2;

  /// from: static public final int VP8Level_Version0
  static const VP8Level_Version0 = 1;

  /// from: static public final int VP8Level_Version1
  static const VP8Level_Version1 = 2;

  /// from: static public final int VP8Level_Version2
  static const VP8Level_Version2 = 4;

  /// from: static public final int VP8Level_Version3
  static const VP8Level_Version3 = 8;

  /// from: static public final int VP8ProfileMain
  static const VP8ProfileMain = 1;

  /// from: static public final int VP9Level1
  static const VP9Level1 = 1;

  /// from: static public final int VP9Level11
  static const VP9Level11 = 2;

  /// from: static public final int VP9Level2
  static const VP9Level2 = 4;

  /// from: static public final int VP9Level21
  static const VP9Level21 = 8;

  /// from: static public final int VP9Level3
  static const VP9Level3 = 16;

  /// from: static public final int VP9Level31
  static const VP9Level31 = 32;

  /// from: static public final int VP9Level4
  static const VP9Level4 = 64;

  /// from: static public final int VP9Level41
  static const VP9Level41 = 128;

  /// from: static public final int VP9Level5
  static const VP9Level5 = 256;

  /// from: static public final int VP9Level51
  static const VP9Level51 = 512;

  /// from: static public final int VP9Level52
  static const VP9Level52 = 1024;

  /// from: static public final int VP9Level6
  static const VP9Level6 = 2048;

  /// from: static public final int VP9Level61
  static const VP9Level61 = 4096;

  /// from: static public final int VP9Level62
  static const VP9Level62 = 8192;

  /// from: static public final int VP9Profile0
  static const VP9Profile0 = 1;

  /// from: static public final int VP9Profile1
  static const VP9Profile1 = 2;

  /// from: static public final int VP9Profile2
  static const VP9Profile2 = 4;

  /// from: static public final int VP9Profile2HDR
  static const VP9Profile2HDR = 4096;

  /// from: static public final int VP9Profile3
  static const VP9Profile3 = 8;

  /// from: static public final int VP9Profile3HDR
  static const VP9Profile3HDR = 8192;

  static final _id_level = jniAccessors.getFieldIDOf(_classRef, "level", "I");

  /// from: public int level
  ///
  /// Defined in the OpenMAX IL specs, depending on the type of media
  /// this can be OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE
  /// OMX_VIDEO_MPEG4LEVELTYPE, OMX_VIDEO_VP8LEVELTYPE or OMX_VIDEO_VP9LEVELTYPE.
  ///
  /// Note that VP9 decoder on platforms before android.os.Build.VERSION_CODES\#N may
  /// not advertise a profile level support. For those VP9 decoders, please use
  /// VideoCapabilities to determine the codec capabilities.
  int get level =>
      jniAccessors.getField(reference, _id_level, jni.JniType.intType).integer;

  /// from: public int level
  ///
  /// Defined in the OpenMAX IL specs, depending on the type of media
  /// this can be OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE
  /// OMX_VIDEO_MPEG4LEVELTYPE, OMX_VIDEO_VP8LEVELTYPE or OMX_VIDEO_VP9LEVELTYPE.
  ///
  /// Note that VP9 decoder on platforms before android.os.Build.VERSION_CODES\#N may
  /// not advertise a profile level support. For those VP9 decoders, please use
  /// VideoCapabilities to determine the codec capabilities.
  set level(int value) => jniEnv.SetIntField(reference, _id_level, value);

  static final _id_profile =
      jniAccessors.getFieldIDOf(_classRef, "profile", "I");

  /// from: public int profile
  ///
  /// Defined in the OpenMAX IL specs, depending on the type of media
  /// this can be OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE,
  /// OMX_VIDEO_MPEG4PROFILETYPE, OMX_VIDEO_VP8PROFILETYPE or OMX_VIDEO_VP9PROFILETYPE.
  int get profile => jniAccessors
      .getField(reference, _id_profile, jni.JniType.intType)
      .integer;

  /// from: public int profile
  ///
  /// Defined in the OpenMAX IL specs, depending on the type of media
  /// this can be OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE,
  /// OMX_VIDEO_MPEG4PROFILETYPE, OMX_VIDEO_VP8PROFILETYPE or OMX_VIDEO_VP9PROFILETYPE.
  set profile(int value) => jniEnv.SetIntField(reference, _id_profile, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaCodecInfo_CodecProfileLevel()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}

/// from: android.media.MediaCodecInfo$CodecCapabilities
///
/// Encapsulates the capabilities of a given codec component.
/// For example, what profile/level combinations it supports and what colorspaces
/// it is capable of providing the decoded data in, as well as some
/// codec-type specific capability flags.
/// You can get an instance for a given MediaCodecInfo object with
/// MediaCodecInfo\#getCapabilitiesForType getCapabilitiesForType(), passing a MIME type.
class MediaCodecInfo_CodecCapabilities extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaCodecInfo\$CodecCapabilities");
  MediaCodecInfo_CodecCapabilities.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int COLOR_Format12bitRGB444
  ///
  /// @deprecated Use \#COLOR_Format24bitBGR888.
  static const COLOR_Format12bitRGB444 = 3;

  /// from: static public final int COLOR_Format16bitARGB1555
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888.
  static const COLOR_Format16bitARGB1555 = 5;

  /// from: static public final int COLOR_Format16bitARGB4444
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888.
  static const COLOR_Format16bitARGB4444 = 4;

  /// from: static public final int COLOR_Format16bitBGR565
  ///
  /// @deprecated Use \#COLOR_Format16bitRGB565.
  static const COLOR_Format16bitBGR565 = 7;

  /// from: static public final int COLOR_Format16bitRGB565
  ///
  /// 16 bits per pixel RGB color format, with 5-bit red & blue and 6-bit green component.
  ///
  /// Using 16-bit little-endian representation, colors stored as Red 15:11, Green 10:5, Blue 4:0.
  /// <pre>
  ///            byte                   byte
  ///  <--------- i --------> | <------ i + 1 ------>
  /// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  /// |     BLUE     |      GREEN      |     RED      |
  /// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  ///  0           4  5     7   0     2  3           7
  /// bit
  /// </pre>
  ///
  /// This format corresponds to android.graphics.PixelFormat\#RGB_565 and
  /// android.graphics.ImageFormat\#RGB_565.
  static const COLOR_Format16bitRGB565 = 6;

  /// from: static public final int COLOR_Format18BitBGR666
  ///
  /// @deprecated Use \#COLOR_Format24bitBGR888.
  static const COLOR_Format18BitBGR666 = 41;

  /// from: static public final int COLOR_Format18bitARGB1665
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888.
  static const COLOR_Format18bitARGB1665 = 9;

  /// from: static public final int COLOR_Format18bitRGB666
  ///
  /// @deprecated Use \#COLOR_Format24bitBGR888.
  static const COLOR_Format18bitRGB666 = 8;

  /// from: static public final int COLOR_Format19bitARGB1666
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888.
  static const COLOR_Format19bitARGB1666 = 10;

  /// from: static public final int COLOR_Format24BitABGR6666
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888.
  static const COLOR_Format24BitABGR6666 = 43;

  /// from: static public final int COLOR_Format24BitARGB6666
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888.
  static const COLOR_Format24BitARGB6666 = 42;

  /// from: static public final int COLOR_Format24bitARGB1887
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888.
  static const COLOR_Format24bitARGB1887 = 13;

  /// from: static public final int COLOR_Format24bitBGR888
  ///
  /// 24 bits per pixel RGB color format, with 8-bit red, green & blue components.
  ///
  /// Using 24-bit little-endian representation, colors stored as Red 7:0, Green 15:8, Blue 23:16.
  /// <pre>
  ///         byte              byte             byte
  ///  <------ i -----> | <---- i+1 ----> | <---- i+2 ----->
  /// +-----------------+-----------------+-----------------+
  /// |       RED       |      GREEN      |       BLUE      |
  /// +-----------------+-----------------+-----------------+
  /// </pre>
  ///
  /// This format corresponds to android.graphics.PixelFormat\#RGB_888, and can also be
  /// represented as a flexible format by \#COLOR_FormatRGBFlexible.
  static const COLOR_Format24bitBGR888 = 12;

  /// from: static public final int COLOR_Format24bitRGB888
  ///
  /// @deprecated Use \#COLOR_Format24bitBGR888 or \#COLOR_FormatRGBFlexible.
  static const COLOR_Format24bitRGB888 = 11;

  /// from: static public final int COLOR_Format25bitARGB1888
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888.
  static const COLOR_Format25bitARGB1888 = 14;

  /// from: static public final int COLOR_Format32bitABGR8888
  ///
  /// 32 bits per pixel RGBA color format, with 8-bit red, green, blue, and alpha components.
  ///
  /// Using 32-bit little-endian representation, colors stored as Red 7:0, Green 15:8,
  /// Blue 23:16, and Alpha 31:24.
  /// <pre>
  ///         byte              byte             byte              byte
  ///  <------ i -----> | <---- i+1 ----> | <---- i+2 ----> | <---- i+3 ----->
  /// +-----------------+-----------------+-----------------+-----------------+
  /// |       RED       |      GREEN      |       BLUE      |      ALPHA      |
  /// +-----------------+-----------------+-----------------+-----------------+
  /// </pre>
  ///
  /// This corresponds to android.graphics.PixelFormat\#RGBA_8888.
  static const COLOR_Format32bitABGR8888 = 2130747392;

  /// from: static public final int COLOR_Format32bitARGB8888
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888 Or \#COLOR_FormatRGBAFlexible.
  static const COLOR_Format32bitARGB8888 = 16;

  /// from: static public final int COLOR_Format32bitBGRA8888
  ///
  /// @deprecated Use \#COLOR_Format32bitABGR8888 Or \#COLOR_FormatRGBAFlexible.
  static const COLOR_Format32bitBGRA8888 = 15;

  /// from: static public final int COLOR_Format8bitRGB332
  ///
  /// @deprecated Use \#COLOR_Format24bitBGR888.
  static const COLOR_Format8bitRGB332 = 2;

  /// from: static public final int COLOR_FormatCbYCrY
  ///
  /// @deprecated Use \#COLOR_FormatYUV422Flexible.
  static const COLOR_FormatCbYCrY = 27;

  /// from: static public final int COLOR_FormatCrYCbY
  ///
  /// @deprecated Use \#COLOR_FormatYUV422Flexible.
  static const COLOR_FormatCrYCbY = 28;

  /// from: static public final int COLOR_FormatL16
  ///
  /// 16 bits per pixel, little-endian Y color format.
  ///
  /// <pre>
  ///            byte                   byte
  ///  <--------- i --------> | <------ i + 1 ------>
  /// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  /// |                       Y                       |
  /// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  ///  0                    7   0                    7
  /// bit
  /// </pre>
  static const COLOR_FormatL16 = 36;

  /// from: static public final int COLOR_FormatL2
  ///
  /// @deprecated Use \#COLOR_FormatL8.
  static const COLOR_FormatL2 = 33;

  /// from: static public final int COLOR_FormatL24
  ///
  /// @deprecated Use \#COLOR_FormatL16.
  static const COLOR_FormatL24 = 37;

  /// from: static public final int COLOR_FormatL32
  ///
  /// 32 bits per pixel, little-endian Y color format.
  ///
  /// <pre>
  ///         byte              byte             byte              byte
  ///  <------ i -----> | <---- i+1 ----> | <---- i+2 ----> | <---- i+3 ----->
  /// +-----------------+-----------------+-----------------+-----------------+
  /// |                                   Y                                   |
  /// +-----------------+-----------------+-----------------+-----------------+
  ///  0               7 0               7 0               7 0               7
  /// bit
  /// </pre>
  ///@deprecated Use \#COLOR_FormatL16.
  static const COLOR_FormatL32 = 38;

  /// from: static public final int COLOR_FormatL4
  ///
  /// @deprecated Use \#COLOR_FormatL8.
  static const COLOR_FormatL4 = 34;

  /// from: static public final int COLOR_FormatL8
  ///
  /// 8 bits per pixel Y color format.
  ///
  /// Each byte contains a single pixel.
  /// This format corresponds to android.graphics.PixelFormat\#L_8.
  static const COLOR_FormatL8 = 35;

  /// from: static public final int COLOR_FormatMonochrome
  ///
  /// @deprecated Use \#COLOR_Format24bitBGR888.
  static const COLOR_FormatMonochrome = 1;

  /// from: static public final int COLOR_FormatRGBAFlexible
  ///
  /// Flexible 32 bits per pixel RGBA color format with 8-bit red, green, blue, and alpha
  /// components.
  ///
  /// Use this format with Image. This format corresponds to
  /// android.graphics.ImageFormat\#FLEX_RGBA_8888, and can represent
  /// \#COLOR_Format32bitBGRA8888, \#COLOR_Format32bitABGR8888 and
  /// \#COLOR_Format32bitARGB8888 formats.
  ///@see Image\#getFormat
  static const COLOR_FormatRGBAFlexible = 2134288520;

  /// from: static public final int COLOR_FormatRGBFlexible
  ///
  /// Flexible 24 bits per pixel RGB color format with 8-bit red, green and blue
  /// components.
  ///
  /// Use this format with Image. This format corresponds to
  /// android.graphics.ImageFormat\#FLEX_RGB_888, and can represent
  /// \#COLOR_Format24bitBGR888 and \#COLOR_Format24bitRGB888 formats.
  ///@see Image\#getFormat.
  static const COLOR_FormatRGBFlexible = 2134292616;

  /// from: static public final int COLOR_FormatRawBayer10bit
  ///
  /// SMIA 10-bit Bayer format.
  static const COLOR_FormatRawBayer10bit = 31;

  /// from: static public final int COLOR_FormatRawBayer8bit
  ///
  /// SMIA 8-bit Bayer format.
  /// Each byte represents the top 8-bits of a 10-bit signal.
  static const COLOR_FormatRawBayer8bit = 30;

  /// from: static public final int COLOR_FormatRawBayer8bitcompressed
  ///
  /// SMIA 8-bit compressed Bayer format.
  /// Each byte represents a sample from the 10-bit signal that is compressed into 8-bits
  /// using DPCM/PCM compression, as defined by the SMIA Functional Specification.
  static const COLOR_FormatRawBayer8bitcompressed = 32;

  /// from: static public final int COLOR_FormatSurface
  static const COLOR_FormatSurface = 2130708361;

  /// from: static public final int COLOR_FormatYCbYCr
  ///
  /// @deprecated Use \#COLOR_FormatYUV422Flexible.
  static const COLOR_FormatYCbYCr = 25;

  /// from: static public final int COLOR_FormatYCrYCb
  ///
  /// @deprecated Use \#COLOR_FormatYUV422Flexible.
  static const COLOR_FormatYCrYCb = 26;

  /// from: static public final int COLOR_FormatYUV411PackedPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV420Flexible.
  static const COLOR_FormatYUV411PackedPlanar = 18;

  /// from: static public final int COLOR_FormatYUV411Planar
  ///
  /// @deprecated Use \#COLOR_FormatYUV420Flexible.
  static const COLOR_FormatYUV411Planar = 17;

  /// from: static public final int COLOR_FormatYUV420Flexible
  ///
  /// Flexible 12 bits per pixel, subsampled YUV color format with 8-bit chroma and luma
  /// components.
  ///
  /// Chroma planes are subsampled by 2 both horizontally and vertically.
  /// Use this format with Image.
  /// This format corresponds to android.graphics.ImageFormat\#YUV_420_888,
  /// and can represent the \#COLOR_FormatYUV411Planar,
  /// \#COLOR_FormatYUV411PackedPlanar, \#COLOR_FormatYUV420Planar,
  /// \#COLOR_FormatYUV420PackedPlanar, \#COLOR_FormatYUV420SemiPlanar
  /// and \#COLOR_FormatYUV420PackedSemiPlanar formats.
  ///@see Image\#getFormat
  static const COLOR_FormatYUV420Flexible = 2135033992;

  /// from: static public final int COLOR_FormatYUV420PackedPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV420Flexible.
  static const COLOR_FormatYUV420PackedPlanar = 20;

  /// from: static public final int COLOR_FormatYUV420PackedSemiPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV420Flexible.
  static const COLOR_FormatYUV420PackedSemiPlanar = 39;

  /// from: static public final int COLOR_FormatYUV420Planar
  ///
  /// @deprecated Use \#COLOR_FormatYUV420Flexible.
  static const COLOR_FormatYUV420Planar = 19;

  /// from: static public final int COLOR_FormatYUV420SemiPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV420Flexible.
  static const COLOR_FormatYUV420SemiPlanar = 21;

  /// from: static public final int COLOR_FormatYUV422Flexible
  ///
  /// Flexible 16 bits per pixel, subsampled YUV color format with 8-bit chroma and luma
  /// components.
  ///
  /// Chroma planes are horizontally subsampled by 2. Use this format with Image.
  /// This format corresponds to android.graphics.ImageFormat\#YUV_422_888,
  /// and can represent the \#COLOR_FormatYCbYCr, \#COLOR_FormatYCrYCb,
  /// \#COLOR_FormatCbYCrY, \#COLOR_FormatCrYCbY,
  /// \#COLOR_FormatYUV422Planar, \#COLOR_FormatYUV422PackedPlanar,
  /// \#COLOR_FormatYUV422SemiPlanar and \#COLOR_FormatYUV422PackedSemiPlanar
  /// formats.
  ///@see Image\#getFormat
  static const COLOR_FormatYUV422Flexible = 2135042184;

  /// from: static public final int COLOR_FormatYUV422PackedPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV422Flexible.
  static const COLOR_FormatYUV422PackedPlanar = 23;

  /// from: static public final int COLOR_FormatYUV422PackedSemiPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV422Flexible.
  static const COLOR_FormatYUV422PackedSemiPlanar = 40;

  /// from: static public final int COLOR_FormatYUV422Planar
  ///
  /// @deprecated Use \#COLOR_FormatYUV422Flexible.
  static const COLOR_FormatYUV422Planar = 22;

  /// from: static public final int COLOR_FormatYUV422SemiPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV422Flexible.
  static const COLOR_FormatYUV422SemiPlanar = 24;

  /// from: static public final int COLOR_FormatYUV444Flexible
  ///
  /// Flexible 24 bits per pixel YUV color format with 8-bit chroma and luma
  /// components.
  ///
  /// Chroma planes are not subsampled. Use this format with Image.
  /// This format corresponds to android.graphics.ImageFormat\#YUV_444_888,
  /// and can represent the \#COLOR_FormatYUV444Interleaved format.
  ///@see Image\#getFormat
  static const COLOR_FormatYUV444Flexible = 2135181448;

  /// from: static public final int COLOR_FormatYUV444Interleaved
  ///
  /// @deprecated Use \#COLOR_FormatYUV444Flexible.
  static const COLOR_FormatYUV444Interleaved = 29;

  /// from: static public final int COLOR_QCOM_FormatYUV420SemiPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV420Flexible.
  static const COLOR_QCOM_FormatYUV420SemiPlanar = 2141391872;

  /// from: static public final int COLOR_TI_FormatYUV420PackedSemiPlanar
  ///
  /// @deprecated Use \#COLOR_FormatYUV420Flexible.
  static const COLOR_TI_FormatYUV420PackedSemiPlanar = 2130706688;

  /// from: static public final java.lang.String FEATURE_AdaptivePlayback
  ///
  /// __video decoder only__: codec supports seamless resolution changes.
  static const FEATURE_AdaptivePlayback = "adaptive-playback";

  /// from: static public final java.lang.String FEATURE_IntraRefresh
  ///
  /// __video encoder only__: codec supports intra refresh.
  static const FEATURE_IntraRefresh = "intra-refresh";

  /// from: static public final java.lang.String FEATURE_PartialFrame
  ///
  /// __video decoder only__: codec supports queuing partial frames.
  static const FEATURE_PartialFrame = "partial-frame";

  /// from: static public final java.lang.String FEATURE_SecurePlayback
  ///
  /// __video decoder only__: codec supports secure decryption.
  static const FEATURE_SecurePlayback = "secure-playback";

  /// from: static public final java.lang.String FEATURE_TunneledPlayback
  ///
  /// __video or audio decoder only__: codec supports tunneled playback.
  static const FEATURE_TunneledPlayback = "tunneled-playback";

  static final _id_colorFormats =
      jniAccessors.getFieldIDOf(_classRef, "colorFormats", "[I");

  /// from: public int[] colorFormats
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Defined in the OpenMAX IL specs, color format values are drawn from
  /// OMX_COLOR_FORMATTYPE.
  jni.JniObject get colorFormats => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_colorFormats, jni.JniType.objectType)
      .object);

  /// from: public int[] colorFormats
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Defined in the OpenMAX IL specs, color format values are drawn from
  /// OMX_COLOR_FORMATTYPE.
  set colorFormats(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_colorFormats, value.reference);

  static final _id_profileLevels = jniAccessors.getFieldIDOf(_classRef,
      "profileLevels", "[Landroid/media/MediaCodecInfo\$CodecProfileLevel;");

  /// from: public android.media.MediaCodecInfo.CodecProfileLevel[] profileLevels
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get profileLevels => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_profileLevels, jni.JniType.objectType)
      .object);

  /// from: public android.media.MediaCodecInfo.CodecProfileLevel[] profileLevels
  /// The returned object must be deleted after use, by calling the `delete` method.
  set profileLevels(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_profileLevels, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MediaCodecInfo_CodecCapabilities()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_isFeatureSupported = jniAccessors.getMethodIDOf(
      _classRef, "isFeatureSupported", "(Ljava/lang/String;)Z");

  /// from: public boolean isFeatureSupported(java.lang.String name)
  ///
  /// Query codec feature capabilities.
  ///
  /// These features are supported to be used by the codec.  These
  /// include optional features that can be turned on, as well as
  /// features that are always on.
  bool isFeatureSupported(jni.JniString name) =>
      jniAccessors.callMethodWithArgs(reference, _id_isFeatureSupported,
          jni.JniType.booleanType, [name.reference]).boolean;

  static final _id_isFeatureRequired = jniAccessors.getMethodIDOf(
      _classRef, "isFeatureRequired", "(Ljava/lang/String;)Z");

  /// from: public boolean isFeatureRequired(java.lang.String name)
  ///
  /// Query codec feature requirements.
  ///
  /// These features are required to be used by the codec, and as such,
  /// they are always turned on.
  bool isFeatureRequired(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isFeatureRequired,
      jni.JniType.booleanType,
      [name.reference]).boolean;

  static final _id_isFormatSupported = jniAccessors.getMethodIDOf(
      _classRef, "isFormatSupported", "(Landroid/media/MediaFormat;)Z");

  /// from: public boolean isFormatSupported(android.media.MediaFormat format)
  ///
  /// Query whether codec supports a given MediaFormat.
  ///
  /// <p class=note>
  /// <strong>Note:</strong> On android.os.Build.VERSION_CODES\#LOLLIPOP,
  /// {@code format} must not contain a {@linkplain MediaFormat\#KEY_FRAME_RATE frame rate}. Use
  /// <code class=prettyprint>format.setString(MediaFormat.KEY_FRAME_RATE, null)</code>
  /// to clear any existing frame rate setting in the format.
  ///
  ///
  /// The following table summarizes the format keys considered by this method.
  ///
  /// <table style="width: 0%">
  ///  <thead>
  ///   <tr>
  ///    <th rowspan=3>OS Version(s)</th>
  ///    <td colspan=3>{@code MediaFormat} keys considered for</th>
  ///   </tr><tr>
  ///    <th>Audio Codecs</th>
  ///    <th>Video Codecs</th>
  ///    <th>Encoders</th>
  ///   </tr>
  ///  </thead>
  ///  <tbody>
  ///   <tr>
  ///    <td>android.os.Build.VERSION_CODES\#LOLLIPOP</th>
  ///    <td rowspan=3>MediaFormat\#KEY_MIME<sup>*</sup>,<br>
  ///        MediaFormat\#KEY_SAMPLE_RATE,<br>
  ///        MediaFormat\#KEY_CHANNEL_COUNT,</td>
  ///    <td>MediaFormat\#KEY_MIME<sup>*</sup>,<br>
  ///        CodecCapabilities\#FEATURE_AdaptivePlayback<sup>D</sup>,<br>
  ///        CodecCapabilities\#FEATURE_SecurePlayback<sup>D</sup>,<br>
  ///        CodecCapabilities\#FEATURE_TunneledPlayback<sup>D</sup>,<br>
  ///        MediaFormat\#KEY_WIDTH,<br>
  ///        MediaFormat\#KEY_HEIGHT,<br>
  ///        <strong>no</strong> {@code KEY_FRAME_RATE}</td>
  ///    <td rowspan=4>MediaFormat\#KEY_BITRATE_MODE,<br>
  ///        MediaFormat\#KEY_PROFILE
  ///        (and/or MediaFormat\#KEY_AAC_PROFILE<sup>~</sup>),<br>
  ///        <!-- {link MediaFormat\#KEY_QUALITY},<br> -->
  ///        MediaFormat\#KEY_COMPLEXITY
  ///        (and/or MediaFormat\#KEY_FLAC_COMPRESSION_LEVEL<sup>~</sup>)</td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#LOLLIPOP_MR1</th>
  ///    <td rowspan=2>as above, plus<br>
  ///        MediaFormat\#KEY_FRAME_RATE</td>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#M</th>
  ///   </tr><tr>
  ///    <td>android.os.Build.VERSION_CODES\#N</th>
  ///    <td>as above, plus<br>
  ///        MediaFormat\#KEY_PROFILE,<br>
  ///        <!-- {link MediaFormat\#KEY_MAX_BIT_RATE},<br> -->
  ///        MediaFormat\#KEY_BIT_RATE</td>
  ///    <td>as above, plus<br>
  ///        MediaFormat\#KEY_PROFILE,<br>
  ///        MediaFormat\#KEY_LEVEL<sup>+</sup>,<br>
  ///        <!-- {link MediaFormat\#KEY_MAX_BIT_RATE},<br> -->
  ///        MediaFormat\#KEY_BIT_RATE,<br>
  ///        CodecCapabilities\#FEATURE_IntraRefresh<sup>E</sup></td>
  ///   </tr>
  ///   <tr>
  ///    <td colspan=4>
  ///     <p class=note><strong>Notes:</strong><br>
  ///      *: must be specified; otherwise, method returns {@code false}.<br>
  ///      +: method does not verify that the format parameters are supported
  ///      by the specified level.<br>
  ///      D: decoders only<br>
  ///      E: encoders only<br>
  ///      ~: if both keys are provided values must match
  ///    </td>
  ///   </tr>
  ///  </tbody>
  /// </table>
  ///@param format media format with optional feature directives.
  ///@throws IllegalArgumentException if format is not a valid media format.
  ///@return whether the codec capabilities support the given format
  ///         and feature requests.
  bool isFormatSupported(mediaformat_.MediaFormat format) =>
      jniAccessors.callMethodWithArgs(reference, _id_isFormatSupported,
          jni.JniType.booleanType, [format.reference]).boolean;

  static final _id_getDefaultFormat = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultFormat", "()Landroid/media/MediaFormat;");

  /// from: public android.media.MediaFormat getDefaultFormat()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a MediaFormat object with default values for configurations that have
  /// defaults.
  mediaformat_.MediaFormat getDefaultFormat() =>
      mediaformat_.MediaFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDefaultFormat, jni.JniType.objectType, []).object);

  static final _id_getMimeType = jniAccessors.getMethodIDOf(
      _classRef, "getMimeType", "()Ljava/lang/String;");

  /// from: public java.lang.String getMimeType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the mime type for which this codec-capability object was created.
  jni.JniString getMimeType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMimeType, jni.JniType.objectType, []).object);

  static final _id_getMaxSupportedInstances =
      jniAccessors.getMethodIDOf(_classRef, "getMaxSupportedInstances", "()I");

  /// from: public int getMaxSupportedInstances()
  ///
  /// Returns the max number of the supported concurrent codec instances.
  ///
  /// This is a hint for an upper bound. Applications should not expect to successfully
  /// operate more instances than the returned value, but the actual number of
  /// concurrently operable instances may be less as it depends on the available
  /// resources at time of use.
  int getMaxSupportedInstances() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxSupportedInstances, jni.JniType.intType, []).integer;

  static final _id_getAudioCapabilities = jniAccessors.getMethodIDOf(
      _classRef,
      "getAudioCapabilities",
      "()Landroid/media/MediaCodecInfo\$AudioCapabilities;");

  /// from: public android.media.MediaCodecInfo.AudioCapabilities getAudioCapabilities()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the audio capabilities or {@code null} if this is not an audio codec.
  MediaCodecInfo_AudioCapabilities getAudioCapabilities() =>
      MediaCodecInfo_AudioCapabilities.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAudioCapabilities,
          jni.JniType.objectType, []).object);

  static final _id_getEncoderCapabilities = jniAccessors.getMethodIDOf(
      _classRef,
      "getEncoderCapabilities",
      "()Landroid/media/MediaCodecInfo\$EncoderCapabilities;");

  /// from: public android.media.MediaCodecInfo.EncoderCapabilities getEncoderCapabilities()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the encoding capabilities or {@code null} if this is not an encoder.
  MediaCodecInfo_EncoderCapabilities getEncoderCapabilities() =>
      MediaCodecInfo_EncoderCapabilities.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getEncoderCapabilities,
              jni.JniType.objectType, []).object);

  static final _id_getVideoCapabilities = jniAccessors.getMethodIDOf(
      _classRef,
      "getVideoCapabilities",
      "()Landroid/media/MediaCodecInfo\$VideoCapabilities;");

  /// from: public android.media.MediaCodecInfo.VideoCapabilities getVideoCapabilities()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the video capabilities or {@code null} if this is not a video codec.
  MediaCodecInfo_VideoCapabilities getVideoCapabilities() =>
      MediaCodecInfo_VideoCapabilities.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getVideoCapabilities,
          jni.JniType.objectType, []).object);

  static final _id_createFromProfileLevel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromProfileLevel",
      "(Ljava/lang/String;II)Landroid/media/MediaCodecInfo\$CodecCapabilities;");

  /// from: static public android.media.MediaCodecInfo.CodecCapabilities createFromProfileLevel(java.lang.String mime, int profile, int level)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the codec capabilities for a certain {@code mime type}, {@code
  /// profile} and {@code level}.  If the type, or profile-level combination
  /// is not understood by the framework, it returns null.
  /// <p class=note> In android.os.Build.VERSION_CODES\#M, calling this
  /// method without calling any method of the MediaCodecList class beforehand
  /// results in a NullPointerException.
  ///
  static MediaCodecInfo_CodecCapabilities createFromProfileLevel(
          jni.JniString mime, int profile, int level) =>
      MediaCodecInfo_CodecCapabilities.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_createFromProfileLevel,
              jni.JniType.objectType, [mime.reference, profile, level]).object);
}

/// from: android.media.MediaCodecInfo$AudioCapabilities
///
/// A class that supports querying the audio capabilities of a codec.
class MediaCodecInfo_AudioCapabilities extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/media/MediaCodecInfo\$AudioCapabilities");
  MediaCodecInfo_AudioCapabilities.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_getBitrateRange = jniAccessors.getMethodIDOf(
      _classRef, "getBitrateRange", "()Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer> getBitrateRange()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the range of supported bitrates in bits/second.
  range_.Range getBitrateRange() =>
      range_.Range.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBitrateRange, jni.JniType.objectType, []).object);

  static final _id_getSupportedSampleRates =
      jniAccessors.getMethodIDOf(_classRef, "getSupportedSampleRates", "()[I");

  /// from: public int[] getSupportedSampleRates()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the array of supported sample rates if the codec
  /// supports only discrete values.  Otherwise, it returns
  /// {@code null}.  The array is sorted in ascending order.
  jni.JniObject getSupportedSampleRates() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedSampleRates, jni.JniType.objectType, []).object);

  static final _id_getSupportedSampleRateRanges = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedSampleRateRanges", "()[Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer>[] getSupportedSampleRateRanges()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the array of supported sample rate ranges.  The
  /// array is sorted in ascending order, and the ranges are
  /// distinct.
  jni.JniObject getSupportedSampleRateRanges() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedSampleRateRanges, jni.JniType.objectType, []).object);

  static final _id_getMaxInputChannelCount =
      jniAccessors.getMethodIDOf(_classRef, "getMaxInputChannelCount", "()I");

  /// from: public int getMaxInputChannelCount()
  ///
  /// Returns the maximum number of input channels supported.  The codec
  /// supports any number of channels between 1 and this maximum value.
  int getMaxInputChannelCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxInputChannelCount, jni.JniType.intType, []).integer;

  static final _id_isSampleRateSupported =
      jniAccessors.getMethodIDOf(_classRef, "isSampleRateSupported", "(I)Z");

  /// from: public boolean isSampleRateSupported(int sampleRate)
  ///
  /// Query whether the sample rate is supported by the codec.
  bool isSampleRateSupported(int sampleRate) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isSampleRateSupported,
      jni.JniType.booleanType,
      [sampleRate]).boolean;
}
