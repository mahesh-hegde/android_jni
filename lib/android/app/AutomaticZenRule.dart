// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../content/ComponentName.dart" as componentname_;

import "../net/Uri.dart" as uri_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.AutomaticZenRule
///
/// Rule instance information for zen mode.
class AutomaticZenRule extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/AutomaticZenRule");
  AutomaticZenRule.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.AutomaticZenRule> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Landroid/content/ComponentName;Landroid/net/Uri;IZ)V");

  /// from: public void <init>(java.lang.String name, android.content.ComponentName owner, android.net.Uri conditionId, int interruptionFilter, boolean enabled)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an automatic zen rule.
  ///@param name The name of the rule.
  ///@param owner The Condition Provider service that owns this rule.
  ///@param conditionId A representation of the state that should cause the Condition Provider
  ///                    service to apply the given interruption filter.
  ///@param interruptionFilter The interruption filter defines which notifications are allowed to
  ///                           interrupt the user (e.g. via sound &amp; vibration) while this rule
  ///                           is active.
  ///@param enabled Whether the rule is enabled.
  AutomaticZenRule(jni.JniString name, componentname_.ComponentName owner,
      uri_.Uri conditionId, int interruptionFilter, bool enabled)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          name.reference,
          owner.reference,
          conditionId.reference,
          interruptionFilter,
          enabled
        ]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AutomaticZenRule.ctor1(parcel_.Parcel source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [source.reference]).object);

  static final _id_getOwner = jniAccessors.getMethodIDOf(
      _classRef, "getOwner", "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getOwner()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ComponentName of the condition provider service that owns this rule.
  componentname_.ComponentName getOwner() =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOwner, jni.JniType.objectType, []).object);

  static final _id_getConditionId = jniAccessors.getMethodIDOf(
      _classRef, "getConditionId", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getConditionId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the representation of the state that causes this rule to become active.
  uri_.Uri getConditionId() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getConditionId, jni.JniType.objectType, []).object);

  static final _id_getInterruptionFilter =
      jniAccessors.getMethodIDOf(_classRef, "getInterruptionFilter", "()I");

  /// from: public int getInterruptionFilter()
  ///
  /// Returns the interruption filter that is applied when this rule is active.
  int getInterruptionFilter() => jniAccessors.callMethodWithArgs(
      reference, _id_getInterruptionFilter, jni.JniType.intType, []).integer;

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of this rule.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Returns whether this rule is enabled.
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getCreationTime =
      jniAccessors.getMethodIDOf(_classRef, "getCreationTime", "()J");

  /// from: public long getCreationTime()
  ///
  /// Returns the time this rule was created, represented as milliseconds since the epoch.
  int getCreationTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getCreationTime, jni.JniType.longType, []).long;

  static final _id_setConditionId = jniAccessors.getMethodIDOf(
      _classRef, "setConditionId", "(Landroid/net/Uri;)V");

  /// from: public void setConditionId(android.net.Uri conditionId)
  ///
  /// Sets the representation of the state that causes this rule to become active.
  void setConditionId(uri_.Uri conditionId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setConditionId,
      jni.JniType.voidType,
      [conditionId.reference]).check();

  static final _id_setInterruptionFilter =
      jniAccessors.getMethodIDOf(_classRef, "setInterruptionFilter", "(I)V");

  /// from: public void setInterruptionFilter(int interruptionFilter)
  ///
  /// Sets the interruption filter that is applied when this rule is active.
  ///@param interruptionFilter The do not disturb mode to enter when this rule is active.
  ///
  /// Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  void setInterruptionFilter(int interruptionFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInterruptionFilter,
          jni.JniType.voidType, [interruptionFilter]).check();

  static final _id_setName =
      jniAccessors.getMethodIDOf(_classRef, "setName", "(Ljava/lang/String;)V");

  /// from: public void setName(java.lang.String name)
  ///
  /// Sets the name of this rule.
  void setName(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference, _id_setName, jni.JniType.voidType, [name.reference]).check();

  static final _id_setEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)V");

  /// from: public void setEnabled(boolean enabled)
  ///
  /// Enables this rule.
  void setEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled, jni.JniType.voidType, [enabled]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
