// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.backup.RestoreObserver
///
/// Callback class for receiving progress reports during a restore operation.  These
/// methods will all be called on your application's main thread.
class RestoreObserver extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/backup/RestoreObserver");
  RestoreObserver.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  RestoreObserver()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_restoreStarting =
      jniAccessors.getMethodIDOf(_classRef, "restoreStarting", "(I)V");

  /// from: public void restoreStarting(int numPackages)
  ///
  /// The restore operation has begun.
  ///@param numPackages The total number of packages being processed in
  ///   this restore operation.
  void restoreStarting(int numPackages) => jniAccessors.callMethodWithArgs(
      reference,
      _id_restoreStarting,
      jni.JniType.voidType,
      [numPackages]).check();

  static final _id_onUpdate = jniAccessors.getMethodIDOf(
      _classRef, "onUpdate", "(ILjava/lang/String;)V");

  /// from: public void onUpdate(int nowBeingRestored, java.lang.String currentPackage)
  ///
  /// An indication of which package is being restored currently, out of the
  /// total number provided in the \#restoreStarting(int) callback.  This method
  /// is not guaranteed to be called: if the transport is unable to obtain
  /// data for one or more of the requested packages, no onUpdate() call will
  /// occur for those packages.
  ///@param nowBeingRestored The index, between 1 and the numPackages parameter
  ///   to the \#restoreStarting(int) callback, of the package now being
  ///   restored.  This may be non-monotonic; it is intended purely as a rough
  ///   indication of the backup manager's progress through the overall restore process.
  ///@param currentPackage The name of the package now being restored.
  void onUpdate(int nowBeingRestored, jni.JniString currentPackage) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onUpdate,
          jni.JniType.voidType,
          [nowBeingRestored, currentPackage.reference]).check();

  static final _id_restoreFinished =
      jniAccessors.getMethodIDOf(_classRef, "restoreFinished", "(I)V");

  /// from: public void restoreFinished(int error)
  ///
  /// The restore process has completed.  This method will always be called,
  /// even if no individual package restore operations were attempted.
  ///@param error Zero on success; a nonzero error code if the restore operation
  ///   as a whole failed.
  void restoreFinished(int error) => jniAccessors.callMethodWithArgs(
      reference, _id_restoreFinished, jni.JniType.voidType, [error]).check();
}
