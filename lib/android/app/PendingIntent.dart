// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/IBinder.dart" as ibinder_;

import "../content/Context.dart" as context_;

import "../content/Intent.dart" as intent_;

import "../os/Bundle.dart" as bundle_;

import "../content/IntentSender.dart" as intentsender_;

import "../os/Handler.dart" as handler_;

import "../os/UserHandle.dart" as userhandle_;

import "../os/Parcel.dart" as parcel_;

import "../util/AndroidException.dart" as androidexception_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.PendingIntent
///
/// A description of an Intent and target action to perform with it.  Instances
/// of this class are created with \#getActivity, \#getActivities,
/// \#getBroadcast, and \#getService; the returned object can be
/// handed to other applications so that they can perform the action you
/// described on your behalf at a later time.
///
/// By giving a PendingIntent to another application,
/// you are granting it the right to perform the operation you have specified
/// as if the other application was yourself (with the same permissions and
/// identity).  As such, you should be careful about how you build the PendingIntent:
/// almost always, for example, the base Intent you supply should have the component
/// name explicitly set to one of your own components, to ensure it is ultimately
/// sent there and nowhere else.
///
/// A PendingIntent itself is simply a reference to a token maintained by
/// the system describing the original data used to retrieve it.  This means
/// that, even if its owning application's process is killed, the
/// PendingIntent itself will remain usable from other processes that
/// have been given it.  If the creating application later re-retrieves the
/// same kind of PendingIntent (same operation, same Intent action, data,
/// categories, and components, and same flags), it will receive a PendingIntent
/// representing the same token if that is still valid, and can thus call
/// \#cancel to remove it.
///
/// Because of this behavior, it is important to know when two Intents
/// are considered to be the same for purposes of retrieving a PendingIntent.
/// A common mistake people make is to create multiple PendingIntent objects
/// with Intents that only vary in their "extra" contents, expecting to get
/// a different PendingIntent each time.  This does _not_ happen.  The
/// parts of the Intent that are used for matching are the same ones defined
/// by Intent\#filterEquals(Intent) Intent.filterEquals.  If you use two
/// Intent objects that are equivalent as per
/// Intent\#filterEquals(Intent) Intent.filterEquals, then you will get
/// the same PendingIntent for both of them.
///
/// There are two typical ways to deal with this.
///
/// If you truly need multiple distinct PendingIntent objects active at
/// the same time (such as to use as two notifications that are both shown
/// at the same time), then you will need to ensure there is something that
/// is different about them to associate them with different PendingIntents.
/// This may be any of the Intent attributes considered by
/// Intent\#filterEquals(Intent) Intent.filterEquals, or different
/// request code integers supplied to \#getActivity, \#getActivities,
/// \#getBroadcast, or \#getService.
///
/// If you only need one PendingIntent active at a time for any of the
/// Intents you will use, then you can alternatively use the flags
/// \#FLAG_CANCEL_CURRENT or \#FLAG_UPDATE_CURRENT to either
/// cancel or modify whatever current PendingIntent is associated with the
/// Intent you are supplying.
class PendingIntent extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/PendingIntent");
  PendingIntent.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.PendingIntent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int FLAG_CANCEL_CURRENT
  ///
  /// Flag indicating that if the described PendingIntent already exists,
  /// the current one should be canceled before generating a new one.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService. You can use
  /// this to retrieve a new PendingIntent when you are only changing the
  /// extra data in the Intent; by canceling the previous pending intent,
  /// this ensures that only entities given the new data will be able to
  /// launch it.  If this assurance is not an issue, consider
  /// \#FLAG_UPDATE_CURRENT.
  static const FLAG_CANCEL_CURRENT = 268435456;

  /// from: static public final int FLAG_IMMUTABLE
  ///
  /// Flag indicating that the created PendingIntent should be immutable.
  /// This means that the additional intent argument passed to the send
  /// methods to fill in unpopulated properties of this intent will be
  /// ignored.
  static const FLAG_IMMUTABLE = 67108864;

  /// from: static public final int FLAG_NO_CREATE
  ///
  /// Flag indicating that if the described PendingIntent does not
  /// already exist, then simply return null instead of creating it.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService.
  static const FLAG_NO_CREATE = 536870912;

  /// from: static public final int FLAG_ONE_SHOT
  ///
  /// Flag indicating that this PendingIntent can be used only once.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService. If set, after
  /// \#send() is called on it, it will be automatically
  /// canceled for you and any future attempt to send through it will fail.
  static const FLAG_ONE_SHOT = 1073741824;

  /// from: static public final int FLAG_UPDATE_CURRENT
  ///
  /// Flag indicating that if the described PendingIntent already exists,
  /// then keep it but replace its extra data with what is in this new
  /// Intent. For use with \#getActivity, \#getBroadcast, and
  /// \#getService. This can be used if you are creating intents where only the
  /// extras change, and don't care that any entities that received your
  /// previous PendingIntent will be able to launch it with your new
  /// extras even if they are not explicitly given to it.
  static const FLAG_UPDATE_CURRENT = 134217728;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/IBinder;Ljava/lang/Object;)V");

  /// from: void <init>(android.os.IBinder target, java.lang.Object cookie)
  /// The returned object must be deleted after use, by calling the `delete` method.
  PendingIntent(ibinder_.IBinder target, jni.JniObject cookie)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [target.reference, cookie.reference]).object);

  static final _id_getActivity = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getActivity",
      "(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;");

  /// from: static public android.app.PendingIntent getActivity(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will start a new activity, like calling
  /// Context\#startActivity(Intent) Context.startActivity(Intent).
  /// Note that the activity will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intent Intent of the activity to be launched.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivity(context_.Context context, int requestCode,
          intent_.Intent intent, int flags) =>
      PendingIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getActivity,
          jni.JniType.objectType,
          [context.reference, requestCode, intent.reference, flags]).object);

  static final _id_getActivity1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getActivity",
      "(Landroid/content/Context;ILandroid/content/Intent;ILandroid/os/Bundle;)Landroid/app/PendingIntent;");

  /// from: static public android.app.PendingIntent getActivity(android.content.Context context, int requestCode, android.content.Intent intent, int flags, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will start a new activity, like calling
  /// Context\#startActivity(Intent) Context.startActivity(Intent).
  /// Note that the activity will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intent Intent of the activity to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options Additional options for how the Activity should be started.
  /// May be null if there are no options.
  ///
  /// This value may be {@code null}.
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivity1(context_.Context context, int requestCode,
          intent_.Intent intent, int flags, bundle_.Bundle options) =>
      PendingIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getActivity1, jni.JniType.objectType, [
        context.reference,
        requestCode,
        intent.reference,
        flags,
        options.reference
      ]).object);

  static final _id_getActivities = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getActivities",
      "(Landroid/content/Context;I[Landroid/content/Intent;I)Landroid/app/PendingIntent;");

  /// from: static public android.app.PendingIntent getActivities(android.content.Context context, int requestCode, android.content.Intent[] intents, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getActivity(Context, int, Intent, int), but allows an
  /// array of Intents to be supplied.  The last Intent in the array is
  /// taken as the primary key for the PendingIntent, like the single Intent
  /// given to \#getActivity(Context, int, Intent, int).  Upon sending
  /// the resulting PendingIntent, all of the Intents are started in the same
  /// way as they would be by passing them to Context\#startActivities(Intent[]).
  ///
  /// <p class="note">
  /// The _first_ intent in the array will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.  (Activities after
  /// the first in the array are started in the context of the previous activity
  /// in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
  ///
  ///
  ///
  /// <p class="note">
  /// The _last_ intent in the array represents the key for the
  /// PendingIntent.  In other words, it is the significant element for matching
  /// (as done with the single intent given to \#getActivity(Context, int, Intent, int),
  /// its content will be the subject of replacement by
  /// \#send(Context, int, Intent) and \#FLAG_UPDATE_CURRENT, etc.
  /// This is because it is the most specific of the supplied intents, and the
  /// UI the user actually sees when the intents are started.
  ///
  ///
  ///
  /// <p class="note">For security reasons, the android.content.Intent objects
  /// you supply here should almost always be _explicit intents_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intents Array of Intents of the activities to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivities(context_.Context context, int requestCode,
          jni.JniObject intents, int flags) =>
      PendingIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getActivities,
          jni.JniType.objectType,
          [context.reference, requestCode, intents.reference, flags]).object);

  static final _id_getActivities1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getActivities",
      "(Landroid/content/Context;I[Landroid/content/Intent;ILandroid/os/Bundle;)Landroid/app/PendingIntent;");

  /// from: static public android.app.PendingIntent getActivities(android.content.Context context, int requestCode, android.content.Intent[] intents, int flags, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getActivity(Context, int, Intent, int), but allows an
  /// array of Intents to be supplied.  The last Intent in the array is
  /// taken as the primary key for the PendingIntent, like the single Intent
  /// given to \#getActivity(Context, int, Intent, int).  Upon sending
  /// the resulting PendingIntent, all of the Intents are started in the same
  /// way as they would be by passing them to Context\#startActivities(Intent[]).
  ///
  /// <p class="note">
  /// The _first_ intent in the array will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.  (Activities after
  /// the first in the array are started in the context of the previous activity
  /// in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
  ///
  ///
  ///
  /// <p class="note">
  /// The _last_ intent in the array represents the key for the
  /// PendingIntent.  In other words, it is the significant element for matching
  /// (as done with the single intent given to \#getActivity(Context, int, Intent, int),
  /// its content will be the subject of replacement by
  /// \#send(Context, int, Intent) and \#FLAG_UPDATE_CURRENT, etc.
  /// This is because it is the most specific of the supplied intents, and the
  /// UI the user actually sees when the intents are started.
  ///
  ///
  ///
  /// <p class="note">For security reasons, the android.content.Intent objects
  /// you supply here should almost always be _explicit intents_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intents Array of Intents of the activities to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options This value may be {@code null}.
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivities1(context_.Context context, int requestCode,
          jni.JniObject intents, int flags, bundle_.Bundle options) =>
      PendingIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getActivities1, jni.JniType.objectType, [
        context.reference,
        requestCode,
        intents.reference,
        flags,
        options.reference
      ]).object);

  static final _id_getBroadcast = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getBroadcast",
      "(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;");

  /// from: static public android.app.PendingIntent getBroadcast(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will perform a broadcast, like calling
  /// Context\#sendBroadcast(Intent) Context.sendBroadcast().
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should perform
  /// the broadcast.
  ///@param requestCode Private request code for the sender
  ///@param intent The Intent to be broadcast.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getBroadcast(context_.Context context, int requestCode,
          intent_.Intent intent, int flags) =>
      PendingIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getBroadcast,
          jni.JniType.objectType,
          [context.reference, requestCode, intent.reference, flags]).object);

  static final _id_getService = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getService",
      "(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;");

  /// from: static public android.app.PendingIntent getService(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will start a service, like calling
  /// Context\#startService Context.startService().  The start
  /// arguments given to the service will come from the extras of the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the service.
  ///@param requestCode Private request code for the sender
  ///@param intent An Intent describing the service to be started.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getService(context_.Context context, int requestCode,
          intent_.Intent intent, int flags) =>
      PendingIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getService,
          jni.JniType.objectType,
          [context.reference, requestCode, intent.reference, flags]).object);

  static final _id_getForegroundService = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getForegroundService",
      "(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;");

  /// from: static public android.app.PendingIntent getForegroundService(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will start a foreground service, like calling
  /// Context\#startForegroundService Context.startForegroundService().  The start
  /// arguments given to the service will come from the extras of the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the service.
  ///@param requestCode Private request code for the sender
  ///@param intent An Intent describing the service to be started.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getForegroundService(context_.Context context,
          int requestCode, intent_.Intent intent, int flags) =>
      PendingIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getForegroundService,
          jni.JniType.objectType,
          [context.reference, requestCode, intent.reference, flags]).object);

  static final _id_getIntentSender = jniAccessors.getMethodIDOf(
      _classRef, "getIntentSender", "()Landroid/content/IntentSender;");

  /// from: public android.content.IntentSender getIntentSender()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a IntentSender object that wraps the existing sender of the PendingIntent
  ///@return Returns a IntentSender object that wraps the sender of PendingIntent
  intentsender_.IntentSender getIntentSender() =>
      intentsender_.IntentSender.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIntentSender, jni.JniType.objectType, []).object);

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "()V");

  /// from: public void cancel()
  ///
  /// Cancel a currently active PendingIntent.  Only the original application
  /// owning a PendingIntent can cancel it.
  void cancel() => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, []).check();

  static final _id_send = jniAccessors.getMethodIDOf(_classRef, "send", "()V");

  /// from: public void send()
  ///
  /// Perform the operation associated with this PendingIntent.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send() => jniAccessors.callMethodWithArgs(
      reference, _id_send, jni.JniType.voidType, []).check();

  static final _id_send1 =
      jniAccessors.getMethodIDOf(_classRef, "send", "(I)V");

  /// from: public void send(int code)
  ///
  /// Perform the operation associated with this PendingIntent.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send1(int code) => jniAccessors.callMethodWithArgs(
      reference, _id_send1, jni.JniType.voidType, [code]).check();

  static final _id_send2 = jniAccessors.getMethodIDOf(_classRef, "send",
      "(Landroid/content/Context;ILandroid/content/Intent;)V");

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use.
  ///@param context The Context of the caller.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent. If flag \#FLAG_IMMUTABLE was set when this
  /// pending intent was created, this argument will be ignored.
  ///
  /// This value may be {@code null}.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send2(context_.Context context, int code, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_send2,
          jni.JniType.voidType,
          [context.reference, code, intent.reference]).check();

  static final _id_send3 = jniAccessors.getMethodIDOf(_classRef, "send",
      "(ILandroid/app/PendingIntent\$OnFinished;Landroid/os/Handler;)V");

  /// from: public void send(int code, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to be notified when the send has completed.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///
  /// This value may be {@code null}.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send3(int code, PendingIntent_OnFinished onFinished,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_send3,
          jni.JniType.voidType,
          [code, onFinished.reference, handler.reference]).check();

  static final _id_send4 = jniAccessors.getMethodIDOf(_classRef, "send",
      "(Landroid/content/Context;ILandroid/content/Intent;Landroid/app/PendingIntent\$OnFinished;Landroid/os/Handler;)V");

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler, String)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send4(context_.Context context, int code, intent_.Intent intent,
          PendingIntent_OnFinished onFinished, handler_.Handler handler) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_send4, jni.JniType.voidType, [
        context.reference,
        code,
        intent.reference,
        onFinished.reference,
        handler.reference
      ]).check();

  static final _id_send5 = jniAccessors.getMethodIDOf(_classRef, "send",
      "(Landroid/content/Context;ILandroid/content/Intent;Landroid/app/PendingIntent\$OnFinished;Landroid/os/Handler;Ljava/lang/String;)V");

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler, java.lang.String requiredPermission)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  /// This value may be {@code null}.
  ///@param requiredPermission Name of permission that a recipient of the PendingIntent
  /// is required to hold.  This is only valid for broadcast intents, and
  /// corresponds to the permission argument in
  /// Context\#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String).
  /// If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send5(
          context_.Context context,
          int code,
          intent_.Intent intent,
          PendingIntent_OnFinished onFinished,
          handler_.Handler handler,
          jni.JniString requiredPermission) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_send5, jni.JniType.voidType, [
        context.reference,
        code,
        intent.reference,
        onFinished.reference,
        handler.reference,
        requiredPermission.reference
      ]).check();

  static final _id_send6 = jniAccessors.getMethodIDOf(_classRef, "send",
      "(Landroid/content/Context;ILandroid/content/Intent;Landroid/app/PendingIntent\$OnFinished;Landroid/os/Handler;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler, java.lang.String requiredPermission, android.os.Bundle options)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  /// This value may be {@code null}.
  ///@param requiredPermission Name of permission that a recipient of the PendingIntent
  /// is required to hold.  This is only valid for broadcast intents, and
  /// corresponds to the permission argument in
  /// Context\#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String).
  /// If null, no permission is required.
  /// This value may be {@code null}.
  ///@param options Additional options the caller would like to provide to modify the sending
  /// behavior.  May be built from an ActivityOptions to apply to an activity start.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send6(
          context_.Context context,
          int code,
          intent_.Intent intent,
          PendingIntent_OnFinished onFinished,
          handler_.Handler handler,
          jni.JniString requiredPermission,
          bundle_.Bundle options) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_send6, jni.JniType.voidType, [
        context.reference,
        code,
        intent.reference,
        onFinished.reference,
        handler.reference,
        requiredPermission.reference,
        options.reference
      ]).check();

  static final _id_getTargetPackage = jniAccessors.getMethodIDOf(
      _classRef, "getTargetPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getTargetPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Renamed to \#getCreatorPackage().
  jni.JniString getTargetPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTargetPackage, jni.JniType.objectType, []).object);

  static final _id_getCreatorPackage = jniAccessors.getMethodIDOf(
      _classRef, "getCreatorPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getCreatorPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of the application that created this
  /// PendingIntent, that is the identity under which you will actually be
  /// sending the Intent.  The returned string is supplied by the system, so
  /// that an application can not spoof its package.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The package name of the PendingIntent, or null if there is
  /// none associated with it.
  jni.JniString getCreatorPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCreatorPackage, jni.JniType.objectType, []).object);

  static final _id_getCreatorUid =
      jniAccessors.getMethodIDOf(_classRef, "getCreatorUid", "()I");

  /// from: public int getCreatorUid()
  ///
  /// Return the uid of the application that created this
  /// PendingIntent, that is the identity under which you will actually be
  /// sending the Intent.  The returned integer is supplied by the system, so
  /// that an application can not spoof its uid.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The uid of the PendingIntent, or -1 if there is
  /// none associated with it.
  int getCreatorUid() => jniAccessors.callMethodWithArgs(
      reference, _id_getCreatorUid, jni.JniType.intType, []).integer;

  static final _id_getCreatorUserHandle = jniAccessors.getMethodIDOf(
      _classRef, "getCreatorUserHandle", "()Landroid/os/UserHandle;");

  /// from: public android.os.UserHandle getCreatorUserHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the user handle of the application that created this
  /// PendingIntent, that is the user under which you will actually be
  /// sending the Intent.  The returned UserHandle is supplied by the system, so
  /// that an application can not spoof its user.  See
  /// android.os.Process\#myUserHandle() Process.myUserHandle() for
  /// more explanation of user handles.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The user handle of the PendingIntent, or null if there is
  /// none associated with it.
  userhandle_.UserHandle getCreatorUserHandle() =>
      userhandle_.UserHandle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCreatorUserHandle, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object otherObj)
  ///
  /// Comparison operator on two PendingIntent objects, such that true
  /// is returned then they both represent the same operation from the
  /// same package.  This allows you to use \#getActivity,
  /// \#getBroadcast, or \#getService multiple times (even
  /// across a process being killed), resulting in different PendingIntent
  /// objects but whose equals() method identifies them as being the same
  /// operation.
  bool equals1(jni.JniObject otherObj) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [otherObj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();

  static final _id_writePendingIntentOrNullToParcel =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "writePendingIntentOrNullToParcel",
          "(Landroid/app/PendingIntent;Landroid/os/Parcel;)V");

  /// from: static public void writePendingIntentOrNullToParcel(android.app.PendingIntent sender, android.os.Parcel out)
  ///
  /// Convenience function for writing either a PendingIntent or null pointer to
  /// a Parcel.  You must use this with \#readPendingIntentOrNullFromParcel
  /// for later reading it.
  ///@param sender The PendingIntent to write, or null.
  /// This value may be {@code null}.
  ///@param out Where to write the PendingIntent.
  ///
  /// This value must never be {@code null}.
  static void writePendingIntentOrNullToParcel(
          PendingIntent sender, parcel_.Parcel out) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_writePendingIntentOrNullToParcel,
          jni.JniType.voidType,
          [sender.reference, out.reference]).check();

  static final _id_readPendingIntentOrNullFromParcel =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "readPendingIntentOrNullFromParcel",
          "(Landroid/os/Parcel;)Landroid/app/PendingIntent;");

  /// from: static public android.app.PendingIntent readPendingIntentOrNullFromParcel(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for reading either a PendingIntent or null pointer from
  /// a Parcel.  You must have previously written the PendingIntent with
  /// \#writePendingIntentOrNullToParcel.
  ///@param in The Parcel containing the written PendingIntent.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the PendingIntent read from the Parcel, or null if null had
  /// been written.
  static PendingIntent readPendingIntentOrNullFromParcel(parcel_.Parcel in0) =>
      PendingIntent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_readPendingIntentOrNullFromParcel,
          jni.JniType.objectType,
          [in0.reference]).object);
}

/// from: android.app.PendingIntent$OnFinished
///
/// Callback interface for discovering when a send operation has
/// completed.  Primarily for use with a PendingIntent that is
/// performing a broadcast, this provides the same information as
/// calling Context\#sendOrderedBroadcast(Intent, String,
/// android.content.BroadcastReceiver, Handler, int, String, Bundle) Context.sendBroadcast() with a final BroadcastReceiver.
class PendingIntent_OnFinished extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/PendingIntent\$OnFinished");
  PendingIntent_OnFinished.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onSendFinished = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendFinished",
      "(Landroid/app/PendingIntent;Landroid/content/Intent;ILjava/lang/String;Landroid/os/Bundle;)V");

  /// from: public abstract void onSendFinished(android.app.PendingIntent pendingIntent, android.content.Intent intent, int resultCode, java.lang.String resultData, android.os.Bundle resultExtras)
  ///
  /// Called when a send operation as completed.
  ///@param pendingIntent The PendingIntent this operation was sent through.
  ///@param intent The original Intent that was sent.
  ///@param resultCode The final result code determined by the send.
  ///@param resultData The final data collected by a broadcast.
  ///@param resultExtras The final extras collected by a broadcast.
  void onSendFinished(
          PendingIntent pendingIntent,
          intent_.Intent intent,
          int resultCode,
          jni.JniString resultData,
          bundle_.Bundle resultExtras) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendFinished, jni.JniType.voidType, [
        pendingIntent.reference,
        intent.reference,
        resultCode,
        resultData.reference,
        resultExtras.reference
      ]).check();
}

/// from: android.app.PendingIntent$CanceledException
///
/// Exception thrown when trying to send through a PendingIntent that
/// has been canceled or is otherwise no longer able to execute the request.
class PendingIntent_CanceledException
    extends androidexception_.AndroidException {
  static final _classRef =
      jniAccessors.getClassOf("android/app/PendingIntent\$CanceledException");
  PendingIntent_CanceledException.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PendingIntent_CanceledException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  PendingIntent_CanceledException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/Exception;)V");

  /// from: public void <init>(java.lang.Exception cause)
  /// The returned object must be deleted after use, by calling the `delete` method.
  PendingIntent_CanceledException.ctor3(jni.JniObject cause)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [cause.reference]).object);
}
