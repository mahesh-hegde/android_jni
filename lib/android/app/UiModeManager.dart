// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.UiModeManager
///
/// This class provides access to the system uimode services.  These services
/// allow applications to control UI modes of the device.
/// It provides functionality to disable the car mode and it gives access to the
/// night mode settings.
///
/// These facilities are built on top of the underlying
/// android.content.Intent\#ACTION_DOCK_EVENT broadcasts that are sent when the user
/// physical places the device into and out of a dock.  When that happens,
/// the UiModeManager switches the system android.content.res.Configuration
/// to the appropriate UI mode, sends broadcasts about the mode switch, and
/// starts the corresponding mode activity if appropriate.  See the
/// broadcasts \#ACTION_ENTER_CAR_MODE and
/// \#ACTION_ENTER_DESK_MODE for more information.
///
/// In addition, the user may manually switch the system to car mode without
/// physically being in a dock.  While in car mode -- whether by manual action
/// from the user or being physically placed in a dock -- a notification is
/// displayed allowing the user to exit dock mode.  Thus the dock mode
/// represented here may be different than the current state of the underlying
/// dock event broadcast.
class UiModeManager extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/UiModeManager");
  UiModeManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ACTION_ENTER_CAR_MODE = jniAccessors.getStaticFieldIDOf(
      _classRef, "ACTION_ENTER_CAR_MODE", "Ljava/lang/String;");

  /// from: static public java.lang.String ACTION_ENTER_CAR_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched to car mode, either
  /// by being placed in a car dock or explicit action of the user.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_CAR_DOCK
  /// to display the car UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal car UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static jni.JniString get ACTION_ENTER_CAR_MODE =>
      jni.JniString.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_ENTER_CAR_MODE, jni.JniType.objectType)
          .object);

  /// from: static public java.lang.String ACTION_ENTER_CAR_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched to car mode, either
  /// by being placed in a car dock or explicit action of the user.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_CAR_DOCK
  /// to display the car UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal car UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static set ACTION_ENTER_CAR_MODE(jni.JniString value) =>
      jniEnv.SetStaticObjectField(
          _classRef, _id_ACTION_ENTER_CAR_MODE, value.reference);

  static final _id_ACTION_ENTER_DESK_MODE = jniAccessors.getStaticFieldIDOf(
      _classRef, "ACTION_ENTER_DESK_MODE", "Ljava/lang/String;");

  /// from: static public java.lang.String ACTION_ENTER_DESK_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched to desk mode,
  /// by being placed in a desk dock.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_DESK_DOCK
  /// to display the desk UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal desk UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static jni.JniString get ACTION_ENTER_DESK_MODE =>
      jni.JniString.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_ENTER_DESK_MODE, jni.JniType.objectType)
          .object);

  /// from: static public java.lang.String ACTION_ENTER_DESK_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched to desk mode,
  /// by being placed in a desk dock.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_DESK_DOCK
  /// to display the desk UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal desk UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static set ACTION_ENTER_DESK_MODE(jni.JniString value) =>
      jniEnv.SetStaticObjectField(
          _classRef, _id_ACTION_ENTER_DESK_MODE, value.reference);

  static final _id_ACTION_EXIT_CAR_MODE = jniAccessors.getStaticFieldIDOf(
      _classRef, "ACTION_EXIT_CAR_MODE", "Ljava/lang/String;");

  /// from: static public java.lang.String ACTION_EXIT_CAR_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switch away from car mode back
  /// to normal mode.  Typically used by a car mode app, to dismiss itself
  /// when the user exits car mode.
  static jni.JniString get ACTION_EXIT_CAR_MODE =>
      jni.JniString.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_EXIT_CAR_MODE, jni.JniType.objectType)
          .object);

  /// from: static public java.lang.String ACTION_EXIT_CAR_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switch away from car mode back
  /// to normal mode.  Typically used by a car mode app, to dismiss itself
  /// when the user exits car mode.
  static set ACTION_EXIT_CAR_MODE(jni.JniString value) =>
      jniEnv.SetStaticObjectField(
          _classRef, _id_ACTION_EXIT_CAR_MODE, value.reference);

  static final _id_ACTION_EXIT_DESK_MODE = jniAccessors.getStaticFieldIDOf(
      _classRef, "ACTION_EXIT_DESK_MODE", "Ljava/lang/String;");

  /// from: static public java.lang.String ACTION_EXIT_DESK_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched away from desk mode back
  /// to normal mode.  Typically used by a desk mode app, to dismiss itself
  /// when the user exits desk mode.
  static jni.JniString get ACTION_EXIT_DESK_MODE =>
      jni.JniString.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_ACTION_EXIT_DESK_MODE, jni.JniType.objectType)
          .object);

  /// from: static public java.lang.String ACTION_EXIT_DESK_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched away from desk mode back
  /// to normal mode.  Typically used by a desk mode app, to dismiss itself
  /// when the user exits desk mode.
  static set ACTION_EXIT_DESK_MODE(jni.JniString value) =>
      jniEnv.SetStaticObjectField(
          _classRef, _id_ACTION_EXIT_DESK_MODE, value.reference);

  /// from: static public final int DISABLE_CAR_MODE_GO_HOME
  ///
  /// Flag for use with \#disableCarMode(int): go to the normal
  /// home activity as part of the disable.  Disabling this way ensures
  /// a clean transition between the current activity (in car mode) and
  /// the original home activity (which was typically last running without
  /// being in car mode).
  static const DISABLE_CAR_MODE_GO_HOME = 1;

  /// from: static public final int ENABLE_CAR_MODE_ALLOW_SLEEP
  ///
  /// Flag for use with \#enableCarMode(int): allow sleep mode while in car mode.
  /// By default, when this flag is not set, the system may hold a full wake lock to keep the
  /// screen turned on and prevent the system from entering sleep mode while in car mode.
  /// Setting this flag disables such behavior and the system may enter sleep mode
  /// if there is no other user activity and no other wake lock held.
  /// Setting this flag can be relevant for a car dock application that does not require the
  /// screen kept on.
  static const ENABLE_CAR_MODE_ALLOW_SLEEP = 2;

  /// from: static public final int ENABLE_CAR_MODE_GO_CAR_HOME
  ///
  /// Flag for use with \#enableCarMode(int): go to the car
  /// home activity as part of the enable.  Enabling this way ensures
  /// a clean transition between the current activity (in non-car-mode) and
  /// the car home activity that will serve as home while in car mode.  This
  /// will switch to the car home activity even if we are already in car mode.
  static const ENABLE_CAR_MODE_GO_CAR_HOME = 1;

  /// from: static public final int MODE_NIGHT_AUTO
  ///
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// automatically switch night mode on and off based on the time.
  static const MODE_NIGHT_AUTO = 0;

  /// from: static public final int MODE_NIGHT_NO
  ///
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// never run in night mode.
  static const MODE_NIGHT_NO = 1;

  /// from: static public final int MODE_NIGHT_YES
  ///
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// always run in night mode.
  static const MODE_NIGHT_YES = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UiModeManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_enableCarMode =
      jniAccessors.getMethodIDOf(_classRef, "enableCarMode", "(I)V");

  /// from: public void enableCarMode(int flags)
  ///
  /// Force device into car mode, like it had been placed in the car dock.
  /// This will cause the device to switch to the car home UI as part of
  /// the mode switch.
  ///@param flags Must be 0.
  void enableCarMode(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_enableCarMode, jni.JniType.voidType, [flags]).check();

  static final _id_disableCarMode =
      jniAccessors.getMethodIDOf(_classRef, "disableCarMode", "(I)V");

  /// from: public void disableCarMode(int flags)
  ///
  /// Turn off special mode if currently in car mode.
  ///@param flags May be 0 or \#DISABLE_CAR_MODE_GO_HOME.
  void disableCarMode(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_disableCarMode, jni.JniType.voidType, [flags]).check();

  static final _id_getCurrentModeType =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentModeType", "()I");

  /// from: public int getCurrentModeType()
  ///
  /// Return the current running mode type.  May be one of
  /// Configuration\#UI_MODE_TYPE_NORMAL Configuration.UI_MODE_TYPE_NORMAL,
  /// Configuration\#UI_MODE_TYPE_DESK Configuration.UI_MODE_TYPE_DESK,
  /// Configuration\#UI_MODE_TYPE_CAR Configuration.UI_MODE_TYPE_CAR,
  /// Configuration\#UI_MODE_TYPE_TELEVISION Configuration.UI_MODE_TYPE_TELEVISION,
  /// Configuration\#UI_MODE_TYPE_APPLIANCE Configuration.UI_MODE_TYPE_APPLIANCE,
  /// Configuration\#UI_MODE_TYPE_WATCH Configuration.UI_MODE_TYPE_WATCH, or
  /// Configuration\#UI_MODE_TYPE_VR_HEADSET Configuration.UI_MODE_TYPE_VR_HEADSET.
  int getCurrentModeType() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentModeType, jni.JniType.intType, []).integer;

  static final _id_setNightMode =
      jniAccessors.getMethodIDOf(_classRef, "setNightMode", "(I)V");

  /// from: public void setNightMode(int mode)
  ///
  /// Sets the night mode.
  ///
  /// The mode can be one of:
  /// <ul>
  ///   <li>_\#MODE_NIGHT_NO_ sets the device into
  ///       {@code notnight} mode</li>
  ///   <li>_\#MODE_NIGHT_YES_ sets the device into
  ///       {@code night} mode</li>
  ///   <li>_\#MODE_NIGHT_AUTO_ automatically switches between
  ///       {@code night} and {@code notnight} based on the device's current
  ///       location and certain other sensors</li>
  /// </ul>
  ///
  /// <strong>Note:</strong> On API 22 and below, changes to the night mode
  /// are only effective when the Configuration\#UI_MODE_TYPE_CAR car
  /// or Configuration\#UI_MODE_TYPE_DESK desk mode is enabled on a
  /// device. Starting in API 23, changes to night mode are always effective.
  ///@param mode the night mode to set
  /// Value is android.app.UiModeManager\#MODE_NIGHT_AUTO, android.app.UiModeManager\#MODE_NIGHT_NO, or android.app.UiModeManager\#MODE_NIGHT_YES
  ///@see \#getNightMode()
  void setNightMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setNightMode, jni.JniType.voidType, [mode]).check();

  static final _id_getNightMode =
      jniAccessors.getMethodIDOf(_classRef, "getNightMode", "()I");

  /// from: public int getNightMode()
  ///
  /// Returns the currently configured night mode.
  ///
  /// May be one of:
  /// <ul>
  ///   <li>\#MODE_NIGHT_NO</li>
  ///   <li>\#MODE_NIGHT_YES</li>
  ///   <li>\#MODE_NIGHT_AUTO</li>
  ///   <li>{@code -1} on error</li>
  /// </ul>
  ///@return the current night mode, or {@code -1} on error
  /// Value is android.app.UiModeManager\#MODE_NIGHT_AUTO, android.app.UiModeManager\#MODE_NIGHT_NO, or android.app.UiModeManager\#MODE_NIGHT_YES
  ///@see \#setNightMode(int)
  int getNightMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getNightMode, jni.JniType.intType, []).integer;
}
