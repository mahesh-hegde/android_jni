// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/View.dart" as view_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../widget/SpinnerAdapter.dart" as spinneradapter_;

import "../content/Context.dart" as context_;

import "FragmentTransaction.dart" as fragmenttransaction_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../util/AttributeSet.dart" as attributeset_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.ActionBar
///
/// A primary toolbar within the activity that may display the activity title, application-level
/// navigation affordances, and other interactive items.
///
/// Beginning with Android 3.0 (API level 11), the action bar appears at the top of an
/// activity's window when the activity uses the system's android.R.style\#Theme_Holo Holo theme (or one of its descendant themes), which is the default.
/// You may otherwise add the action bar by calling android.view.Window\#requestFeature requestFeature(FEATURE_ACTION_BAR) or by declaring it in a
/// custom theme with the android.R.styleable\#Theme_windowActionBar windowActionBar property.
///
///
///
/// Beginning with Android L (API level 21), the action bar may be represented by any
/// Toolbar widget within the application layout. The application may signal to the Activity
/// which Toolbar should be treated as the Activity's action bar. Activities that use this
/// feature should use one of the supplied <code>.NoActionBar</code> themes, set the
/// android.R.styleable\#Theme_windowActionBar windowActionBar attribute to <code>false</code>
/// or otherwise not request the window feature.
///
///
/// By adjusting the window features requested by the theme and the layouts used for
/// an Activity's content view, an app can use the standard system action bar on older platform
/// releases and the newer inline toolbars on newer platform releases. The <code>ActionBar</code>
/// object obtained from the Activity can be used to control either configuration transparently.
///
///
/// When using the Holo themes the action bar shows the application icon on
/// the left, followed by the activity title. If your activity has an options menu, you can make
/// select items accessible directly from the action bar as "action items". You can also
/// modify various characteristics of the action bar or remove it completely.
///
///
/// When using the Material themes (default in API 21 or newer) the navigation button
/// (formerly "Home") takes over the space previously occupied by the application icon.
/// Apps wishing to express a stronger branding should use their brand colors heavily
/// in the action bar and other application chrome or use a \#setLogo(int) logo
/// in place of their standard title text.
///
///
/// From your activity, you can retrieve an instance of ActionBar by calling android.app.Activity\#getActionBar getActionBar().
///
///
/// In some cases, the action bar may be overlayed by another bar that enables contextual actions,
/// using an android.view.ActionMode. For example, when the user selects one or more items in
/// your activity, you can enable an action mode that offers actions specific to the selected
/// items, with a UI that temporarily replaces the action bar. Although the UI may occupy the
/// same space, the android.view.ActionMode APIs are distinct and independent from those for
/// ActionBar.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about how to use the action bar, including how to add action items, navigation
/// modes and more, read the <a href="{@docRoot}guide/topics/ui/actionbar.html">Action
/// Bar</a> developer guide.
///
/// </div>
class ActionBar extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/ActionBar");
  ActionBar.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DISPLAY_HOME_AS_UP
  ///
  /// Display the 'home' element such that it appears as an 'up' affordance.
  /// e.g. show an arrow to the left indicating the action that will be taken.
  ///
  /// Set this flag if selecting the 'home' button in the action bar to return
  /// up by a single level in your UI rather than back to the top level or front page.
  ///
  /// Setting this option will implicitly enable interaction with the home/up
  /// button. See \#setHomeButtonEnabled(boolean).
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_HOME_AS_UP = 4;

  /// from: static public final int DISPLAY_SHOW_CUSTOM
  ///
  /// Show the custom view if one has been set.
  ///@see \#setCustomView(View)
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_CUSTOM = 16;

  /// from: static public final int DISPLAY_SHOW_HOME
  ///
  /// Show 'home' elements in this action bar, leaving more space for other
  /// navigation elements. This includes logo and icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_HOME = 2;

  /// from: static public final int DISPLAY_SHOW_TITLE
  ///
  /// Show the activity title and subtitle, if present.
  ///@see \#setTitle(CharSequence)
  ///@see \#setTitle(int)
  ///@see \#setSubtitle(CharSequence)
  ///@see \#setSubtitle(int)
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_TITLE = 8;

  /// from: static public final int DISPLAY_USE_LOGO
  ///
  /// Use logo instead of icon if available. This flag will cause appropriate
  /// navigation modes to use a wider logo in place of the standard icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_USE_LOGO = 1;

  /// from: static public final int NAVIGATION_MODE_LIST
  ///
  /// List navigation mode. Instead of static title text this mode
  /// presents a list menu for navigation within the activity.
  /// e.g. this might be presented to the user as a dropdown list.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_LIST = 1;

  /// from: static public final int NAVIGATION_MODE_STANDARD
  ///
  /// Standard navigation mode. Consists of either a logo or icon
  /// and title text with an optional subtitle. Clicking any of these elements
  /// will dispatch onOptionsItemSelected to the host Activity with
  /// a MenuItem with item ID android.R.id.home.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_STANDARD = 0;

  /// from: static public final int NAVIGATION_MODE_TABS
  ///
  /// Tab navigation mode. Instead of static title text this mode
  /// presents a series of tabs for navigation within the activity.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_TABS = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionBar()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setCustomView = jniAccessors.getMethodIDOf(
      _classRef, "setCustomView", "(Landroid/view/View;)V");

  /// from: public abstract void setCustomView(android.view.View view)
  ///
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///@param view Custom navigation view to place in the ActionBar.
  void setCustomView(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCustomView,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setCustomView1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setCustomView",
      "(Landroid/view/View;Landroid/app/ActionBar\$LayoutParams;)V");

  /// from: public abstract void setCustomView(android.view.View view, android.app.ActionBar.LayoutParams layoutParams)
  ///
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///
  ///
  /// The display option \#DISPLAY_SHOW_CUSTOM must be set for
  /// the custom view to be displayed.
  ///
  ///@param view Custom navigation view to place in the ActionBar.
  ///@param layoutParams How this custom view should layout in the bar.
  ///@see \#setDisplayOptions(int, int)
  void setCustomView1(view_.View view, ActionBar_LayoutParams layoutParams) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCustomView1,
          jni.JniType.voidType,
          [view.reference, layoutParams.reference]).check();

  static final _id_setCustomView2 =
      jniAccessors.getMethodIDOf(_classRef, "setCustomView", "(I)V");

  /// from: public abstract void setCustomView(int resId)
  ///
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///
  ///
  /// The display option \#DISPLAY_SHOW_CUSTOM must be set for
  /// the custom view to be displayed.
  ///
  ///@param resId Resource ID of a layout to inflate into the ActionBar.
  ///@see \#setDisplayOptions(int, int)
  void setCustomView2(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setCustomView2, jni.JniType.voidType, [resId]).check();

  static final _id_setIcon =
      jniAccessors.getMethodIDOf(_classRef, "setIcon", "(I)V");

  /// from: public abstract void setIcon(int resId)
  ///
  /// Set the icon to display in the 'home' section of the action bar.
  /// The action bar will use an icon specified by its style or the
  /// activity icon by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param resId Resource ID of a drawable to show as an icon.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setIcon(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setIcon, jni.JniType.voidType, [resId]).check();

  static final _id_setIcon1 = jniAccessors.getMethodIDOf(
      _classRef, "setIcon", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public abstract void setIcon(android.graphics.drawable.Drawable icon)
  ///
  /// Set the icon to display in the 'home' section of the action bar.
  /// The action bar will use an icon specified by its style or the
  /// activity icon by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param icon Drawable to show as an icon.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setIcon1(drawable_.Drawable icon) => jniAccessors.callMethodWithArgs(
      reference, _id_setIcon1, jni.JniType.voidType, [icon.reference]).check();

  static final _id_setLogo =
      jniAccessors.getMethodIDOf(_classRef, "setLogo", "(I)V");

  /// from: public abstract void setLogo(int resId)
  ///
  /// Set the logo to display in the 'home' section of the action bar.
  /// The action bar will use a logo specified by its style or the
  /// activity logo by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param resId Resource ID of a drawable to show as a logo.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setLogo(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setLogo, jni.JniType.voidType, [resId]).check();

  static final _id_setLogo1 = jniAccessors.getMethodIDOf(
      _classRef, "setLogo", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public abstract void setLogo(android.graphics.drawable.Drawable logo)
  ///
  /// Set the logo to display in the 'home' section of the action bar.
  /// The action bar will use a logo specified by its style or the
  /// activity logo by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param logo Drawable to show as a logo.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setLogo1(drawable_.Drawable logo) => jniAccessors.callMethodWithArgs(
      reference, _id_setLogo1, jni.JniType.voidType, [logo.reference]).check();

  static final _id_setListNavigationCallbacks = jniAccessors.getMethodIDOf(
      _classRef,
      "setListNavigationCallbacks",
      "(Landroid/widget/SpinnerAdapter;Landroid/app/ActionBar\$OnNavigationListener;)V");

  /// from: public abstract void setListNavigationCallbacks(android.widget.SpinnerAdapter adapter, android.app.ActionBar.OnNavigationListener callback)
  ///
  /// Set the adapter and navigation callback for list navigation mode.
  ///
  /// The supplied adapter will provide views for the expanded list as well as
  /// the currently selected item. (These may be displayed differently.)
  ///
  /// The supplied OnNavigationListener will alert the application when the user
  /// changes the current list selection.
  ///@param adapter An adapter that will provide views both to display
  ///                the current navigation selection and populate views
  ///                within the dropdown navigation menu.
  ///@param callback An OnNavigationListener that will receive events when the user
  ///                 selects a navigation item.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setListNavigationCallbacks(spinneradapter_.SpinnerAdapter adapter,
          ActionBar_OnNavigationListener callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setListNavigationCallbacks,
          jni.JniType.voidType,
          [adapter.reference, callback.reference]).check();

  static final _id_setSelectedNavigationItem = jniAccessors.getMethodIDOf(
      _classRef, "setSelectedNavigationItem", "(I)V");

  /// from: public abstract void setSelectedNavigationItem(int position)
  ///
  /// Set the selected navigation item in list or tabbed navigation modes.
  ///@param position Position of the item to select.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setSelectedNavigationItem(int position) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSelectedNavigationItem,
          jni.JniType.voidType, [position]).check();

  static final _id_getSelectedNavigationIndex = jniAccessors.getMethodIDOf(
      _classRef, "getSelectedNavigationIndex", "()I");

  /// from: public abstract int getSelectedNavigationIndex()
  ///
  /// Get the position of the selected navigation item in list or tabbed navigation modes.
  ///@return Position of the selected item.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getSelectedNavigationIndex() => jniAccessors.callMethodWithArgs(reference,
      _id_getSelectedNavigationIndex, jni.JniType.intType, []).integer;

  static final _id_getNavigationItemCount =
      jniAccessors.getMethodIDOf(_classRef, "getNavigationItemCount", "()I");

  /// from: public abstract int getNavigationItemCount()
  ///
  /// Get the number of navigation items present in the current navigation mode.
  ///@return Number of navigation items.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getNavigationItemCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getNavigationItemCount, jni.JniType.intType, []).integer;

  static final _id_setTitle = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public abstract void setTitle(java.lang.CharSequence title)
  ///
  /// Set the action bar's title. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param title Title to set
  ///@see \#setTitle(int)
  ///@see \#setDisplayOptions(int, int)
  void setTitle(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle, jni.JniType.voidType, [title.reference]).check();

  static final _id_setTitle1 =
      jniAccessors.getMethodIDOf(_classRef, "setTitle", "(I)V");

  /// from: public abstract void setTitle(int resId)
  ///
  /// Set the action bar's title. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param resId Resource ID of title string to set
  ///@see \#setTitle(CharSequence)
  ///@see \#setDisplayOptions(int, int)
  void setTitle1(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle1, jni.JniType.voidType, [resId]).check();

  static final _id_setSubtitle = jniAccessors.getMethodIDOf(
      _classRef, "setSubtitle", "(Ljava/lang/CharSequence;)V");

  /// from: public abstract void setSubtitle(java.lang.CharSequence subtitle)
  ///
  /// Set the action bar's subtitle. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set. Set to null to disable the
  /// subtitle entirely.
  ///@param subtitle Subtitle to set
  ///@see \#setSubtitle(int)
  ///@see \#setDisplayOptions(int, int)
  void setSubtitle(jni.JniObject subtitle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSubtitle,
      jni.JniType.voidType,
      [subtitle.reference]).check();

  static final _id_setSubtitle1 =
      jniAccessors.getMethodIDOf(_classRef, "setSubtitle", "(I)V");

  /// from: public abstract void setSubtitle(int resId)
  ///
  /// Set the action bar's subtitle. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param resId Resource ID of subtitle string to set
  ///@see \#setSubtitle(CharSequence)
  ///@see \#setDisplayOptions(int, int)
  void setSubtitle1(int resId) => jniAccessors.callMethodWithArgs(
      reference, _id_setSubtitle1, jni.JniType.voidType, [resId]).check();

  static final _id_setDisplayOptions =
      jniAccessors.getMethodIDOf(_classRef, "setDisplayOptions", "(I)V");

  /// from: public abstract void setDisplayOptions(int options)
  ///
  /// Set display options. This changes all display option bits at once. To change
  /// a limited subset of display options, see \#setDisplayOptions(int, int).
  ///@param options A combination of the bits defined by the DISPLAY_ constants
  ///                defined in ActionBar.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  void setDisplayOptions(int options) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDisplayOptions,
      jni.JniType.voidType,
      [options]).check();

  static final _id_setDisplayOptions1 =
      jniAccessors.getMethodIDOf(_classRef, "setDisplayOptions", "(II)V");

  /// from: public abstract void setDisplayOptions(int options, int mask)
  ///
  /// Set selected display options. Only the options specified by mask will be changed.
  /// To change all display option bits at once, see \#setDisplayOptions(int).
  ///
  /// Example: setDisplayOptions(0, DISPLAY_SHOW_HOME) will disable the
  /// \#DISPLAY_SHOW_HOME option.
  /// setDisplayOptions(DISPLAY_SHOW_HOME, DISPLAY_SHOW_HOME | DISPLAY_USE_LOGO)
  /// will enable \#DISPLAY_SHOW_HOME and disable \#DISPLAY_USE_LOGO.
  ///@param options A combination of the bits defined by the DISPLAY_ constants
  ///                defined in ActionBar.
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  ///@param mask A bit mask declaring which display options should be changed.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  void setDisplayOptions1(int options, int mask) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisplayOptions1,
          jni.JniType.voidType, [options, mask]).check();

  static final _id_setDisplayUseLogoEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setDisplayUseLogoEnabled", "(Z)V");

  /// from: public abstract void setDisplayUseLogoEnabled(boolean useLogo)
  ///
  /// Set whether to display the activity logo rather than the activity icon.
  /// A logo is often a wider, more detailed image.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param useLogo true to use the activity logo, false to use the activity icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayUseLogoEnabled(bool useLogo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisplayUseLogoEnabled,
          jni.JniType.voidType, [useLogo]).check();

  static final _id_setDisplayShowHomeEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setDisplayShowHomeEnabled", "(Z)V");

  /// from: public abstract void setDisplayShowHomeEnabled(boolean showHome)
  ///
  /// Set whether to include the application home affordance in the action bar.
  /// Home is presented as either an activity icon or logo.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showHome true to show home, false otherwise.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowHomeEnabled(bool showHome) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisplayShowHomeEnabled,
          jni.JniType.voidType, [showHome]).check();

  static final _id_setDisplayHomeAsUpEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setDisplayHomeAsUpEnabled", "(Z)V");

  /// from: public abstract void setDisplayHomeAsUpEnabled(boolean showHomeAsUp)
  ///
  /// Set whether home should be displayed as an "up" affordance.
  /// Set this to true if selecting "home" returns up by a single level in your UI
  /// rather than back to the top level or front page.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showHomeAsUp true to show the user that selecting home will return one
  ///                     level up rather than to the top level of the app.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayHomeAsUpEnabled(bool showHomeAsUp) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisplayHomeAsUpEnabled,
          jni.JniType.voidType, [showHomeAsUp]).check();

  static final _id_setDisplayShowTitleEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setDisplayShowTitleEnabled", "(Z)V");

  /// from: public abstract void setDisplayShowTitleEnabled(boolean showTitle)
  ///
  /// Set whether an activity title/subtitle should be displayed.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showTitle true to display a title/subtitle if present.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowTitleEnabled(bool showTitle) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDisplayShowTitleEnabled,
          jni.JniType.voidType, [showTitle]).check();

  static final _id_setDisplayShowCustomEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setDisplayShowCustomEnabled", "(Z)V");

  /// from: public abstract void setDisplayShowCustomEnabled(boolean showCustom)
  ///
  /// Set whether a custom view should be displayed, if set.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showCustom true if the currently set custom view should be displayed, false otherwise.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowCustomEnabled(bool showCustom) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDisplayShowCustomEnabled,
          jni.JniType.voidType,
          [showCustom]).check();

  static final _id_setBackgroundDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setBackgroundDrawable", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public abstract void setBackgroundDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Set the ActionBar's background. This will be used for the primary
  /// action bar.
  ///@param d Background drawable
  /// This value may be {@code null}.
  ///@see \#setStackedBackgroundDrawable(Drawable)
  ///@see \#setSplitBackgroundDrawable(Drawable)
  void setBackgroundDrawable(drawable_.Drawable d) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBackgroundDrawable,
          jni.JniType.voidType, [d.reference]).check();

  static final _id_setStackedBackgroundDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "setStackedBackgroundDrawable",
      "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setStackedBackgroundDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Set the ActionBar's stacked background. This will appear
  /// in the second row/stacked bar on some devices and configurations.
  ///@param d Background drawable for the stacked row
  void setStackedBackgroundDrawable(drawable_.Drawable d) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setStackedBackgroundDrawable,
          jni.JniType.voidType,
          [d.reference]).check();

  static final _id_setSplitBackgroundDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "setSplitBackgroundDrawable",
      "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setSplitBackgroundDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Set the ActionBar's split background. This will appear in
  /// the split action bar containing menu-provided action buttons
  /// on some devices and configurations.
  /// You can enable split action bar with android.R.attr\#uiOptions
  ///@param d Background drawable for the split bar
  void setSplitBackgroundDrawable(drawable_.Drawable d) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSplitBackgroundDrawable,
          jni.JniType.voidType, [d.reference]).check();

  static final _id_getCustomView = jniAccessors.getMethodIDOf(
      _classRef, "getCustomView", "()Landroid/view/View;");

  /// from: public abstract android.view.View getCustomView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The current custom view.
  view_.View getCustomView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCustomView, jni.JniType.objectType, []).object);

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current ActionBar title in standard mode.
  /// Returns null if \#getNavigationMode() would not return
  /// \#NAVIGATION_MODE_STANDARD.
  ///@return The current ActionBar title or null.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_getSubtitle = jniAccessors.getMethodIDOf(
      _classRef, "getSubtitle", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getSubtitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current ActionBar subtitle in standard mode.
  /// Returns null if \#getNavigationMode() would not return
  /// \#NAVIGATION_MODE_STANDARD.
  ///@return The current ActionBar subtitle or null.
  jni.JniObject getSubtitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSubtitle, jni.JniType.objectType, []).object);

  static final _id_getNavigationMode =
      jniAccessors.getMethodIDOf(_classRef, "getNavigationMode", "()I");

  /// from: public abstract int getNavigationMode()
  ///
  /// Returns the current navigation mode. The result will be one of:
  /// <ul>
  /// <li>\#NAVIGATION_MODE_STANDARD</li>
  /// <li>\#NAVIGATION_MODE_LIST</li>
  /// <li>\#NAVIGATION_MODE_TABS</li>
  /// </ul>
  ///@return The current navigation mode.
  ///
  /// Value is android.app.ActionBar\#NAVIGATION_MODE_STANDARD, android.app.ActionBar\#NAVIGATION_MODE_LIST, or android.app.ActionBar\#NAVIGATION_MODE_TABS
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getNavigationMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getNavigationMode, jni.JniType.intType, []).integer;

  static final _id_setNavigationMode =
      jniAccessors.getMethodIDOf(_classRef, "setNavigationMode", "(I)V");

  /// from: public abstract void setNavigationMode(int mode)
  ///
  /// Set the current navigation mode.
  ///@param mode The new mode to set.
  /// Value is android.app.ActionBar\#NAVIGATION_MODE_STANDARD, android.app.ActionBar\#NAVIGATION_MODE_LIST, or android.app.ActionBar\#NAVIGATION_MODE_TABS
  ///@see \#NAVIGATION_MODE_STANDARD
  ///@see \#NAVIGATION_MODE_LIST
  ///@see \#NAVIGATION_MODE_TABS
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setNavigationMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setNavigationMode, jni.JniType.voidType, [mode]).check();

  static final _id_getDisplayOptions =
      jniAccessors.getMethodIDOf(_classRef, "getDisplayOptions", "()I");

  /// from: public abstract int getDisplayOptions()
  ///
  /// @return The current set of display options.
  int getDisplayOptions() => jniAccessors.callMethodWithArgs(
      reference, _id_getDisplayOptions, jni.JniType.intType, []).integer;

  static final _id_newTab = jniAccessors.getMethodIDOf(
      _classRef, "newTab", "()Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab newTab()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create and return a new Tab.
  /// This tab will not be included in the action bar until it is added.
  ///
  /// Very often tabs will be used to switch between Fragment
  /// objects.  Here is a typical implementation of such tabs:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentTabs.java
  ///      complete}
  ///@return A new Tab
  ///@see \#addTab(Tab)
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab newTab() =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_newTab, jni.JniType.objectType, []).object);

  static final _id_addTab = jniAccessors.getMethodIDOf(
      _classRef, "addTab", "(Landroid/app/ActionBar\$Tab;)V");

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab)
  ///
  /// Add a tab for use in tabbed navigation mode. The tab will be added at the end of the list.
  /// If this is the first tab to be added it will become the selected tab.
  ///@param tab Tab to add
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab(ActionBar_Tab tab) => jniAccessors.callMethodWithArgs(
      reference, _id_addTab, jni.JniType.voidType, [tab.reference]).check();

  static final _id_addTab1 = jniAccessors.getMethodIDOf(
      _classRef, "addTab", "(Landroid/app/ActionBar\$Tab;Z)V");

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, boolean setSelected)
  ///
  /// Add a tab for use in tabbed navigation mode. The tab will be added at the end of the list.
  ///@param tab Tab to add
  ///@param setSelected True if the added tab should become the selected tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab1(ActionBar_Tab tab, bool setSelected) =>
      jniAccessors.callMethodWithArgs(reference, _id_addTab1,
          jni.JniType.voidType, [tab.reference, setSelected]).check();

  static final _id_addTab2 = jniAccessors.getMethodIDOf(
      _classRef, "addTab", "(Landroid/app/ActionBar\$Tab;I)V");

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, int position)
  ///
  /// Add a tab for use in tabbed navigation mode. The tab will be inserted at
  /// <code>position</code>. If this is the first tab to be added it will become
  /// the selected tab.
  ///@param tab The tab to add
  ///@param position The new position of the tab
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab2(ActionBar_Tab tab, int position) =>
      jniAccessors.callMethodWithArgs(reference, _id_addTab2,
          jni.JniType.voidType, [tab.reference, position]).check();

  static final _id_addTab3 = jniAccessors.getMethodIDOf(
      _classRef, "addTab", "(Landroid/app/ActionBar\$Tab;IZ)V");

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, int position, boolean setSelected)
  ///
  /// Add a tab for use in tabbed navigation mode. The tab will be insterted at
  /// <code>position</code>.
  ///@param tab The tab to add
  ///@param position The new position of the tab
  ///@param setSelected True if the added tab should become the selected tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab3(ActionBar_Tab tab, int position, bool setSelected) =>
      jniAccessors.callMethodWithArgs(reference, _id_addTab3,
          jni.JniType.voidType, [tab.reference, position, setSelected]).check();

  static final _id_removeTab = jniAccessors.getMethodIDOf(
      _classRef, "removeTab", "(Landroid/app/ActionBar\$Tab;)V");

  /// from: public abstract void removeTab(android.app.ActionBar.Tab tab)
  ///
  /// Remove a tab from the action bar. If the removed tab was selected it will be deselected
  /// and another tab will be selected if present.
  ///@param tab The tab to remove
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeTab(ActionBar_Tab tab) => jniAccessors.callMethodWithArgs(
      reference, _id_removeTab, jni.JniType.voidType, [tab.reference]).check();

  static final _id_removeTabAt =
      jniAccessors.getMethodIDOf(_classRef, "removeTabAt", "(I)V");

  /// from: public abstract void removeTabAt(int position)
  ///
  /// Remove a tab from the action bar. If the removed tab was selected it will be deselected
  /// and another tab will be selected if present.
  ///@param position Position of the tab to remove
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeTabAt(int position) => jniAccessors.callMethodWithArgs(
      reference, _id_removeTabAt, jni.JniType.voidType, [position]).check();

  static final _id_removeAllTabs =
      jniAccessors.getMethodIDOf(_classRef, "removeAllTabs", "()V");

  /// from: public abstract void removeAllTabs()
  ///
  /// Remove all tabs from the action bar and deselect the current tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeAllTabs() => jniAccessors.callMethodWithArgs(
      reference, _id_removeAllTabs, jni.JniType.voidType, []).check();

  static final _id_selectTab = jniAccessors.getMethodIDOf(
      _classRef, "selectTab", "(Landroid/app/ActionBar\$Tab;)V");

  /// from: public abstract void selectTab(android.app.ActionBar.Tab tab)
  ///
  /// Select the specified tab. If it is not a child of this action bar it will be added.
  ///
  /// Note: If you want to select by index, use \#setSelectedNavigationItem(int).
  ///
  ///@param tab Tab to select
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void selectTab(ActionBar_Tab tab) => jniAccessors.callMethodWithArgs(
      reference, _id_selectTab, jni.JniType.voidType, [tab.reference]).check();

  static final _id_getSelectedTab = jniAccessors.getMethodIDOf(
      _classRef, "getSelectedTab", "()Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab getSelectedTab()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the currently selected tab if in tabbed navigation mode and there is at least
  /// one tab present.
  ///@return The currently selected tab or null
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab getSelectedTab() =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSelectedTab, jni.JniType.objectType, []).object);

  static final _id_getTabAt = jniAccessors.getMethodIDOf(
      _classRef, "getTabAt", "(I)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab getTabAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the tab at the specified index.
  ///@param index Index value in the range 0-get
  ///@return
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab getTabAt(int index) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTabAt, jni.JniType.objectType, [index]).object);

  static final _id_getTabCount =
      jniAccessors.getMethodIDOf(_classRef, "getTabCount", "()I");

  /// from: public abstract int getTabCount()
  ///
  /// Returns the number of tabs currently registered with the action bar.
  ///@return Tab count
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getTabCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getTabCount, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public abstract int getHeight()
  ///
  /// Retrieve the current height of the ActionBar.
  ///@return The ActionBar's height
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_show0 = jniAccessors.getMethodIDOf(_classRef, "show", "()V");

  /// from: public abstract void show()
  ///
  /// Show the ActionBar if it is not currently showing.
  /// If the window hosting the ActionBar does not have the feature
  /// Window\#FEATURE_ACTION_BAR_OVERLAY it will resize application
  /// content to fit the new space available.
  ///
  /// If you are hiding the ActionBar through
  /// View\#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN,
  /// you should not call this function directly.
  void show0() => jniAccessors.callMethodWithArgs(
      reference, _id_show0, jni.JniType.voidType, []).check();

  static final _id_hide0 = jniAccessors.getMethodIDOf(_classRef, "hide", "()V");

  /// from: public abstract void hide()
  ///
  /// Hide the ActionBar if it is currently showing.
  /// If the window hosting the ActionBar does not have the feature
  /// Window\#FEATURE_ACTION_BAR_OVERLAY it will resize application
  /// content to fit the new space available.
  ///
  /// Instead of calling this function directly, you can also cause an
  /// ActionBar using the overlay feature to hide through
  /// View\#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN.
  /// Hiding the ActionBar through this system UI flag allows you to more
  /// seamlessly hide it in conjunction with other screen decorations.
  void hide0() => jniAccessors.callMethodWithArgs(
      reference, _id_hide0, jni.JniType.voidType, []).check();

  static final _id_isShowing =
      jniAccessors.getMethodIDOf(_classRef, "isShowing", "()Z");

  /// from: public abstract boolean isShowing()
  ///
  /// @return <code>true</code> if the ActionBar is showing, <code>false</code> otherwise.
  bool isShowing() => jniAccessors.callMethodWithArgs(
      reference, _id_isShowing, jni.JniType.booleanType, []).boolean;

  static final _id_addOnMenuVisibilityListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnMenuVisibilityListener",
      "(Landroid/app/ActionBar\$OnMenuVisibilityListener;)V");

  /// from: public abstract void addOnMenuVisibilityListener(android.app.ActionBar.OnMenuVisibilityListener listener)
  ///
  /// Add a listener that will respond to menu visibility change events.
  ///@param listener The new listener to add
  void addOnMenuVisibilityListener(
          ActionBar_OnMenuVisibilityListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnMenuVisibilityListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_removeOnMenuVisibilityListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnMenuVisibilityListener",
      "(Landroid/app/ActionBar\$OnMenuVisibilityListener;)V");

  /// from: public abstract void removeOnMenuVisibilityListener(android.app.ActionBar.OnMenuVisibilityListener listener)
  ///
  /// Remove a menu visibility listener. This listener will no longer receive menu
  /// visibility change events.
  ///@param listener A listener to remove that was previously added
  void removeOnMenuVisibilityListener(
          ActionBar_OnMenuVisibilityListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnMenuVisibilityListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_setHomeButtonEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setHomeButtonEnabled", "(Z)V");

  /// from: public void setHomeButtonEnabled(boolean enabled)
  ///
  /// Enable or disable the "home" button in the corner of the action bar. (Note that this
  /// is the application home/up affordance on the action bar, not the systemwide home
  /// button.)
  ///
  /// This defaults to true for packages targeting &lt; API 14. For packages targeting
  /// API 14 or greater, the application should call this method to enable interaction
  /// with the home/up affordance.
  ///
  /// Setting the \#DISPLAY_HOME_AS_UP display option will automatically enable
  /// the home button.
  ///@param enabled true to enable the home button, false to disable the home button.
  void setHomeButtonEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setHomeButtonEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_getThemedContext = jniAccessors.getMethodIDOf(
      _classRef, "getThemedContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getThemedContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Context with an appropriate theme for creating views that
  /// will appear in the action bar. If you are inflating or instantiating custom views
  /// that will appear in an action bar, you should use the Context returned by this method.
  /// (This includes adapters used for list navigation mode.)
  /// This will ensure that views contrast properly against the action bar.
  ///@return A themed Context for creating views
  context_.Context getThemedContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getThemedContext, jni.JniType.objectType, []).object);

  static final _id_setHomeAsUpIndicator = jniAccessors.getMethodIDOf(_classRef,
      "setHomeAsUpIndicator", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setHomeAsUpIndicator(android.graphics.drawable.Drawable indicator)
  ///
  /// Set an alternate drawable to display next to the icon/logo/title
  /// when \#DISPLAY_HOME_AS_UP is enabled. This can be useful if you are using
  /// this mode to display an alternate selection for up navigation, such as a sliding drawer.
  ///
  /// If you pass <code>null</code> to this method, the default drawable from the theme
  /// will be used.
  ///
  ///
  /// If you implement alternate or intermediate behavior around Up, you should also
  /// call \#setHomeActionContentDescription(int) setHomeActionContentDescription()
  /// to provide a correct description of the action for accessibility support.
  ///
  ///@param indicator A drawable to use for the up indicator, or null to use the theme's default
  ///@see \#setDisplayOptions(int, int)
  ///@see \#setDisplayHomeAsUpEnabled(boolean)
  ///@see \#setHomeActionContentDescription(int)
  void setHomeAsUpIndicator(drawable_.Drawable indicator) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHomeAsUpIndicator,
          jni.JniType.voidType, [indicator.reference]).check();

  static final _id_setHomeAsUpIndicator1 =
      jniAccessors.getMethodIDOf(_classRef, "setHomeAsUpIndicator", "(I)V");

  /// from: public void setHomeAsUpIndicator(int resId)
  ///
  /// Set an alternate drawable to display next to the icon/logo/title
  /// when \#DISPLAY_HOME_AS_UP is enabled. This can be useful if you are using
  /// this mode to display an alternate selection for up navigation, such as a sliding drawer.
  ///
  /// If you pass <code>0</code> to this method, the default drawable from the theme
  /// will be used.
  ///
  ///
  /// If you implement alternate or intermediate behavior around Up, you should also
  /// call \#setHomeActionContentDescription(int) setHomeActionContentDescription()
  /// to provide a correct description of the action for accessibility support.
  ///
  ///@param resId Resource ID of a drawable to use for the up indicator, or null
  ///              to use the theme's default
  ///@see \#setDisplayOptions(int, int)
  ///@see \#setDisplayHomeAsUpEnabled(boolean)
  ///@see \#setHomeActionContentDescription(int)
  void setHomeAsUpIndicator1(int resId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setHomeAsUpIndicator1,
      jni.JniType.voidType,
      [resId]).check();

  static final _id_setHomeActionContentDescription = jniAccessors.getMethodIDOf(
      _classRef,
      "setHomeActionContentDescription",
      "(Ljava/lang/CharSequence;)V");

  /// from: public void setHomeActionContentDescription(java.lang.CharSequence description)
  ///
  /// Set an alternate description for the Home/Up action, when enabled.
  ///
  /// This description is commonly used for accessibility/screen readers when
  /// the Home action is enabled. (See \#setDisplayHomeAsUpEnabled(boolean).)
  /// Examples of this are, "Navigate Home" or "Navigate Up" depending on the
  /// \#DISPLAY_HOME_AS_UP display option. If you have changed the home-as-up
  /// indicator using \#setHomeAsUpIndicator(int) to indicate more specific
  /// functionality such as a sliding drawer, you should also set this to accurately
  /// describe the action.
  ///
  ///
  /// Setting this to <code>null</code> will use the system default description.
  ///
  ///@param description New description for the Home action when enabled
  ///@see \#setHomeAsUpIndicator(int)
  ///@see \#setHomeAsUpIndicator(android.graphics.drawable.Drawable)
  void setHomeActionContentDescription(jni.JniObject description) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setHomeActionContentDescription,
          jni.JniType.voidType,
          [description.reference]).check();

  static final _id_setHomeActionContentDescription1 = jniAccessors
      .getMethodIDOf(_classRef, "setHomeActionContentDescription", "(I)V");

  /// from: public void setHomeActionContentDescription(int resId)
  ///
  /// Set an alternate description for the Home/Up action, when enabled.
  ///
  /// This description is commonly used for accessibility/screen readers when
  /// the Home action is enabled. (See \#setDisplayHomeAsUpEnabled(boolean).)
  /// Examples of this are, "Navigate Home" or "Navigate Up" depending on the
  /// \#DISPLAY_HOME_AS_UP display option. If you have changed the home-as-up
  /// indicator using \#setHomeAsUpIndicator(int) to indicate more specific
  /// functionality such as a sliding drawer, you should also set this to accurately
  /// describe the action.
  ///
  ///
  /// Setting this to <code>0</code> will use the system default description.
  ///
  ///@param resId Resource ID of a string to use as the new description
  ///              for the Home action when enabled
  ///@see \#setHomeAsUpIndicator(int)
  ///@see \#setHomeAsUpIndicator(android.graphics.drawable.Drawable)
  void setHomeActionContentDescription1(int resId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setHomeActionContentDescription1,
          jni.JniType.voidType,
          [resId]).check();

  static final _id_setHideOnContentScrollEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setHideOnContentScrollEnabled", "(Z)V");

  /// from: public void setHideOnContentScrollEnabled(boolean hideOnContentScroll)
  ///
  /// Enable hiding the action bar on content scroll.
  ///
  /// If enabled, the action bar will scroll out of sight along with a
  /// View\#setNestedScrollingEnabled(boolean) nested scrolling child view's content.
  /// The action bar must be in Window\#FEATURE_ACTION_BAR_OVERLAY overlay mode
  /// to enable hiding on content scroll.
  ///
  ///
  /// When partially scrolled off screen the action bar is considered
  /// \#hide() hidden. A call to \#show() show will cause it to return to full view.
  ///
  ///
  ///@param hideOnContentScroll true to enable hiding on content scroll.
  void setHideOnContentScrollEnabled(bool hideOnContentScroll) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setHideOnContentScrollEnabled,
          jni.JniType.voidType,
          [hideOnContentScroll]).check();

  static final _id_isHideOnContentScrollEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isHideOnContentScrollEnabled", "()Z");

  /// from: public boolean isHideOnContentScrollEnabled()
  ///
  /// Return whether the action bar is configured to scroll out of sight along with
  /// a View\#setNestedScrollingEnabled(boolean) nested scrolling child.
  ///@return true if hide-on-content-scroll is enabled
  ///@see \#setHideOnContentScrollEnabled(boolean)
  bool isHideOnContentScrollEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isHideOnContentScrollEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_getHideOffset =
      jniAccessors.getMethodIDOf(_classRef, "getHideOffset", "()I");

  /// from: public int getHideOffset()
  ///
  /// Return the current vertical offset of the action bar.
  ///
  /// The action bar's current hide offset is the distance that the action bar is currently
  /// scrolled offscreen in pixels. The valid range is 0 (fully visible) to the action bar's
  /// current measured \#getHeight() height (fully invisible).
  ///
  ///@return The action bar's offset toward its fully hidden state in pixels
  int getHideOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getHideOffset, jni.JniType.intType, []).integer;

  static final _id_setHideOffset =
      jniAccessors.getMethodIDOf(_classRef, "setHideOffset", "(I)V");

  /// from: public void setHideOffset(int offset)
  ///
  /// Set the current hide offset of the action bar.
  ///
  /// The action bar's current hide offset is the distance that the action bar is currently
  /// scrolled offscreen in pixels. The valid range is 0 (fully visible) to the action bar's
  /// current measured \#getHeight() height (fully invisible).
  ///
  ///@param offset The action bar's offset toward its fully hidden state in pixels.
  void setHideOffset(int offset) => jniAccessors.callMethodWithArgs(
      reference, _id_setHideOffset, jni.JniType.voidType, [offset]).check();

  static final _id_setElevation =
      jniAccessors.getMethodIDOf(_classRef, "setElevation", "(F)V");

  /// from: public void setElevation(float elevation)
  ///
  /// Set the Z-axis elevation of the action bar in pixels.
  ///
  /// The action bar's elevation is the distance it is placed from its parent surface. Higher
  /// values are closer to the user.
  ///
  ///@param elevation Elevation value in pixels
  void setElevation(double elevation) => jniAccessors.callMethodWithArgs(
      reference, _id_setElevation, jni.JniType.voidType, [elevation]).check();

  static final _id_getElevation =
      jniAccessors.getMethodIDOf(_classRef, "getElevation", "()F");

  /// from: public float getElevation()
  ///
  /// Get the Z-axis elevation of the action bar in pixels.
  ///
  /// The action bar's elevation is the distance it is placed from its parent surface. Higher
  /// values are closer to the user.
  ///
  ///@return Elevation value in pixels
  double getElevation() => jniAccessors.callMethodWithArgs(
      reference, _id_getElevation, jni.JniType.floatType, []).float;
}

/// from: android.app.ActionBar$TabListener
///
/// Callback interface invoked when a tab is focused, unfocused, added, or removed.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_TabListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActionBar\$TabListener");
  ActionBar_TabListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onTabSelected = jniAccessors.getMethodIDOf(
      _classRef,
      "onTabSelected",
      "(Landroid/app/ActionBar\$Tab;Landroid/app/FragmentTransaction;)V");

  /// from: public abstract void onTabSelected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  ///
  /// Called when a tab enters the selected state.
  ///@param tab The tab that was selected
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        during a tab switch. The previous tab's unselect and this tab's select will be
  ///        executed in a single transaction. This FragmentTransaction does not support
  ///        being added to the back stack.
  void onTabSelected(
          ActionBar_Tab tab, fragmenttransaction_.FragmentTransaction ft) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTabSelected,
          jni.JniType.voidType, [tab.reference, ft.reference]).check();

  static final _id_onTabUnselected = jniAccessors.getMethodIDOf(
      _classRef,
      "onTabUnselected",
      "(Landroid/app/ActionBar\$Tab;Landroid/app/FragmentTransaction;)V");

  /// from: public abstract void onTabUnselected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  ///
  /// Called when a tab exits the selected state.
  ///@param tab The tab that was unselected
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        during a tab switch. This tab's unselect and the newly selected tab's select
  ///        will be executed in a single transaction. This FragmentTransaction does not
  ///        support being added to the back stack.
  void onTabUnselected(
          ActionBar_Tab tab, fragmenttransaction_.FragmentTransaction ft) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTabUnselected,
          jni.JniType.voidType, [tab.reference, ft.reference]).check();

  static final _id_onTabReselected = jniAccessors.getMethodIDOf(
      _classRef,
      "onTabReselected",
      "(Landroid/app/ActionBar\$Tab;Landroid/app/FragmentTransaction;)V");

  /// from: public abstract void onTabReselected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  ///
  /// Called when a tab that is already selected is chosen again by the user.
  /// Some applications may use this action to return to the top level of a category.
  ///@param tab The tab that was reselected.
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        once this method returns. This FragmentTransaction does not support
  ///        being added to the back stack.
  void onTabReselected(
          ActionBar_Tab tab, fragmenttransaction_.FragmentTransaction ft) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTabReselected,
          jni.JniType.voidType, [tab.reference, ft.reference]).check();
}

/// from: android.app.ActionBar$Tab
///
/// A tab in the action bar.
///
/// Tabs manage the hiding and showing of Fragments.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_Tab extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActionBar\$Tab");
  ActionBar_Tab.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int INVALID_POSITION
  ///
  /// An invalid position for a tab.
  ///@see \#getPosition()
  static const INVALID_POSITION = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionBar_Tab()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getPosition =
      jniAccessors.getMethodIDOf(_classRef, "getPosition", "()I");

  /// from: public abstract int getPosition()
  ///
  /// Return the current position of this tab in the action bar.
  ///@return Current position, or \#INVALID_POSITION if this tab is not currently in
  ///         the action bar.
  int getPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getPosition, jni.JniType.intType, []).integer;

  static final _id_getIcon = jniAccessors.getMethodIDOf(
      _classRef, "getIcon", "()Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the icon associated with this tab.
  ///@return The tab's icon
  drawable_.Drawable getIcon() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIcon, jni.JniType.objectType, []).object);

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the text of this tab.
  ///@return The tab's text
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_setIcon = jniAccessors.getMethodIDOf(_classRef, "setIcon",
      "(Landroid/graphics/drawable/Drawable;)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setIcon(android.graphics.drawable.Drawable icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the icon displayed on this tab.
  ///@param icon The drawable to use as an icon
  ///@return The current instance for call chaining
  ActionBar_Tab setIcon(drawable_.Drawable icon) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setIcon, jni.JniType.objectType, [icon.reference]).object);

  static final _id_setIcon1 = jniAccessors.getMethodIDOf(
      _classRef, "setIcon", "(I)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setIcon(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the icon displayed on this tab.
  ///@param resId Resource ID referring to the drawable to use as an icon
  ///@return The current instance for call chaining
  ActionBar_Tab setIcon1(int resId) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setIcon1, jni.JniType.objectType, [resId]).object);

  static final _id_setText = jniAccessors.getMethodIDOf(_classRef, "setText",
      "(Ljava/lang/CharSequence;)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setText(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the text displayed on this tab. Text may be truncated if there is not
  /// room to display the entire string.
  ///@param text The text to display
  ///@return The current instance for call chaining
  ActionBar_Tab setText(jni.JniObject text) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setText, jni.JniType.objectType, [text.reference]).object);

  static final _id_setText1 = jniAccessors.getMethodIDOf(
      _classRef, "setText", "(I)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setText(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the text displayed on this tab. Text may be truncated if there is not
  /// room to display the entire string.
  ///@param resId A resource ID referring to the text that should be displayed
  ///@return The current instance for call chaining
  ActionBar_Tab setText1(int resId) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setText1, jni.JniType.objectType, [resId]).object);

  static final _id_setCustomView = jniAccessors.getMethodIDOf(_classRef,
      "setCustomView", "(Landroid/view/View;)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setCustomView(android.view.View view)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a custom view to be used for this tab. This overrides values set by
  /// \#setText(CharSequence) and \#setIcon(Drawable).
  ///@param view Custom view to be used as a tab.
  ///@return The current instance for call chaining
  ActionBar_Tab setCustomView(view_.View view) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setCustomView, jni.JniType.objectType, [view.reference]).object);

  static final _id_setCustomView1 = jniAccessors.getMethodIDOf(
      _classRef, "setCustomView", "(I)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setCustomView(int layoutResId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a custom view to be used for this tab. This overrides values set by
  /// \#setText(CharSequence) and \#setIcon(Drawable).
  ///@param layoutResId A layout resource to inflate and use as a custom tab view
  ///@return The current instance for call chaining
  ActionBar_Tab setCustomView1(int layoutResId) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setCustomView1, jni.JniType.objectType, [layoutResId]).object);

  static final _id_getCustomView = jniAccessors.getMethodIDOf(
      _classRef, "getCustomView", "()Landroid/view/View;");

  /// from: public abstract android.view.View getCustomView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a previously set custom view for this tab.
  ///@return The custom view set by \#setCustomView(View).
  view_.View getCustomView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCustomView, jni.JniType.objectType, []).object);

  static final _id_setTag = jniAccessors.getMethodIDOf(
      _classRef, "setTag", "(Ljava/lang/Object;)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setTag(java.lang.Object obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Give this Tab an arbitrary object to hold for later use.
  ///@param obj Object to store
  ///@return The current instance for call chaining
  ActionBar_Tab setTag(jni.JniObject obj) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setTag, jni.JniType.objectType, [obj.reference]).object);

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Ljava/lang/Object;");

  /// from: public abstract java.lang.Object getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This Tab's tag object.
  jni.JniObject getTag() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_setTabListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setTabListener",
      "(Landroid/app/ActionBar\$TabListener;)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setTabListener(android.app.ActionBar.TabListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the TabListener that will handle switching to and from this tab.
  /// All tabs must have a TabListener set before being added to the ActionBar.
  ///@param listener Listener to handle tab selection events
  ///@return The current instance for call chaining
  ActionBar_Tab setTabListener(ActionBar_TabListener listener) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTabListener,
          jni.JniType.objectType,
          [listener.reference]).object);

  static final _id_select =
      jniAccessors.getMethodIDOf(_classRef, "select", "()V");

  /// from: public abstract void select()
  ///
  /// Select this tab. Only valid if the tab has been added to the action bar.
  void select() => jniAccessors.callMethodWithArgs(
      reference, _id_select, jni.JniType.voidType, []).check();

  static final _id_setContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "setContentDescription", "(I)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setContentDescription(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a description of this tab's content for use in accessibility support.
  /// If no content description is provided the title will be used.
  ///@param resId A resource ID referring to the description text
  ///@return The current instance for call chaining
  ///@see \#setContentDescription(CharSequence)
  ///@see \#getContentDescription()
  ActionBar_Tab setContentDescription(int resId) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setContentDescription, jni.JniType.objectType, [resId]).object);

  static final _id_setContentDescription1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentDescription",
      "(Ljava/lang/CharSequence;)Landroid/app/ActionBar\$Tab;");

  /// from: public abstract android.app.ActionBar.Tab setContentDescription(java.lang.CharSequence contentDesc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a description of this tab's content for use in accessibility support.
  /// If no content description is provided the title will be used.
  ///@param contentDesc Description of this tab's content
  ///@return The current instance for call chaining
  ///@see \#setContentDescription(int)
  ///@see \#getContentDescription()
  ActionBar_Tab setContentDescription1(jni.JniObject contentDesc) =>
      ActionBar_Tab.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentDescription1,
          jni.JniType.objectType,
          [contentDesc.reference]).object);

  static final _id_getContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "getContentDescription", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getContentDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a brief description of this tab's content for use in accessibility support.
  ///@return Description of this tab's content
  ///@see \#setContentDescription(CharSequence)
  ///@see \#setContentDescription(int)
  jni.JniObject getContentDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getContentDescription, jni.JniType.objectType, []).object);
}

/// from: android.app.ActionBar$OnNavigationListener
///
/// Listener interface for ActionBar navigation events.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_OnNavigationListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActionBar\$OnNavigationListener");
  ActionBar_OnNavigationListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onNavigationItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onNavigationItemSelected", "(IJ)Z");

  /// from: public abstract boolean onNavigationItemSelected(int itemPosition, long itemId)
  ///
  /// This method is called whenever a navigation item in your action bar
  /// is selected.
  ///@param itemPosition Position of the item clicked.
  ///@param itemId ID of the item clicked.
  ///@return True if the event was handled, false otherwise.
  bool onNavigationItemSelected(int itemPosition, int itemId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onNavigationItemSelected,
          jni.JniType.booleanType, [itemPosition, itemId]).boolean;
}

/// from: android.app.ActionBar$OnMenuVisibilityListener
///
/// Listener for receiving events when action bar menus are shown or hidden.
class ActionBar_OnMenuVisibilityListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/ActionBar\$OnMenuVisibilityListener");
  ActionBar_OnMenuVisibilityListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onMenuVisibilityChanged =
      jniAccessors.getMethodIDOf(_classRef, "onMenuVisibilityChanged", "(Z)V");

  /// from: public abstract void onMenuVisibilityChanged(boolean isVisible)
  ///
  /// Called when an action bar menu is shown or hidden. Applications may want to use
  /// this to tune auto-hiding behavior for the action bar or pause/resume video playback,
  /// gameplay, or other activity within the main content area.
  ///@param isVisible True if an action bar menu is now visible, false if no action bar
  ///                  menus are visible.
  void onMenuVisibilityChanged(bool isVisible) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuVisibilityChanged,
          jni.JniType.voidType, [isVisible]).check();
}

/// from: android.app.ActionBar$LayoutParams
///
/// Per-child layout information associated with action bar custom views.
///@attr ref android.R.styleable\#ActionBar_LayoutParams_layout_gravity
class ActionBar_LayoutParams extends viewgroup_.ViewGroup_MarginLayoutParams {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActionBar\$LayoutParams");
  ActionBar_LayoutParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_gravity =
      jniAccessors.getFieldIDOf(_classRef, "gravity", "I");

  /// from: public int gravity
  ///
  /// Gravity for the view associated with these LayoutParams.
  ///@see android.view.Gravity
  int get gravity => jniAccessors
      .getField(reference, _id_gravity, jni.JniType.intType)
      .integer;

  /// from: public int gravity
  ///
  /// Gravity for the view associated with these LayoutParams.
  ///@see android.view.Gravity
  set gravity(int value) => jniEnv.SetIntField(reference, _id_gravity, value);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param c This value must never be {@code null}.
  ActionBar_LayoutParams(context_.Context c, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [c.reference, attrs.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionBar_LayoutParams.ctor1(int width, int height)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [width, height]).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(III)V");

  /// from: public void <init>(int width, int height, int gravity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionBar_LayoutParams.ctor4(int width, int height, int gravity)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [width, height, gravity]).object);

  static final _id_ctor5 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int gravity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionBar_LayoutParams.ctor5(int gravity)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor5, [gravity]).object);

  static final _id_ctor6 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/ActionBar\$LayoutParams;)V");

  /// from: public void <init>(android.app.ActionBar.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionBar_LayoutParams.ctor6(ActionBar_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor6, [source.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void <init>(android.view.ViewGroup.LayoutParams source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActionBar_LayoutParams.ctor2(viewgroup_.ViewGroup_LayoutParams source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [source.reference]).object);
}
