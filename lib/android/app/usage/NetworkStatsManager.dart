// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "NetworkStats.dart" as networkstats_;

import "../../os/Handler.dart" as handler_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.usage.NetworkStatsManager
///
/// Provides access to network usage history and statistics. Usage data is collected in
/// discrete bins of time called 'Buckets'. See NetworkStats.Bucket for details.
/// <p/>
/// Queries can define a time interval in the form of start and end timestamps (Long.MIN_VALUE and
/// Long.MAX_VALUE can be used to simulate open ended intervals). By default, apps can only obtain
/// data about themselves. See the below note for special cases in which apps can obtain data about
/// other applications.
/// <h3>
/// Summary queries
/// </h3>
/// \#querySummaryForDevice <p/>
/// \#querySummaryForUser <p/>
/// \#querySummary <p/>
/// These queries aggregate network usage across the whole interval. Therefore there will be only one
/// bucket for a particular key, state, metered and roaming combination. In case of the user-wide
/// and device-wide summaries a single bucket containing the totalised network usage is returned.
/// <h3>
/// History queries
/// </h3>
/// \#queryDetailsForUid <p/>
/// \#queryDetails <p/>
/// These queries do not aggregate over time but do aggregate over state, metered and roaming.
/// Therefore there can be multiple buckets for a particular key. However, all Buckets will have
/// {@code state} NetworkStats.Bucket\#STATE_ALL,
/// {@code defaultNetwork} NetworkStats.Bucket\#DEFAULT_NETWORK_ALL,
/// {@code metered } NetworkStats.Bucket\#METERED_ALL,
/// {@code roaming} NetworkStats.Bucket\#ROAMING_ALL.
/// <p/>
/// __NOTE:__ Calling \#querySummaryForDevice or accessing stats for apps other than the
/// calling app requires the permission android.Manifest.permission\#PACKAGE_USAGE_STATS,
/// which is a system-level permission and will not be granted to third-party apps. However,
/// declaring the permission implies intention to use the API and the user of the device can grant
/// permission through the Settings application.
/// <p/>
/// Profile owner apps are automatically granted permission to query data on the profile they manage
/// (that is, for any query except \#querySummaryForDevice). Device owner apps and carrier-
/// privileged apps likewise get access to usage data for all users on the device.
/// <p/>
/// In addition to tethering usage, usage by removed users and apps, and usage by the system
/// is also included in the results for callers with one of these higher levels of access.
/// <p/>
/// __NOTE:__ Prior to API level {@value android.os.Build.VERSION_CODES\#N}, all calls to these APIs required
/// the above permission, even to access an app's own data usage, and carrier-privileged apps were
/// not included.
class NetworkStatsManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/usage/NetworkStatsManager");
  NetworkStatsManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_querySummaryForDevice = jniAccessors.getMethodIDOf(
      _classRef,
      "querySummaryForDevice",
      "(ILjava/lang/String;JJ)Landroid/app/usage/NetworkStats\$Bucket;");

  /// from: public android.app.usage.NetworkStats.Bucket querySummaryForDevice(int networkType, java.lang.String subscriberId, long startTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics summaries. Result is summarised data usage for the whole
  /// device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and
  /// roaming. This means the bucket's start and end timestamp are going to be the same as the
  /// 'startTime' and 'endTime' parameters. State is going to be
  /// NetworkStats.Bucket\#STATE_ALL, uid NetworkStats.Bucket\#UID_ALL,
  /// tag NetworkStats.Bucket\#TAG_NONE,
  /// default network NetworkStats.Bucket\#DEFAULT_NETWORK_ALL,
  /// metered NetworkStats.Bucket\#METERED_ALL,
  /// and roaming NetworkStats.Bucket\#ROAMING_ALL.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@return Bucket object or null if permissions are insufficient or error happened during
  ///         statistics collection.
  networkstats_.NetworkStats_Bucket querySummaryForDevice(int networkType,
          jni.JniString subscriberId, int startTime, int endTime) =>
      networkstats_.NetworkStats_Bucket.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_querySummaryForDevice,
          jni.JniType.objectType,
          [networkType, subscriberId.reference, startTime, endTime]).object);

  static final _id_querySummaryForUser = jniAccessors.getMethodIDOf(
      _classRef,
      "querySummaryForUser",
      "(ILjava/lang/String;JJ)Landroid/app/usage/NetworkStats\$Bucket;");

  /// from: public android.app.usage.NetworkStats.Bucket querySummaryForUser(int networkType, java.lang.String subscriberId, long startTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics summaries. Result is summarised data usage for all uids
  /// belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
  /// This means the bucket's start and end timestamp are going to be the same as the 'startTime'
  /// and 'endTime' parameters. State is going to be NetworkStats.Bucket\#STATE_ALL,
  /// uid NetworkStats.Bucket\#UID_ALL, tag NetworkStats.Bucket\#TAG_NONE,
  /// metered NetworkStats.Bucket\#METERED_ALL, and roaming
  /// NetworkStats.Bucket\#ROAMING_ALL.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@return Bucket object or null if permissions are insufficient or error happened during
  ///         statistics collection.
  networkstats_.NetworkStats_Bucket querySummaryForUser(int networkType,
          jni.JniString subscriberId, int startTime, int endTime) =>
      networkstats_.NetworkStats_Bucket.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_querySummaryForUser,
          jni.JniType.objectType,
          [networkType, subscriberId.reference, startTime, endTime]).object);

  static final _id_querySummary = jniAccessors.getMethodIDOf(
      _classRef,
      "querySummary",
      "(ILjava/lang/String;JJ)Landroid/app/usage/NetworkStats;");

  /// from: public android.app.usage.NetworkStats querySummary(int networkType, java.lang.String subscriberId, long startTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics summaries. Result filtered to include only uids belonging to
  /// calling user. Result is aggregated over time, hence all buckets will have the same start and
  /// end timestamps. Not aggregated over state, uid, default network, metered, or roaming. This
  /// means buckets' start and end timestamps are going to be the same as the 'startTime' and
  /// 'endTime' parameters. State, uid, metered, and roaming are going to vary, and tag is going to
  /// be the same.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@return Statistics object or null if permissions are insufficient or error happened during
  ///         statistics collection.
  networkstats_.NetworkStats querySummary(int networkType,
          jni.JniString subscriberId, int startTime, int endTime) =>
      networkstats_.NetworkStats.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_querySummary,
          jni.JniType.objectType,
          [networkType, subscriberId.reference, startTime, endTime]).object);

  static final _id_queryDetailsForUid = jniAccessors.getMethodIDOf(
      _classRef,
      "queryDetailsForUid",
      "(ILjava/lang/String;JJI)Landroid/app/usage/NetworkStats;");

  /// from: public android.app.usage.NetworkStats queryDetailsForUid(int networkType, java.lang.String subscriberId, long startTime, long endTime, int uid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics details for a given uid.
  ///
  /// \#see queryDetailsForUidTagState(int, String, long, long, int, int, int)
  networkstats_.NetworkStats queryDetailsForUid(int networkType,
          jni.JniString subscriberId, int startTime, int endTime, int uid) =>
      networkstats_.NetworkStats.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_queryDetailsForUid, jni.JniType.objectType, [
        networkType,
        subscriberId.reference,
        startTime,
        endTime,
        uid
      ]).object);

  static final _id_queryDetailsForUidTag = jniAccessors.getMethodIDOf(
      _classRef,
      "queryDetailsForUidTag",
      "(ILjava/lang/String;JJII)Landroid/app/usage/NetworkStats;");

  /// from: public android.app.usage.NetworkStats queryDetailsForUidTag(int networkType, java.lang.String subscriberId, long startTime, long endTime, int uid, int tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics details for a given uid and tag.
  ///
  /// \#see queryDetailsForUidTagState(int, String, long, long, int, int, int)
  networkstats_.NetworkStats queryDetailsForUidTag(
          int networkType,
          jni.JniString subscriberId,
          int startTime,
          int endTime,
          int uid,
          int tag) =>
      networkstats_.NetworkStats.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_queryDetailsForUidTag, jni.JniType.objectType, [
        networkType,
        subscriberId.reference,
        startTime,
        endTime,
        uid,
        tag
      ]).object);

  static final _id_queryDetailsForUidTagState = jniAccessors.getMethodIDOf(
      _classRef,
      "queryDetailsForUidTagState",
      "(ILjava/lang/String;JJIII)Landroid/app/usage/NetworkStats;");

  /// from: public android.app.usage.NetworkStats queryDetailsForUidTagState(int networkType, java.lang.String subscriberId, long startTime, long endTime, int uid, int tag, int state)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics details for a given uid, tag, and state. Only usable for uids
  /// belonging to calling user. Result is not aggregated over time. This means buckets' start and
  /// end timestamps are going to be between 'startTime' and 'endTime' parameters. The uid is going
  /// to be the same as the 'uid' parameter, the tag the same as the 'tag' parameter, and the state
  /// the same as the 'state' parameter.
  /// defaultNetwork is going to be NetworkStats.Bucket\#DEFAULT_NETWORK_ALL,
  /// metered is going to be NetworkStats.Bucket\#METERED_ALL, and
  /// roaming is going to be NetworkStats.Bucket\#ROAMING_ALL.
  /// Only includes buckets that atomically occur in the inclusive time range. Doesn't
  /// interpolate across partial buckets. Since bucket length is in the order of hours, this
  /// method cannot be used to measure data usage on a fine grained time scale.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param uid UID of app
  ///@param tag TAG of interest. Use NetworkStats.Bucket\#TAG_NONE for no tags.
  ///@param state state of interest. Use NetworkStats.Bucket\#STATE_ALL to aggregate
  ///            traffic from all states.
  ///@return Statistics object or null if an error happened during statistics collection.
  ///@throws SecurityException if permissions are insufficient to read network statistics.
  networkstats_.NetworkStats queryDetailsForUidTagState(
          int networkType,
          jni.JniString subscriberId,
          int startTime,
          int endTime,
          int uid,
          int tag,
          int state) =>
      networkstats_.NetworkStats.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_queryDetailsForUidTagState, jni.JniType.objectType, [
        networkType,
        subscriberId.reference,
        startTime,
        endTime,
        uid,
        tag,
        state
      ]).object);

  static final _id_queryDetails = jniAccessors.getMethodIDOf(
      _classRef,
      "queryDetails",
      "(ILjava/lang/String;JJ)Landroid/app/usage/NetworkStats;");

  /// from: public android.app.usage.NetworkStats queryDetails(int networkType, java.lang.String subscriberId, long startTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics details. Result filtered to include only uids belonging to
  /// calling user. Result is aggregated over state but not aggregated over time, uid, tag,
  /// metered, nor roaming. This means buckets' start and end timestamps are going to be between
  /// 'startTime' and 'endTime' parameters. State is going to be
  /// NetworkStats.Bucket\#STATE_ALL, uid will vary,
  /// tag NetworkStats.Bucket\#TAG_NONE,
  /// default network is going to be NetworkStats.Bucket\#DEFAULT_NETWORK_ALL,
  /// metered is going to be NetworkStats.Bucket\#METERED_ALL,
  /// and roaming is going to be NetworkStats.Bucket\#ROAMING_ALL.
  /// Only includes buckets that atomically occur in the inclusive time range. Doesn't
  /// interpolate across partial buckets. Since bucket length is in the order of hours, this
  /// method cannot be used to measure data usage on a fine grained time scale.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@return Statistics object or null if permissions are insufficient or error happened during
  ///         statistics collection.
  networkstats_.NetworkStats queryDetails(int networkType,
          jni.JniString subscriberId, int startTime, int endTime) =>
      networkstats_.NetworkStats.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryDetails,
          jni.JniType.objectType,
          [networkType, subscriberId.reference, startTime, endTime]).object);

  static final _id_registerUsageCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerUsageCallback",
      "(ILjava/lang/String;JLandroid/app/usage/NetworkStatsManager\$UsageCallback;)V");

  /// from: public void registerUsageCallback(int networkType, java.lang.String subscriberId, long thresholdBytes, android.app.usage.NetworkStatsManager.UsageCallback callback)
  ///
  /// Registers to receive notifications about data usage on specified networks.
  ///
  /// \#see registerUsageCallback(int, String[], long, UsageCallback, Handler)
  void registerUsageCallback(int networkType, jni.JniString subscriberId,
          int thresholdBytes, NetworkStatsManager_UsageCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_registerUsageCallback, jni.JniType.voidType, [
        networkType,
        subscriberId.reference,
        thresholdBytes,
        callback.reference
      ]).check();

  static final _id_registerUsageCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerUsageCallback",
      "(ILjava/lang/String;JLandroid/app/usage/NetworkStatsManager\$UsageCallback;Landroid/os/Handler;)V");

  /// from: public void registerUsageCallback(int networkType, java.lang.String subscriberId, long thresholdBytes, android.app.usage.NetworkStatsManager.UsageCallback callback, android.os.Handler handler)
  ///
  /// Registers to receive notifications about data usage on specified networks.
  ///
  /// The callbacks will continue to be called as long as the process is live or
  /// \#unregisterUsageCallback is called.
  ///@param networkType Type of network to monitor. Either
  ///             ConnectivityManager\#TYPE_MOBILE or ConnectivityManager\#TYPE_WIFI.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param thresholdBytes Threshold in bytes to be notified on.
  ///@param callback The UsageCallback that the system will call when data usage
  ///            has exceeded the specified threshold.
  ///@param handler to dispatch callback events through, otherwise if {@code null} it uses
  ///            the calling thread.
  ///
  /// This value may be {@code null}.
  void registerUsageCallback1(
          int networkType,
          jni.JniString subscriberId,
          int thresholdBytes,
          NetworkStatsManager_UsageCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_registerUsageCallback1, jni.JniType.voidType, [
        networkType,
        subscriberId.reference,
        thresholdBytes,
        callback.reference,
        handler.reference
      ]).check();

  static final _id_unregisterUsageCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterUsageCallback",
      "(Landroid/app/usage/NetworkStatsManager\$UsageCallback;)V");

  /// from: public void unregisterUsageCallback(android.app.usage.NetworkStatsManager.UsageCallback callback)
  ///
  /// Unregisters callbacks on data usage.
  ///@param callback The UsageCallback used when registering.
  void unregisterUsageCallback(NetworkStatsManager_UsageCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterUsageCallback,
          jni.JniType.voidType, [callback.reference]).check();
}

/// from: android.app.usage.NetworkStatsManager$UsageCallback
///
/// Base class for usage callbacks. Should be extended by applications wanting notifications.
class NetworkStatsManager_UsageCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/usage/NetworkStatsManager\$UsageCallback");
  NetworkStatsManager_UsageCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  NetworkStatsManager_UsageCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onThresholdReached = jniAccessors.getMethodIDOf(
      _classRef, "onThresholdReached", "(ILjava/lang/String;)V");

  /// from: public abstract void onThresholdReached(int networkType, java.lang.String subscriberId)
  ///
  /// Called when data usage has reached the given threshold.
  void onThresholdReached(int networkType, jni.JniString subscriberId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onThresholdReached,
          jni.JniType.voidType, [networkType, subscriberId.reference]).check();
}
