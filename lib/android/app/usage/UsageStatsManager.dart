// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "UsageEvents.dart" as usageevents_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.usage.UsageStatsManager
///
/// Provides access to device usage history and statistics. Usage data is aggregated into
/// time intervals: days, weeks, months, and years.
/// <p/>
/// When requesting usage data since a particular time, the request might look something like this:
/// <pre>
/// PAST                   REQUEST_TIME                    TODAY                   FUTURE
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014¦-----------------------|
///                        YEAR ||                           ¦                       |
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014¦-----------------------|
///  MONTH            |         ||                MONTH      ¦                       |
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014|\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014¦-----------------------|
///   |      WEEK     |     WEEK||    |     WEEK     |     WE¦EK     |      WEEK     |
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014|\u2014\u2014\u2014\u2014\u2014\u2014\u2014¦-----------------------|
///                             ||           |DAY|DAY|DAY|DAY¦DAY|DAY|DAY|DAY|DAY|DAY|
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014¦-----------------------|
/// </pre>
/// A request for data in the middle of a time interval will include that interval.
/// <p/>
/// __NOTE:__ Most methods on this API require the permission
/// android.permission.PACKAGE_USAGE_STATS. However, declaring the permission implies intention to
/// use the API and the user of the device still needs to grant permission through the Settings
/// application.
/// See android.provider.Settings\#ACTION_USAGE_ACCESS_SETTINGS.
/// Methods which only return the information for the calling package do not require this permission.
/// E.g. \#getAppStandbyBucket() and \#queryEventsForSelf(long, long).
class UsageStatsManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/usage/UsageStatsManager");
  UsageStatsManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int INTERVAL_BEST
  ///
  /// An interval type that will use the best fit interval for the given time range.
  /// See \#queryUsageStats(int, long, long).
  static const INTERVAL_BEST = 4;

  /// from: static public final int INTERVAL_DAILY
  ///
  /// An interval type that spans a day. See \#queryUsageStats(int, long, long).
  static const INTERVAL_DAILY = 0;

  /// from: static public final int INTERVAL_MONTHLY
  ///
  /// An interval type that spans a month. See \#queryUsageStats(int, long, long).
  static const INTERVAL_MONTHLY = 2;

  /// from: static public final int INTERVAL_WEEKLY
  ///
  /// An interval type that spans a week. See \#queryUsageStats(int, long, long).
  static const INTERVAL_WEEKLY = 1;

  /// from: static public final int INTERVAL_YEARLY
  ///
  /// An interval type that spans a year. See \#queryUsageStats(int, long, long).
  static const INTERVAL_YEARLY = 3;

  /// from: static public final int STANDBY_BUCKET_ACTIVE
  ///
  /// The app was used very recently, currently in use or likely to be used very soon. Standby
  /// bucket values that are &le; \#STANDBY_BUCKET_ACTIVE will not be throttled by the
  /// system while they are in this bucket. Buckets &gt; \#STANDBY_BUCKET_ACTIVE will most
  /// likely be restricted in some way. For instance, jobs and alarms may be deferred.
  ///@see \#getAppStandbyBucket()
  static const STANDBY_BUCKET_ACTIVE = 10;

  /// from: static public final int STANDBY_BUCKET_FREQUENT
  ///
  /// The app was used in the last few days and/or likely to be used in the next few days.
  /// Restrictions will apply to these apps, such as deferral of jobs and alarms. The delays may be
  /// greater than for apps in higher buckets (lower bucket value). Bucket values &gt;
  /// \#STANDBY_BUCKET_FREQUENT may additionally have network access limited.
  ///@see \#getAppStandbyBucket()
  static const STANDBY_BUCKET_FREQUENT = 30;

  /// from: static public final int STANDBY_BUCKET_RARE
  ///
  /// The app has not be used for several days and/or is unlikely to be used for several days.
  /// Apps in this bucket will have the most restrictions, including network restrictions, except
  /// during certain short periods (at a minimum, once a day) when they are allowed to execute
  /// jobs, access the network, etc.
  ///@see \#getAppStandbyBucket()
  static const STANDBY_BUCKET_RARE = 40;

  /// from: static public final int STANDBY_BUCKET_WORKING_SET
  ///
  /// The app was used recently and/or likely to be used in the next few hours. Restrictions will
  /// apply to these apps, such as deferral of jobs and alarms.
  ///@see \#getAppStandbyBucket()
  static const STANDBY_BUCKET_WORKING_SET = 20;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UsageStatsManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_queryUsageStats = jniAccessors.getMethodIDOf(
      _classRef, "queryUsageStats", "(IJJ)Ljava/util/List;");

  /// from: public java.util.List<android.app.usage.UsageStats> queryUsageStats(int intervalType, long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets application usage stats for the given time range, aggregated by the specified interval.
  /// The returned list will contain a UsageStats object for each package that
  /// has data for an interval that is a subset of the time range given. To illustrate:
  ///
  /// <pre>
  /// intervalType = INTERVAL_YEARLY
  /// beginTime = 2013
  /// endTime = 2015 (exclusive)
  ///
  /// Results:
  /// 2013 - com.example.alpha
  /// 2013 - com.example.beta
  /// 2014 - com.example.alpha
  /// 2014 - com.example.beta
  /// 2014 - com.example.charlie
  /// </pre>
  ///
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param intervalType The time interval by which the stats are aggregated.
  ///@param beginTime The inclusive beginning of the range of stats to include in the results.
  ///@param endTime The exclusive end of the range of stats to include in the results.
  ///@return A list of UsageStats
  ///@see \#INTERVAL_DAILY
  ///@see \#INTERVAL_WEEKLY
  ///@see \#INTERVAL_MONTHLY
  ///@see \#INTERVAL_YEARLY
  ///@see \#INTERVAL_BEST
  jni.JniObject queryUsageStats(int intervalType, int beginTime, int endTime) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryUsageStats,
          jni.JniType.objectType,
          [intervalType, beginTime, endTime]).object);

  static final _id_queryConfigurations = jniAccessors.getMethodIDOf(
      _classRef, "queryConfigurations", "(IJJ)Ljava/util/List;");

  /// from: public java.util.List<android.app.usage.ConfigurationStats> queryConfigurations(int intervalType, long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the hardware configurations the device was in for the given time range, aggregated by
  /// the specified interval. The results are ordered as in
  /// \#queryUsageStats(int, long, long).
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param intervalType The time interval by which the stats are aggregated.
  ///@param beginTime The inclusive beginning of the range of stats to include in the results.
  ///@param endTime The exclusive end of the range of stats to include in the results.
  ///@return A list of ConfigurationStats
  jni.JniObject queryConfigurations(
          int intervalType, int beginTime, int endTime) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryConfigurations,
          jni.JniType.objectType,
          [intervalType, beginTime, endTime]).object);

  static final _id_queryEventStats = jniAccessors.getMethodIDOf(
      _classRef, "queryEventStats", "(IJJ)Ljava/util/List;");

  /// from: public java.util.List<android.app.usage.EventStats> queryEventStats(int intervalType, long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets aggregated event stats for the given time range, aggregated by the specified interval.
  /// The returned list will contain a EventStats object for each event type that
  /// is being aggregated and has data for an interval that is a subset of the time range given.
  ///
  /// The current event types that will be aggregated here are:
  ///
  /// <ul>
  ///     <li>UsageEvents.Event\#SCREEN_INTERACTIVE</li>
  ///     <li>UsageEvents.Event\#SCREEN_NON_INTERACTIVE</li>
  ///     <li>UsageEvents.Event\#KEYGUARD_SHOWN</li>
  ///     <li>UsageEvents.Event\#KEYGUARD_HIDDEN</li>
  /// </ul>
  ///
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param intervalType The time interval by which the stats are aggregated.
  ///@param beginTime The inclusive beginning of the range of stats to include in the results.
  ///@param endTime The exclusive end of the range of stats to include in the results.
  ///@return A list of EventStats
  ///@see \#INTERVAL_DAILY
  ///@see \#INTERVAL_WEEKLY
  ///@see \#INTERVAL_MONTHLY
  ///@see \#INTERVAL_YEARLY
  ///@see \#INTERVAL_BEST
  jni.JniObject queryEventStats(int intervalType, int beginTime, int endTime) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryEventStats,
          jni.JniType.objectType,
          [intervalType, beginTime, endTime]).object);

  static final _id_queryEvents = jniAccessors.getMethodIDOf(
      _classRef, "queryEvents", "(JJ)Landroid/app/usage/UsageEvents;");

  /// from: public android.app.usage.UsageEvents queryEvents(long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query for events in the given time range. Events are only kept by the system for a few
  /// days.
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param beginTime The inclusive beginning of the range of events to include in the results.
  ///@param endTime The exclusive end of the range of events to include in the results.
  ///@return A UsageEvents.
  usageevents_.UsageEvents queryEvents(int beginTime, int endTime) =>
      usageevents_.UsageEvents.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryEvents,
          jni.JniType.objectType,
          [beginTime, endTime]).object);

  static final _id_queryEventsForSelf = jniAccessors.getMethodIDOf(
      _classRef, "queryEventsForSelf", "(JJ)Landroid/app/usage/UsageEvents;");

  /// from: public android.app.usage.UsageEvents queryEventsForSelf(long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#queryEvents(long, long), but only returns events for the calling package.
  ///@param beginTime The inclusive beginning of the range of events to include in the results.
  ///@param endTime The exclusive end of the range of events to include in the results.
  ///@return A UsageEvents object.
  ///@see \#queryEvents(long, long)
  usageevents_.UsageEvents queryEventsForSelf(int beginTime, int endTime) =>
      usageevents_.UsageEvents.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryEventsForSelf,
          jni.JniType.objectType,
          [beginTime, endTime]).object);

  static final _id_queryAndAggregateUsageStats = jniAccessors.getMethodIDOf(
      _classRef, "queryAndAggregateUsageStats", "(JJ)Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,android.app.usage.UsageStats> queryAndAggregateUsageStats(long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience method that queries for all stats in the given range (using the best interval
  /// for that range), merges the resulting data, and keys it by package name.
  /// See \#queryUsageStats(int, long, long).
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param beginTime The inclusive beginning of the range of stats to include in the results.
  ///@param endTime The exclusive end of the range of stats to include in the results.
  ///@return A java.util.Map keyed by package name
  jni.JniObject queryAndAggregateUsageStats(int beginTime, int endTime) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryAndAggregateUsageStats,
          jni.JniType.objectType,
          [beginTime, endTime]).object);

  static final _id_isAppInactive = jniAccessors.getMethodIDOf(
      _classRef, "isAppInactive", "(Ljava/lang/String;)Z");

  /// from: public boolean isAppInactive(java.lang.String packageName)
  ///
  /// Returns whether the specified app is currently considered inactive. This will be true if the
  /// app hasn't been used directly or indirectly for a period of time defined by the system. This
  /// could be of the order of several hours or days.
  ///@param packageName The package name of the app to query
  ///@return whether the app is currently considered inactive
  bool isAppInactive(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_isAppInactive,
          jni.JniType.booleanType, [packageName.reference]).boolean;

  static final _id_getAppStandbyBucket =
      jniAccessors.getMethodIDOf(_classRef, "getAppStandbyBucket", "()I");

  /// from: public int getAppStandbyBucket()
  ///
  /// Returns the current standby bucket of the calling app. The system determines the standby
  /// state of the app based on app usage patterns. Standby buckets determine how much an app will
  /// be restricted from running background tasks such as jobs and alarms.
  /// Restrictions increase progressively from \#STANDBY_BUCKET_ACTIVE to
  /// \#STANDBY_BUCKET_RARE, with \#STANDBY_BUCKET_ACTIVE being the least
  /// restrictive. The battery level of the device might also affect the restrictions.
  /// Apps in buckets &le; \#STANDBY_BUCKET_ACTIVE have no standby restrictions imposed.
  /// Apps in buckets &gt; \#STANDBY_BUCKET_FREQUENT may have network access restricted when
  /// running in the background.
  /// The standby state of an app can change at any time either due to a user interaction or a
  /// system interaction or some algorithm determining that the app can be restricted for a period
  /// of time before the user has a need for it.
  /// You can also query the recent history of standby bucket changes by calling
  /// \#queryEventsForSelf(long, long) and searching for
  /// UsageEvents.Event\#STANDBY_BUCKET_CHANGED.
  ///@return the current standby bucket of the calling app. One of STANDBY_BUCKET_* constants.
  ///
  /// Value is android.app.usage.UsageStatsManager.STANDBY_BUCKET_EXEMPTED, android.app.usage.UsageStatsManager\#STANDBY_BUCKET_ACTIVE, android.app.usage.UsageStatsManager\#STANDBY_BUCKET_WORKING_SET, android.app.usage.UsageStatsManager\#STANDBY_BUCKET_FREQUENT, android.app.usage.UsageStatsManager\#STANDBY_BUCKET_RARE, or android.app.usage.UsageStatsManager.STANDBY_BUCKET_NEVER
  int getAppStandbyBucket() => jniAccessors.callMethodWithArgs(
      reference, _id_getAppStandbyBucket, jni.JniType.intType, []).integer;
}
