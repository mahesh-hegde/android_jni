// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/ContextThemeWrapper.dart" as contextthemewrapper_;

import "../content/Intent.dart" as intent_;

import "Application.dart" as application_;

import "../view/WindowManager.dart" as windowmanager_;

import "../view/Window.dart" as window_;

import "LoaderManager.dart" as loadermanager_;

import "../view/View.dart" as view_;

import "../content/Context.dart" as context_;

import "../os/Bundle.dart" as bundle_;

import "../os/PersistableBundle.dart" as persistablebundle_;

import "VoiceInteractor.dart" as voiceinteractor_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../graphics/Canvas.dart" as canvas_;

import "assist/AssistContent.dart" as assistcontent_;

import "../view/Menu.dart" as menu_;

import "../content/res/Configuration.dart" as configuration_;

import "PictureInPictureParams.dart" as pictureinpictureparams_;

import "FragmentManager.dart" as fragmentmanager_;

import "Fragment.dart" as fragment_;

import "../database/Cursor.dart" as cursor_;

import "../net/Uri.dart" as uri_;

import "ActionBar.dart" as actionbar_;

import "../widget/Toolbar.dart" as toolbar_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../transition/TransitionManager.dart" as transitionmanager_;

import "../transition/Scene.dart" as scene_;

import "../view/KeyEvent.dart" as keyevent_;

import "../view/MotionEvent.dart" as motionevent_;

import "../view/accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "../view/MenuItem.dart" as menuitem_;

import "TaskStackBuilder.dart" as taskstackbuilder_;

import "../view/ContextMenu.dart" as contextmenu_;

import "Dialog.dart" as dialog_;

import "../view/SearchEvent.dart" as searchevent_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../view/LayoutInflater.dart" as layoutinflater_;

import "../view/MenuInflater.dart" as menuinflater_;

import "../content/res/Resources.dart" as resources_;

import "../content/IntentSender.dart" as intentsender_;

import "../content/ComponentName.dart" as componentname_;

import "PendingIntent.dart" as pendingintent_;

import "../content/SharedPreferences.dart" as sharedpreferences_;

import "ActivityManager.dart" as activitymanager_;

import "../media/session/MediaController.dart" as mediacontroller_;

import "../util/AttributeSet.dart" as attributeset_;

import "../view/ActionMode.dart" as actionmode_;

import "SharedElementCallback.dart" as sharedelementcallback_;

import "../view/DragAndDropPermissions.dart" as draganddroppermissions_;

import "../view/DragEvent.dart" as dragevent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.Activity
///
/// An activity is a single, focused thing that the user can do.  Almost all
/// activities interact with the user, so the Activity class takes care of
/// creating a window for you in which you can place your UI with
/// \#setContentView.  While activities are often presented to the user
/// as full-screen windows, they can also be used in other ways: as floating
/// windows (via a theme with android.R.attr\#windowIsFloating set)
/// or embedded inside of another activity (using ActivityGroup).
///
/// There are two methods almost all subclasses of Activity will implement:
///
/// <ul>
///     <li> \#onCreate is where you initialize your activity.  Most
///     importantly, here you will usually call \#setContentView(int)
///     with a layout resource defining your UI, and using \#findViewById
///     to retrieve the widgets in that UI that you need to interact with
///     programmatically.
///
///     <li> \#onPause is where you deal with the user leaving your
///     activity.  Most importantly, any changes made by the user should at this
///     point be committed (usually to the
///     android.content.ContentProvider holding the data).
/// </ul>
///
/// To be of use with android.content.Context\#startActivity Context.startActivity(), all
/// activity classes must have a corresponding
/// android.R.styleable\#AndroidManifestActivity &lt;activity&gt;
/// declaration in their package's <code>AndroidManifest.xml</code>.
///
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#Fragments">Fragments</a>
/// <li><a href="\#ActivityLifecycle">Activity Lifecycle</a>
/// <li><a href="\#ConfigurationChanges">Configuration Changes</a>
/// <li><a href="\#StartingActivities">Starting Activities and Getting Results</a>
/// <li><a href="\#SavingPersistentState">Saving Persistent State</a>
/// <li><a href="\#Permissions">Permissions</a>
/// <li><a href="\#ProcessLifecycle">Process Lifecycle</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// The Activity class is an important part of an application's overall lifecycle,
/// and the way activities are launched and put together is a fundamental
/// part of the platform's application model. For a detailed perspective on the structure of an
/// Android application and how activities behave, please read the
/// <a href="{@docRoot}guide/topics/fundamentals.html">Application Fundamentals</a> and
/// <a href="{@docRoot}guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a>
/// developer guides.
///
///
/// You can also find a detailed discussion about how to create activities in the
/// <a href="{@docRoot}guide/components/activities.html">Activities</a>
/// developer guide.
///
/// </div>
///
/// <a name="Fragments"></a>
/// <h3>Fragments</h3>
///
/// The android.support.v4.app.FragmentActivity subclass
/// can make use of the android.support.v4.app.Fragment class to better
/// modularize their code, build more sophisticated user interfaces for larger
/// screens, and help scale their application between small and large screens.
///
///
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
///
/// <a name="ActivityLifecycle"></a>
/// <h3>Activity Lifecycle</h3>
///
/// Activities in the system are managed as an _activity stack_.
/// When a new activity is started, it is placed on the top of the stack
/// and becomes the running activity -- the previous activity always remains
/// below it in the stack, and will not come to the foreground again until
/// the new activity exits.
///
///
/// An activity has essentially four states:
///
/// <ul>
///     <li> If an activity is in the foreground of the screen (at the top of
///         the stack),
///         it is _active_ or  _running_. </li>
///     <li>If an activity has lost focus but is still visible (that is, a new non-full-sized
///         or transparent activity has focus on top of your activity), it
///         is _paused_. A paused activity is completely alive (it
///         maintains all state and member information and remains attached to
///         the window manager), but can be killed by the system in extreme
///         low memory situations.
///     <li>If an activity is completely obscured by another activity,
///         it is _stopped_. It still retains all state and member information,
///         however, it is no longer visible to the user so its window is hidden
///         and it will often be killed by the system when memory is needed
///         elsewhere.</li>
///     <li>If an activity is paused or stopped, the system can drop the activity
///         from memory by either asking it to finish, or simply killing its
///         process.  When it is displayed again to the user, it must be
///         completely restarted and restored to its previous state.</li>
/// </ul>
///
/// The following diagram shows the important state paths of an Activity.
/// The square rectangles represent callback methods you can implement to
/// perform operations when the Activity moves between states.  The colored
/// ovals are major states the Activity can be in.
///
///
/// <img src="../../../images/activity_lifecycle.png"alt="State diagram for an Android Activity Lifecycle."border="0"/>
///
///
/// There are three key loops you may be interested in monitoring within your
/// activity:
///
/// <ul>
/// <li>The __entire lifetime__ of an activity happens between the first call
/// to android.app.Activity\#onCreate through to a single final call
/// to android.app.Activity\#onDestroy.  An activity will do all setup
/// of "global" state in onCreate(), and release all remaining resources in
/// onDestroy().  For example, if it has a thread running in the background
/// to download data from the network, it may create that thread in onCreate()
/// and then stop the thread in onDestroy().
///
/// <li>The __visible lifetime__ of an activity happens between a call to
/// android.app.Activity\#onStart until a corresponding call to
/// android.app.Activity\#onStop.  During this time the user can see the
/// activity on-screen, though it may not be in the foreground and interacting
/// with the user.  Between these two methods you can maintain resources that
/// are needed to show the activity to the user.  For example, you can register
/// a android.content.BroadcastReceiver in onStart() to monitor for changes
/// that impact your UI, and unregister it in onStop() when the user no
/// longer sees what you are displaying.  The onStart() and onStop() methods
/// can be called multiple times, as the activity becomes visible and hidden
/// to the user.
///
/// <li>The __foreground lifetime__ of an activity happens between a call to
/// android.app.Activity\#onResume until a corresponding call to
/// android.app.Activity\#onPause.  During this time the activity is
/// in front of all other activities and interacting with the user.  An activity
/// can frequently go between the resumed and paused states -- for example when
/// the device goes to sleep, when an activity result is delivered, when a new
/// intent is delivered -- so the code in these methods should be fairly
/// lightweight.
/// </ul>
///
/// The entire lifecycle of an activity is defined by the following
/// Activity methods.  All of these are hooks that you can override
/// to do appropriate work when the activity changes state.  All
/// activities will implement android.app.Activity\#onCreate
/// to do their initial setup; many will also implement
/// android.app.Activity\#onPause to commit changes to data and
/// otherwise prepare to stop interacting with the user.  You should always
/// call up to your superclass when implementing these methods.
///
///
///
///
/// <pre class="prettyprint">
/// public class Activity extends ApplicationContext {
///     protected void onCreate(Bundle savedInstanceState);
///
///     protected void onStart();
///
///     protected void onRestart();
///
///     protected void onResume();
///
///     protected void onPause();
///
///     protected void onStop();
///
///     protected void onDestroy();
/// }
/// </pre>
///
/// In general the movement through an activity's lifecycle looks like
/// this:
///
///
/// <table border="2"width="85%"align="center"frame="hsides"rules="rows">
///     <colgroup align="left"span="3"/>
///     <colgroup align="left"/>
///     <colgroup align="center"/>
///     <colgroup align="center"/>
///
///     <thead>
///     <tr><th colspan="3">Method</th> <th>Description</th> <th>Killable?</th> <th>Next</th></tr>
///     </thead>
///
///     <tbody>
///     <tr><td colspan="3"align="left"border="0">android.app.Activity\#onCreate onCreate()</td>
///         <td>Called when the activity is first created.
///             This is where you should do all of your normal static set up:
///             create views, bind data to lists, etc.  This method also
///             provides you with a Bundle containing the activity's previously
///             frozen state, if there was one.
///             Always followed by <code>onStart()</code>.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onStart()</code></td>
///     </tr>
///
///     <tr><td rowspan="5"style="border-left: none; border-right: none;">&nbsp;&nbsp;&nbsp;&nbsp;</td>
///         <td colspan="2"align="left"border="0">android.app.Activity\#onRestart onRestart()</td>
///         <td>Called after your activity has been stopped, prior to it being
///             started again.
///             Always followed by <code>onStart()</code></td>
///         <td align="center">No</td>
///         <td align="center"><code>onStart()</code></td>
///     </tr>
///
///     <tr><td colspan="2"align="left"border="0">android.app.Activity\#onStart onStart()</td>
///         <td>Called when the activity is becoming visible to the user.
///             Followed by <code>onResume()</code> if the activity comes
///             to the foreground, or <code>onStop()</code> if it becomes hidden.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onResume()</code> or <code>onStop()</code></td>
///     </tr>
///
///     <tr><td rowspan="2"style="border-left: none;">&nbsp;&nbsp;&nbsp;&nbsp;</td>
///         <td align="left"border="0">android.app.Activity\#onResume onResume()</td>
///         <td>Called when the activity will start
///             interacting with the user.  At this point your activity is at
///             the top of the activity stack, with user input going to it.
///             Always followed by <code>onPause()</code>.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onPause()</code></td>
///     </tr>
///
///     <tr><td align="left"border="0">android.app.Activity\#onPause onPause()</td>
///         <td>Called when the system is about to start resuming a previous
///             activity.  This is typically used to commit unsaved changes to
///             persistent data, stop animations and other things that may be consuming
///             CPU, etc.  Implementations of this method must be very quick because
///             the next activity will not be resumed until this method returns.
///             Followed by either <code>onResume()</code> if the activity
///             returns back to the front, or <code>onStop()</code> if it becomes
///             invisible to the user.</td>
///         <td align="center"><font color="\#800000"><strong>Pre-android.os.Build.VERSION_CODES\#HONEYCOMB</strong></font></td>
///         <td align="center"><code>onResume()</code> or<br>
///                 <code>onStop()</code></td>
///     </tr>
///
///     <tr><td colspan="2"align="left"border="0">android.app.Activity\#onStop onStop()</td>
///         <td>Called when the activity is no longer visible to the user, because
///             another activity has been resumed and is covering this one.  This
///             may happen either because a new activity is being started, an existing
///             one is being brought in front of this one, or this one is being
///             destroyed.
///             Followed by either <code>onRestart()</code> if
///             this activity is coming back to interact with the user, or
///             <code>onDestroy()</code> if this activity is going away.</td>
///         <td align="center"><font color="\#800000"><strong>Yes</strong></font></td>
///         <td align="center"><code>onRestart()</code> or<br>
///                 <code>onDestroy()</code></td>
///     </tr>
///
///     <tr><td colspan="3"align="left"border="0">android.app.Activity\#onDestroy onDestroy()</td>
///         <td>The final call you receive before your
///             activity is destroyed.  This can happen either because the
///             activity is finishing (someone called Activity\#finish on
///             it, or because the system is temporarily destroying this
///             instance of the activity to save space.  You can distinguish
///             between these two scenarios with the Activity\#isFinishing method.</td>
///         <td align="center"><font color="\#800000"><strong>Yes</strong></font></td>
///         <td align="center">_nothing_</td>
///     </tr>
///     </tbody>
/// </table>
///
/// Note the "Killable" column in the above table -- for those methods that
/// are marked as being killable, after that method returns the process hosting the
/// activity may be killed by the system _at any time_ without another line
/// of its code being executed.  Because of this, you should use the
/// \#onPause method to write any persistent data (such as user edits)
/// to storage.  In addition, the method
/// \#onSaveInstanceState(Bundle) is called before placing the activity
/// in such a background state, allowing you to save away any dynamic instance
/// state in your activity into the given Bundle, to be later received in
/// \#onCreate if the activity needs to be re-created.
/// See the <a href="\#ProcessLifecycle">Process Lifecycle</a>
/// section for more information on how the lifecycle of a process is tied
/// to the activities it is hosting.  Note that it is important to save
/// persistent data in \#onPause instead of \#onSaveInstanceState
/// because the latter is not part of the lifecycle callbacks, so will not
/// be called in every situation as described in its documentation.
///
///
/// <p class="note">Be aware that these semantics will change slightly between
/// applications targeting platforms starting with android.os.Build.VERSION_CODES\#HONEYCOMB
/// vs. those targeting prior platforms.  Starting with Honeycomb, an application
/// is not in the killable state until its \#onStop has returned.  This
/// impacts when \#onSaveInstanceState(Bundle) may be called (it may be
/// safely called after \#onPause()) and allows an application to safely
/// wait until \#onStop() to save persistent state.
///
///
/// <p class="note">For applications targeting platforms starting with
/// android.os.Build.VERSION_CODES\#P \#onSaveInstanceState(Bundle)
/// will always be called after \#onStop, so an application may safely
/// perform fragment transactions in \#onStop and will be able to save
/// persistent state later.
///
///
/// For those methods that are not marked as being killable, the activity's
/// process will not be killed by the system starting from the time the method
/// is called and continuing after it returns.  Thus an activity is in the killable
/// state, for example, between after <code>onPause()</code> to the start of
/// <code>onResume()</code>.
///
///
/// <a name="ConfigurationChanges"></a>
/// <h3>Configuration Changes</h3>
///
/// If the configuration of the device (as defined by the
/// Configuration Resources.Configuration class) changes,
/// then anything displaying a user interface will need to update to match that
/// configuration.  Because Activity is the primary mechanism for interacting
/// with the user, it includes special support for handling configuration
/// changes.
///
///
/// Unless you specify otherwise, a configuration change (such as a change
/// in screen orientation, language, input devices, etc) will cause your
/// current activity to be _destroyed_, going through the normal activity
/// lifecycle process of \#onPause,
/// \#onStop, and \#onDestroy as appropriate.  If the activity
/// had been in the foreground or visible to the user, once \#onDestroy is
/// called in that instance then a new instance of the activity will be
/// created, with whatever savedInstanceState the previous instance had generated
/// from \#onSaveInstanceState.
///
///
/// This is done because any application resource,
/// including layout files, can change based on any configuration value.  Thus
/// the only safe way to handle a configuration change is to re-retrieve all
/// resources, including layouts, drawables, and strings.  Because activities
/// must already know how to save their state and re-create themselves from
/// that state, this is a convenient way to have an activity restart itself
/// with a new configuration.
///
///
/// In some special cases, you may want to bypass restarting of your
/// activity based on one or more types of configuration changes.  This is
/// done with the android.R.attr\#configChanges android:configChanges
/// attribute in its manifest.  For any types of configuration changes you say
/// that you handle there, you will receive a call to your current activity's
/// \#onConfigurationChanged method instead of being restarted.  If
/// a configuration change involves any that you do not handle, however, the
/// activity will still be restarted and \#onConfigurationChanged
/// will not be called.
///
///
/// <a name="StartingActivities"></a>
/// <h3>Starting Activities and Getting Results</h3>
///
/// The android.app.Activity\#startActivity
/// method is used to start a
/// new activity, which will be placed at the top of the activity stack.  It
/// takes a single argument, an android.content.Intent Intent,
/// which describes the activity
/// to be executed.
///
///
/// Sometimes you want to get a result back from an activity when it
/// ends.  For example, you may start an activity that lets the user pick
/// a person in a list of contacts; when it ends, it returns the person
/// that was selected.  To do this, you call the
/// android.app.Activity\#startActivityForResult(Intent, int)
/// version with a second integer parameter identifying the call.  The result
/// will come back through your android.app.Activity\#onActivityResult
/// method.
///
///
/// When an activity exits, it can call
/// android.app.Activity\#setResult(int)
/// to return data back to its parent.  It must always supply a result code,
/// which can be the standard results RESULT_CANCELED, RESULT_OK, or any
/// custom values starting at RESULT_FIRST_USER.  In addition, it can optionally
/// return back an Intent containing any additional data it wants.  All of this
/// information appears back on the
/// parent's <code>Activity.onActivityResult()</code>, along with the integer
/// identifier it originally supplied.
///
///
/// If a child activity fails for any reason (such as crashing), the parent
/// activity will receive a result with the code RESULT_CANCELED.
///
///
/// <pre class="prettyprint">
/// public class MyActivity extends Activity {
///     ...
///
///     static final int PICK_CONTACT_REQUEST = 0;
///
///     public boolean onKeyDown(int keyCode, KeyEvent event) {
///         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
///             // When the user center presses, let them pick a contact.
///             startActivityForResult(
///                 new Intent(Intent.ACTION_PICK,
///                 new Uri("content://contacts")),
///                 PICK_CONTACT_REQUEST);
///            return true;
///         }
///         return false;
///     }
///
///     protected void onActivityResult(int requestCode, int resultCode,
///             Intent data) {
///         if (requestCode == PICK_CONTACT_REQUEST) {
///             if (resultCode == RESULT_OK) {
///                 // A contact was picked.  Here we will just display it
///                 // to the user.
///                 startActivity(new Intent(Intent.ACTION_VIEW, data));
///             }
///         }
///     }
/// }
/// </pre>
///
/// <a name="SavingPersistentState"></a>
/// <h3>Saving Persistent State</h3>
///
/// There are generally two kinds of persistent state than an activity
/// will deal with: shared document-like data (typically stored in a SQLite
/// database using a {@linkplain android.content.ContentProvider content provider})
/// and internal state such as user preferences.
///
///
/// For content provider data, we suggest that activities use a
/// "edit in place" user model.  That is, any edits a user makes are effectively
/// made immediately without requiring an additional confirmation step.
/// Supporting this model is generally a simple matter of following two rules:
///
///
/// <ul>
///     <li> When creating a new document, the backing database entry or file for
///             it is created immediately.  For example, if the user chooses to write
///             a new email, a new entry for that email is created as soon as they
///             start entering data, so that if they go to any other activity after
///             that point this email will now appear in the list of drafts.
///
///     <li> When an activity's <code>onPause()</code> method is called, it should
///             commit to the backing content provider or file any changes the user
///             has made.  This ensures that those changes will be seen by any other
///             activity that is about to run.  You will probably want to commit
///             your data even more aggressively at key times during your
///             activity's lifecycle: for example before starting a new
///             activity, before finishing your own activity, when the user
///             switches between input fields, etc.
///
/// </ul>
///
/// This model is designed to prevent data loss when a user is navigating
/// between activities, and allows the system to safely kill an activity (because
/// system resources are needed somewhere else) at any time after it has been
/// paused.  Note this implies
/// that the user pressing BACK from your activity does _not_
/// mean "cancel" -- it means to leave the activity with its current contents
/// saved away.  Canceling edits in an activity must be provided through
/// some other mechanism, such as an explicit "revert" or "undo" option.
///
///
/// See the {@linkplain android.content.ContentProvider content package} for
/// more information about content providers.  These are a key aspect of how
/// different activities invoke and propagate data between themselves.
///
///
/// The Activity class also provides an API for managing internal persistent state
/// associated with an activity.  This can be used, for example, to remember
/// the user's preferred initial display in a calendar (day view or week view)
/// or the user's default home page in a web browser.
///
///
/// Activity persistent state is managed
/// with the method \#getPreferences,
/// allowing you to retrieve and
/// modify a set of name/value pairs associated with the activity.  To use
/// preferences that are shared across multiple application components
/// (activities, receivers, services, providers), you can use the underlying
/// Context\#getSharedPreferences Context.getSharedPreferences() method
/// to retrieve a preferences
/// object stored under a specific name.
/// (Note that it is not possible to share settings data across application
/// packages -- for that you will need a content provider.)
///
///
/// Here is an excerpt from a calendar activity that stores the user's
/// preferred view mode in its persistent settings:
///
///
/// <pre class="prettyprint">
/// public class CalendarActivity extends Activity {
///     ...
///
///     static final int DAY_VIEW_MODE = 0;
///     static final int WEEK_VIEW_MODE = 1;
///
///     private SharedPreferences mPrefs;
///     private int mCurViewMode;
///
///     protected void onCreate(Bundle savedInstanceState) {
///         super.onCreate(savedInstanceState);
///
///         SharedPreferences mPrefs = getSharedPreferences();
///         mCurViewMode = mPrefs.getInt("view_mode", DAY_VIEW_MODE);
///     }
///
///     protected void onPause() {
///         super.onPause();
///
///         SharedPreferences.Editor ed = mPrefs.edit();
///         ed.putInt("view_mode", mCurViewMode);
///         ed.commit();
///     }
/// }
/// </pre>
///
/// <a name="Permissions"></a>
/// <h3>Permissions</h3>
///
/// The ability to start a particular Activity can be enforced when it is
/// declared in its
/// manifest's android.R.styleable\#AndroidManifestActivity &lt;activity&gt;
/// tag.  By doing so, other applications will need to declare a corresponding
/// android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt;
/// element in their own manifest to be able to start that activity.
///
/// When starting an Activity you can set Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION on the Intent.  This will grant the
/// Activity access to the specific URIs in the Intent.  Access will remain
/// until the Activity has finished (it will remain across the hosting
/// process being killed and other temporary destruction).  As of
/// android.os.Build.VERSION_CODES\#GINGERBREAD, if the Activity
/// was already created and a new Intent is being delivered to
/// \#onNewIntent(Intent), any newly granted URI permissions will be added
/// to the existing ones it holds.
///
/// See the <a href="{@docRoot}guide/topics/security/security.html">Security and Permissions</a>
/// document for more information on permissions and security in general.
///
/// <a name="ProcessLifecycle"></a>
/// <h3>Process Lifecycle</h3>
///
/// The Android system attempts to keep an application process around for as
/// long as possible, but eventually will need to remove old processes when
/// memory runs low. As described in <a href="\#ActivityLifecycle">Activity
/// Lifecycle</a>, the decision about which process to remove is intimately
/// tied to the state of the user's interaction with it. In general, there
/// are four states a process can be in based on the activities running in it,
/// listed here in order of importance. The system will kill less important
/// processes (the last ones) before it resorts to killing more important
/// processes (the first ones).
///
/// <ol>
/// <li> The __foreground activity__ (the activity at the top of the screen
/// that the user is currently interacting with) is considered the most important.
/// Its process will only be killed as a last resort, if it uses more memory
/// than is available on the device.  Generally at this point the device has
/// reached a memory paging state, so this is required in order to keep the user
/// interface responsive.
/// <li> A __visible activity__ (an activity that is visible to the user
/// but not in the foreground, such as one sitting behind a foreground dialog)
/// is considered extremely important and will not be killed unless that is
/// required to keep the foreground activity running.
/// <li> A __background activity__ (an activity that is not visible to
/// the user and has been paused) is no longer critical, so the system may
/// safely kill its process to reclaim memory for other foreground or
/// visible processes.  If its process needs to be killed, when the user navigates
/// back to the activity (making it visible on the screen again), its
/// \#onCreate method will be called with the savedInstanceState it had previously
/// supplied in \#onSaveInstanceState so that it can restart itself in the same
/// state as the user last left it.
/// <li> An __empty process__ is one hosting no activities or other
/// application components (such as Service or
/// android.content.BroadcastReceiver classes).  These are killed very
/// quickly by the system as memory becomes low.  For this reason, any
/// background operation you do outside of an activity must be executed in the
/// context of an activity BroadcastReceiver or Service to ensure that the system
/// knows it needs to keep your process around.
/// </ol>
///
/// Sometimes an Activity may need to do a long-running operation that exists
/// independently of the activity lifecycle itself.  An example may be a camera
/// application that allows you to upload a picture to a web site.  The upload
/// may take a long time, and the application should allow the user to leave
/// the application while it is executing.  To accomplish this, your Activity
/// should start a Service in which the upload takes place.  This allows
/// the system to properly prioritize your process (considering it to be more
/// important than other non-visible applications) for the duration of the
/// upload, independent of whether the original activity is paused, stopped,
/// or finished.
class Activity extends contextthemewrapper_.ContextThemeWrapper {
  static final _classRef = jniAccessors.getClassOf("android/app/Activity");
  Activity.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DEFAULT_KEYS_DIALER
  ///
  /// Use with \#setDefaultKeyMode to launch the dialer during default
  /// key handling.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_DIALER = 1;

  /// from: static public final int DEFAULT_KEYS_DISABLE
  ///
  /// Use with \#setDefaultKeyMode to turn off default handling of
  /// keys.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_DISABLE = 0;

  /// from: static public final int DEFAULT_KEYS_SEARCH_GLOBAL
  ///
  /// Use with \#setDefaultKeyMode to specify that unhandled keystrokes
  /// will start a global search (typically web search, but some platforms may define alternate
  /// methods for global search)
  ///
  /// See android.app.SearchManager android.app.SearchManager for more details.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SEARCH_GLOBAL = 4;

  /// from: static public final int DEFAULT_KEYS_SEARCH_LOCAL
  ///
  /// Use with \#setDefaultKeyMode to specify that unhandled keystrokes
  /// will start an application-defined search.  (If the application or activity does not
  /// actually define a search, the the keys will be ignored.)
  ///
  /// See android.app.SearchManager android.app.SearchManager for more details.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SEARCH_LOCAL = 3;

  /// from: static public final int DEFAULT_KEYS_SHORTCUT
  ///
  /// Use with \#setDefaultKeyMode to execute a menu shortcut in
  /// default key handling.
  ///
  /// That is, the user does not need to hold down the menu key to execute menu shortcuts.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SHORTCUT = 2;

  static final _id_FOCUSED_STATE_SET =
      jniAccessors.getStaticFieldIDOf(_classRef, "FOCUSED_STATE_SET", "[I");

  /// from: static protected final int[] FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject get FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_FOCUSED_STATE_SET, jni.JniType.objectType)
          .object);

  /// from: static public final int RESULT_CANCELED
  ///
  /// Standard activity result: operation canceled.
  static const RESULT_CANCELED = 0;

  /// from: static public final int RESULT_FIRST_USER
  ///
  /// Start of user-defined activity results.
  static const RESULT_FIRST_USER = 1;

  /// from: static public final int RESULT_OK
  ///
  /// Standard activity result: operation succeeded.
  static const RESULT_OK = -1;

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Activity.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_getIntent = jniAccessors.getMethodIDOf(
      _classRef, "getIntent", "()Landroid/content/Intent;");

  /// from: public android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the intent that started this activity.
  intent_.Intent getIntent() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIntent, jni.JniType.objectType, []).object);

  static final _id_setIntent = jniAccessors.getMethodIDOf(
      _classRef, "setIntent", "(Landroid/content/Intent;)V");

  /// from: public void setIntent(android.content.Intent newIntent)
  ///
  /// Change the intent returned by \#getIntent.  This holds a
  /// reference to the given intent; it does not copy it.  Often used in
  /// conjunction with \#onNewIntent.
  ///@param newIntent The new Intent object to return from getIntent
  ///@see \#getIntent
  ///@see \#onNewIntent
  void setIntent(intent_.Intent newIntent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIntent,
      jni.JniType.voidType,
      [newIntent.reference]).check();

  static final _id_getApplication = jniAccessors.getMethodIDOf(
      _classRef, "getApplication", "()Landroid/app/Application;");

  /// from: public final android.app.Application getApplication()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the application that owns this activity.
  application_.Application getApplication() =>
      application_.Application.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getApplication, jni.JniType.objectType, []).object);

  static final _id_isChild =
      jniAccessors.getMethodIDOf(_classRef, "isChild", "()Z");

  /// from: public final boolean isChild()
  ///
  /// Is this activity embedded inside of another activity?
  bool isChild() => jniAccessors.callMethodWithArgs(
      reference, _id_isChild, jni.JniType.booleanType, []).boolean;

  static final _id_getParent = jniAccessors.getMethodIDOf(
      _classRef, "getParent", "()Landroid/app/Activity;");

  /// from: public final android.app.Activity getParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the parent activity if this view is an embedded child.
  Activity getParent() => Activity.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getParent, jni.JniType.objectType, []).object);

  static final _id_getWindowManager = jniAccessors.getMethodIDOf(
      _classRef, "getWindowManager", "()Landroid/view/WindowManager;");

  /// from: public android.view.WindowManager getWindowManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the window manager for showing custom windows.
  windowmanager_.WindowManager getWindowManager() =>
      windowmanager_.WindowManager.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindowManager, jni.JniType.objectType, []).object);

  static final _id_getWindow = jniAccessors.getMethodIDOf(
      _classRef, "getWindow", "()Landroid/view/Window;");

  /// from: public android.view.Window getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current android.view.Window for the activity.
  /// This can be used to directly access parts of the Window API that
  /// are not available through Activity/Screen.
  ///@return Window The current window, or null if the activity is not
  ///         visual.
  window_.Window getWindow() =>
      window_.Window.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_getLoaderManager = jniAccessors.getMethodIDOf(
      _classRef, "getLoaderManager", "()Landroid/app/LoaderManager;");

  /// from: public android.app.LoaderManager getLoaderManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the LoaderManager for this activity, creating it if needed.
  ///@deprecated Use android.support.v4.app.FragmentActivity\#getSupportLoaderManager()
  loadermanager_.LoaderManager getLoaderManager() =>
      loadermanager_.LoaderManager.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLoaderManager, jni.JniType.objectType, []).object);

  static final _id_getCurrentFocus = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentFocus", "()Landroid/view/View;");

  /// from: public android.view.View getCurrentFocus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calls android.view.Window\#getCurrentFocus on the
  /// Window of this Activity to return the currently focused view.
  ///@return View The current View with focus or null.
  ///@see \#getWindow
  ///@see android.view.Window\#getCurrentFocus
  view_.View getCurrentFocus() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCurrentFocus, jni.JniType.objectType, []).object);

  static final _id_attachBaseContext = jniAccessors.getMethodIDOf(
      _classRef, "attachBaseContext", "(Landroid/content/Context;)V");

  /// from: protected void attachBaseContext(android.content.Context newBase)
  void attachBaseContext(context_.Context newBase) =>
      jniAccessors.callMethodWithArgs(reference, _id_attachBaseContext,
          jni.JniType.voidType, [newBase.reference]).check();

  static final _id_onCreate = jniAccessors.getMethodIDOf(
      _classRef, "onCreate", "(Landroid/os/Bundle;)V");

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  ///
  /// Called when the activity is starting.  This is where most initialization
  /// should go: calling \#setContentView(int) to inflate the
  /// activity's UI, using \#findViewById to programmatically interact
  /// with widgets in the UI, calling
  /// \#managedQuery(android.net.Uri , String[], String, String[], String) to retrieve
  /// cursors for data being displayed, etc.
  ///
  /// You can call \#finish from within this function, in
  /// which case onDestroy() will be immediately called after \#onCreate without any of the
  /// rest of the activity lifecycle (\#onStart, \#onResume, \#onPause, etc)
  /// executing.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.  __<i>Note: Otherwise it is null.</i>__
  ///
  /// This value may be {@code null}.
  ///@see \#onStart
  ///@see \#onSaveInstanceState
  ///@see \#onRestoreInstanceState
  ///@see \#onPostCreate
  void onCreate(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreate,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onCreate1 = jniAccessors.getMethodIDOf(_classRef, "onCreate",
      "(Landroid/os/Bundle;Landroid/os/PersistableBundle;)V");

  /// from: public void onCreate(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  ///
  /// Same as \#onCreate(android.os.Bundle) but called for those activities created with
  /// the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>.
  ///@param savedInstanceState if the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.
  ///     __<i>Note: Otherwise it is null.</i>__
  /// This value may be {@code null}.
  ///@param persistentState if the activity is being re-initialized after
  ///     previously being shut down or powered off then this Bundle contains the data it most
  ///     recently supplied to outPersistentState in \#onSaveInstanceState.
  ///     __<i>Note: Otherwise it is null.</i>__
  ///
  /// This value may be {@code null}.
  ///@see \#onCreate(android.os.Bundle)
  ///@see \#onStart
  ///@see \#onSaveInstanceState
  ///@see \#onRestoreInstanceState
  ///@see \#onPostCreate
  void onCreate1(bundle_.Bundle savedInstanceState,
          persistablebundle_.PersistableBundle persistentState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreate1,
          jni.JniType.voidType,
          [savedInstanceState.reference, persistentState.reference]).check();

  static final _id_onRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Bundle;)V");

  /// from: protected void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  ///
  /// This method is called after \#onStart when the activity is
  /// being re-initialized from a previously saved state, given here in
  /// <var>savedInstanceState</var>.  Most implementations will simply use \#onCreate
  /// to restore their state, but it is sometimes convenient to do it here
  /// after all of the initialization has been done or to allow subclasses to
  /// decide whether to use your default implementation.  The default
  /// implementation of this method performs a restore of any view state that
  /// had previously been frozen by \#onSaveInstanceState.
  ///
  /// This method is called between \#onStart and
  /// \#onPostCreate.
  ///@param savedInstanceState the data most recently supplied in \#onSaveInstanceState.
  ///@see \#onCreate
  ///@see \#onPostCreate
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  void onRestoreInstanceState(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onRestoreInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onRestoreInstanceState",
      "(Landroid/os/Bundle;Landroid/os/PersistableBundle;)V");

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  ///
  /// This is the same as \#onRestoreInstanceState(Bundle) but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>. The android.os.PersistableBundle passed
  /// came from the restored PersistableBundle first
  /// saved in \#onSaveInstanceState(Bundle, PersistableBundle).
  ///
  /// This method is called between \#onStart and
  /// \#onPostCreate.
  ///
  /// If this method is called \#onRestoreInstanceState(Bundle) will not be called.
  ///@param savedInstanceState the data most recently supplied in \#onSaveInstanceState.
  ///@param persistentState the data most recently supplied in \#onSaveInstanceState.
  ///@see \#onRestoreInstanceState(Bundle)
  ///@see \#onCreate
  ///@see \#onPostCreate
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  void onRestoreInstanceState1(bundle_.Bundle savedInstanceState,
          persistablebundle_.PersistableBundle persistentState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRestoreInstanceState1,
          jni.JniType.voidType,
          [savedInstanceState.reference, persistentState.reference]).check();

  static final _id_onPostCreate = jniAccessors.getMethodIDOf(
      _classRef, "onPostCreate", "(Landroid/os/Bundle;)V");

  /// from: protected void onPostCreate(android.os.Bundle savedInstanceState)
  ///
  /// Called when activity start-up is complete (after \#onStart
  /// and \#onRestoreInstanceState have been called).  Applications will
  /// generally not implement this method; it is intended for system
  /// classes to do final initialization after application code has run.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.  __<i>Note: Otherwise it is null.</i>__
  /// This value may be {@code null}.
  ///@see \#onCreate
  void onPostCreate(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPostCreate,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onPostCreate1 = jniAccessors.getMethodIDOf(_classRef,
      "onPostCreate", "(Landroid/os/Bundle;Landroid/os/PersistableBundle;)V");

  /// from: public void onPostCreate(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  ///
  /// This is the same as \#onPostCreate(Bundle) but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>.
  ///@param savedInstanceState The data most recently supplied in \#onSaveInstanceState
  /// This value may be {@code null}.
  ///@param persistentState The data caming from the PersistableBundle first
  /// saved in \#onSaveInstanceState(Bundle, PersistableBundle).
  ///
  /// This value may be {@code null}.
  ///@see \#onCreate
  void onPostCreate1(bundle_.Bundle savedInstanceState,
          persistablebundle_.PersistableBundle persistentState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPostCreate1,
          jni.JniType.voidType,
          [savedInstanceState.reference, persistentState.reference]).check();

  static final _id_onStart =
      jniAccessors.getMethodIDOf(_classRef, "onStart", "()V");

  /// from: protected void onStart()
  ///
  /// Called after \#onCreate &mdash; or after \#onRestart when
  /// the activity had been stopped, but is now again being displayed to the
  /// user.  It will be followed by \#onResume.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onCreate
  ///@see \#onStop
  ///@see \#onResume
  void onStart() => jniAccessors.callMethodWithArgs(
      reference, _id_onStart, jni.JniType.voidType, []).check();

  static final _id_onRestart =
      jniAccessors.getMethodIDOf(_classRef, "onRestart", "()V");

  /// from: protected void onRestart()
  ///
  /// Called after \#onStop when the current activity is being
  /// re-displayed to the user (the user has navigated back to it).  It will
  /// be followed by \#onStart and then \#onResume.
  ///
  /// For activities that are using raw Cursor objects (instead of
  /// creating them through
  /// \#managedQuery(android.net.Uri , String[], String, String[], String),
  /// this is usually the place
  /// where the cursor should be requeried (because you had deactivated it in
  /// \#onStop.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onStop
  ///@see \#onStart
  ///@see \#onResume
  void onRestart() => jniAccessors.callMethodWithArgs(
      reference, _id_onRestart, jni.JniType.voidType, []).check();

  static final _id_onStateNotSaved =
      jniAccessors.getMethodIDOf(_classRef, "onStateNotSaved", "()V");

  /// from: public void onStateNotSaved()
  ///
  /// Called when an \#onResume is coming up, prior to other pre-resume callbacks
  /// such as \#onNewIntent and \#onActivityResult.  This is primarily intended
  /// to give the activity a hint that its state is no longer saved -- it will generally
  /// be called after \#onSaveInstanceState and prior to the activity being
  /// resumed/started again.
  void onStateNotSaved() => jniAccessors.callMethodWithArgs(
      reference, _id_onStateNotSaved, jni.JniType.voidType, []).check();

  static final _id_onResume =
      jniAccessors.getMethodIDOf(_classRef, "onResume", "()V");

  /// from: protected void onResume()
  ///
  /// Called after \#onRestoreInstanceState, \#onRestart, or
  /// \#onPause, for your activity to start interacting with the user.
  /// This is a good place to begin animations, open exclusive-access devices
  /// (such as the camera), etc.
  ///
  /// Keep in mind that onResume is not the best indicator that your activity
  /// is visible to the user; a system window such as the keyguard may be in
  /// front.  Use \#onWindowFocusChanged to know for certain that your
  /// activity is visible to the user (for example, to resume a game).
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onRestoreInstanceState
  ///@see \#onRestart
  ///@see \#onPostResume
  ///@see \#onPause
  void onResume() => jniAccessors.callMethodWithArgs(
      reference, _id_onResume, jni.JniType.voidType, []).check();

  static final _id_onPostResume =
      jniAccessors.getMethodIDOf(_classRef, "onPostResume", "()V");

  /// from: protected void onPostResume()
  ///
  /// Called when activity resume is complete (after \#onResume has
  /// been called). Applications will generally not implement this method;
  /// it is intended for system classes to do final setup after application
  /// resume code has run.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onResume
  void onPostResume() => jniAccessors.callMethodWithArgs(
      reference, _id_onPostResume, jni.JniType.voidType, []).check();

  static final _id_isVoiceInteraction =
      jniAccessors.getMethodIDOf(_classRef, "isVoiceInteraction", "()Z");

  /// from: public boolean isVoiceInteraction()
  ///
  /// Check whether this activity is running as part of a voice interaction with the user.
  /// If true, it should perform its interaction with the user through the
  /// VoiceInteractor returned by \#getVoiceInteractor.
  bool isVoiceInteraction() => jniAccessors.callMethodWithArgs(
      reference, _id_isVoiceInteraction, jni.JniType.booleanType, []).boolean;

  static final _id_isVoiceInteractionRoot =
      jniAccessors.getMethodIDOf(_classRef, "isVoiceInteractionRoot", "()Z");

  /// from: public boolean isVoiceInteractionRoot()
  ///
  /// Like \#isVoiceInteraction, but only returns true if this is also the root
  /// of a voice interaction.  That is, returns true if this activity was directly
  /// started by the voice interaction service as the initiation of a voice interaction.
  /// Otherwise, for example if it was started by another activity while under voice
  /// interaction, returns false.
  bool isVoiceInteractionRoot() => jniAccessors.callMethodWithArgs(reference,
      _id_isVoiceInteractionRoot, jni.JniType.booleanType, []).boolean;

  static final _id_getVoiceInteractor = jniAccessors.getMethodIDOf(
      _classRef, "getVoiceInteractor", "()Landroid/app/VoiceInteractor;");

  /// from: public android.app.VoiceInteractor getVoiceInteractor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the active VoiceInteractor that the user is going through to
  /// interact with this activity.
  voiceinteractor_.VoiceInteractor getVoiceInteractor() =>
      voiceinteractor_.VoiceInteractor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getVoiceInteractor,
          jni.JniType.objectType, []).object);

  static final _id_isLocalVoiceInteractionSupported = jniAccessors
      .getMethodIDOf(_classRef, "isLocalVoiceInteractionSupported", "()Z");

  /// from: public boolean isLocalVoiceInteractionSupported()
  ///
  /// Queries whether the currently enabled voice interaction service supports returning
  /// a voice interactor for use by the activity. This is valid only for the duration of the
  /// activity.
  ///@return whether the current voice interaction service supports local voice interaction
  bool isLocalVoiceInteractionSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isLocalVoiceInteractionSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_startLocalVoiceInteraction = jniAccessors.getMethodIDOf(
      _classRef, "startLocalVoiceInteraction", "(Landroid/os/Bundle;)V");

  /// from: public void startLocalVoiceInteraction(android.os.Bundle privateOptions)
  ///
  /// Starts a local voice interaction session. When ready,
  /// \#onLocalVoiceInteractionStarted() is called. You can pass a bundle of private options
  /// to the registered voice interaction service.
  ///@param privateOptions a Bundle of private arguments to the current voice interaction service
  void startLocalVoiceInteraction(bundle_.Bundle privateOptions) =>
      jniAccessors.callMethodWithArgs(reference, _id_startLocalVoiceInteraction,
          jni.JniType.voidType, [privateOptions.reference]).check();

  static final _id_onLocalVoiceInteractionStarted = jniAccessors.getMethodIDOf(
      _classRef, "onLocalVoiceInteractionStarted", "()V");

  /// from: public void onLocalVoiceInteractionStarted()
  ///
  /// Callback to indicate that \#startLocalVoiceInteraction(Bundle) has resulted in a
  /// voice interaction session being started. You can now retrieve a voice interactor using
  /// \#getVoiceInteractor().
  void onLocalVoiceInteractionStarted() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onLocalVoiceInteractionStarted,
      jni.JniType.voidType, []).check();

  static final _id_onLocalVoiceInteractionStopped = jniAccessors.getMethodIDOf(
      _classRef, "onLocalVoiceInteractionStopped", "()V");

  /// from: public void onLocalVoiceInteractionStopped()
  ///
  /// Callback to indicate that the local voice interaction has stopped either
  /// because it was requested through a call to \#stopLocalVoiceInteraction()
  /// or because it was canceled by the user. The previously acquired VoiceInteractor
  /// is no longer valid after this.
  void onLocalVoiceInteractionStopped() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onLocalVoiceInteractionStopped,
      jni.JniType.voidType, []).check();

  static final _id_stopLocalVoiceInteraction =
      jniAccessors.getMethodIDOf(_classRef, "stopLocalVoiceInteraction", "()V");

  /// from: public void stopLocalVoiceInteraction()
  ///
  /// Request to terminate the current voice interaction that was previously started
  /// using \#startLocalVoiceInteraction(Bundle). When the interaction is
  /// terminated, \#onLocalVoiceInteractionStopped() will be called.
  void stopLocalVoiceInteraction() => jniAccessors.callMethodWithArgs(reference,
      _id_stopLocalVoiceInteraction, jni.JniType.voidType, []).check();

  static final _id_onNewIntent = jniAccessors.getMethodIDOf(
      _classRef, "onNewIntent", "(Landroid/content/Intent;)V");

  /// from: protected void onNewIntent(android.content.Intent intent)
  ///
  /// This is called for activities that set launchMode to "singleTop" in
  /// their package, or if a client used the Intent\#FLAG_ACTIVITY_SINGLE_TOP
  /// flag when calling \#startActivity.  In either case, when the
  /// activity is re-launched while at the top of the activity stack instead
  /// of a new instance of the activity being started, onNewIntent() will be
  /// called on the existing instance with the Intent that was used to
  /// re-launch it.
  ///
  /// An activity will always be paused before receiving a new intent, so
  /// you can count on \#onResume being called after this method.
  ///
  /// Note that \#getIntent still returns the original Intent.  You
  /// can use \#setIntent to update it to this new Intent.
  ///@param intent The new intent that was started for the activity.
  ///@see \#getIntent
  ///@see \#setIntent
  ///@see \#onResume
  void onNewIntent(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onNewIntent,
      jni.JniType.voidType,
      [intent.reference]).check();

  static final _id_onSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "(Landroid/os/Bundle;)V");

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  ///
  /// Called to retrieve per-instance state from an activity before being killed
  /// so that the state can be restored in \#onCreate or
  /// \#onRestoreInstanceState (the Bundle populated by this method
  /// will be passed to both).
  ///
  /// This method is called before an activity may be killed so that when it
  /// comes back some time in the future it can restore its state.  For example,
  /// if activity B is launched in front of activity A, and at some point activity
  /// A is killed to reclaim resources, activity A will have a chance to save the
  /// current state of its user interface via this method so that when the user
  /// returns to activity A, the state of the user interface can be restored
  /// via \#onCreate or \#onRestoreInstanceState.
  ///
  /// Do not confuse this method with activity lifecycle callbacks such as
  /// \#onPause, which is always called when an activity is being placed
  /// in the background or on its way to destruction, or \#onStop which
  /// is called before destruction.  One example of when \#onPause and
  /// \#onStop is called and not this method is when a user navigates back
  /// from activity B to activity A: there is no need to call \#onSaveInstanceState
  /// on B because that particular instance will never be restored, so the
  /// system avoids calling it.  An example when \#onPause is called and
  /// not \#onSaveInstanceState is when activity B is launched in front of activity A:
  /// the system may avoid calling \#onSaveInstanceState on activity A if it isn't
  /// killed during the lifetime of B since the state of the user interface of
  /// A will stay intact.
  ///
  /// The default implementation takes care of most of the UI per-instance
  /// state for you by calling android.view.View\#onSaveInstanceState() on each
  /// view in the hierarchy that has an id, and by saving the id of the currently
  /// focused view (all of which is restored by the default implementation of
  /// \#onRestoreInstanceState).  If you override this method to save additional
  /// information not captured by each individual view, you will likely want to
  /// call through to the default implementation, otherwise be prepared to save
  /// all of the state of each view yourself.
  ///
  /// If called, this method will occur after \#onStop for applications
  /// targeting platforms starting with android.os.Build.VERSION_CODES\#P.
  /// For applications targeting earlier platform versions this method will occur
  /// before \#onStop and there are no guarantees about whether it will
  /// occur before or after \#onPause.
  ///@param outState Bundle in which to place your saved state.
  ///@see \#onCreate
  ///@see \#onRestoreInstanceState
  ///@see \#onPause
  void onSaveInstanceState(bundle_.Bundle outState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSaveInstanceState,
          jni.JniType.voidType, [outState.reference]).check();

  static final _id_onSaveInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onSaveInstanceState",
      "(Landroid/os/Bundle;Landroid/os/PersistableBundle;)V");

  /// from: public void onSaveInstanceState(android.os.Bundle outState, android.os.PersistableBundle outPersistentState)
  ///
  /// This is the same as \#onSaveInstanceState but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>. The android.os.PersistableBundle passed
  /// in will be saved and presented in \#onCreate(Bundle, PersistableBundle)
  /// the first time that this activity is restarted following the next device reboot.
  ///@param outState Bundle in which to place your saved state.
  ///@param outPersistentState State which will be saved across reboots.
  ///@see \#onSaveInstanceState(Bundle)
  ///@see \#onCreate
  ///@see \#onRestoreInstanceState(Bundle, PersistableBundle)
  ///@see \#onPause
  void onSaveInstanceState1(bundle_.Bundle outState,
          persistablebundle_.PersistableBundle outPersistentState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSaveInstanceState1,
          jni.JniType.voidType,
          [outState.reference, outPersistentState.reference]).check();

  static final _id_onPause =
      jniAccessors.getMethodIDOf(_classRef, "onPause", "()V");

  /// from: protected void onPause()
  ///
  /// Called as part of the activity lifecycle when an activity is going into
  /// the background, but has not (yet) been killed.  The counterpart to
  /// \#onResume.
  ///
  /// When activity B is launched in front of activity A, this callback will
  /// be invoked on A.  B will not be created until A's \#onPause returns,
  /// so be sure to not do anything lengthy here.
  ///
  /// This callback is mostly used for saving any persistent state the
  /// activity is editing, to present a "edit in place" model to the user and
  /// making sure nothing is lost if there are not enough resources to start
  /// the new activity without first killing this one.  This is also a good
  /// place to do things like stop animations and other things that consume a
  /// noticeable amount of CPU in order to make the switch to the next activity
  /// as fast as possible, or to close resources that are exclusive access
  /// such as the camera.
  ///
  /// In situations where the system needs more memory it may kill paused
  /// processes to reclaim resources.  Because of this, you should be sure
  /// that all of your state is saved by the time you return from
  /// this function.  In general \#onSaveInstanceState is used to save
  /// per-instance state in the activity and this method is used to store
  /// global persistent data (in content providers, files, etc.)
  ///
  /// After receiving this call you will usually receive a following call
  /// to \#onStop (after the next activity has been resumed and
  /// displayed), however in some cases there will be a direct call back to
  /// \#onResume without going through the stopped state.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  ///@see \#onStop
  void onPause() => jniAccessors.callMethodWithArgs(
      reference, _id_onPause, jni.JniType.voidType, []).check();

  static final _id_onUserLeaveHint =
      jniAccessors.getMethodIDOf(_classRef, "onUserLeaveHint", "()V");

  /// from: protected void onUserLeaveHint()
  ///
  /// Called as part of the activity lifecycle when an activity is about to go
  /// into the background as the result of user choice.  For example, when the
  /// user presses the Home key, \#onUserLeaveHint will be called, but
  /// when an incoming phone call causes the in-call Activity to be automatically
  /// brought to the foreground, \#onUserLeaveHint will not be called on
  /// the activity being interrupted.  In cases when it is invoked, this method
  /// is called right before the activity's \#onPause callback.
  ///
  /// This callback and \#onUserInteraction are intended to help
  /// activities manage status bar notifications intelligently; specifically,
  /// for helping activities determine the proper time to cancel a notification.
  ///@see \#onUserInteraction()
  void onUserLeaveHint() => jniAccessors.callMethodWithArgs(
      reference, _id_onUserLeaveHint, jni.JniType.voidType, []).check();

  static final _id_onCreateThumbnail = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateThumbnail",
      "(Landroid/graphics/Bitmap;Landroid/graphics/Canvas;)Z");

  /// from: public boolean onCreateThumbnail(android.graphics.Bitmap outBitmap, android.graphics.Canvas canvas)
  ///
  /// @deprecated Method doesn't do anything and will be removed in the future.
  bool onCreateThumbnail(bitmap_.Bitmap outBitmap, canvas_.Canvas canvas) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateThumbnail,
          jni.JniType.booleanType,
          [outBitmap.reference, canvas.reference]).boolean;

  static final _id_onCreateDescription = jniAccessors.getMethodIDOf(
      _classRef, "onCreateDescription", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence onCreateDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generate a new description for this activity.  This method is called
  /// before stopping the activity and can, if desired, return some textual
  /// description of its current state to be displayed to the user.
  ///
  /// The default implementation returns null, which will cause you to
  /// inherit the description from the previous activity.  If all activities
  /// return null, generally the label of the top activity will be used as the
  /// description.
  ///@return A description of what the user is doing.  It should be short and
  ///         sweet (only a few words).
  ///@see \#onSaveInstanceState
  ///@see \#onStop
  jni.JniObject onCreateDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreateDescription, jni.JniType.objectType, []).object);

  static final _id_onProvideAssistData = jniAccessors.getMethodIDOf(
      _classRef, "onProvideAssistData", "(Landroid/os/Bundle;)V");

  /// from: public void onProvideAssistData(android.os.Bundle data)
  ///
  /// This is called when the user is requesting an assist, to build a full
  /// Intent\#ACTION_ASSIST Intent with all of the context of the current
  /// application.  You can override this method to place into the bundle anything
  /// you would like to appear in the Intent\#EXTRA_ASSIST_CONTEXT part
  /// of the assist Intent.
  ///
  /// This function will be called after any global assist callbacks that had
  /// been registered with Application\#registerOnProvideAssistDataListener Application.registerOnProvideAssistDataListener.
  void onProvideAssistData(bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideAssistData,
          jni.JniType.voidType, [data.reference]).check();

  static final _id_onProvideAssistContent = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideAssistContent",
      "(Landroid/app/assist/AssistContent;)V");

  /// from: public void onProvideAssistContent(android.app.assist.AssistContent outContent)
  ///
  /// This is called when the user is requesting an assist, to provide references
  /// to content related to the current activity.  Before being called, the
  /// {@code outContent} Intent is filled with the base Intent of the activity (the Intent
  /// returned by \#getIntent()).  The Intent's extras are stripped of any types
  /// that are not valid for PersistableBundle or non-framework Parcelables, and
  /// the flags Intent\#FLAG_GRANT_WRITE_URI_PERMISSION and
  /// Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION are cleared from the Intent.
  ///
  /// Custom implementation may adjust the content intent to better reflect the top-level
  /// context of the activity, and fill in its ClipData with additional content of
  /// interest that the user is currently viewing.  For example, an image gallery application
  /// that has launched in to an activity allowing the user to swipe through pictures should
  /// modify the intent to reference the current image they are looking it; such an
  /// application when showing a list of pictures should add a ClipData that has
  /// references to all of the pictures currently visible on screen.
  ///
  ///@param outContent The assist content to return.
  void onProvideAssistContent(assistcontent_.AssistContent outContent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideAssistContent,
          jni.JniType.voidType, [outContent.reference]).check();

  static final _id_requestShowKeyboardShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "requestShowKeyboardShortcuts", "()V");

  /// from: public final void requestShowKeyboardShortcuts()
  ///
  /// Request the Keyboard Shortcuts screen to show up. This will trigger
  /// \#onProvideKeyboardShortcuts to retrieve the shortcuts for the foreground activity.
  void requestShowKeyboardShortcuts() => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestShowKeyboardShortcuts,
      jni.JniType.voidType, []).check();

  static final _id_dismissKeyboardShortcutsHelper = jniAccessors.getMethodIDOf(
      _classRef, "dismissKeyboardShortcutsHelper", "()V");

  /// from: public final void dismissKeyboardShortcutsHelper()
  ///
  /// Dismiss the Keyboard Shortcuts screen.
  void dismissKeyboardShortcutsHelper() => jniAccessors.callMethodWithArgs(
      reference,
      _id_dismissKeyboardShortcutsHelper,
      jni.JniType.voidType, []).check();

  static final _id_onProvideKeyboardShortcuts = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideKeyboardShortcuts",
      "(Ljava/util/List;Landroid/view/Menu;I)V");

  /// from: public void onProvideKeyboardShortcuts(java.util.List<android.view.KeyboardShortcutGroup> data, android.view.Menu menu, int deviceId)
  void onProvideKeyboardShortcuts(
          jni.JniObject data, menu_.Menu menu, int deviceId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onProvideKeyboardShortcuts,
          jni.JniType.voidType,
          [data.reference, menu.reference, deviceId]).check();

  static final _id_showAssist = jniAccessors.getMethodIDOf(
      _classRef, "showAssist", "(Landroid/os/Bundle;)Z");

  /// from: public boolean showAssist(android.os.Bundle args)
  ///
  /// Ask to have the current assistant shown to the user.  This only works if the calling
  /// activity is the current foreground activity.  It is the same as calling
  /// android.service.voice.VoiceInteractionService\#showSession VoiceInteractionService.showSession and requesting all of the possible context.
  /// The receiver will always see
  /// android.service.voice.VoiceInteractionSession\#SHOW_SOURCE_APPLICATION set.
  ///@return Returns true if the assistant was successfully invoked, else false.  For example
  /// false will be returned if the caller is not the current top activity.
  bool showAssist(bundle_.Bundle args) => jniAccessors.callMethodWithArgs(
      reference,
      _id_showAssist,
      jni.JniType.booleanType,
      [args.reference]).boolean;

  static final _id_onStop =
      jniAccessors.getMethodIDOf(_classRef, "onStop", "()V");

  /// from: protected void onStop()
  ///
  /// Called when you are no longer visible to the user.  You will next
  /// receive either \#onRestart, \#onDestroy, or nothing,
  /// depending on later user activity.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onRestart
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  ///@see \#onDestroy
  void onStop() => jniAccessors.callMethodWithArgs(
      reference, _id_onStop, jni.JniType.voidType, []).check();

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: protected void onDestroy()
  ///
  /// Perform any final cleanup before an activity is destroyed.  This can
  /// happen either because the activity is finishing (someone called
  /// \#finish on it, or because the system is temporarily destroying
  /// this instance of the activity to save space.  You can distinguish
  /// between these two scenarios with the \#isFinishing method.
  ///
  /// _Note: do not count on this method being called as a place for
  /// saving data! For example, if an activity is editing data in a content
  /// provider, those edits should be committed in either \#onPause or
  /// \#onSaveInstanceState, not here._ This method is usually implemented to
  /// free resources like threads that are associated with an activity, so
  /// that a destroyed activity does not leave such things around while the
  /// rest of its application is still running.  There are situations where
  /// the system will simply kill the activity's hosting process without
  /// calling this method (or any others) in it, so it should not be used to
  /// do things that are intended to remain around after the process goes
  /// away.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onPause
  ///@see \#onStop
  ///@see \#finish
  ///@see \#isFinishing
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_reportFullyDrawn =
      jniAccessors.getMethodIDOf(_classRef, "reportFullyDrawn", "()V");

  /// from: public void reportFullyDrawn()
  ///
  /// Report to the system that your app is now fully drawn, purely for diagnostic
  /// purposes (calling it does not impact the visible behavior of the activity).
  /// This is only used to help instrument application launch times, so that the
  /// app can report when it is fully in a usable state; without this, the only thing
  /// the system itself can determine is the point at which the activity's window
  /// is _first_ drawn and displayed.  To participate in app launch time
  /// measurement, you should always call this method after first launch (when
  /// \#onCreate(android.os.Bundle) is called), at the point where you have
  /// entirely drawn your UI and populated with all of the significant data.  You
  /// can safely call this method any time after first launch as well, in which case
  /// it will simply be ignored.
  void reportFullyDrawn() => jniAccessors.callMethodWithArgs(
      reference, _id_reportFullyDrawn, jni.JniType.voidType, []).check();

  static final _id_onMultiWindowModeChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onMultiWindowModeChanged",
      "(ZLandroid/content/res/Configuration;)V");

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@see android.R.attr\#resizeableActivity
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInMultiWindowMode}.
  void onMultiWindowModeChanged(
          bool isInMultiWindowMode, configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onMultiWindowModeChanged,
          jni.JniType.voidType,
          [isInMultiWindowMode, newConfig.reference]).check();

  static final _id_onMultiWindowModeChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onMultiWindowModeChanged", "(Z)V");

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode)
  ///
  /// Called by the system when the activity changes from fullscreen mode to multi-window mode and
  /// visa-versa.
  ///@see android.R.attr\#resizeableActivity
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@deprecated Use \#onMultiWindowModeChanged(boolean, Configuration) instead.
  void onMultiWindowModeChanged1(bool isInMultiWindowMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMultiWindowModeChanged1,
          jni.JniType.voidType, [isInMultiWindowMode]).check();

  static final _id_isInMultiWindowMode =
      jniAccessors.getMethodIDOf(_classRef, "isInMultiWindowMode", "()Z");

  /// from: public boolean isInMultiWindowMode()
  ///
  /// Returns true if the activity is currently in multi-window mode.
  ///@see android.R.attr\#resizeableActivity
  ///@return True if the activity is in multi-window mode.
  bool isInMultiWindowMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isInMultiWindowMode, jni.JniType.booleanType, []).boolean;

  static final _id_onPictureInPictureModeChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onPictureInPictureModeChanged",
      "(ZLandroid/content/res/Configuration;)V");

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the activity changes to and from picture-in-picture mode. This
  /// method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInPictureInPictureMode}.
  void onPictureInPictureModeChanged(bool isInPictureInPictureMode,
          configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPictureInPictureModeChanged,
          jni.JniType.voidType,
          [isInPictureInPictureMode, newConfig.reference]).check();

  static final _id_onPictureInPictureModeChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "onPictureInPictureModeChanged", "(Z)V");

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  ///
  /// Called by the system when the activity changes to and from picture-in-picture mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@deprecated Use \#onPictureInPictureModeChanged(boolean, Configuration) instead.
  void onPictureInPictureModeChanged1(bool isInPictureInPictureMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPictureInPictureModeChanged1,
          jni.JniType.voidType,
          [isInPictureInPictureMode]).check();

  static final _id_isInPictureInPictureMode =
      jniAccessors.getMethodIDOf(_classRef, "isInPictureInPictureMode", "()Z");

  /// from: public boolean isInPictureInPictureMode()
  ///
  /// Returns true if the activity is currently in picture-in-picture mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@return True if the activity is in picture-in-picture mode.
  bool isInPictureInPictureMode() => jniAccessors.callMethodWithArgs(reference,
      _id_isInPictureInPictureMode, jni.JniType.booleanType, []).boolean;

  static final _id_enterPictureInPictureMode =
      jniAccessors.getMethodIDOf(_classRef, "enterPictureInPictureMode", "()V");

  /// from: public void enterPictureInPictureMode()
  ///
  /// Puts the activity in picture-in-picture mode if possible in the current system state. Any
  /// prior calls to \#setPictureInPictureParams(PictureInPictureParams) will still apply
  /// when entering picture-in-picture through this call.
  ///@see \#enterPictureInPictureMode(PictureInPictureParams)
  ///@see android.R.attr\#supportsPictureInPicture
  void enterPictureInPictureMode() => jniAccessors.callMethodWithArgs(reference,
      _id_enterPictureInPictureMode, jni.JniType.voidType, []).check();

  static final _id_enterPictureInPictureMode1 = jniAccessors.getMethodIDOf(
      _classRef,
      "enterPictureInPictureMode",
      "(Landroid/app/PictureInPictureParams;)Z");

  /// from: public boolean enterPictureInPictureMode(android.app.PictureInPictureParams params)
  ///
  /// Puts the activity in picture-in-picture mode if possible in the current system state. The
  /// set parameters in {@param params} will be combined with the parameters from prior calls to
  /// \#setPictureInPictureParams(PictureInPictureParams).
  ///
  /// The system may disallow entering picture-in-picture in various cases, including when the
  /// activity is not visible, if the screen is locked or if the user has an activity pinned.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@see PictureInPictureParams
  ///@param params non-null parameters to be combined with previously set parameters when entering
  /// picture-in-picture.
  ///
  /// This value must never be {@code null}.
  ///@return true if the system successfully put this activity into picture-in-picture mode or was
  /// already in picture-in-picture mode (@see {@link \#isInPictureInPictureMode()). If the device
  /// does not support picture-in-picture, return false.
  bool enterPictureInPictureMode1(
          pictureinpictureparams_.PictureInPictureParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_enterPictureInPictureMode1,
          jni.JniType.booleanType, [params.reference]).boolean;

  static final _id_setPictureInPictureParams = jniAccessors.getMethodIDOf(
      _classRef,
      "setPictureInPictureParams",
      "(Landroid/app/PictureInPictureParams;)V");

  /// from: public void setPictureInPictureParams(android.app.PictureInPictureParams params)
  ///
  /// Updates the properties of the picture-in-picture activity, or sets it to be used later when
  /// \#enterPictureInPictureMode() is called.
  ///@param params the new parameters for the picture-in-picture.
  ///
  /// This value must never be {@code null}.
  void setPictureInPictureParams(
          pictureinpictureparams_.PictureInPictureParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPictureInPictureParams,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_getMaxNumPictureInPictureActions = jniAccessors
      .getMethodIDOf(_classRef, "getMaxNumPictureInPictureActions", "()I");

  /// from: public int getMaxNumPictureInPictureActions()
  ///
  /// Return the number of actions that will be displayed in the picture-in-picture UI when the
  /// user interacts with the activity currently in picture-in-picture mode. This number may change
  /// if the global configuration changes (ie. if the device is plugged into an external display),
  /// but will always be larger than three.
  int getMaxNumPictureInPictureActions() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getMaxNumPictureInPictureActions,
      jni.JniType.intType, []).integer;

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the device configuration changes while your
  /// activity is running.  Note that this will _only_ be called if
  /// you have selected configurations you would like to handle with the
  /// android.R.attr\#configChanges attribute in your manifest.  If
  /// any configuration change occurs that is not selected to be reported
  /// by that attribute, then instead of reporting it the system will stop
  /// and restart the activity (to have it launched with the new
  /// configuration).
  ///
  /// At the time that this function has been called, your Resources
  /// object will have been updated to return resource values matching the
  /// new configuration.
  ///@param newConfig The new device configuration.
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// If this activity is being destroyed because it can not handle a
  /// configuration parameter being changed (and thus its
  /// \#onConfigurationChanged(Configuration) method is
  /// _not_ being called), then you can use this method to discover
  /// the set of changes that have occurred while in the process of being
  /// destroyed.  Note that there is no guarantee that these will be
  /// accurate (other changes could have happened at any time), so you should
  /// only use this as an optimization hint.
  ///@return Returns a bit field of the configuration parameters that are
  /// changing, as defined by the android.content.res.Configuration
  /// class.
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_getLastNonConfigurationInstance = jniAccessors.getMethodIDOf(
      _classRef, "getLastNonConfigurationInstance", "()Ljava/lang/Object;");

  /// from: public java.lang.Object getLastNonConfigurationInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the non-configuration instance data that was previously
  /// returned by \#onRetainNonConfigurationInstance().  This will
  /// be available from the initial \#onCreate and
  /// \#onStart calls to the new instance, allowing you to extract
  /// any useful dynamic state from the previous instance.
  ///
  /// Note that the data you retrieve here should _only_ be used
  /// as an optimization for handling configuration changes.  You should always
  /// be able to handle getting a null pointer back, and an activity must
  /// still be able to restore itself to its previous state (through the
  /// normal \#onSaveInstanceState(Bundle) mechanism) even if this
  /// function returns null.
  ///
  /// <strong>Note:</strong> For most cases you should use the Fragment API
  /// Fragment\#setRetainInstance(boolean) instead; this is also
  /// available on older platforms through the Android support libraries.
  ///@return the object previously returned by \#onRetainNonConfigurationInstance()
  jni.JniObject getLastNonConfigurationInstance() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLastNonConfigurationInstance,
          jni.JniType.objectType, []).object);

  static final _id_onRetainNonConfigurationInstance =
      jniAccessors.getMethodIDOf(_classRef, "onRetainNonConfigurationInstance",
          "()Ljava/lang/Object;");

  /// from: public java.lang.Object onRetainNonConfigurationInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the system, as part of destroying an
  /// activity due to a configuration change, when it is known that a new
  /// instance will immediately be created for the new configuration.  You
  /// can return any object you like here, including the activity instance
  /// itself, which can later be retrieved by calling
  /// \#getLastNonConfigurationInstance() in the new activity
  /// instance.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a Fragment with
  /// Fragment\#setRetainInstance(boolean) Fragment.setRetainInstance(boolean._
  ///
  /// This function is called purely as an optimization, and you must
  /// not rely on it being called.  When it is called, a number of guarantees
  /// will be made to help optimize configuration switching:
  /// <ul>
  /// <li> The function will be called between \#onStop and
  /// \#onDestroy.
  /// <li> A new instance of the activity will _always_ be immediately
  /// created after this one's \#onDestroy() is called.  In particular,
  /// _no_ messages will be dispatched during this time (when the returned
  /// object does not have an activity to be associated with).
  /// <li> The object you return here will _always_ be available from
  /// the \#getLastNonConfigurationInstance() method of the following
  /// activity instance as described there.
  /// </ul>
  ///
  /// These guarantees are designed so that an activity can use this API
  /// to propagate extensive state from the old to new activity instance, from
  /// loaded bitmaps, to network connections, to evenly actively running
  /// threads.  Note that you should _not_ propagate any data that
  /// may change based on the configuration, including any data loaded from
  /// resources such as strings, layouts, or drawables.
  ///
  /// The guarantee of no message handling during the switch to the next
  /// activity simplifies use with active objects.  For example if your retained
  /// state is an android.os.AsyncTask you are guaranteed that its
  /// call back functions (like android.os.AsyncTask\#onPostExecute) will
  /// not be called from the call here until you execute the next instance's
  /// \#onCreate(Bundle).  (Note however that there is of course no such
  /// guarantee for android.os.AsyncTask\#doInBackground since that is
  /// running in a separate thread.)
  ///
  /// <strong>Note:</strong> For most cases you should use the Fragment API
  /// Fragment\#setRetainInstance(boolean) instead; this is also
  /// available on older platforms through the Android support libraries.
  ///@return any Object holding the desired state to propagate to the
  ///         next activity instance
  jni.JniObject onRetainNonConfigurationInstance() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onRetainNonConfigurationInstance,
          jni.JniType.objectType, []).object);

  static final _id_onLowMemory =
      jniAccessors.getMethodIDOf(_classRef, "onLowMemory", "()V");

  /// from: public void onLowMemory()
  void onLowMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_onLowMemory, jni.JniType.voidType, []).check();

  static final _id_onTrimMemory =
      jniAccessors.getMethodIDOf(_classRef, "onTrimMemory", "(I)V");

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onTrimMemory, jni.JniType.voidType, [level]).check();

  static final _id_getFragmentManager = jniAccessors.getMethodIDOf(
      _classRef, "getFragmentManager", "()Landroid/app/FragmentManager;");

  /// from: public android.app.FragmentManager getFragmentManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the FragmentManager for interacting with fragments associated
  /// with this activity.
  ///@deprecated Use android.support.v4.app.FragmentActivity\#getSupportFragmentManager()
  fragmentmanager_.FragmentManager getFragmentManager() =>
      fragmentmanager_.FragmentManager.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFragmentManager,
          jni.JniType.objectType, []).object);

  static final _id_onAttachFragment = jniAccessors.getMethodIDOf(
      _classRef, "onAttachFragment", "(Landroid/app/Fragment;)V");

  /// from: public void onAttachFragment(android.app.Fragment fragment)
  ///
  /// Called when a Fragment is being attached to this activity, immediately
  /// after the call to its Fragment\#onAttach Fragment.onAttach()
  /// method and before Fragment\#onCreate Fragment.onCreate().
  ///@deprecated Use android.support.v4.app.FragmentActivity\#onAttachFragment(android.support.v4.app.Fragment)
  void onAttachFragment(fragment_.Fragment fragment) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAttachFragment,
          jni.JniType.voidType, [fragment.reference]).check();

  static final _id_managedQuery = jniAccessors.getMethodIDOf(
      _classRef,
      "managedQuery",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor managedQuery(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Wrapper around
  /// ContentResolver\#query(android.net.Uri , String[], String, String[], String)
  /// that gives the resulting Cursor to call
  /// \#startManagingCursor so that the activity will manage its
  /// lifecycle for you.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using LoaderManager instead, available
  /// via \#getLoaderManager()._
  ///
  /// <strong>Warning:</strong> Do not call Cursor\#close() on a cursor obtained using
  /// this method, because the activity will do that for you at the appropriate time. However, if
  /// you call \#stopManagingCursor on a cursor from a managed query, the system _will
  /// not_ automatically close the cursor and, in that case, you must call
  /// Cursor\#close().
  ///
  ///@param uri The URI of the content provider to query.
  ///@param projection List of columns to return.
  ///@param selection SQL WHERE clause.
  ///@param selectionArgs The arguments to selection, if any ?s are pesent
  ///@param sortOrder SQL ORDER BY clause.
  ///@return The Cursor that was returned by query().
  ///@see ContentResolver\#query(android.net.Uri , String[], String, String[], String)
  ///@see \#startManagingCursor
  ///@deprecated Use CursorLoader instead.
  cursor_.Cursor managedQuery(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_managedQuery, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference
      ]).object);

  static final _id_startManagingCursor = jniAccessors.getMethodIDOf(
      _classRef, "startManagingCursor", "(Landroid/database/Cursor;)V");

  /// from: public void startManagingCursor(android.database.Cursor c)
  ///
  /// This method allows the activity to take care of managing the given
  /// Cursor's lifecycle for you based on the activity's lifecycle.
  /// That is, when the activity is stopped it will automatically call
  /// Cursor\#deactivate on the given Cursor, and when it is later restarted
  /// it will call Cursor\#requery for you.  When the activity is
  /// destroyed, all managed Cursors will be closed automatically.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using LoaderManager instead, available
  /// via \#getLoaderManager()._
  ///
  /// <strong>Warning:</strong> Do not call Cursor\#close() on cursor obtained from
  /// \#managedQuery, because the activity will do that for you at the appropriate time.
  /// However, if you call \#stopManagingCursor on a cursor from a managed query, the system
  /// _will not_ automatically close the cursor and, in that case, you must call
  /// Cursor\#close().
  ///
  ///@param c The Cursor to be managed.
  ///@see \#managedQuery(android.net.Uri , String[], String, String[], String)
  ///@see \#stopManagingCursor
  ///@deprecated Use the new android.content.CursorLoader class with
  /// LoaderManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void startManagingCursor(cursor_.Cursor c) => jniAccessors.callMethodWithArgs(
      reference,
      _id_startManagingCursor,
      jni.JniType.voidType,
      [c.reference]).check();

  static final _id_stopManagingCursor = jniAccessors.getMethodIDOf(
      _classRef, "stopManagingCursor", "(Landroid/database/Cursor;)V");

  /// from: public void stopManagingCursor(android.database.Cursor c)
  ///
  /// Given a Cursor that was previously given to
  /// \#startManagingCursor, stop the activity's management of that
  /// cursor.
  ///
  /// <strong>Warning:</strong> After calling this method on a cursor from a managed query,
  /// the system _will not_ automatically close the cursor and you must call
  /// Cursor\#close().
  ///
  ///@param c The Cursor that was being managed.
  ///@see \#startManagingCursor
  ///@deprecated Use the new android.content.CursorLoader class with
  /// LoaderManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void stopManagingCursor(cursor_.Cursor c) => jniAccessors.callMethodWithArgs(
      reference,
      _id_stopManagingCursor,
      jni.JniType.voidType,
      [c.reference]).check();

  static final _id_getActionBar = jniAccessors.getMethodIDOf(
      _classRef, "getActionBar", "()Landroid/app/ActionBar;");

  /// from: public android.app.ActionBar getActionBar()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a reference to this activity's ActionBar.
  ///@return The Activity's ActionBar, or null if it does not have one.
  actionbar_.ActionBar getActionBar() =>
      actionbar_.ActionBar.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActionBar, jni.JniType.objectType, []).object);

  static final _id_setActionBar = jniAccessors.getMethodIDOf(
      _classRef, "setActionBar", "(Landroid/widget/Toolbar;)V");

  /// from: public void setActionBar(android.widget.Toolbar toolbar)
  ///
  /// Set a android.widget.Toolbar Toolbar to act as the ActionBar for this
  /// Activity window.
  ///
  /// When set to a non-null value the \#getActionBar() method will return
  /// an ActionBar object that can be used to control the given toolbar as if it were
  /// a traditional window decor action bar. The toolbar's menu will be populated with the
  /// Activity's options menu and the navigation button will be wired through the standard
  /// android.R.id\#home home menu select action.
  ///
  ///
  /// In order to use a Toolbar within the Activity's window content the application
  /// must not request the window feature Window\#FEATURE_ACTION_BAR FEATURE_ACTION_BAR.
  ///
  ///@param toolbar Toolbar to set as the Activity's action bar, or {@code null} to clear it
  ///
  /// This value may be {@code null}.
  void setActionBar(toolbar_.Toolbar toolbar) =>
      jniAccessors.callMethodWithArgs(reference, _id_setActionBar,
          jni.JniType.voidType, [toolbar.reference]).check();

  static final _id_setContentView =
      jniAccessors.getMethodIDOf(_classRef, "setContentView", "(I)V");

  /// from: public void setContentView(int layoutResID)
  ///
  /// Set the activity content from a layout resource.  The resource will be
  /// inflated, adding all top-level views to the activity.
  ///@param layoutResID Resource ID to be inflated.
  ///@see \#setContentView(android.view.View)
  ///@see \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  void setContentView(int layoutResID) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView,
      jni.JniType.voidType,
      [layoutResID]).check();

  static final _id_setContentView1 = jniAccessors.getMethodIDOf(
      _classRef, "setContentView", "(Landroid/view/View;)V");

  /// from: public void setContentView(android.view.View view)
  ///
  /// Set the activity content to an explicit view.  This view is placed
  /// directly into the activity's view hierarchy.  It can itself be a complex
  /// view hierarchy.  When calling this method, the layout parameters of the
  /// specified view are ignored.  Both the width and the height of the view are
  /// set by default to ViewGroup.LayoutParams\#MATCH_PARENT. To use
  /// your own layout parameters, invoke
  /// \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  /// instead.
  ///@param view The desired content to display.
  ///@see \#setContentView(int)
  ///@see \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  void setContentView1(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView1,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setContentView2 = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void setContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Set the activity content to an explicit view.  This view is placed
  /// directly into the activity's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  ///@see \#setContentView(android.view.View)
  ///@see \#setContentView(int)
  void setContentView2(
          view_.View view, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentView2,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_addContentView = jniAccessors.getMethodIDOf(
      _classRef,
      "addContentView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void addContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Add an additional content view to the activity.  Added after any existing
  /// ones in the activity -- existing views are NOT removed.
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  void addContentView(
          view_.View view, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_addContentView,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_getContentTransitionManager = jniAccessors.getMethodIDOf(
      _classRef,
      "getContentTransitionManager",
      "()Landroid/transition/TransitionManager;");

  /// from: public android.transition.TransitionManager getContentTransitionManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the TransitionManager responsible for default transitions in this window.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///
  /// This method will return non-null after content has been initialized (e.g. by using
  /// \#setContentView) if Window\#FEATURE_CONTENT_TRANSITIONS has been granted.
  ///
  ///@return This window's content TransitionManager or null if none is set.
  transitionmanager_.TransitionManager getContentTransitionManager() =>
      transitionmanager_.TransitionManager.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getContentTransitionManager,
              jni.JniType.objectType, []).object);

  static final _id_setContentTransitionManager = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentTransitionManager",
      "(Landroid/transition/TransitionManager;)V");

  /// from: public void setContentTransitionManager(android.transition.TransitionManager tm)
  ///
  /// Set the TransitionManager to use for default transitions in this window.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///@param tm The TransitionManager to use for scene changes.
  void setContentTransitionManager(transitionmanager_.TransitionManager tm) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentTransitionManager,
          jni.JniType.voidType,
          [tm.reference]).check();

  static final _id_getContentScene = jniAccessors.getMethodIDOf(
      _classRef, "getContentScene", "()Landroid/transition/Scene;");

  /// from: public android.transition.Scene getContentScene()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Scene representing this window's current content.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///
  /// This method will return null if the current content is not represented by a Scene.
  ///
  ///@return Current Scene being shown or null
  scene_.Scene getContentScene() =>
      scene_.Scene.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContentScene, jni.JniType.objectType, []).object);

  static final _id_setFinishOnTouchOutside =
      jniAccessors.getMethodIDOf(_classRef, "setFinishOnTouchOutside", "(Z)V");

  /// from: public void setFinishOnTouchOutside(boolean finish)
  ///
  /// Sets whether this activity is finished when touched outside its window's
  /// bounds.
  void setFinishOnTouchOutside(bool finish) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFinishOnTouchOutside,
      jni.JniType.voidType,
      [finish]).check();

  static final _id_setDefaultKeyMode =
      jniAccessors.getMethodIDOf(_classRef, "setDefaultKeyMode", "(I)V");

  /// from: public final void setDefaultKeyMode(int mode)
  ///
  /// Select the default key handling for this activity.  This controls what
  /// will happen to key events that are not otherwise handled.  The default
  /// mode (\#DEFAULT_KEYS_DISABLE) will simply drop them on the
  /// floor. Other modes allow you to launch the dialer
  /// (\#DEFAULT_KEYS_DIALER), execute a shortcut in your options
  /// menu without requiring the menu key be held down
  /// (\#DEFAULT_KEYS_SHORTCUT), or launch a search (\#DEFAULT_KEYS_SEARCH_LOCAL
  /// and \#DEFAULT_KEYS_SEARCH_GLOBAL).
  ///
  /// Note that the mode selected here does not impact the default
  /// handling of system keys, such as the "back" and "menu" keys, and your
  /// activity and its views always get a first chance to receive and handle
  /// all application keys.
  ///@param mode The desired default key mode constant.
  ///
  /// Value is android.app.Activity\#DEFAULT_KEYS_DISABLE, android.app.Activity\#DEFAULT_KEYS_DIALER, android.app.Activity\#DEFAULT_KEYS_SHORTCUT, android.app.Activity\#DEFAULT_KEYS_SEARCH_LOCAL, or android.app.Activity\#DEFAULT_KEYS_SEARCH_GLOBAL
  ///@see \#onKeyDown
  void setDefaultKeyMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setDefaultKeyMode, jni.JniType.voidType, [mode]).check();

  static final _id_onKeyDown = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key was pressed down and not handled by any of the views
  /// inside of the activity. So, for example, key presses while the cursor
  /// is inside a TextView will not trigger the event (unless it is a navigation
  /// to another object) because TextView handles its own key presses.
  ///
  /// If the focused view didn't want this event, this method is called.
  ///
  /// The default implementation takes care of KeyEvent\#KEYCODE_BACK
  /// by calling \#onBackPressed(), though the behavior varies based
  /// on the application compatibility mode: for
  /// android.os.Build.VERSION_CODES\#ECLAIR or later applications,
  /// it will set up the dispatch to call \#onKeyUp where the action
  /// will be performed; for earlier applications, it will perform the
  /// action immediately in on-down, as those versions of the platform
  /// behaved.
  ///
  /// Other additional default key handling may be performed
  /// if configured with \#setDefaultKeyMode.
  ///@return Return <code>true</code> to prevent this event from being propagated
  /// further, or <code>false</code> to indicate that you have not handled
  /// this event and it should continue to be propagated.
  ///@see \#onKeyUp
  ///@see android.view.KeyEvent
  bool onKeyDown(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyLongPress = jniAccessors.getMethodIDOf(
      _classRef, "onKeyLongPress", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle
  /// the event).
  bool onKeyLongPress(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyLongPress,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyUp = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key was released and not handled by any of the views
  /// inside of the activity. So, for example, key presses while the cursor
  /// is inside a TextView will not trigger the event (unless it is a navigation
  /// to another object) because TextView handles its own key presses.
  ///
  /// The default implementation handles KEYCODE_BACK to stop the activity
  /// and go back.
  ///@return Return <code>true</code> to prevent this event from being propagated
  /// further, or <code>false</code> to indicate that you have not handled
  /// this event and it should continue to be propagated.
  ///@see \#onKeyDown
  ///@see KeyEvent
  bool onKeyUp(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyMultiple = jniAccessors.getMethodIDOf(
      _classRef, "onKeyMultiple", "(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyMultiple(int, int, KeyEvent) KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle
  /// the event).
  bool onKeyMultiple(int keyCode, int repeatCount, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onKeyMultiple,
          jni.JniType.booleanType,
          [keyCode, repeatCount, event.reference]).boolean;

  static final _id_onBackPressed =
      jniAccessors.getMethodIDOf(_classRef, "onBackPressed", "()V");

  /// from: public void onBackPressed()
  ///
  /// Called when the activity has detected the user's press of the back
  /// key.  The default implementation simply finishes the current activity,
  /// but you can override this to do whatever you want.
  void onBackPressed() => jniAccessors.callMethodWithArgs(
      reference, _id_onBackPressed, jni.JniType.voidType, []).check();

  static final _id_onKeyShortcut = jniAccessors.getMethodIDOf(
      _classRef, "onKeyShortcut", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyShortcut(int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key shortcut event is not handled by any of the views in the Activity.
  /// Override this method to implement global key shortcuts for the Activity.
  /// Key shortcuts can also be implemented by setting the
  /// MenuItem\#setShortcut(char, char) shortcut property of menu items.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  ///@return True if the key shortcut was handled.
  bool onKeyShortcut(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyShortcut,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  ///
  /// Called when a touch screen event was not handled by any of the views
  /// under it.  This is most useful to process touch events that happen
  /// outside of your window bounds, where there is no view to receive it.
  ///@param event The touch screen event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  ///
  /// Called when the trackball was moved and not handled by any of the
  /// views inside of the activity.  So, for example, if the trackball moves
  /// while focus is on a button, you will receive a call here because
  /// buttons do not normally do anything with trackball events.  The call
  /// here happens _before_ trackball movements are converted to
  /// DPAD key events, which then get sent back to the view hierarchy, and
  /// will be processed at the point for things like focus navigation.
  ///@param event The trackball event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Called when a generic motion event was not handled by any of the
  /// views inside of the activity.
  ///
  /// Generic motion events describe joystick movements, mouse hovers, track pad
  /// touches, scroll wheel movements and other input events.  The
  /// MotionEvent\#getSource() source of the motion event specifies
  /// the class of input that was received.  Implementations of this method
  /// must examine the bits in the source before processing the event.
  /// The following code example shows how this is done.
  ///
  ///
  /// Generic motion events with source class
  /// android.view.InputDevice\#SOURCE_CLASS_POINTER
  /// are delivered to the view under the pointer.  All other generic motion events are
  /// delivered to the focused view.
  ///
  ///
  /// See View\#onGenericMotionEvent(MotionEvent) for an example of how to
  /// handle this event.
  ///
  ///
  ///@param event The generic motion event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onUserInteraction =
      jniAccessors.getMethodIDOf(_classRef, "onUserInteraction", "()V");

  /// from: public void onUserInteraction()
  ///
  /// Called whenever a key, touch, or trackball event is dispatched to the
  /// activity.  Implement this method if you wish to know that the user has
  /// interacted with the device in some way while your activity is running.
  /// This callback and \#onUserLeaveHint are intended to help
  /// activities manage status bar notifications intelligently; specifically,
  /// for helping activities determine the proper time to cancel a notfication.
  ///
  /// All calls to your activity's \#onUserLeaveHint callback will
  /// be accompanied by calls to \#onUserInteraction.  This
  /// ensures that your activity will be told of relevant user activity such
  /// as pulling down the notification pane and touching an item there.
  ///
  /// Note that this callback will be invoked for the touch down action
  /// that begins a touch gesture, but may not be invoked for the touch-moved
  /// and touch-up actions that follow.
  ///@see \#onUserLeaveHint()
  void onUserInteraction() => jniAccessors.callMethodWithArgs(
      reference, _id_onUserInteraction, jni.JniType.voidType, []).check();

  static final _id_onWindowAttributesChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowAttributesChanged",
      "(Landroid/view/WindowManager\$LayoutParams;)V");

  /// from: public void onWindowAttributesChanged(android.view.WindowManager.LayoutParams params)
  void onWindowAttributesChanged(
          windowmanager_.WindowManager_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowAttributesChanged,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_onContentChanged =
      jniAccessors.getMethodIDOf(_classRef, "onContentChanged", "()V");

  /// from: public void onContentChanged()
  void onContentChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_onContentChanged, jni.JniType.voidType, []).check();

  static final _id_onWindowFocusChanged =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  ///
  /// Called when the current Window of the activity gains or loses
  /// focus.  This is the best indicator of whether this activity is visible
  /// to the user.  The default implementation clears the key tracking
  /// state, so should always be called.
  ///
  /// Note that this provides information about global focus state, which
  /// is managed independently of activity lifecycles.  As such, while focus
  /// changes will generally have some relation to lifecycle changes (an
  /// activity that is stopped will not generally get window focus), you
  /// should not rely on any particular order between the callbacks here and
  /// those in the other lifecycle methods such as \#onResume.
  ///
  /// As a general rule, however, a resumed activity will have window
  /// focus...  unless it has displayed other dialogs or popups that take
  /// input focus, in which case the activity itself will not have focus
  /// when the other windows have it.  Likewise, the system may display
  /// system-level windows (such as the status bar notification panel or
  /// a system alert) which will temporarily take window input focus without
  /// pausing the foreground activity.
  ///@param hasFocus Whether the window of this activity has focus.
  ///@see \#hasWindowFocus()
  ///@see \#onResume
  ///@see View\#onWindowFocusChanged(boolean)
  void onWindowFocusChanged(bool hasFocus) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onWindowFocusChanged,
      jni.JniType.voidType,
      [hasFocus]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: public void onAttachedToWindow()
  ///
  /// Called when the main window associated with the activity has been
  /// attached to the window manager.
  /// See View\#onAttachedToWindow() View.onAttachedToWindow()
  /// for more information.
  ///@see View\#onAttachedToWindow
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: public void onDetachedFromWindow()
  ///
  /// Called when the main window associated with the activity has been
  /// detached from the window manager.
  /// See View\#onDetachedFromWindow() View.onDetachedFromWindow()
  /// for more information.
  ///@see View\#onDetachedFromWindow
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_hasWindowFocus =
      jniAccessors.getMethodIDOf(_classRef, "hasWindowFocus", "()Z");

  /// from: public boolean hasWindowFocus()
  ///
  /// Returns true if this activity's _main_ window currently has window focus.
  /// Note that this is not the same as the view itself having focus.
  ///@return True if this activity's main window currently has window focus.
  ///@see \#onWindowAttributesChanged(android.view.WindowManager.LayoutParams)
  bool hasWindowFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_hasWindowFocus, jni.JniType.booleanType, []).boolean;

  static final _id_dispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  ///
  /// Called to process key events.  You can override this to intercept all
  /// key events before they are dispatched to the window.  Be sure to call
  /// this implementation for key events that should be handled normally.
  ///@param event The key event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchKeyShortcutEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyShortcutEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  ///
  /// Called to process a key shortcut event.
  /// You can override this to intercept all key shortcut events before they are
  /// dispatched to the window.  Be sure to call this implementation for key shortcut
  /// events that should be handled normally.
  ///@param event The key shortcut event.
  ///@return True if this event was consumed.
  bool dispatchKeyShortcutEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyShortcutEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent ev)
  ///
  /// Called to process touch screen events.  You can override this to
  /// intercept all touch screen events before they are dispatched to the
  /// window.  Be sure to call this implementation for touch screen events
  /// that should be handled normally.
  ///@param ev The touch screen event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTouchEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTouchEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_dispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent ev)
  ///
  /// Called to process trackball events.  You can override this to
  /// intercept all trackball events before they are dispatched to the
  /// window.  Be sure to call this implementation for trackball events
  /// that should be handled normally.
  ///@param ev The trackball event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTrackballEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTrackballEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_dispatchGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent ev)
  ///
  /// Called to process generic motion events.  You can override this to
  /// intercept all generic motion events before they are dispatched to the
  /// window.  Be sure to call this implementation for generic motion events
  /// that should be handled normally.
  ///@param ev The generic motion event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchGenericMotionEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchGenericMotionEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_dispatchPopulateAccessibilityEvent =
      jniAccessors.getMethodIDOf(
          _classRef,
          "dispatchPopulateAccessibilityEvent",
          "(Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  bool dispatchPopulateAccessibilityEvent(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPopulateAccessibilityEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_onCreatePanelView = jniAccessors.getMethodIDOf(
      _classRef, "onCreatePanelView", "(I)Landroid/view/View;");

  /// from: public android.view.View onCreatePanelView(int featureId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onCreatePanelView
  /// for activities. This
  /// simply returns null so that all panel sub-windows will have the default
  /// menu behavior.
  view_.View onCreatePanelView(int featureId) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreatePanelView, jni.JniType.objectType, [featureId]).object);

  static final _id_onCreatePanelMenu = jniAccessors.getMethodIDOf(
      _classRef, "onCreatePanelMenu", "(ILandroid/view/Menu;)Z");

  /// from: public boolean onCreatePanelMenu(int featureId, android.view.Menu menu)
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onCreatePanelMenu
  /// for activities.  This calls through to the new
  /// \#onCreateOptionsMenu method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL panel,
  /// so that subclasses of Activity don't need to deal with feature codes.
  bool onCreatePanelMenu(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreatePanelMenu,
          jni.JniType.booleanType, [featureId, menu.reference]).boolean;

  static final _id_onPreparePanel = jniAccessors.getMethodIDOf(_classRef,
      "onPreparePanel", "(ILandroid/view/View;Landroid/view/Menu;)Z");

  /// from: public boolean onPreparePanel(int featureId, android.view.View view, android.view.Menu menu)
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onPreparePanel
  /// for activities.  This
  /// calls through to the new \#onPrepareOptionsMenu method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL
  /// panel, so that subclasses of
  /// Activity don't need to deal with feature codes.
  bool onPreparePanel(int featureId, view_.View view, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPreparePanel,
          jni.JniType.booleanType,
          [featureId, view.reference, menu.reference]).boolean;

  static final _id_onMenuOpened = jniAccessors.getMethodIDOf(
      _classRef, "onMenuOpened", "(ILandroid/view/Menu;)Z");

  /// from: public boolean onMenuOpened(int featureId, android.view.Menu menu)
  ///
  /// {@inheritDoc}
  ///@return The default implementation returns true.
  bool onMenuOpened(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuOpened,
          jni.JniType.booleanType, [featureId, menu.reference]).boolean;

  static final _id_onMenuItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onMenuItemSelected", "(ILandroid/view/MenuItem;)Z");

  /// from: public boolean onMenuItemSelected(int featureId, android.view.MenuItem item)
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onMenuItemSelected
  /// for activities.  This calls through to the new
  /// \#onOptionsItemSelected method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL
  /// panel, so that subclasses of
  /// Activity don't need to deal with feature codes.
  bool onMenuItemSelected(int featureId, menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuItemSelected,
          jni.JniType.booleanType, [featureId, item.reference]).boolean;

  static final _id_onPanelClosed = jniAccessors.getMethodIDOf(
      _classRef, "onPanelClosed", "(ILandroid/view/Menu;)V");

  /// from: public void onPanelClosed(int featureId, android.view.Menu menu)
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onPanelClosed(int, Menu) for
  /// activities. This calls through to \#onOptionsMenuClosed(Menu)
  /// method for the android.view.Window\#FEATURE_OPTIONS_PANEL panel,
  /// so that subclasses of Activity don't need to deal with feature codes.
  /// For context menus (Window\#FEATURE_CONTEXT_MENU), the
  /// \#onContextMenuClosed(Menu) will be called.
  void onPanelClosed(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPanelClosed,
          jni.JniType.voidType, [featureId, menu.reference]).check();

  static final _id_invalidateOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "invalidateOptionsMenu", "()V");

  /// from: public void invalidateOptionsMenu()
  ///
  /// Declare that the options menu has changed, so should be recreated.
  /// The \#onCreateOptionsMenu(Menu) method will be called the next
  /// time it needs to be displayed.
  void invalidateOptionsMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidateOptionsMenu, jni.JniType.voidType, []).check();

  static final _id_onCreateOptionsMenu = jniAccessors.getMethodIDOf(
      _classRef, "onCreateOptionsMenu", "(Landroid/view/Menu;)Z");

  /// from: public boolean onCreateOptionsMenu(android.view.Menu menu)
  ///
  /// Initialize the contents of the Activity's standard options menu.  You
  /// should place your menu items in to <var>menu</var>.
  ///
  /// This is only called once, the first time the options menu is
  /// displayed.  To update the menu every time it is displayed, see
  /// \#onPrepareOptionsMenu.
  ///
  /// The default implementation populates the menu with standard system
  /// menu items.  These are placed in the Menu\#CATEGORY_SYSTEM group so that
  /// they will be correctly ordered with application-defined menu items.
  /// Deriving classes should always call through to the base implementation.
  ///
  /// You can safely hold on to <var>menu</var> (and any items created
  /// from it), making modifications to it as desired, until the next
  /// time onCreateOptionsMenu() is called.
  ///
  /// When you add items to the menu, you can implement the Activity's
  /// \#onOptionsItemSelected method to handle them there.
  ///@param menu The options menu in which you place your items.
  ///@return You must return true for the menu to be displayed;
  ///         if you return false it will not be shown.
  ///@see \#onPrepareOptionsMenu
  ///@see \#onOptionsItemSelected
  bool onCreateOptionsMenu(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCreateOptionsMenu,
      jni.JniType.booleanType,
      [menu.reference]).boolean;

  static final _id_onPrepareOptionsMenu = jniAccessors.getMethodIDOf(
      _classRef, "onPrepareOptionsMenu", "(Landroid/view/Menu;)Z");

  /// from: public boolean onPrepareOptionsMenu(android.view.Menu menu)
  ///
  /// Prepare the Screen's standard options menu to be displayed.  This is
  /// called right before the menu is shown, every time it is shown.  You can
  /// use this method to efficiently enable/disable items or otherwise
  /// dynamically modify the contents.
  ///
  /// The default implementation updates the system menu items based on the
  /// activity's state.  Deriving classes should always call through to the
  /// base class implementation.
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  ///@return You must return true for the menu to be displayed;
  ///         if you return false it will not be shown.
  ///@see \#onCreateOptionsMenu
  bool onPrepareOptionsMenu(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onPrepareOptionsMenu,
      jni.JniType.booleanType,
      [menu.reference]).boolean;

  static final _id_onOptionsItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onOptionsItemSelected", "(Landroid/view/MenuItem;)Z");

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  ///
  /// This hook is called whenever an item in your options menu is selected.
  /// The default implementation simply returns false to have the normal
  /// processing happen (calling the item's Runnable or sending a message to
  /// its Handler as appropriate).  You can use this method for any items
  /// for which you would like to do processing without those other
  /// facilities.
  ///
  /// Derived classes should call through to the base class for it to
  /// perform the default menu handling.
  ///
  ///@param item The menu item that was selected.
  ///@return boolean Return false to allow normal menu processing to
  ///         proceed, true to consume it here.
  ///@see \#onCreateOptionsMenu
  bool onOptionsItemSelected(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onOptionsItemSelected,
          jni.JniType.booleanType, [item.reference]).boolean;

  static final _id_onNavigateUp =
      jniAccessors.getMethodIDOf(_classRef, "onNavigateUp", "()Z");

  /// from: public boolean onNavigateUp()
  ///
  /// This method is called whenever the user chooses to navigate Up within your application's
  /// activity hierarchy from the action bar.
  ///
  /// If the attribute android.R.attr\#parentActivityName parentActivityName
  /// was specified in the manifest for this activity or an activity-alias to it,
  /// default Up navigation will be handled automatically. If any activity
  /// along the parent chain requires extra Intent arguments, the Activity subclass
  /// should override the method \#onPrepareNavigateUpTaskStack(TaskStackBuilder)
  /// to supply those arguments.
  ///
  ///
  /// See <a href="{@docRoot}guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a>
  /// from the developer guide and <a href="{@docRoot}design/patterns/navigation.html">Navigation</a>
  /// from the design guide for more information about navigating within your app.
  ///
  ///
  /// See the TaskStackBuilder class and the Activity methods
  /// \#getParentActivityIntent(), \#shouldUpRecreateTask(Intent), and
  /// \#navigateUpTo(Intent) for help implementing custom Up navigation.
  /// The AppNavigation sample application in the Android SDK is also available for reference.
  ///
  ///@return true if Up navigation completed successfully and this Activity was finished,
  ///         false otherwise.
  bool onNavigateUp() => jniAccessors.callMethodWithArgs(
      reference, _id_onNavigateUp, jni.JniType.booleanType, []).boolean;

  static final _id_onNavigateUpFromChild = jniAccessors.getMethodIDOf(
      _classRef, "onNavigateUpFromChild", "(Landroid/app/Activity;)Z");

  /// from: public boolean onNavigateUpFromChild(android.app.Activity child)
  ///
  /// This is called when a child activity of this one attempts to navigate up.
  /// The default implementation simply calls onNavigateUp() on this activity (the parent).
  ///@param child The activity making the call.
  bool onNavigateUpFromChild(Activity child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onNavigateUpFromChild,
      jni.JniType.booleanType,
      [child.reference]).boolean;

  static final _id_onCreateNavigateUpTaskStack = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateNavigateUpTaskStack",
      "(Landroid/app/TaskStackBuilder;)V");

  /// from: public void onCreateNavigateUpTaskStack(android.app.TaskStackBuilder builder)
  ///
  /// Define the synthetic task stack that will be generated during Up navigation from
  /// a different task.
  ///
  /// The default implementation of this method adds the parent chain of this activity
  /// as specified in the manifest to the supplied TaskStackBuilder. Applications
  /// may choose to override this method to construct the desired task stack in a different
  /// way.
  ///
  ///
  /// This method will be invoked by the default implementation of \#onNavigateUp()
  /// if \#shouldUpRecreateTask(Intent) returns true when supplied with the intent
  /// returned by \#getParentActivityIntent().
  ///
  ///
  /// Applications that wish to supply extra Intent parameters to the parent stack defined
  /// by the manifest should override \#onPrepareNavigateUpTaskStack(TaskStackBuilder).
  ///
  ///@param builder An empty TaskStackBuilder - the application should add intents representing
  ///                the desired task stack
  void onCreateNavigateUpTaskStack(
          taskstackbuilder_.TaskStackBuilder builder) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateNavigateUpTaskStack,
          jni.JniType.voidType,
          [builder.reference]).check();

  static final _id_onPrepareNavigateUpTaskStack = jniAccessors.getMethodIDOf(
      _classRef,
      "onPrepareNavigateUpTaskStack",
      "(Landroid/app/TaskStackBuilder;)V");

  /// from: public void onPrepareNavigateUpTaskStack(android.app.TaskStackBuilder builder)
  ///
  /// Prepare the synthetic task stack that will be generated during Up navigation
  /// from a different task.
  ///
  /// This method receives the TaskStackBuilder with the constructed series of
  /// Intents as generated by \#onCreateNavigateUpTaskStack(TaskStackBuilder).
  /// If any extra data should be added to these intents before launching the new task,
  /// the application should override this method and add that data here.
  ///
  ///@param builder A TaskStackBuilder that has been populated with Intents by
  ///                onCreateNavigateUpTaskStack.
  void onPrepareNavigateUpTaskStack(
          taskstackbuilder_.TaskStackBuilder builder) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPrepareNavigateUpTaskStack,
          jni.JniType.voidType,
          [builder.reference]).check();

  static final _id_onOptionsMenuClosed = jniAccessors.getMethodIDOf(
      _classRef, "onOptionsMenuClosed", "(Landroid/view/Menu;)V");

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  ///
  /// This hook is called whenever the options menu is being closed (either by the user canceling
  /// the menu with the back/menu button, or when an item is selected).
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  void onOptionsMenuClosed(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onOptionsMenuClosed,
      jni.JniType.voidType,
      [menu.reference]).check();

  static final _id_openOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "openOptionsMenu", "()V");

  /// from: public void openOptionsMenu()
  ///
  /// Programmatically opens the options menu. If the options menu is already
  /// open, this method does nothing.
  void openOptionsMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_openOptionsMenu, jni.JniType.voidType, []).check();

  static final _id_closeOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "closeOptionsMenu", "()V");

  /// from: public void closeOptionsMenu()
  ///
  /// Progammatically closes the options menu. If the options menu is already
  /// closed, this method does nothing.
  void closeOptionsMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_closeOptionsMenu, jni.JniType.voidType, []).check();

  static final _id_onCreateContextMenu = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateContextMenu",
      "(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu\$ContextMenuInfo;)V");

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  ///
  /// Called when a context menu for the {@code view} is about to be shown.
  /// Unlike \#onCreateOptionsMenu(Menu), this will be called every
  /// time the context menu is about to be shown and should be populated for
  /// the view (or item inside the view for AdapterView subclasses,
  /// this can be found in the {@code menuInfo})).
  ///
  /// Use \#onContextItemSelected(android.view.MenuItem) to know when an
  /// item has been selected.
  ///
  /// It is not safe to hold onto the context menu after this method returns.
  void onCreateContextMenu(contextmenu_.ContextMenu menu, view_.View v,
          contextmenu_.ContextMenu_ContextMenuInfo menuInfo) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateContextMenu,
          jni.JniType.voidType,
          [menu.reference, v.reference, menuInfo.reference]).check();

  static final _id_registerForContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "registerForContextMenu", "(Landroid/view/View;)V");

  /// from: public void registerForContextMenu(android.view.View view)
  ///
  /// Registers a context menu to be shown for the given view (multiple views
  /// can show the context menu). This method will set the
  /// OnCreateContextMenuListener on the view to this activity, so
  /// \#onCreateContextMenu(ContextMenu, View, ContextMenuInfo) will be
  /// called when it is time to show the context menu.
  ///@see \#unregisterForContextMenu(View)
  ///@param view The view that should show a context menu.
  void registerForContextMenu(view_.View view) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerForContextMenu,
          jni.JniType.voidType, [view.reference]).check();

  static final _id_unregisterForContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "unregisterForContextMenu", "(Landroid/view/View;)V");

  /// from: public void unregisterForContextMenu(android.view.View view)
  ///
  /// Prevents a context menu to be shown for the given view. This method will remove the
  /// OnCreateContextMenuListener on the view.
  ///@see \#registerForContextMenu(View)
  ///@param view The view that should stop showing a context menu.
  void unregisterForContextMenu(view_.View view) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterForContextMenu,
          jni.JniType.voidType, [view.reference]).check();

  static final _id_openContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "openContextMenu", "(Landroid/view/View;)V");

  /// from: public void openContextMenu(android.view.View view)
  ///
  /// Programmatically opens the context menu for a particular {@code view}.
  /// The {@code view} should have been added via
  /// \#registerForContextMenu(View).
  ///@param view The view to show the context menu for.
  void openContextMenu(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_openContextMenu,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_closeContextMenu =
      jniAccessors.getMethodIDOf(_classRef, "closeContextMenu", "()V");

  /// from: public void closeContextMenu()
  ///
  /// Programmatically closes the most recently opened context menu, if showing.
  void closeContextMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_closeContextMenu, jni.JniType.voidType, []).check();

  static final _id_onContextItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onContextItemSelected", "(Landroid/view/MenuItem;)Z");

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  ///
  /// This hook is called whenever an item in a context menu is selected. The
  /// default implementation simply returns false to have the normal processing
  /// happen (calling the item's Runnable or sending a message to its Handler
  /// as appropriate). You can use this method for any items for which you
  /// would like to do processing without those other facilities.
  ///
  /// Use MenuItem\#getMenuInfo() to get extra information set by the
  /// View that added this menu item.
  ///
  /// Derived classes should call through to the base class for it to perform
  /// the default menu handling.
  ///@param item The context menu item that was selected.
  ///@return boolean Return false to allow normal context menu processing to
  ///         proceed, true to consume it here.
  bool onContextItemSelected(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onContextItemSelected,
          jni.JniType.booleanType, [item.reference]).boolean;

  static final _id_onContextMenuClosed = jniAccessors.getMethodIDOf(
      _classRef, "onContextMenuClosed", "(Landroid/view/Menu;)V");

  /// from: public void onContextMenuClosed(android.view.Menu menu)
  ///
  /// This hook is called whenever the context menu is being closed (either by
  /// the user canceling the menu with the back/menu button, or when an item is
  /// selected).
  ///@param menu The context menu that is being closed.
  void onContextMenuClosed(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onContextMenuClosed,
      jni.JniType.voidType,
      [menu.reference]).check();

  static final _id_onCreateDialog = jniAccessors.getMethodIDOf(
      _classRef, "onCreateDialog", "(I)Landroid/app/Dialog;");

  /// from: protected android.app.Dialog onCreateDialog(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Old no-arguments version of \#onCreateDialog(int, Bundle).
  dialog_.Dialog onCreateDialog(int id) =>
      dialog_.Dialog.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCreateDialog, jni.JniType.objectType, [id]).object);

  static final _id_onCreateDialog1 = jniAccessors.getMethodIDOf(_classRef,
      "onCreateDialog", "(ILandroid/os/Bundle;)Landroid/app/Dialog;");

  /// from: protected android.app.Dialog onCreateDialog(int id, android.os.Bundle args)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Callback for creating dialogs that are managed (saved and restored) for you
  /// by the activity.  The default implementation calls through to
  /// \#onCreateDialog(int) for compatibility.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a DialogFragment instead._
  ///
  /// If you use \#showDialog(int), the activity will call through to
  /// this method the first time, and hang onto it thereafter.  Any dialog
  /// that is created by this method will automatically be saved and restored
  /// for you, including whether it is showing.
  ///
  /// If you would like the activity to manage saving and restoring dialogs
  /// for you, you should override this method and handle any ids that are
  /// passed to \#showDialog.
  ///
  /// If you would like an opportunity to prepare your dialog before it is shown,
  /// override \#onPrepareDialog(int, Dialog, Bundle).
  ///@param id The id of the dialog.
  ///@param args The dialog arguments provided to \#showDialog(int, Bundle).
  ///@return The dialog.  If you return null, the dialog will not be created.
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int, Bundle)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  dialog_.Dialog onCreateDialog1(int id, bundle_.Bundle args) =>
      dialog_.Dialog.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateDialog1,
          jni.JniType.objectType,
          [id, args.reference]).object);

  static final _id_onPrepareDialog = jniAccessors.getMethodIDOf(
      _classRef, "onPrepareDialog", "(ILandroid/app/Dialog;)V");

  /// from: protected void onPrepareDialog(int id, android.app.Dialog dialog)
  ///
  /// @deprecated Old no-arguments version of
  /// \#onPrepareDialog(int, Dialog, Bundle).
  void onPrepareDialog(int id, dialog_.Dialog dialog) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrepareDialog,
          jni.JniType.voidType, [id, dialog.reference]).check();

  static final _id_onPrepareDialog1 = jniAccessors.getMethodIDOf(_classRef,
      "onPrepareDialog", "(ILandroid/app/Dialog;Landroid/os/Bundle;)V");

  /// from: protected void onPrepareDialog(int id, android.app.Dialog dialog, android.os.Bundle args)
  ///
  /// Provides an opportunity to prepare a managed dialog before it is being
  /// shown.  The default implementation calls through to
  /// \#onPrepareDialog(int, Dialog) for compatibility.
  ///
  ///
  /// Override this if you need to update a managed dialog based on the state
  /// of the application each time it is shown. For example, a time picker
  /// dialog might want to be updated with the current time. You should call
  /// through to the superclass's implementation. The default implementation
  /// will set this Activity as the owner activity on the Dialog.
  ///@param id The id of the managed dialog.
  ///@param dialog The dialog.
  ///@param args The dialog arguments provided to \#showDialog(int, Bundle).
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#showDialog(int)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void onPrepareDialog1(int id, dialog_.Dialog dialog, bundle_.Bundle args) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrepareDialog1,
          jni.JniType.voidType, [id, dialog.reference, args.reference]).check();

  static final _id_showDialog =
      jniAccessors.getMethodIDOf(_classRef, "showDialog", "(I)V");

  /// from: public final void showDialog(int id)
  ///
  /// Simple version of \#showDialog(int, Bundle) that does not
  /// take any arguments.  Simply calls \#showDialog(int, Bundle)
  /// with null arguments.
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void showDialog(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_showDialog, jni.JniType.voidType, [id]).check();

  static final _id_showDialog1 = jniAccessors.getMethodIDOf(
      _classRef, "showDialog", "(ILandroid/os/Bundle;)Z");

  /// from: public final boolean showDialog(int id, android.os.Bundle args)
  ///
  /// Show a dialog managed by this activity.  A call to \#onCreateDialog(int, Bundle)
  /// will be made with the same id the first time this is called for a given
  /// id.  From thereafter, the dialog will be automatically saved and restored.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a DialogFragment instead._
  ///
  /// Each time a dialog is shown, \#onPrepareDialog(int, Dialog, Bundle) will
  /// be made to provide an opportunity to do any timely preparation.
  ///@param id The id of the managed dialog.
  ///@param args Arguments to pass through to the dialog.  These will be saved
  /// and restored for you.  Note that if the dialog is already created,
  /// \#onCreateDialog(int, Bundle) will not be called with the new
  /// arguments but \#onPrepareDialog(int, Dialog, Bundle) will be.
  /// If you need to rebuild the dialog, call \#removeDialog(int) first.
  ///@return Returns true if the Dialog was created; false is returned if
  /// it is not created because \#onCreateDialog(int, Bundle) returns false.
  ///@see Dialog
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  bool showDialog1(int id, bundle_.Bundle args) =>
      jniAccessors.callMethodWithArgs(reference, _id_showDialog1,
          jni.JniType.booleanType, [id, args.reference]).boolean;

  static final _id_dismissDialog =
      jniAccessors.getMethodIDOf(_classRef, "dismissDialog", "(I)V");

  /// from: public final void dismissDialog(int id)
  ///
  /// Dismiss a dialog that was previously shown via \#showDialog(int).
  ///@param id The id of the managed dialog.
  ///@throws IllegalArgumentException if the id was not previously shown via
  ///   \#showDialog(int).
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void dismissDialog(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_dismissDialog, jni.JniType.voidType, [id]).check();

  static final _id_removeDialog =
      jniAccessors.getMethodIDOf(_classRef, "removeDialog", "(I)V");

  /// from: public final void removeDialog(int id)
  ///
  /// Removes any internal references to a dialog managed by this Activity.
  /// If the dialog is showing, it will dismiss it as part of the clean up.
  ///
  /// This can be useful if you know that you will never show a dialog again and
  /// want to avoid the overhead of saving and restoring it in the future.
  ///
  /// As of android.os.Build.VERSION_CODES\#GINGERBREAD, this function
  /// will not throw an exception if you try to remove an ID that does not
  /// currently have an associated dialog.
  ///
  ///@param id The id of the managed dialog.
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int)
  ///@see \#dismissDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void removeDialog(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_removeDialog, jni.JniType.voidType, [id]).check();

  static final _id_onSearchRequested = jniAccessors.getMethodIDOf(
      _classRef, "onSearchRequested", "(Landroid/view/SearchEvent;)Z");

  /// from: public boolean onSearchRequested(android.view.SearchEvent searchEvent)
  ///
  /// This hook is called when the user signals the desire to start a search.
  ///
  /// You can use this function as a simple way to launch the search UI, in response to a
  /// menu item, search button, or other widgets within your activity. Unless overidden,
  /// calling this function is the same as calling
  /// \#startSearch startSearch(null, false, null, false), which launches
  /// search for the current activity as specified in its manifest, see SearchManager.
  ///
  /// You can override this function to force global search, e.g. in response to a dedicated
  /// search key, or to block search entirely (by simply returning false).
  ///
  /// Note: when running in a Configuration\#UI_MODE_TYPE_TELEVISION or
  /// Configuration\#UI_MODE_TYPE_WATCH, the default implementation changes to simply
  /// return false and you must supply your own custom implementation if you want to support
  /// search.
  ///@param searchEvent The SearchEvent that signaled this search.
  /// This value may be {@code null}.
  ///@return Returns {@code true} if search launched, and {@code false} if the activity does
  /// not respond to search.  The default implementation always returns {@code true}, except
  /// when in Configuration\#UI_MODE_TYPE_TELEVISION mode where it returns false.
  ///@see android.app.SearchManager
  bool onSearchRequested(searchevent_.SearchEvent searchEvent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSearchRequested,
          jni.JniType.booleanType, [searchEvent.reference]).boolean;

  static final _id_onSearchRequested1 =
      jniAccessors.getMethodIDOf(_classRef, "onSearchRequested", "()Z");

  /// from: public boolean onSearchRequested()
  ///
  /// @see \#onSearchRequested(SearchEvent)
  bool onSearchRequested1() => jniAccessors.callMethodWithArgs(
      reference, _id_onSearchRequested1, jni.JniType.booleanType, []).boolean;

  static final _id_getSearchEvent = jniAccessors.getMethodIDOf(
      _classRef, "getSearchEvent", "()Landroid/view/SearchEvent;");

  /// from: public final android.view.SearchEvent getSearchEvent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// During the onSearchRequested() callbacks, this function will return the
  /// SearchEvent that triggered the callback, if it exists.
  ///@return SearchEvent The SearchEvent that triggered the \#onSearchRequested callback.
  searchevent_.SearchEvent getSearchEvent() =>
      searchevent_.SearchEvent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSearchEvent, jni.JniType.objectType, []).object);

  static final _id_startSearch = jniAccessors.getMethodIDOf(
      _classRef, "startSearch", "(Ljava/lang/String;ZLandroid/os/Bundle;Z)V");

  /// from: public void startSearch(java.lang.String initialQuery, boolean selectInitialQuery, android.os.Bundle appSearchData, boolean globalSearch)
  ///
  /// This hook is called to launch the search UI.
  ///
  /// It is typically called from onSearchRequested(), either directly from
  /// Activity.onSearchRequested() or from an overridden version in any given
  /// Activity.  If your goal is simply to activate search, it is preferred to call
  /// onSearchRequested(), which may have been overridden elsewhere in your Activity.  If your goal
  /// is to inject specific data such as context data, it is preferred to <i>override</i>
  /// onSearchRequested(), so that any callers to it will benefit from the override.
  ///
  /// Note: when running in a Configuration\#UI_MODE_TYPE_WATCH, use of this API is
  /// not supported.
  ///@param initialQuery Any non-null non-empty string will be inserted as
  /// pre-entered text in the search query box.
  /// This value may be {@code null}.
  ///@param selectInitialQuery If true, the initial query will be preselected, which means that
  /// any further typing will replace it.  This is useful for cases where an entire pre-formed
  /// query is being inserted.  If false, the selection point will be placed at the end of the
  /// inserted query.  This is useful when the inserted query is text that the user entered,
  /// and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
  /// if initialQuery is a non-empty string.</i>
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  /// This value may be {@code null}.
  ///@param globalSearch If false, this will only launch the search that has been specifically
  /// defined by the application (which is usually defined as a local search).  If no default
  /// search is defined in the current application or activity, global search will be launched.
  /// If true, this will always launch a platform-global (e.g. web-based) search instead.
  ///@see android.app.SearchManager
  ///@see \#onSearchRequested
  void startSearch(jni.JniString initialQuery, bool selectInitialQuery,
          bundle_.Bundle appSearchData, bool globalSearch) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startSearch, jni.JniType.voidType, [
        initialQuery.reference,
        selectInitialQuery,
        appSearchData.reference,
        globalSearch
      ]).check();

  static final _id_triggerSearch = jniAccessors.getMethodIDOf(
      _classRef, "triggerSearch", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void triggerSearch(java.lang.String query, android.os.Bundle appSearchData)
  ///
  /// Similar to \#startSearch, but actually fires off the search query after invoking
  /// the search dialog.  Made available for testing purposes.
  ///@param query The query to trigger.  If empty, the request will be ignored.
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  ///
  /// This value may be {@code null}.
  void triggerSearch(jni.JniString query, bundle_.Bundle appSearchData) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_triggerSearch,
          jni.JniType.voidType,
          [query.reference, appSearchData.reference]).check();

  static final _id_takeKeyEvents =
      jniAccessors.getMethodIDOf(_classRef, "takeKeyEvents", "(Z)V");

  /// from: public void takeKeyEvents(boolean get)
  ///
  /// Request that key events come to this activity. Use this if your
  /// activity has no views with focus, but the activity still wants
  /// a chance to process key events.
  ///@see android.view.Window\#takeKeyEvents
  void takeKeyEvents(bool get0) => jniAccessors.callMethodWithArgs(
      reference, _id_takeKeyEvents, jni.JniType.voidType, [get0]).check();

  static final _id_requestWindowFeature =
      jniAccessors.getMethodIDOf(_classRef, "requestWindowFeature", "(I)Z");

  /// from: public final boolean requestWindowFeature(int featureId)
  ///
  /// Enable extended window features.  This is a convenience for calling
  /// android.view.Window\#requestFeature getWindow().requestFeature().
  ///@param featureId The desired feature as defined in
  ///                  android.view.Window.
  ///@return Returns true if the requested feature is supported and now
  ///         enabled.
  ///@see android.view.Window\#requestFeature
  bool requestWindowFeature(int featureId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestWindowFeature,
      jni.JniType.booleanType,
      [featureId]).boolean;

  static final _id_setFeatureDrawableResource = jniAccessors.getMethodIDOf(
      _classRef, "setFeatureDrawableResource", "(II)V");

  /// from: public final void setFeatureDrawableResource(int featureId, int resId)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableResource.
  void setFeatureDrawableResource(int featureId, int resId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableResource,
          jni.JniType.voidType, [featureId, resId]).check();

  static final _id_setFeatureDrawableUri = jniAccessors.getMethodIDOf(
      _classRef, "setFeatureDrawableUri", "(ILandroid/net/Uri;)V");

  /// from: public final void setFeatureDrawableUri(int featureId, android.net.Uri uri)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableUri.
  void setFeatureDrawableUri(int featureId, uri_.Uri uri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableUri,
          jni.JniType.voidType, [featureId, uri.reference]).check();

  static final _id_setFeatureDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setFeatureDrawable", "(ILandroid/graphics/drawable/Drawable;)V");

  /// from: public final void setFeatureDrawable(int featureId, android.graphics.drawable.Drawable drawable)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawable(int, Drawable).
  void setFeatureDrawable(int featureId, drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawable,
          jni.JniType.voidType, [featureId, drawable.reference]).check();

  static final _id_setFeatureDrawableAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setFeatureDrawableAlpha", "(II)V");

  /// from: public final void setFeatureDrawableAlpha(int featureId, int alpha)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableAlpha.
  void setFeatureDrawableAlpha(int featureId, int alpha) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableAlpha,
          jni.JniType.voidType, [featureId, alpha]).check();

  static final _id_getLayoutInflater = jniAccessors.getMethodIDOf(
      _classRef, "getLayoutInflater", "()Landroid/view/LayoutInflater;");

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for calling
  /// android.view.Window\#getLayoutInflater.
  ///@return This value will never be {@code null}.
  layoutinflater_.LayoutInflater getLayoutInflater() =>
      layoutinflater_.LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLayoutInflater, jni.JniType.objectType, []).object);

  static final _id_getMenuInflater = jniAccessors.getMethodIDOf(
      _classRef, "getMenuInflater", "()Landroid/view/MenuInflater;");

  /// from: public android.view.MenuInflater getMenuInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a MenuInflater with this context.
  ///@return This value will never be {@code null}.
  menuinflater_.MenuInflater getMenuInflater() =>
      menuinflater_.MenuInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMenuInflater, jni.JniType.objectType, []).object);

  static final _id_setTheme =
      jniAccessors.getMethodIDOf(_classRef, "setTheme", "(I)V");

  /// from: public void setTheme(int resid)
  void setTheme(int resid) => jniAccessors.callMethodWithArgs(
      reference, _id_setTheme, jni.JniType.voidType, [resid]).check();

  static final _id_onApplyThemeResource = jniAccessors.getMethodIDOf(_classRef,
      "onApplyThemeResource", "(Landroid/content/res/Resources\$Theme;IZ)V");

  /// from: protected void onApplyThemeResource(android.content.res.Resources.Theme theme, int resid, boolean first)
  void onApplyThemeResource(
          resources_.Resources_Theme theme, int resid, bool first) =>
      jniAccessors.callMethodWithArgs(reference, _id_onApplyThemeResource,
          jni.JniType.voidType, [theme.reference, resid, first]).check();

  static final _id_requestPermissions = jniAccessors.getMethodIDOf(
      _classRef, "requestPermissions", "([Ljava/lang/String;I)V");

  /// from: public final void requestPermissions(java.lang.String[] permissions, int requestCode)
  ///
  /// Requests permissions to be granted to this application. These permissions
  /// must be requested in your manifest, they should not be granted to your app,
  /// and they should have protection level android.content.pm.PermissionInfo \#PROTECTION_DANGEROUS dangerous, regardless whether they are declared by
  /// the platform or a third-party app.
  ///
  /// Normal permissions android.content.pm.PermissionInfo\#PROTECTION_NORMAL
  /// are granted at install time if requested in the manifest. Signature permissions
  /// android.content.pm.PermissionInfo\#PROTECTION_SIGNATURE are granted at
  /// install time if requested in the manifest and the signature of your app matches
  /// the signature of the app declaring the permissions.
  ///
  ///
  ///
  /// If your app does not have the requested permissions the user will be presented
  /// with UI for accepting them. After the user has accepted or rejected the
  /// requested permissions you will receive a callback on \#onRequestPermissionsResult(int, String[], int[]) reporting whether the
  /// permissions were granted or not.
  ///
  ///
  ///
  /// Note that requesting a permission does not guarantee it will be granted and
  /// your app should be able to run without having this permission.
  ///
  ///
  ///
  /// This method may start an activity allowing the user to choose which permissions
  /// to grant and which to reject. Hence, you should be prepared that your activity
  /// may be paused and resumed. Further, granting some permissions may require
  /// a restart of you application. In such a case, the system will recreate the
  /// activity stack before delivering the result to \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// When checking whether you have a permission you should use \#checkSelfPermission(String).
  ///
  ///
  ///
  /// Calling this API for permissions already granted to your app would show UI
  /// to the user to decide whether the app can still hold these permissions. This
  /// can be useful if the way your app uses data guarded by the permissions
  /// changes significantly.
  ///
  ///
  ///
  /// You cannot request a permission if your activity sets android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code> because in this case the activity would not receive
  /// result callbacks including \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// The <a href="http://developer.android.com/samples/RuntimePermissions/index.html">
  /// RuntimePermissions</a> sample app demonstrates how to use this method to
  /// request permissions at run time.
  ///
  ///
  ///@param permissions The requested permissions. Must me non-null and not empty.
  /// This value must never be {@code null}.
  ///@param requestCode Application specific request code to match with a result
  ///    reported to \#onRequestPermissionsResult(int, String[], int[]).
  ///    Should be >= 0.
  ///@throws IllegalArgumentException if requestCode is negative.
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  ///@see \#checkSelfPermission(String)
  ///@see \#shouldShowRequestPermissionRationale(String)
  void requestPermissions(jni.JniObject permissions, int requestCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestPermissions,
          jni.JniType.voidType, [permissions.reference, requestCode]).check();

  static final _id_onRequestPermissionsResult = jniAccessors.getMethodIDOf(
      _classRef, "onRequestPermissionsResult", "(I[Ljava/lang/String;[I)V");

  /// from: public void onRequestPermissionsResult(int requestCode, java.lang.String[] permissions, int[] grantResults)
  ///
  /// Callback for the result from requesting permissions. This method
  /// is invoked for every call on \#requestPermissions(String[], int).
  ///
  /// <strong>Note:</strong> It is possible that the permissions request interaction
  /// with the user is interrupted. In this case you will receive empty permissions
  /// and results arrays which should be treated as a cancellation.
  ///
  ///
  ///@param requestCode The request code passed in \#requestPermissions(String[], int).
  ///@param permissions The requested permissions. Never null.
  /// This value must never be {@code null}.
  ///@param grantResults The grant results for the corresponding permissions
  ///     which is either android.content.pm.PackageManager\#PERMISSION_GRANTED
  ///     or android.content.pm.PackageManager\#PERMISSION_DENIED. Never null.
  ///
  /// This value must never be {@code null}.
  ///@see \#requestPermissions(String[], int)
  void onRequestPermissionsResult(int requestCode, jni.JniObject permissions,
          jni.JniObject grantResults) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRequestPermissionsResult,
          jni.JniType.voidType,
          [requestCode, permissions.reference, grantResults.reference]).check();

  static final _id_shouldShowRequestPermissionRationale =
      jniAccessors.getMethodIDOf(_classRef,
          "shouldShowRequestPermissionRationale", "(Ljava/lang/String;)Z");

  /// from: public boolean shouldShowRequestPermissionRationale(java.lang.String permission)
  ///
  /// Gets whether you should show UI with rationale for requesting a permission.
  /// You should do this only if you do not have the permission and the context in
  /// which the permission is requested does not clearly communicate to the user
  /// what would be the benefit from granting this permission.
  ///
  /// For example, if you write a camera app, requesting the camera permission
  /// would be expected by the user and no rationale for why it is requested is
  /// needed. If however, the app needs location for tagging photos then a non-tech
  /// savvy user may wonder how location is related to taking photos. In this case
  /// you may choose to show UI with rationale of requesting this permission.
  ///
  ///
  ///@param permission A permission your app wants to request.
  /// This value must never be {@code null}.
  ///@return Whether you can show permission rationale UI.
  ///@see \#checkSelfPermission(String)
  ///@see \#requestPermissions(String[], int)
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  bool shouldShowRequestPermissionRationale(jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_shouldShowRequestPermissionRationale,
          jni.JniType.booleanType,
          [permission.reference]).boolean;

  static final _id_startActivityForResult = jniAccessors.getMethodIDOf(
      _classRef, "startActivityForResult", "(Landroid/content/Intent;I)V");

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode)
  ///
  /// Same as calling \#startActivityForResult(Intent, int, Bundle)
  /// with no options.
  ///@param intent The intent to start.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  void startActivityForResult(intent_.Intent intent, int requestCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivityForResult,
          jni.JniType.voidType, [intent.reference, requestCode]).check();

  static final _id_startActivityForResult1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivityForResult",
      "(Landroid/content/Intent;ILandroid/os/Bundle;)V");

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// Launch an activity for which you would like a result when it finished.
  /// When this activity exits, your
  /// onActivityResult() method will be called with the given requestCode.
  /// Using a negative requestCode is the same as calling
  /// \#startActivity (the activity is not launched as a sub-activity).
  ///
  /// Note that this method should only be used with Intent protocols
  /// that are defined to return a result.  In other protocols (such as
  /// Intent\#ACTION_MAIN or Intent\#ACTION_VIEW), you may
  /// not get the result when you expect.  For example, if the activity you
  /// are launching uses Intent\#FLAG_ACTIVITY_NEW_TASK, it will not
  /// run in your task and thus you will immediately receive a cancel result.
  ///
  /// As a special case, if you call startActivityForResult() with a requestCode
  /// >= 0 during the initial onCreate(Bundle savedInstanceState)/onResume() of your
  /// activity, then your window will not be displayed until a result is
  /// returned back from the started activity.  This is to avoid visible
  /// flickering when redirecting to another activity.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intent The intent to start.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  void startActivityForResult1(
          intent_.Intent intent, int requestCode, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivityForResult1,
          jni.JniType.voidType,
          [intent.reference, requestCode, options.reference]).check();

  static final _id_isActivityTransitionRunning = jniAccessors.getMethodIDOf(
      _classRef, "isActivityTransitionRunning", "()Z");

  /// from: public boolean isActivityTransitionRunning()
  ///
  /// Returns whether there are any activity transitions currently running on this
  /// activity. A return value of {@code true} can mean that either an enter or
  /// exit transition is running, including whether the background of the activity
  /// is animating as a part of that transition.
  ///@return true if a transition is currently running on this activity, false otherwise.
  bool isActivityTransitionRunning() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isActivityTransitionRunning,
      jni.JniType.booleanType, []).boolean;

  static final _id_startIntentSenderForResult = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSenderForResult",
      "(Landroid/content/IntentSender;ILandroid/content/Intent;III)V");

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  ///
  /// Same as calling \#startIntentSenderForResult(IntentSender, int,
  /// Intent, int, int, int, Bundle) with no options.
  ///@param intent The IntentSender to launch.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  void startIntentSenderForResult(
          intentsender_.IntentSender intent,
          int requestCode,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSenderForResult, jni.JniType.voidType, [
        intent.reference,
        requestCode,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags
      ]).check();

  static final _id_startIntentSenderForResult1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSenderForResult",
      "(Landroid/content/IntentSender;ILandroid/content/Intent;IIILandroid/os/Bundle;)V");

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Like \#startActivityForResult(Intent, int), but allowing you
  /// to use a IntentSender to describe the activity to be started.  If
  /// the IntentSender is for an activity, that activity will be started
  /// as if you had called the regular \#startActivityForResult(Intent, int)
  /// here; otherwise, its associated action will be executed (such as
  /// sending a broadcast) as if you had called
  /// IntentSender\#sendIntent IntentSender.sendIntent on it.
  ///@param intent The IntentSender to launch.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.  If options
  /// have also been supplied by the IntentSender, options given here will
  /// override any that conflict with those given by the IntentSender.
  void startIntentSenderForResult1(
          intentsender_.IntentSender intent,
          int requestCode,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSenderForResult1, jni.JniType.voidType, [
        intent.reference,
        requestCode,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags,
        options.reference
      ]).check();

  static final _id_startActivity2 = jniAccessors.getMethodIDOf(
      _classRef, "startActivity", "(Landroid/content/Intent;)V");

  /// from: public void startActivity(android.content.Intent intent)
  ///
  /// Same as \#startActivity(Intent, Bundle) with no options
  /// specified.
  ///@param intent The intent to start.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity(Intent, Bundle)
  ///@see \#startActivityForResult
  void startActivity2(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_startActivity2,
      jni.JniType.voidType,
      [intent.reference]).check();

  static final _id_startActivity3 = jniAccessors.getMethodIDOf(_classRef,
      "startActivity", "(Landroid/content/Intent;Landroid/os/Bundle;)V");

  /// from: public void startActivity(android.content.Intent intent, android.os.Bundle options)
  ///
  /// Launch a new activity.  You will not receive any information about when
  /// the activity exits.  This implementation overrides the base version,
  /// providing information about
  /// the activity performing the launch.  Because of this additional
  /// information, the Intent\#FLAG_ACTIVITY_NEW_TASK launch flag is not
  /// required; if not specified, the new activity will be added to the
  /// task of the caller.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intent The intent to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity(Intent)
  ///@see \#startActivityForResult
  void startActivity3(intent_.Intent intent, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivity3,
          jni.JniType.voidType, [intent.reference, options.reference]).check();

  static final _id_startActivities2 = jniAccessors.getMethodIDOf(
      _classRef, "startActivities", "([Landroid/content/Intent;)V");

  /// from: public void startActivities(android.content.Intent[] intents)
  ///
  /// Same as \#startActivities(Intent[], Bundle) with no options
  /// specified.
  ///@param intents The intents to start.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivities(Intent[], Bundle)
  ///@see \#startActivityForResult
  void startActivities2(jni.JniObject intents) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivities2,
          jni.JniType.voidType, [intents.reference]).check();

  static final _id_startActivities3 = jniAccessors.getMethodIDOf(_classRef,
      "startActivities", "([Landroid/content/Intent;Landroid/os/Bundle;)V");

  /// from: public void startActivities(android.content.Intent[] intents, android.os.Bundle options)
  ///
  /// Launch a new activity.  You will not receive any information about when
  /// the activity exits.  This implementation overrides the base version,
  /// providing information about
  /// the activity performing the launch.  Because of this additional
  /// information, the Intent\#FLAG_ACTIVITY_NEW_TASK launch flag is not
  /// required; if not specified, the new activity will be added to the
  /// task of the caller.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intents The intents to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivities(Intent[])
  ///@see \#startActivityForResult
  void startActivities3(jni.JniObject intents, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivities3,
          jni.JniType.voidType, [intents.reference, options.reference]).check();

  static final _id_startIntentSender2 = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSender",
      "(Landroid/content/IntentSender;Landroid/content/Intent;III)V");

  /// from: public void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  ///
  /// Same as calling \#startIntentSender(IntentSender, Intent, int, int, int, Bundle)
  /// with no options.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  void startIntentSender2(
          intentsender_.IntentSender intent,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSender2, jni.JniType.voidType, [
        intent.reference,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags
      ]).check();

  static final _id_startIntentSender3 = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSender",
      "(Landroid/content/IntentSender;Landroid/content/Intent;IIILandroid/os/Bundle;)V");

  /// from: public void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Like \#startActivity(Intent, Bundle), but taking a IntentSender
  /// to start; see
  /// \#startIntentSenderForResult(IntentSender, int, Intent, int, int, int, Bundle)
  /// for more information.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.  If options
  /// have also been supplied by the IntentSender, options given here will
  /// override any that conflict with those given by the IntentSender.
  void startIntentSender3(
          intentsender_.IntentSender intent,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSender3, jni.JniType.voidType, [
        intent.reference,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags,
        options.reference
      ]).check();

  static final _id_startActivityIfNeeded = jniAccessors.getMethodIDOf(
      _classRef, "startActivityIfNeeded", "(Landroid/content/Intent;I)Z");

  /// from: public boolean startActivityIfNeeded(android.content.Intent intent, int requestCode)
  ///
  /// Same as calling \#startActivityIfNeeded(Intent, int, Bundle)
  /// with no options.
  ///@param intent The intent to start.
  /// This value must never be {@code null}.
  ///@param requestCode If >= 0, this code will be returned in
  ///         onActivityResult() when the activity exits, as described in
  ///         \#startActivityForResult.
  ///@return If a new activity was launched then true is returned; otherwise
  ///         false is returned and you must handle the Intent yourself.
  ///@see \#startActivity
  ///@see \#startActivityForResult
  bool startActivityIfNeeded(intent_.Intent intent, int requestCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivityIfNeeded,
          jni.JniType.booleanType, [intent.reference, requestCode]).boolean;

  static final _id_startActivityIfNeeded1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivityIfNeeded",
      "(Landroid/content/Intent;ILandroid/os/Bundle;)Z");

  /// from: public boolean startActivityIfNeeded(android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// A special variation to launch an activity only if a new activity
  /// instance is needed to handle the given Intent.  In other words, this is
  /// just like \#startActivityForResult(Intent, int) except: if you are
  /// using the Intent\#FLAG_ACTIVITY_SINGLE_TOP flag, or
  /// singleTask or singleTop
  /// android.R.styleable\#AndroidManifestActivity_launchMode launchMode,
  /// and the activity
  /// that handles <var>intent</var> is the same as your currently running
  /// activity, then a new instance is not needed.  In this case, instead of
  /// the normal behavior of calling \#onNewIntent this function will
  /// return and you can handle the Intent yourself.
  ///
  /// This function can only be called from a top-level activity; if it is
  /// called from a child activity, a runtime exception will be thrown.
  ///@param intent The intent to start.
  /// This value must never be {@code null}.
  ///@param requestCode If >= 0, this code will be returned in
  ///         onActivityResult() when the activity exits, as described in
  ///         \#startActivityForResult.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@return If a new activity was launched then true is returned; otherwise
  ///         false is returned and you must handle the Intent yourself.
  ///@see \#startActivity
  ///@see \#startActivityForResult
  bool startActivityIfNeeded1(
          intent_.Intent intent, int requestCode, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivityIfNeeded1,
          jni.JniType.booleanType,
          [intent.reference, requestCode, options.reference]).boolean;

  static final _id_startNextMatchingActivity = jniAccessors.getMethodIDOf(
      _classRef, "startNextMatchingActivity", "(Landroid/content/Intent;)Z");

  /// from: public boolean startNextMatchingActivity(android.content.Intent intent)
  ///
  /// Same as calling \#startNextMatchingActivity(Intent, Bundle) with
  /// no options.
  ///@param intent The intent to dispatch to the next activity.  For
  /// correct behavior, this must be the same as the Intent that started
  /// your own activity; the only changes you can make are to the extras
  /// inside of it.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a boolean indicating whether there was another Activity
  /// to start: true if there was a next activity to start, false if there
  /// wasn't.  In general, if true is returned you will then want to call
  /// finish() on yourself.
  bool startNextMatchingActivity(intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_startNextMatchingActivity,
          jni.JniType.booleanType, [intent.reference]).boolean;

  static final _id_startNextMatchingActivity1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startNextMatchingActivity",
      "(Landroid/content/Intent;Landroid/os/Bundle;)Z");

  /// from: public boolean startNextMatchingActivity(android.content.Intent intent, android.os.Bundle options)
  ///
  /// Special version of starting an activity, for use when you are replacing
  /// other activity components.  You can use this to hand the Intent off
  /// to the next Activity that can handle it.  You typically call this in
  /// \#onCreate with the Intent returned by \#getIntent.
  ///@param intent The intent to dispatch to the next activity.  For
  /// correct behavior, this must be the same as the Intent that started
  /// your own activity; the only changes you can make are to the extras
  /// inside of it.
  /// This value must never be {@code null}.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@return Returns a boolean indicating whether there was another Activity
  /// to start: true if there was a next activity to start, false if there
  /// wasn't.  In general, if true is returned you will then want to call
  /// finish() on yourself.
  bool startNextMatchingActivity1(
          intent_.Intent intent, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startNextMatchingActivity1,
          jni.JniType.booleanType,
          [intent.reference, options.reference]).boolean;

  static final _id_startActivityFromChild = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivityFromChild",
      "(Landroid/app/Activity;Landroid/content/Intent;I)V");

  /// from: public void startActivityFromChild(android.app.Activity child, android.content.Intent intent, int requestCode)
  ///
  /// Same as calling \#startActivityFromChild(Activity, Intent, int, Bundle)
  /// with no options.
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  ///@see \#startActivityForResult
  void startActivityFromChild(
          Activity child, intent_.Intent intent, int requestCode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivityFromChild,
          jni.JniType.voidType,
          [child.reference, intent.reference, requestCode]).check();

  static final _id_startActivityFromChild1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivityFromChild",
      "(Landroid/app/Activity;Landroid/content/Intent;ILandroid/os/Bundle;)V");

  /// from: public void startActivityFromChild(android.app.Activity child, android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// This is called when a child activity of this one calls its
  /// \#startActivity or \#startActivityForResult method.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  ///@see \#startActivityForResult
  void startActivityFromChild1(Activity child, intent_.Intent intent,
          int requestCode, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startActivityFromChild1, jni.JniType.voidType, [
        child.reference,
        intent.reference,
        requestCode,
        options.reference
      ]).check();

  static final _id_startActivityFromFragment = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivityFromFragment",
      "(Landroid/app/Fragment;Landroid/content/Intent;I)V");

  /// from: public void startActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int requestCode)
  ///
  /// Same as calling \#startActivityFromFragment(Fragment, Intent, int, Bundle)
  /// with no options.
  ///@param fragment The fragment making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@throws android.content.ActivityNotFoundException
  ///@see Fragment\#startActivity
  ///@see Fragment\#startActivityForResult
  ///@deprecated Use android.support.v4.app.FragmentActivity\#startActivityFromFragment(
  /// android.support.v4.app.Fragment,Intent,int)
  void startActivityFromFragment(fragment_.Fragment fragment,
          intent_.Intent intent, int requestCode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivityFromFragment,
          jni.JniType.voidType,
          [fragment.reference, intent.reference, requestCode]).check();

  static final _id_startActivityFromFragment1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivityFromFragment",
      "(Landroid/app/Fragment;Landroid/content/Intent;ILandroid/os/Bundle;)V");

  /// from: public void startActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// This is called when a Fragment in this activity calls its
  /// Fragment\#startActivity or Fragment\#startActivityForResult
  /// method.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param fragment The fragment making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see Fragment\#startActivity
  ///@see Fragment\#startActivityForResult
  ///@deprecated Use android.support.v4.app.FragmentActivity\#startActivityFromFragment(
  /// android.support.v4.app.Fragment,Intent,int,Bundle)
  void startActivityFromFragment1(fragment_.Fragment fragment,
          intent_.Intent intent, int requestCode, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startActivityFromFragment1, jni.JniType.voidType, [
        fragment.reference,
        intent.reference,
        requestCode,
        options.reference
      ]).check();

  static final _id_startIntentSenderFromChild = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSenderFromChild",
      "(Landroid/app/Activity;Landroid/content/IntentSender;ILandroid/content/Intent;III)V");

  /// from: public void startIntentSenderFromChild(android.app.Activity child, android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  ///
  /// Same as calling \#startIntentSenderFromChild(Activity, IntentSender,
  /// int, Intent, int, int, int, Bundle) with no options.
  void startIntentSenderFromChild(
          Activity child,
          intentsender_.IntentSender intent,
          int requestCode,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSenderFromChild, jni.JniType.voidType, [
        child.reference,
        intent.reference,
        requestCode,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags
      ]).check();

  static final _id_startIntentSenderFromChild1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSenderFromChild",
      "(Landroid/app/Activity;Landroid/content/IntentSender;ILandroid/content/Intent;IIILandroid/os/Bundle;)V");

  /// from: public void startIntentSenderFromChild(android.app.Activity child, android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Like \#startActivityFromChild(Activity, Intent, int), but
  /// taking a IntentSender; see
  /// \#startIntentSenderForResult(IntentSender, int, Intent, int, int, int)
  /// for more information.
  ///@param options This value may be {@code null}.
  void startIntentSenderFromChild1(
          Activity child,
          intentsender_.IntentSender intent,
          int requestCode,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSenderFromChild1, jni.JniType.voidType, [
        child.reference,
        intent.reference,
        requestCode,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags,
        options.reference
      ]).check();

  static final _id_overridePendingTransition = jniAccessors.getMethodIDOf(
      _classRef, "overridePendingTransition", "(II)V");

  /// from: public void overridePendingTransition(int enterAnim, int exitAnim)
  ///
  /// Call immediately after one of the flavors of \#startActivity(Intent)
  /// or \#finish to specify an explicit transition animation to
  /// perform next.
  ///
  /// As of android.os.Build.VERSION_CODES\#JELLY_BEAN an alternative
  /// to using this with starting activities is to supply the desired animation
  /// information through a ActivityOptions bundle to
  /// \#startActivity(Intent, Bundle) or a related function.  This allows
  /// you to specify a custom animation even when starting an activity from
  /// outside the context of the current top activity.
  ///@param enterAnim A resource ID of the animation resource to use for
  /// the incoming activity.  Use 0 for no animation.
  ///@param exitAnim A resource ID of the animation resource to use for
  /// the outgoing activity.  Use 0 for no animation.
  void overridePendingTransition(int enterAnim, int exitAnim) =>
      jniAccessors.callMethodWithArgs(reference, _id_overridePendingTransition,
          jni.JniType.voidType, [enterAnim, exitAnim]).check();

  static final _id_setResult =
      jniAccessors.getMethodIDOf(_classRef, "setResult", "(I)V");

  /// from: public final void setResult(int resultCode)
  ///
  /// Call this to set the result that your activity will return to its
  /// caller.
  ///@param resultCode The result code to propagate back to the originating
  ///                   activity, often RESULT_CANCELED or RESULT_OK
  ///@see \#RESULT_CANCELED
  ///@see \#RESULT_OK
  ///@see \#RESULT_FIRST_USER
  ///@see \#setResult(int, Intent)
  void setResult(int resultCode) => jniAccessors.callMethodWithArgs(
      reference, _id_setResult, jni.JniType.voidType, [resultCode]).check();

  static final _id_setResult1 = jniAccessors.getMethodIDOf(
      _classRef, "setResult", "(ILandroid/content/Intent;)V");

  /// from: public final void setResult(int resultCode, android.content.Intent data)
  ///
  /// Call this to set the result that your activity will return to its
  /// caller.
  ///
  /// As of android.os.Build.VERSION_CODES\#GINGERBREAD, the Intent
  /// you supply here can have Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION set.  This will grant the
  /// Activity receiving the result access to the specific URIs in the Intent.
  /// Access will remain until the Activity has finished (it will remain across the hosting
  /// process being killed and other temporary destruction) and will be added
  /// to any existing set of URI permissions it already holds.
  ///@param resultCode The result code to propagate back to the originating
  ///                   activity, often RESULT_CANCELED or RESULT_OK
  ///@param data The data to propagate back to the originating activity.
  ///@see \#RESULT_CANCELED
  ///@see \#RESULT_OK
  ///@see \#RESULT_FIRST_USER
  ///@see \#setResult(int)
  void setResult1(int resultCode, intent_.Intent data) =>
      jniAccessors.callMethodWithArgs(reference, _id_setResult1,
          jni.JniType.voidType, [resultCode, data.reference]).check();

  static final _id_getReferrer = jniAccessors.getMethodIDOf(
      _classRef, "getReferrer", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getReferrer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return information about who launched this activity.  If the launching Intent
  /// contains an android.content.Intent\#EXTRA_REFERRER Intent.EXTRA_REFERRER,
  /// that will be returned as-is; otherwise, if known, an
  /// Intent\#URI_ANDROID_APP_SCHEME android-app: referrer URI containing the
  /// package name that started the Intent will be returned.  This may return null if no
  /// referrer can be identified -- it is neither explicitly specified, nor is it known which
  /// application package was involved.
  ///
  /// If called while inside the handling of \#onNewIntent, this function will
  /// return the referrer that submitted that new intent to the activity.  Otherwise, it
  /// always returns the referrer of the original Intent.
  ///
  ///
  /// Note that this is _not_ a security feature -- you can not trust the
  /// referrer information, applications can spoof it.
  ///
  uri_.Uri getReferrer() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getReferrer, jni.JniType.objectType, []).object);

  static final _id_onProvideReferrer = jniAccessors.getMethodIDOf(
      _classRef, "onProvideReferrer", "()Landroid/net/Uri;");

  /// from: public android.net.Uri onProvideReferrer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override to generate the desired referrer for the content currently being shown
  /// by the app.  The default implementation returns null, meaning the referrer will simply
  /// be the android-app: of the package name of this activity.  Return a non-null Uri to
  /// have that supplied as the Intent\#EXTRA_REFERRER of any activities started from it.
  uri_.Uri onProvideReferrer() =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onProvideReferrer, jni.JniType.objectType, []).object);

  static final _id_getCallingPackage = jniAccessors.getMethodIDOf(
      _classRef, "getCallingPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getCallingPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the package that invoked this activity.  This is who
  /// the data in \#setResult setResult() will be sent to.  You can
  /// use this information to validate that the recipient is allowed to
  /// receive the data.
  ///
  /// <p class="note">Note: if the calling activity is not expecting a result (that is it
  /// did not use the \#startActivityForResult
  /// form that includes a request code), then the calling package will be
  /// null.
  ///
  ///
  /// <p class="note">Note: prior to android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  /// the result from this method was unstable.  If the process hosting the calling
  /// package was no longer running, it would return null instead of the proper package
  /// name.  You can use \#getCallingActivity() and retrieve the package name
  /// from that instead.
  ///
  ///@return The package of the activity that will receive your
  ///         reply, or null if none.
  jni.JniString getCallingPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallingPackage, jni.JniType.objectType, []).object);

  static final _id_getCallingActivity = jniAccessors.getMethodIDOf(
      _classRef, "getCallingActivity", "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getCallingActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the activity that invoked this activity.  This is
  /// who the data in \#setResult setResult() will be sent to.  You
  /// can use this information to validate that the recipient is allowed to
  /// receive the data.
  ///
  /// <p class="note">Note: if the calling activity is not expecting a result (that is it
  /// did not use the \#startActivityForResult
  /// form that includes a request code), then the calling package will be
  /// null.
  ///@return The ComponentName of the activity that will receive your
  ///         reply, or null if none.
  componentname_.ComponentName getCallingActivity() =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCallingActivity,
          jni.JniType.objectType, []).object);

  static final _id_setVisible =
      jniAccessors.getMethodIDOf(_classRef, "setVisible", "(Z)V");

  /// from: public void setVisible(boolean visible)
  ///
  /// Control whether this activity's main window is visible.  This is intended
  /// only for the special case of an activity that is not going to show a
  /// UI itself, but can't just finish prior to onResume() because it needs
  /// to wait for a service binding or such.  Setting this to false allows
  /// you to prevent your UI from being shown during that time.
  ///
  /// The default value for this is taken from the
  /// android.R.attr\#windowNoDisplay attribute of the activity's theme.
  void setVisible(bool visible) => jniAccessors.callMethodWithArgs(
      reference, _id_setVisible, jni.JniType.voidType, [visible]).check();

  static final _id_isFinishing =
      jniAccessors.getMethodIDOf(_classRef, "isFinishing", "()Z");

  /// from: public boolean isFinishing()
  ///
  /// Check to see whether this activity is in the process of finishing,
  /// either because you called \#finish on it or someone else
  /// has requested that it finished.  This is often used in
  /// \#onPause to determine whether the activity is simply pausing or
  /// completely finishing.
  ///@return If the activity is finishing, returns true; else returns false.
  ///@see \#finish
  bool isFinishing() => jniAccessors.callMethodWithArgs(
      reference, _id_isFinishing, jni.JniType.booleanType, []).boolean;

  static final _id_isDestroyed =
      jniAccessors.getMethodIDOf(_classRef, "isDestroyed", "()Z");

  /// from: public boolean isDestroyed()
  ///
  /// Returns true if the final \#onDestroy() call has been made
  /// on the Activity, so this instance is now dead.
  bool isDestroyed() => jniAccessors.callMethodWithArgs(
      reference, _id_isDestroyed, jni.JniType.booleanType, []).boolean;

  static final _id_isChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "isChangingConfigurations", "()Z");

  /// from: public boolean isChangingConfigurations()
  ///
  /// Check to see whether this activity is in the process of being destroyed in order to be
  /// recreated with a new configuration. This is often used in
  /// \#onStop to determine whether the state needs to be cleaned up or will be passed
  /// on to the next instance of the activity via \#onRetainNonConfigurationInstance().
  ///@return If the activity is being torn down in order to be recreated with a new configuration,
  /// returns true; else returns false.
  bool isChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_isChangingConfigurations, jni.JniType.booleanType, []).boolean;

  static final _id_recreate =
      jniAccessors.getMethodIDOf(_classRef, "recreate", "()V");

  /// from: public void recreate()
  ///
  /// Cause this Activity to be recreated with a new instance.  This results
  /// in essentially the same flow as when the Activity is created due to
  /// a configuration change -- the current instance will go through its
  /// lifecycle to \#onDestroy and a new instance then created after it.
  void recreate() => jniAccessors.callMethodWithArgs(
      reference, _id_recreate, jni.JniType.voidType, []).check();

  static final _id_finish =
      jniAccessors.getMethodIDOf(_classRef, "finish", "()V");

  /// from: public void finish()
  ///
  /// Call this when your activity is done and should be closed.  The
  /// ActivityResult is propagated back to whoever launched you via
  /// onActivityResult().
  void finish() => jniAccessors.callMethodWithArgs(
      reference, _id_finish, jni.JniType.voidType, []).check();

  static final _id_finishAffinity =
      jniAccessors.getMethodIDOf(_classRef, "finishAffinity", "()V");

  /// from: public void finishAffinity()
  ///
  /// Finish this activity as well as all activities immediately below it
  /// in the current task that have the same affinity.  This is typically
  /// used when an application can be launched on to another task (such as
  /// from an ACTION_VIEW of a content type it understands) and the user
  /// has used the up navigation to switch out of the current task and in
  /// to its own task.  In this case, if the user has navigated down into
  /// any other activities of the second application, all of those should
  /// be removed from the original task as part of the task switch.
  ///
  /// Note that this finish does _not_ allow you to deliver results
  /// to the previous activity, and an exception will be thrown if you are trying
  /// to do so.
  ///
  void finishAffinity() => jniAccessors.callMethodWithArgs(
      reference, _id_finishAffinity, jni.JniType.voidType, []).check();

  static final _id_finishFromChild = jniAccessors.getMethodIDOf(
      _classRef, "finishFromChild", "(Landroid/app/Activity;)V");

  /// from: public void finishFromChild(android.app.Activity child)
  ///
  /// This is called when a child activity of this one calls its
  /// \#finish method.  The default implementation simply calls
  /// finish() on this activity (the parent), finishing the entire group.
  ///@param child The activity making the call.
  ///@see \#finish
  void finishFromChild(Activity child) => jniAccessors.callMethodWithArgs(
      reference,
      _id_finishFromChild,
      jni.JniType.voidType,
      [child.reference]).check();

  static final _id_finishAfterTransition =
      jniAccessors.getMethodIDOf(_classRef, "finishAfterTransition", "()V");

  /// from: public void finishAfterTransition()
  ///
  /// Reverses the Activity Scene entry Transition and triggers the calling Activity
  /// to reverse its exit Transition. When the exit Transition completes,
  /// \#finish() is called. If no entry Transition was used, finish() is called
  /// immediately and the Activity exit Transition is run.
  ///@see android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity, android.util.Pair[])
  void finishAfterTransition() => jniAccessors.callMethodWithArgs(
      reference, _id_finishAfterTransition, jni.JniType.voidType, []).check();

  static final _id_finishActivity =
      jniAccessors.getMethodIDOf(_classRef, "finishActivity", "(I)V");

  /// from: public void finishActivity(int requestCode)
  ///
  /// Force finish another activity that you had previously started with
  /// \#startActivityForResult.
  ///@param requestCode The request code of the activity that you had
  ///                    given to startActivityForResult().  If there are multiple
  ///                    activities started with this request code, they
  ///                    will all be finished.
  void finishActivity(int requestCode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_finishActivity,
      jni.JniType.voidType,
      [requestCode]).check();

  static final _id_finishActivityFromChild = jniAccessors.getMethodIDOf(
      _classRef, "finishActivityFromChild", "(Landroid/app/Activity;I)V");

  /// from: public void finishActivityFromChild(android.app.Activity child, int requestCode)
  ///
  /// This is called when a child activity of this one calls its
  /// finishActivity().
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param requestCode Request code that had been used to start the
  ///                    activity.
  void finishActivityFromChild(Activity child, int requestCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_finishActivityFromChild,
          jni.JniType.voidType, [child.reference, requestCode]).check();

  static final _id_finishAndRemoveTask =
      jniAccessors.getMethodIDOf(_classRef, "finishAndRemoveTask", "()V");

  /// from: public void finishAndRemoveTask()
  ///
  /// Call this when your activity is done and should be closed and the task should be completely
  /// removed as a part of finishing the root activity of the task.
  void finishAndRemoveTask() => jniAccessors.callMethodWithArgs(
      reference, _id_finishAndRemoveTask, jni.JniType.voidType, []).check();

  static final _id_releaseInstance =
      jniAccessors.getMethodIDOf(_classRef, "releaseInstance", "()Z");

  /// from: public boolean releaseInstance()
  ///
  /// Ask that the local app instance of this activity be released to free up its memory.
  /// This is asking for the activity to be destroyed, but does __not__ finish the activity --
  /// a new instance of the activity will later be re-created if needed due to the user
  /// navigating back to it.
  ///@return Returns true if the activity was in a state that it has started the process
  /// of destroying its current instance; returns false if for any reason this could not
  /// be done: it is currently visible to the user, it is already being destroyed, it is
  /// being finished, it hasn't yet saved its state, etc.
  bool releaseInstance() => jniAccessors.callMethodWithArgs(
      reference, _id_releaseInstance, jni.JniType.booleanType, []).boolean;

  static final _id_onActivityResult = jniAccessors.getMethodIDOf(
      _classRef, "onActivityResult", "(IILandroid/content/Intent;)V");

  /// from: protected void onActivityResult(int requestCode, int resultCode, android.content.Intent data)
  ///
  /// Called when an activity you launched exits, giving you the requestCode
  /// you started it with, the resultCode it returned, and any additional
  /// data from it.  The <var>resultCode</var> will be
  /// \#RESULT_CANCELED if the activity explicitly returned that,
  /// didn't return any result, or crashed during its operation.
  ///
  /// You will receive this call immediately before onResume() when your
  /// activity is re-starting.
  ///
  /// This method is never invoked if your activity sets
  /// android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code>.
  ///@param requestCode The integer request code originally supplied to
  ///                    startActivityForResult(), allowing you to identify who this
  ///                    result came from.
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  ///@see \#startActivityForResult
  ///@see \#createPendingResult
  ///@see \#setResult(int)
  void onActivityResult(int requestCode, int resultCode, intent_.Intent data) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onActivityResult,
          jni.JniType.voidType,
          [requestCode, resultCode, data.reference]).check();

  static final _id_onActivityReenter = jniAccessors.getMethodIDOf(
      _classRef, "onActivityReenter", "(ILandroid/content/Intent;)V");

  /// from: public void onActivityReenter(int resultCode, android.content.Intent data)
  ///
  /// Called when an activity you launched with an activity transition exposes this
  /// Activity through a returning activity transition, giving you the resultCode
  /// and any additional data from it. This method will only be called if the activity
  /// set a result code other than \#RESULT_CANCELED and it supports activity
  /// transitions with Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///
  /// The purpose of this function is to let the called Activity send a hint about
  /// its state so that this underlying Activity can prepare to be exposed. A call to
  /// this method does not guarantee that the called Activity has or will be exiting soon.
  /// It only indicates that it will expose this Activity's Window and it has
  /// some data to pass to prepare it.
  ///
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  void onActivityReenter(int resultCode, intent_.Intent data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActivityReenter,
          jni.JniType.voidType, [resultCode, data.reference]).check();

  static final _id_createPendingResult = jniAccessors.getMethodIDOf(
      _classRef,
      "createPendingResult",
      "(ILandroid/content/Intent;I)Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent createPendingResult(int requestCode, android.content.Intent data, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new PendingIntent object which you can hand to others
  /// for them to use to send result data back to your
  /// \#onActivityResult callback.  The created object will be either
  /// one-shot (becoming invalid after a result is sent back) or multiple
  /// (allowing any number of results to be sent through it).
  ///@param requestCode Private request code for the sender that will be
  /// associated with the result data when it is returned.  The sender can not
  /// modify this value, allowing you to identify incoming results.
  ///@param data Default data to supply in the result, which may be modified
  /// by the sender.
  /// This value must never be {@code null}.
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT,
  /// PendingIntent\#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE,
  /// PendingIntent\#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT,
  /// PendingIntent\#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if
  /// PendingIntent\#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE has been
  /// supplied.
  ///@see PendingIntent
  pendingintent_.PendingIntent createPendingResult(
          int requestCode, intent_.Intent data, int flags) =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createPendingResult,
          jni.JniType.objectType,
          [requestCode, data.reference, flags]).object);

  static final _id_setRequestedOrientation =
      jniAccessors.getMethodIDOf(_classRef, "setRequestedOrientation", "(I)V");

  /// from: public void setRequestedOrientation(int requestedOrientation)
  ///
  /// Change the desired orientation of this activity.  If the activity
  /// is currently in the foreground or otherwise impacting the screen
  /// orientation, the screen will immediately be changed (possibly causing
  /// the activity to be restarted). Otherwise, this will be used the next
  /// time the activity is visible.
  ///@param requestedOrientation An orientation constant as used in
  /// ActivityInfo\#screenOrientation ActivityInfo.screenOrientation.
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  void setRequestedOrientation(int requestedOrientation) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRequestedOrientation,
          jni.JniType.voidType, [requestedOrientation]).check();

  static final _id_getRequestedOrientation =
      jniAccessors.getMethodIDOf(_classRef, "getRequestedOrientation", "()I");

  /// from: public int getRequestedOrientation()
  ///
  /// Return the current requested orientation of the activity.  This will
  /// either be the orientation requested in its component's manifest, or
  /// the last requested orientation given to
  /// \#setRequestedOrientation(int).
  ///@return Returns an orientation constant as used in
  /// ActivityInfo\#screenOrientation ActivityInfo.screenOrientation.
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  int getRequestedOrientation() => jniAccessors.callMethodWithArgs(
      reference, _id_getRequestedOrientation, jni.JniType.intType, []).integer;

  static final _id_getTaskId =
      jniAccessors.getMethodIDOf(_classRef, "getTaskId", "()I");

  /// from: public int getTaskId()
  ///
  /// Return the identifier of the task this activity is in.  This identifier
  /// will remain the same for the lifetime of the activity.
  ///@return Task identifier, an opaque integer.
  int getTaskId() => jniAccessors.callMethodWithArgs(
      reference, _id_getTaskId, jni.JniType.intType, []).integer;

  static final _id_isTaskRoot =
      jniAccessors.getMethodIDOf(_classRef, "isTaskRoot", "()Z");

  /// from: public boolean isTaskRoot()
  ///
  /// Return whether this activity is the root of a task.  The root is the
  /// first activity in a task.
  ///@return True if this is the root activity, else false.
  bool isTaskRoot() => jniAccessors.callMethodWithArgs(
      reference, _id_isTaskRoot, jni.JniType.booleanType, []).boolean;

  static final _id_moveTaskToBack =
      jniAccessors.getMethodIDOf(_classRef, "moveTaskToBack", "(Z)Z");

  /// from: public boolean moveTaskToBack(boolean nonRoot)
  ///
  /// Move the task containing this activity to the back of the activity
  /// stack.  The activity's order within the task is unchanged.
  ///@param nonRoot If false then this only works if the activity is the root
  ///                of a task; if true it will work for any activity in
  ///                a task.
  ///@return If the task was moved (or it was already at the
  ///         back) true is returned, else false.
  bool moveTaskToBack(bool nonRoot) => jniAccessors.callMethodWithArgs(
      reference,
      _id_moveTaskToBack,
      jni.JniType.booleanType,
      [nonRoot]).boolean;

  static final _id_getLocalClassName = jniAccessors.getMethodIDOf(
      _classRef, "getLocalClassName", "()Ljava/lang/String;");

  /// from: public java.lang.String getLocalClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns class name for this activity with the package prefix removed.
  /// This is the default name used to read and write settings.
  ///@return The local class name.
  ///
  /// This value will never be {@code null}.
  jni.JniString getLocalClassName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocalClassName, jni.JniType.objectType, []).object);

  static final _id_getComponentName = jniAccessors.getMethodIDOf(
      _classRef, "getComponentName", "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getComponentName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the complete component name of this activity.
  ///@return Returns the complete component name for this activity
  componentname_.ComponentName getComponentName() =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getComponentName, jni.JniType.objectType, []).object);

  static final _id_getPreferences = jniAccessors.getMethodIDOf(
      _classRef, "getPreferences", "(I)Landroid/content/SharedPreferences;");

  /// from: public android.content.SharedPreferences getPreferences(int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a SharedPreferences object for accessing preferences
  /// that are private to this activity.  This simply calls the underlying
  /// \#getSharedPreferences(String, int) method by passing in this activity's
  /// class name as the preferences name.
  ///@param mode Operating mode.  Use \#MODE_PRIVATE for the default
  ///             operation.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_MULTI_PROCESS
  ///@return Returns the single SharedPreferences instance that can be used
  ///         to retrieve and modify the preference values.
  sharedpreferences_.SharedPreferences getPreferences(int mode) =>
      sharedpreferences_.SharedPreferences.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getPreferences,
              jni.JniType.objectType, [mode]).object);

  static final _id_getSystemService = jniAccessors.getMethodIDOf(
      _classRef, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");

  /// from: public java.lang.Object getSystemService(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param name Value is android.content.Context\#POWER_SERVICE, android.content.Context\#WINDOW_SERVICE, android.content.Context\#LAYOUT_INFLATER_SERVICE, android.content.Context\#ACCOUNT_SERVICE, android.content.Context\#ACTIVITY_SERVICE, android.content.Context\#ALARM_SERVICE, android.content.Context\#NOTIFICATION_SERVICE, android.content.Context\#ACCESSIBILITY_SERVICE, android.content.Context\#CAPTIONING_SERVICE, android.content.Context\#KEYGUARD_SERVICE, android.content.Context\#LOCATION_SERVICE, android.content.Context\#SEARCH_SERVICE, android.content.Context\#SENSOR_SERVICE, android.content.Context\#STORAGE_SERVICE, android.content.Context\#STORAGE_STATS_SERVICE, android.content.Context\#WALLPAPER_SERVICE, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, android.content.Context\#VIBRATOR_SERVICE, android.content.Context\#CONNECTIVITY_SERVICE, android.content.Context\#IPSEC_SERVICE, android.content.Context\#NETWORK_STATS_SERVICE, android.content.Context\#WIFI_SERVICE, android.content.Context\#WIFI_AWARE_SERVICE, android.content.Context\#WIFI_P2P_SERVICE, android.content.Context.WIFI_SCANNING_SERVICE, android.content.Context\#WIFI_RTT_RANGING_SERVICE, android.content.Context\#NSD_SERVICE, android.content.Context\#AUDIO_SERVICE, android.content.Context\#FINGERPRINT_SERVICE, android.content.Context\#MEDIA_ROUTER_SERVICE, android.content.Context\#TELEPHONY_SERVICE, android.content.Context\#TELEPHONY_SUBSCRIPTION_SERVICE, android.content.Context\#CARRIER_CONFIG_SERVICE, android.content.Context\#TELECOM_SERVICE, android.content.Context\#CLIPBOARD_SERVICE, android.content.Context\#INPUT_METHOD_SERVICE, android.content.Context\#TEXT_SERVICES_MANAGER_SERVICE, android.content.Context\#TEXT_CLASSIFICATION_SERVICE, android.content.Context\#APPWIDGET_SERVICE, android.content.Context\#DROPBOX_SERVICE, android.content.Context\#DEVICE_POLICY_SERVICE, android.content.Context\#UI_MODE_SERVICE, android.content.Context\#DOWNLOAD_SERVICE, android.content.Context\#NFC_SERVICE, android.content.Context\#BLUETOOTH_SERVICE, android.content.Context\#USB_SERVICE, android.content.Context\#LAUNCHER_APPS_SERVICE, android.content.Context\#INPUT_SERVICE, android.content.Context\#DISPLAY_SERVICE, android.content.Context\#USER_SERVICE, android.content.Context\#RESTRICTIONS_SERVICE, android.content.Context\#APP_OPS_SERVICE, android.content.Context\#CAMERA_SERVICE, android.content.Context\#PRINT_SERVICE, android.content.Context\#CONSUMER_IR_SERVICE, android.content.Context\#TV_INPUT_SERVICE, android.content.Context\#USAGE_STATS_SERVICE, android.content.Context\#MEDIA_SESSION_SERVICE, android.content.Context\#BATTERY_SERVICE, android.content.Context\#JOB_SCHEDULER_SERVICE, android.content.Context\#MEDIA_PROJECTION_SERVICE, android.content.Context\#MIDI_SERVICE, android.content.Context.RADIO_SERVICE, android.content.Context\#HARDWARE_PROPERTIES_SERVICE, android.content.Context\#SHORTCUT_SERVICE, android.content.Context\#SYSTEM_HEALTH_SERVICE, android.content.Context\#COMPANION_DEVICE_SERVICE, or android.content.Context\#CROSS_PROFILE_APPS_SERVICE
  ///
  /// This value must never be {@code null}.
  jni.JniObject getSystemService(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSystemService,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_setTitle = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public void setTitle(java.lang.CharSequence title)
  ///
  /// Change the title associated with this activity.  If this is a
  /// top-level activity, the title for its window will change.  If it
  /// is an embedded activity, the parent can do whatever it wants
  /// with it.
  void setTitle(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle, jni.JniType.voidType, [title.reference]).check();

  static final _id_setTitle1 =
      jniAccessors.getMethodIDOf(_classRef, "setTitle", "(I)V");

  /// from: public void setTitle(int titleId)
  ///
  /// Change the title associated with this activity.  If this is a
  /// top-level activity, the title for its window will change.  If it
  /// is an embedded activity, the parent can do whatever it wants
  /// with it.
  void setTitle1(int titleId) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle1, jni.JniType.voidType, [titleId]).check();

  static final _id_setTitleColor =
      jniAccessors.getMethodIDOf(_classRef, "setTitleColor", "(I)V");

  /// from: public void setTitleColor(int textColor)
  ///
  /// Change the color of the title associated with this activity.
  ///
  /// This method is deprecated starting in API Level 11 and replaced by action
  /// bar styles. For information on styling the Action Bar, read the <a href="{@docRoot} guide/topics/ui/actionbar.html">Action Bar</a> developer
  /// guide.
  ///@deprecated Use action bar styles instead.
  void setTitleColor(int textColor) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitleColor, jni.JniType.voidType, [textColor]).check();

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public final java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_getTitleColor =
      jniAccessors.getMethodIDOf(_classRef, "getTitleColor", "()I");

  /// from: public final int getTitleColor()
  int getTitleColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getTitleColor, jni.JniType.intType, []).integer;

  static final _id_onTitleChanged = jniAccessors.getMethodIDOf(
      _classRef, "onTitleChanged", "(Ljava/lang/CharSequence;I)V");

  /// from: protected void onTitleChanged(java.lang.CharSequence title, int color)
  void onTitleChanged(jni.JniObject title, int color) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTitleChanged,
          jni.JniType.voidType, [title.reference, color]).check();

  static final _id_onChildTitleChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onChildTitleChanged",
      "(Landroid/app/Activity;Ljava/lang/CharSequence;)V");

  /// from: protected void onChildTitleChanged(android.app.Activity childActivity, java.lang.CharSequence title)
  void onChildTitleChanged(Activity childActivity, jni.JniObject title) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onChildTitleChanged,
          jni.JniType.voidType,
          [childActivity.reference, title.reference]).check();

  static final _id_setTaskDescription = jniAccessors.getMethodIDOf(
      _classRef,
      "setTaskDescription",
      "(Landroid/app/ActivityManager\$TaskDescription;)V");

  /// from: public void setTaskDescription(android.app.ActivityManager.TaskDescription taskDescription)
  ///
  /// Sets information describing the task with this activity for presentation inside the Recents
  /// System UI. When ActivityManager\#getRecentTasks is called, the activities of each task
  /// are traversed in order from the topmost activity to the bottommost. The traversal continues
  /// for each property until a suitable value is found. For each task the taskDescription will be
  /// returned in android.app.ActivityManager.TaskDescription.
  ///@see ActivityManager\#getRecentTasks
  ///@see android.app.ActivityManager.TaskDescription
  ///@param taskDescription The TaskDescription properties that describe the task with this activity
  void setTaskDescription(
          activitymanager_.ActivityManager_TaskDescription taskDescription) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTaskDescription,
          jni.JniType.voidType, [taskDescription.reference]).check();

  static final _id_setProgressBarVisibility =
      jniAccessors.getMethodIDOf(_classRef, "setProgressBarVisibility", "(Z)V");

  /// from: public final void setProgressBarVisibility(boolean visible)
  ///
  /// Sets the visibility of the progress bar in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param visible Whether to show the progress bars in the title.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarVisibility(bool visible) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProgressBarVisibility,
          jni.JniType.voidType, [visible]).check();

  static final _id_setProgressBarIndeterminateVisibility =
      jniAccessors.getMethodIDOf(
          _classRef, "setProgressBarIndeterminateVisibility", "(Z)V");

  /// from: public final void setProgressBarIndeterminateVisibility(boolean visible)
  ///
  /// Sets the visibility of the indeterminate progress bar in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param visible Whether to show the progress bars in the title.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarIndeterminateVisibility(bool visible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setProgressBarIndeterminateVisibility,
          jni.JniType.voidType,
          [visible]).check();

  static final _id_setProgressBarIndeterminate = jniAccessors.getMethodIDOf(
      _classRef, "setProgressBarIndeterminate", "(Z)V");

  /// from: public final void setProgressBarIndeterminate(boolean indeterminate)
  ///
  /// Sets whether the horizontal progress bar in the title should be indeterminate (the circular
  /// is always indeterminate).
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param indeterminate Whether the horizontal progress bar should be indeterminate.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarIndeterminate(bool indeterminate) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setProgressBarIndeterminate,
          jni.JniType.voidType,
          [indeterminate]).check();

  static final _id_setProgress =
      jniAccessors.getMethodIDOf(_classRef, "setProgress", "(I)V");

  /// from: public final void setProgress(int progress)
  ///
  /// Sets the progress for the progress bars in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param progress The progress for the progress bar. Valid ranges are from
  ///            0 to 10000 (both inclusive). If 10000 is given, the progress
  ///            bar will be completely filled and will fade out.
  ///@deprecated No longer supported starting in API 21.
  void setProgress(int progress) => jniAccessors.callMethodWithArgs(
      reference, _id_setProgress, jni.JniType.voidType, [progress]).check();

  static final _id_setSecondaryProgress =
      jniAccessors.getMethodIDOf(_classRef, "setSecondaryProgress", "(I)V");

  /// from: public final void setSecondaryProgress(int secondaryProgress)
  ///
  /// Sets the secondary progress for the progress bar in the title. This
  /// progress is drawn between the primary progress (set via
  /// \#setProgress(int) and the background. It can be ideal for media
  /// scenarios such as showing the buffering progress while the default
  /// progress shows the play progress.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param secondaryProgress The secondary progress for the progress bar. Valid ranges are from
  ///            0 to 10000 (both inclusive).
  ///@deprecated No longer supported starting in API 21.
  void setSecondaryProgress(int secondaryProgress) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSecondaryProgress,
          jni.JniType.voidType, [secondaryProgress]).check();

  static final _id_setVolumeControlStream =
      jniAccessors.getMethodIDOf(_classRef, "setVolumeControlStream", "(I)V");

  /// from: public final void setVolumeControlStream(int streamType)
  ///
  /// Suggests an audio stream whose volume should be changed by the hardware
  /// volume controls.
  ///
  /// The suggested audio stream will be tied to the window of this Activity.
  /// Volume requests which are received while the Activity is in the
  /// foreground will affect this stream.
  ///
  /// It is not guaranteed that the hardware volume controls will always change
  /// this stream's volume (for example, if a call is in progress, its stream's
  /// volume may be changed instead). To reset back to the default, use
  /// AudioManager\#USE_DEFAULT_STREAM_TYPE.
  ///@param streamType The type of the audio stream whose volume should be
  ///            changed by the hardware volume controls.
  void setVolumeControlStream(int streamType) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVolumeControlStream,
          jni.JniType.voidType, [streamType]).check();

  static final _id_getVolumeControlStream =
      jniAccessors.getMethodIDOf(_classRef, "getVolumeControlStream", "()I");

  /// from: public final int getVolumeControlStream()
  ///
  /// Gets the suggested audio stream whose volume should be changed by the
  /// hardware volume controls.
  ///@return The suggested audio stream type whose volume should be changed by
  ///         the hardware volume controls.
  ///@see \#setVolumeControlStream(int)
  int getVolumeControlStream() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolumeControlStream, jni.JniType.intType, []).integer;

  static final _id_setMediaController = jniAccessors.getMethodIDOf(_classRef,
      "setMediaController", "(Landroid/media/session/MediaController;)V");

  /// from: public final void setMediaController(android.media.session.MediaController controller)
  ///
  /// Sets a MediaController to send media keys and volume changes to.
  ///
  /// The controller will be tied to the window of this Activity. Media key and
  /// volume events which are received while the Activity is in the foreground
  /// will be forwarded to the controller and used to invoke transport controls
  /// or adjust the volume. This may be used instead of or in addition to
  /// \#setVolumeControlStream to affect a specific session instead of a
  /// specific stream.
  ///
  /// It is not guaranteed that the hardware volume controls will always change
  /// this session's volume (for example, if a call is in progress, its
  /// stream's volume may be changed instead). To reset back to the default use
  /// null as the controller.
  ///@param controller The controller for the session which should receive
  ///            media keys and volume changes.
  void setMediaController(mediacontroller_.MediaController controller) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMediaController,
          jni.JniType.voidType, [controller.reference]).check();

  static final _id_getMediaController = jniAccessors.getMethodIDOf(_classRef,
      "getMediaController", "()Landroid/media/session/MediaController;");

  /// from: public final android.media.session.MediaController getMediaController()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the controller which should be receiving media key and volume events
  /// while this activity is in the foreground.
  ///@return The controller which should receive events.
  ///@see \#setMediaController(android.media.session.MediaController)
  mediacontroller_.MediaController getMediaController() =>
      mediacontroller_.MediaController.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getMediaController,
          jni.JniType.objectType, []).object);

  static final _id_runOnUiThread = jniAccessors.getMethodIDOf(
      _classRef, "runOnUiThread", "(Ljava/lang/Runnable;)V");

  /// from: public final void runOnUiThread(java.lang.Runnable action)
  ///
  /// Runs the specified action on the UI thread. If the current thread is the UI
  /// thread, then the action is executed immediately. If the current thread is
  /// not the UI thread, the action is posted to the event queue of the UI thread.
  ///@param action the action to run on the UI thread
  void runOnUiThread(jni.JniObject action) => jniAccessors.callMethodWithArgs(
      reference,
      _id_runOnUiThread,
      jni.JniType.voidType,
      [action.reference]).check();

  static final _id_onCreateView = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Ljava/lang/String;Landroid/content/Context;Landroid/util/AttributeSet;)Landroid/view/View;");

  /// from: public android.view.View onCreateView(java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard implementation of
  /// android.view.LayoutInflater.Factory\#onCreateView used when
  /// inflating with the LayoutInflater returned by \#getSystemService.
  /// This implementation does nothing and is for
  /// pre-android.os.Build.VERSION_CODES\#HONEYCOMB apps.  Newer apps
  /// should use \#onCreateView(View, String, Context, AttributeSet).
  ///@see android.view.LayoutInflater\#createView
  ///@see android.view.Window\#getLayoutInflater
  ///@return This value may be {@code null}.
  view_.View onCreateView(jni.JniString name, context_.Context context,
          attributeset_.AttributeSet attrs) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateView,
          jni.JniType.objectType,
          [name.reference, context.reference, attrs.reference]).object);

  static final _id_onCreateView1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Landroid/view/View;Ljava/lang/String;Landroid/content/Context;Landroid/util/AttributeSet;)Landroid/view/View;");

  /// from: public android.view.View onCreateView(android.view.View parent, java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard implementation of
  /// android.view.LayoutInflater.Factory2\#onCreateView(View, String, Context, AttributeSet)
  /// used when inflating with the LayoutInflater returned by \#getSystemService.
  /// This implementation handles <fragment> tags to embed fragments inside
  /// of the activity.
  ///@see android.view.LayoutInflater\#createView
  ///@see android.view.Window\#getLayoutInflater
  view_.View onCreateView1(view_.View parent, jni.JniString name,
          context_.Context context, attributeset_.AttributeSet attrs) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCreateView1, jni.JniType.objectType, [
        parent.reference,
        name.reference,
        context.reference,
        attrs.reference
      ]).object);

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Activity's state into the given stream.  This gets invoked if
  /// you run "adb shell dumpsys activity &lt;activity_component_name&gt;".
  ///@param prefix Desired prefix to prepend at each line of output.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();

  static final _id_isImmersive =
      jniAccessors.getMethodIDOf(_classRef, "isImmersive", "()Z");

  /// from: public boolean isImmersive()
  ///
  /// Bit indicating that this activity is "immersive" and should not be
  /// interrupted by notifications if possible.
  ///
  /// This value is initially set by the manifest property
  /// <code>android:immersive</code> but may be changed at runtime by
  /// \#setImmersive.
  ///@see \#setImmersive(boolean)
  ///@see android.content.pm.ActivityInfo\#FLAG_IMMERSIVE
  bool isImmersive() => jniAccessors.callMethodWithArgs(
      reference, _id_isImmersive, jni.JniType.booleanType, []).boolean;

  static final _id_requestVisibleBehind =
      jniAccessors.getMethodIDOf(_classRef, "requestVisibleBehind", "(Z)Z");

  /// from: public boolean requestVisibleBehind(boolean visible)
  ///
  /// Activities that want to remain visible behind a translucent activity above them must call
  /// this method anytime between the start of \#onResume() and the return from
  /// \#onPause(). If this call is successful then the activity will remain visible after
  /// \#onPause() is called, and is allowed to continue playing media in the background.
  ///
  /// The actions of this call are reset each time that this activity is brought to the
  /// front. That is, every time \#onResume() is called the activity will be assumed
  /// to not have requested visible behind. Therefore, if you want this activity to continue to
  /// be visible in the background you must call this method again.
  ///
  /// Only fullscreen opaque activities may make this call. I.e. this call is a nop
  /// for dialog and translucent activities.
  ///
  /// Under all circumstances, the activity must stop playing and release resources prior to or
  /// within a call to \#onVisibleBehindCanceled() or if this call returns false.
  ///
  /// False will be returned any time this method is called between the return of onPause and
  ///      the next call to onResume.
  ///@deprecated This method's functionality is no longer supported as of
  ///             android.os.Build.VERSION_CODES\#O and will be removed in a future release.
  ///@param visible true to notify the system that the activity wishes to be visible behind other
  ///                translucent activities, false to indicate otherwise. Resources must be
  ///                released when passing false to this method.
  ///@return the resulting visibiity state. If true the activity will remain visible beyond
  ///      \#onPause() if the next activity is translucent or not fullscreen. If false
  ///      then the activity may not count on being visible behind other translucent activities,
  ///      and must stop any media playback and release resources.
  ///      Returning false may occur in lieu of a call to \#onVisibleBehindCanceled() so
  ///      the return value must be checked.
  ///@see \#onVisibleBehindCanceled()
  bool requestVisibleBehind(bool visible) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestVisibleBehind,
      jni.JniType.booleanType,
      [visible]).boolean;

  static final _id_onVisibleBehindCanceled =
      jniAccessors.getMethodIDOf(_classRef, "onVisibleBehindCanceled", "()V");

  /// from: public void onVisibleBehindCanceled()
  ///
  /// Called when a translucent activity over this activity is becoming opaque or another
  /// activity is being launched. Activities that override this method must call
  /// <code>super.onVisibleBehindCanceled()</code> or a SuperNotCalledException will be thrown.
  ///
  /// When this method is called the activity has 500 msec to release any resources it may be
  /// using while visible in the background.
  /// If the activity has not returned from this method in 500 msec the system will destroy
  /// the activity and kill the process in order to recover the resources for another
  /// process. Otherwise \#onStop() will be called following return.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#requestVisibleBehind(boolean)
  ///@deprecated This method's functionality is no longer supported as of
  /// android.os.Build.VERSION_CODES\#O and will be removed in a future release.
  void onVisibleBehindCanceled() => jniAccessors.callMethodWithArgs(
      reference, _id_onVisibleBehindCanceled, jni.JniType.voidType, []).check();

  static final _id_onEnterAnimationComplete =
      jniAccessors.getMethodIDOf(_classRef, "onEnterAnimationComplete", "()V");

  /// from: public void onEnterAnimationComplete()
  ///
  /// Activities cannot draw during the period that their windows are animating in. In order
  /// to know when it is safe to begin drawing they can override this method which will be
  /// called when the entering animation has completed.
  void onEnterAnimationComplete() => jniAccessors.callMethodWithArgs(reference,
      _id_onEnterAnimationComplete, jni.JniType.voidType, []).check();

  static final _id_setImmersive =
      jniAccessors.getMethodIDOf(_classRef, "setImmersive", "(Z)V");

  /// from: public void setImmersive(boolean i)
  ///
  /// Adjust the current immersive mode setting.
  ///
  /// Note that changing this value will have no effect on the activity's
  /// android.content.pm.ActivityInfo structure; that is, if
  /// <code>android:immersive</code> is set to <code>true</code>
  /// in the application's manifest entry for this activity, the android.content.pm.ActivityInfo\#flags ActivityInfo.flags member will
  /// always have its android.content.pm.ActivityInfo\#FLAG_IMMERSIVE FLAG_IMMERSIVE bit set.
  ///@see \#isImmersive()
  ///@see android.content.pm.ActivityInfo\#FLAG_IMMERSIVE
  void setImmersive(bool i) => jniAccessors.callMethodWithArgs(
      reference, _id_setImmersive, jni.JniType.voidType, [i]).check();

  static final _id_setVrModeEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setVrModeEnabled", "(ZLandroid/content/ComponentName;)V");

  /// from: public void setVrModeEnabled(boolean enabled, android.content.ComponentName requestedComponent)
  ///
  /// Enable or disable virtual reality (VR) mode for this Activity.
  ///
  /// VR mode is a hint to Android system to switch to a mode optimized for VR applications
  /// while this Activity has user focus.
  ///
  ///
  /// It is recommended that applications additionally declare
  /// android.R.attr\#enableVrMode in their manifest to allow for smooth activity
  /// transitions when switching between VR activities.
  ///
  ///
  /// If the requested android.service.vr.VrListenerService component is not available,
  /// VR mode will not be started.  Developers can handle this case as follows:
  ///
  ///
  /// <pre>
  /// String servicePackage = "com.whatever.app";
  /// String serviceClass = "com.whatever.app.MyVrListenerService";
  ///
  /// // Name of the component of the VrListenerService to start.
  /// ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
  ///
  /// try {
  ///    setVrModeEnabled(true, myComponentName);
  /// } catch (PackageManager.NameNotFoundException e) {
  ///        List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
  ///        boolean isInstalled = false;
  ///        for (ApplicationInfo app : installed) {
  ///            if (app.packageName.equals(servicePackage)) {
  ///                isInstalled = true;
  ///                break;
  ///            }
  ///        }
  ///        if (isInstalled) {
  ///            // Package is installed, but not enabled in Settings.  Let user enable it.
  ///            startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
  ///        } else {
  ///            // Package is not installed.  Send an intent to download this.
  ///            sentIntentToLaunchAppStore(servicePackage);
  ///        }
  /// }
  /// </pre>
  ///@param enabled {@code true} to enable this mode.
  ///@param requestedComponent the name of the component to use as a
  ///        android.service.vr.VrListenerService while VR mode is enabled.
  ///
  /// This value must never be {@code null}.
  ///@throws android.content.pm.PackageManager.NameNotFoundException if the given component
  ///    to run as a android.service.vr.VrListenerService is not installed, or has
  ///    not been enabled in user settings.
  ///@see android.content.pm.PackageManager\#FEATURE_VR_MODE_HIGH_PERFORMANCE
  ///@see android.service.vr.VrListenerService
  ///@see android.provider.Settings\#ACTION_VR_LISTENER_SETTINGS
  ///@see android.R.attr\#enableVrMode
  void setVrModeEnabled(
          bool enabled, componentname_.ComponentName requestedComponent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVrModeEnabled,
          jni.JniType.voidType,
          [enabled, requestedComponent.reference]).check();

  static final _id_startActionMode = jniAccessors.getMethodIDOf(
      _classRef,
      "startActionMode",
      "(Landroid/view/ActionMode\$Callback;)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start an action mode of the default type ActionMode\#TYPE_PRIMARY.
  ///@param callback Callback that will manage lifecycle events for this action mode
  ///@return The ActionMode that was started, or null if it was canceled
  ///@see ActionMode
  actionmode_.ActionMode startActionMode(
          actionmode_.ActionMode_Callback callback) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActionMode,
          jni.JniType.objectType,
          [callback.reference]).object);

  static final _id_startActionMode1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActionMode",
      "(Landroid/view/ActionMode\$Callback;I)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start an action mode of the given type.
  ///@param callback Callback that will manage lifecycle events for this action mode
  ///@param type One of ActionMode\#TYPE_PRIMARY or ActionMode\#TYPE_FLOATING.
  ///@return The ActionMode that was started, or null if it was canceled
  ///@see ActionMode
  actionmode_.ActionMode startActionMode1(
          actionmode_.ActionMode_Callback callback, int type) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActionMode1,
          jni.JniType.objectType,
          [callback.reference, type]).object);

  static final _id_onWindowStartingActionMode = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowStartingActionMode",
      "(Landroid/view/ActionMode\$Callback;)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Give the Activity a chance to control the UI for an action mode requested
  /// by the system.
  ///
  /// Note: If you are looking for a notification callback that an action mode
  /// has been started for this activity, see \#onActionModeStarted(ActionMode).
  ///
  ///@param callback The callback that should control the new action mode
  ///@return The new action mode, or <code>null</code> if the activity does not want to
  ///         provide special handling for this action mode. (It will be handled by the system.)
  actionmode_.ActionMode onWindowStartingActionMode(
          actionmode_.ActionMode_Callback callback) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowStartingActionMode,
          jni.JniType.objectType,
          [callback.reference]).object);

  static final _id_onWindowStartingActionMode1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowStartingActionMode",
      "(Landroid/view/ActionMode\$Callback;I)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///@return This value may be {@code null}.
  actionmode_.ActionMode onWindowStartingActionMode1(
          actionmode_.ActionMode_Callback callback, int type) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowStartingActionMode1,
          jni.JniType.objectType,
          [callback.reference, type]).object);

  static final _id_onActionModeStarted = jniAccessors.getMethodIDOf(
      _classRef, "onActionModeStarted", "(Landroid/view/ActionMode;)V");

  /// from: public void onActionModeStarted(android.view.ActionMode mode)
  ///
  /// Notifies the Activity that an action mode has been started.
  /// Activity subclasses overriding this method should call the superclass implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param mode The new action mode.
  void onActionModeStarted(actionmode_.ActionMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionModeStarted,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_onActionModeFinished = jniAccessors.getMethodIDOf(
      _classRef, "onActionModeFinished", "(Landroid/view/ActionMode;)V");

  /// from: public void onActionModeFinished(android.view.ActionMode mode)
  ///
  /// Notifies the activity that an action mode has finished.
  /// Activity subclasses overriding this method should call the superclass implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param mode The action mode that just finished.
  void onActionModeFinished(actionmode_.ActionMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionModeFinished,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_shouldUpRecreateTask = jniAccessors.getMethodIDOf(
      _classRef, "shouldUpRecreateTask", "(Landroid/content/Intent;)Z");

  /// from: public boolean shouldUpRecreateTask(android.content.Intent targetIntent)
  ///
  /// Returns true if the app should recreate the task when navigating 'up' from this activity
  /// by using targetIntent.
  ///
  /// If this method returns false the app can trivially call
  /// \#navigateUpTo(Intent) using the same parameters to correctly perform
  /// up navigation. If this method returns false, the app should synthesize a new task stack
  /// by using TaskStackBuilder or another similar mechanism to perform up navigation.
  ///
  ///@param targetIntent An intent representing the target destination for up navigation
  ///@return true if navigating up should recreate a new task stack, false if the same task
  ///         should be used for the destination
  bool shouldUpRecreateTask(intent_.Intent targetIntent) =>
      jniAccessors.callMethodWithArgs(reference, _id_shouldUpRecreateTask,
          jni.JniType.booleanType, [targetIntent.reference]).boolean;

  static final _id_navigateUpTo = jniAccessors.getMethodIDOf(
      _classRef, "navigateUpTo", "(Landroid/content/Intent;)Z");

  /// from: public boolean navigateUpTo(android.content.Intent upIntent)
  ///
  /// Navigate from this activity to the activity specified by upIntent, finishing this activity
  /// in the process. If the activity indicated by upIntent already exists in the task's history,
  /// this activity and all others before the indicated activity in the history stack will be
  /// finished.
  ///
  /// If the indicated activity does not appear in the history stack, this will finish
  /// each activity in this task until the root activity of the task is reached, resulting in
  /// an "in-app home" behavior. This can be useful in apps with a complex navigation hierarchy
  /// when an activity may be reached by a path not passing through a canonical parent
  /// activity.
  ///
  ///
  /// This method should be used when performing up navigation from within the same task
  /// as the destination. If up navigation should cross tasks in some cases, see
  /// \#shouldUpRecreateTask(Intent).
  ///
  ///@param upIntent An intent representing the target destination for up navigation
  ///@return true if up navigation successfully reached the activity indicated by upIntent and
  ///         upIntent was delivered to it. false if an instance of the indicated activity could
  ///         not be found and this activity was simply finished normally.
  bool navigateUpTo(intent_.Intent upIntent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_navigateUpTo,
      jni.JniType.booleanType,
      [upIntent.reference]).boolean;

  static final _id_navigateUpToFromChild = jniAccessors.getMethodIDOf(
      _classRef,
      "navigateUpToFromChild",
      "(Landroid/app/Activity;Landroid/content/Intent;)Z");

  /// from: public boolean navigateUpToFromChild(android.app.Activity child, android.content.Intent upIntent)
  ///
  /// This is called when a child activity of this one calls its
  /// \#navigateUpTo method.  The default implementation simply calls
  /// navigateUpTo(upIntent) on this activity (the parent).
  ///@param child The activity making the call.
  ///@param upIntent An intent representing the target destination for up navigation
  ///@return true if up navigation successfully reached the activity indicated by upIntent and
  ///         upIntent was delivered to it. false if an instance of the indicated activity could
  ///         not be found and this activity was simply finished normally.
  bool navigateUpToFromChild(Activity child, intent_.Intent upIntent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_navigateUpToFromChild,
          jni.JniType.booleanType,
          [child.reference, upIntent.reference]).boolean;

  static final _id_getParentActivityIntent = jniAccessors.getMethodIDOf(
      _classRef, "getParentActivityIntent", "()Landroid/content/Intent;");

  /// from: public android.content.Intent getParentActivityIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain an Intent that will launch an explicit target activity specified by
  /// this activity's logical parent. The logical parent is named in the application's manifest
  /// by the android.R.attr\#parentActivityName parentActivityName attribute.
  /// Activity subclasses may override this method to modify the Intent returned by
  /// super.getParentActivityIntent() or to implement a different mechanism of retrieving
  /// the parent intent entirely.
  ///@return a new Intent targeting the defined parent of this activity or null if
  ///         there is no valid parent.
  intent_.Intent getParentActivityIntent() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getParentActivityIntent, jni.JniType.objectType, []).object);

  static final _id_setEnterSharedElementCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setEnterSharedElementCallback",
      "(Landroid/app/SharedElementCallback;)V");

  /// from: public void setEnterSharedElementCallback(android.app.SharedElementCallback callback)
  ///
  /// When android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.view.View, String) was used to start an Activity, <var>callback</var>
  /// will be called to handle shared elements on the <i>launched</i> Activity. This requires
  /// Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param callback Used to manipulate shared element transitions on the launched Activity.
  void setEnterSharedElementCallback(
          sharedelementcallback_.SharedElementCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setEnterSharedElementCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_setExitSharedElementCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setExitSharedElementCallback",
      "(Landroid/app/SharedElementCallback;)V");

  /// from: public void setExitSharedElementCallback(android.app.SharedElementCallback callback)
  ///
  /// When android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.view.View, String) was used to start an Activity, <var>callback</var>
  /// will be called to handle shared elements on the <i>launching</i> Activity. Most
  /// calls will only come when returning from the started Activity.
  /// This requires Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param callback Used to manipulate shared element transitions on the launching Activity.
  void setExitSharedElementCallback(
          sharedelementcallback_.SharedElementCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setExitSharedElementCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_postponeEnterTransition =
      jniAccessors.getMethodIDOf(_classRef, "postponeEnterTransition", "()V");

  /// from: public void postponeEnterTransition()
  ///
  /// Postpone the entering activity transition when Activity was started with
  /// android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.util.Pair[]).
  /// This method gives the Activity the ability to delay starting the entering and
  /// shared element transitions until all data is loaded. Until then, the Activity won't
  /// draw into its window, leaving the window transparent. This may also cause the
  /// returning animation to be delayed until data is ready. This method should be
  /// called in \#onCreate(android.os.Bundle) or in
  /// \#onActivityReenter(int, android.content.Intent).
  /// \#startPostponedEnterTransition() must be called to allow the Activity to
  /// start the transitions. If the Activity did not use
  /// android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.util.Pair[]), then this method does nothing.
  ///
  void postponeEnterTransition() => jniAccessors.callMethodWithArgs(
      reference, _id_postponeEnterTransition, jni.JniType.voidType, []).check();

  static final _id_startPostponedEnterTransition = jniAccessors.getMethodIDOf(
      _classRef, "startPostponedEnterTransition", "()V");

  /// from: public void startPostponedEnterTransition()
  ///
  /// Begin postponed transitions after \#postponeEnterTransition() was called.
  /// If postponeEnterTransition() was called, you must call startPostponedEnterTransition()
  /// to have your Activity start drawing.
  void startPostponedEnterTransition() => jniAccessors.callMethodWithArgs(
      reference,
      _id_startPostponedEnterTransition,
      jni.JniType.voidType, []).check();

  static final _id_requestDragAndDropPermissions = jniAccessors.getMethodIDOf(
      _classRef,
      "requestDragAndDropPermissions",
      "(Landroid/view/DragEvent;)Landroid/view/DragAndDropPermissions;");

  /// from: public android.view.DragAndDropPermissions requestDragAndDropPermissions(android.view.DragEvent event)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create DragAndDropPermissions object bound to this activity and controlling the
  /// access permissions for content URIs associated with the DragEvent.
  ///@param event Drag event
  ///@return The DragAndDropPermissions object used to control access to the content URIs.
  /// Null if no content URIs are associated with the event or if permissions could not be granted.
  draganddroppermissions_.DragAndDropPermissions requestDragAndDropPermissions(
          dragevent_.DragEvent event) =>
      draganddroppermissions_.DragAndDropPermissions.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_requestDragAndDropPermissions,
              jni.JniType.objectType, [event.reference]).object);

  static final _id_startLockTask =
      jniAccessors.getMethodIDOf(_classRef, "startLockTask", "()V");

  /// from: public void startLockTask()
  ///
  /// Request to put this activity in a mode where the user is locked to a restricted set of
  /// applications.
  ///
  /// If DevicePolicyManager\#isLockTaskPermitted(String) returns {@code true}
  /// for this component, the current task will be launched directly into LockTask mode. Only apps
  /// whitelisted by DevicePolicyManager\#setLockTaskPackages(ComponentName, String[]) can
  /// be launched while LockTask mode is active. The user will not be able to leave this mode
  /// until this activity calls \#stopLockTask(). Calling this method while the device is
  /// already in LockTask mode has no effect.
  ///
  /// Otherwise, the current task will be launched into screen pinning mode. In this case, the
  /// system will prompt the user with a dialog requesting permission to use this mode.
  /// The user can exit at any time through instructions shown on the request dialog. Calling
  /// \#stopLockTask() will also terminate this mode.
  ///
  /// <strong>Note:</strong> this method can only be called when the activity is foreground.
  /// That is, between \#onResume() and \#onPause().
  ///@see \#stopLockTask()
  ///@see android.R.attr\#lockTaskMode
  void startLockTask() => jniAccessors.callMethodWithArgs(
      reference, _id_startLockTask, jni.JniType.voidType, []).check();

  static final _id_stopLockTask =
      jniAccessors.getMethodIDOf(_classRef, "stopLockTask", "()V");

  /// from: public void stopLockTask()
  ///
  /// Stop the current task from being locked.
  ///
  /// Called to end the LockTask or screen pinning mode started by \#startLockTask().
  /// This can only be called by activities that have called \#startLockTask() previously.
  ///
  /// <strong>Note:</strong> If the device is in LockTask mode that is not initially started
  /// by this activity, then calling this method will not terminate the LockTask mode, but only
  /// finish its own task. The device will remain in LockTask mode, until the activity which
  /// started the LockTask mode calls this method, or until its whitelist authorization is revoked
  /// by DevicePolicyManager\#setLockTaskPackages(ComponentName, String[]).
  ///@see \#startLockTask()
  ///@see android.R.attr\#lockTaskMode
  ///@see ActivityManager\#getLockTaskModeState()
  void stopLockTask() => jniAccessors.callMethodWithArgs(
      reference, _id_stopLockTask, jni.JniType.voidType, []).check();

  static final _id_showLockTaskEscapeMessage =
      jniAccessors.getMethodIDOf(_classRef, "showLockTaskEscapeMessage", "()V");

  /// from: public void showLockTaskEscapeMessage()
  ///
  /// Shows the user the system defined message for telling the user how to exit
  /// lock task mode. The task containing this activity must be in lock task mode at the time
  /// of this call for the message to be displayed.
  void showLockTaskEscapeMessage() => jniAccessors.callMethodWithArgs(reference,
      _id_showLockTaskEscapeMessage, jni.JniType.voidType, []).check();

  static final _id_setShowWhenLocked =
      jniAccessors.getMethodIDOf(_classRef, "setShowWhenLocked", "(Z)V");

  /// from: public void setShowWhenLocked(boolean showWhenLocked)
  ///
  /// Specifies whether an Activity should be shown on top of the the lock screen whenever
  /// the lockscreen is up and the activity is resumed. Normally an activity will be transitioned
  /// to the stopped state if it is started while the lockscreen is up, but with this flag set the
  /// activity will remain in the resumed state visible on-top of the lock screen. This value can
  /// be set as a manifest attribute using android.R.attr\#showWhenLocked.
  ///@param showWhenLocked {@code true} to show the Activity on top of the lock screen;
  ///                                   {@code false} otherwise.
  ///@see \#setTurnScreenOn(boolean)
  ///@see android.R.attr\#turnScreenOn
  ///@see android.R.attr\#showWhenLocked
  void setShowWhenLocked(bool showWhenLocked) =>
      jniAccessors.callMethodWithArgs(reference, _id_setShowWhenLocked,
          jni.JniType.voidType, [showWhenLocked]).check();

  static final _id_setTurnScreenOn =
      jniAccessors.getMethodIDOf(_classRef, "setTurnScreenOn", "(Z)V");

  /// from: public void setTurnScreenOn(boolean turnScreenOn)
  ///
  /// Specifies whether the screen should be turned on when the Activity is resumed.
  /// Normally an activity will be transitioned to the stopped state if it is started while the
  /// screen if off, but with this flag set the activity will cause the screen to turn on if the
  /// activity will be visible and resumed due to the screen coming on. The screen will not be
  /// turned on if the activity won't be visible after the screen is turned on. This flag is
  /// normally used in conjunction with the android.R.attr\#showWhenLocked flag to make sure
  /// the activity is visible after the screen is turned on when the lockscreen is up. In addition,
  /// if this flag is set and the activity calls KeyguardManager\#requestDismissKeyguard(Activity, KeyguardManager.KeyguardDismissCallback)
  /// the screen will turn on.
  ///@param turnScreenOn {@code true} to turn on the screen; {@code false} otherwise.
  ///@see \#setShowWhenLocked(boolean)
  ///@see android.R.attr\#turnScreenOn
  ///@see android.R.attr\#showWhenLocked
  void setTurnScreenOn(bool turnScreenOn) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTurnScreenOn,
      jni.JniType.voidType,
      [turnScreenOn]).check();
}
