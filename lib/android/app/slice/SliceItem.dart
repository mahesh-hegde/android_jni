// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;

import "../../os/Bundle.dart" as bundle_;

import "../../graphics/drawable/Icon.dart" as icon_;

import "../PendingIntent.dart" as pendingintent_;

import "../RemoteInput.dart" as remoteinput_;

import "Slice.dart" as slice_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.slice.SliceItem
///
/// A SliceItem is a single unit in the tree structure of a Slice.
///
/// A SliceItem a piece of content and some hints about what that content
/// means or how it should be displayed. The types of content can be:
/// <li>\#FORMAT_SLICE</li>
/// <li>\#FORMAT_TEXT</li>
/// <li>\#FORMAT_IMAGE</li>
/// <li>\#FORMAT_ACTION</li>
/// <li>\#FORMAT_INT</li>
/// <li>\#FORMAT_LONG</li>
/// <li>\#FORMAT_REMOTE_INPUT</li>
/// <li>\#FORMAT_BUNDLE</li>
///
/// The hints that a SliceItem are a set of strings which annotate
/// the content. The hints that are guaranteed to be understood by the system
/// are defined on Slice.
class SliceItem extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/slice/SliceItem");
  SliceItem.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.slice.SliceItem> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String FORMAT_ACTION
  ///
  /// A SliceItem that contains a PendingIntent
  ///
  /// Note: Actions contain 2 pieces of data, In addition to the pending intent, the
  /// item contains a Slice that the action applies to.
  static const FORMAT_ACTION = "action";

  /// from: static public final java.lang.String FORMAT_BUNDLE
  ///
  /// A SliceItem that contains a Bundle.
  static const FORMAT_BUNDLE = "bundle";

  /// from: static public final java.lang.String FORMAT_IMAGE
  ///
  /// A SliceItem that contains an Icon
  static const FORMAT_IMAGE = "image";

  /// from: static public final java.lang.String FORMAT_INT
  ///
  /// A SliceItem that contains an int.
  static const FORMAT_INT = "int";

  /// from: static public final java.lang.String FORMAT_LONG
  ///
  /// A SliceItem that contains a long.
  static const FORMAT_LONG = "long";

  /// from: static public final java.lang.String FORMAT_REMOTE_INPUT
  ///
  /// A SliceItem that contains a RemoteInput.
  static const FORMAT_REMOTE_INPUT = "input";

  /// from: static public final java.lang.String FORMAT_SLICE
  ///
  /// A SliceItem that contains a Slice
  static const FORMAT_SLICE = "slice";

  /// from: static public final java.lang.String FORMAT_TEXT
  ///
  /// A SliceItem that contains a CharSequence
  static const FORMAT_TEXT = "text";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  SliceItem(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [in0.reference]).object);

  static final _id_getHints =
      jniAccessors.getMethodIDOf(_classRef, "getHints", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getHints()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets all hints associated with this SliceItem.
  ///@return Array of hints.
  ///
  /// This value will never be {@code null}.
  ///
  /// Value is android.app.slice.Slice\#HINT_TITLE, android.app.slice.Slice\#HINT_LIST, android.app.slice.Slice\#HINT_LIST_ITEM, android.app.slice.Slice\#HINT_LARGE, android.app.slice.Slice\#HINT_ACTIONS, android.app.slice.Slice\#HINT_SELECTED, android.app.slice.Slice\#HINT_NO_TINT, android.app.slice.Slice\#HINT_SHORTCUT, android.app.slice.Slice.HINT_TOGGLE, android.app.slice.Slice\#HINT_HORIZONTAL, android.app.slice.Slice\#HINT_PARTIAL, android.app.slice.Slice\#HINT_SEE_MORE, android.app.slice.Slice\#HINT_KEYWORDS, android.app.slice.Slice\#HINT_ERROR, android.app.slice.Slice\#HINT_TTL, android.app.slice.Slice\#HINT_LAST_UPDATED, or android.app.slice.Slice\#HINT_PERMISSION_REQUEST
  jni.JniObject getHints() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHints, jni.JniType.objectType, []).object);

  static final _id_getFormat = jniAccessors.getMethodIDOf(
      _classRef, "getFormat", "()Ljava/lang/String;");

  /// from: public java.lang.String getFormat()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the format of this SliceItem.
  ///
  /// The format will be one of the following types supported by the platform:
  /// <li>\#FORMAT_SLICE</li>
  /// <li>\#FORMAT_TEXT</li>
  /// <li>\#FORMAT_IMAGE</li>
  /// <li>\#FORMAT_ACTION</li>
  /// <li>\#FORMAT_INT</li>
  /// <li>\#FORMAT_LONG</li>
  /// <li>\#FORMAT_REMOTE_INPUT</li>
  /// <li>\#FORMAT_BUNDLE</li>
  ///@see \#getSubType() ()
  jni.JniString getFormat() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFormat, jni.JniType.objectType, []).object);

  static final _id_getSubType = jniAccessors.getMethodIDOf(
      _classRef, "getSubType", "()Ljava/lang/String;");

  /// from: public java.lang.String getSubType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the sub-type of this SliceItem.
  ///
  /// Subtypes provide additional information about the type of this information beyond basic
  /// interpretations inferred by \#getFormat(). For example a slice may contain
  /// many \#FORMAT_TEXT items, but only some of them may be Slice\#SUBTYPE_MESSAGE.
  ///@see \#getFormat()
  jni.JniString getSubType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSubType, jni.JniType.objectType, []).object);

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The text held by this \#FORMAT_TEXT SliceItem
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_getBundle = jniAccessors.getMethodIDOf(
      _classRef, "getBundle", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getBundle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The parcelable held by this \#FORMAT_BUNDLE SliceItem
  bundle_.Bundle getBundle() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBundle, jni.JniType.objectType, []).object);

  static final _id_getIcon = jniAccessors.getMethodIDOf(
      _classRef, "getIcon", "()Landroid/graphics/drawable/Icon;");

  /// from: public android.graphics.drawable.Icon getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The icon held by this \#FORMAT_IMAGE SliceItem
  icon_.Icon getIcon() => icon_.Icon.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getIcon, jni.JniType.objectType, []).object);

  static final _id_getAction = jniAccessors.getMethodIDOf(
      _classRef, "getAction", "()Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getAction()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The pending intent held by this \#FORMAT_ACTION SliceItem
  pendingintent_.PendingIntent getAction() =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAction, jni.JniType.objectType, []).object);

  static final _id_getRemoteInput = jniAccessors.getMethodIDOf(
      _classRef, "getRemoteInput", "()Landroid/app/RemoteInput;");

  /// from: public android.app.RemoteInput getRemoteInput()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The remote input held by this \#FORMAT_REMOTE_INPUT SliceItem
  remoteinput_.RemoteInput getRemoteInput() =>
      remoteinput_.RemoteInput.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRemoteInput, jni.JniType.objectType, []).object);

  static final _id_getInt =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "()I");

  /// from: public int getInt()
  ///
  /// @return The color held by this \#FORMAT_INT SliceItem
  int getInt() => jniAccessors.callMethodWithArgs(
      reference, _id_getInt, jni.JniType.intType, []).integer;

  static final _id_getSlice = jniAccessors.getMethodIDOf(
      _classRef, "getSlice", "()Landroid/app/slice/Slice;");

  /// from: public android.app.slice.Slice getSlice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The slice held by this \#FORMAT_ACTION or \#FORMAT_SLICE SliceItem
  slice_.Slice getSlice() =>
      slice_.Slice.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSlice, jni.JniType.objectType, []).object);

  static final _id_getLong =
      jniAccessors.getMethodIDOf(_classRef, "getLong", "()J");

  /// from: public long getLong()
  ///
  /// @return The long held by this \#FORMAT_LONG SliceItem
  int getLong() => jniAccessors.callMethodWithArgs(
      reference, _id_getLong, jni.JniType.longType, []).long;

  static final _id_hasHint =
      jniAccessors.getMethodIDOf(_classRef, "hasHint", "(Ljava/lang/String;)Z");

  /// from: public boolean hasHint(java.lang.String hint)
  ///
  /// @param hint The hint to check for
  /// Value is android.app.slice.Slice\#HINT_TITLE, android.app.slice.Slice\#HINT_LIST, android.app.slice.Slice\#HINT_LIST_ITEM, android.app.slice.Slice\#HINT_LARGE, android.app.slice.Slice\#HINT_ACTIONS, android.app.slice.Slice\#HINT_SELECTED, android.app.slice.Slice\#HINT_NO_TINT, android.app.slice.Slice\#HINT_SHORTCUT, android.app.slice.Slice.HINT_TOGGLE, android.app.slice.Slice\#HINT_HORIZONTAL, android.app.slice.Slice\#HINT_PARTIAL, android.app.slice.Slice\#HINT_SEE_MORE, android.app.slice.Slice\#HINT_KEYWORDS, android.app.slice.Slice\#HINT_ERROR, android.app.slice.Slice\#HINT_TTL, android.app.slice.Slice\#HINT_LAST_UPDATED, or android.app.slice.Slice\#HINT_PERMISSION_REQUEST
  ///@return true if this item contains the given hint
  bool hasHint(jni.JniString hint) => jniAccessors.callMethodWithArgs(reference,
      _id_hasHint, jni.JniType.booleanType, [hint.reference]).boolean;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
