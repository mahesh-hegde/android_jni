// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/ContentProvider.dart" as contentprovider_;

import "../../content/Context.dart" as context_;

import "../../content/pm/ProviderInfo.dart" as providerinfo_;

import "Slice.dart" as slice_;

import "../../net/Uri.dart" as uri_;

import "../../content/Intent.dart" as intent_;

import "../PendingIntent.dart" as pendingintent_;

import "../../content/ContentValues.dart" as contentvalues_;

import "../../database/Cursor.dart" as cursor_;

import "../../os/CancellationSignal.dart" as cancellationsignal_;

import "../../os/Bundle.dart" as bundle_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.slice.SliceProvider
///
/// A SliceProvider allows an app to provide content to be displayed in system spaces. This content
/// is templated and can contain actions, and the behavior of how it is surfaced is specific to the
/// system surface.
///
/// Slices are not currently live content. They are bound once and shown to the user. If the content
/// changes due to a callback from user interaction, then
/// ContentResolver\#notifyChange(Uri, ContentObserver) should be used to notify the system.
///
///
///
/// The provider needs to be declared in the manifest to provide the authority for the app. The
/// authority for most slices is expected to match the package of the application.
///
///
///
/// <pre class="prettyprint">
/// {@literal
/// <provider
///     android:name="com.example.mypkg.MySliceProvider"
///     android:authorities="com.example.mypkg" />}
/// </pre>
///
/// Slices can be identified by a Uri or by an Intent. To link an Intent with a slice, the provider
/// must have an IntentFilter matching the slice intent. When a slice is being requested via
/// an intent, \#onMapIntentToUri(Intent) can be called and is expected to return an
/// appropriate Uri representing the slice.
///
/// <pre class="prettyprint">
/// {@literal
/// <provider
///     android:name="com.example.mypkg.MySliceProvider"
///     android:authorities="com.example.mypkg">
///     <intent-filter>
///         <action android:name="com.example.mypkg.intent.action.MY_SLICE_INTENT" />
///         <category android:name="android.app.slice.category.SLICE" />
///     </intent-filter>
/// </provider>}
/// </pre>
///@see Slice
class SliceProvider extends contentprovider_.ContentProvider {
  static final _classRef =
      jniAccessors.getClassOf("android/app/slice/SliceProvider");
  SliceProvider.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String SLICE_TYPE
  ///
  /// This is the Android platform's MIME type for a URI
  /// containing a slice implemented through SliceProvider.
  static const SLICE_TYPE = "vnd.android.slice";

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String[] autoGrantPermissions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A version of constructing a SliceProvider that allows autogranting slice permissions
  /// to apps that hold specific platform permissions.
  ///
  /// When an app tries to bind a slice from this provider that it does not have access to,
  /// This provider will check if the caller holds permissions to any of the autoGrantPermissions
  /// specified, if they do they will be granted persisted uri access to all slices of this
  /// provider.
  ///@param autoGrantPermissions List of permissions that holders are auto-granted access
  ///                             to slices.
  ///
  /// This value must never be {@code null}.
  SliceProvider.ctor1(jni.JniObject autoGrantPermissions)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [autoGrantPermissions.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SliceProvider()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_attachInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "attachInfo",
      "(Landroid/content/Context;Landroid/content/pm/ProviderInfo;)V");

  /// from: public void attachInfo(android.content.Context context, android.content.pm.ProviderInfo info)
  void attachInfo(context_.Context context, providerinfo_.ProviderInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_attachInfo,
          jni.JniType.voidType, [context.reference, info.reference]).check();

  static final _id_onBindSlice = jniAccessors.getMethodIDOf(
      _classRef,
      "onBindSlice",
      "(Landroid/net/Uri;Ljava/util/Set;)Landroid/app/slice/Slice;");

  /// from: public android.app.slice.Slice onBindSlice(android.net.Uri sliceUri, java.util.Set<android.app.slice.SliceSpec> supportedSpecs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implemented to create a slice.
  ///
  /// onBindSlice should return as quickly as possible so that the UI tied
  /// to this slice can be responsive. No network or other IO will be allowed
  /// during onBindSlice. Any loading that needs to be done should happen
  /// in the background with a call to ContentResolver\#notifyChange(Uri, ContentObserver)
  /// when the app is ready to provide the complete data in onBindSlice.
  ///
  /// The slice returned should have a spec that is compatible with one of
  /// the supported specs.
  ///@param sliceUri Uri to bind.
  ///@param supportedSpecs List of supported specs.
  ///@see Slice.
  ///@see Slice\#HINT_PARTIAL
  slice_.Slice onBindSlice(uri_.Uri sliceUri, jni.JniObject supportedSpecs) =>
      slice_.Slice.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onBindSlice,
          jni.JniType.objectType,
          [sliceUri.reference, supportedSpecs.reference]).object);

  static final _id_onSlicePinned = jniAccessors.getMethodIDOf(
      _classRef, "onSlicePinned", "(Landroid/net/Uri;)V");

  /// from: public void onSlicePinned(android.net.Uri sliceUri)
  ///
  /// Called to inform an app that a slice has been pinned.
  ///
  /// Pinning is a way that slice hosts use to notify apps of which slices
  /// they care about updates for. When a slice is pinned the content is
  /// expected to be relatively fresh and kept up to date.
  ///
  /// Being pinned does not provide any escalated privileges for the slice
  /// provider. So apps should do things such as turn on syncing or schedule
  /// a job in response to a onSlicePinned.
  ///
  /// Pinned state is not persisted through a reboot, and apps can expect a
  /// new call to onSlicePinned for any slices that should remain pinned
  /// after a reboot occurs.
  ///@param sliceUri The uri of the slice being unpinned.
  ///@see \#onSliceUnpinned(Uri)
  void onSlicePinned(uri_.Uri sliceUri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSlicePinned,
      jni.JniType.voidType,
      [sliceUri.reference]).check();

  static final _id_onSliceUnpinned = jniAccessors.getMethodIDOf(
      _classRef, "onSliceUnpinned", "(Landroid/net/Uri;)V");

  /// from: public void onSliceUnpinned(android.net.Uri sliceUri)
  ///
  /// Called to inform an app that a slices is no longer pinned.
  ///
  /// This means that no other apps on the device care about updates to this
  /// slice anymore and therefore it is not important to be updated. Any syncs
  /// or jobs related to this slice should be cancelled.
  ///@see \#onSlicePinned(Uri)
  void onSliceUnpinned(uri_.Uri sliceUri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSliceUnpinned,
      jni.JniType.voidType,
      [sliceUri.reference]).check();

  static final _id_onGetSliceDescendants = jniAccessors.getMethodIDOf(_classRef,
      "onGetSliceDescendants", "(Landroid/net/Uri;)Ljava/util/Collection;");

  /// from: public java.util.Collection<android.net.Uri> onGetSliceDescendants(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a list of slices that are descendants of the specified Uri.
  ///
  /// Implementing this is optional for a SliceProvider, but does provide a good
  /// discovery mechanism for finding slice Uris.
  ///@param uri The uri to look for descendants under.
  /// This value must never be {@code null}.
  ///@return All slices within the space.
  /// This value will never be {@code null}.
  ///@see SliceManager\#getSliceDescendants(Uri)
  jni.JniObject onGetSliceDescendants(uri_.Uri uri) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetSliceDescendants,
          jni.JniType.objectType,
          [uri.reference]).object);

  static final _id_onMapIntentToUri = jniAccessors.getMethodIDOf(_classRef,
      "onMapIntentToUri", "(Landroid/content/Intent;)Landroid/net/Uri;");

  /// from: public android.net.Uri onMapIntentToUri(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method must be overridden if an IntentFilter is specified on the SliceProvider.
  /// In that case, this method can be called and is expected to return a non-null Uri representing
  /// a slice. Otherwise this will throw UnsupportedOperationException.
  ///
  /// Any intent filter added to a slice provider should also contain
  /// SliceManager\#CATEGORY_SLICE, because otherwise it will not be detected by
  /// SliceManager\#mapIntentToUri(Intent).
  ///@return Uri representing the slice associated with the provided intent.
  ///@see Slice
  ///@see SliceManager\#mapIntentToUri(Intent)
  uri_.Uri onMapIntentToUri(intent_.Intent intent) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onMapIntentToUri,
          jni.JniType.objectType,
          [intent.reference]).object);

  static final _id_onCreatePermissionRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreatePermissionRequest",
      "(Landroid/net/Uri;)Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent onCreatePermissionRequest(android.net.Uri sliceUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when an app requests a slice it does not have write permission
  /// to the uri for.
  ///
  /// The return value will be the action on a slice that prompts the user that
  /// the calling app wants to show slices from this app. The default implementation
  /// launches a dialog that allows the user to grant access to this slice. Apps
  /// that do not want to allow this user grant, can override this and instead
  /// launch their own dialog with different behavior.
  ///@param sliceUri the Uri of the slice attempting to be bound.
  ///@see \#getCallingPackage()
  ///@return This value will never be {@code null}.
  pendingintent_.PendingIntent onCreatePermissionRequest(uri_.Uri sliceUri) =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreatePermissionRequest,
          jni.JniType.objectType,
          [sliceUri.reference]).object);

  static final _id_update = jniAccessors.getMethodIDOf(_classRef, "update",
      "(Landroid/net/Uri;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public final int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs)
  int update(uri_.Uri uri, contentvalues_.ContentValues values,
          jni.JniString selection, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_update, jni.JniType.intType, [
        uri.reference,
        values.reference,
        selection.reference,
        selectionArgs.reference
      ]).integer;

  static final _id_delete1 = jniAccessors.getMethodIDOf(_classRef, "delete",
      "(Landroid/net/Uri;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public final int delete(android.net.Uri uri, java.lang.String selection, java.lang.String[] selectionArgs)
  int delete1(
          uri_.Uri uri, jni.JniString selection, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_delete1, jni.JniType.intType, [
        uri.reference,
        selection.reference,
        selectionArgs.reference
      ]).integer;

  static final _id_query = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  cursor_.Cursor query(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference
      ]).object);

  static final _id_query1 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  cursor_.Cursor query1(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query1, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_query2 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, android.os.Bundle queryArgs, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  cursor_.Cursor query2(
          uri_.Uri uri,
          jni.JniObject projection,
          bundle_.Bundle queryArgs,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query2, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        queryArgs.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_insert = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(Landroid/net/Uri;Landroid/content/ContentValues;)Landroid/net/Uri;");

  /// from: public final android.net.Uri insert(android.net.Uri uri, android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  uri_.Uri insert(uri_.Uri uri, contentvalues_.ContentValues values) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference, _id_insert,
          jni.JniType.objectType, [uri.reference, values.reference]).object);

  static final _id_getType = jniAccessors.getMethodIDOf(
      _classRef, "getType", "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: public final java.lang.String getType(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getType(uri_.Uri uri) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getType, jni.JniType.objectType, [uri.reference]).object);

  static final _id_call = jniAccessors.getMethodIDOf(_classRef, "call",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle call(java.lang.String method, java.lang.String arg, android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  bundle_.Bundle call(
          jni.JniString method, jni.JniString arg, bundle_.Bundle extras) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_call,
          jni.JniType.objectType,
          [method.reference, arg.reference, extras.reference]).object);
}
