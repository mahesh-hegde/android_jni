// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../os/Handler.dart" as handler_;

import "Notification.dart" as notification_;

import "NotificationChannelGroup.dart" as notificationchannelgroup_;

import "NotificationChannel.dart" as notificationchannel_;

import "AutomaticZenRule.dart" as automaticzenrule_;

import "../content/ComponentName.dart" as componentname_;

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.NotificationManager
///
/// Class to notify the user of events that happen.  This is how you tell
/// the user that something has happened in the background. {@more }
///
/// Notifications can take different forms:
/// <ul>
///      <li>A persistent icon that goes in the status bar and is accessible
///          through the launcher, (when the user selects it, a designated Intent
///          can be launched),</li>
///      <li>Turning on or flashing LEDs on the device, or</li>
///      <li>Alerting the user by flashing the backlight, playing a sound,
///          or vibrating.</li>
/// </ul>
///
///
/// Each of the notify methods takes an int id parameter and optionally a
/// String tag parameter, which may be {@code null}.  These parameters
/// are used to form a pair (tag, id), or ({@code null}, id) if tag is
/// unspecified.  This pair identifies this notification from your app to the
/// system, so that pair should be unique within your app.  If you call one
/// of the notify methods with a (tag, id) pair that is currently active and
/// a new set of notification parameters, it will be updated.  For example,
/// if you pass a new status bar icon, the old icon in the status bar will
/// be replaced with the new one.  This is also the same tag and id you pass
/// to the \#cancel(int) or \#cancel(String, int) method to clear
/// this notification.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a guide to creating notifications, read the
/// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html">Status Bar Notifications</a>
/// developer guide.
///
/// </div>
///@see android.app.Notification
class NotificationManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/NotificationManager");
  NotificationManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_APP_BLOCK_STATE_CHANGED
  ///
  /// Intent that is broadcast when an application is blocked or unblocked.
  ///
  /// This broadcast is only sent to the app whose block state has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_APP_BLOCK_STATE_CHANGED =
      "android.app.action.APP_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_INTERRUPTION_FILTER_CHANGED
  ///
  /// Intent that is broadcast when the state of getCurrentInterruptionFilter() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_INTERRUPTION_FILTER_CHANGED =
      "android.app.action.INTERRUPTION_FILTER_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED
  ///
  /// Intent that is broadcast when a NotificationChannel is blocked
  /// (when NotificationChannel\#getImportance() is \#IMPORTANCE_NONE) or unblocked
  /// (when NotificationChannel\#getImportance() is anything other than
  /// \#IMPORTANCE_NONE).
  ///
  /// This broadcast is only sent to the app that owns the channel that has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_NOTIFICATION_CHANNEL_ID
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED =
      "android.app.action.NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED
  ///
  /// Intent that is broadcast when a NotificationChannelGroup is
  /// NotificationChannelGroup\#isBlocked() blocked or unblocked.
  ///
  /// This broadcast is only sent to the app that owns the channel group that has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_NOTIFICATION_CHANNEL_GROUP_ID
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED =
      "android.app.action.NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED
  ///
  /// Intent that is broadcast when the state of \#isNotificationPolicyAccessGranted()
  /// changes.
  ///
  /// This broadcast is only sent to registered receivers, and only to the apps that have changed.
  static const ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED =
      "android.app.action.NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_POLICY_CHANGED
  ///
  /// Intent that is broadcast when the state of getNotificationPolicy() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_NOTIFICATION_POLICY_CHANGED =
      "android.app.action.NOTIFICATION_POLICY_CHANGED";

  /// from: static public final java.lang.String EXTRA_BLOCKED_STATE
  ///
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED or
  /// \#ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED containing the new blocked
  /// state as a boolean.
  ///
  /// The value will be {@code true} if this channel or group is now blocked and {@code false} if
  /// this channel or group is now unblocked.
  static const EXTRA_BLOCKED_STATE = "android.app.extra.BLOCKED_STATE";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CHANNEL_GROUP_ID
  ///
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED containing the id
  /// of the NotificationChannelGroup which has a new blocked state.
  ///
  /// The value will be the NotificationChannelGroup\#getId() of the group.
  static const EXTRA_NOTIFICATION_CHANNEL_GROUP_ID =
      "android.app.extra.NOTIFICATION_CHANNEL_GROUP_ID";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CHANNEL_ID
  ///
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED containing the id of the
  /// NotificationChannel which has a new blocked state.
  ///
  /// The value will be the NotificationChannel\#getId() of the channel.
  static const EXTRA_NOTIFICATION_CHANNEL_ID =
      "android.app.extra.NOTIFICATION_CHANNEL_ID";

  /// from: static public final int IMPORTANCE_DEFAULT
  ///
  /// Default notification importance: shows everywhere, makes noise, but does not visually
  /// intrude.
  static const IMPORTANCE_DEFAULT = 3;

  /// from: static public final int IMPORTANCE_HIGH
  ///
  /// Higher notification importance: shows everywhere, makes noise and peeks. May use full screen
  /// intents.
  static const IMPORTANCE_HIGH = 4;

  /// from: static public final int IMPORTANCE_LOW
  ///
  /// Low notification importance: shows everywhere, but is not intrusive.
  static const IMPORTANCE_LOW = 2;

  /// from: static public final int IMPORTANCE_MAX
  ///
  /// Unused.
  static const IMPORTANCE_MAX = 5;

  /// from: static public final int IMPORTANCE_MIN
  ///
  /// Min notification importance: only shows in the shade, below the fold.  This should
  /// not be used with Service\#startForeground(int, Notification) Service.startForeground
  /// since a foreground service is supposed to be something the user cares about so it does
  /// not make semantic sense to mark its notification as minimum importance.  If you do this
  /// as of Android version android.os.Build.VERSION_CODES\#O, the system will show
  /// a higher-priority notification about your app running in the background.
  static const IMPORTANCE_MIN = 1;

  /// from: static public final int IMPORTANCE_NONE
  ///
  /// A notification with no importance: does not show in the shade.
  static const IMPORTANCE_NONE = 0;

  /// from: static public final int IMPORTANCE_UNSPECIFIED
  ///
  /// Value signifying that the user has not expressed an importance.
  ///
  /// This value is for persisting preferences, and should never be associated with
  /// an actual notification.
  static const IMPORTANCE_UNSPECIFIED = -1000;

  /// from: static public final int INTERRUPTION_FILTER_ALARMS
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Alarms only interruption filter - all notifications except those of category
  ///     Notification\#CATEGORY_ALARM are suppressed. Some audio streams are muted.
  static const INTERRUPTION_FILTER_ALARMS = 4;

  /// from: static public final int INTERRUPTION_FILTER_ALL
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Normal interruption filter - no notifications are suppressed.
  static const INTERRUPTION_FILTER_ALL = 1;

  /// from: static public final int INTERRUPTION_FILTER_NONE
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     No interruptions filter - all notifications are suppressed and all audio streams (except
  ///     those used for phone calls) and vibrations are muted.
  static const INTERRUPTION_FILTER_NONE = 3;

  /// from: static public final int INTERRUPTION_FILTER_PRIORITY
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Priority interruption filter - all notifications are suppressed except those that match
  ///     the priority criteria. Some audio streams are muted. See
  ///     Policy\#priorityCallSenders, Policy\#priorityCategories,
  ///     Policy\#priorityMessageSenders to define or query this criteria. Users can
  ///     additionally specify packages that can bypass this interruption filter.
  static const INTERRUPTION_FILTER_PRIORITY = 2;

  /// from: static public final int INTERRUPTION_FILTER_UNKNOWN
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant - returned when
  /// the value is unavailable for any reason.
  static const INTERRUPTION_FILTER_UNKNOWN = 0;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Landroid/os/Handler;)V");

  /// from: void <init>(android.content.Context context, android.os.Handler handler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  NotificationManager(context_.Context context, handler_.Handler handler)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [context.reference, handler.reference]).object);

  static final _id_notify = jniAccessors.getMethodIDOf(
      _classRef, "notify", "(ILandroid/app/Notification;)V");

  /// from: public void notify(int id, android.app.Notification notification)
  ///
  /// Post a notification to be shown in the status bar. If a notification with
  /// the same id has already been posted by your application and has not yet been canceled, it
  /// will be replaced by the updated information.
  ///@param id An identifier for this notification unique within your
  ///        application.
  ///@param notification A Notification object describing what to show the user. Must not
  ///        be null.
  void notify(int id, notification_.Notification notification) =>
      jniAccessors.callMethodWithArgs(reference, _id_notify,
          jni.JniType.voidType, [id, notification.reference]).check();

  static final _id_notify1 = jniAccessors.getMethodIDOf(
      _classRef, "notify", "(Ljava/lang/String;ILandroid/app/Notification;)V");

  /// from: public void notify(java.lang.String tag, int id, android.app.Notification notification)
  ///
  /// Post a notification to be shown in the status bar. If a notification with
  /// the same tag and id has already been posted by your application and has not yet been
  /// canceled, it will be replaced by the updated information.
  ///
  /// All android.service.notification.NotificationListenerService listener services will
  /// be granted Intent\#FLAG_GRANT_READ_URI_PERMISSION access to any Uri uris
  /// provided on this notification or the
  /// NotificationChannel this notification is posted to using
  /// Context\#grantUriPermission(String, Uri, int). Permission will be revoked when the
  /// notification is canceled, or you can revoke permissions with
  /// Context\#revokeUriPermission(Uri, int).
  ///@param tag A string identifier for this notification.  May be {@code null}.
  ///@param id An identifier for this notification.  The pair (tag, id) must be unique
  ///        within your application.
  ///@param notification A Notification object describing what to
  ///        show the user. Must not be null.
  void notify1(
          jni.JniString tag, int id, notification_.Notification notification) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notify1,
          jni.JniType.voidType,
          [tag.reference, id, notification.reference]).check();

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "(I)V");

  /// from: public void cancel(int id)
  ///
  /// Cancel a previously shown notification.  If it's transient, the view
  /// will be hidden.  If it's persistent, it will be removed from the status
  /// bar.
  void cancel(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, [id]).check();

  static final _id_cancel1 =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "(Ljava/lang/String;I)V");

  /// from: public void cancel(java.lang.String tag, int id)
  ///
  /// Cancel a previously shown notification.  If it's transient, the view
  /// will be hidden.  If it's persistent, it will be removed from the status
  /// bar.
  void cancel1(jni.JniString tag, int id) => jniAccessors.callMethodWithArgs(
      reference,
      _id_cancel1,
      jni.JniType.voidType,
      [tag.reference, id]).check();

  static final _id_cancelAll =
      jniAccessors.getMethodIDOf(_classRef, "cancelAll", "()V");

  /// from: public void cancelAll()
  ///
  /// Cancel all previously shown notifications. See \#cancel for the
  /// detailed behavior.
  void cancelAll() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelAll, jni.JniType.voidType, []).check();

  static final _id_createNotificationChannelGroup = jniAccessors.getMethodIDOf(
      _classRef,
      "createNotificationChannelGroup",
      "(Landroid/app/NotificationChannelGroup;)V");

  /// from: public void createNotificationChannelGroup(android.app.NotificationChannelGroup group)
  ///
  /// Creates a group container for NotificationChannel objects.
  ///
  /// This can be used to rename an existing group.
  ///
  ///     Group information is only used for presentation, not for behavior. Groups are optional
  ///     for channels, and you can have a mix of channels that belong to groups and channels
  ///     that do not.
  ///
  ///
  ///
  ///     For example, if your application supports multiple accounts, and those accounts will
  ///     have similar channels, you can create a group for each account with account specific
  ///     labels instead of appending account information to each channel's label.
  ///
  ///
  ///@param group The group to create
  ///
  /// This value must never be {@code null}.
  void createNotificationChannelGroup(
          notificationchannelgroup_.NotificationChannelGroup group) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_createNotificationChannelGroup,
          jni.JniType.voidType,
          [group.reference]).check();

  static final _id_createNotificationChannelGroups = jniAccessors.getMethodIDOf(
      _classRef, "createNotificationChannelGroups", "(Ljava/util/List;)V");

  /// from: public void createNotificationChannelGroups(java.util.List<android.app.NotificationChannelGroup> groups)
  ///
  /// Creates multiple notification channel groups.
  ///@param groups The list of groups to create
  ///
  /// This value must never be {@code null}.
  void createNotificationChannelGroups(jni.JniObject groups) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_createNotificationChannelGroups,
          jni.JniType.voidType,
          [groups.reference]).check();

  static final _id_createNotificationChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "createNotificationChannel",
      "(Landroid/app/NotificationChannel;)V");

  /// from: public void createNotificationChannel(android.app.NotificationChannel channel)
  ///
  /// Creates a notification channel that notifications can be posted to.
  ///
  /// This can also be used to restore a deleted channel and to update an existing channel's
  /// name, description, group, and/or importance.
  ///
  /// The name and description should only be changed if the locale changes
  /// or in response to the user renaming this channel. For example, if a user has a channel
  /// named 'John Doe' that represents messages from a 'John Doe', and 'John Doe' changes his name
  /// to 'John Smith,' the channel can be renamed to match.
  ///
  /// The importance of an existing channel will only be changed if the new importance is lower
  /// than the current value and the user has not altered any settings on this channel.
  ///
  /// The group an existing channel will only be changed if the channel does not already
  /// belong to a group.
  ///
  /// All other fields are ignored for channels that already exist.
  ///@param channel the channel to create.  Note that the created channel may differ from this
  ///                 value. If the provided channel is malformed, a RemoteException will be
  ///                 thrown.
  ///
  /// This value must never be {@code null}.
  void createNotificationChannel(
          notificationchannel_.NotificationChannel channel) =>
      jniAccessors.callMethodWithArgs(reference, _id_createNotificationChannel,
          jni.JniType.voidType, [channel.reference]).check();

  static final _id_createNotificationChannels = jniAccessors.getMethodIDOf(
      _classRef, "createNotificationChannels", "(Ljava/util/List;)V");

  /// from: public void createNotificationChannels(java.util.List<android.app.NotificationChannel> channels)
  ///
  /// Creates multiple notification channels that different notifications can be posted to. See
  /// \#createNotificationChannel(NotificationChannel).
  ///@param channels the list of channels to attempt to create.
  ///
  /// This value must never be {@code null}.
  void createNotificationChannels(jni.JniObject channels) =>
      jniAccessors.callMethodWithArgs(reference, _id_createNotificationChannels,
          jni.JniType.voidType, [channels.reference]).check();

  static final _id_getNotificationChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "getNotificationChannel",
      "(Ljava/lang/String;)Landroid/app/NotificationChannel;");

  /// from: public android.app.NotificationChannel getNotificationChannel(java.lang.String channelId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the notification channel settings for a given channel id.
  ///
  /// The channel must belong to your package, or it will not be returned.
  notificationchannel_.NotificationChannel getNotificationChannel(
          jni.JniString channelId) =>
      notificationchannel_.NotificationChannel.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getNotificationChannel,
              jni.JniType.objectType, [channelId.reference]).object);

  static final _id_getNotificationChannels = jniAccessors.getMethodIDOf(
      _classRef, "getNotificationChannels", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.NotificationChannel> getNotificationChannels()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all notification channels belonging to the calling package.
  jni.JniObject getNotificationChannels() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNotificationChannels, jni.JniType.objectType, []).object);

  static final _id_deleteNotificationChannel = jniAccessors.getMethodIDOf(
      _classRef, "deleteNotificationChannel", "(Ljava/lang/String;)V");

  /// from: public void deleteNotificationChannel(java.lang.String channelId)
  ///
  /// Deletes the given notification channel.
  ///
  /// If you \#createNotificationChannel(NotificationChannel) create a new channel with
  /// this same id, the deleted channel will be un-deleted with all of the same settings it
  /// had before it was deleted.
  void deleteNotificationChannel(jni.JniString channelId) =>
      jniAccessors.callMethodWithArgs(reference, _id_deleteNotificationChannel,
          jni.JniType.voidType, [channelId.reference]).check();

  static final _id_getNotificationChannelGroup = jniAccessors.getMethodIDOf(
      _classRef,
      "getNotificationChannelGroup",
      "(Ljava/lang/String;)Landroid/app/NotificationChannelGroup;");

  /// from: public android.app.NotificationChannelGroup getNotificationChannelGroup(java.lang.String channelGroupId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the notification channel group settings for a given channel group id.
  ///
  /// The channel group must belong to your package, or null will be returned.
  notificationchannelgroup_.NotificationChannelGroup
      getNotificationChannelGroup(jni.JniString channelGroupId) =>
          notificationchannelgroup_.NotificationChannelGroup.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_getNotificationChannelGroup,
                  jni.JniType.objectType,
                  [channelGroupId.reference]).object);

  static final _id_getNotificationChannelGroups = jniAccessors.getMethodIDOf(
      _classRef, "getNotificationChannelGroups", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.NotificationChannelGroup> getNotificationChannelGroups()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all notification channel groups belonging to the calling app.
  jni.JniObject getNotificationChannelGroups() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNotificationChannelGroups, jni.JniType.objectType, []).object);

  static final _id_deleteNotificationChannelGroup = jniAccessors.getMethodIDOf(
      _classRef, "deleteNotificationChannelGroup", "(Ljava/lang/String;)V");

  /// from: public void deleteNotificationChannelGroup(java.lang.String groupId)
  ///
  /// Deletes the given notification channel group, and all notification channels that
  /// belong to it.
  void deleteNotificationChannelGroup(jni.JniString groupId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_deleteNotificationChannelGroup,
          jni.JniType.voidType,
          [groupId.reference]).check();

  static final _id_getAutomaticZenRules = jniAccessors.getMethodIDOf(
      _classRef, "getAutomaticZenRules", "()Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,android.app.AutomaticZenRule> getAutomaticZenRules()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns AutomaticZenRules owned by the caller.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  jni.JniObject getAutomaticZenRules() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAutomaticZenRules, jni.JniType.objectType, []).object);

  static final _id_getAutomaticZenRule = jniAccessors.getMethodIDOf(
      _classRef,
      "getAutomaticZenRule",
      "(Ljava/lang/String;)Landroid/app/AutomaticZenRule;");

  /// from: public android.app.AutomaticZenRule getAutomaticZenRule(java.lang.String id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the AutomaticZenRule with the given id, if it exists and the caller has access.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Returns null if there are no zen rules that match the given id, or if the calling package
  /// doesn't own the matching rule. See AutomaticZenRule\#getOwner.
  automaticzenrule_.AutomaticZenRule getAutomaticZenRule(jni.JniString id) =>
      automaticzenrule_.AutomaticZenRule.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getAutomaticZenRule,
              jni.JniType.objectType, [id.reference]).object);

  static final _id_addAutomaticZenRule = jniAccessors.getMethodIDOf(
      _classRef,
      "addAutomaticZenRule",
      "(Landroid/app/AutomaticZenRule;)Ljava/lang/String;");

  /// from: public java.lang.String addAutomaticZenRule(android.app.AutomaticZenRule automaticZenRule)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the given zen rule.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///@param automaticZenRule the rule to create.
  ///@return The id of the newly created rule; null if the rule could not be created.
  jni.JniString addAutomaticZenRule(
          automaticzenrule_.AutomaticZenRule automaticZenRule) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addAutomaticZenRule,
          jni.JniType.objectType,
          [automaticZenRule.reference]).object);

  static final _id_updateAutomaticZenRule = jniAccessors.getMethodIDOf(
      _classRef,
      "updateAutomaticZenRule",
      "(Ljava/lang/String;Landroid/app/AutomaticZenRule;)Z");

  /// from: public boolean updateAutomaticZenRule(java.lang.String id, android.app.AutomaticZenRule automaticZenRule)
  ///
  /// Updates the given zen rule.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Callers can only update rules that they own. See AutomaticZenRule\#getOwner.
  ///@param id The id of the rule to update
  ///@param automaticZenRule the rule to update.
  ///@return Whether the rule was successfully updated.
  bool updateAutomaticZenRule(jni.JniString id,
          automaticzenrule_.AutomaticZenRule automaticZenRule) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_updateAutomaticZenRule,
          jni.JniType.booleanType,
          [id.reference, automaticZenRule.reference]).boolean;

  static final _id_removeAutomaticZenRule = jniAccessors.getMethodIDOf(
      _classRef, "removeAutomaticZenRule", "(Ljava/lang/String;)Z");

  /// from: public boolean removeAutomaticZenRule(java.lang.String id)
  ///
  /// Deletes the automatic zen rule with the given id.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Callers can only delete rules that they own. See AutomaticZenRule\#getOwner.
  ///@param id the id of the rule to delete.
  ///@return Whether the rule was successfully deleted.
  bool removeAutomaticZenRule(jni.JniString id) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeAutomaticZenRule,
          jni.JniType.booleanType, [id.reference]).boolean;

  static final _id_getImportance =
      jniAccessors.getMethodIDOf(_classRef, "getImportance", "()I");

  /// from: public int getImportance()
  ///
  /// Returns the user specified importance for notifications from the calling
  /// package.
  ///@return Value is android.app.NotificationManager\#IMPORTANCE_UNSPECIFIED, android.app.NotificationManager\#IMPORTANCE_NONE, android.app.NotificationManager\#IMPORTANCE_MIN, android.app.NotificationManager\#IMPORTANCE_LOW, android.app.NotificationManager\#IMPORTANCE_DEFAULT, or android.app.NotificationManager\#IMPORTANCE_HIGH
  int getImportance() => jniAccessors.callMethodWithArgs(
      reference, _id_getImportance, jni.JniType.intType, []).integer;

  static final _id_areNotificationsEnabled =
      jniAccessors.getMethodIDOf(_classRef, "areNotificationsEnabled", "()Z");

  /// from: public boolean areNotificationsEnabled()
  ///
  /// Returns whether notifications from the calling package are blocked.
  bool areNotificationsEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_areNotificationsEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_isNotificationPolicyAccessGranted = jniAccessors
      .getMethodIDOf(_classRef, "isNotificationPolicyAccessGranted", "()Z");

  /// from: public boolean isNotificationPolicyAccessGranted()
  ///
  /// Checks the ability to modify notification do not disturb policy for the calling package.
  ///
  ///
  /// Returns true if the calling package can modify notification policy.
  ///
  ///
  /// Apps can request policy access by sending the user to the activity that matches the system
  /// intent action android.provider.Settings\#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS.
  ///
  ///
  /// Use \#ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED to listen for
  /// user grant or denial of this access.
  bool isNotificationPolicyAccessGranted() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isNotificationPolicyAccessGranted,
      jni.JniType.booleanType, []).boolean;

  static final _id_isNotificationListenerAccessGranted =
      jniAccessors.getMethodIDOf(
          _classRef,
          "isNotificationListenerAccessGranted",
          "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isNotificationListenerAccessGranted(android.content.ComponentName listener)
  ///
  /// Checks whether the user has approved a given
  /// android.service.notification.NotificationListenerService.
  ///
  ///
  /// The listener service must belong to the calling app.
  ///
  ///
  /// Apps can request notification listener access by sending the user to the activity that
  /// matches the system intent action
  /// android.provider.Settings\#ACTION_NOTIFICATION_LISTENER_SETTINGS.
  bool isNotificationListenerAccessGranted(
          componentname_.ComponentName listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isNotificationListenerAccessGranted,
          jni.JniType.booleanType,
          [listener.reference]).boolean;

  static final _id_getNotificationPolicy = jniAccessors.getMethodIDOf(_classRef,
      "getNotificationPolicy", "()Landroid/app/NotificationManager\$Policy;");

  /// from: public android.app.NotificationManager.Policy getNotificationPolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current notification policy.
  ///
  ///
  NotificationManager_Policy getNotificationPolicy() =>
      NotificationManager_Policy.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNotificationPolicy,
          jni.JniType.objectType, []).object);

  static final _id_setNotificationPolicy = jniAccessors.getMethodIDOf(_classRef,
      "setNotificationPolicy", "(Landroid/app/NotificationManager\$Policy;)V");

  /// from: public void setNotificationPolicy(android.app.NotificationManager.Policy policy)
  ///
  /// Sets the current notification policy.
  ///
  ///
  /// Only available if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///@param policy The new desired policy.
  ///
  /// This value must never be {@code null}.
  void setNotificationPolicy(NotificationManager_Policy policy) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNotificationPolicy,
          jni.JniType.voidType, [policy.reference]).check();

  static final _id_getActiveNotifications = jniAccessors.getMethodIDOf(
      _classRef,
      "getActiveNotifications",
      "()[Landroid/service/notification/StatusBarNotification;");

  /// from: public android.service.notification.StatusBarNotification[] getActiveNotifications()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Recover a list of active notifications: ones that have been posted by the calling app that
  /// have not yet been dismissed by the user or \#cancel(String, int)ed by the app.
  ///
  /// Each notification is embedded in a StatusBarNotification object, including the
  /// original <code>tag</code> and <code>id</code> supplied to
  /// \#notify(String, int, Notification) notify()
  /// (via StatusBarNotification\#getTag() getTag() and
  /// StatusBarNotification\#getId() getId()) as well as a copy of the original
  /// Notification object (via StatusBarNotification\#getNotification()).
  ///@return An array of StatusBarNotification.
  jni.JniObject getActiveNotifications() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getActiveNotifications, jni.JniType.objectType, []).object);

  static final _id_getCurrentInterruptionFilter = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentInterruptionFilter", "()I");

  /// from: public final int getCurrentInterruptionFilter()
  ///
  /// Gets the current notification interruption filter.
  ///
  /// The interruption filter defines which notifications are allowed to
  /// interrupt the user (e.g. via sound &amp; vibration) and is applied
  /// globally.
  ///@return Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  int getCurrentInterruptionFilter() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCurrentInterruptionFilter,
      jni.JniType.intType, []).integer;

  static final _id_setInterruptionFilter =
      jniAccessors.getMethodIDOf(_classRef, "setInterruptionFilter", "(I)V");

  /// from: public final void setInterruptionFilter(int interruptionFilter)
  ///
  /// Sets the current notification interruption filter.
  ///
  /// The interruption filter defines which notifications are allowed to
  /// interrupt the user (e.g. via sound &amp; vibration) and is applied
  /// globally.
  ///
  /// Only available if policy access is granted to this package. See
  /// \#isNotificationPolicyAccessGranted.
  ///@param interruptionFilter Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  void setInterruptionFilter(int interruptionFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInterruptionFilter,
          jni.JniType.voidType, [interruptionFilter]).check();
}

/// from: android.app.NotificationManager$Policy
///
/// Notification policy configuration.  Represents user-preferences for notification
/// filtering.
class NotificationManager_Policy extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/NotificationManager\$Policy");
  NotificationManager_Policy.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.NotificationManager.Policy> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int PRIORITY_CATEGORY_ALARMS
  ///
  /// Alarms are prioritized
  static const PRIORITY_CATEGORY_ALARMS = 32;

  /// from: static public final int PRIORITY_CATEGORY_CALLS
  ///
  /// Calls are prioritized.
  static const PRIORITY_CATEGORY_CALLS = 8;

  /// from: static public final int PRIORITY_CATEGORY_EVENTS
  ///
  /// Event notifications are prioritized.
  static const PRIORITY_CATEGORY_EVENTS = 2;

  /// from: static public final int PRIORITY_CATEGORY_MEDIA
  ///
  /// Media, game, voice navigation are prioritized
  static const PRIORITY_CATEGORY_MEDIA = 64;

  /// from: static public final int PRIORITY_CATEGORY_MESSAGES
  ///
  /// Message notifications are prioritized.
  static const PRIORITY_CATEGORY_MESSAGES = 4;

  /// from: static public final int PRIORITY_CATEGORY_REMINDERS
  ///
  /// Reminder notifications are prioritized.
  static const PRIORITY_CATEGORY_REMINDERS = 1;

  /// from: static public final int PRIORITY_CATEGORY_REPEAT_CALLERS
  ///
  /// Calls from repeat callers are prioritized.
  static const PRIORITY_CATEGORY_REPEAT_CALLERS = 16;

  /// from: static public final int PRIORITY_CATEGORY_SYSTEM
  ///
  /// System (catch-all for non-never suppressible sounds) are prioritized
  static const PRIORITY_CATEGORY_SYSTEM = 128;

  /// from: static public final int PRIORITY_SENDERS_ANY
  ///
  /// Any sender is prioritized.
  static const PRIORITY_SENDERS_ANY = 0;

  /// from: static public final int PRIORITY_SENDERS_CONTACTS
  ///
  /// Saved contacts are prioritized.
  static const PRIORITY_SENDERS_CONTACTS = 1;

  /// from: static public final int PRIORITY_SENDERS_STARRED
  ///
  /// Only starred contacts are prioritized.
  static const PRIORITY_SENDERS_STARRED = 2;

  /// from: static public final int SUPPRESSED_EFFECT_AMBIENT
  ///
  /// Whether notification intercepted by DND are prevented from appearing on ambient displays
  /// on devices that support ambient display.
  static const SUPPRESSED_EFFECT_AMBIENT = 128;

  /// from: static public final int SUPPRESSED_EFFECT_BADGE
  ///
  /// Whether NotificationChannel\#canShowBadge() badges from
  /// notifications intercepted by DND are blocked on devices that support badging.
  static const SUPPRESSED_EFFECT_BADGE = 64;

  /// from: static public final int SUPPRESSED_EFFECT_FULL_SCREEN_INTENT
  ///
  /// Whether Notification\#fullScreenIntent full screen intents from
  /// notifications intercepted by DND are blocked.
  static const SUPPRESSED_EFFECT_FULL_SCREEN_INTENT = 4;

  /// from: static public final int SUPPRESSED_EFFECT_LIGHTS
  ///
  /// Whether NotificationChannel\#shouldShowLights() notification lights from
  /// notifications intercepted by DND are blocked.
  static const SUPPRESSED_EFFECT_LIGHTS = 8;

  /// from: static public final int SUPPRESSED_EFFECT_NOTIFICATION_LIST
  ///
  /// Whether notification intercepted by DND are prevented from appearing in notification
  /// list views like the notification shade or lockscreen on devices that support those
  /// views.
  static const SUPPRESSED_EFFECT_NOTIFICATION_LIST = 256;

  /// from: static public final int SUPPRESSED_EFFECT_PEEK
  ///
  /// Whether notifications intercepted by DND are prevented from peeking.
  static const SUPPRESSED_EFFECT_PEEK = 16;

  /// from: static public final int SUPPRESSED_EFFECT_SCREEN_OFF
  ///
  /// Whether notifications suppressed by DND should not interrupt visually (e.g.&nbsp;with
  /// notification lights or by turning the screen on) when the screen is off.
  ///@deprecated use \#SUPPRESSED_EFFECT_FULL_SCREEN_INTENT and
  /// \#SUPPRESSED_EFFECT_AMBIENT and \#SUPPRESSED_EFFECT_LIGHTS individually.
  static const SUPPRESSED_EFFECT_SCREEN_OFF = 1;

  /// from: static public final int SUPPRESSED_EFFECT_SCREEN_ON
  ///
  /// Whether notifications suppressed by DND should not interrupt visually when the screen
  /// is on (e.g.&nbsp;by peeking onto the screen).
  ///@deprecated use \#SUPPRESSED_EFFECT_PEEK.
  static const SUPPRESSED_EFFECT_SCREEN_ON = 2;

  /// from: static public final int SUPPRESSED_EFFECT_STATUS_BAR
  ///
  /// Whether notifications intercepted by DND are prevented from appearing in the status bar,
  /// on devices that support status bars.
  static const SUPPRESSED_EFFECT_STATUS_BAR = 32;

  static final _id_priorityCallSenders =
      jniAccessors.getFieldIDOf(_classRef, "priorityCallSenders", "I");

  /// from: public final int priorityCallSenders
  ///
  /// Notification senders to prioritize for calls. One of:
  /// PRIORITY_SENDERS_ANY, PRIORITY_SENDERS_CONTACTS, PRIORITY_SENDERS_STARRED
  int get priorityCallSenders => jniAccessors
      .getField(reference, _id_priorityCallSenders, jni.JniType.intType)
      .integer;

  static final _id_priorityCategories =
      jniAccessors.getFieldIDOf(_classRef, "priorityCategories", "I");

  /// from: public final int priorityCategories
  ///
  /// Notification categories to prioritize. Bitmask of PRIORITY_CATEGORY_* constants.
  int get priorityCategories => jniAccessors
      .getField(reference, _id_priorityCategories, jni.JniType.intType)
      .integer;

  static final _id_priorityMessageSenders =
      jniAccessors.getFieldIDOf(_classRef, "priorityMessageSenders", "I");

  /// from: public final int priorityMessageSenders
  ///
  /// Notification senders to prioritize for messages. One of:
  /// PRIORITY_SENDERS_ANY, PRIORITY_SENDERS_CONTACTS, PRIORITY_SENDERS_STARRED
  int get priorityMessageSenders => jniAccessors
      .getField(reference, _id_priorityMessageSenders, jni.JniType.intType)
      .integer;

  static final _id_suppressedVisualEffects =
      jniAccessors.getFieldIDOf(_classRef, "suppressedVisualEffects", "I");

  /// from: public final int suppressedVisualEffects
  ///
  /// Visual effects to suppress for a notification that is filtered by Do Not Disturb mode.
  /// Bitmask of SUPPRESSED_EFFECT_* constants.
  int get suppressedVisualEffects => jniAccessors
      .getField(reference, _id_suppressedVisualEffects, jni.JniType.intType)
      .integer;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(III)V");

  /// from: public void <init>(int priorityCategories, int priorityCallSenders, int priorityMessageSenders)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a policy for Do Not Disturb priority mode behavior.
  ///
  ///
  ///     Apps that target API levels below Build.VERSION_CODES\#P cannot
  ///     change user-designated values to allow or disallow
  ///     Policy\#PRIORITY_CATEGORY_ALARMS, Policy\#PRIORITY_CATEGORY_SYSTEM, and
  ///     Policy\#PRIORITY_CATEGORY_MEDIA from bypassing dnd.
  ///@param priorityCategories bitmask of categories of notifications that can bypass DND.
  ///@param priorityCallSenders which callers can bypass DND.
  ///@param priorityMessageSenders which message senders can bypass DND.
  NotificationManager_Policy(int priorityCategories, int priorityCallSenders,
      int priorityMessageSenders)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          priorityCategories,
          priorityCallSenders,
          priorityMessageSenders
        ]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIII)V");

  /// from: public void <init>(int priorityCategories, int priorityCallSenders, int priorityMessageSenders, int suppressedVisualEffects)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a policy for Do Not Disturb priority mode behavior.
  ///
  ///
  ///     Apps that target API levels below Build.VERSION_CODES\#P cannot
  ///     change user-designated values to allow or disallow
  ///     Policy\#PRIORITY_CATEGORY_ALARMS, Policy\#PRIORITY_CATEGORY_SYSTEM, and
  ///     Policy\#PRIORITY_CATEGORY_MEDIA from bypassing dnd.
  ///
  ///     Additionally, apps that target API levels below Build.VERSION_CODES\#P can
  ///     only modify the \#SUPPRESSED_EFFECT_SCREEN_ON and
  ///     \#SUPPRESSED_EFFECT_SCREEN_OFF bits of the suppressed visual effects field.
  ///     All other suppressed effects will be ignored and reconstituted from the screen on
  ///     and screen off values.
  ///
  ///     Apps that target Build.VERSION_CODES\#P or above can set any
  ///     suppressed visual effects. However, if any suppressed effects >
  ///     \#SUPPRESSED_EFFECT_SCREEN_ON are set, \#SUPPRESSED_EFFECT_SCREEN_ON
  ///     and \#SUPPRESSED_EFFECT_SCREEN_OFF will be ignored and reconstituted from
  ///     the more specific suppressed visual effect bits. Apps should migrate to targeting
  ///     specific effects instead of the deprecated \#SUPPRESSED_EFFECT_SCREEN_ON and
  ///     \#SUPPRESSED_EFFECT_SCREEN_OFF effects.
  ///@param priorityCategories bitmask of categories of notifications that can bypass DND.
  ///@param priorityCallSenders which callers can bypass DND.
  ///@param priorityMessageSenders which message senders can bypass DND.
  ///@param suppressedVisualEffects which visual interruptions should be suppressed from
  ///                                notifications that are filtered by DND.
  NotificationManager_Policy.ctor1(
      int priorityCategories,
      int priorityCallSenders,
      int priorityMessageSenders,
      int suppressedVisualEffects)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          priorityCategories,
          priorityCallSenders,
          priorityMessageSenders,
          suppressedVisualEffects
        ]).object);

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_suppressedEffectsToString = jniAccessors.getStaticMethodIDOf(
      _classRef, "suppressedEffectsToString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String suppressedEffectsToString(int effects)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniString suppressedEffectsToString(int effects) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_suppressedEffectsToString,
          jni.JniType.objectType,
          [effects]).object);

  static final _id_priorityCategoriesToString =
      jniAccessors.getStaticMethodIDOf(
          _classRef, "priorityCategoriesToString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String priorityCategoriesToString(int priorityCategories)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniString priorityCategoriesToString(int priorityCategories) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_priorityCategoriesToString,
          jni.JniType.objectType,
          [priorityCategories]).object);

  static final _id_prioritySendersToString = jniAccessors.getStaticMethodIDOf(
      _classRef, "prioritySendersToString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String prioritySendersToString(int prioritySenders)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniString prioritySendersToString(int prioritySenders) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_prioritySendersToString,
          jni.JniType.objectType,
          [prioritySenders]).object);
}
