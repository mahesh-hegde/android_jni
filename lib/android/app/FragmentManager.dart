// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "FragmentTransaction.dart" as fragmenttransaction_;

import "Fragment.dart" as fragment_;

import "../os/Bundle.dart" as bundle_;

import "../content/Context.dart" as context_;

import "../view/View.dart" as view_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.FragmentManager
///
/// Interface for interacting with Fragment objects inside of an
/// Activity
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
/// </div>
///
/// While the FragmentManager API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentManager for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class FragmentManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/FragmentManager");
  FragmentManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int POP_BACK_STACK_INCLUSIVE
  ///
  /// Flag for \#popBackStack(String, int)
  /// and \#popBackStack(int, int): If set, and the name or ID of
  /// a back stack entry has been supplied, then all matching entries will
  /// be consumed until one that doesn't match is found or the bottom of
  /// the stack is reached.  Otherwise, all entries up to but not including that entry
  /// will be removed.
  static const POP_BACK_STACK_INCLUSIVE = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  FragmentManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_beginTransaction = jniAccessors.getMethodIDOf(
      _classRef, "beginTransaction", "()Landroid/app/FragmentTransaction;");

  /// from: public abstract android.app.FragmentTransaction beginTransaction()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a series of edit operations on the Fragments associated with
  /// this FragmentManager.
  ///
  /// Note: A fragment transaction can only be created/committed prior
  /// to an activity saving its state.  If you try to commit a transaction
  /// after Activity\#onSaveInstanceState Activity.onSaveInstanceState()
  /// (and prior to a following Activity\#onStart Activity.onStart
  /// or Activity\#onResume Activity.onResume(), you will get an error.
  /// This is because the framework takes care of saving your current fragments
  /// in the state, and if changes are made after the state is saved then they
  /// will be lost.
  ///
  fragmenttransaction_.FragmentTransaction beginTransaction() =>
      fragmenttransaction_.FragmentTransaction.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_beginTransaction,
              jni.JniType.objectType, []).object);

  static final _id_executePendingTransactions = jniAccessors.getMethodIDOf(
      _classRef, "executePendingTransactions", "()Z");

  /// from: public abstract boolean executePendingTransactions()
  ///
  /// After a FragmentTransaction is committed with
  /// FragmentTransaction\#commit FragmentTransaction.commit(), it
  /// is scheduled to be executed asynchronously on the process's main thread.
  /// If you want to immediately executing any such pending operations, you
  /// can call this function (only from the main thread) to do so.  Note that
  /// all callbacks and other related behavior will be done from within this
  /// call, so be careful about where this is called from.
  ///
  /// This also forces the start of any postponed Transactions where
  /// Fragment\#postponeEnterTransition() has been called.
  ///@return Returns true if there were any pending transactions to be
  /// executed.
  bool executePendingTransactions() => jniAccessors.callMethodWithArgs(
      reference,
      _id_executePendingTransactions,
      jni.JniType.booleanType, []).boolean;

  static final _id_findFragmentById = jniAccessors.getMethodIDOf(
      _classRef, "findFragmentById", "(I)Landroid/app/Fragment;");

  /// from: public abstract android.app.Fragment findFragmentById(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds a fragment that was identified by the given id either when inflated
  /// from XML or as the container ID when added in a transaction.  This first
  /// searches through fragments that are currently added to the manager's
  /// activity; if no such fragment is found, then all fragments currently
  /// on the back stack associated with this ID are searched.
  ///@return The fragment if found or null otherwise.
  fragment_.Fragment findFragmentById(int id) =>
      fragment_.Fragment.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_findFragmentById, jni.JniType.objectType, [id]).object);

  static final _id_findFragmentByTag = jniAccessors.getMethodIDOf(_classRef,
      "findFragmentByTag", "(Ljava/lang/String;)Landroid/app/Fragment;");

  /// from: public abstract android.app.Fragment findFragmentByTag(java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds a fragment that was identified by the given tag either when inflated
  /// from XML or as supplied when added in a transaction.  This first
  /// searches through fragments that are currently added to the manager's
  /// activity; if no such fragment is found, then all fragments currently
  /// on the back stack are searched.
  ///@return The fragment if found or null otherwise.
  fragment_.Fragment findFragmentByTag(jni.JniString tag) =>
      fragment_.Fragment.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findFragmentByTag,
          jni.JniType.objectType,
          [tag.reference]).object);

  static final _id_popBackStack =
      jniAccessors.getMethodIDOf(_classRef, "popBackStack", "()V");

  /// from: public abstract void popBackStack()
  ///
  /// Pop the top state off the back stack.  This function is asynchronous -- it
  /// enqueues the request to pop, but the action will not be performed until the
  /// application returns to its event loop.
  void popBackStack() => jniAccessors.callMethodWithArgs(
      reference, _id_popBackStack, jni.JniType.voidType, []).check();

  static final _id_popBackStackImmediate =
      jniAccessors.getMethodIDOf(_classRef, "popBackStackImmediate", "()Z");

  /// from: public abstract boolean popBackStackImmediate()
  ///
  /// Like \#popBackStack(), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate() => jniAccessors.callMethodWithArgs(reference,
      _id_popBackStackImmediate, jni.JniType.booleanType, []).boolean;

  static final _id_popBackStack1 = jniAccessors.getMethodIDOf(
      _classRef, "popBackStack", "(Ljava/lang/String;I)V");

  /// from: public abstract void popBackStack(java.lang.String name, int flags)
  ///
  /// Pop the last fragment transition from the manager's fragment
  /// back stack.  If there is nothing to pop, false is returned.
  /// This function is asynchronous -- it enqueues the
  /// request to pop, but the action will not be performed until the application
  /// returns to its event loop.
  ///@param name If non-null, this is the name of a previous back state
  /// to look for; if found, all states up to that state will be popped.  The
  /// \#POP_BACK_STACK_INCLUSIVE flag can be used to control whether
  /// the named state itself is popped. If null, only the top state is popped.
  ///@param flags Either 0 or \#POP_BACK_STACK_INCLUSIVE.
  void popBackStack1(jni.JniString name, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_popBackStack1,
          jni.JniType.voidType, [name.reference, flags]).check();

  static final _id_popBackStackImmediate1 = jniAccessors.getMethodIDOf(
      _classRef, "popBackStackImmediate", "(Ljava/lang/String;I)Z");

  /// from: public abstract boolean popBackStackImmediate(java.lang.String name, int flags)
  ///
  /// Like \#popBackStack(String, int), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate1(jni.JniString name, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_popBackStackImmediate1,
          jni.JniType.booleanType, [name.reference, flags]).boolean;

  static final _id_popBackStack2 =
      jniAccessors.getMethodIDOf(_classRef, "popBackStack", "(II)V");

  /// from: public abstract void popBackStack(int id, int flags)
  ///
  /// Pop all back stack states up to the one with the given identifier.
  /// This function is asynchronous -- it enqueues the
  /// request to pop, but the action will not be performed until the application
  /// returns to its event loop.
  ///@param id Identifier of the stated to be popped. If no identifier exists,
  /// false is returned.
  /// The identifier is the number returned by
  /// FragmentTransaction\#commit() FragmentTransaction.commit().  The
  /// \#POP_BACK_STACK_INCLUSIVE flag can be used to control whether
  /// the named state itself is popped.
  ///@param flags Either 0 or \#POP_BACK_STACK_INCLUSIVE.
  void popBackStack2(int id, int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_popBackStack2, jni.JniType.voidType, [id, flags]).check();

  static final _id_popBackStackImmediate2 =
      jniAccessors.getMethodIDOf(_classRef, "popBackStackImmediate", "(II)Z");

  /// from: public abstract boolean popBackStackImmediate(int id, int flags)
  ///
  /// Like \#popBackStack(int, int), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate2(int id, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_popBackStackImmediate2,
          jni.JniType.booleanType, [id, flags]).boolean;

  static final _id_getBackStackEntryCount =
      jniAccessors.getMethodIDOf(_classRef, "getBackStackEntryCount", "()I");

  /// from: public abstract int getBackStackEntryCount()
  ///
  /// Return the number of entries currently in the back stack.
  int getBackStackEntryCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getBackStackEntryCount, jni.JniType.intType, []).integer;

  static final _id_getBackStackEntryAt = jniAccessors.getMethodIDOf(
      _classRef,
      "getBackStackEntryAt",
      "(I)Landroid/app/FragmentManager\$BackStackEntry;");

  /// from: public abstract android.app.FragmentManager.BackStackEntry getBackStackEntryAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the BackStackEntry at index <var>index</var> in the back stack;
  /// where the item on the bottom of the stack has index 0.
  FragmentManager_BackStackEntry getBackStackEntryAt(int index) =>
      FragmentManager_BackStackEntry.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBackStackEntryAt,
          jni.JniType.objectType,
          [index]).object);

  static final _id_addOnBackStackChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnBackStackChangedListener",
      "(Landroid/app/FragmentManager\$OnBackStackChangedListener;)V");

  /// from: public abstract void addOnBackStackChangedListener(android.app.FragmentManager.OnBackStackChangedListener listener)
  ///
  /// Add a new listener for changes to the fragment back stack.
  void addOnBackStackChangedListener(
          FragmentManager_OnBackStackChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnBackStackChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_removeOnBackStackChangedListener =
      jniAccessors.getMethodIDOf(_classRef, "removeOnBackStackChangedListener",
          "(Landroid/app/FragmentManager\$OnBackStackChangedListener;)V");

  /// from: public abstract void removeOnBackStackChangedListener(android.app.FragmentManager.OnBackStackChangedListener listener)
  ///
  /// Remove a listener that was previously added with
  /// \#addOnBackStackChangedListener(OnBackStackChangedListener).
  void removeOnBackStackChangedListener(
          FragmentManager_OnBackStackChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnBackStackChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_putFragment = jniAccessors.getMethodIDOf(
      _classRef,
      "putFragment",
      "(Landroid/os/Bundle;Ljava/lang/String;Landroid/app/Fragment;)V");

  /// from: public abstract void putFragment(android.os.Bundle bundle, java.lang.String key, android.app.Fragment fragment)
  ///
  /// Put a reference to a fragment in a Bundle.  This Bundle can be
  /// persisted as saved state, and when later restoring
  /// \#getFragment(Bundle, String) will return the current
  /// instance of the same fragment.
  ///@param bundle The bundle in which to put the fragment reference.
  ///@param key The name of the entry in the bundle.
  ///@param fragment The Fragment whose reference is to be stored.
  void putFragment(bundle_.Bundle bundle, jni.JniString key,
          fragment_.Fragment fragment) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_putFragment,
          jni.JniType.voidType,
          [bundle.reference, key.reference, fragment.reference]).check();

  static final _id_getFragment = jniAccessors.getMethodIDOf(
      _classRef,
      "getFragment",
      "(Landroid/os/Bundle;Ljava/lang/String;)Landroid/app/Fragment;");

  /// from: public abstract android.app.Fragment getFragment(android.os.Bundle bundle, java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current Fragment instance for a reference previously
  /// placed with \#putFragment(Bundle, String, Fragment).
  ///@param bundle The bundle from which to retrieve the fragment reference.
  ///@param key The name of the entry in the bundle.
  ///@return Returns the current Fragment instance that is associated with
  /// the given reference.
  fragment_.Fragment getFragment(bundle_.Bundle bundle, jni.JniString key) =>
      fragment_.Fragment.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFragment,
          jni.JniType.objectType,
          [bundle.reference, key.reference]).object);

  static final _id_getFragments = jniAccessors.getMethodIDOf(
      _classRef, "getFragments", "()Ljava/util/List;");

  /// from: public abstract java.util.List<android.app.Fragment> getFragments()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of all fragments that are currently added to the FragmentManager.
  /// This may include those that are hidden as well as those that are shown.
  /// This will not include any fragments only in the back stack, or fragments that
  /// are detached or removed.
  ///
  /// The order of the fragments in the list is the order in which they were
  /// added or attached.
  ///@return A list of all fragments that are added to the FragmentManager.
  jni.JniObject getFragments() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFragments, jni.JniType.objectType, []).object);

  static final _id_saveFragmentInstanceState = jniAccessors.getMethodIDOf(
      _classRef,
      "saveFragmentInstanceState",
      "(Landroid/app/Fragment;)Landroid/app/Fragment\$SavedState;");

  /// from: public abstract android.app.Fragment.SavedState saveFragmentInstanceState(android.app.Fragment f)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Save the current instance state of the given Fragment.  This can be
  /// used later when creating a new instance of the Fragment and adding
  /// it to the fragment manager, to have it create itself to match the
  /// current state returned here.  Note that there are limits on how
  /// this can be used:
  ///
  /// <ul>
  /// <li>The Fragment must currently be attached to the FragmentManager.
  /// <li>A new Fragment created using this saved state must be the same class
  /// type as the Fragment it was created from.
  /// <li>The saved state can not contain dependencies on other fragments --
  /// that is it can't use \#putFragment(Bundle, String, Fragment) to
  /// store a fragment reference because that reference may not be valid when
  /// this saved state is later used.  Likewise the Fragment's target and
  /// result code are not included in this state.
  /// </ul>
  ///@param f The Fragment whose state is to be saved.
  ///@return The generated state.  This will be null if there was no
  /// interesting state created by the fragment.
  fragment_.Fragment_SavedState saveFragmentInstanceState(
          fragment_.Fragment f) =>
      fragment_.Fragment_SavedState.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_saveFragmentInstanceState,
          jni.JniType.objectType,
          [f.reference]).object);

  static final _id_isDestroyed =
      jniAccessors.getMethodIDOf(_classRef, "isDestroyed", "()Z");

  /// from: public abstract boolean isDestroyed()
  ///
  /// Returns true if the final Activity\#onDestroy() Activity.onDestroy()
  /// call has been made on the FragmentManager's Activity, so this instance is now dead.
  bool isDestroyed() => jniAccessors.callMethodWithArgs(
      reference, _id_isDestroyed, jni.JniType.booleanType, []).boolean;

  static final _id_registerFragmentLifecycleCallbacks =
      jniAccessors.getMethodIDOf(
          _classRef,
          "registerFragmentLifecycleCallbacks",
          "(Landroid/app/FragmentManager\$FragmentLifecycleCallbacks;Z)V");

  /// from: public abstract void registerFragmentLifecycleCallbacks(android.app.FragmentManager.FragmentLifecycleCallbacks cb, boolean recursive)
  ///
  /// Registers a FragmentLifecycleCallbacks to listen to fragment lifecycle events
  /// happening in this FragmentManager. All registered callbacks will be automatically
  /// unregistered when this FragmentManager is destroyed.
  ///@param cb Callbacks to register
  ///@param recursive true to automatically register this callback for all child FragmentManagers
  void registerFragmentLifecycleCallbacks(
          FragmentManager_FragmentLifecycleCallbacks cb, bool recursive) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerFragmentLifecycleCallbacks,
          jni.JniType.voidType,
          [cb.reference, recursive]).check();

  static final _id_unregisterFragmentLifecycleCallbacks =
      jniAccessors.getMethodIDOf(
          _classRef,
          "unregisterFragmentLifecycleCallbacks",
          "(Landroid/app/FragmentManager\$FragmentLifecycleCallbacks;)V");

  /// from: public abstract void unregisterFragmentLifecycleCallbacks(android.app.FragmentManager.FragmentLifecycleCallbacks cb)
  ///
  /// Unregisters a previously registered FragmentLifecycleCallbacks. If the callback
  /// was not previously registered this call has no effect. All registered callbacks will be
  /// automatically unregistered when this FragmentManager is destroyed.
  ///@param cb Callbacks to unregister
  void unregisterFragmentLifecycleCallbacks(
          FragmentManager_FragmentLifecycleCallbacks cb) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterFragmentLifecycleCallbacks,
          jni.JniType.voidType,
          [cb.reference]).check();

  static final _id_getPrimaryNavigationFragment = jniAccessors.getMethodIDOf(
      _classRef, "getPrimaryNavigationFragment", "()Landroid/app/Fragment;");

  /// from: public abstract android.app.Fragment getPrimaryNavigationFragment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the currently active primary navigation fragment for this FragmentManager.
  ///
  /// The primary navigation fragment's
  /// Fragment\#getChildFragmentManager() child FragmentManager will be called first
  /// to process delegated navigation actions such as \#popBackStack() if no ID
  /// or transaction name is provided to pop to.
  ///
  ///@return the fragment designated as the primary navigation fragment
  fragment_.Fragment getPrimaryNavigationFragment() =>
      fragment_.Fragment.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPrimaryNavigationFragment, jni.JniType.objectType, []).object);

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public abstract void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the FragmentManager's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer A PrintWriter to which the dump is to be set.
  ///@param args Additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();

  static final _id_enableDebugLogging =
      jniAccessors.getStaticMethodIDOf(_classRef, "enableDebugLogging", "(Z)V");

  /// from: static public void enableDebugLogging(boolean enabled)
  ///
  /// Control whether the framework's internal fragment manager debugging
  /// logs are turned on.  If enabled, you will see output in logcat as
  /// the framework performs fragment operations.
  static void enableDebugLogging(bool enabled) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_enableDebugLogging,
          jni.JniType.voidType, [enabled]).check();

  static final _id_invalidateOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "invalidateOptionsMenu", "()V");

  /// from: public void invalidateOptionsMenu()
  ///
  /// Invalidate the attached activity's options menu as necessary.
  /// This may end up being deferred until we move to the resumed state.
  void invalidateOptionsMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidateOptionsMenu, jni.JniType.voidType, []).check();

  static final _id_isStateSaved =
      jniAccessors.getMethodIDOf(_classRef, "isStateSaved", "()Z");

  /// from: public abstract boolean isStateSaved()
  ///
  /// Returns {@code true} if the FragmentManager's state has already been saved
  /// by its host. Any operations that would change saved state should not be performed
  /// if this method returns true. For example, any popBackStack() method, such as
  /// \#popBackStackImmediate() or any FragmentTransaction using
  /// FragmentTransaction\#commit() instead of
  /// FragmentTransaction\#commitAllowingStateLoss() will change
  /// the state and will result in an error.
  ///@return true if this FragmentManager's state has already been saved by its host
  bool isStateSaved() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateSaved, jni.JniType.booleanType, []).boolean;
}

/// from: android.app.FragmentManager$OnBackStackChangedListener
///
/// Interface to watch for changes to the back stack.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a>
///      android.support.v4.app.FragmentManager.OnBackStackChangedListener
class FragmentManager_OnBackStackChangedListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/FragmentManager\$OnBackStackChangedListener");
  FragmentManager_OnBackStackChangedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onBackStackChanged =
      jniAccessors.getMethodIDOf(_classRef, "onBackStackChanged", "()V");

  /// from: public abstract void onBackStackChanged()
  ///
  /// Called whenever the contents of the back stack change.
  void onBackStackChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_onBackStackChanged, jni.JniType.voidType, []).check();
}

/// from: android.app.FragmentManager$FragmentLifecycleCallbacks
///
/// Callback interface for listening to fragment state changes that happen
/// within a given FragmentManager.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a>
///      android.support.v4.app.FragmentManager.FragmentLifecycleCallbacks
class FragmentManager_FragmentLifecycleCallbacks extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/FragmentManager\$FragmentLifecycleCallbacks");
  FragmentManager_FragmentLifecycleCallbacks.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  FragmentManager_FragmentLifecycleCallbacks()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onFragmentPreAttached = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentPreAttached",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;Landroid/content/Context;)V");

  /// from: public void onFragmentPreAttached(android.app.FragmentManager fm, android.app.Fragment f, android.content.Context context)
  ///
  /// Called right before the fragment's Fragment\#onAttach(Context) method is called.
  /// This is a good time to inject any required dependencies for the fragment before any of
  /// the fragment's lifecycle methods are invoked.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param context Context that the Fragment is being attached to
  void onFragmentPreAttached(
          FragmentManager fm, fragment_.Fragment f, context_.Context context) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFragmentPreAttached,
          jni.JniType.voidType,
          [fm.reference, f.reference, context.reference]).check();

  static final _id_onFragmentAttached = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentAttached",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;Landroid/content/Context;)V");

  /// from: public void onFragmentAttached(android.app.FragmentManager fm, android.app.Fragment f, android.content.Context context)
  ///
  /// Called after the fragment has been attached to its host. Its host will have had
  /// <code>onAttachFragment</code> called before this call happens.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param context Context that the Fragment was attached to
  void onFragmentAttached(
          FragmentManager fm, fragment_.Fragment f, context_.Context context) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFragmentAttached,
          jni.JniType.voidType,
          [fm.reference, f.reference, context.reference]).check();

  static final _id_onFragmentPreCreated = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentPreCreated",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;Landroid/os/Bundle;)V");

  /// from: public void onFragmentPreCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  ///
  /// Called right before the fragment's Fragment\#onCreate(Bundle) method is called.
  /// This is a good time to inject any required dependencies or perform other configuration
  /// for the fragment.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentPreCreated(FragmentManager fm, fragment_.Fragment f,
          bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFragmentPreCreated,
          jni.JniType.voidType,
          [fm.reference, f.reference, savedInstanceState.reference]).check();

  static final _id_onFragmentCreated = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentCreated",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;Landroid/os/Bundle;)V");

  /// from: public void onFragmentCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onCreate(Bundle). This will only happen once for any given
  /// fragment instance, though the fragment may be attached and detached multiple times.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentCreated(FragmentManager fm, fragment_.Fragment f,
          bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFragmentCreated,
          jni.JniType.voidType,
          [fm.reference, f.reference, savedInstanceState.reference]).check();

  static final _id_onFragmentActivityCreated = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentActivityCreated",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;Landroid/os/Bundle;)V");

  /// from: public void onFragmentActivityCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onActivityCreated(Bundle). This will only happen once for any given
  /// fragment instance, though the fragment may be attached and detached multiple times.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentActivityCreated(FragmentManager fm, fragment_.Fragment f,
          bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFragmentActivityCreated,
          jni.JniType.voidType,
          [fm.reference, f.reference, savedInstanceState.reference]).check();

  static final _id_onFragmentViewCreated = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentViewCreated",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;Landroid/view/View;Landroid/os/Bundle;)V");

  /// from: public void onFragmentViewCreated(android.app.FragmentManager fm, android.app.Fragment f, android.view.View v, android.os.Bundle savedInstanceState)
  ///
  /// Called after the fragment has returned a non-null view from the FragmentManager's
  /// request to Fragment\#onCreateView(LayoutInflater, ViewGroup, Bundle).
  ///@param fm Host FragmentManager
  ///@param f Fragment that created and owns the view
  ///@param v View returned by the fragment
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentViewCreated(FragmentManager fm, fragment_.Fragment f,
          view_.View v, bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onFragmentViewCreated, jni.JniType.voidType, [
        fm.reference,
        f.reference,
        v.reference,
        savedInstanceState.reference
      ]).check();

  static final _id_onFragmentStarted = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentStarted",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;)V");

  /// from: public void onFragmentStarted(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onStart().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentStarted(FragmentManager fm, fragment_.Fragment f) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFragmentStarted,
          jni.JniType.voidType, [fm.reference, f.reference]).check();

  static final _id_onFragmentResumed = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentResumed",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;)V");

  /// from: public void onFragmentResumed(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onResume().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentResumed(FragmentManager fm, fragment_.Fragment f) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFragmentResumed,
          jni.JniType.voidType, [fm.reference, f.reference]).check();

  static final _id_onFragmentPaused = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentPaused",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;)V");

  /// from: public void onFragmentPaused(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onPause().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentPaused(FragmentManager fm, fragment_.Fragment f) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFragmentPaused,
          jni.JniType.voidType, [fm.reference, f.reference]).check();

  static final _id_onFragmentStopped = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentStopped",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;)V");

  /// from: public void onFragmentStopped(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onStop().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentStopped(FragmentManager fm, fragment_.Fragment f) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFragmentStopped,
          jni.JniType.voidType, [fm.reference, f.reference]).check();

  static final _id_onFragmentSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentSaveInstanceState",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;Landroid/os/Bundle;)V");

  /// from: public void onFragmentSaveInstanceState(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle outState)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onSaveInstanceState(Bundle).
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param outState Saved state bundle for the fragment
  void onFragmentSaveInstanceState(
          FragmentManager fm, fragment_.Fragment f, bundle_.Bundle outState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFragmentSaveInstanceState,
          jni.JniType.voidType,
          [fm.reference, f.reference, outState.reference]).check();

  static final _id_onFragmentViewDestroyed = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentViewDestroyed",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;)V");

  /// from: public void onFragmentViewDestroyed(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDestroyView().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentViewDestroyed(FragmentManager fm, fragment_.Fragment f) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFragmentViewDestroyed,
          jni.JniType.voidType, [fm.reference, f.reference]).check();

  static final _id_onFragmentDestroyed = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentDestroyed",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;)V");

  /// from: public void onFragmentDestroyed(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDestroy().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentDestroyed(FragmentManager fm, fragment_.Fragment f) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFragmentDestroyed,
          jni.JniType.voidType, [fm.reference, f.reference]).check();

  static final _id_onFragmentDetached = jniAccessors.getMethodIDOf(
      _classRef,
      "onFragmentDetached",
      "(Landroid/app/FragmentManager;Landroid/app/Fragment;)V");

  /// from: public void onFragmentDetached(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDetach().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentDetached(FragmentManager fm, fragment_.Fragment f) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFragmentDetached,
          jni.JniType.voidType, [fm.reference, f.reference]).check();
}

/// from: android.app.FragmentManager$BackStackEntry
///
/// Representation of an entry on the fragment back stack, as created
/// with FragmentTransaction\#addToBackStack(String) FragmentTransaction.addToBackStack().  Entries can later be
/// retrieved with FragmentManager\#getBackStackEntryAt(int) FragmentManager.getBackStackEntryAt().
///
/// Note that you should never hold on to a BackStackEntry object;
/// the identifier as returned by \#getId is the only thing that
/// will be persisted across activity instances.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a> android.support.v4.app.FragmentManager.BackStackEntry
class FragmentManager_BackStackEntry extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/FragmentManager\$BackStackEntry");
  FragmentManager_BackStackEntry.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public abstract int getId()
  ///
  /// Return the unique identifier for the entry.  This is the only
  /// representation of the entry that will persist across activity
  /// instances.
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the name that was supplied to
  /// FragmentTransaction\#addToBackStack(String) FragmentTransaction.addToBackStack(String) when creating this entry.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_getBreadCrumbTitleRes =
      jniAccessors.getMethodIDOf(_classRef, "getBreadCrumbTitleRes", "()I");

  /// from: public abstract int getBreadCrumbTitleRes()
  ///
  /// Return the full bread crumb title resource identifier for the entry,
  /// or 0 if it does not have one.
  int getBreadCrumbTitleRes() => jniAccessors.callMethodWithArgs(
      reference, _id_getBreadCrumbTitleRes, jni.JniType.intType, []).integer;

  static final _id_getBreadCrumbShortTitleRes = jniAccessors.getMethodIDOf(
      _classRef, "getBreadCrumbShortTitleRes", "()I");

  /// from: public abstract int getBreadCrumbShortTitleRes()
  ///
  /// Return the short bread crumb title resource identifier for the entry,
  /// or 0 if it does not have one.
  int getBreadCrumbShortTitleRes() => jniAccessors.callMethodWithArgs(reference,
      _id_getBreadCrumbShortTitleRes, jni.JniType.intType, []).integer;

  static final _id_getBreadCrumbTitle = jniAccessors.getMethodIDOf(
      _classRef, "getBreadCrumbTitle", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getBreadCrumbTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full bread crumb title for the entry, or null if it
  /// does not have one.
  jni.JniObject getBreadCrumbTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBreadCrumbTitle, jni.JniType.objectType, []).object);

  static final _id_getBreadCrumbShortTitle = jniAccessors.getMethodIDOf(
      _classRef, "getBreadCrumbShortTitle", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getBreadCrumbShortTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the short bread crumb title for the entry, or null if it
  /// does not have one.
  jni.JniObject getBreadCrumbShortTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBreadCrumbShortTitle, jni.JniType.objectType, []).object);
}
