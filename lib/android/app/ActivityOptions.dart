// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../view/View.dart" as view_;

import "../graphics/Bitmap.dart" as bitmap_;

import "Activity.dart" as activity_;

import "../graphics/Rect.dart" as rect_;

import "../os/Bundle.dart" as bundle_;

import "PendingIntent.dart" as pendingintent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.ActivityOptions
///
/// Helper class for building an options Bundle that can be used with
/// android.content.Context\#startActivity(android.content.Intent, android.os.Bundle) Context.startActivity(Intent, Bundle) and related methods.
class ActivityOptions extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActivityOptions");
  ActivityOptions.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String EXTRA_USAGE_TIME_REPORT
  ///
  /// A long in the extras delivered by \#requestUsageTimeReport that contains
  /// the total time (in ms) the user spent in the app flow.
  static const EXTRA_USAGE_TIME_REPORT = "android.activity.usage_time";

  /// from: static public final java.lang.String EXTRA_USAGE_TIME_REPORT_PACKAGES
  ///
  /// A Bundle in the extras delivered by \#requestUsageTimeReport that contains
  /// detailed information about the time spent in each package associated with the app;
  /// each key is a package name, whose value is a long containing the time (in ms).
  static const EXTRA_USAGE_TIME_REPORT_PACKAGES = "android.usage_time_packages";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityOptions()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_makeCustomAnimation = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeCustomAnimation",
      "(Landroid/content/Context;II)Landroid/app/ActivityOptions;");

  /// from: static public android.app.ActivityOptions makeCustomAnimation(android.content.Context context, int enterResId, int exitResId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions specifying a custom animation to run when
  /// the activity is displayed.
  ///@param context Who is defining this.  This is the application that the
  /// animation resources will be loaded from.
  ///@param enterResId A resource ID of the animation resource to use for
  /// the incoming activity.  Use 0 for no animation.
  ///@param exitResId A resource ID of the animation resource to use for
  /// the outgoing activity.  Use 0 for no animation.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeCustomAnimation(
          context_.Context context, int enterResId, int exitResId) =>
      ActivityOptions.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_makeCustomAnimation,
          jni.JniType.objectType,
          [context.reference, enterResId, exitResId]).object);

  static final _id_makeScaleUpAnimation = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeScaleUpAnimation",
      "(Landroid/view/View;IIII)Landroid/app/ActivityOptions;");

  /// from: static public android.app.ActivityOptions makeScaleUpAnimation(android.view.View source, int startX, int startY, int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions specifying an animation where the new
  /// activity is scaled from a small originating area of the screen to
  /// its final full representation.
  ///
  /// If the Intent this is being used with has not set its
  /// android.content.Intent\#setSourceBounds Intent.setSourceBounds,
  /// those bounds will be filled in for you based on the initial
  /// bounds passed in here.
  ///@param source The View that the new activity is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param startX The x starting location of the new activity, relative to <var>source</var>.
  ///@param startY The y starting location of the activity, relative to <var>source</var>.
  ///@param width The initial width of the new activity.
  ///@param height The initial height of the new activity.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeScaleUpAnimation(
          view_.View source, int startX, int startY, int width, int height) =>
      ActivityOptions.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_makeScaleUpAnimation,
          jni.JniType.objectType,
          [source.reference, startX, startY, width, height]).object);

  static final _id_makeClipRevealAnimation = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeClipRevealAnimation",
      "(Landroid/view/View;IIII)Landroid/app/ActivityOptions;");

  /// from: static public android.app.ActivityOptions makeClipRevealAnimation(android.view.View source, int startX, int startY, int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions specifying an animation where the new
  /// activity is revealed from a small originating area of the screen to
  /// its final full representation.
  ///@param source The View that the new activity is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param startX The x starting location of the new activity, relative to <var>source</var>.
  ///@param startY The y starting location of the activity, relative to <var>source</var>.
  ///@param width The initial width of the new activity.
  ///@param height The initial height of the new activity.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeClipRevealAnimation(
          view_.View source, int startX, int startY, int width, int height) =>
      ActivityOptions.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_makeClipRevealAnimation,
          jni.JniType.objectType,
          [source.reference, startX, startY, width, height]).object);

  static final _id_makeThumbnailScaleUpAnimation = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeThumbnailScaleUpAnimation",
      "(Landroid/view/View;Landroid/graphics/Bitmap;II)Landroid/app/ActivityOptions;");

  /// from: static public android.app.ActivityOptions makeThumbnailScaleUpAnimation(android.view.View source, android.graphics.Bitmap thumbnail, int startX, int startY)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions specifying an animation where a thumbnail
  /// is scaled from a given position to the new activity window that is
  /// being started.
  ///
  /// If the Intent this is being used with has not set its
  /// android.content.Intent\#setSourceBounds Intent.setSourceBounds,
  /// those bounds will be filled in for you based on the initial
  /// thumbnail location and size provided here.
  ///@param source The View that this thumbnail is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param thumbnail The bitmap that will be shown as the initial thumbnail
  /// of the animation.
  ///@param startX The x starting location of the bitmap, relative to <var>source</var>.
  ///@param startY The y starting location of the bitmap, relative to <var>source</var>.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeThumbnailScaleUpAnimation(view_.View source,
          bitmap_.Bitmap thumbnail, int startX, int startY) =>
      ActivityOptions.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_makeThumbnailScaleUpAnimation,
          jni.JniType.objectType,
          [source.reference, thumbnail.reference, startX, startY]).object);

  static final _id_makeSceneTransitionAnimation = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeSceneTransitionAnimation",
      "(Landroid/app/Activity;Landroid/view/View;Ljava/lang/String;)Landroid/app/ActivityOptions;");

  /// from: static public android.app.ActivityOptions makeSceneTransitionAnimation(android.app.Activity activity, android.view.View sharedElement, java.lang.String sharedElementName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions to transition between Activities using cross-Activity scene
  /// animations. This method carries the position of one shared element to the started Activity.
  /// The position of <code>sharedElement</code> will be used as the epicenter for the
  /// exit Transition. The position of the shared element in the launched Activity will be the
  /// epicenter of its entering Transition.
  ///
  /// This requires android.view.Window\#FEATURE_ACTIVITY_TRANSITIONS to be
  /// enabled on the calling Activity to cause an exit transition. The same must be in
  /// the called Activity to get an entering transition.
  ///
  ///@param activity The Activity whose window contains the shared elements.
  ///@param sharedElement The View to transition to the started Activity.
  ///@param sharedElementName The shared element name as used in the target Activity. This
  ///                          must not be null.
  ///@return Returns a new ActivityOptions object that you can use to
  ///         supply these options as the options Bundle when starting an activity.
  ///@see android.transition.Transition\#setEpicenterCallback(
  ///          android.transition.Transition.EpicenterCallback)
  static ActivityOptions makeSceneTransitionAnimation(
          activity_.Activity activity,
          view_.View sharedElement,
          jni.JniString sharedElementName) =>
      ActivityOptions.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_makeSceneTransitionAnimation, jni.JniType.objectType, [
        activity.reference,
        sharedElement.reference,
        sharedElementName.reference
      ]).object);

  static final _id_makeSceneTransitionAnimation1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeSceneTransitionAnimation",
      "(Landroid/app/Activity;[Landroid/util/Pair;)Landroid/app/ActivityOptions;");

  /// from: static public android.app.ActivityOptions makeSceneTransitionAnimation(android.app.Activity activity, android.util.Pair<android.view.View,java.lang.String>[] sharedElements)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions to transition between Activities using cross-Activity scene
  /// animations. This method carries the position of multiple shared elements to the started
  /// Activity. The position of the first element in sharedElements
  /// will be used as the epicenter for the exit Transition. The position of the associated
  /// shared element in the launched Activity will be the epicenter of its entering Transition.
  ///
  /// This requires android.view.Window\#FEATURE_ACTIVITY_TRANSITIONS to be
  /// enabled on the calling Activity to cause an exit transition. The same must be in
  /// the called Activity to get an entering transition.
  ///
  ///@param activity The Activity whose window contains the shared elements.
  ///@param sharedElements The names of the shared elements to transfer to the called
  ///                       Activity and their associated Views. The Views must each have
  ///                       a unique shared element name.
  ///@return Returns a new ActivityOptions object that you can use to
  ///         supply these options as the options Bundle when starting an activity.
  ///@see android.transition.Transition\#setEpicenterCallback(
  ///          android.transition.Transition.EpicenterCallback)
  static ActivityOptions makeSceneTransitionAnimation1(
          activity_.Activity activity, jni.JniObject sharedElements) =>
      ActivityOptions.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_makeSceneTransitionAnimation1,
          jni.JniType.objectType,
          [activity.reference, sharedElements.reference]).object);

  static final _id_makeTaskLaunchBehind = jniAccessors.getStaticMethodIDOf(
      _classRef, "makeTaskLaunchBehind", "()Landroid/app/ActivityOptions;");

  /// from: static public android.app.ActivityOptions makeTaskLaunchBehind()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If set along with Intent.FLAG_ACTIVITY_NEW_DOCUMENT then the task being launched will not be
  /// presented to the user but will instead be only available through the recents task list.
  /// In addition, the new task wil be affiliated with the launching activity's task.
  /// Affiliated tasks are grouped together in the recents task list.
  ///
  /// This behavior is not supported for activities with android.R.styleable\#AndroidManifestActivity_launchMode launchMode values of
  /// <code>singleInstance</code> or <code>singleTask</code>.
  static ActivityOptions makeTaskLaunchBehind() =>
      ActivityOptions.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_makeTaskLaunchBehind, jni.JniType.objectType, []).object);

  static final _id_makeBasic = jniAccessors.getStaticMethodIDOf(
      _classRef, "makeBasic", "()Landroid/app/ActivityOptions;");

  /// from: static public android.app.ActivityOptions makeBasic()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a basic ActivityOptions that has no special animation associated with it.
  /// Other options can still be set.
  static ActivityOptions makeBasic() =>
      ActivityOptions.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_makeBasic, jni.JniType.objectType, []).object);

  static final _id_setLaunchBounds = jniAccessors.getMethodIDOf(
      _classRef,
      "setLaunchBounds",
      "(Landroid/graphics/Rect;)Landroid/app/ActivityOptions;");

  /// from: public android.app.ActivityOptions setLaunchBounds(android.graphics.Rect screenSpacePixelRect)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the bounds (window size) that the activity should be launched in.
  /// Rect position should be provided in pixels and in screen coordinates.
  /// Set to null explicitly for fullscreen.
  ///
  /// <strong>NOTE:<strong/> This value is ignored on devices that don't have
  /// android.content.pm.PackageManager\#FEATURE_FREEFORM_WINDOW_MANAGEMENT or
  /// android.content.pm.PackageManager\#FEATURE_PICTURE_IN_PICTURE enabled.
  ///@param screenSpacePixelRect Launch bounds to use for the activity or null for fullscreen.
  ///
  /// This value may be {@code null}.
  ActivityOptions setLaunchBounds(rect_.Rect screenSpacePixelRect) =>
      ActivityOptions.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setLaunchBounds,
          jni.JniType.objectType,
          [screenSpacePixelRect.reference]).object);

  static final _id_getLaunchBounds = jniAccessors.getMethodIDOf(
      _classRef, "getLaunchBounds", "()Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect getLaunchBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the bounds that should be used to launch the activity.
  ///@see \#setLaunchBounds(Rect)
  ///@return Bounds used to launch the activity.
  ///
  /// This value may be {@code null}.
  rect_.Rect getLaunchBounds() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLaunchBounds, jni.JniType.objectType, []).object);

  static final _id_getLockTaskMode =
      jniAccessors.getMethodIDOf(_classRef, "getLockTaskMode", "()Z");

  /// from: public boolean getLockTaskMode()
  ///
  /// Gets whether the activity is to be launched into LockTask mode.
  ///@return {@code true} if the activity is to be launched into LockTask mode.
  ///@see Activity\#startLockTask()
  ///@see android.app.admin.DevicePolicyManager\#setLockTaskPackages(ComponentName, String[])
  bool getLockTaskMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getLockTaskMode, jni.JniType.booleanType, []).boolean;

  static final _id_setLockTaskEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setLockTaskEnabled", "(Z)Landroid/app/ActivityOptions;");

  /// from: public android.app.ActivityOptions setLockTaskEnabled(boolean lockTaskMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether the activity is to be launched into LockTask mode.
  ///
  /// Use this option to start an activity in LockTask mode. Note that only apps permitted by
  /// android.app.admin.DevicePolicyManager can run in LockTask mode. Therefore, if
  /// android.app.admin.DevicePolicyManager\#isLockTaskPermitted(String) returns
  /// {@code false} for the package of the target activity, a SecurityException will be
  /// thrown during Context\#startActivity(Intent, Bundle). This method doesn't affect
  /// activities that are already running \u2014 relaunch the activity to run in lock task mode.
  ///
  /// Defaults to {@code false} if not set.
  ///@param lockTaskMode {@code true} if the activity is to be launched into LockTask mode.
  ///@return {@code this} ActivityOptions instance.
  ///@see Activity\#startLockTask()
  ///@see android.app.admin.DevicePolicyManager\#setLockTaskPackages(ComponentName, String[])
  ActivityOptions setLockTaskEnabled(bool lockTaskMode) =>
      ActivityOptions.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setLockTaskEnabled,
          jni.JniType.objectType,
          [lockTaskMode]).object);

  static final _id_getLaunchDisplayId =
      jniAccessors.getMethodIDOf(_classRef, "getLaunchDisplayId", "()I");

  /// from: public int getLaunchDisplayId()
  ///
  /// Gets the id of the display where activity should be launched.
  ///@return The id of the display where activity should be launched,
  ///         android.view.Display\#INVALID_DISPLAY if not set.
  ///@see \#setLaunchDisplayId(int)
  int getLaunchDisplayId() => jniAccessors.callMethodWithArgs(
      reference, _id_getLaunchDisplayId, jni.JniType.intType, []).integer;

  static final _id_setLaunchDisplayId = jniAccessors.getMethodIDOf(
      _classRef, "setLaunchDisplayId", "(I)Landroid/app/ActivityOptions;");

  /// from: public android.app.ActivityOptions setLaunchDisplayId(int launchDisplayId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the id of the display where activity should be launched.
  /// An app can launch activities on public displays or private displays that are owned by the app
  /// or where an app already has activities. Otherwise, trying to launch on a private display
  /// or providing an invalid display id will result in an exception.
  ///
  /// Setting launch display id will be ignored on devices that don't have
  /// android.content.pm.PackageManager\#FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS.
  ///@param launchDisplayId The id of the display where the activity should be launched.
  ///@return {@code this} ActivityOptions instance.
  ActivityOptions setLaunchDisplayId(int launchDisplayId) =>
      ActivityOptions.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setLaunchDisplayId,
          jni.JniType.objectType,
          [launchDisplayId]).object);

  static final _id_update = jniAccessors.getMethodIDOf(
      _classRef, "update", "(Landroid/app/ActivityOptions;)V");

  /// from: public void update(android.app.ActivityOptions otherOptions)
  ///
  /// Update the current values in this ActivityOptions from those supplied
  /// in <var>otherOptions</var>.  Any values
  /// defined in <var>otherOptions</var> replace those in the base options.
  void update(ActivityOptions otherOptions) => jniAccessors.callMethodWithArgs(
      reference,
      _id_update,
      jni.JniType.voidType,
      [otherOptions.reference]).check();

  static final _id_toBundle = jniAccessors.getMethodIDOf(
      _classRef, "toBundle", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle toBundle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the created options as a Bundle, which can be passed to
  /// android.content.Context\#startActivity(android.content.Intent, android.os.Bundle) Context.startActivity(Intent, Bundle) and related methods.
  /// Note that the returned Bundle is still owned by the ActivityOptions
  /// object; you must not modify it, but can supply it to the startActivity
  /// methods that take an options Bundle.
  bundle_.Bundle toBundle() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toBundle, jni.JniType.objectType, []).object);

  static final _id_requestUsageTimeReport = jniAccessors.getMethodIDOf(
      _classRef, "requestUsageTimeReport", "(Landroid/app/PendingIntent;)V");

  /// from: public void requestUsageTimeReport(android.app.PendingIntent receiver)
  ///
  /// Ask the the system track that time the user spends in the app being launched, and
  /// report it back once done.  The report will be sent to the given receiver, with
  /// the extras \#EXTRA_USAGE_TIME_REPORT and \#EXTRA_USAGE_TIME_REPORT_PACKAGES
  /// filled in.
  ///
  /// The time interval tracked is from launching this activity until the user leaves
  /// that activity's flow.  They are considered to stay in the flow as long as
  /// new activities are being launched or returned to from the original flow,
  /// even if this crosses package or task boundaries.  For example, if the originator
  /// starts an activity to view an image, and while there the user selects to share,
  /// which launches their email app in a new task, and they complete the share, the
  /// time during that entire operation will be included until they finally hit back from
  /// the original image viewer activity.
  ///
  ///
  /// The user is considered to complete a flow once they switch to another
  /// activity that is not part of the tracked flow.  This may happen, for example, by
  /// using the notification shade, launcher, or recents to launch or switch to another
  /// app.  Simply going in to these navigation elements does not break the flow (although
  /// the launcher and recents stops time tracking of the session); it is the act of
  /// going somewhere else that completes the tracking.
  ///
  ///@param receiver A broadcast receiver that willl receive the report.
  void requestUsageTimeReport(pendingintent_.PendingIntent receiver) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestUsageTimeReport,
          jni.JniType.voidType, [receiver.reference]).check();

  static final _id_setAppVerificationBundle = jniAccessors.getMethodIDOf(
      _classRef,
      "setAppVerificationBundle",
      "(Landroid/os/Bundle;)Landroid/app/ActivityOptions;");

  /// from: public android.app.ActivityOptions setAppVerificationBundle(android.os.Bundle bundle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the Bundle that is provided to the app installer for additional verification
  /// if the call to Context\#startActivity results in an app being installed.
  ///
  /// This Bundle is not provided to any other app besides the installer.
  ActivityOptions setAppVerificationBundle(bundle_.Bundle bundle) =>
      ActivityOptions.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setAppVerificationBundle,
          jni.JniType.objectType,
          [bundle.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
