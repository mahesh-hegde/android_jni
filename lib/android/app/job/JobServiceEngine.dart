// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Service.dart" as service_;

import "../../os/IBinder.dart" as ibinder_;

import "JobParameters.dart" as jobparameters_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.job.JobServiceEngine
///
/// Helper for implementing a android.app.Service that interacts with
/// JobScheduler.  This is not intended for use by regular applications, but
/// allows frameworks built on top of the platform to create their own
/// android.app.Service that interact with JobScheduler as well as
/// add in additional functionality.  If you just want to execute jobs normally, you
/// should instead be looking at JobService.
class JobServiceEngine extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/job/JobServiceEngine");
  JobServiceEngine.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Service;)V");

  /// from: public void <init>(android.app.Service service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new engine, ready for use.
  ///@param service The Service that is creating this engine and in which it will run.
  JobServiceEngine(service_.Service service)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [service.reference]).object);

  static final _id_getBinder = jniAccessors.getMethodIDOf(
      _classRef, "getBinder", "()Landroid/os/IBinder;");

  /// from: public final android.os.IBinder getBinder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the engine's IPC interface that should be returned by
  /// Service\#onBind(Intent).
  ibinder_.IBinder getBinder() =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBinder, jni.JniType.objectType, []).object);

  static final _id_onStartJob = jniAccessors.getMethodIDOf(
      _classRef, "onStartJob", "(Landroid/app/job/JobParameters;)Z");

  /// from: public abstract boolean onStartJob(android.app.job.JobParameters params)
  ///
  /// Engine's report that a job has started.  See
  /// JobService\#onStartJob(JobParameters) JobService.onStartJob for more information.
  bool onStartJob(jobparameters_.JobParameters params) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartJob,
          jni.JniType.booleanType, [params.reference]).boolean;

  static final _id_onStopJob = jniAccessors.getMethodIDOf(
      _classRef, "onStopJob", "(Landroid/app/job/JobParameters;)Z");

  /// from: public abstract boolean onStopJob(android.app.job.JobParameters params)
  ///
  /// Engine's report that a job has stopped.  See
  /// JobService\#onStopJob(JobParameters) JobService.onStopJob for more information.
  bool onStopJob(jobparameters_.JobParameters params) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStopJob,
          jni.JniType.booleanType, [params.reference]).boolean;

  static final _id_jobFinished = jniAccessors.getMethodIDOf(
      _classRef, "jobFinished", "(Landroid/app/job/JobParameters;Z)V");

  /// from: public void jobFinished(android.app.job.JobParameters params, boolean needsReschedule)
  ///
  /// Call in to engine to report that a job has finished executing.  See
  /// JobService\#jobFinished(JobParameters, boolean)  JobService.jobFinished} for more
  /// information.
  void jobFinished(jobparameters_.JobParameters params, bool needsReschedule) =>
      jniAccessors.callMethodWithArgs(reference, _id_jobFinished,
          jni.JniType.voidType, [params.reference, needsReschedule]).check();
}
