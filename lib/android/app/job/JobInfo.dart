// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;

import "../../os/PersistableBundle.dart" as persistablebundle_;

import "../../os/Bundle.dart" as bundle_;

import "../../content/ClipData.dart" as clipdata_;

import "../../content/ComponentName.dart" as componentname_;

import "../../net/NetworkRequest.dart" as networkrequest_;

import "../../net/Uri.dart" as uri_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.job.JobInfo
///
/// Container of data passed to the android.app.job.JobScheduler fully encapsulating the
/// parameters required to schedule work against the calling application. These are constructed
/// using the JobInfo.Builder.
/// You must specify at least one sort of constraint on the JobInfo object that you are creating.
/// The goal here is to provide the scheduler with high-level semantics about the work you want to
/// accomplish. Doing otherwise with throw an exception in your app.
class JobInfo extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/job/JobInfo");
  JobInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BACKOFF_POLICY_EXPONENTIAL
  ///
  /// Exponentially back-off a failed job. See
  /// android.app.job.JobInfo.Builder\#setBackoffCriteria(long, int)
  ///
  /// retry_time(current_time, num_failures) =
  ///     current_time + initial_backoff_millis * 2 ^ (num_failures - 1), num_failures >= 1
  static const BACKOFF_POLICY_EXPONENTIAL = 1;

  /// from: static public final int BACKOFF_POLICY_LINEAR
  ///
  /// Linearly back-off a failed job. See
  /// android.app.job.JobInfo.Builder\#setBackoffCriteria(long, int)
  /// retry_time(current_time, num_failures) =
  ///     current_time + initial_backoff_millis * num_failures, num_failures >= 1
  static const BACKOFF_POLICY_LINEAR = 0;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.job.JobInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final long DEFAULT_INITIAL_BACKOFF_MILLIS
  ///
  /// Amount of backoff a job has initially by default, in milliseconds.
  static const DEFAULT_INITIAL_BACKOFF_MILLIS = 30000;

  /// from: static public final long MAX_BACKOFF_DELAY_MILLIS
  ///
  /// Maximum backoff we allow for a job, in milliseconds.
  static const MAX_BACKOFF_DELAY_MILLIS = 18000000;

  /// from: static public final int NETWORK_BYTES_UNKNOWN
  ///
  /// Sentinel value indicating that bytes are unknown.
  static const NETWORK_BYTES_UNKNOWN = -1;

  /// from: static public final int NETWORK_TYPE_ANY
  ///
  /// This job requires network connectivity.
  static const NETWORK_TYPE_ANY = 1;

  /// from: static public final int NETWORK_TYPE_CELLULAR
  ///
  /// This job requires network connectivity that is a cellular network.
  static const NETWORK_TYPE_CELLULAR = 4;

  /// from: static public final int NETWORK_TYPE_METERED
  ///
  /// This job requires metered connectivity such as most cellular data
  /// networks.
  ///@deprecated Cellular networks may be unmetered, or Wi-Fi networks may be
  ///             metered, so this isn't a good way of selecting a specific
  ///             transport. Instead, use \#NETWORK_TYPE_CELLULAR or
  ///             android.net.NetworkRequest.Builder\#addTransportType(int)
  ///             if your job requires a specific network transport.
  static const NETWORK_TYPE_METERED = 4;

  /// from: static public final int NETWORK_TYPE_NONE
  ///
  /// Default.
  static const NETWORK_TYPE_NONE = 0;

  /// from: static public final int NETWORK_TYPE_NOT_ROAMING
  ///
  /// This job requires network connectivity that is not roaming.
  static const NETWORK_TYPE_NOT_ROAMING = 3;

  /// from: static public final int NETWORK_TYPE_UNMETERED
  ///
  /// This job requires network connectivity that is unmetered.
  static const NETWORK_TYPE_UNMETERED = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  JobInfo(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [in0.reference]).object);

  static final _id_getMinPeriodMillis =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMinPeriodMillis", "()J");

  /// from: static public final long getMinPeriodMillis()
  ///
  /// Query the minimum interval allowed for periodic scheduled jobs.  Attempting
  /// to declare a smaller period that this when scheduling a job will result in a
  /// job that is still periodic, but will run with this effective period.
  ///@return The minimum available interval for scheduling periodic jobs, in milliseconds.
  static int getMinPeriodMillis() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMinPeriodMillis, jni.JniType.longType, []).long;

  static final _id_getMinFlexMillis =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMinFlexMillis", "()J");

  /// from: static public final long getMinFlexMillis()
  ///
  /// Query the minimum flex time allowed for periodic scheduled jobs.  Attempting
  /// to declare a shorter flex time than this when scheduling such a job will
  /// result in this amount as the effective flex time for the job.
  ///@return The minimum available flex time for scheduling periodic jobs, in milliseconds.
  static int getMinFlexMillis() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMinFlexMillis, jni.JniType.longType, []).long;

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// Unique job id associated with this application (uid).  This is the same job ID
  /// you supplied in the Builder constructor.
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see JobInfo.Builder\#setExtras(PersistableBundle)
  ///@return This value will never be {@code null}.
  persistablebundle_.PersistableBundle getExtras() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_getTransientExtras = jniAccessors.getMethodIDOf(
      _classRef, "getTransientExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getTransientExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see JobInfo.Builder\#setTransientExtras(Bundle)
  ///@return This value will never be {@code null}.
  bundle_.Bundle getTransientExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTransientExtras, jni.JniType.objectType, []).object);

  static final _id_getClipData = jniAccessors.getMethodIDOf(
      _classRef, "getClipData", "()Landroid/content/ClipData;");

  /// from: public android.content.ClipData getClipData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see JobInfo.Builder\#setClipData(ClipData, int)
  ///@return This value may be {@code null}.
  clipdata_.ClipData getClipData() =>
      clipdata_.ClipData.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClipData, jni.JniType.objectType, []).object);

  static final _id_getClipGrantFlags =
      jniAccessors.getMethodIDOf(_classRef, "getClipGrantFlags", "()I");

  /// from: public int getClipGrantFlags()
  ///
  /// @see JobInfo.Builder\#setClipData(ClipData, int)
  int getClipGrantFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getClipGrantFlags, jni.JniType.intType, []).integer;

  static final _id_getService = jniAccessors.getMethodIDOf(
      _classRef, "getService", "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getService()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Name of the service endpoint that will be called back into by the JobScheduler.
  ///@return This value will never be {@code null}.
  componentname_.ComponentName getService() =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getService, jni.JniType.objectType, []).object);

  static final _id_isRequireCharging =
      jniAccessors.getMethodIDOf(_classRef, "isRequireCharging", "()Z");

  /// from: public boolean isRequireCharging()
  ///
  /// @see JobInfo.Builder\#setRequiresCharging(boolean)
  bool isRequireCharging() => jniAccessors.callMethodWithArgs(
      reference, _id_isRequireCharging, jni.JniType.booleanType, []).boolean;

  static final _id_isRequireBatteryNotLow =
      jniAccessors.getMethodIDOf(_classRef, "isRequireBatteryNotLow", "()Z");

  /// from: public boolean isRequireBatteryNotLow()
  ///
  /// @see JobInfo.Builder\#setRequiresBatteryNotLow(boolean)
  bool isRequireBatteryNotLow() => jniAccessors.callMethodWithArgs(reference,
      _id_isRequireBatteryNotLow, jni.JniType.booleanType, []).boolean;

  static final _id_isRequireDeviceIdle =
      jniAccessors.getMethodIDOf(_classRef, "isRequireDeviceIdle", "()Z");

  /// from: public boolean isRequireDeviceIdle()
  ///
  /// @see JobInfo.Builder\#setRequiresDeviceIdle(boolean)
  bool isRequireDeviceIdle() => jniAccessors.callMethodWithArgs(
      reference, _id_isRequireDeviceIdle, jni.JniType.booleanType, []).boolean;

  static final _id_isRequireStorageNotLow =
      jniAccessors.getMethodIDOf(_classRef, "isRequireStorageNotLow", "()Z");

  /// from: public boolean isRequireStorageNotLow()
  ///
  /// @see JobInfo.Builder\#setRequiresStorageNotLow(boolean)
  bool isRequireStorageNotLow() => jniAccessors.callMethodWithArgs(reference,
      _id_isRequireStorageNotLow, jni.JniType.booleanType, []).boolean;

  static final _id_getTriggerContentUris = jniAccessors.getMethodIDOf(
      _classRef,
      "getTriggerContentUris",
      "()[Landroid/app/job/JobInfo\$TriggerContentUri;");

  /// from: public android.app.job.JobInfo.TriggerContentUri[] getTriggerContentUris()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Which content: URIs must change for the job to be scheduled.  Returns null
  /// if there are none required.
  ///@see JobInfo.Builder\#addTriggerContentUri(TriggerContentUri)
  jni.JniObject getTriggerContentUris() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTriggerContentUris, jni.JniType.objectType, []).object);

  static final _id_getTriggerContentUpdateDelay = jniAccessors.getMethodIDOf(
      _classRef, "getTriggerContentUpdateDelay", "()J");

  /// from: public long getTriggerContentUpdateDelay()
  ///
  /// When triggering on content URI changes, this is the delay from when a change
  /// is detected until the job is scheduled.
  ///@see JobInfo.Builder\#setTriggerContentUpdateDelay(long)
  int getTriggerContentUpdateDelay() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getTriggerContentUpdateDelay,
      jni.JniType.longType, []).long;

  static final _id_getTriggerContentMaxDelay =
      jniAccessors.getMethodIDOf(_classRef, "getTriggerContentMaxDelay", "()J");

  /// from: public long getTriggerContentMaxDelay()
  ///
  /// When triggering on content URI changes, this is the maximum delay we will
  /// use before scheduling the job.
  ///@see JobInfo.Builder\#setTriggerContentMaxDelay(long)
  int getTriggerContentMaxDelay() => jniAccessors.callMethodWithArgs(
      reference, _id_getTriggerContentMaxDelay, jni.JniType.longType, []).long;

  static final _id_getNetworkType =
      jniAccessors.getMethodIDOf(_classRef, "getNetworkType", "()I");

  /// from: public int getNetworkType()
  ///
  /// Return the basic description of the kind of network this job requires.
  ///@deprecated This method attempts to map \#getRequiredNetwork()
  ///             into the set of simple constants, which results in a loss of
  ///             fidelity. Callers should move to using
  ///             \#getRequiredNetwork() directly.
  ///@see Builder\#setRequiredNetworkType(int)
  ///@return Value is android.app.job.JobInfo\#NETWORK_TYPE_NONE, android.app.job.JobInfo\#NETWORK_TYPE_ANY, android.app.job.JobInfo\#NETWORK_TYPE_UNMETERED, android.app.job.JobInfo\#NETWORK_TYPE_NOT_ROAMING, or android.app.job.JobInfo\#NETWORK_TYPE_CELLULAR
  int getNetworkType() => jniAccessors.callMethodWithArgs(
      reference, _id_getNetworkType, jni.JniType.intType, []).integer;

  static final _id_getRequiredNetwork = jniAccessors.getMethodIDOf(
      _classRef, "getRequiredNetwork", "()Landroid/net/NetworkRequest;");

  /// from: public android.net.NetworkRequest getRequiredNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the detailed description of the kind of network this job requires,
  /// or {@code null} if no specific kind of network is required.
  ///@see Builder\#setRequiredNetwork(NetworkRequest)
  networkrequest_.NetworkRequest getRequiredNetwork() =>
      networkrequest_.NetworkRequest.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getRequiredNetwork,
          jni.JniType.objectType, []).object);

  static final _id_getEstimatedNetworkDownloadBytes = jniAccessors
      .getMethodIDOf(_classRef, "getEstimatedNetworkDownloadBytes", "()J");

  /// from: public long getEstimatedNetworkDownloadBytes()
  ///
  /// Return the estimated size of download traffic that will be performed by
  /// this job, in bytes.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Estimated size of download traffic, or
  ///         \#NETWORK_BYTES_UNKNOWN when unknown.
  /// Value is a non-negative number of bytes.
  ///@see Builder\#setEstimatedNetworkBytes(long, long)
  int getEstimatedNetworkDownloadBytes() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getEstimatedNetworkDownloadBytes,
      jni.JniType.longType, []).long;

  static final _id_getEstimatedNetworkUploadBytes = jniAccessors.getMethodIDOf(
      _classRef, "getEstimatedNetworkUploadBytes", "()J");

  /// from: public long getEstimatedNetworkUploadBytes()
  ///
  /// Return the estimated size of upload traffic that will be performed by
  /// this job, in bytes.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Estimated size of upload traffic, or
  ///         \#NETWORK_BYTES_UNKNOWN when unknown.
  /// Value is a non-negative number of bytes.
  ///@see Builder\#setEstimatedNetworkBytes(long, long)
  int getEstimatedNetworkUploadBytes() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getEstimatedNetworkUploadBytes,
      jni.JniType.longType, []).long;

  static final _id_getMinLatencyMillis =
      jniAccessors.getMethodIDOf(_classRef, "getMinLatencyMillis", "()J");

  /// from: public long getMinLatencyMillis()
  ///
  /// Set for a job that does not recur periodically, to specify a delay after which the job
  /// will be eligible for execution. This value is not set if the job recurs periodically.
  ///@see JobInfo.Builder\#setMinimumLatency(long)
  int getMinLatencyMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinLatencyMillis, jni.JniType.longType, []).long;

  static final _id_getMaxExecutionDelayMillis = jniAccessors.getMethodIDOf(
      _classRef, "getMaxExecutionDelayMillis", "()J");

  /// from: public long getMaxExecutionDelayMillis()
  ///
  /// @see JobInfo.Builder\#setOverrideDeadline(long)
  int getMaxExecutionDelayMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxExecutionDelayMillis, jni.JniType.longType, []).long;

  static final _id_isPeriodic =
      jniAccessors.getMethodIDOf(_classRef, "isPeriodic", "()Z");

  /// from: public boolean isPeriodic()
  ///
  /// Track whether this job will repeat with a given period.
  ///@see JobInfo.Builder\#setPeriodic(long)
  ///@see JobInfo.Builder\#setPeriodic(long, long)
  bool isPeriodic() => jniAccessors.callMethodWithArgs(
      reference, _id_isPeriodic, jni.JniType.booleanType, []).boolean;

  static final _id_isPersisted =
      jniAccessors.getMethodIDOf(_classRef, "isPersisted", "()Z");

  /// from: public boolean isPersisted()
  ///
  /// @see JobInfo.Builder\#setPersisted(boolean)
  bool isPersisted() => jniAccessors.callMethodWithArgs(
      reference, _id_isPersisted, jni.JniType.booleanType, []).boolean;

  static final _id_getIntervalMillis =
      jniAccessors.getMethodIDOf(_classRef, "getIntervalMillis", "()J");

  /// from: public long getIntervalMillis()
  ///
  /// Set to the interval between occurrences of this job. This value is __not__ set if the
  /// job does not recur periodically.
  ///@see JobInfo.Builder\#setPeriodic(long)
  ///@see JobInfo.Builder\#setPeriodic(long, long)
  int getIntervalMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntervalMillis, jni.JniType.longType, []).long;

  static final _id_getFlexMillis =
      jniAccessors.getMethodIDOf(_classRef, "getFlexMillis", "()J");

  /// from: public long getFlexMillis()
  ///
  /// Flex time for this job. Only valid if this is a periodic job.  The job can
  /// execute at any time in a window of flex length at the end of the period.
  ///@see JobInfo.Builder\#setPeriodic(long)
  ///@see JobInfo.Builder\#setPeriodic(long, long)
  int getFlexMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getFlexMillis, jni.JniType.longType, []).long;

  static final _id_getInitialBackoffMillis =
      jniAccessors.getMethodIDOf(_classRef, "getInitialBackoffMillis", "()J");

  /// from: public long getInitialBackoffMillis()
  ///
  /// The amount of time the JobScheduler will wait before rescheduling a failed job. This value
  /// will be increased depending on the backoff policy specified at job creation time. Defaults
  /// to 30 seconds, minimum is currently 10 seconds.
  ///@see JobInfo.Builder\#setBackoffCriteria(long, int)
  int getInitialBackoffMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getInitialBackoffMillis, jni.JniType.longType, []).long;

  static final _id_getBackoffPolicy =
      jniAccessors.getMethodIDOf(_classRef, "getBackoffPolicy", "()I");

  /// from: public int getBackoffPolicy()
  ///
  /// Return the backoff policy of this job.
  ///@see JobInfo.Builder\#setBackoffCriteria(long, int)
  ///@return Value is android.app.job.JobInfo\#BACKOFF_POLICY_LINEAR, or android.app.job.JobInfo\#BACKOFF_POLICY_EXPONENTIAL
  int getBackoffPolicy() => jniAccessors.callMethodWithArgs(
      reference, _id_getBackoffPolicy, jni.JniType.intType, []).integer;

  static final _id_isImportantWhileForeground = jniAccessors.getMethodIDOf(
      _classRef, "isImportantWhileForeground", "()Z");

  /// from: public boolean isImportantWhileForeground()
  ///
  /// @see JobInfo.Builder\#setImportantWhileForeground(boolean)
  bool isImportantWhileForeground() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isImportantWhileForeground,
      jni.JniType.booleanType, []).boolean;

  static final _id_isPrefetch =
      jniAccessors.getMethodIDOf(_classRef, "isPrefetch", "()Z");

  /// from: public boolean isPrefetch()
  ///
  /// @see JobInfo.Builder\#setPrefetch(boolean)
  bool isPrefetch() => jniAccessors.callMethodWithArgs(
      reference, _id_isPrefetch, jni.JniType.booleanType, []).boolean;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.app.job.JobInfo$TriggerContentUri
///
/// Information about a content URI modification that a job would like to
/// trigger on.
class JobInfo_TriggerContentUri extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/job/JobInfo\$TriggerContentUri");
  JobInfo_TriggerContentUri.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.job.JobInfo.TriggerContentUri> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int FLAG_NOTIFY_FOR_DESCENDANTS
  ///
  /// Flag for trigger: also trigger if any descendants of the given URI change.
  /// Corresponds to the <var>notifyForDescendants</var> of
  /// android.content.ContentResolver\#registerContentObserver.
  static const FLAG_NOTIFY_FOR_DESCENDANTS = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/net/Uri;I)V");

  /// from: public void <init>(android.net.Uri uri, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new trigger description.
  ///@param uri The URI to observe.  Must be non-null.
  /// This value must never be {@code null}.
  ///@param flags Flags for the observer.
  ///
  /// Value is either <code>0</code> or android.app.job.JobInfo.TriggerContentUri\#FLAG_NOTIFY_FOR_DESCENDANTS
  JobInfo_TriggerContentUri(uri_.Uri uri, int flags)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [uri.reference, flags]).object);

  static final _id_getUri =
      jniAccessors.getMethodIDOf(_classRef, "getUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Uri this trigger was created for.
  uri_.Uri getUri() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getUri, jni.JniType.objectType, []).object);

  static final _id_getFlags =
      jniAccessors.getMethodIDOf(_classRef, "getFlags", "()I");

  /// from: public int getFlags()
  ///
  /// Return the flags supplied for the trigger.
  ///@return Value is either <code>0</code> or android.app.job.JobInfo.TriggerContentUri\#FLAG_NOTIFY_FOR_DESCENDANTS
  int getFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getFlags, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();
}

/// from: android.app.job.JobInfo$Builder
///
/// Builder class for constructing JobInfo objects.
class JobInfo_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/job/JobInfo\$Builder");
  JobInfo_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILandroid/content/ComponentName;)V");

  /// from: public void <init>(int jobId, android.content.ComponentName jobService)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initialize a new Builder to construct a JobInfo.
  ///@param jobId Application-provided id for this job. Subsequent calls to cancel, or
  /// jobs created with the same jobId, will update the pre-existing job with
  /// the same id.  This ID must be unique across all clients of the same uid
  /// (not just the same package).  You will want to make sure this is a stable
  /// id across app updates, so probably not based on a resource ID.
  ///@param jobService The endpoint that you implement that will receive the callback from the
  /// JobScheduler.
  ///
  /// This value must never be {@code null}.
  JobInfo_Builder(int jobId, componentname_.ComponentName jobService)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [jobId, jobService.reference]).object);

  static final _id_setExtras = jniAccessors.getMethodIDOf(
      _classRef,
      "setExtras",
      "(Landroid/os/PersistableBundle;)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setExtras(android.os.PersistableBundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set optional extras. This is persisted, so we only allow primitive types.
  ///@param extras Bundle containing extras you want the scheduler to hold on to for you.
  /// This value must never be {@code null}.
  ///@see JobInfo\#getExtras()
  JobInfo_Builder setExtras(persistablebundle_.PersistableBundle extras) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setExtras, jni.JniType.objectType, [extras.reference]).object);

  static final _id_setTransientExtras = jniAccessors.getMethodIDOf(
      _classRef,
      "setTransientExtras",
      "(Landroid/os/Bundle;)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setTransientExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set optional transient extras.
  ///
  /// Because setting this property is not compatible with persisted
  /// jobs, doing so will throw an java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///
  ///@param extras Bundle containing extras you want the scheduler to hold on to for you.
  /// This value must never be {@code null}.
  ///@see JobInfo\#getTransientExtras()
  JobInfo_Builder setTransientExtras(bundle_.Bundle extras) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTransientExtras,
          jni.JniType.objectType,
          [extras.reference]).object);

  static final _id_setClipData = jniAccessors.getMethodIDOf(
      _classRef,
      "setClipData",
      "(Landroid/content/ClipData;I)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setClipData(android.content.ClipData clip, int grantFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a ClipData associated with this Job.
  ///
  /// The main purpose of providing a ClipData is to allow granting of
  /// URI permissions for data associated with the clip.  The exact kind
  /// of permission grant to perform is specified through <var>grantFlags</var>.
  ///
  /// If the ClipData contains items that are Intents, any
  /// grant flags in those Intents will be ignored.  Only flags provided as an argument
  /// to this method are respected, and will be applied to all Uri or
  /// Intent items in the clip (or sub-items of the clip).
  ///
  /// Because setting this property is not compatible with persisted
  /// jobs, doing so will throw an java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///
  ///@param clip The new clip to set.  May be null to clear the current clip.
  /// This value may be {@code null}.
  ///@param grantFlags The desired permissions to grant for any URIs.  This should be
  /// a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION,
  /// android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, and
  /// android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION.
  ///@see JobInfo\#getClipData()
  ///@see JobInfo\#getClipGrantFlags()
  JobInfo_Builder setClipData(clipdata_.ClipData clip, int grantFlags) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setClipData,
          jni.JniType.objectType,
          [clip.reference, grantFlags]).object);

  static final _id_setRequiredNetworkType = jniAccessors.getMethodIDOf(
      _classRef,
      "setRequiredNetworkType",
      "(I)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setRequiredNetworkType(int networkType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set basic description of the kind of network your job requires. If
  /// you need more precise control over network capabilities, see
  /// \#setRequiredNetwork(NetworkRequest).
  ///
  /// If your job doesn't need a network connection, you don't need to call
  /// this method, as the default value is \#NETWORK_TYPE_NONE.
  ///
  /// Calling this method defines network as a strict requirement for your
  /// job. If the network requested is not available your job will never
  /// run. See \#setOverrideDeadline(long) to change this behavior.
  /// Calling this method will override any requirements previously defined
  /// by \#setRequiredNetwork(NetworkRequest); you typically only
  /// want to call one of these methods.
  /// <p class="note">
  /// When your job executes in
  /// JobService\#onStartJob(JobParameters), be sure to use the
  /// specific network returned by JobParameters\#getNetwork(),
  /// otherwise you'll use the default network which may not meet this
  /// constraint.
  ///@see \#setRequiredNetwork(NetworkRequest)
  ///@see JobInfo\#getNetworkType()
  ///@see JobParameters\#getNetwork()
  ///@param networkType Value is android.app.job.JobInfo\#NETWORK_TYPE_NONE, android.app.job.JobInfo\#NETWORK_TYPE_ANY, android.app.job.JobInfo\#NETWORK_TYPE_UNMETERED, android.app.job.JobInfo\#NETWORK_TYPE_NOT_ROAMING, or android.app.job.JobInfo\#NETWORK_TYPE_CELLULAR
  JobInfo_Builder setRequiredNetworkType(int networkType) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiredNetworkType,
          jni.JniType.objectType,
          [networkType]).object);

  static final _id_setRequiredNetwork = jniAccessors.getMethodIDOf(
      _classRef,
      "setRequiredNetwork",
      "(Landroid/net/NetworkRequest;)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setRequiredNetwork(android.net.NetworkRequest networkRequest)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set detailed description of the kind of network your job requires.
  ///
  /// If your job doesn't need a network connection, you don't need to call
  /// this method, as the default is {@code null}.
  ///
  /// Calling this method defines network as a strict requirement for your
  /// job. If the network requested is not available your job will never
  /// run. See \#setOverrideDeadline(long) to change this behavior.
  /// Calling this method will override any requirements previously defined
  /// by \#setRequiredNetworkType(int); you typically only want to
  /// call one of these methods.
  /// <p class="note">
  /// When your job executes in
  /// JobService\#onStartJob(JobParameters), be sure to use the
  /// specific network returned by JobParameters\#getNetwork(),
  /// otherwise you'll use the default network which may not meet this
  /// constraint.
  ///@param networkRequest The detailed description of the kind of network
  ///            this job requires, or {@code null} if no specific kind of
  ///            network is required. Defining a NetworkSpecifier
  ///            is only supported for jobs that aren't persisted.
  /// This value may be {@code null}.
  ///@see \#setRequiredNetworkType(int)
  ///@see JobInfo\#getRequiredNetwork()
  ///@see JobParameters\#getNetwork()
  JobInfo_Builder setRequiredNetwork(
          networkrequest_.NetworkRequest networkRequest) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiredNetwork,
          jni.JniType.objectType,
          [networkRequest.reference]).object);

  static final _id_setEstimatedNetworkBytes = jniAccessors.getMethodIDOf(
      _classRef,
      "setEstimatedNetworkBytes",
      "(JJ)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setEstimatedNetworkBytes(long downloadBytes, long uploadBytes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the estimated size of network traffic that will be performed by
  /// this job, in bytes.
  ///
  /// Apps are encouraged to provide values that are as accurate as
  /// possible, but when the exact size isn't available, an
  /// order-of-magnitude estimate can be provided instead. Here are some
  /// specific examples:
  /// <ul>
  /// <li>A job that is backing up a photo knows the exact size of that
  /// photo, so it should provide that size as the estimate.
  /// <li>A job that refreshes top news stories wouldn't know an exact
  /// size, but if the size is expected to be consistently around 100KB, it
  /// can provide that order-of-magnitude value as the estimate.
  /// <li>A job that synchronizes email could end up using an extreme range
  /// of data, from under 1KB when nothing has changed, to dozens of MB
  /// when there are new emails with attachments. Jobs that cannot provide
  /// reasonable estimates should use the sentinel value
  /// JobInfo\#NETWORK_BYTES_UNKNOWN.
  /// </ul>
  /// Note that the system may choose to delay jobs with large network
  /// usage estimates when the device has a poor network connection, in
  /// order to save battery.
  ///
  /// The values provided here only reflect the traffic that will be
  /// performed by the base job; if you're using JobWorkItem then
  /// you also need to define the network traffic used by each work item
  /// when constructing them.
  ///@param downloadBytes The estimated size of network traffic that will
  ///            be downloaded by this job, in bytes.
  /// Value is a non-negative number of bytes.
  ///@param uploadBytes The estimated size of network traffic that will be
  ///            uploaded by this job, in bytes.
  /// Value is a non-negative number of bytes.
  ///@see JobInfo\#getEstimatedNetworkDownloadBytes()
  ///@see JobInfo\#getEstimatedNetworkUploadBytes()
  ///@see JobWorkItem\#JobWorkItem(android.content.Intent, long, long)
  JobInfo_Builder setEstimatedNetworkBytes(
          int downloadBytes, int uploadBytes) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setEstimatedNetworkBytes,
          jni.JniType.objectType,
          [downloadBytes, uploadBytes]).object);

  static final _id_setRequiresCharging = jniAccessors.getMethodIDOf(_classRef,
      "setRequiresCharging", "(Z)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setRequiresCharging(boolean requiresCharging)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run this job, the device must be charging (or be a
  /// non-battery-powered device connected to permanent power, such as Android TV
  /// devices). This defaults to {@code false}.
  ///
  /// <p class="note">For purposes of running jobs, a battery-powered device
  /// "charging" is not quite the same as simply being connected to power.  If the
  /// device is so busy that the battery is draining despite a power connection, jobs
  /// with this constraint will _not_ run.  This can happen during some
  /// common use cases such as video chat, particularly if the device is plugged in
  /// to USB rather than to wall power.
  ///@param requiresCharging Pass {@code true} to require that the device be
  ///     charging in order to run the job.
  ///@see JobInfo\#isRequireCharging()
  JobInfo_Builder setRequiresCharging(bool requiresCharging) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiresCharging,
          jni.JniType.objectType,
          [requiresCharging]).object);

  static final _id_setRequiresBatteryNotLow = jniAccessors.getMethodIDOf(
      _classRef,
      "setRequiresBatteryNotLow",
      "(Z)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setRequiresBatteryNotLow(boolean batteryNotLow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run this job, the device's battery level must not be low.
  /// This defaults to false.  If true, the job will only run when the battery level
  /// is not low, which is generally the point where the user is given a "low battery"
  /// warning.
  ///@param batteryNotLow Whether or not the device's battery level must not be low.
  ///@see JobInfo\#isRequireBatteryNotLow()
  JobInfo_Builder setRequiresBatteryNotLow(bool batteryNotLow) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiresBatteryNotLow,
          jni.JniType.objectType,
          [batteryNotLow]).object);

  static final _id_setRequiresDeviceIdle = jniAccessors.getMethodIDOf(_classRef,
      "setRequiresDeviceIdle", "(Z)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setRequiresDeviceIdle(boolean requiresDeviceIdle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// When set {@code true}, ensure that this job will not run if the device is in active use.
  /// The default state is {@code false}: that is, the for the job to be runnable even when
  /// someone is interacting with the device.
  ///
  /// This state is a loose definition provided by the system. In general, it means that
  /// the device is not currently being used interactively, and has not been in use for some
  /// time. As such, it is a good time to perform resource heavy jobs. Bear in mind that
  /// battery usage will still be attributed to your application, and surfaced to the user in
  /// battery stats.
  ///
  ///
  /// <p class="note">Despite the similar naming, this job constraint is _not_
  /// related to the system's "device idle" or "doze" states.  This constraint only
  /// determines whether a job is allowed to run while the device is directly in use.
  ///@param requiresDeviceIdle Pass {@code true} to prevent the job from running
  ///     while the device is being used interactively.
  ///@see JobInfo\#isRequireDeviceIdle()
  JobInfo_Builder setRequiresDeviceIdle(bool requiresDeviceIdle) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiresDeviceIdle,
          jni.JniType.objectType,
          [requiresDeviceIdle]).object);

  static final _id_setRequiresStorageNotLow = jniAccessors.getMethodIDOf(
      _classRef,
      "setRequiresStorageNotLow",
      "(Z)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setRequiresStorageNotLow(boolean storageNotLow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run this job, the device's available storage must not be low.
  /// This defaults to false.  If true, the job will only run when the device is not
  /// in a low storage state, which is generally the point where the user is given a
  /// "low storage" warning.
  ///@param storageNotLow Whether or not the device's available storage must not be low.
  ///@see JobInfo\#isRequireStorageNotLow()
  JobInfo_Builder setRequiresStorageNotLow(bool storageNotLow) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiresStorageNotLow,
          jni.JniType.objectType,
          [storageNotLow]).object);

  static final _id_addTriggerContentUri = jniAccessors.getMethodIDOf(
      _classRef,
      "addTriggerContentUri",
      "(Landroid/app/job/JobInfo\$TriggerContentUri;)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder addTriggerContentUri(android.app.job.JobInfo.TriggerContentUri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new content: URI that will be monitored with a
  /// android.database.ContentObserver, and will cause the job to execute if changed.
  /// If you have any trigger content URIs associated with a job, it will not execute until
  /// there has been a change report for one or more of them.
  ///
  /// Note that trigger URIs can not be used in combination with
  /// \#setPeriodic(long) or \#setPersisted(boolean).  To continually monitor
  /// for content changes, you need to schedule a new JobInfo observing the same URIs
  /// before you finish execution of the JobService handling the most recent changes.
  /// Following this pattern will ensure you do not lost any content changes: while your
  /// job is running, the system will continue monitoring for content changes, and propagate
  /// any it sees over to the next job you schedule.
  ///
  ///
  /// Because setting this property is not compatible with periodic or
  /// persisted jobs, doing so will throw an java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///
  ///
  /// The following example shows how this feature can be used to monitor for changes
  /// in the photos on a device.
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/content/PhotosContentJob.java
  ///      job}
  ///@param uri The content: URI to monitor.
  /// This value must never be {@code null}.
  ///@see JobInfo\#getTriggerContentUris()
  JobInfo_Builder addTriggerContentUri(JobInfo_TriggerContentUri uri) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addTriggerContentUri,
          jni.JniType.objectType,
          [uri.reference]).object);

  static final _id_setTriggerContentUpdateDelay = jniAccessors.getMethodIDOf(
      _classRef,
      "setTriggerContentUpdateDelay",
      "(J)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setTriggerContentUpdateDelay(long durationMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the delay (in milliseconds) from when a content change is detected until
  /// the job is scheduled.  If there are more changes during that time, the delay
  /// will be reset to start at the time of the most recent change.
  ///@param durationMs Delay after most recent content change, in milliseconds.
  ///@see JobInfo\#getTriggerContentUpdateDelay()
  JobInfo_Builder setTriggerContentUpdateDelay(int durationMs) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTriggerContentUpdateDelay,
          jni.JniType.objectType,
          [durationMs]).object);

  static final _id_setTriggerContentMaxDelay = jniAccessors.getMethodIDOf(
      _classRef,
      "setTriggerContentMaxDelay",
      "(J)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setTriggerContentMaxDelay(long durationMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the maximum total delay (in milliseconds) that is allowed from the first
  /// time a content change is detected until the job is scheduled.
  ///@param durationMs Delay after initial content change, in milliseconds.
  ///@see JobInfo\#getTriggerContentMaxDelay()
  JobInfo_Builder setTriggerContentMaxDelay(int durationMs) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTriggerContentMaxDelay,
          jni.JniType.objectType,
          [durationMs]).object);

  static final _id_setPeriodic = jniAccessors.getMethodIDOf(
      _classRef, "setPeriodic", "(J)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setPeriodic(long intervalMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that this job should recur with the provided interval, not more than once per
  /// period. You have no control over when within this interval this job will be executed,
  /// only the guarantee that it will be executed at most once within this interval.
  /// Setting this function on the builder with \#setMinimumLatency(long) or
  /// \#setOverrideDeadline(long) will result in an error.
  ///@param intervalMillis Millisecond interval for which this job will repeat.
  ///@see JobInfo\#getIntervalMillis()
  ///@see JobInfo\#getFlexMillis()
  JobInfo_Builder setPeriodic(int intervalMillis) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setPeriodic, jni.JniType.objectType, [intervalMillis]).object);

  static final _id_setPeriodic1 = jniAccessors.getMethodIDOf(
      _classRef, "setPeriodic", "(JJ)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setPeriodic(long intervalMillis, long flexMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that this job should recur with the provided interval and flex. The job can
  /// execute at any time in a window of flex length at the end of the period.
  ///@param intervalMillis Millisecond interval for which this job will repeat. A minimum
  ///                       value of \#getMinPeriodMillis() is enforced.
  ///@param flexMillis Millisecond flex for this job. Flex is clamped to be at least
  ///                   \#getMinFlexMillis() or 5 percent of the period, whichever is
  ///                   higher.
  ///@see JobInfo\#getIntervalMillis()
  ///@see JobInfo\#getFlexMillis()
  JobInfo_Builder setPeriodic1(int intervalMillis, int flexMillis) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setPeriodic1,
          jni.JniType.objectType,
          [intervalMillis, flexMillis]).object);

  static final _id_setMinimumLatency = jniAccessors.getMethodIDOf(
      _classRef, "setMinimumLatency", "(J)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setMinimumLatency(long minLatencyMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that this job should be delayed by the provided amount of time.
  /// Because it doesn't make sense setting this property on a periodic job, doing so will
  /// throw an java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///@param minLatencyMillis Milliseconds before which this job will not be considered for
  ///                         execution.
  ///@see JobInfo\#getMinLatencyMillis()
  JobInfo_Builder setMinimumLatency(int minLatencyMillis) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setMinimumLatency,
          jni.JniType.objectType,
          [minLatencyMillis]).object);

  static final _id_setOverrideDeadline = jniAccessors.getMethodIDOf(_classRef,
      "setOverrideDeadline", "(J)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setOverrideDeadline(long maxExecutionDelayMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set deadline which is the maximum scheduling latency. The job will be run by this
  /// deadline even if other requirements are not met. Because it doesn't make sense setting
  /// this property on a periodic job, doing so will throw an
  /// java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///@see JobInfo\#getMaxExecutionDelayMillis()
  JobInfo_Builder setOverrideDeadline(int maxExecutionDelayMillis) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setOverrideDeadline,
          jni.JniType.objectType,
          [maxExecutionDelayMillis]).object);

  static final _id_setBackoffCriteria = jniAccessors.getMethodIDOf(_classRef,
      "setBackoffCriteria", "(JI)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setBackoffCriteria(long initialBackoffMillis, int backoffPolicy)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set up the back-off/retry policy.
  /// This defaults to some respectable values: {30 seconds, Exponential}. We cap back-off at
  /// 5hrs.
  /// Note that trying to set a backoff criteria for a job with
  /// \#setRequiresDeviceIdle(boolean) will throw an exception when you call build().
  /// This is because back-off typically does not make sense for these types of jobs. See
  /// android.app.job.JobService\#jobFinished(android.app.job.JobParameters, boolean)
  /// for more description of the return value for the case of a job executing while in idle
  /// mode.
  ///@param initialBackoffMillis Millisecond time interval to wait initially when job has
  ///                             failed.
  ///@see JobInfo\#getInitialBackoffMillis()
  ///@see JobInfo\#getBackoffPolicy()
  ///@param backoffPolicy Value is android.app.job.JobInfo\#BACKOFF_POLICY_LINEAR, or android.app.job.JobInfo\#BACKOFF_POLICY_EXPONENTIAL
  JobInfo_Builder setBackoffCriteria(
          int initialBackoffMillis, int backoffPolicy) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setBackoffCriteria,
          jni.JniType.objectType,
          [initialBackoffMillis, backoffPolicy]).object);

  static final _id_setImportantWhileForeground = jniAccessors.getMethodIDOf(
      _classRef,
      "setImportantWhileForeground",
      "(Z)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setImportantWhileForeground(boolean importantWhileForeground)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Setting this to true indicates that this job is important while the scheduling app
  /// is in the foreground or on the temporary whitelist for background restrictions.
  /// This means that the system will relax doze restrictions on this job during this time.
  ///
  /// Apps should use this flag only for short jobs that are essential for the app to function
  /// properly in the foreground.
  ///
  /// Note that once the scheduling app is no longer whitelisted from background restrictions
  /// and in the background, or the job failed due to unsatisfied constraints,
  /// this job should be expected to behave like other jobs without this flag.
  ///@param importantWhileForeground whether to relax doze restrictions for this job when the
  ///                                 app is in the foreground. False by default.
  ///@see JobInfo\#isImportantWhileForeground()
  JobInfo_Builder setImportantWhileForeground(bool importantWhileForeground) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setImportantWhileForeground,
          jni.JniType.objectType,
          [importantWhileForeground]).object);

  static final _id_setPrefetch = jniAccessors.getMethodIDOf(
      _classRef, "setPrefetch", "(Z)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setPrefetch(boolean prefetch)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Setting this to true indicates that this job is designed to prefetch
  /// content that will make a material improvement to the experience of
  /// the specific user of this device. For example, fetching top headlines
  /// of interest to the current user.
  ///
  /// The system may use this signal to relax the network constraints you
  /// originally requested, such as allowing a
  /// JobInfo\#NETWORK_TYPE_UNMETERED job to run over a metered
  /// network when there is a surplus of metered data available. The system
  /// may also use this signal in combination with end user usage patterns
  /// to ensure data is prefetched before the user launches your app.
  ///@see JobInfo\#isPrefetch()
  JobInfo_Builder setPrefetch(bool prefetch) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setPrefetch, jni.JniType.objectType, [prefetch]).object);

  static final _id_setPersisted = jniAccessors.getMethodIDOf(
      _classRef, "setPersisted", "(Z)Landroid/app/job/JobInfo\$Builder;");

  /// from: public android.app.job.JobInfo.Builder setPersisted(boolean isPersisted)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether or not to persist this job across device reboots.
  ///
  /// Requires android.Manifest.permission\#RECEIVE_BOOT_COMPLETED
  ///@param isPersisted True to indicate that the job will be written to
  ///            disk and loaded at boot.
  ///@see JobInfo\#isPersisted()
  JobInfo_Builder setPersisted(bool isPersisted) =>
      JobInfo_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setPersisted, jni.JniType.objectType, [isPersisted]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/app/job/JobInfo;");

  /// from: public android.app.job.JobInfo build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The job object to hand to the JobScheduler. This object is immutable.
  JobInfo build() => JobInfo.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_build, jni.JniType.objectType, []).object);
}
