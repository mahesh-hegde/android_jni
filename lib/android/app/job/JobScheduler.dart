// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "JobInfo.dart" as jobinfo_;

import "JobWorkItem.dart" as jobworkitem_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.job.JobScheduler
///
/// This is an API for scheduling various types of jobs against the framework that will be executed
/// in your application's own process.
///
/// See android.app.job.JobInfo for more description of the types of jobs that can be run
/// and how to construct them. You will construct these JobInfo objects and pass them to the
/// JobScheduler with \#schedule(JobInfo). When the criteria declared are met, the
/// system will execute this job on your application's android.app.job.JobService.
/// You identify the service component that implements the logic for your job when you
/// construct the JobInfo using
/// android.app.job.JobInfo.Builder\#JobInfo.Builder(int,android.content.ComponentName).
///
///
///
/// The framework will be intelligent about when it executes jobs, and attempt to batch
/// and defer them as much as possible. Typically if you don't specify a deadline on a job, it
/// can be run at any moment depending on the current state of the JobScheduler's internal queue.
///
/// While a job is running, the system holds a wakelock on behalf of your app.  For this reason,
/// you do not need to take any action to guarantee that the device stays awake for the
/// duration of the job.
///
///
/// You do not
/// instantiate this class directly; instead, retrieve it through
/// android.content.Context\#getSystemService Context.getSystemService(Context.JOB_SCHEDULER_SERVICE).
class JobScheduler extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/job/JobScheduler");
  JobScheduler.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int RESULT_FAILURE
  ///
  /// Returned from \#schedule(JobInfo) when an invalid parameter was supplied. This can occur
  /// if the run-time for your job is too short, or perhaps the system can't resolve the
  /// requisite JobService in your package.
  static const RESULT_FAILURE = 0;

  /// from: static public final int RESULT_SUCCESS
  ///
  /// Returned from \#schedule(JobInfo) if this job has been successfully scheduled.
  static const RESULT_SUCCESS = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  JobScheduler()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_schedule = jniAccessors.getMethodIDOf(
      _classRef, "schedule", "(Landroid/app/job/JobInfo;)I");

  /// from: public abstract int schedule(android.app.job.JobInfo job)
  ///
  /// Schedule a job to be executed.  Will replace any currently scheduled job with the same
  /// ID with the new information in the JobInfo.  If a job with the given ID is currently
  /// running, it will be stopped.
  ///@param job The job you wish scheduled. See
  /// android.app.job.JobInfo.Builder JobInfo.Builder for more detail on the sorts of jobs
  /// you can schedule.
  /// This value must never be {@code null}.
  ///@return the result of the schedule request.
  ///
  /// Value is android.app.job.JobScheduler\#RESULT_FAILURE, or android.app.job.JobScheduler\#RESULT_SUCCESS
  int schedule(jobinfo_.JobInfo job) => jniAccessors.callMethodWithArgs(
      reference, _id_schedule, jni.JniType.intType, [job.reference]).integer;

  static final _id_enqueue = jniAccessors.getMethodIDOf(_classRef, "enqueue",
      "(Landroid/app/job/JobInfo;Landroid/app/job/JobWorkItem;)I");

  /// from: public abstract int enqueue(android.app.job.JobInfo job, android.app.job.JobWorkItem work)
  ///
  /// Similar to \#schedule, but allows you to enqueue work for a new _or existing_
  /// job.  If a job with the same ID is already scheduled, it will be replaced with the
  /// new JobInfo, but any previously enqueued work will remain and be dispatched the
  /// next time it runs.  If a job with the same ID is already running, the new work will be
  /// enqueued for it.
  ///
  /// The work you enqueue is later retrieved through
  /// JobParameters\#dequeueWork() JobParameters.dequeueWork.  Be sure to see there
  /// about how to process work; the act of enqueueing work changes how you should handle the
  /// overall lifecycle of an executing job.
  ///
  ///
  /// It is strongly encouraged that you use the same JobInfo for all work you
  /// enqueue.  This will allow the system to optimally schedule work along with any pending
  /// and/or currently running work.  If the JobInfo changes from the last time the job was
  /// enqueued, the system will need to update the associated JobInfo, which can cause a disruption
  /// in execution.  In particular, this can result in any currently running job that is processing
  /// previous work to be stopped and restarted with the new JobInfo.
  ///
  ///
  /// It is recommended that you avoid using
  /// JobInfo.Builder\#setExtras(PersistableBundle) or
  /// JobInfo.Builder\#setTransientExtras(Bundle) with a JobInfo you are using to
  /// enqueue work.  The system will try to compare these extras with the previous JobInfo,
  /// but there are situations where it may get this wrong and count the JobInfo as changing.
  /// (That said, you should be relatively safe with a simple set of consistent data in these
  /// fields.)  You should never use JobInfo.Builder\#setClipData(ClipData, int) with
  /// work you are enqueue, since currently this will always be treated as a different JobInfo,
  /// even if the ClipData contents are exactly the same.
  ///
  ///@param job The job you wish to enqueue work for. See
  /// android.app.job.JobInfo.Builder JobInfo.Builder for more detail on the sorts of jobs
  /// you can schedule.
  /// This value must never be {@code null}.
  ///@param work New work to enqueue.  This will be available later when the job starts running.
  /// This value must never be {@code null}.
  ///@return the result of the enqueue request.
  ///
  /// Value is android.app.job.JobScheduler\#RESULT_FAILURE, or android.app.job.JobScheduler\#RESULT_SUCCESS
  int enqueue(jobinfo_.JobInfo job, jobworkitem_.JobWorkItem work) =>
      jniAccessors.callMethodWithArgs(reference, _id_enqueue,
          jni.JniType.intType, [job.reference, work.reference]).integer;

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "(I)V");

  /// from: public abstract void cancel(int jobId)
  ///
  /// Cancel the specified job.  If the job is currently executing, it is stopped
  /// immediately and the return value from its JobService\#onStopJob(JobParameters)
  /// method is ignored.
  ///@param jobId unique identifier for the job to be canceled, as supplied to
  ///     JobInfo.Builder\#JobInfo.Builder(int, android.content.ComponentName)
  ///     JobInfo.Builder(int, android.content.ComponentName).
  void cancel(int jobId) => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, [jobId]).check();

  static final _id_cancelAll =
      jniAccessors.getMethodIDOf(_classRef, "cancelAll", "()V");

  /// from: public abstract void cancelAll()
  ///
  /// Cancel _all_ jobs that have been scheduled by the calling application.
  void cancelAll() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelAll, jni.JniType.voidType, []).check();

  static final _id_getAllPendingJobs = jniAccessors.getMethodIDOf(
      _classRef, "getAllPendingJobs", "()Ljava/util/List;");

  /// from: public abstract java.util.List<android.app.job.JobInfo> getAllPendingJobs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all jobs that have been scheduled by the calling application.
  ///@return a list of all of the app's scheduled jobs.  This includes jobs that are
  ///     currently started as well as those that are still waiting to run.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getAllPendingJobs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllPendingJobs, jni.JniType.objectType, []).object);

  static final _id_getPendingJob = jniAccessors.getMethodIDOf(
      _classRef, "getPendingJob", "(I)Landroid/app/job/JobInfo;");

  /// from: public abstract android.app.job.JobInfo getPendingJob(int jobId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Look up the description of a scheduled job.
  ///@return The JobInfo description of the given scheduled job, or {@code null}
  ///     if the supplied job ID does not correspond to any job.
  jobinfo_.JobInfo getPendingJob(int jobId) =>
      jobinfo_.JobInfo.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPendingJob, jni.JniType.objectType, [jobId]).object);
}
