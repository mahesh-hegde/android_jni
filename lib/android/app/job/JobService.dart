// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Service.dart" as service_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;

import "JobParameters.dart" as jobparameters_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.job.JobService
///
/// Entry point for the callback from the android.app.job.JobScheduler.
///
/// This is the base class that handles asynchronous requests that were previously scheduled. You
/// are responsible for overriding JobService\#onStartJob(JobParameters), which is where
/// you will implement your job logic.
///
/// This service executes each incoming job on a android.os.Handler running on your
/// application's main thread. This means that you __must__ offload your execution logic to
/// another thread/handler/android.os.AsyncTask of your choosing. Not doing so will result
/// in blocking any future callbacks from the JobManager - specifically
/// \#onStopJob(android.app.job.JobParameters), which is meant to inform you that the
/// scheduling requirements are no longer being met.
///
class JobService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/app/job/JobService");
  JobService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String PERMISSION_BIND
  ///
  /// Job services must be protected with this permission:
  ///
  /// <pre class="prettyprint">
  ///     &\#60;service android:name="MyJobService"
  ///              android:permission="android.permission.BIND_JOB_SERVICE" &\#62;
  ///         ...
  ///     &\#60;/service&\#62;
  /// </pre>
  ///
  /// If a job service is declared in the manifest but not protected with this
  /// permission, that service will be ignored by the system.
  static const PERMISSION_BIND = "android.permission.BIND_JOB_SERVICE";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  JobService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_jobFinished = jniAccessors.getMethodIDOf(
      _classRef, "jobFinished", "(Landroid/app/job/JobParameters;Z)V");

  /// from: public final void jobFinished(android.app.job.JobParameters params, boolean wantsReschedule)
  ///
  /// Call this to inform the JobScheduler that the job has finished its work.  When the
  /// system receives this message, it releases the wakelock being held for the job.
  ///
  /// You can request that the job be scheduled again by passing {@code true} as
  /// the <code>wantsReschedule</code> parameter. This will apply back-off policy
  /// for the job; this policy can be adjusted through the
  /// android.app.job.JobInfo.Builder\#setBackoffCriteria(long, int) method
  /// when the job is originally scheduled.  The job's initial
  /// requirements are preserved when jobs are rescheduled, regardless of backed-off
  /// policy.
  /// <p class="note">
  /// A job running while the device is dozing will not be rescheduled with the normal back-off
  /// policy.  Instead, the job will be re-added to the queue and executed again during
  /// a future idle maintenance window.
  ///
  ///
  ///@param params The parameters identifying this job, as supplied to
  ///               the job in the \#onStartJob(JobParameters) callback.
  ///@param wantsReschedule {@code true} if this job should be rescheduled according
  ///     to the back-off criteria specified when it was first scheduled; {@code false}
  ///     otherwise.
  void jobFinished(jobparameters_.JobParameters params, bool wantsReschedule) =>
      jniAccessors.callMethodWithArgs(reference, _id_jobFinished,
          jni.JniType.voidType, [params.reference, wantsReschedule]).check();

  static final _id_onStartJob = jniAccessors.getMethodIDOf(
      _classRef, "onStartJob", "(Landroid/app/job/JobParameters;)Z");

  /// from: public abstract boolean onStartJob(android.app.job.JobParameters params)
  ///
  /// Called to indicate that the job has begun executing.  Override this method with the
  /// logic for your job.  Like all other component lifecycle callbacks, this method executes
  /// on your application's main thread.
  ///
  /// Return {@code true} from this method if your job needs to continue running.  If you
  /// do this, the job remains active until you call
  /// \#jobFinished(JobParameters, boolean) to tell the system that it has completed
  /// its work, or until the job's required constraints are no longer satisfied.  For
  /// example, if the job was scheduled using
  /// JobInfo.Builder\#setRequiresCharging(boolean) setRequiresCharging(true),
  /// it will be immediately halted by the system if the user unplugs the device from power,
  /// the job's \#onStopJob(JobParameters) callback will be invoked, and the app
  /// will be expected to shut down all ongoing work connected with that job.
  ///
  /// The system holds a wakelock on behalf of your app as long as your job is executing.
  /// This wakelock is acquired before this method is invoked, and is not released until either
  /// you call \#jobFinished(JobParameters, boolean), or after the system invokes
  /// \#onStopJob(JobParameters) to notify your job that it is being shut down
  /// prematurely.
  ///
  /// Returning {@code false} from this method means your job is already finished.  The
  /// system's wakelock for the job will be released, and \#onStopJob(JobParameters)
  /// will not be invoked.
  ///@param params Parameters specifying info about this job, including the optional
  ///     extras configured with {@link JobInfo.Builder\#setExtras(android.os.PersistableBundle).
  ///     This object serves to identify this specific running job instance when calling
  ///     \#jobFinished(JobParameters, boolean).
  ///@return {@code true} if your service will continue running, using a separate thread
  ///     when appropriate.  {@code false} means that this job has completed its work.
  bool onStartJob(jobparameters_.JobParameters params) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartJob,
          jni.JniType.booleanType, [params.reference]).boolean;

  static final _id_onStopJob = jniAccessors.getMethodIDOf(
      _classRef, "onStopJob", "(Landroid/app/job/JobParameters;)Z");

  /// from: public abstract boolean onStopJob(android.app.job.JobParameters params)
  ///
  /// This method is called if the system has determined that you must stop execution of your job
  /// even before you've had a chance to call \#jobFinished(JobParameters, boolean).
  ///
  /// This will happen if the requirements specified at schedule time are no longer met. For
  /// example you may have requested WiFi with
  /// android.app.job.JobInfo.Builder\#setRequiredNetworkType(int), yet while your
  /// job was executing the user toggled WiFi. Another example is if you had specified
  /// android.app.job.JobInfo.Builder\#setRequiresDeviceIdle(boolean), and the phone left its
  /// idle maintenance window. You are solely responsible for the behavior of your application
  /// upon receipt of this message; your app will likely start to misbehave if you ignore it.
  ///
  /// Once this method returns, the system releases the wakelock that it is holding on
  /// behalf of the job.
  ///
  ///@param params The parameters identifying this job, as supplied to
  ///               the job in the \#onStartJob(JobParameters) callback.
  ///@return {@code true} to indicate to the JobManager whether you'd like to reschedule
  /// this job based on the retry criteria provided at job creation-time; or {@code false}
  /// to end the job entirely.  Regardless of the value returned, your job must stop executing.
  bool onStopJob(jobparameters_.JobParameters params) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStopJob,
          jni.JniType.booleanType, [params.reference]).boolean;
}
