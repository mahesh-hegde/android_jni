// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Loader.dart" as loader_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.LoaderManager
///
/// Interface associated with an Activity or Fragment for managing
/// one or more android.content.Loader instances associated with it.  This
/// helps an application manage longer-running operations in conjunction with the
/// Activity or Fragment lifecycle; the most common use of this is with a
/// android.content.CursorLoader, however applications are free to write
/// their own loaders for loading other types of data.
///
/// While the LoaderManager API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///
/// As an example, here is the full implementation of a Fragment
/// that displays a android.widget.ListView containing the results of
/// a query against the contacts content provider.  It uses a
/// android.content.CursorLoader to manage the query on the provider.
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LoaderCursor.java
///      fragment_cursor}
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using loaders, read the
/// <a href="{@docRoot}guide/topics/fundamentals/loaders.html">Loaders</a> developer guide.
///
/// </div>
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.LoaderManager
class LoaderManager extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/LoaderManager");
  LoaderManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LoaderManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_initLoader = jniAccessors.getMethodIDOf(
      _classRef,
      "initLoader",
      "(ILandroid/os/Bundle;Landroid/app/LoaderManager\$LoaderCallbacks;)Landroid/content/Loader;");

  /// from: public abstract android.content.Loader<D> initLoader(int id, android.os.Bundle args, android.app.LoaderManager.LoaderCallbacks<D> callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Ensures a loader is initialized and active.  If the loader doesn't
  /// already exist, one is created and (if the activity/fragment is currently
  /// started) starts the loader.  Otherwise the last created
  /// loader is re-used.
  ///
  /// In either case, the given callback is associated with the loader, and
  /// will be called as the loader state changes.  If at the point of call
  /// the caller is in its started state, and the requested loader
  /// already exists and has generated its data, then
  /// callback LoaderCallbacks\#onLoadFinished will
  /// be called immediately (inside of this function), so you must be prepared
  /// for this to happen.
  ///@param id A unique identifier for this loader.  Can be whatever you want.
  /// Identifiers are scoped to a particular LoaderManager instance.
  ///@param args Optional arguments to supply to the loader at construction.
  /// If a loader already exists (a new one does not need to be created), this
  /// parameter will be ignored and the last arguments continue to be used.
  ///@param callback Interface the LoaderManager will call to report about
  /// changes in the state of the loader.  Required.
  loader_.Loader initLoader(int id, bundle_.Bundle args,
          LoaderManager_LoaderCallbacks callback) =>
      loader_.Loader.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_initLoader,
          jni.JniType.objectType,
          [id, args.reference, callback.reference]).object);

  static final _id_restartLoader = jniAccessors.getMethodIDOf(
      _classRef,
      "restartLoader",
      "(ILandroid/os/Bundle;Landroid/app/LoaderManager\$LoaderCallbacks;)Landroid/content/Loader;");

  /// from: public abstract android.content.Loader<D> restartLoader(int id, android.os.Bundle args, android.app.LoaderManager.LoaderCallbacks<D> callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Starts a new or restarts an existing android.content.Loader in
  /// this manager, registers the callbacks to it,
  /// and (if the activity/fragment is currently started) starts loading it.
  /// If a loader with the same id has previously been
  /// started it will automatically be destroyed when the new loader completes
  /// its work. The callback will be delivered before the old loader
  /// is destroyed.
  ///@param id A unique identifier for this loader.  Can be whatever you want.
  /// Identifiers are scoped to a particular LoaderManager instance.
  ///@param args Optional arguments to supply to the loader at construction.
  ///@param callback Interface the LoaderManager will call to report about
  /// changes in the state of the loader.  Required.
  loader_.Loader restartLoader(int id, bundle_.Bundle args,
          LoaderManager_LoaderCallbacks callback) =>
      loader_.Loader.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_restartLoader,
          jni.JniType.objectType,
          [id, args.reference, callback.reference]).object);

  static final _id_destroyLoader =
      jniAccessors.getMethodIDOf(_classRef, "destroyLoader", "(I)V");

  /// from: public abstract void destroyLoader(int id)
  ///
  /// Stops and removes the loader with the given ID.  If this loader
  /// had previously reported data to the client through
  /// LoaderCallbacks\#onLoadFinished(Loader, Object), a call
  /// will be made to LoaderCallbacks\#onLoaderReset(Loader).
  void destroyLoader(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_destroyLoader, jni.JniType.voidType, [id]).check();

  static final _id_getLoader = jniAccessors.getMethodIDOf(
      _classRef, "getLoader", "(I)Landroid/content/Loader;");

  /// from: public abstract android.content.Loader<D> getLoader(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Loader with the given id or null if no matching Loader
  /// is found.
  loader_.Loader getLoader(int id) =>
      loader_.Loader.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLoader, jni.JniType.objectType, [id]).object);

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public abstract void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the LoaderManager's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer A PrintWriter to which the dump is to be set.
  ///@param args Additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();

  static final _id_enableDebugLogging =
      jniAccessors.getStaticMethodIDOf(_classRef, "enableDebugLogging", "(Z)V");

  /// from: static public void enableDebugLogging(boolean enabled)
  ///
  /// Control whether the framework's internal loader manager debugging
  /// logs are turned on.  If enabled, you will see output in logcat as
  /// the framework performs loader operations.
  static void enableDebugLogging(bool enabled) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_enableDebugLogging,
          jni.JniType.voidType, [enabled]).check();
}

/// from: android.app.LoaderManager$LoaderCallbacks
///
/// Callback interface for a client to interact with the manager.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a> android.support.v4.app.LoaderManager.LoaderCallbacks
class LoaderManager_LoaderCallbacks extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/LoaderManager\$LoaderCallbacks");
  LoaderManager_LoaderCallbacks.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onCreateLoader = jniAccessors.getMethodIDOf(_classRef,
      "onCreateLoader", "(ILandroid/os/Bundle;)Landroid/content/Loader;");

  /// from: public abstract android.content.Loader<D> onCreateLoader(int id, android.os.Bundle args)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiate and return a new Loader for the given ID.
  ///@param id The ID whose loader is to be created.
  ///@param args Any arguments supplied by the caller.
  ///@return Return a new Loader instance that is ready to start loading.
  loader_.Loader onCreateLoader(int id, bundle_.Bundle args) =>
      loader_.Loader.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateLoader,
          jni.JniType.objectType,
          [id, args.reference]).object);

  static final _id_onLoaderReset = jniAccessors.getMethodIDOf(
      _classRef, "onLoaderReset", "(Landroid/content/Loader;)V");

  /// from: public abstract void onLoaderReset(android.content.Loader<D> loader)
  ///
  /// Called when a previously created loader is being reset, and thus
  /// making its data unavailable.  The application should at this point
  /// remove any references it has to the Loader's data.
  ///@param loader The Loader that is being reset.
  void onLoaderReset(loader_.Loader loader) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onLoaderReset,
      jni.JniType.voidType,
      [loader.reference]).check();
}
