// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../content/ComponentName.dart" as componentname_;

import "../../os/Parcel.dart" as parcel_;

import "../../view/autofill/AutofillId.dart" as autofillid_;

import "../../view/autofill/AutofillValue.dart" as autofillvalue_;

import "../../graphics/Matrix.dart" as matrix_;

import "../../view/ViewStructure.dart" as viewstructure_;

import "../../os/LocaleList.dart" as localelist_;

import "../../os/Bundle.dart" as bundle_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.assist.AssistStructure
///
/// Assist data automatically created by the platform's implementation of assist and autofill.
///
/// The structure is used for assist purposes when created by
/// android.app.Activity\#onProvideAssistData, View\#onProvideStructure(ViewStructure),
/// or View\#onProvideVirtualStructure(ViewStructure).
///
/// The structure is used for autofill purposes when created by
/// View\#onProvideAutofillStructure(ViewStructure, int),
/// or View\#onProvideAutofillVirtualStructure(ViewStructure, int).
///
/// For performance reasons, some properties of the assist data might be available just for assist
/// or autofill purposes; in those case, the property availability will be document in its javadoc.
class AssistStructure extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/assist/AssistStructure");
  AssistStructure.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.assist.AssistStructure> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AssistStructure()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getAcquisitionStartTime =
      jniAccessors.getMethodIDOf(_classRef, "getAcquisitionStartTime", "()J");

  /// from: public long getAcquisitionStartTime()
  ///
  /// Returns the time when the activity started generating assist data to build the
  /// AssistStructure. The time is as specified by SystemClock\#uptimeMillis().
  ///@see \#getAcquisitionEndTime()
  ///@return Returns the acquisition start time of the assist data, in milliseconds.
  int getAcquisitionStartTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getAcquisitionStartTime, jni.JniType.longType, []).long;

  static final _id_getAcquisitionEndTime =
      jniAccessors.getMethodIDOf(_classRef, "getAcquisitionEndTime", "()J");

  /// from: public long getAcquisitionEndTime()
  ///
  /// Returns the time when the activity finished generating assist data to build the
  /// AssistStructure. The time is as specified by SystemClock\#uptimeMillis().
  ///@see \#getAcquisitionStartTime()
  ///@return Returns the acquisition end time of the assist data, in milliseconds.
  int getAcquisitionEndTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getAcquisitionEndTime, jni.JniType.longType, []).long;

  static final _id_getActivityComponent = jniAccessors.getMethodIDOf(
      _classRef, "getActivityComponent", "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getActivityComponent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the activity this AssistStructure came from.
  componentname_.ComponentName getActivityComponent() =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityComponent,
          jni.JniType.objectType, []).object);

  static final _id_isHomeActivity =
      jniAccessors.getMethodIDOf(_classRef, "isHomeActivity", "()Z");

  /// from: public boolean isHomeActivity()
  ///
  /// Returns whether the activity associated with this AssistStructure was the home activity
  /// (Launcher) at the time the assist data was acquired.
  ///@return Whether the activity was the home activity.
  ///@see android.content.Intent\#CATEGORY_HOME
  bool isHomeActivity() => jniAccessors.callMethodWithArgs(
      reference, _id_isHomeActivity, jni.JniType.booleanType, []).boolean;

  static final _id_getWindowNodeCount =
      jniAccessors.getMethodIDOf(_classRef, "getWindowNodeCount", "()I");

  /// from: public int getWindowNodeCount()
  ///
  /// Return the number of window contents that have been collected in this assist data.
  int getWindowNodeCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getWindowNodeCount, jni.JniType.intType, []).integer;

  static final _id_getWindowNodeAt = jniAccessors.getMethodIDOf(_classRef,
      "getWindowNodeAt", "(I)Landroid/app/assist/AssistStructure\$WindowNode;");

  /// from: public android.app.assist.AssistStructure.WindowNode getWindowNodeAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return one of the windows in the assist data.
  ///@param index Which window to retrieve, may be 0 to \#getWindowNodeCount()-1.
  AssistStructure_WindowNode getWindowNodeAt(int index) =>
      AssistStructure_WindowNode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getWindowNodeAt,
          jni.JniType.objectType,
          [index]).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();
}

/// from: android.app.assist.AssistStructure$WindowNode
///
/// Describes a window in the assist data.
class AssistStructure_WindowNode extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/assist/AssistStructure\$WindowNode");
  AssistStructure_WindowNode.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AssistStructure_WindowNode()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getLeft =
      jniAccessors.getMethodIDOf(_classRef, "getLeft", "()I");

  /// from: public int getLeft()
  ///
  /// Returns the left edge of the window, in pixels, relative to the left
  /// edge of the screen.
  int getLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getLeft, jni.JniType.intType, []).integer;

  static final _id_getTop =
      jniAccessors.getMethodIDOf(_classRef, "getTop", "()I");

  /// from: public int getTop()
  ///
  /// Returns the top edge of the window, in pixels, relative to the top
  /// edge of the screen.
  int getTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getTop, jni.JniType.intType, []).integer;

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Returns the total width of the window in pixels.
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Returns the total height of the window in pixels.
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the title associated with the window, if it has one.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_getDisplayId =
      jniAccessors.getMethodIDOf(_classRef, "getDisplayId", "()I");

  /// from: public int getDisplayId()
  ///
  /// Returns the ID of the display this window is on, for use with
  /// android.hardware.display.DisplayManager\#getDisplay DisplayManager.getDisplay().
  int getDisplayId() => jniAccessors.callMethodWithArgs(
      reference, _id_getDisplayId, jni.JniType.intType, []).integer;

  static final _id_getRootViewNode = jniAccessors.getMethodIDOf(_classRef,
      "getRootViewNode", "()Landroid/app/assist/AssistStructure\$ViewNode;");

  /// from: public android.app.assist.AssistStructure.ViewNode getRootViewNode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ViewNode containing the root content of the window.
  AssistStructure_ViewNode getRootViewNode() =>
      AssistStructure_ViewNode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRootViewNode, jni.JniType.objectType, []).object);
}

/// from: android.app.assist.AssistStructure$ViewNode
///
/// Describes a single view in the assist data.
class AssistStructure_ViewNode extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/assist/AssistStructure\$ViewNode");
  AssistStructure_ViewNode.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int TEXT_COLOR_UNDEFINED
  ///
  /// Magic value for text color that has not been defined, which is very unlikely
  /// to be confused with a real text color.
  static const TEXT_COLOR_UNDEFINED = 1;

  /// from: static public final int TEXT_STYLE_BOLD
  static const TEXT_STYLE_BOLD = 1;

  /// from: static public final int TEXT_STYLE_ITALIC
  static const TEXT_STYLE_ITALIC = 2;

  /// from: static public final int TEXT_STYLE_STRIKE_THRU
  static const TEXT_STYLE_STRIKE_THRU = 8;

  /// from: static public final int TEXT_STYLE_UNDERLINE
  static const TEXT_STYLE_UNDERLINE = 4;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AssistStructure_ViewNode()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// Returns the ID associated with this view, as per View\#getId() View.getId().
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getIdPackage = jniAccessors.getMethodIDOf(
      _classRef, "getIdPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getIdPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If \#getId() is a resource identifier, this is the package name of that
  /// identifier.  See android.view.ViewStructure\#setId ViewStructure.setId
  /// for more information.
  jni.JniString getIdPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIdPackage, jni.JniType.objectType, []).object);

  static final _id_getIdType = jniAccessors.getMethodIDOf(
      _classRef, "getIdType", "()Ljava/lang/String;");

  /// from: public java.lang.String getIdType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If \#getId() is a resource identifier, this is the type name of that
  /// identifier.  See android.view.ViewStructure\#setId ViewStructure.setId
  /// for more information.
  jni.JniString getIdType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIdType, jni.JniType.objectType, []).object);

  static final _id_getIdEntry = jniAccessors.getMethodIDOf(
      _classRef, "getIdEntry", "()Ljava/lang/String;");

  /// from: public java.lang.String getIdEntry()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If \#getId() is a resource identifier, this is the entry name of that
  /// identifier.  See android.view.ViewStructure\#setId ViewStructure.setId
  /// for more information.
  jni.JniString getIdEntry() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIdEntry, jni.JniType.objectType, []).object);

  static final _id_getAutofillId = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillId", "()Landroid/view/autofill/AutofillId;");

  /// from: public android.view.autofill.AutofillId getAutofillId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the id that can be used to autofill the view contents.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes.
  ///@return id that can be used to autofill the view contents, or {@code null} if the
  /// structure was created for assist purposes.
  autofillid_.AutofillId getAutofillId() =>
      autofillid_.AutofillId.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillId, jni.JniType.objectType, []).object);

  static final _id_getAutofillType =
      jniAccessors.getMethodIDOf(_classRef, "getAutofillType", "()I");

  /// from: public int getAutofillType()
  ///
  /// Gets the the type of value that can be used to autofill the view contents.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes.
  ///@return autofill type as defined by View\#getAutofillType(),
  /// or View\#AUTOFILL_TYPE_NONE if the structure was created for assist purposes.
  ///
  /// Value is android.view.View\#AUTOFILL_TYPE_NONE, android.view.View\#AUTOFILL_TYPE_TEXT, android.view.View\#AUTOFILL_TYPE_TOGGLE, android.view.View\#AUTOFILL_TYPE_LIST, or android.view.View\#AUTOFILL_TYPE_DATE
  int getAutofillType() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutofillType, jni.JniType.intType, []).integer;

  static final _id_getAutofillHints = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillHints", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getAutofillHints()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Describes the content of a view so that a autofill service can fill in the appropriate
  /// data.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes,
  /// not for Assist - see View\#getAutofillHints() for more info.
  ///@return The autofill hints for this view, or {@code null} if the structure was created
  /// for assist purposes.
  jni.JniObject getAutofillHints() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillHints, jni.JniType.objectType, []).object);

  static final _id_getAutofillValue = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillValue", "()Landroid/view/autofill/AutofillValue;");

  /// from: public android.view.autofill.AutofillValue getAutofillValue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the the value of this view.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes,
  /// not for assist purposes.
  ///@return the autofill value of this view, or {@code null} if the structure was created
  /// for assist purposes.
  autofillvalue_.AutofillValue getAutofillValue() =>
      autofillvalue_.AutofillValue.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAutofillValue, jni.JniType.objectType, []).object);

  static final _id_getAutofillOptions = jniAccessors.getMethodIDOf(
      _classRef, "getAutofillOptions", "()[Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence[] getAutofillOptions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the options that can be used to autofill this view.
  ///
  /// Typically used by nodes whose View\#getAutofillType() is a list to indicate
  /// the meaning of each possible value in the list.
  ///
  /// It's relevant when the AssistStructure is used for autofill purposes, not
  /// for assist purposes.
  ///@return the options that can be used to autofill this view, or {@code null} if the
  /// structure was created for assist purposes.
  jni.JniObject getAutofillOptions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAutofillOptions, jni.JniType.objectType, []).object);

  static final _id_getInputType =
      jniAccessors.getMethodIDOf(_classRef, "getInputType", "()I");

  /// from: public int getInputType()
  ///
  /// Gets the android.text.InputType bits of this structure.
  ///@return bits as defined by android.text.InputType.
  int getInputType() => jniAccessors.callMethodWithArgs(
      reference, _id_getInputType, jni.JniType.intType, []).integer;

  static final _id_getLeft =
      jniAccessors.getMethodIDOf(_classRef, "getLeft", "()I");

  /// from: public int getLeft()
  ///
  /// Returns the left edge of this view, in pixels, relative to the left edge of its parent.
  int getLeft() => jniAccessors.callMethodWithArgs(
      reference, _id_getLeft, jni.JniType.intType, []).integer;

  static final _id_getTop =
      jniAccessors.getMethodIDOf(_classRef, "getTop", "()I");

  /// from: public int getTop()
  ///
  /// Returns the top edge of this view, in pixels, relative to the top edge of its parent.
  int getTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getTop, jni.JniType.intType, []).integer;

  static final _id_getScrollX =
      jniAccessors.getMethodIDOf(_classRef, "getScrollX", "()I");

  /// from: public int getScrollX()
  ///
  /// Returns the current X scroll offset of this view, as per
  /// android.view.View\#getScrollX() View.getScrollX().
  int getScrollX() => jniAccessors.callMethodWithArgs(
      reference, _id_getScrollX, jni.JniType.intType, []).integer;

  static final _id_getScrollY =
      jniAccessors.getMethodIDOf(_classRef, "getScrollY", "()I");

  /// from: public int getScrollY()
  ///
  /// Returns the current Y scroll offset of this view, as per
  /// android.view.View\#getScrollX() View.getScrollY().
  int getScrollY() => jniAccessors.callMethodWithArgs(
      reference, _id_getScrollY, jni.JniType.intType, []).integer;

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public int getWidth()
  ///
  /// Returns the width of this view, in pixels.
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Returns the height of this view, in pixels.
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getTransformation = jniAccessors.getMethodIDOf(
      _classRef, "getTransformation", "()Landroid/graphics/Matrix;");

  /// from: public android.graphics.Matrix getTransformation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the transformation that has been applied to this view, such as a translation
  /// or scaling.  The returned Matrix object is owned by ViewNode; do not modify it.
  /// Returns null if there is no transformation applied to the view.
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  matrix_.Matrix getTransformation() =>
      matrix_.Matrix.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTransformation, jni.JniType.objectType, []).object);

  static final _id_getElevation =
      jniAccessors.getMethodIDOf(_classRef, "getElevation", "()F");

  /// from: public float getElevation()
  ///
  /// Returns the visual elevation of the view, used for shadowing and other visual
  /// characterstics, as set by ViewStructure\#setElevation ViewStructure.setElevation(float).
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  double getElevation() => jniAccessors.callMethodWithArgs(
      reference, _id_getElevation, jni.JniType.floatType, []).float;

  static final _id_getAlpha =
      jniAccessors.getMethodIDOf(_classRef, "getAlpha", "()F");

  /// from: public float getAlpha()
  ///
  /// Returns the alpha transformation of the view, used to reduce the overall opacity
  /// of the view's contents, as set by ViewStructure\#setAlpha ViewStructure.setAlpha(float).
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  double getAlpha() => jniAccessors.callMethodWithArgs(
      reference, _id_getAlpha, jni.JniType.floatType, []).float;

  static final _id_getVisibility =
      jniAccessors.getMethodIDOf(_classRef, "getVisibility", "()I");

  /// from: public int getVisibility()
  ///
  /// Returns the visibility mode of this view, as per
  /// android.view.View\#getVisibility() View.getVisibility().
  int getVisibility() => jniAccessors.callMethodWithArgs(
      reference, _id_getVisibility, jni.JniType.intType, []).integer;

  static final _id_isAssistBlocked =
      jniAccessors.getMethodIDOf(_classRef, "isAssistBlocked", "()Z");

  /// from: public boolean isAssistBlocked()
  ///
  /// Returns true if assist data has been blocked starting at this node in the hierarchy.
  bool isAssistBlocked() => jniAccessors.callMethodWithArgs(
      reference, _id_isAssistBlocked, jni.JniType.booleanType, []).boolean;

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Returns true if this node is in an enabled state.
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_isClickable =
      jniAccessors.getMethodIDOf(_classRef, "isClickable", "()Z");

  /// from: public boolean isClickable()
  ///
  /// Returns true if this node is clickable by the user.
  bool isClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isClickable, jni.JniType.booleanType, []).boolean;

  static final _id_isFocusable =
      jniAccessors.getMethodIDOf(_classRef, "isFocusable", "()Z");

  /// from: public boolean isFocusable()
  ///
  /// Returns true if this node can take input focus.
  bool isFocusable() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocusable, jni.JniType.booleanType, []).boolean;

  static final _id_isFocused =
      jniAccessors.getMethodIDOf(_classRef, "isFocused", "()Z");

  /// from: public boolean isFocused()
  ///
  /// Returns true if this node currently had input focus at the time that the
  /// structure was collected.
  bool isFocused() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocused, jni.JniType.booleanType, []).boolean;

  static final _id_isAccessibilityFocused =
      jniAccessors.getMethodIDOf(_classRef, "isAccessibilityFocused", "()Z");

  /// from: public boolean isAccessibilityFocused()
  ///
  /// Returns true if this node currently had accessibility focus at the time that the
  /// structure was collected.
  bool isAccessibilityFocused() => jniAccessors.callMethodWithArgs(reference,
      _id_isAccessibilityFocused, jni.JniType.booleanType, []).boolean;

  static final _id_isCheckable =
      jniAccessors.getMethodIDOf(_classRef, "isCheckable", "()Z");

  /// from: public boolean isCheckable()
  ///
  /// Returns true if this node represents something that is checkable by the user.
  bool isCheckable() => jniAccessors.callMethodWithArgs(
      reference, _id_isCheckable, jni.JniType.booleanType, []).boolean;

  static final _id_isChecked =
      jniAccessors.getMethodIDOf(_classRef, "isChecked", "()Z");

  /// from: public boolean isChecked()
  ///
  /// Returns true if this node is currently in a checked state.
  bool isChecked() => jniAccessors.callMethodWithArgs(
      reference, _id_isChecked, jni.JniType.booleanType, []).boolean;

  static final _id_isSelected =
      jniAccessors.getMethodIDOf(_classRef, "isSelected", "()Z");

  /// from: public boolean isSelected()
  ///
  /// Returns true if this node has currently been selected by the user.
  bool isSelected() => jniAccessors.callMethodWithArgs(
      reference, _id_isSelected, jni.JniType.booleanType, []).boolean;

  static final _id_isActivated =
      jniAccessors.getMethodIDOf(_classRef, "isActivated", "()Z");

  /// from: public boolean isActivated()
  ///
  /// Returns true if this node has currently been activated by the user.
  bool isActivated() => jniAccessors.callMethodWithArgs(
      reference, _id_isActivated, jni.JniType.booleanType, []).boolean;

  static final _id_isOpaque =
      jniAccessors.getMethodIDOf(_classRef, "isOpaque", "()Z");

  /// from: public boolean isOpaque()
  ///
  /// Returns true if this node is opaque.
  bool isOpaque() => jniAccessors.callMethodWithArgs(
      reference, _id_isOpaque, jni.JniType.booleanType, []).boolean;

  static final _id_isLongClickable =
      jniAccessors.getMethodIDOf(_classRef, "isLongClickable", "()Z");

  /// from: public boolean isLongClickable()
  ///
  /// Returns true if this node is something the user can perform a long click/press on.
  bool isLongClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isLongClickable, jni.JniType.booleanType, []).boolean;

  static final _id_isContextClickable =
      jniAccessors.getMethodIDOf(_classRef, "isContextClickable", "()Z");

  /// from: public boolean isContextClickable()
  ///
  /// Returns true if this node is something the user can perform a context click on.
  bool isContextClickable() => jniAccessors.callMethodWithArgs(
      reference, _id_isContextClickable, jni.JniType.booleanType, []).boolean;

  static final _id_getClassName = jniAccessors.getMethodIDOf(
      _classRef, "getClassName", "()Ljava/lang/String;");

  /// from: public java.lang.String getClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the class name of the node's implementation, indicating its behavior.
  /// For example, a button will report "android.widget.Button" meaning it behaves
  /// like a android.widget.Button.
  jni.JniString getClassName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClassName, jni.JniType.objectType, []).object);

  static final _id_getContentDescription = jniAccessors.getMethodIDOf(
      _classRef, "getContentDescription", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getContentDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns any content description associated with the node, which semantically describes
  /// its purpose for accessibility and other uses.
  jni.JniObject getContentDescription() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getContentDescription, jni.JniType.objectType, []).object);

  static final _id_getWebDomain = jniAccessors.getMethodIDOf(
      _classRef, "getWebDomain", "()Ljava/lang/String;");

  /// from: public java.lang.String getWebDomain()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the domain of the HTML document represented by this view.
  ///
  /// Typically used when the view associated with the view is a container for an HTML
  /// document.
  ///
  /// __Warning:__ an autofill service cannot trust the value reported by this method
  /// without verifing its authenticity&mdash;see the "Web security" section of
  /// android.service.autofill.AutofillService for more details.
  ///@return domain-only part of the document. For example, if the full URL is
  /// {@code https://example.com/login?user=my_user}, it returns {@code example.com}.
  ///
  /// This value may be {@code null}.
  jni.JniString getWebDomain() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWebDomain, jni.JniType.objectType, []).object);

  static final _id_getWebScheme = jniAccessors.getMethodIDOf(
      _classRef, "getWebScheme", "()Ljava/lang/String;");

  /// from: public java.lang.String getWebScheme()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the scheme of the HTML document represented by this view.
  ///
  /// Typically used when the view associated with the view is a container for an HTML
  /// document.
  ///@return scheme-only part of the document. For example, if the full URL is
  /// {@code https://example.com/login?user=my_user}, it returns {@code https}.
  ///
  /// This value may be {@code null}.
  jni.JniString getWebScheme() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWebScheme, jni.JniType.objectType, []).object);

  static final _id_getHtmlInfo = jniAccessors.getMethodIDOf(
      _classRef, "getHtmlInfo", "()Landroid/view/ViewStructure\$HtmlInfo;");

  /// from: public android.view.ViewStructure.HtmlInfo getHtmlInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the HTML properties associated with this view.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes,
  /// not for assist purposes.
  ///@return the HTML properties associated with this view, or {@code null} if the
  /// structure was created for assist purposes.
  viewstructure_.ViewStructure_HtmlInfo getHtmlInfo() =>
      viewstructure_.ViewStructure_HtmlInfo.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getHtmlInfo, jni.JniType.objectType, []).object);

  static final _id_getLocaleList = jniAccessors.getMethodIDOf(
      _classRef, "getLocaleList", "()Landroid/os/LocaleList;");

  /// from: public android.os.LocaleList getLocaleList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the the list of locales associated with this view.
  ///@return This value may be {@code null}.
  localelist_.LocaleList getLocaleList() =>
      localelist_.LocaleList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocaleList, jni.JniType.objectType, []).object);

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns any text associated with the node that is displayed to the user, or null
  /// if there is none.
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_getTextSelectionStart =
      jniAccessors.getMethodIDOf(_classRef, "getTextSelectionStart", "()I");

  /// from: public int getTextSelectionStart()
  ///
  /// If \#getText() is non-null, this is where the current selection starts.
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  int getTextSelectionStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSelectionStart, jni.JniType.intType, []).integer;

  static final _id_getTextSelectionEnd =
      jniAccessors.getMethodIDOf(_classRef, "getTextSelectionEnd", "()I");

  /// from: public int getTextSelectionEnd()
  ///
  /// If \#getText() is non-null, this is where the current selection starts.
  /// If there is no selection, returns the same value as \#getTextSelectionStart(),
  /// indicating the cursor position.
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  int getTextSelectionEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSelectionEnd, jni.JniType.intType, []).integer;

  static final _id_getTextColor =
      jniAccessors.getMethodIDOf(_classRef, "getTextColor", "()I");

  /// from: public int getTextColor()
  ///
  /// If \#getText() is non-null, this is the main text color associated with it.
  /// If there is no text color, \#TEXT_COLOR_UNDEFINED is returned.
  /// Note that the text may also contain style spans that modify the color of specific
  /// parts of the text.
  int getTextColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextColor, jni.JniType.intType, []).integer;

  static final _id_getTextBackgroundColor =
      jniAccessors.getMethodIDOf(_classRef, "getTextBackgroundColor", "()I");

  /// from: public int getTextBackgroundColor()
  ///
  /// If \#getText() is non-null, this is the main text background color associated
  /// with it.
  /// If there is no text background color, \#TEXT_COLOR_UNDEFINED is returned.
  /// Note that the text may also contain style spans that modify the color of specific
  /// parts of the text.
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  int getTextBackgroundColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextBackgroundColor, jni.JniType.intType, []).integer;

  static final _id_getTextSize =
      jniAccessors.getMethodIDOf(_classRef, "getTextSize", "()F");

  /// from: public float getTextSize()
  ///
  /// If \#getText() is non-null, this is the main text size (in pixels) associated
  /// with it.
  /// Note that the text may also contain style spans that modify the size of specific
  /// parts of the text.
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  double getTextSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextSize, jni.JniType.floatType, []).float;

  static final _id_getTextStyle =
      jniAccessors.getMethodIDOf(_classRef, "getTextStyle", "()I");

  /// from: public int getTextStyle()
  ///
  /// If \#getText() is non-null, this is the main text style associated
  /// with it, containing a bit mask of \#TEXT_STYLE_BOLD,
  /// \#TEXT_STYLE_BOLD, \#TEXT_STYLE_STRIKE_THRU, and/or
  /// \#TEXT_STYLE_UNDERLINE.
  /// Note that the text may also contain style spans that modify the style of specific
  /// parts of the text.
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  int getTextStyle() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextStyle, jni.JniType.intType, []).integer;

  static final _id_getTextLineCharOffsets =
      jniAccessors.getMethodIDOf(_classRef, "getTextLineCharOffsets", "()[I");

  /// from: public int[] getTextLineCharOffsets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return per-line offsets into the text returned by \#getText().  Each entry
  /// in the array is a formatted line of text, and the value it contains is the offset
  /// into the text string where that line starts.  May return null if there is no line
  /// information.
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  jni.JniObject getTextLineCharOffsets() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTextLineCharOffsets, jni.JniType.objectType, []).object);

  static final _id_getTextLineBaselines =
      jniAccessors.getMethodIDOf(_classRef, "getTextLineBaselines", "()[I");

  /// from: public int[] getTextLineBaselines()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return per-line baselines into the text returned by \#getText().  Each entry
  /// in the array is a formatted line of text, and the value it contains is the baseline
  /// where that text appears in the view.  May return null if there is no line
  /// information.
  ///
  /// It's only relevant when the AssistStructure is used for assist purposes,
  /// not for autofill purposes.
  jni.JniObject getTextLineBaselines() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTextLineBaselines, jni.JniType.objectType, []).object);

  static final _id_getTextIdEntry = jniAccessors.getMethodIDOf(
      _classRef, "getTextIdEntry", "()Ljava/lang/String;");

  /// from: public java.lang.String getTextIdEntry()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the identifier used to set the text associated with this view.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes,
  /// not for assist purposes.
  ///@return This value may be {@code null}.
  jni.JniString getTextIdEntry() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextIdEntry, jni.JniType.objectType, []).object);

  static final _id_getHint =
      jniAccessors.getMethodIDOf(_classRef, "getHint", "()Ljava/lang/String;");

  /// from: public java.lang.String getHint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return additional hint text associated with the node; this is typically used with
  /// a node that takes user input, describing to the user what the input means.
  jni.JniString getHint() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHint, jni.JniType.objectType, []).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a Bundle containing optional vendor-specific extension information.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_getChildCount =
      jniAccessors.getMethodIDOf(_classRef, "getChildCount", "()I");

  /// from: public int getChildCount()
  ///
  /// Return the number of children this node has.
  int getChildCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getChildCount, jni.JniType.intType, []).integer;

  static final _id_getChildAt = jniAccessors.getMethodIDOf(_classRef,
      "getChildAt", "(I)Landroid/app/assist/AssistStructure\$ViewNode;");

  /// from: public android.app.assist.AssistStructure.ViewNode getChildAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a child of this node, given an index value from 0 to
  /// \#getChildCount()-1.
  AssistStructure_ViewNode getChildAt(int index) =>
      AssistStructure_ViewNode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChildAt, jni.JniType.objectType, [index]).object);

  static final _id_getMinTextEms =
      jniAccessors.getMethodIDOf(_classRef, "getMinTextEms", "()I");

  /// from: public int getMinTextEms()
  ///
  /// Returns the minimum width in ems of the text associated with this node, or {@code -1}
  /// if not supported by the node.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes,
  /// not for assist purposes.
  int getMinTextEms() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinTextEms, jni.JniType.intType, []).integer;

  static final _id_getMaxTextEms =
      jniAccessors.getMethodIDOf(_classRef, "getMaxTextEms", "()I");

  /// from: public int getMaxTextEms()
  ///
  /// Returns the maximum width in ems of the text associated with this node, or {@code -1}
  /// if not supported by the node.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes,
  /// not for assist purposes.
  int getMaxTextEms() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxTextEms, jni.JniType.intType, []).integer;

  static final _id_getMaxTextLength =
      jniAccessors.getMethodIDOf(_classRef, "getMaxTextLength", "()I");

  /// from: public int getMaxTextLength()
  ///
  /// Returns the maximum length of the text associated with this node node, or {@code -1}
  /// if not supported by the node or not set.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes,
  /// not for assist purposes.
  int getMaxTextLength() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxTextLength, jni.JniType.intType, []).integer;

  static final _id_getImportantForAutofill =
      jniAccessors.getMethodIDOf(_classRef, "getImportantForAutofill", "()I");

  /// from: public int getImportantForAutofill()
  ///
  /// Gets the View\#setImportantForAutofill(int) importantForAutofill mode of
  /// the view associated with this node.
  ///
  /// It's only relevant when the AssistStructure is used for autofill purposes.
  ///@return Value is android.view.View\#IMPORTANT_FOR_AUTOFILL_AUTO, android.view.View\#IMPORTANT_FOR_AUTOFILL_YES, android.view.View\#IMPORTANT_FOR_AUTOFILL_NO, android.view.View\#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS, or android.view.View\#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
  int getImportantForAutofill() => jniAccessors.callMethodWithArgs(
      reference, _id_getImportantForAutofill, jni.JniType.intType, []).integer;
}
