// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Bundle.dart" as bundle_;

import "../content/Context.dart" as context_;

import "../content/ComponentName.dart" as componentname_;

import "Activity.dart" as activity_;

import "../content/Intent.dart" as intent_;

import "../content/IntentFilter.dart" as intentfilter_;

import "../view/KeyEvent.dart" as keyevent_;

import "../view/MotionEvent.dart" as motionevent_;

import "Application.dart" as application_;

import "../os/IBinder.dart" as ibinder_;

import "../content/pm/ActivityInfo.dart" as activityinfo_;

import "../os/PersistableBundle.dart" as persistablebundle_;

import "UiAutomation.dart" as uiautomation_;

import "../os/TestLooperManager.dart" as testloopermanager_;

import "../os/Looper.dart" as looper_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.Instrumentation
///
/// Base class for implementing application instrumentation code.  When running
/// with instrumentation turned on, this class will be instantiated for you
/// before any of the application code, allowing you to monitor all of the
/// interaction the system has with the application.  An Instrumentation
/// implementation is described to the system through an AndroidManifest.xml's
/// &lt;instrumentation&gt; tag.
class Instrumentation extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Instrumentation");
  Instrumentation.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String REPORT_KEY_IDENTIFIER
  ///
  /// If included in the status or final bundle sent to an IInstrumentationWatcher, this key
  /// identifies the class that is writing the report.  This can be used to provide more structured
  /// logging or reporting capabilities in the IInstrumentationWatcher.
  static const REPORT_KEY_IDENTIFIER = "id";

  /// from: static public final java.lang.String REPORT_KEY_STREAMRESULT
  ///
  /// If included in the status or final bundle sent to an IInstrumentationWatcher, this key
  /// identifies a string which can simply be printed to the output stream.  Using these streams
  /// provides a "pretty printer" version of the status & final packets.  Any bundles including
  /// this key should also include the complete set of raw key/value pairs, so that the
  /// instrumentation can also be launched, and results collected, by an automated system.
  static const REPORT_KEY_STREAMRESULT = "stream";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Instrumentation()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onCreate = jniAccessors.getMethodIDOf(
      _classRef, "onCreate", "(Landroid/os/Bundle;)V");

  /// from: public void onCreate(android.os.Bundle arguments)
  ///
  /// Called when the instrumentation is starting, before any application code
  /// has been loaded.  Usually this will be implemented to simply call
  /// \#start to begin the instrumentation thread, which will then
  /// continue execution in \#onStart.
  ///
  /// If you do not need your own thread -- that is you are writing your
  /// instrumentation to be completely asynchronous (returning to the event
  /// loop so that the application can run), you can simply begin your
  /// instrumentation here, for example call Context\#startActivity to
  /// begin the appropriate first activity of the application.
  ///@param arguments Any additional arguments that were supplied when the
  ///                  instrumentation was started.
  void onCreate(bundle_.Bundle arguments) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCreate,
      jni.JniType.voidType,
      [arguments.reference]).check();

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "()V");

  /// from: public void start()
  ///
  /// Create and start a new thread in which to run instrumentation.  This new
  /// thread will call to \#onStart where you can implement the
  /// instrumentation.
  void start() => jniAccessors.callMethodWithArgs(
      reference, _id_start, jni.JniType.voidType, []).check();

  static final _id_onStart =
      jniAccessors.getMethodIDOf(_classRef, "onStart", "()V");

  /// from: public void onStart()
  ///
  /// Method where the instrumentation thread enters execution.  This allows
  /// you to run your instrumentation code in a separate thread than the
  /// application, so that it can perform blocking operation such as
  /// \#sendKeySync or \#startActivitySync.
  ///
  /// You will typically want to call finish() when this function is done,
  /// to end your instrumentation.
  void onStart() => jniAccessors.callMethodWithArgs(
      reference, _id_onStart, jni.JniType.voidType, []).check();

  static final _id_onException = jniAccessors.getMethodIDOf(
      _classRef, "onException", "(Ljava/lang/Object;Ljava/lang/Throwable;)Z");

  /// from: public boolean onException(java.lang.Object obj, java.lang.Throwable e)
  ///
  /// This is called whenever the system captures an unhandled exception that
  /// was thrown by the application.  The default implementation simply
  /// returns false, allowing normal system handling of the exception to take
  /// place.
  ///@param obj The client object that generated the exception.  May be an
  ///            Application, Activity, BroadcastReceiver, Service, or null.
  ///@param e The exception that was thrown.
  ///@return To allow normal system exception process to occur, return false.
  ///         If true is returned, the system will proceed as if the exception
  ///         didn't happen.
  bool onException(jni.JniObject obj, jni.JniObject e) =>
      jniAccessors.callMethodWithArgs(reference, _id_onException,
          jni.JniType.booleanType, [obj.reference, e.reference]).boolean;

  static final _id_sendStatus = jniAccessors.getMethodIDOf(
      _classRef, "sendStatus", "(ILandroid/os/Bundle;)V");

  /// from: public void sendStatus(int resultCode, android.os.Bundle results)
  ///
  /// Provide a status report about the application.
  ///@param resultCode Current success/failure of instrumentation.
  ///@param results Any results to send back to the code that started the instrumentation.
  void sendStatus(int resultCode, bundle_.Bundle results) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendStatus,
          jni.JniType.voidType, [resultCode, results.reference]).check();

  static final _id_addResults = jniAccessors.getMethodIDOf(
      _classRef, "addResults", "(Landroid/os/Bundle;)V");

  /// from: public void addResults(android.os.Bundle results)
  ///
  /// Report some results in the middle of instrumentation execution.  Later results (including
  /// those provided by \#finish) will be combined with Bundle\#putAll.
  void addResults(bundle_.Bundle results) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addResults,
      jni.JniType.voidType,
      [results.reference]).check();

  static final _id_finish = jniAccessors.getMethodIDOf(
      _classRef, "finish", "(ILandroid/os/Bundle;)V");

  /// from: public void finish(int resultCode, android.os.Bundle results)
  ///
  /// Terminate instrumentation of the application.  This will cause the
  /// application process to exit, removing this instrumentation from the next
  /// time the application is started.  If multiple processes are currently running
  /// for this instrumentation, all of those processes will be killed.
  ///@param resultCode Overall success/failure of instrumentation.
  ///@param results Any results to send back to the code that started the
  ///                instrumentation.
  void finish(int resultCode, bundle_.Bundle results) =>
      jniAccessors.callMethodWithArgs(reference, _id_finish,
          jni.JniType.voidType, [resultCode, results.reference]).check();

  static final _id_setAutomaticPerformanceSnapshots = jniAccessors
      .getMethodIDOf(_classRef, "setAutomaticPerformanceSnapshots", "()V");

  /// from: public void setAutomaticPerformanceSnapshots()
  void setAutomaticPerformanceSnapshots() => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAutomaticPerformanceSnapshots,
      jni.JniType.voidType, []).check();

  static final _id_startPerformanceSnapshot =
      jniAccessors.getMethodIDOf(_classRef, "startPerformanceSnapshot", "()V");

  /// from: public void startPerformanceSnapshot()
  void startPerformanceSnapshot() => jniAccessors.callMethodWithArgs(reference,
      _id_startPerformanceSnapshot, jni.JniType.voidType, []).check();

  static final _id_endPerformanceSnapshot =
      jniAccessors.getMethodIDOf(_classRef, "endPerformanceSnapshot", "()V");

  /// from: public void endPerformanceSnapshot()
  void endPerformanceSnapshot() => jniAccessors.callMethodWithArgs(
      reference, _id_endPerformanceSnapshot, jni.JniType.voidType, []).check();

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  ///
  /// Called when the instrumented application is stopping, after all of the
  /// normal application cleanup has occurred.
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Context of this instrumentation's package.  Note that this is
  /// often different than the Context of the application being
  /// instrumentated, since the instrumentation code often lives is a
  /// different package than that of the application it is running against.
  /// See \#getTargetContext to retrieve a Context for the target
  /// application.
  ///@return The instrumentation's package context.
  ///@see \#getTargetContext
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getComponentName = jniAccessors.getMethodIDOf(
      _classRef, "getComponentName", "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getComponentName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns complete component name of this instrumentation.
  ///@return Returns the complete component name for this instrumentation.
  componentname_.ComponentName getComponentName() =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getComponentName, jni.JniType.objectType, []).object);

  static final _id_getTargetContext = jniAccessors.getMethodIDOf(
      _classRef, "getTargetContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getTargetContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a Context for the target application being instrumented.  Note
  /// that this is often different than the Context of the instrumentation
  /// code, since the instrumentation code often lives is a different package
  /// than that of the application it is running against. See
  /// \#getContext to retrieve a Context for the instrumentation code.
  ///@return A Context in the target application.
  ///@see \#getContext
  context_.Context getTargetContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTargetContext, jni.JniType.objectType, []).object);

  static final _id_getProcessName = jniAccessors.getMethodIDOf(
      _classRef, "getProcessName", "()Ljava/lang/String;");

  /// from: public java.lang.String getProcessName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the process this instrumentation is running in.  Note this should
  /// only be used for testing and debugging.  If you are thinking about using this to,
  /// for example, conditionalize what is initialized in an Application class, it is strongly
  /// recommended to instead use lazy initialization (such as a getter for the state that
  /// only creates it when requested).  This can greatly reduce the work your process does
  /// when created for secondary things, such as to receive a broadcast.
  jni.JniString getProcessName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getProcessName, jni.JniType.objectType, []).object);

  static final _id_isProfiling =
      jniAccessors.getMethodIDOf(_classRef, "isProfiling", "()Z");

  /// from: public boolean isProfiling()
  ///
  /// Check whether this instrumentation was started with profiling enabled.
  ///@return Returns true if profiling was enabled when starting, else false.
  bool isProfiling() => jniAccessors.callMethodWithArgs(
      reference, _id_isProfiling, jni.JniType.booleanType, []).boolean;

  static final _id_startProfiling =
      jniAccessors.getMethodIDOf(_classRef, "startProfiling", "()V");

  /// from: public void startProfiling()
  ///
  /// This method will start profiling if isProfiling() returns true. You should
  /// only call this method if you set the handleProfiling attribute in the
  /// manifest file for this Instrumentation to true.
  void startProfiling() => jniAccessors.callMethodWithArgs(
      reference, _id_startProfiling, jni.JniType.voidType, []).check();

  static final _id_stopProfiling =
      jniAccessors.getMethodIDOf(_classRef, "stopProfiling", "()V");

  /// from: public void stopProfiling()
  ///
  /// Stops profiling if isProfiling() returns true.
  void stopProfiling() => jniAccessors.callMethodWithArgs(
      reference, _id_stopProfiling, jni.JniType.voidType, []).check();

  static final _id_setInTouchMode =
      jniAccessors.getMethodIDOf(_classRef, "setInTouchMode", "(Z)V");

  /// from: public void setInTouchMode(boolean inTouch)
  ///
  /// Force the global system in or out of touch mode.  This can be used if
  /// your instrumentation relies on the UI being in one more or the other
  /// when it starts.
  ///@param inTouch Set to true to be in touch mode, false to be in
  /// focus mode.
  void setInTouchMode(bool inTouch) => jniAccessors.callMethodWithArgs(
      reference, _id_setInTouchMode, jni.JniType.voidType, [inTouch]).check();

  static final _id_waitForIdle = jniAccessors.getMethodIDOf(
      _classRef, "waitForIdle", "(Ljava/lang/Runnable;)V");

  /// from: public void waitForIdle(java.lang.Runnable recipient)
  ///
  /// Schedule a callback for when the application's main thread goes idle
  /// (has no more events to process).
  ///@param recipient Called the next time the thread's message queue is
  ///                  idle.
  void waitForIdle(jni.JniObject recipient) => jniAccessors.callMethodWithArgs(
      reference,
      _id_waitForIdle,
      jni.JniType.voidType,
      [recipient.reference]).check();

  static final _id_waitForIdleSync =
      jniAccessors.getMethodIDOf(_classRef, "waitForIdleSync", "()V");

  /// from: public void waitForIdleSync()
  ///
  /// Synchronously wait for the application to be idle.  Can not be called
  /// from the main application thread -- use \#start to execute
  /// instrumentation in its own thread.
  void waitForIdleSync() => jniAccessors.callMethodWithArgs(
      reference, _id_waitForIdleSync, jni.JniType.voidType, []).check();

  static final _id_runOnMainSync = jniAccessors.getMethodIDOf(
      _classRef, "runOnMainSync", "(Ljava/lang/Runnable;)V");

  /// from: public void runOnMainSync(java.lang.Runnable runner)
  ///
  /// Execute a call on the application's main thread, blocking until it is
  /// complete.  Useful for doing things that are not thread-safe, such as
  /// looking at or modifying the view hierarchy.
  ///@param runner The code to run on the main thread.
  void runOnMainSync(jni.JniObject runner) => jniAccessors.callMethodWithArgs(
      reference,
      _id_runOnMainSync,
      jni.JniType.voidType,
      [runner.reference]).check();

  static final _id_startActivitySync = jniAccessors.getMethodIDOf(_classRef,
      "startActivitySync", "(Landroid/content/Intent;)Landroid/app/Activity;");

  /// from: public android.app.Activity startActivitySync(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a new activity and wait for it to begin running before returning.
  /// In addition to being synchronous, this method as some semantic
  /// differences from the standard Context\#startActivity call: the
  /// activity component is resolved before talking with the activity manager
  /// (its class name is specified in the Intent that this method ultimately
  /// starts), and it does not allow you to start activities that run in a
  /// different process.  In addition, if the given Intent resolves to
  /// multiple activities, instead of displaying a dialog for the user to
  /// select an activity, an exception will be thrown.
  ///
  /// The function returns as soon as the activity goes idle following the
  /// call to its Activity\#onCreate.  Generally this means it has gone
  /// through the full initialization including Activity\#onResume and
  /// drawn and displayed its initial window.
  ///@param intent Description of the activity to start.
  ///@see Context\#startActivity
  ///@see \#startActivitySync(Intent, Bundle)
  activity_.Activity startActivitySync(intent_.Intent intent) =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivitySync,
          jni.JniType.objectType,
          [intent.reference]).object);

  static final _id_startActivitySync1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivitySync",
      "(Landroid/content/Intent;Landroid/os/Bundle;)Landroid/app/Activity;");

  /// from: public android.app.Activity startActivitySync(android.content.Intent intent, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a new activity and wait for it to begin running before returning.
  /// In addition to being synchronous, this method as some semantic
  /// differences from the standard Context\#startActivity call: the
  /// activity component is resolved before talking with the activity manager
  /// (its class name is specified in the Intent that this method ultimately
  /// starts), and it does not allow you to start activities that run in a
  /// different process.  In addition, if the given Intent resolves to
  /// multiple activities, instead of displaying a dialog for the user to
  /// select an activity, an exception will be thrown.
  ///
  /// The function returns as soon as the activity goes idle following the
  /// call to its Activity\#onCreate.  Generally this means it has gone
  /// through the full initialization including Activity\#onResume and
  /// drawn and displayed its initial window.
  ///@param intent Description of the activity to start.
  /// This value must never be {@code null}.
  ///@param options Additional options for how the Activity should be started.
  /// May be null if there are no options.  See android.app.ActivityOptions
  /// for how to build the Bundle supplied here; there are no supported definitions
  /// for building it manually.
  ///
  /// This value may be {@code null}.
  ///@see Context\#startActivity(Intent, Bundle)
  activity_.Activity startActivitySync1(
          intent_.Intent intent, bundle_.Bundle options) =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivitySync1,
          jni.JniType.objectType,
          [intent.reference, options.reference]).object);

  static final _id_addMonitor = jniAccessors.getMethodIDOf(_classRef,
      "addMonitor", "(Landroid/app/Instrumentation\$ActivityMonitor;)V");

  /// from: public void addMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  ///
  /// Add a new ActivityMonitor that will be checked whenever an
  /// activity is started.  The monitor is added
  /// after any existing ones; the monitor will be hit only if none of the
  /// existing monitors can themselves handle the Intent.
  ///@param monitor The new ActivityMonitor to see.
  ///@see \#addMonitor(IntentFilter, ActivityResult, boolean)
  ///@see \#checkMonitorHit
  void addMonitor(Instrumentation_ActivityMonitor monitor) =>
      jniAccessors.callMethodWithArgs(reference, _id_addMonitor,
          jni.JniType.voidType, [monitor.reference]).check();

  static final _id_addMonitor1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addMonitor",
      "(Landroid/content/IntentFilter;Landroid/app/Instrumentation\$ActivityResult;Z)Landroid/app/Instrumentation\$ActivityMonitor;");

  /// from: public android.app.Instrumentation.ActivityMonitor addMonitor(android.content.IntentFilter filter, android.app.Instrumentation.ActivityResult result, boolean block)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience wrapper for \#addMonitor(ActivityMonitor) that
  /// creates an intent filter matching ActivityMonitor for you and
  /// returns it.
  ///@param filter The set of intents this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@return The newly created and added activity monitor.
  ///@see \#addMonitor(ActivityMonitor)
  ///@see \#checkMonitorHit
  Instrumentation_ActivityMonitor addMonitor1(intentfilter_.IntentFilter filter,
          Instrumentation_ActivityResult result, bool block) =>
      Instrumentation_ActivityMonitor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addMonitor1,
          jni.JniType.objectType,
          [filter.reference, result.reference, block]).object);

  static final _id_addMonitor2 = jniAccessors.getMethodIDOf(
      _classRef,
      "addMonitor",
      "(Ljava/lang/String;Landroid/app/Instrumentation\$ActivityResult;Z)Landroid/app/Instrumentation\$ActivityMonitor;");

  /// from: public android.app.Instrumentation.ActivityMonitor addMonitor(java.lang.String cls, android.app.Instrumentation.ActivityResult result, boolean block)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience wrapper for \#addMonitor(ActivityMonitor) that
  /// creates a class matching ActivityMonitor for you and returns it.
  ///@param cls The activity class this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@return The newly created and added activity monitor.
  ///@see \#addMonitor(ActivityMonitor)
  ///@see \#checkMonitorHit
  Instrumentation_ActivityMonitor addMonitor2(jni.JniString cls,
          Instrumentation_ActivityResult result, bool block) =>
      Instrumentation_ActivityMonitor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addMonitor2,
          jni.JniType.objectType,
          [cls.reference, result.reference, block]).object);

  static final _id_checkMonitorHit = jniAccessors.getMethodIDOf(_classRef,
      "checkMonitorHit", "(Landroid/app/Instrumentation\$ActivityMonitor;I)Z");

  /// from: public boolean checkMonitorHit(android.app.Instrumentation.ActivityMonitor monitor, int minHits)
  ///
  /// Test whether an existing ActivityMonitor has been hit.  If the
  /// monitor has been hit at least <var>minHits</var> times, then it will be
  /// removed from the activity monitor list and true returned.  Otherwise it
  /// is left as-is and false is returned.
  ///@param monitor The ActivityMonitor to check.
  ///@param minHits The minimum number of hits required.
  ///@return True if the hit count has been reached, else false.
  ///@see \#addMonitor
  bool checkMonitorHit(Instrumentation_ActivityMonitor monitor, int minHits) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkMonitorHit,
          jni.JniType.booleanType, [monitor.reference, minHits]).boolean;

  static final _id_waitForMonitor = jniAccessors.getMethodIDOf(
      _classRef,
      "waitForMonitor",
      "(Landroid/app/Instrumentation\$ActivityMonitor;)Landroid/app/Activity;");

  /// from: public android.app.Activity waitForMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Wait for an existing ActivityMonitor to be hit.  Once the
  /// monitor has been hit, it is removed from the activity monitor list and
  /// the first created Activity object that matched it is returned.
  ///@param monitor The ActivityMonitor to wait for.
  ///@return The Activity object that matched the monitor.
  activity_.Activity waitForMonitor(Instrumentation_ActivityMonitor monitor) =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_waitForMonitor,
          jni.JniType.objectType,
          [monitor.reference]).object);

  static final _id_waitForMonitorWithTimeout = jniAccessors.getMethodIDOf(
      _classRef,
      "waitForMonitorWithTimeout",
      "(Landroid/app/Instrumentation\$ActivityMonitor;J)Landroid/app/Activity;");

  /// from: public android.app.Activity waitForMonitorWithTimeout(android.app.Instrumentation.ActivityMonitor monitor, long timeOut)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Wait for an existing ActivityMonitor to be hit till the timeout
  /// expires.  Once the monitor has been hit, it is removed from the activity
  /// monitor list and the first created Activity object that matched it is
  /// returned.  If the timeout expires, a null object is returned.
  ///@param monitor The ActivityMonitor to wait for.
  ///@param timeOut The timeout value in milliseconds.
  ///@return The Activity object that matched the monitor.
  activity_.Activity waitForMonitorWithTimeout(
          Instrumentation_ActivityMonitor monitor, int timeOut) =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_waitForMonitorWithTimeout,
          jni.JniType.objectType,
          [monitor.reference, timeOut]).object);

  static final _id_removeMonitor = jniAccessors.getMethodIDOf(_classRef,
      "removeMonitor", "(Landroid/app/Instrumentation\$ActivityMonitor;)V");

  /// from: public void removeMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  ///
  /// Remove an ActivityMonitor that was previously added with
  /// \#addMonitor.
  ///@param monitor The monitor to remove.
  ///@see \#addMonitor
  void removeMonitor(Instrumentation_ActivityMonitor monitor) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeMonitor,
          jni.JniType.voidType, [monitor.reference]).check();

  static final _id_invokeMenuActionSync = jniAccessors.getMethodIDOf(
      _classRef, "invokeMenuActionSync", "(Landroid/app/Activity;II)Z");

  /// from: public boolean invokeMenuActionSync(android.app.Activity targetActivity, int id, int flag)
  ///
  /// Execute a particular menu item.
  ///@param targetActivity The activity in question.
  ///@param id The identifier associated with the menu item.
  ///@param flag Additional flags, if any.
  ///@return Whether the invocation was successful (for example, it could be
  ///         false if item is disabled).
  bool invokeMenuActionSync(
          activity_.Activity targetActivity, int id, int flag) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_invokeMenuActionSync,
          jni.JniType.booleanType,
          [targetActivity.reference, id, flag]).boolean;

  static final _id_invokeContextMenuAction = jniAccessors.getMethodIDOf(
      _classRef, "invokeContextMenuAction", "(Landroid/app/Activity;II)Z");

  /// from: public boolean invokeContextMenuAction(android.app.Activity targetActivity, int id, int flag)
  ///
  /// Show the context menu for the currently focused view and executes a
  /// particular context menu item.
  ///@param targetActivity The activity in question.
  ///@param id The identifier associated with the context menu item.
  ///@param flag Additional flags, if any.
  ///@return Whether the invocation was successful (for example, it could be
  ///         false if item is disabled).
  bool invokeContextMenuAction(
          activity_.Activity targetActivity, int id, int flag) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_invokeContextMenuAction,
          jni.JniType.booleanType,
          [targetActivity.reference, id, flag]).boolean;

  static final _id_sendStringSync = jniAccessors.getMethodIDOf(
      _classRef, "sendStringSync", "(Ljava/lang/String;)V");

  /// from: public void sendStringSync(java.lang.String text)
  ///
  /// Sends the key events corresponding to the text to the app being
  /// instrumented.
  ///@param text The text to be sent.
  void sendStringSync(jni.JniString text) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendStringSync,
      jni.JniType.voidType,
      [text.reference]).check();

  static final _id_sendKeySync = jniAccessors.getMethodIDOf(
      _classRef, "sendKeySync", "(Landroid/view/KeyEvent;)V");

  /// from: public void sendKeySync(android.view.KeyEvent event)
  ///
  /// Send a key event to the currently focused window/view and wait for it to
  /// be processed.  Finished at some point after the recipient has returned
  /// from its event processing, though it may _not_ have completely
  /// finished reacting from the event -- for example, if it needs to update
  /// its display as a result, it may still be in the process of doing that.
  ///@param event The event to send to the current focus.
  void sendKeySync(keyevent_.KeyEvent event) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendKeySync,
      jni.JniType.voidType,
      [event.reference]).check();

  static final _id_sendKeyDownUpSync =
      jniAccessors.getMethodIDOf(_classRef, "sendKeyDownUpSync", "(I)V");

  /// from: public void sendKeyDownUpSync(int key)
  ///
  /// Sends an up and down key event sync to the currently focused window.
  ///@param key The integer keycode for the event.
  void sendKeyDownUpSync(int key) => jniAccessors.callMethodWithArgs(
      reference, _id_sendKeyDownUpSync, jni.JniType.voidType, [key]).check();

  static final _id_sendCharacterSync =
      jniAccessors.getMethodIDOf(_classRef, "sendCharacterSync", "(I)V");

  /// from: public void sendCharacterSync(int keyCode)
  ///
  /// Higher-level method for sending both the down and up key events for a
  /// particular character key code.  Equivalent to creating both KeyEvent
  /// objects by hand and calling \#sendKeySync.  The event appears
  /// as if it came from keyboard 0, the built in one.
  ///@param keyCode The key code of the character to send.
  void sendCharacterSync(int keyCode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendCharacterSync,
      jni.JniType.voidType,
      [keyCode]).check();

  static final _id_sendPointerSync = jniAccessors.getMethodIDOf(
      _classRef, "sendPointerSync", "(Landroid/view/MotionEvent;)V");

  /// from: public void sendPointerSync(android.view.MotionEvent event)
  ///
  /// Dispatch a pointer event. Finished at some point after the recipient has
  /// returned from its event processing, though it may _not_ have
  /// completely finished reacting from the event -- for example, if it needs
  /// to update its display as a result, it may still be in the process of
  /// doing that.
  ///@param event A motion event describing the pointer action.  (As noted in
  /// MotionEvent\#obtain(long, long, int, float, float, int), be sure to use
  /// SystemClock\#uptimeMillis() as the timebase.
  void sendPointerSync(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendPointerSync,
          jni.JniType.voidType, [event.reference]).check();

  static final _id_sendTrackballEventSync = jniAccessors.getMethodIDOf(
      _classRef, "sendTrackballEventSync", "(Landroid/view/MotionEvent;)V");

  /// from: public void sendTrackballEventSync(android.view.MotionEvent event)
  ///
  /// Dispatch a trackball event. Finished at some point after the recipient has
  /// returned from its event processing, though it may _not_ have
  /// completely finished reacting from the event -- for example, if it needs
  /// to update its display as a result, it may still be in the process of
  /// doing that.
  ///@param event A motion event describing the trackball action.  (As noted in
  /// MotionEvent\#obtain(long, long, int, float, float, int), be sure to use
  /// SystemClock\#uptimeMillis() as the timebase.
  void sendTrackballEventSync(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendTrackballEventSync,
          jni.JniType.voidType, [event.reference]).check();

  static final _id_newApplication = jniAccessors.getMethodIDOf(
      _classRef,
      "newApplication",
      "(Ljava/lang/ClassLoader;Ljava/lang/String;Landroid/content/Context;)Landroid/app/Application;");

  /// from: public android.app.Application newApplication(java.lang.ClassLoader cl, java.lang.String className, android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform instantiation of the process's Application object.  The
  /// default implementation provides the normal system behavior.
  ///@param cl The ClassLoader with which to instantiate the object.
  ///@param className The name of the class implementing the Application
  ///                  object.
  ///@param context The context to initialize the application with
  ///@return The newly instantiated Application object.
  application_.Application newApplication(jni.JniObject cl,
          jni.JniString className, context_.Context context) =>
      application_.Application.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_newApplication,
          jni.JniType.objectType,
          [cl.reference, className.reference, context.reference]).object);

  static final _id_newApplication1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newApplication",
      "(Ljava/lang/Class;Landroid/content/Context;)Landroid/app/Application;");

  /// from: static public android.app.Application newApplication(java.lang.Class<?> clazz, android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform instantiation of the process's Application object.  The
  /// default implementation provides the normal system behavior.
  ///@param clazz The class used to create an Application object from.
  ///@param context The context to initialize the application with
  ///@return The newly instantiated Application object.
  static application_.Application newApplication1(
          jni.JniObject clazz, context_.Context context) =>
      application_.Application.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newApplication1,
          jni.JniType.objectType,
          [clazz.reference, context.reference]).object);

  static final _id_callApplicationOnCreate = jniAccessors.getMethodIDOf(
      _classRef, "callApplicationOnCreate", "(Landroid/app/Application;)V");

  /// from: public void callApplicationOnCreate(android.app.Application app)
  ///
  /// Perform calling of the application's Application\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///
  /// Note: This method will be called immediately after \#onCreate(Bundle).
  /// Often instrumentation tests start their test thread in onCreate(); you
  /// need to be careful of races between these.  (Well between it and
  /// everything else, but let's start here.)
  ///@param app The application being created.
  void callApplicationOnCreate(application_.Application app) =>
      jniAccessors.callMethodWithArgs(reference, _id_callApplicationOnCreate,
          jni.JniType.voidType, [app.reference]).check();

  static final _id_newActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "newActivity",
      "(Ljava/lang/Class;Landroid/content/Context;Landroid/os/IBinder;Landroid/app/Application;Landroid/content/Intent;Landroid/content/pm/ActivityInfo;Ljava/lang/CharSequence;Landroid/app/Activity;Ljava/lang/String;Ljava/lang/Object;)Landroid/app/Activity;");

  /// from: public android.app.Activity newActivity(java.lang.Class<?> clazz, android.content.Context context, android.os.IBinder token, android.app.Application application, android.content.Intent intent, android.content.pm.ActivityInfo info, java.lang.CharSequence title, android.app.Activity parent, java.lang.String id, java.lang.Object lastNonConfigurationInstance)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform instantiation of an Activity object.  This method is intended for use with
  /// unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
  /// locally but will be missing some of the linkages necessary for use within the system.
  ///@param clazz The Class of the desired Activity
  ///@param context The base context for the activity to use
  ///@param token The token for this activity to communicate with
  ///@param application The application object (if any)
  ///@param intent The intent that started this Activity
  ///@param info ActivityInfo from the manifest
  ///@param title The title, typically retrieved from the ActivityInfo record
  ///@param parent The parent Activity (if any)
  ///@param id The embedded Id (if any)
  ///@param lastNonConfigurationInstance Arbitrary object that will be
  /// available via Activity\#getLastNonConfigurationInstance() Activity.getLastNonConfigurationInstance().
  ///@return Returns the instantiated activity
  ///@throws InstantiationException
  ///@throws IllegalAccessException
  activity_.Activity newActivity(
          jni.JniObject clazz,
          context_.Context context,
          ibinder_.IBinder token,
          application_.Application application,
          intent_.Intent intent,
          activityinfo_.ActivityInfo info,
          jni.JniObject title,
          activity_.Activity parent,
          jni.JniString id,
          jni.JniObject lastNonConfigurationInstance) =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_newActivity, jni.JniType.objectType, [
        clazz.reference,
        context.reference,
        token.reference,
        application.reference,
        intent.reference,
        info.reference,
        title.reference,
        parent.reference,
        id.reference,
        lastNonConfigurationInstance.reference
      ]).object);

  static final _id_newActivity1 = jniAccessors.getMethodIDOf(
      _classRef,
      "newActivity",
      "(Ljava/lang/ClassLoader;Ljava/lang/String;Landroid/content/Intent;)Landroid/app/Activity;");

  /// from: public android.app.Activity newActivity(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform instantiation of the process's Activity object.  The
  /// default implementation provides the normal system behavior.
  ///@param cl The ClassLoader with which to instantiate the object.
  ///@param className The name of the class implementing the Activity
  ///                  object.
  ///@param intent The Intent object that specified the activity class being
  ///               instantiated.
  ///@return The newly instantiated Activity object.
  activity_.Activity newActivity1(
          jni.JniObject cl, jni.JniString className, intent_.Intent intent) =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_newActivity1,
          jni.JniType.objectType,
          [cl.reference, className.reference, intent.reference]).object);

  static final _id_callActivityOnCreate = jniAccessors.getMethodIDOf(_classRef,
      "callActivityOnCreate", "(Landroid/app/Activity;Landroid/os/Bundle;)V");

  /// from: public void callActivityOnCreate(android.app.Activity activity, android.os.Bundle icicle)
  ///
  /// Perform calling of an activity's Activity\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to onCreate().
  void callActivityOnCreate(
          activity_.Activity activity, bundle_.Bundle icicle) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnCreate,
          jni.JniType.voidType, [activity.reference, icicle.reference]).check();

  static final _id_callActivityOnCreate1 = jniAccessors.getMethodIDOf(
      _classRef,
      "callActivityOnCreate",
      "(Landroid/app/Activity;Landroid/os/Bundle;Landroid/os/PersistableBundle;)V");

  /// from: public void callActivityOnCreate(android.app.Activity activity, android.os.Bundle icicle, android.os.PersistableBundle persistentState)
  ///
  /// Perform calling of an activity's Activity\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///@param persistentState The previously persisted state (or null)
  void callActivityOnCreate1(activity_.Activity activity, bundle_.Bundle icicle,
          persistablebundle_.PersistableBundle persistentState) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_callActivityOnCreate1, jni.JniType.voidType, [
        activity.reference,
        icicle.reference,
        persistentState.reference
      ]).check();

  static final _id_callActivityOnDestroy = jniAccessors.getMethodIDOf(
      _classRef, "callActivityOnDestroy", "(Landroid/app/Activity;)V");

  /// from: public void callActivityOnDestroy(android.app.Activity activity)
  void callActivityOnDestroy(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnDestroy,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_callActivityOnRestoreInstanceState =
      jniAccessors.getMethodIDOf(
          _classRef,
          "callActivityOnRestoreInstanceState",
          "(Landroid/app/Activity;Landroid/os/Bundle;)V");

  /// from: public void callActivityOnRestoreInstanceState(android.app.Activity activity, android.os.Bundle savedInstanceState)
  ///
  /// Perform calling of an activity's Activity\#onRestoreInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restored.
  ///@param savedInstanceState The previously saved state being restored.
  void callActivityOnRestoreInstanceState(
          activity_.Activity activity, bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_callActivityOnRestoreInstanceState,
          jni.JniType.voidType,
          [activity.reference, savedInstanceState.reference]).check();

  static final _id_callActivityOnRestoreInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef,
      "callActivityOnRestoreInstanceState",
      "(Landroid/app/Activity;Landroid/os/Bundle;Landroid/os/PersistableBundle;)V");

  /// from: public void callActivityOnRestoreInstanceState(android.app.Activity activity, android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  ///
  /// Perform calling of an activity's Activity\#onRestoreInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restored.
  ///@param savedInstanceState The previously saved state being restored.
  ///@param persistentState The previously persisted state (or null)
  void callActivityOnRestoreInstanceState1(
          activity_.Activity activity,
          bundle_.Bundle savedInstanceState,
          persistablebundle_.PersistableBundle persistentState) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_callActivityOnRestoreInstanceState1, jni.JniType.voidType, [
        activity.reference,
        savedInstanceState.reference,
        persistentState.reference
      ]).check();

  static final _id_callActivityOnPostCreate = jniAccessors.getMethodIDOf(
      _classRef,
      "callActivityOnPostCreate",
      "(Landroid/app/Activity;Landroid/os/Bundle;)V");

  /// from: public void callActivityOnPostCreate(android.app.Activity activity, android.os.Bundle icicle)
  ///
  /// Perform calling of an activity's Activity\#onPostCreate method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///               onPostCreate().
  void callActivityOnPostCreate(
          activity_.Activity activity, bundle_.Bundle icicle) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnPostCreate,
          jni.JniType.voidType, [activity.reference, icicle.reference]).check();

  static final _id_callActivityOnPostCreate1 = jniAccessors.getMethodIDOf(
      _classRef,
      "callActivityOnPostCreate",
      "(Landroid/app/Activity;Landroid/os/Bundle;Landroid/os/PersistableBundle;)V");

  /// from: public void callActivityOnPostCreate(android.app.Activity activity, android.os.Bundle icicle, android.os.PersistableBundle persistentState)
  ///
  /// Perform calling of an activity's Activity\#onPostCreate method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///               onPostCreate().
  void callActivityOnPostCreate1(
          activity_.Activity activity,
          bundle_.Bundle icicle,
          persistablebundle_.PersistableBundle persistentState) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_callActivityOnPostCreate1, jni.JniType.voidType, [
        activity.reference,
        icicle.reference,
        persistentState.reference
      ]).check();

  static final _id_callActivityOnNewIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "callActivityOnNewIntent",
      "(Landroid/app/Activity;Landroid/content/Intent;)V");

  /// from: public void callActivityOnNewIntent(android.app.Activity activity, android.content.Intent intent)
  ///
  /// Perform calling of an activity's Activity\#onNewIntent
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity receiving a new Intent.
  ///@param intent The new intent being received.
  void callActivityOnNewIntent(
          activity_.Activity activity, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnNewIntent,
          jni.JniType.voidType, [activity.reference, intent.reference]).check();

  static final _id_callActivityOnStart = jniAccessors.getMethodIDOf(
      _classRef, "callActivityOnStart", "(Landroid/app/Activity;)V");

  /// from: public void callActivityOnStart(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onStart
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being started.
  void callActivityOnStart(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnStart,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_callActivityOnRestart = jniAccessors.getMethodIDOf(
      _classRef, "callActivityOnRestart", "(Landroid/app/Activity;)V");

  /// from: public void callActivityOnRestart(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onRestart
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restarted.
  void callActivityOnRestart(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnRestart,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_callActivityOnResume = jniAccessors.getMethodIDOf(
      _classRef, "callActivityOnResume", "(Landroid/app/Activity;)V");

  /// from: public void callActivityOnResume(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onResume method.  The
  /// default implementation simply calls through to that method.
  ///@param activity The activity being resumed.
  void callActivityOnResume(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnResume,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_callActivityOnStop = jniAccessors.getMethodIDOf(
      _classRef, "callActivityOnStop", "(Landroid/app/Activity;)V");

  /// from: public void callActivityOnStop(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onStop
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being stopped.
  void callActivityOnStop(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnStop,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_callActivityOnSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef,
      "callActivityOnSaveInstanceState",
      "(Landroid/app/Activity;Landroid/os/Bundle;)V");

  /// from: public void callActivityOnSaveInstanceState(android.app.Activity activity, android.os.Bundle outState)
  ///
  /// Perform calling of an activity's Activity\#onSaveInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being saved.
  ///@param outState The bundle to pass to the call.
  void callActivityOnSaveInstanceState(
          activity_.Activity activity, bundle_.Bundle outState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_callActivityOnSaveInstanceState,
          jni.JniType.voidType,
          [activity.reference, outState.reference]).check();

  static final _id_callActivityOnSaveInstanceState1 = jniAccessors.getMethodIDOf(
      _classRef,
      "callActivityOnSaveInstanceState",
      "(Landroid/app/Activity;Landroid/os/Bundle;Landroid/os/PersistableBundle;)V");

  /// from: public void callActivityOnSaveInstanceState(android.app.Activity activity, android.os.Bundle outState, android.os.PersistableBundle outPersistentState)
  ///
  /// Perform calling of an activity's Activity\#onSaveInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being saved.
  ///@param outState The bundle to pass to the call.
  ///@param outPersistentState The persistent bundle to pass to the call.
  void callActivityOnSaveInstanceState1(
          activity_.Activity activity,
          bundle_.Bundle outState,
          persistablebundle_.PersistableBundle outPersistentState) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_callActivityOnSaveInstanceState1, jni.JniType.voidType, [
        activity.reference,
        outState.reference,
        outPersistentState.reference
      ]).check();

  static final _id_callActivityOnPause = jniAccessors.getMethodIDOf(
      _classRef, "callActivityOnPause", "(Landroid/app/Activity;)V");

  /// from: public void callActivityOnPause(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onPause method.  The
  /// default implementation simply calls through to that method.
  ///@param activity The activity being paused.
  void callActivityOnPause(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnPause,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_callActivityOnUserLeaving = jniAccessors.getMethodIDOf(
      _classRef, "callActivityOnUserLeaving", "(Landroid/app/Activity;)V");

  /// from: public void callActivityOnUserLeaving(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onUserLeaveHint method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being notified that the user has navigated away
  void callActivityOnUserLeaving(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_callActivityOnUserLeaving,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_startAllocCounting =
      jniAccessors.getMethodIDOf(_classRef, "startAllocCounting", "()V");

  /// from: public void startAllocCounting()
  void startAllocCounting() => jniAccessors.callMethodWithArgs(
      reference, _id_startAllocCounting, jni.JniType.voidType, []).check();

  static final _id_stopAllocCounting =
      jniAccessors.getMethodIDOf(_classRef, "stopAllocCounting", "()V");

  /// from: public void stopAllocCounting()
  void stopAllocCounting() => jniAccessors.callMethodWithArgs(
      reference, _id_stopAllocCounting, jni.JniType.voidType, []).check();

  static final _id_getAllocCounts = jniAccessors.getMethodIDOf(
      _classRef, "getAllocCounts", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getAllocCounts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a bundle with the current results from the allocation counting.
  bundle_.Bundle getAllocCounts() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllocCounts, jni.JniType.objectType, []).object);

  static final _id_getBinderCounts = jniAccessors.getMethodIDOf(
      _classRef, "getBinderCounts", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getBinderCounts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a bundle with the counts for various binder counts for this process. Currently the only two that are
  /// reported are the number of send and the number of received transactions.
  bundle_.Bundle getBinderCounts() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBinderCounts, jni.JniType.objectType, []).object);

  static final _id_getUiAutomation = jniAccessors.getMethodIDOf(
      _classRef, "getUiAutomation", "()Landroid/app/UiAutomation;");

  /// from: public android.app.UiAutomation getUiAutomation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the UiAutomation instance with no flags set.
  ///
  /// <strong>Note:</strong> The APIs exposed via the returned UiAutomation
  /// work across application boundaries while the APIs exposed by the instrumentation
  /// do not. For example, Instrumentation\#sendPointerSync(MotionEvent) will
  /// not allow you to inject the event in an app different from the instrumentation
  /// target, while UiAutomation\#injectInputEvent(android.view.InputEvent, boolean)
  /// will work regardless of the current application.
  ///
  ///
  ///
  /// A typical test case should be using either the UiAutomation or
  /// Instrumentation APIs. Using both APIs at the same time is not
  /// a mistake by itself but a client has to be aware of the APIs limitations.
  ///
  ///
  ///
  /// Equivalent to {@code getUiAutomation(0)}. If a UiAutomation exists with different
  /// flags, the flags on that instance will be changed, and then it will be returned.
  ///
  ///
  ///@return The UI automation instance.
  ///@see UiAutomation
  uiautomation_.UiAutomation getUiAutomation() =>
      uiautomation_.UiAutomation.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUiAutomation, jni.JniType.objectType, []).object);

  static final _id_getUiAutomation1 = jniAccessors.getMethodIDOf(
      _classRef, "getUiAutomation", "(I)Landroid/app/UiAutomation;");

  /// from: public android.app.UiAutomation getUiAutomation(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the UiAutomation instance with flags set.
  ///
  /// <strong>Note:</strong> The APIs exposed via the returned UiAutomation
  /// work across application boundaries while the APIs exposed by the instrumentation
  /// do not. For example, Instrumentation\#sendPointerSync(MotionEvent) will
  /// not allow you to inject the event in an app different from the instrumentation
  /// target, while UiAutomation\#injectInputEvent(android.view.InputEvent, boolean)
  /// will work regardless of the current application.
  ///
  ///
  ///
  /// A typical test case should be using either the UiAutomation or
  /// Instrumentation APIs. Using both APIs at the same time is not
  /// a mistake by itself but a client has to be aware of the APIs limitations.
  ///
  ///
  ///
  /// If a UiAutomation exists with different flags, the flags on that instance will be
  /// changed, and then it will be returned.
  ///
  ///
  ///@param flags The flags to be passed to the UiAutomation, for example
  ///        UiAutomation\#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES.
  ///
  /// Value is 0, or android.app.UiAutomation\#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES
  ///@return The UI automation instance.
  ///@see UiAutomation
  uiautomation_.UiAutomation getUiAutomation1(int flags) =>
      uiautomation_.UiAutomation.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getUiAutomation1,
          jni.JniType.objectType,
          [flags]).object);

  static final _id_acquireLooperManager = jniAccessors.getMethodIDOf(
      _classRef,
      "acquireLooperManager",
      "(Landroid/os/Looper;)Landroid/os/TestLooperManager;");

  /// from: public android.os.TestLooperManager acquireLooperManager(android.os.Looper looper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Takes control of the execution of messages on the specified looper until
  /// TestLooperManager\#release is called.
  testloopermanager_.TestLooperManager acquireLooperManager(
          looper_.Looper looper) =>
      testloopermanager_.TestLooperManager.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_acquireLooperManager,
              jni.JniType.objectType, [looper.reference]).object);
}

/// from: android.app.Instrumentation$ActivityResult
///
/// Description of a Activity execution result to return to the original
/// activity.
class Instrumentation_ActivityResult extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Instrumentation\$ActivityResult");
  Instrumentation_ActivityResult.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILandroid/content/Intent;)V");

  /// from: public void <init>(int resultCode, android.content.Intent resultData)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new activity result.  See Activity\#setResult for
  /// more information.
  ///@param resultCode The result code to propagate back to the
  /// originating activity, often RESULT_CANCELED or RESULT_OK
  ///@param resultData The data to propagate back to the originating
  /// activity.
  Instrumentation_ActivityResult(int resultCode, intent_.Intent resultData)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [resultCode, resultData.reference]).object);

  static final _id_getResultCode =
      jniAccessors.getMethodIDOf(_classRef, "getResultCode", "()I");

  /// from: public int getResultCode()
  ///
  /// Retrieve the result code contained in this result.
  int getResultCode() => jniAccessors.callMethodWithArgs(
      reference, _id_getResultCode, jni.JniType.intType, []).integer;

  static final _id_getResultData = jniAccessors.getMethodIDOf(
      _classRef, "getResultData", "()Landroid/content/Intent;");

  /// from: public android.content.Intent getResultData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the data contained in this result.
  intent_.Intent getResultData() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getResultData, jni.JniType.objectType, []).object);
}

/// from: android.app.Instrumentation$ActivityMonitor
///
/// Information about a particular kind of Intent that is being monitored.
/// An instance of this class is added to the
/// current instrumentation through \#addMonitor; after being added,
/// when a new activity is being started the monitor will be checked and, if
/// matching, its hit count updated and (optionally) the call stopped and a
/// canned result returned.
///
/// An ActivityMonitor can also be used to look for the creation of an
/// activity, through the \#waitForActivity method.  This will return
/// after a matching activity has been created with that activity object.
class Instrumentation_ActivityMonitor extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Instrumentation\$ActivityMonitor");
  Instrumentation_ActivityMonitor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/IntentFilter;Landroid/app/Instrumentation\$ActivityResult;Z)V");

  /// from: public void <init>(android.content.IntentFilter which, android.app.Instrumentation.ActivityResult result, boolean block)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ActivityMonitor that looks for a particular kind of
  /// intent to be started.
  ///@param which The set of intents this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@see Instrumentation\#addMonitor
  Instrumentation_ActivityMonitor(intentfilter_.IntentFilter which,
      Instrumentation_ActivityResult result, bool block)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [which.reference, result.reference, block]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Landroid/app/Instrumentation\$ActivityResult;Z)V");

  /// from: public void <init>(java.lang.String cls, android.app.Instrumentation.ActivityResult result, boolean block)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ActivityMonitor that looks for a specific activity
  /// class to be started.
  ///@param cls The activity class this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@see Instrumentation\#addMonitor
  Instrumentation_ActivityMonitor.ctor1(
      jni.JniString cls, Instrumentation_ActivityResult result, bool block)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [cls.reference, result.reference, block]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ActivityMonitor that can be used for intercepting any activity to be
  /// started.
  ///
  ///  When an activity is started, \#onStartActivity(Intent) will be called on
  /// instances created using this constructor to see if it is a hit.
  ///@see \#onStartActivity(Intent)
  Instrumentation_ActivityMonitor.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_getFilter = jniAccessors.getMethodIDOf(
      _classRef, "getFilter", "()Landroid/content/IntentFilter;");

  /// from: public final android.content.IntentFilter getFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the filter associated with this ActivityMonitor.
  intentfilter_.IntentFilter getFilter() =>
      intentfilter_.IntentFilter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFilter, jni.JniType.objectType, []).object);

  static final _id_getResult = jniAccessors.getMethodIDOf(_classRef,
      "getResult", "()Landroid/app/Instrumentation\$ActivityResult;");

  /// from: public final android.app.Instrumentation.ActivityResult getResult()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the result associated with this ActivityMonitor, or null if
  /// none.
  Instrumentation_ActivityResult getResult() =>
      Instrumentation_ActivityResult.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getResult, jni.JniType.objectType, []).object);

  static final _id_isBlocking =
      jniAccessors.getMethodIDOf(_classRef, "isBlocking", "()Z");

  /// from: public final boolean isBlocking()
  ///
  /// Check whether this monitor blocks activity starts (not allowing the
  /// actual activity to run) or allows them to execute normally.
  bool isBlocking() => jniAccessors.callMethodWithArgs(
      reference, _id_isBlocking, jni.JniType.booleanType, []).boolean;

  static final _id_getHits =
      jniAccessors.getMethodIDOf(_classRef, "getHits", "()I");

  /// from: public final int getHits()
  ///
  /// Retrieve the number of times the monitor has been hit so far.
  int getHits() => jniAccessors.callMethodWithArgs(
      reference, _id_getHits, jni.JniType.intType, []).integer;

  static final _id_getLastActivity = jniAccessors.getMethodIDOf(
      _classRef, "getLastActivity", "()Landroid/app/Activity;");

  /// from: public final android.app.Activity getLastActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the most recent activity class that was seen by this
  /// monitor.
  activity_.Activity getLastActivity() =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLastActivity, jni.JniType.objectType, []).object);

  static final _id_waitForActivity = jniAccessors.getMethodIDOf(
      _classRef, "waitForActivity", "()Landroid/app/Activity;");

  /// from: public final android.app.Activity waitForActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Block until an Activity is created that matches this monitor,
  /// returning the resulting activity.
  ///@return Activity
  activity_.Activity waitForActivity() =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_waitForActivity, jni.JniType.objectType, []).object);

  static final _id_waitForActivityWithTimeout = jniAccessors.getMethodIDOf(
      _classRef, "waitForActivityWithTimeout", "(J)Landroid/app/Activity;");

  /// from: public final android.app.Activity waitForActivityWithTimeout(long timeOut)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Block until an Activity is created that matches this monitor,
  /// returning the resulting activity or till the timeOut period expires.
  /// If the timeOut expires before the activity is started, return null.
  ///@param timeOut Time to wait in milliseconds before the activity is created.
  ///@return Activity
  activity_.Activity waitForActivityWithTimeout(int timeOut) =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_waitForActivityWithTimeout,
          jni.JniType.objectType,
          [timeOut]).object);

  static final _id_onStartActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "onStartActivity",
      "(Landroid/content/Intent;)Landroid/app/Instrumentation\$ActivityResult;");

  /// from: public android.app.Instrumentation.ActivityResult onStartActivity(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used for intercepting any started activity.
  ///
  ///  A non-null return value here will be considered a hit for this monitor.
  /// By default this will return {@code null} and subclasses can override this to return
  /// a non-null value if the intent needs to be intercepted.
  ///
  ///  Whenever a new activity is started, this method will be called on instances created
  /// using \#Instrumentation.ActivityMonitor() to check if there is a match. In case
  /// of a match, the activity start will be blocked and the returned result will be used.
  ///@param intent The intent used for starting the activity.
  ///@return The ActivityResult that needs to be used in case of a match.
  Instrumentation_ActivityResult onStartActivity(intent_.Intent intent) =>
      Instrumentation_ActivityResult.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onStartActivity,
          jni.JniType.objectType,
          [intent.reference]).object);
}
