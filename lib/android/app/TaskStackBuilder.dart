// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../content/Intent.dart" as intent_;

import "Activity.dart" as activity_;

import "../content/ComponentName.dart" as componentname_;

import "../os/Bundle.dart" as bundle_;

import "PendingIntent.dart" as pendingintent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.TaskStackBuilder
///
/// Utility class for constructing synthetic back stacks for cross-task navigation
/// on Android 3.0 and newer.
///
/// In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
/// app navigation using the back key changed. The back key's behavior is local
/// to the current task and does not capture navigation across different tasks.
/// Navigating across tasks and easily reaching the previous task is accomplished
/// through the "recents" UI, accessible through the software-provided Recents key
/// on the navigation or system bar. On devices with the older hardware button configuration
/// the recents UI can be accessed with a long press on the Home key.
///
///
/// When crossing from one task stack to another post-Android 3.0,
/// the application should synthesize a back stack/history for the new task so that
/// the user may navigate out of the new task and back to the Launcher by repeated
/// presses of the back key. Back key presses should not navigate across task stacks.
///
///
/// TaskStackBuilder provides a way to obey the correct conventions
/// around cross-task navigation.
///
///
/// <div class="special reference">
/// <h3>About Navigation</h3>
/// For more detailed information about tasks, the back stack, and navigation design guidelines,
/// please read
/// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back Stack</a>
/// from the developer guide and <a href="{@docRoot}design/patterns/navigation.html">Navigation</a>
/// from the design guide.
/// </div>
class TaskStackBuilder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/TaskStackBuilder");
  TaskStackBuilder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: void <init>(android.content.Context a)
  /// The returned object must be deleted after use, by calling the `delete` method.
  TaskStackBuilder(context_.Context a)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [a.reference]).object);

  static final _id_create = jniAccessors.getStaticMethodIDOf(_classRef,
      "create", "(Landroid/content/Context;)Landroid/app/TaskStackBuilder;");

  /// from: static public android.app.TaskStackBuilder create(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new TaskStackBuilder for launching a fresh task stack consisting
  /// of a series of activities.
  ///@param context The context that will launch the new task stack or generate a PendingIntent
  ///@return A new TaskStackBuilder
  static TaskStackBuilder create(context_.Context context) =>
      TaskStackBuilder.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_create, jni.JniType.objectType, [context.reference]).object);

  static final _id_addNextIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "addNextIntent",
      "(Landroid/content/Intent;)Landroid/app/TaskStackBuilder;");

  /// from: public android.app.TaskStackBuilder addNextIntent(android.content.Intent nextIntent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new Intent to the task stack. The most recently added Intent will invoke
  /// the Activity at the top of the final task stack.
  ///@param nextIntent Intent for the next Activity in the synthesized task stack
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addNextIntent(intent_.Intent nextIntent) =>
      TaskStackBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addNextIntent,
          jni.JniType.objectType,
          [nextIntent.reference]).object);

  static final _id_addNextIntentWithParentStack = jniAccessors.getMethodIDOf(
      _classRef,
      "addNextIntentWithParentStack",
      "(Landroid/content/Intent;)Landroid/app/TaskStackBuilder;");

  /// from: public android.app.TaskStackBuilder addNextIntentWithParentStack(android.content.Intent nextIntent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new Intent with the resolved chain of parents for the target activity to
  /// the task stack.
  ///
  /// This is equivalent to calling \#addParentStack(ComponentName) addParentStack
  /// with the resolved ComponentName of nextIntent (if it can be resolved), followed by
  /// \#addNextIntent(Intent) addNextIntent with nextIntent.
  ///
  ///@param nextIntent Intent for the topmost Activity in the synthesized task stack.
  ///                   Its chain of parents as specified in the manifest will be added.
  ///@return This TaskStackBuilder for method chaining.
  TaskStackBuilder addNextIntentWithParentStack(intent_.Intent nextIntent) =>
      TaskStackBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addNextIntentWithParentStack,
          jni.JniType.objectType,
          [nextIntent.reference]).object);

  static final _id_addParentStack = jniAccessors.getMethodIDOf(
      _classRef,
      "addParentStack",
      "(Landroid/app/Activity;)Landroid/app/TaskStackBuilder;");

  /// from: public android.app.TaskStackBuilder addParentStack(android.app.Activity sourceActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the activity parent chain as specified by the
  /// Activity\#getParentActivityIntent() getParentActivityIntent() method of the activity
  /// specified and the android.R.attr\#parentActivityName parentActivityName attributes
  /// of each successive activity (or activity-alias) element in the application's manifest
  /// to the task stack builder.
  ///@param sourceActivity All parents of this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack(activity_.Activity sourceActivity) =>
      TaskStackBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addParentStack,
          jni.JniType.objectType,
          [sourceActivity.reference]).object);

  static final _id_addParentStack1 = jniAccessors.getMethodIDOf(_classRef,
      "addParentStack", "(Ljava/lang/Class;)Landroid/app/TaskStackBuilder;");

  /// from: public android.app.TaskStackBuilder addParentStack(java.lang.Class<?> sourceActivityClass)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the activity parent chain as specified by the
  /// android.R.attr\#parentActivityName parentActivityName attribute of the activity
  /// (or activity-alias) element in the application's manifest to the task stack builder.
  ///@param sourceActivityClass All parents of this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack1(jni.JniObject sourceActivityClass) =>
      TaskStackBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addParentStack1,
          jni.JniType.objectType,
          [sourceActivityClass.reference]).object);

  static final _id_addParentStack2 = jniAccessors.getMethodIDOf(
      _classRef,
      "addParentStack",
      "(Landroid/content/ComponentName;)Landroid/app/TaskStackBuilder;");

  /// from: public android.app.TaskStackBuilder addParentStack(android.content.ComponentName sourceActivityName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the activity parent chain as specified by the
  /// android.R.attr\#parentActivityName parentActivityName attribute of the activity
  /// (or activity-alias) element in the application's manifest to the task stack builder.
  ///@param sourceActivityName Must specify an Activity component. All parents of
  ///                           this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack2(
          componentname_.ComponentName sourceActivityName) =>
      TaskStackBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addParentStack2,
          jni.JniType.objectType,
          [sourceActivityName.reference]).object);

  static final _id_getIntentCount =
      jniAccessors.getMethodIDOf(_classRef, "getIntentCount", "()I");

  /// from: public int getIntentCount()
  ///
  /// @return the number of intents added so far.
  int getIntentCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getIntentCount, jni.JniType.intType, []).integer;

  static final _id_editIntentAt = jniAccessors.getMethodIDOf(
      _classRef, "editIntentAt", "(I)Landroid/content/Intent;");

  /// from: public android.content.Intent editIntentAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the intent at the specified index for modification.
  /// Useful if you need to modify the flags or extras of an intent that was previously added,
  /// for example with \#addParentStack(Activity).
  ///@param index Index from 0-getIntentCount()
  ///@return the intent at position index
  intent_.Intent editIntentAt(int index) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_editIntentAt, jni.JniType.objectType, [index]).object);

  static final _id_startActivities =
      jniAccessors.getMethodIDOf(_classRef, "startActivities", "()V");

  /// from: public void startActivities()
  ///
  /// Start the task stack constructed by this builder.
  void startActivities() => jniAccessors.callMethodWithArgs(
      reference, _id_startActivities, jni.JniType.voidType, []).check();

  static final _id_startActivities1 = jniAccessors.getMethodIDOf(
      _classRef, "startActivities", "(Landroid/os/Bundle;)V");

  /// from: public void startActivities(android.os.Bundle options)
  ///
  /// Start the task stack constructed by this builder.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  void startActivities1(bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivities1,
          jni.JniType.voidType, [options.reference]).check();

  static final _id_getPendingIntent = jniAccessors.getMethodIDOf(
      _classRef, "getPendingIntent", "(II)Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getPendingIntent(int requestCode, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a PendingIntent for launching the task constructed by this builder so far.
  ///@param requestCode Private request code for the sender
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT,
  ///              PendingIntent\#FLAG_NO_CREATE, PendingIntent\#FLAG_CANCEL_CURRENT,
  ///              PendingIntent\#FLAG_UPDATE_CURRENT, or any of the flags supported by
  ///              Intent\#fillIn(Intent, int) to control which unspecified parts of the
  ///              intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return The obtained PendingIntent
  pendingintent_.PendingIntent getPendingIntent(int requestCode, int flags) =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPendingIntent,
          jni.JniType.objectType,
          [requestCode, flags]).object);

  static final _id_getPendingIntent1 = jniAccessors.getMethodIDOf(_classRef,
      "getPendingIntent", "(IILandroid/os/Bundle;)Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getPendingIntent(int requestCode, int flags, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a PendingIntent for launching the task constructed by this builder so far.
  ///@param requestCode Private request code for the sender
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT,
  ///              PendingIntent\#FLAG_NO_CREATE, PendingIntent\#FLAG_CANCEL_CURRENT,
  ///              PendingIntent\#FLAG_UPDATE_CURRENT, or any of the flags supported by
  ///              Intent\#fillIn(Intent, int) to control which unspecified parts of the
  ///              intent that can be supplied when the actual send happens.
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///@return The obtained PendingIntent
  pendingintent_.PendingIntent getPendingIntent1(
          int requestCode, int flags, bundle_.Bundle options) =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPendingIntent1,
          jni.JniType.objectType,
          [requestCode, flags, options.reference]).object);

  static final _id_getIntents = jniAccessors.getMethodIDOf(
      _classRef, "getIntents", "()[Landroid/content/Intent;");

  /// from: public android.content.Intent[] getIntents()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an array containing the intents added to this builder. The intent at the
  /// root of the task stack will appear as the first item in the array and the
  /// intent at the top of the stack will appear as the last item.
  ///@return An array containing the intents added to this builder.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getIntents() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIntents, jni.JniType.objectType, []).object);
}
