// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Fragment.dart" as fragment_;

import "../view/View.dart" as view_;

import "../view/LayoutInflater.dart" as layoutinflater_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../os/Bundle.dart" as bundle_;

import "../widget/ListView.dart" as listview_;

import "../widget/ListAdapter.dart" as listadapter_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.ListFragment
///
/// A fragment that displays a list of items by binding to a data source such as
/// an array or Cursor, and exposes event handlers when the user selects an item.
///
/// ListFragment hosts a android.widget.ListView ListView object that can
/// be bound to different data sources, typically either an array or a Cursor
/// holding query results. Binding, screen layout, and row layout are discussed
/// in the following sections.
///
/// <strong>Screen Layout</strong>
///
///
///
/// ListFragment has a default layout that consists of a single list view.
/// However, if you desire, you can customize the fragment layout by returning
/// your own view hierarchy from \#onCreateView.
/// To do this, your view hierarchy _must_ contain a ListView object with the
/// id "@android:id/list" (or android.R.id\#list if it's in code)
///
/// Optionally, your view hierarchy can contain another view object of any type to
/// display when the list view is empty. This "empty list" notifier must have an
/// id "android:empty". Note that when an empty view is present, the list view
/// will be hidden when there is no data to display.
///
/// The following code demonstrates an (ugly) custom list layout. It has a list
/// with a green background, and an alternate red "no data" message.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///         android:orientation=&quot;vertical&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;match_parent&quot;
///         android:paddingLeft=&quot;8dp&quot;
///         android:paddingRight=&quot;8dp&quot;&gt;
///
///     &lt;ListView android:id=&quot;@id/android:list&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#00FF00&quot;
///               android:layout_weight=&quot;1&quot;
///               android:drawSelectorOnTop=&quot;false&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@id/android:empty&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#FF0000&quot;
///               android:text=&quot;No data&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// <strong>Row Layout</strong>
///
///
///
/// You can specify the layout of individual rows in the list. You do this by
/// specifying a layout resource in the ListAdapter object hosted by the fragment
/// (the ListAdapter binds the ListView to the data; more on this later).
///
/// A ListAdapter constructor takes a parameter that specifies a layout resource
/// for each row. It also has two additional parameters that let you specify
/// which data field to associate with which object in the row layout resource.
/// These two parameters are typically parallel arrays.
///
///
///
/// Android provides some standard row layout resources. These are in the
/// android.R.layout class, and have names such as simple_list_item_1,
/// simple_list_item_2, and two_line_list_item. The following layout XML is the
/// source for the resource two_line_list_item, which displays two data
/// fields,one above the other, for each list row.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///     android:layout_width=&quot;match_parent&quot;
///     android:layout_height=&quot;wrap_content&quot;
///     android:orientation=&quot;vertical&quot;&gt;
///
///     &lt;TextView android:id=&quot;@+id/text1&quot;
///         android:textSize=&quot;16sp&quot;
///         android:textStyle=&quot;bold&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@+id/text2&quot;
///         android:textSize=&quot;16sp&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// You must identify the data bound to each TextView object in this layout. The
/// syntax for this is discussed in the next section.
///
///
///
/// <strong>Binding to Data</strong>
///
///
///
/// You bind the ListFragment's ListView object to data using a class that
/// implements the android.widget.ListAdapter ListAdapter interface.
/// Android provides two standard list adapters:
/// android.widget.SimpleAdapter SimpleAdapter for static data (Maps),
/// and android.widget.SimpleCursorAdapter SimpleCursorAdapter for Cursor
/// query results.
///
///
///
/// You __must__ use
/// \#setListAdapter(ListAdapter) ListFragment.setListAdapter() to
/// associate the list with an adapter.  Do not directly call
/// ListView\#setAdapter(ListAdapter) ListView.setAdapter() or else
/// important initialization will be skipped.
///
///
///@see \#setListAdapter
///@see android.widget.ListView
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.ListFragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class ListFragment extends fragment_.Fragment {
  static final _classRef = jniAccessors.getClassOf("android/app/ListFragment");
  ListFragment.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ListFragment()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onCreateView = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Landroid/view/LayoutInflater;Landroid/view/ViewGroup;Landroid/os/Bundle;)Landroid/view/View;");

  /// from: public android.view.View onCreateView(android.view.LayoutInflater inflater, android.view.ViewGroup container, android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide default implementation to return a simple list view.  Subclasses
  /// can override to replace with their own layout.  If doing so, the
  /// returned view hierarchy _must_ have a ListView whose id
  /// is android.R.id\#list android.R.id.list and can optionally
  /// have a sibling view id android.R.id\#empty android.R.id.empty
  /// that is to be shown when the list is empty.
  ///
  /// If you are overriding this method with your own custom content,
  /// consider including the standard layout android.R.layout\#list_content
  /// in your layout file, so that you continue to retain all of the standard
  /// behavior of ListFragment.  In particular, this is currently the only
  /// way to have the built-in indeterminant progress state be shown.
  view_.View onCreateView(layoutinflater_.LayoutInflater inflater,
          viewgroup_.ViewGroup container, bundle_.Bundle savedInstanceState) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCreateView, jni.JniType.objectType, [
        inflater.reference,
        container.reference,
        savedInstanceState.reference
      ]).object);

  static final _id_onViewCreated = jniAccessors.getMethodIDOf(
      _classRef, "onViewCreated", "(Landroid/view/View;Landroid/os/Bundle;)V");

  /// from: public void onViewCreated(android.view.View view, android.os.Bundle savedInstanceState)
  ///
  /// Attach to list view once the view hierarchy has been created.
  void onViewCreated(view_.View view, bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onViewCreated,
          jni.JniType.voidType,
          [view.reference, savedInstanceState.reference]).check();

  static final _id_onDestroyView =
      jniAccessors.getMethodIDOf(_classRef, "onDestroyView", "()V");

  /// from: public void onDestroyView()
  ///
  /// Detach from list view.
  void onDestroyView() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroyView, jni.JniType.voidType, []).check();

  static final _id_onListItemClick = jniAccessors.getMethodIDOf(_classRef,
      "onListItemClick", "(Landroid/widget/ListView;Landroid/view/View;IJ)V");

  /// from: public void onListItemClick(android.widget.ListView l, android.view.View v, int position, long id)
  ///
  /// This method will be called when an item in the list is selected.
  /// Subclasses should override. Subclasses can call
  /// getListView().getItemAtPosition(position) if they need to access the
  /// data associated with the selected item.
  ///@param l The ListView where the click happened
  ///@param v The view that was clicked within the ListView
  ///@param position The position of the view in the list
  ///@param id The row id of the item that was clicked
  void onListItemClick(
          listview_.ListView l, view_.View v, int position, int id) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onListItemClick,
          jni.JniType.voidType,
          [l.reference, v.reference, position, id]).check();

  static final _id_setListAdapter = jniAccessors.getMethodIDOf(
      _classRef, "setListAdapter", "(Landroid/widget/ListAdapter;)V");

  /// from: public void setListAdapter(android.widget.ListAdapter adapter)
  ///
  /// Provide the cursor for the list view.
  void setListAdapter(listadapter_.ListAdapter adapter) =>
      jniAccessors.callMethodWithArgs(reference, _id_setListAdapter,
          jni.JniType.voidType, [adapter.reference]).check();

  static final _id_setSelection =
      jniAccessors.getMethodIDOf(_classRef, "setSelection", "(I)V");

  /// from: public void setSelection(int position)
  ///
  /// Set the currently selected list item to the specified
  /// position with the adapter's data
  ///@param position
  void setSelection(int position) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelection, jni.JniType.voidType, [position]).check();

  static final _id_getSelectedItemPosition =
      jniAccessors.getMethodIDOf(_classRef, "getSelectedItemPosition", "()I");

  /// from: public int getSelectedItemPosition()
  ///
  /// Get the position of the currently selected list item.
  int getSelectedItemPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectedItemPosition, jni.JniType.intType, []).integer;

  static final _id_getSelectedItemId =
      jniAccessors.getMethodIDOf(_classRef, "getSelectedItemId", "()J");

  /// from: public long getSelectedItemId()
  ///
  /// Get the cursor row ID of the currently selected list item.
  int getSelectedItemId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSelectedItemId, jni.JniType.longType, []).long;

  static final _id_getListView = jniAccessors.getMethodIDOf(
      _classRef, "getListView", "()Landroid/widget/ListView;");

  /// from: public android.widget.ListView getListView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the fragment's list view widget.
  listview_.ListView getListView() =>
      listview_.ListView.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getListView, jni.JniType.objectType, []).object);

  static final _id_setEmptyText = jniAccessors.getMethodIDOf(
      _classRef, "setEmptyText", "(Ljava/lang/CharSequence;)V");

  /// from: public void setEmptyText(java.lang.CharSequence text)
  ///
  /// The default content for a ListFragment has a TextView that can
  /// be shown when the list is empty.  If you would like to have it
  /// shown, call this method to supply the text it should use.
  void setEmptyText(jni.JniObject text) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setEmptyText,
      jni.JniType.voidType,
      [text.reference]).check();

  static final _id_setListShown =
      jniAccessors.getMethodIDOf(_classRef, "setListShown", "(Z)V");

  /// from: public void setListShown(boolean shown)
  ///
  /// Control whether the list is being displayed.  You can make it not
  /// displayed if you are waiting for the initial data to show in it.  During
  /// this time an indeterminant progress indicator will be shown instead.
  ///
  /// Applications do not normally need to use this themselves.  The default
  /// behavior of ListFragment is to start with the list not being shown, only
  /// showing it once an adapter is given with \#setListAdapter(ListAdapter).
  /// If the list at that point had not been shown, when it does get shown
  /// it will be do without the user ever seeing the hidden state.
  ///@param shown If true, the list view is shown; if false, the progress
  /// indicator.  The initial value is true.
  void setListShown(bool shown) => jniAccessors.callMethodWithArgs(
      reference, _id_setListShown, jni.JniType.voidType, [shown]).check();

  static final _id_setListShownNoAnimation =
      jniAccessors.getMethodIDOf(_classRef, "setListShownNoAnimation", "(Z)V");

  /// from: public void setListShownNoAnimation(boolean shown)
  ///
  /// Like \#setListShown(boolean), but no animation is used when
  /// transitioning from the previous state.
  void setListShownNoAnimation(bool shown) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setListShownNoAnimation,
      jni.JniType.voidType,
      [shown]).check();

  static final _id_getListAdapter = jniAccessors.getMethodIDOf(
      _classRef, "getListAdapter", "()Landroid/widget/ListAdapter;");

  /// from: public android.widget.ListAdapter getListAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the ListAdapter associated with this fragment's ListView.
  listadapter_.ListAdapter getListAdapter() =>
      listadapter_.ListAdapter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getListAdapter, jni.JniType.objectType, []).object);
}
