// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "FragmentHostCallback.dart" as fragmenthostcallback_;

import "FragmentManager.dart" as fragmentmanager_;

import "LoaderManager.dart" as loadermanager_;

import "Fragment.dart" as fragment_;

import "../view/View.dart" as view_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../os/Parcelable.dart" as parcelable_;

import "FragmentManagerNonConfig.dart" as fragmentmanagernonconfig_;

import "../content/res/Configuration.dart" as configuration_;

import "../view/Menu.dart" as menu_;

import "../view/MenuInflater.dart" as menuinflater_;

import "../view/MenuItem.dart" as menuitem_;

import "../util/ArrayMap.dart" as arraymap_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.FragmentController
///
/// Provides integration points with a FragmentManager for a fragment host.
///
/// It is the responsibility of the host to take care of the Fragment's lifecycle.
/// The methods provided by FragmentController are for that purpose.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentController
class FragmentController extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/FragmentController");
  FragmentController.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_createController = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createController",
      "(Landroid/app/FragmentHostCallback;)Landroid/app/FragmentController;");

  /// from: static public final android.app.FragmentController createController(android.app.FragmentHostCallback<?> callbacks)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a FragmentController.
  static FragmentController createController(
          fragmenthostcallback_.FragmentHostCallback callbacks) =>
      FragmentController.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createController,
          jni.JniType.objectType,
          [callbacks.reference]).object);

  static final _id_getFragmentManager = jniAccessors.getMethodIDOf(
      _classRef, "getFragmentManager", "()Landroid/app/FragmentManager;");

  /// from: public android.app.FragmentManager getFragmentManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a FragmentManager for this controller.
  fragmentmanager_.FragmentManager getFragmentManager() =>
      fragmentmanager_.FragmentManager.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFragmentManager,
          jni.JniType.objectType, []).object);

  static final _id_getLoaderManager = jniAccessors.getMethodIDOf(
      _classRef, "getLoaderManager", "()Landroid/app/LoaderManager;");

  /// from: public android.app.LoaderManager getLoaderManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a LoaderManager.
  loadermanager_.LoaderManager getLoaderManager() =>
      loadermanager_.LoaderManager.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLoaderManager, jni.JniType.objectType, []).object);

  static final _id_findFragmentByWho = jniAccessors.getMethodIDOf(_classRef,
      "findFragmentByWho", "(Ljava/lang/String;)Landroid/app/Fragment;");

  /// from: public android.app.Fragment findFragmentByWho(java.lang.String who)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a fragment with the given identifier.
  ///@return This value may be {@code null}.
  fragment_.Fragment findFragmentByWho(jni.JniString who) =>
      fragment_.Fragment.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findFragmentByWho,
          jni.JniType.objectType,
          [who.reference]).object);

  static final _id_attachHost = jniAccessors.getMethodIDOf(
      _classRef, "attachHost", "(Landroid/app/Fragment;)V");

  /// from: public void attachHost(android.app.Fragment parent)
  ///
  /// Attaches the host to the FragmentManager for this controller. The host must be
  /// attached before the FragmentManager can be used to manage Fragments.
  void attachHost(fragment_.Fragment parent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_attachHost,
      jni.JniType.voidType,
      [parent.reference]).check();

  static final _id_onCreateView = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Landroid/view/View;Ljava/lang/String;Landroid/content/Context;Landroid/util/AttributeSet;)Landroid/view/View;");

  /// from: public android.view.View onCreateView(android.view.View parent, java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiates a Fragment's view.
  ///@param parent The parent that the created view will be placed
  /// in; _note that this may be null_.
  ///@param name Tag name to be inflated.
  ///@param context The context the view is being created in.
  ///@param attrs Inflation attributes as specified in XML file.
  ///@return view the newly created view
  view_.View onCreateView(view_.View parent, jni.JniString name,
          context_.Context context, attributeset_.AttributeSet attrs) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCreateView, jni.JniType.objectType, [
        parent.reference,
        name.reference,
        context.reference,
        attrs.reference
      ]).object);

  static final _id_noteStateNotSaved =
      jniAccessors.getMethodIDOf(_classRef, "noteStateNotSaved", "()V");

  /// from: public void noteStateNotSaved()
  ///
  /// Marks the fragment state as unsaved. This allows for "state loss" detection.
  void noteStateNotSaved() => jniAccessors.callMethodWithArgs(
      reference, _id_noteStateNotSaved, jni.JniType.voidType, []).check();

  static final _id_saveAllState = jniAccessors.getMethodIDOf(
      _classRef, "saveAllState", "()Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable saveAllState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Saves the state for all Fragments.
  parcelable_.Parcelable saveAllState() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_saveAllState, jni.JniType.objectType, []).object);

  static final _id_restoreAllState = jniAccessors.getMethodIDOf(_classRef,
      "restoreAllState", "(Landroid/os/Parcelable;Ljava/util/List;)V");

  /// from: public void restoreAllState(android.os.Parcelable state, java.util.List<android.app.Fragment> nonConfigList)
  ///
  /// Restores the saved state for all Fragments. The given Fragment list are Fragment
  /// instances retained across configuration changes.
  ///@see \#retainNonConfig()
  ///@deprecated use \#restoreAllState(Parcelable, FragmentManagerNonConfig)
  void restoreAllState(
          parcelable_.Parcelable state, jni.JniObject nonConfigList) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_restoreAllState,
          jni.JniType.voidType,
          [state.reference, nonConfigList.reference]).check();

  static final _id_restoreAllState1 = jniAccessors.getMethodIDOf(
      _classRef,
      "restoreAllState",
      "(Landroid/os/Parcelable;Landroid/app/FragmentManagerNonConfig;)V");

  /// from: public void restoreAllState(android.os.Parcelable state, android.app.FragmentManagerNonConfig nonConfig)
  ///
  /// Restores the saved state for all Fragments. The given FragmentManagerNonConfig are Fragment
  /// instances retained across configuration changes, including nested fragments
  ///@see \#retainNestedNonConfig()
  void restoreAllState1(parcelable_.Parcelable state,
          fragmentmanagernonconfig_.FragmentManagerNonConfig nonConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_restoreAllState1,
          jni.JniType.voidType, [state.reference, nonConfig.reference]).check();

  static final _id_retainNonConfig = jniAccessors.getMethodIDOf(
      _classRef, "retainNonConfig", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.Fragment> retainNonConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of Fragments that have opted to retain their instance across
  /// configuration changes.
  ///@deprecated use \#retainNestedNonConfig() to also track retained
  ///             nested child fragments
  jni.JniObject retainNonConfig() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_retainNonConfig, jni.JniType.objectType, []).object);

  static final _id_retainNestedNonConfig = jniAccessors.getMethodIDOf(_classRef,
      "retainNestedNonConfig", "()Landroid/app/FragmentManagerNonConfig;");

  /// from: public android.app.FragmentManagerNonConfig retainNestedNonConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a nested tree of Fragments that have opted to retain their instance across
  /// configuration changes.
  fragmentmanagernonconfig_.FragmentManagerNonConfig retainNestedNonConfig() =>
      fragmentmanagernonconfig_.FragmentManagerNonConfig.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_retainNestedNonConfig,
              jni.JniType.objectType, []).object);

  static final _id_dispatchCreate =
      jniAccessors.getMethodIDOf(_classRef, "dispatchCreate", "()V");

  /// from: public void dispatchCreate()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the create state.
  /// Call when Fragments should be created.
  ///@see Fragment\#onCreate(Bundle)
  void dispatchCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchCreate, jni.JniType.voidType, []).check();

  static final _id_dispatchActivityCreated =
      jniAccessors.getMethodIDOf(_classRef, "dispatchActivityCreated", "()V");

  /// from: public void dispatchActivityCreated()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the activity created state.
  /// Call when Fragments should be informed their host has been created.
  ///@see Fragment\#onActivityCreated(Bundle)
  void dispatchActivityCreated() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchActivityCreated, jni.JniType.voidType, []).check();

  static final _id_dispatchStart =
      jniAccessors.getMethodIDOf(_classRef, "dispatchStart", "()V");

  /// from: public void dispatchStart()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the start state.
  /// Call when Fragments should be started.
  ///@see Fragment\#onStart()
  void dispatchStart() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchStart, jni.JniType.voidType, []).check();

  static final _id_dispatchResume =
      jniAccessors.getMethodIDOf(_classRef, "dispatchResume", "()V");

  /// from: public void dispatchResume()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the resume state.
  /// Call when Fragments should be resumed.
  ///@see Fragment\#onResume()
  void dispatchResume() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchResume, jni.JniType.voidType, []).check();

  static final _id_dispatchPause =
      jniAccessors.getMethodIDOf(_classRef, "dispatchPause", "()V");

  /// from: public void dispatchPause()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the pause state.
  /// Call when Fragments should be paused.
  ///@see Fragment\#onPause()
  void dispatchPause() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchPause, jni.JniType.voidType, []).check();

  static final _id_dispatchStop =
      jniAccessors.getMethodIDOf(_classRef, "dispatchStop", "()V");

  /// from: public void dispatchStop()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the stop state.
  /// Call when Fragments should be stopped.
  ///@see Fragment\#onStop()
  void dispatchStop() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchStop, jni.JniType.voidType, []).check();

  static final _id_dispatchDestroyView =
      jniAccessors.getMethodIDOf(_classRef, "dispatchDestroyView", "()V");

  /// from: public void dispatchDestroyView()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the destroy view state.
  /// Call when the Fragment's views should be destroyed.
  ///@see Fragment\#onDestroyView()
  void dispatchDestroyView() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchDestroyView, jni.JniType.voidType, []).check();

  static final _id_dispatchDestroy =
      jniAccessors.getMethodIDOf(_classRef, "dispatchDestroy", "()V");

  /// from: public void dispatchDestroy()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the destroy state.
  /// Call when Fragments should be destroyed.
  ///@see Fragment\#onDestroy()
  void dispatchDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchDestroy, jni.JniType.voidType, []).check();

  static final _id_dispatchMultiWindowModeChanged = jniAccessors.getMethodIDOf(
      _classRef, "dispatchMultiWindowModeChanged", "(Z)V");

  /// from: public void dispatchMultiWindowModeChanged(boolean isInMultiWindowMode)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager know the multi-window mode of
  /// the activity changed.
  /// Call when the multi-window mode of the activity changed.
  ///@see Fragment\#onMultiWindowModeChanged
  ///@deprecated use \#dispatchMultiWindowModeChanged(boolean, Configuration)
  void dispatchMultiWindowModeChanged(bool isInMultiWindowMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchMultiWindowModeChanged,
          jni.JniType.voidType,
          [isInMultiWindowMode]).check();

  static final _id_dispatchMultiWindowModeChanged1 = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchMultiWindowModeChanged",
      "(ZLandroid/content/res/Configuration;)V");

  /// from: public void dispatchMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager know the multi-window mode of
  /// the activity changed.
  /// Call when the multi-window mode of the activity changed.
  ///@see Fragment\#onMultiWindowModeChanged
  void dispatchMultiWindowModeChanged1(
          bool isInMultiWindowMode, configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchMultiWindowModeChanged1,
          jni.JniType.voidType,
          [isInMultiWindowMode, newConfig.reference]).check();

  static final _id_dispatchPictureInPictureModeChanged = jniAccessors
      .getMethodIDOf(_classRef, "dispatchPictureInPictureModeChanged", "(Z)V");

  /// from: public void dispatchPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager know the picture-in-picture
  /// mode of the activity changed.
  /// Call when the picture-in-picture mode of the activity changed.
  ///@see Fragment\#onPictureInPictureModeChanged
  ///@deprecated use \#dispatchPictureInPictureModeChanged(boolean, Configuration)
  void dispatchPictureInPictureModeChanged(bool isInPictureInPictureMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPictureInPictureModeChanged,
          jni.JniType.voidType,
          [isInPictureInPictureMode]).check();

  static final _id_dispatchPictureInPictureModeChanged1 =
      jniAccessors.getMethodIDOf(
          _classRef,
          "dispatchPictureInPictureModeChanged",
          "(ZLandroid/content/res/Configuration;)V");

  /// from: public void dispatchPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager know the picture-in-picture
  /// mode of the activity changed.
  /// Call when the picture-in-picture mode of the activity changed.
  ///@see Fragment\#onPictureInPictureModeChanged
  void dispatchPictureInPictureModeChanged1(bool isInPictureInPictureMode,
          configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPictureInPictureModeChanged1,
          jni.JniType.voidType,
          [isInPictureInPictureMode, newConfig.reference]).check();

  static final _id_dispatchConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void dispatchConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know a configuration change occurred.
  /// Call when there is a configuration change.
  ///@see Fragment\#onConfigurationChanged(Configuration)
  void dispatchConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchConfigurationChanged,
          jni.JniType.voidType,
          [newConfig.reference]).check();

  static final _id_dispatchLowMemory =
      jniAccessors.getMethodIDOf(_classRef, "dispatchLowMemory", "()V");

  /// from: public void dispatchLowMemory()
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know the device is in a low memory condition.
  /// Call when the device is low on memory and Fragment's should trim
  /// their memory usage.
  ///@see Fragment\#onLowMemory()
  void dispatchLowMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchLowMemory, jni.JniType.voidType, []).check();

  static final _id_dispatchTrimMemory =
      jniAccessors.getMethodIDOf(_classRef, "dispatchTrimMemory", "(I)V");

  /// from: public void dispatchTrimMemory(int level)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should trim their memory usage.
  /// Call when the Fragment can release allocated memory [such as if
  /// the Fragment is in the background].
  ///@see Fragment\#onTrimMemory(int)
  void dispatchTrimMemory(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchTrimMemory, jni.JniType.voidType, [level]).check();

  static final _id_dispatchCreateOptionsMenu = jniAccessors.getMethodIDOf(
      _classRef,
      "dispatchCreateOptionsMenu",
      "(Landroid/view/Menu;Landroid/view/MenuInflater;)Z");

  /// from: public boolean dispatchCreateOptionsMenu(android.view.Menu menu, android.view.MenuInflater inflater)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should create an options menu.
  /// Call when the Fragment should create an options menu.
  ///@return {@code true} if the options menu contains items to display
  ///@see Fragment\#onCreateOptionsMenu(Menu, MenuInflater)
  bool dispatchCreateOptionsMenu(
          menu_.Menu menu, menuinflater_.MenuInflater inflater) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchCreateOptionsMenu,
          jni.JniType.booleanType,
          [menu.reference, inflater.reference]).boolean;

  static final _id_dispatchPrepareOptionsMenu = jniAccessors.getMethodIDOf(
      _classRef, "dispatchPrepareOptionsMenu", "(Landroid/view/Menu;)Z");

  /// from: public boolean dispatchPrepareOptionsMenu(android.view.Menu menu)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should prepare their options menu for display.
  /// Call immediately before displaying the Fragment's options menu.
  ///@return {@code true} if the options menu contains items to display
  ///@see Fragment\#onPrepareOptionsMenu(Menu)
  bool dispatchPrepareOptionsMenu(menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchPrepareOptionsMenu,
          jni.JniType.booleanType, [menu.reference]).boolean;

  static final _id_dispatchOptionsItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "dispatchOptionsItemSelected", "(Landroid/view/MenuItem;)Z");

  /// from: public boolean dispatchOptionsItemSelected(android.view.MenuItem item)
  ///
  /// Sends an option item selection event to the Fragments managed by the
  /// controller's FragmentManager. Once the event has been consumed,
  /// no additional handling will be performed.
  /// Call immediately after an options menu item has been selected
  ///@return {@code true} if the options menu selection event was consumed
  ///@see Fragment\#onOptionsItemSelected(MenuItem)
  bool dispatchOptionsItemSelected(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchOptionsItemSelected,
          jni.JniType.booleanType,
          [item.reference]).boolean;

  static final _id_dispatchContextItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "dispatchContextItemSelected", "(Landroid/view/MenuItem;)Z");

  /// from: public boolean dispatchContextItemSelected(android.view.MenuItem item)
  ///
  /// Sends a context item selection event to the Fragments managed by the
  /// controller's FragmentManager. Once the event has been consumed,
  /// no additional handling will be performed.
  /// Call immediately after an options menu item has been selected
  ///@return {@code true} if the context menu selection event was consumed
  ///@see Fragment\#onContextItemSelected(MenuItem)
  bool dispatchContextItemSelected(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchContextItemSelected,
          jni.JniType.booleanType,
          [item.reference]).boolean;

  static final _id_dispatchOptionsMenuClosed = jniAccessors.getMethodIDOf(
      _classRef, "dispatchOptionsMenuClosed", "(Landroid/view/Menu;)V");

  /// from: public void dispatchOptionsMenuClosed(android.view.Menu menu)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know their options menu has closed.
  /// Call immediately after closing the Fragment's options menu.
  ///@see Fragment\#onOptionsMenuClosed(Menu)
  void dispatchOptionsMenuClosed(menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchOptionsMenuClosed,
          jni.JniType.voidType, [menu.reference]).check();

  static final _id_execPendingActions =
      jniAccessors.getMethodIDOf(_classRef, "execPendingActions", "()Z");

  /// from: public boolean execPendingActions()
  ///
  /// Execute any pending actions for the Fragments managed by the
  /// controller's FragmentManager.
  /// Call when queued actions can be performed [eg when the
  /// Fragment moves into a start or resume state].
  ///@return {@code true} if queued actions were performed
  bool execPendingActions() => jniAccessors.callMethodWithArgs(
      reference, _id_execPendingActions, jni.JniType.booleanType, []).boolean;

  static final _id_doLoaderStart =
      jniAccessors.getMethodIDOf(_classRef, "doLoaderStart", "()V");

  /// from: public void doLoaderStart()
  ///
  /// Starts the loaders.
  void doLoaderStart() => jniAccessors.callMethodWithArgs(
      reference, _id_doLoaderStart, jni.JniType.voidType, []).check();

  static final _id_doLoaderStop =
      jniAccessors.getMethodIDOf(_classRef, "doLoaderStop", "(Z)V");

  /// from: public void doLoaderStop(boolean retain)
  ///
  /// Stops the loaders, optionally retaining their state. This is useful for keeping the
  /// loader state across configuration changes.
  ///@param retain When {@code true}, the loaders aren't stopped, but, their instances
  /// are retained in a started state
  void doLoaderStop(bool retain) => jniAccessors.callMethodWithArgs(
      reference, _id_doLoaderStop, jni.JniType.voidType, [retain]).check();

  static final _id_doLoaderDestroy =
      jniAccessors.getMethodIDOf(_classRef, "doLoaderDestroy", "()V");

  /// from: public void doLoaderDestroy()
  ///
  /// Destroys the loaders and, if their state is not being retained, removes them.
  void doLoaderDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_doLoaderDestroy, jni.JniType.voidType, []).check();

  static final _id_reportLoaderStart =
      jniAccessors.getMethodIDOf(_classRef, "reportLoaderStart", "()V");

  /// from: public void reportLoaderStart()
  ///
  /// Lets the loaders know the host is ready to receive notifications.
  void reportLoaderStart() => jniAccessors.callMethodWithArgs(
      reference, _id_reportLoaderStart, jni.JniType.voidType, []).check();

  static final _id_retainLoaderNonConfig = jniAccessors.getMethodIDOf(
      _classRef, "retainLoaderNonConfig", "()Landroid/util/ArrayMap;");

  /// from: public android.util.ArrayMap<java.lang.String,android.app.LoaderManager> retainLoaderNonConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of LoaderManagers that have opted to retain their instance across
  /// configuration changes.
  arraymap_.ArrayMap retainLoaderNonConfig() =>
      arraymap_.ArrayMap.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_retainLoaderNonConfig, jni.JniType.objectType, []).object);

  static final _id_restoreLoaderNonConfig = jniAccessors.getMethodIDOf(
      _classRef, "restoreLoaderNonConfig", "(Landroid/util/ArrayMap;)V");

  /// from: public void restoreLoaderNonConfig(android.util.ArrayMap<java.lang.String,android.app.LoaderManager> loaderManagers)
  ///
  /// Restores the saved state for all LoaderManagers. The given LoaderManager list are
  /// LoaderManager instances retained across configuration changes.
  ///@see \#retainLoaderNonConfig()
  void restoreLoaderNonConfig(arraymap_.ArrayMap loaderManagers) =>
      jniAccessors.callMethodWithArgs(reference, _id_restoreLoaderNonConfig,
          jni.JniType.voidType, [loaderManagers.reference]).check();

  static final _id_dumpLoaders = jniAccessors.getMethodIDOf(
      _classRef,
      "dumpLoaders",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dumpLoaders(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Dumps the current state of the loaders.
  void dumpLoaders(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dumpLoaders, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();
}
