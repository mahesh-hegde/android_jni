// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/accessibility/AccessibilityNodeInfo.dart"
    as accessibilitynodeinfo_;

import "../accessibilityservice/AccessibilityServiceInfo.dart"
    as accessibilityserviceinfo_;

import "../view/InputEvent.dart" as inputevent_;

import "../view/accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../view/WindowContentFrameStats.dart" as windowcontentframestats_;

import "../view/WindowAnimationFrameStats.dart" as windowanimationframestats_;

import "../os/UserHandle.dart" as userhandle_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.UiAutomation
///
/// Class for interacting with the device's UI by simulation user actions and
/// introspection of the screen content. It relies on the platform accessibility
/// APIs to introspect the screen and to perform some actions on the remote view
/// tree. It also allows injecting of arbitrary raw input events simulating user
/// interaction with keyboards and touch devices. One can think of a UiAutomation
/// as a special type of android.accessibilityservice.AccessibilityService
/// which does not provide hooks for the service life cycle and exposes other
/// APIs that are useful for UI test automation.
///
/// The APIs exposed by this class are low-level to maximize flexibility when
/// developing UI test automation tools and libraries. Generally, a UiAutomation
/// client should be using a higher-level library or implement high-level functions.
/// For example, performing a tap on the screen requires construction and injecting
/// of a touch down and up events which have to be delivered to the system by a
/// call to \#injectInputEvent(InputEvent, boolean).
///
///
///
/// The APIs exposed by this class operate across applications enabling a client
/// to write tests that cover use cases spanning over multiple applications. For
/// example, going to the settings application to change a setting and then
/// interacting with another application whose behavior depends on that setting.
///
///
class UiAutomation extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/UiAutomation");
  UiAutomation.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES
  ///
  /// UiAutomation supresses accessibility services by default. This flag specifies that
  /// existing accessibility services should continue to run, and that new ones may start.
  /// This flag is set when obtaining the UiAutomation from
  /// Instrumentation\#getUiAutomation(int).
  static const FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES = 1;

  /// from: static public final int ROTATION_FREEZE_0
  ///
  /// Rotation constant: Freeze rotation to 0 degrees (natural orientation)
  static const ROTATION_FREEZE_0 = 0;

  /// from: static public final int ROTATION_FREEZE_180
  ///
  /// Rotation constant: Freeze rotation to 180 degrees .
  static const ROTATION_FREEZE_180 = 2;

  /// from: static public final int ROTATION_FREEZE_270
  ///
  /// Rotation constant: Freeze rotation to 270 degrees .
  static const ROTATION_FREEZE_270 = 3;

  /// from: static public final int ROTATION_FREEZE_90
  ///
  /// Rotation constant: Freeze rotation to 90 degrees .
  static const ROTATION_FREEZE_90 = 1;

  /// from: static public final int ROTATION_FREEZE_CURRENT
  ///
  /// Rotation constant: Freeze rotation to its current state.
  static const ROTATION_FREEZE_CURRENT = -1;

  /// from: static public final int ROTATION_UNFREEZE
  ///
  /// Rotation constant: Unfreeze rotation (rotating the device changes its rotation state).
  static const ROTATION_UNFREEZE = -2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UiAutomation()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setOnAccessibilityEventListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnAccessibilityEventListener",
      "(Landroid/app/UiAutomation\$OnAccessibilityEventListener;)V");

  /// from: public void setOnAccessibilityEventListener(android.app.UiAutomation.OnAccessibilityEventListener listener)
  ///
  /// Sets a callback for observing the stream of AccessibilityEvents.
  /// The callbacks are delivered on the main application thread.
  ///@param listener The callback.
  void setOnAccessibilityEventListener(
          UiAutomation_OnAccessibilityEventListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnAccessibilityEventListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_performGlobalAction =
      jniAccessors.getMethodIDOf(_classRef, "performGlobalAction", "(I)Z");

  /// from: public boolean performGlobalAction(int action)
  ///
  /// Performs a global action. Such an action can be performed at any moment
  /// regardless of the current application or user location in that application.
  /// For example going back, going home, opening recents, etc.
  ///@param action The action to perform.
  ///@return Whether the action was successfully performed.
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_BACK
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_HOME
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_NOTIFICATIONS
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_RECENTS
  bool performGlobalAction(int action) => jniAccessors.callMethodWithArgs(
      reference,
      _id_performGlobalAction,
      jni.JniType.booleanType,
      [action]).boolean;

  static final _id_findFocus = jniAccessors.getMethodIDOf(_classRef,
      "findFocus", "(I)Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo findFocus(int focus)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the view that has the specified focus type. The search is performed
  /// across all windows.
  ///
  /// <strong>Note:</strong> In order to access the windows you have to opt-in
  /// to retrieve the interactive windows by setting the
  /// AccessibilityServiceInfo\#FLAG_RETRIEVE_INTERACTIVE_WINDOWS flag.
  /// Otherwise, the search will be performed only in the active window.
  ///
  ///
  ///@param focus The focus to find. One of AccessibilityNodeInfo\#FOCUS_INPUT or
  ///         AccessibilityNodeInfo\#FOCUS_ACCESSIBILITY.
  ///@return The node info of the focused view or null.
  ///@see AccessibilityNodeInfo\#FOCUS_INPUT
  ///@see AccessibilityNodeInfo\#FOCUS_ACCESSIBILITY
  accessibilitynodeinfo_.AccessibilityNodeInfo findFocus(int focus) =>
      accessibilitynodeinfo_.AccessibilityNodeInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_findFocus, jni.JniType.objectType,
              [focus]).object);

  static final _id_getServiceInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getServiceInfo",
      "()Landroid/accessibilityservice/AccessibilityServiceInfo;");

  /// from: public android.accessibilityservice.AccessibilityServiceInfo getServiceInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the an AccessibilityServiceInfo describing this UiAutomation.
  /// This method is useful if one wants to change some of the dynamically
  /// configurable properties at runtime.
  ///@return The accessibility service info.
  ///@see AccessibilityServiceInfo
  accessibilityserviceinfo_.AccessibilityServiceInfo getServiceInfo() =>
      accessibilityserviceinfo_.AccessibilityServiceInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getServiceInfo,
              jni.JniType.objectType, []).object);

  static final _id_setServiceInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "setServiceInfo",
      "(Landroid/accessibilityservice/AccessibilityServiceInfo;)V");

  /// from: public void setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo info)
  ///
  /// Sets the AccessibilityServiceInfo that describes how this
  /// UiAutomation will be handled by the platform accessibility layer.
  ///@param info The info.
  ///@see AccessibilityServiceInfo
  void setServiceInfo(
          accessibilityserviceinfo_.AccessibilityServiceInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_setServiceInfo,
          jni.JniType.voidType, [info.reference]).check();

  static final _id_getWindows =
      jniAccessors.getMethodIDOf(_classRef, "getWindows", "()Ljava/util/List;");

  /// from: public java.util.List<android.view.accessibility.AccessibilityWindowInfo> getWindows()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the windows on the screen. This method returns only the windows
  /// that a sighted user can interact with, as opposed to all windows.
  /// For example, if there is a modal dialog shown and the user cannot touch
  /// anything behind it, then only the modal window will be reported
  /// (assuming it is the top one). For convenience the returned windows
  /// are ordered in a descending layer order, which is the windows that
  /// are higher in the Z-order are reported first.
  ///
  /// <strong>Note:</strong> In order to access the windows you have to opt-in
  /// to retrieve the interactive windows by setting the
  /// AccessibilityServiceInfo\#FLAG_RETRIEVE_INTERACTIVE_WINDOWS flag.
  ///
  ///
  ///@return The windows if there are windows such, otherwise an empty list.
  jni.JniObject getWindows() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindows, jni.JniType.objectType, []).object);

  static final _id_getRootInActiveWindow = jniAccessors.getMethodIDOf(
      _classRef,
      "getRootInActiveWindow",
      "()Landroid/view/accessibility/AccessibilityNodeInfo;");

  /// from: public android.view.accessibility.AccessibilityNodeInfo getRootInActiveWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the root AccessibilityNodeInfo in the active window.
  ///@return The root info.
  accessibilitynodeinfo_.AccessibilityNodeInfo getRootInActiveWindow() =>
      accessibilitynodeinfo_.AccessibilityNodeInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getRootInActiveWindow,
              jni.JniType.objectType, []).object);

  static final _id_injectInputEvent = jniAccessors.getMethodIDOf(
      _classRef, "injectInputEvent", "(Landroid/view/InputEvent;Z)Z");

  /// from: public boolean injectInputEvent(android.view.InputEvent event, boolean sync)
  ///
  /// A method for injecting an arbitrary input event.
  ///
  /// <strong>Note:</strong> It is caller's responsibility to recycle the event.
  ///
  ///
  ///@param event The event to inject.
  ///@param sync Whether to inject the event synchronously.
  ///@return Whether event injection succeeded.
  bool injectInputEvent(inputevent_.InputEvent event, bool sync0) =>
      jniAccessors.callMethodWithArgs(reference, _id_injectInputEvent,
          jni.JniType.booleanType, [event.reference, sync0]).boolean;

  static final _id_setRotation =
      jniAccessors.getMethodIDOf(_classRef, "setRotation", "(I)Z");

  /// from: public boolean setRotation(int rotation)
  ///
  /// Sets the device rotation. A client can freeze the rotation in
  /// desired state or freeze the rotation to its current state or
  /// unfreeze the rotation (rotating the device changes its rotation
  /// state).
  ///@param rotation The desired rotation.
  ///@return Whether the rotation was set successfully.
  ///@see \#ROTATION_FREEZE_0
  ///@see \#ROTATION_FREEZE_90
  ///@see \#ROTATION_FREEZE_180
  ///@see \#ROTATION_FREEZE_270
  ///@see \#ROTATION_FREEZE_CURRENT
  ///@see \#ROTATION_UNFREEZE
  bool setRotation(int rotation) => jniAccessors.callMethodWithArgs(
      reference, _id_setRotation, jni.JniType.booleanType, [rotation]).boolean;

  static final _id_executeAndWaitForEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "executeAndWaitForEvent",
      "(Ljava/lang/Runnable;Landroid/app/UiAutomation\$AccessibilityEventFilter;J)Landroid/view/accessibility/AccessibilityEvent;");

  /// from: public android.view.accessibility.AccessibilityEvent executeAndWaitForEvent(java.lang.Runnable command, android.app.UiAutomation.AccessibilityEventFilter filter, long timeoutMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Executes a command and waits for a specific accessibility event up to a
  /// given wait timeout. To detect a sequence of events one can implement a
  /// filter that keeps track of seen events of the expected sequence and
  /// returns true after the last event of that sequence is received.
  ///
  /// <strong>Note:</strong> It is caller's responsibility to recycle the returned event.
  ///
  ///
  ///@param command The command to execute.
  ///@param filter Filter that recognizes the expected event.
  ///@param timeoutMillis The wait timeout in milliseconds.
  ///@throws TimeoutException If the expected event is not received within the timeout.
  accessibilityevent_.AccessibilityEvent executeAndWaitForEvent(
          jni.JniObject command,
          UiAutomation_AccessibilityEventFilter filter,
          int timeoutMillis) =>
      accessibilityevent_.AccessibilityEvent.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_executeAndWaitForEvent,
              jni.JniType.objectType,
              [command.reference, filter.reference, timeoutMillis]).object);

  static final _id_waitForIdle =
      jniAccessors.getMethodIDOf(_classRef, "waitForIdle", "(JJ)V");

  /// from: public void waitForIdle(long idleTimeoutMillis, long globalTimeoutMillis)
  ///
  /// Waits for the accessibility event stream to become idle, which is not to
  /// have received an accessibility event within <code>idleTimeoutMillis</code>.
  /// The total time spent to wait for an idle accessibility event stream is bounded
  /// by the <code>globalTimeoutMillis</code>.
  ///@param idleTimeoutMillis The timeout in milliseconds between two events
  ///            to consider the device idle.
  ///@param globalTimeoutMillis The maximal global timeout in milliseconds in
  ///            which to wait for an idle state.
  ///@throws TimeoutException If no idle state was detected within
  ///            <code>globalTimeoutMillis.</code>
  void waitForIdle(int idleTimeoutMillis, int globalTimeoutMillis) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_waitForIdle,
          jni.JniType.voidType,
          [idleTimeoutMillis, globalTimeoutMillis]).check();

  static final _id_takeScreenshot = jniAccessors.getMethodIDOf(
      _classRef, "takeScreenshot", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap takeScreenshot()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Takes a screenshot.
  ///@return The screenshot bitmap on success, null otherwise.
  bitmap_.Bitmap takeScreenshot() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_takeScreenshot, jni.JniType.objectType, []).object);

  static final _id_setRunAsMonkey =
      jniAccessors.getMethodIDOf(_classRef, "setRunAsMonkey", "(Z)V");

  /// from: public void setRunAsMonkey(boolean enable)
  ///
  /// Sets whether this UiAutomation to run in a "monkey" mode. Applications can query whether
  /// they are executed in a "monkey" mode, i.e. run by a test framework, and avoid doing
  /// potentially undesirable actions such as calling 911 or posting on public forums etc.
  ///@param enable whether to run in a "monkey" mode or not. Default is not.
  ///@see ActivityManager\#isUserAMonkey()
  void setRunAsMonkey(bool enable) => jniAccessors.callMethodWithArgs(
      reference, _id_setRunAsMonkey, jni.JniType.voidType, [enable]).check();

  static final _id_clearWindowContentFrameStats = jniAccessors.getMethodIDOf(
      _classRef, "clearWindowContentFrameStats", "(I)Z");

  /// from: public boolean clearWindowContentFrameStats(int windowId)
  ///
  /// Clears the frame statistics for the content of a given window. These
  /// statistics contain information about the most recently rendered content
  /// frames.
  ///@param windowId The window id.
  ///@return Whether the window is present and its frame statistics
  ///         were cleared.
  ///@see android.view.WindowContentFrameStats
  ///@see \#getWindowContentFrameStats(int)
  ///@see \#getWindows()
  ///@see AccessibilityWindowInfo\#getId() AccessibilityWindowInfo.getId()
  bool clearWindowContentFrameStats(int windowId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_clearWindowContentFrameStats,
          jni.JniType.booleanType,
          [windowId]).boolean;

  static final _id_getWindowContentFrameStats = jniAccessors.getMethodIDOf(
      _classRef,
      "getWindowContentFrameStats",
      "(I)Landroid/view/WindowContentFrameStats;");

  /// from: public android.view.WindowContentFrameStats getWindowContentFrameStats(int windowId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the frame statistics for a given window. These statistics contain
  /// information about the most recently rendered content frames.
  ///
  /// A typical usage requires clearing the window frame statistics via \#clearWindowContentFrameStats(int) followed by an interaction with the UI and
  /// finally getting the window frame statistics via calling this method.
  ///
  ///
  /// <pre>
  /// // Assume we have at least one window.
  /// final int windowId = getWindows().get(0).getId();
  ///
  /// // Start with a clean slate.
  /// uiAutimation.clearWindowContentFrameStats(windowId);
  ///
  /// // Do stuff with the UI.
  ///
  /// // Get the frame statistics.
  /// WindowContentFrameStats stats = uiAutomation.getWindowContentFrameStats(windowId);
  /// </pre>
  ///@param windowId The window id.
  ///@return The window frame statistics, or null if the window is not present.
  ///@see android.view.WindowContentFrameStats
  ///@see \#clearWindowContentFrameStats(int)
  ///@see \#getWindows()
  ///@see AccessibilityWindowInfo\#getId() AccessibilityWindowInfo.getId()
  windowcontentframestats_.WindowContentFrameStats getWindowContentFrameStats(
          int windowId) =>
      windowcontentframestats_.WindowContentFrameStats.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getWindowContentFrameStats,
              jni.JniType.objectType, [windowId]).object);

  static final _id_clearWindowAnimationFrameStats = jniAccessors.getMethodIDOf(
      _classRef, "clearWindowAnimationFrameStats", "()V");

  /// from: public void clearWindowAnimationFrameStats()
  ///
  /// Clears the window animation rendering statistics. These statistics contain
  /// information about the most recently rendered window animation frames, i.e.
  /// for window transition animations.
  ///@see android.view.WindowAnimationFrameStats
  ///@see \#getWindowAnimationFrameStats()
  ///@see android.R.styleable\#WindowAnimation
  void clearWindowAnimationFrameStats() => jniAccessors.callMethodWithArgs(
      reference,
      _id_clearWindowAnimationFrameStats,
      jni.JniType.voidType, []).check();

  static final _id_getWindowAnimationFrameStats = jniAccessors.getMethodIDOf(
      _classRef,
      "getWindowAnimationFrameStats",
      "()Landroid/view/WindowAnimationFrameStats;");

  /// from: public android.view.WindowAnimationFrameStats getWindowAnimationFrameStats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the window animation frame statistics. These statistics contain
  /// information about the most recently rendered window animation frames, i.e.
  /// for window transition animations.
  ///
  ///
  /// A typical usage requires clearing the window animation frame statistics via
  /// \#clearWindowAnimationFrameStats() followed by an interaction that causes
  /// a window transition which uses a window animation and finally getting the window
  /// animation frame statistics by calling this method.
  ///
  ///
  /// <pre>
  /// // Start with a clean slate.
  /// uiAutimation.clearWindowAnimationFrameStats();
  ///
  /// // Do stuff to trigger a window transition.
  ///
  /// // Get the frame statistics.
  /// WindowAnimationFrameStats stats = uiAutomation.getWindowAnimationFrameStats();
  /// </pre>
  ///@return The window animation frame statistics.
  ///@see android.view.WindowAnimationFrameStats
  ///@see \#clearWindowAnimationFrameStats()
  ///@see android.R.styleable\#WindowAnimation
  windowanimationframestats_.WindowAnimationFrameStats
      getWindowAnimationFrameStats() =>
          windowanimationframestats_.WindowAnimationFrameStats.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_getWindowAnimationFrameStats,
                  jni.JniType.objectType, []).object);

  static final _id_grantRuntimePermission = jniAccessors.getMethodIDOf(
      _classRef,
      "grantRuntimePermission",
      "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void grantRuntimePermission(java.lang.String packageName, java.lang.String permission)
  ///
  /// Grants a runtime permission to a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to grant the permission.
  void grantRuntimePermission(
          jni.JniString packageName, jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_grantRuntimePermission,
          jni.JniType.voidType,
          [packageName.reference, permission.reference]).check();

  static final _id_grantRuntimePermissionAsUser = jniAccessors.getMethodIDOf(
      _classRef,
      "grantRuntimePermissionAsUser",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/os/UserHandle;)V");

  /// from: public void grantRuntimePermissionAsUser(java.lang.String packageName, java.lang.String permission, android.os.UserHandle userHandle)
  ///
  /// Grants a runtime permission to a package for a user.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to grant the permission.
  void grantRuntimePermissionAsUser(jni.JniString packageName,
          jni.JniString permission, userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_grantRuntimePermissionAsUser, jni.JniType.voidType, [
        packageName.reference,
        permission.reference,
        userHandle.reference
      ]).check();

  static final _id_revokeRuntimePermission = jniAccessors.getMethodIDOf(
      _classRef,
      "revokeRuntimePermission",
      "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void revokeRuntimePermission(java.lang.String packageName, java.lang.String permission)
  ///
  /// Revokes a runtime permission from a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to revoke the permission.
  void revokeRuntimePermission(
          jni.JniString packageName, jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_revokeRuntimePermission,
          jni.JniType.voidType,
          [packageName.reference, permission.reference]).check();

  static final _id_revokeRuntimePermissionAsUser = jniAccessors.getMethodIDOf(
      _classRef,
      "revokeRuntimePermissionAsUser",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/os/UserHandle;)V");

  /// from: public void revokeRuntimePermissionAsUser(java.lang.String packageName, java.lang.String permission, android.os.UserHandle userHandle)
  ///
  /// Revokes a runtime permission from a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to revoke the permission.
  void revokeRuntimePermissionAsUser(jni.JniString packageName,
          jni.JniString permission, userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_revokeRuntimePermissionAsUser, jni.JniType.voidType, [
        packageName.reference,
        permission.reference,
        userHandle.reference
      ]).check();

  static final _id_executeShellCommand = jniAccessors.getMethodIDOf(
      _classRef,
      "executeShellCommand",
      "(Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;");

  /// from: public android.os.ParcelFileDescriptor executeShellCommand(java.lang.String command)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Executes a shell command. This method returns a file descriptor that points
  /// to the standard output stream. The command execution is similar to running
  /// "adb shell <command>" from a host connected to the device.
  ///
  /// <strong>Note:</strong> It is your responsibility to close the returned file
  /// descriptor once you are done reading.
  ///
  ///
  ///@param command The command to execute.
  ///@return A file descriptor to the standard output stream.
  parcelfiledescriptor_.ParcelFileDescriptor executeShellCommand(
          jni.JniString command) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_executeShellCommand,
              jni.JniType.objectType, [command.reference]).object);
}

/// from: android.app.UiAutomation$OnAccessibilityEventListener
///
/// Listener for observing the AccessibilityEvent stream.
class UiAutomation_OnAccessibilityEventListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/UiAutomation\$OnAccessibilityEventListener");
  UiAutomation_OnAccessibilityEventListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onAccessibilityEvent = jniAccessors.getMethodIDOf(
      _classRef,
      "onAccessibilityEvent",
      "(Landroid/view/accessibility/AccessibilityEvent;)V");

  /// from: public abstract void onAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Callback for receiving an AccessibilityEvent.
  ///
  /// <strong>Note:</strong> This method is <strong>NOT</strong> executed
  /// on the main test thread. The client is responsible for proper
  /// synchronization.
  ///
  ///
  ///
  /// <strong>Note:</strong> It is responsibility of the client
  /// to recycle the received events to minimize object creation.
  ///
  ///
  ///@param event The received event.
  void onAccessibilityEvent(accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAccessibilityEvent,
          jni.JniType.voidType, [event.reference]).check();
}

/// from: android.app.UiAutomation$AccessibilityEventFilter
///
/// Listener for filtering accessibility events.
class UiAutomation_AccessibilityEventFilter extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/UiAutomation\$AccessibilityEventFilter");
  UiAutomation_AccessibilityEventFilter.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_accept = jniAccessors.getMethodIDOf(_classRef, "accept",
      "(Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public abstract boolean accept(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Callback for determining whether an event is accepted or
  /// it is filtered out.
  ///@param event The event to process.
  ///@return True if the event is accepted, false to filter it out.
  bool accept(accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_accept,
          jni.JniType.booleanType, [event.reference]).boolean;
}
