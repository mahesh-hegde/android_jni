// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/ContextWrapper.dart" as contextwrapper_;

import "Application.dart" as application_;

import "../content/Intent.dart" as intent_;

import "../content/res/Configuration.dart" as configuration_;

import "../os/IBinder.dart" as ibinder_;

import "Notification.dart" as notification_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.Service
///
/// A Service is an application component representing either an application's desire
/// to perform a longer-running operation while not interacting with the user
/// or to supply functionality for other applications to use.  Each service
/// class must have a corresponding
/// android.R.styleable\#AndroidManifestService &lt;service&gt;
/// declaration in its package's <code>AndroidManifest.xml</code>.  Services
/// can be started with
/// android.content.Context\#startService Context.startService() and
/// android.content.Context\#bindService Context.bindService().
///
/// Note that services, like other application objects, run in the main
/// thread of their hosting process.  This means that, if your service is going
/// to do any CPU intensive (such as MP3 playback) or blocking (such as
/// networking) operations, it should spawn its own thread in which to do that
/// work.  More information on this can be found in
/// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html">Processes and
/// Threads</a>.  The IntentService class is available
/// as a standard implementation of Service that has its own thread where it
/// schedules its work to be done.
///
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#WhatIsAService">What is a Service?</a>
/// <li><a href="\#ServiceLifecycle">Service Lifecycle</a>
/// <li><a href="\#Permissions">Permissions</a>
/// <li><a href="\#ProcessLifecycle">Process Lifecycle</a>
/// <li><a href="\#LocalServiceSample">Local Service Sample</a>
/// <li><a href="\#RemoteMessengerServiceSample">Remote Messenger Service Sample</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a detailed discussion about how to create services, read the
/// <a href="{@docRoot}guide/topics/fundamentals/services.html">Services</a> developer guide.
///
/// </div>
///
/// <a name="WhatIsAService"></a>
/// <h3>What is a Service?</h3>
///
/// Most confusion about the Service class actually revolves around what
/// it is _not_:
///
///
/// <ul>
/// <li> A Service is __not__ a separate process.  The Service object itself
/// does not imply it is running in its own process; unless otherwise specified,
/// it runs in the same process as the application it is part of.
/// <li> A Service is __not__ a thread.  It is not a means itself to do work off
/// of the main thread (to avoid Application Not Responding errors).
/// </ul>
///
/// Thus a Service itself is actually very simple, providing two main features:
///
///
/// <ul>
/// <li>A facility for the application to tell the system _about_
/// something it wants to be doing in the background (even when the user is not
/// directly interacting with the application).  This corresponds to calls to
/// android.content.Context\#startService Context.startService(), which
/// ask the system to schedule work for the service, to be run until the service
/// or someone else explicitly stop it.
/// <li>A facility for an application to expose some of its functionality to
/// other applications.  This corresponds to calls to
/// android.content.Context\#bindService Context.bindService(), which
/// allows a long-standing connection to be made to the service in order to
/// interact with it.
/// </ul>
///
/// When a Service component is actually created, for either of these reasons,
/// all that the system actually does is instantiate the component
/// and call its \#onCreate and any other appropriate callbacks on the
/// main thread.  It is up to the Service to implement these with the appropriate
/// behavior, such as creating a secondary thread in which it does its work.
///
///
/// Note that because Service itself is so simple, you can make your
/// interaction with it as simple or complicated as you want: from treating it
/// as a local Java object that you make direct method calls on (as illustrated
/// by <a href="\#LocalServiceSample">Local Service Sample</a>), to providing
/// a full remoteable interface using AIDL.
///
///
/// <a name="ServiceLifecycle"></a>
/// <h3>Service Lifecycle</h3>
///
/// There are two reasons that a service can be run by the system.  If someone
/// calls android.content.Context\#startService Context.startService() then the system will
/// retrieve the service (creating it and calling its \#onCreate method
/// if needed) and then call its \#onStartCommand method with the
/// arguments supplied by the client.  The service will at this point continue
/// running until android.content.Context\#stopService Context.stopService() or
/// \#stopSelf() is called.  Note that multiple calls to
/// Context.startService() do not nest (though they do result in multiple corresponding
/// calls to onStartCommand()), so no matter how many times it is started a service
/// will be stopped once Context.stopService() or stopSelf() is called; however,
/// services can use their \#stopSelf(int) method to ensure the service is
/// not stopped until started intents have been processed.
///
/// For started services, there are two additional major modes of operation
/// they can decide to run in, depending on the value they return from
/// onStartCommand(): \#START_STICKY is used for services that are
/// explicitly started and stopped as needed, while \#START_NOT_STICKY
/// or \#START_REDELIVER_INTENT are used for services that should only
/// remain running while processing any commands sent to them.  See the linked
/// documentation for more detail on the semantics.
///
/// Clients can also use android.content.Context\#bindService Context.bindService() to
/// obtain a persistent connection to a service.  This likewise creates the
/// service if it is not already running (calling \#onCreate while
/// doing so), but does not call onStartCommand().  The client will receive the
/// android.os.IBinder object that the service returns from its
/// \#onBind method, allowing the client to then make calls back
/// to the service.  The service will remain running as long as the connection
/// is established (whether or not the client retains a reference on the
/// service's IBinder).  Usually the IBinder returned is for a complex
/// interface that has been <a href="{@docRoot}guide/components/aidl.html">written
/// in aidl</a>.
///
/// A service can be both started and have connections bound to it.  In such
/// a case, the system will keep the service running as long as either it is
/// started _or_ there are one or more connections to it with the
/// android.content.Context\#BIND_AUTO_CREATE Context.BIND_AUTO_CREATE
/// flag.  Once neither
/// of these situations hold, the service's \#onDestroy method is called
/// and the service is effectively terminated.  All cleanup (stopping threads,
/// unregistering receivers) should be complete upon returning from onDestroy().
///
/// <a name="Permissions"></a>
/// <h3>Permissions</h3>
///
/// Global access to a service can be enforced when it is declared in its
/// manifest's android.R.styleable\#AndroidManifestService &lt;service&gt;
/// tag.  By doing so, other applications will need to declare a corresponding
/// android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt;
/// element in their own manifest to be able to start, stop, or bind to
/// the service.
///
/// As of android.os.Build.VERSION_CODES\#GINGERBREAD, when using
/// Context\#startService(Intent) Context.startService(Intent), you can
/// also set Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION on the Intent.  This will grant the
/// Service temporary access to the specific URIs in the Intent.  Access will
/// remain until the Service has called \#stopSelf(int) for that start
/// command or a later one, or until the Service has been completely stopped.
/// This works for granting access to the other apps that have not requested
/// the permission protecting the Service, or even when the Service is not
/// exported at all.
///
/// In addition, a service can protect individual IPC calls into it with
/// permissions, by calling the
/// \#checkCallingPermission
/// method before executing the implementation of that call.
///
/// See the <a href="{@docRoot}guide/topics/security/security.html">Security and Permissions</a>
/// document for more information on permissions and security in general.
///
/// <a name="ProcessLifecycle"></a>
/// <h3>Process Lifecycle</h3>
///
/// The Android system will attempt to keep the process hosting a service
/// around as long as the service has been started or has clients bound to it.
/// When running low on memory and needing to kill existing processes, the
/// priority of a process hosting the service will be the higher of the
/// following possibilities:
///
/// <ul>
/// <li>If the service is currently executing code in its
/// \#onCreate onCreate(), \#onStartCommand onStartCommand(),
/// or \#onDestroy onDestroy() methods, then the hosting process will
/// be a foreground process to ensure this code can execute without
/// being killed.
/// <li>If the service has been started, then its hosting process is considered
/// to be less important than any processes that are currently visible to the
/// user on-screen, but more important than any process not visible.  Because
/// only a few processes are generally visible to the user, this means that
/// the service should not be killed except in low memory conditions.  However, since
/// the user is not directly aware of a background service, in that state it _is_
/// considered a valid candidate to kill, and you should be prepared for this to
/// happen.  In particular, long-running services will be increasingly likely to
/// kill and are guaranteed to be killed (and restarted if appropriate) if they
/// remain started long enough.
/// <li>If there are clients bound to the service, then the service's hosting
/// process is never less important than the most important client.  That is,
/// if one of its clients is visible to the user, then the service itself is
/// considered to be visible.  The way a client's importance impacts the service's
/// importance can be adjusted through Context\#BIND_ABOVE_CLIENT,
/// Context\#BIND_ALLOW_OOM_MANAGEMENT, Context\#BIND_WAIVE_PRIORITY,
/// Context\#BIND_IMPORTANT, and Context\#BIND_ADJUST_WITH_ACTIVITY.
/// <li>A started service can use the \#startForeground(int, Notification)
/// API to put the service in a foreground state, where the system considers
/// it to be something the user is actively aware of and thus not a candidate
/// for killing when low on memory.  (It is still theoretically possible for
/// the service to be killed under extreme memory pressure from the current
/// foreground application, but in practice this should not be a concern.)
/// </ul>
///
/// Note this means that most of the time your service is running, it may
/// be killed by the system if it is under heavy memory pressure.  If this
/// happens, the system will later try to restart the service.  An important
/// consequence of this is that if you implement \#onStartCommand onStartCommand()
/// to schedule work to be done asynchronously or in another thread, then you
/// may want to use \#START_FLAG_REDELIVERY to have the system
/// re-deliver an Intent for you so that it does not get lost if your service
/// is killed while processing it.
///
/// Other application components running in the same process as the service
/// (such as an android.app.Activity) can, of course, increase the
/// importance of the overall
/// process beyond just the importance of the service itself.
///
/// <a name="LocalServiceSample"></a>
/// <h3>Local Service Sample</h3>
///
/// One of the most common uses of a Service is as a secondary component
/// running alongside other parts of an application, in the same process as
/// the rest of the components.  All components of an .apk run in the same
/// process unless explicitly stated otherwise, so this is a typical situation.
///
/// When used in this way, by assuming the
/// components are in the same process, you can greatly simplify the interaction
/// between them: clients of the service can simply cast the IBinder they
/// receive from it to a concrete class published by the service.
///
/// An example of this use of a Service is shown here.  First is the Service
/// itself, publishing a custom class when bound:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LocalService.java
///      service}
///
/// With that done, one can now write client code that directly accesses the
/// running service, such as:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LocalServiceActivities.java
///      bind}
///
/// <a name="RemoteMessengerServiceSample"></a>
/// <h3>Remote Messenger Service Sample</h3>
///
/// If you need to be able to write a Service that can perform complicated
/// communication with clients in remote processes (beyond simply the use of
/// Context\#startService(Intent) Context.startService to send
/// commands to it), then you can use the android.os.Messenger class
/// instead of writing full AIDL files.
///
/// An example of a Service that uses Messenger as its client interface
/// is shown here.  First is the Service itself, publishing a Messenger to
/// an internal Handler when bound:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/MessengerService.java
///      service}
///
/// If we want to make this service run in a remote process (instead of the
/// standard one for its .apk), we can use <code>android:process</code> in its
/// manifest tag to specify one:
///
/// {@sample development/samples/ApiDemos/AndroidManifest.xml remote_service_declaration}
///
/// Note that the name "remote" chosen here is arbitrary, and you can use
/// other names if you want additional processes.  The ':' prefix appends the
/// name to your package's standard process name.
///
/// With that done, clients can now bind to the service and send messages
/// to it.  Note that this allows clients to register with it to receive
/// messages back as well:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/MessengerServiceActivities.java
///      bind}
class Service extends contextwrapper_.ContextWrapper {
  static final _classRef = jniAccessors.getClassOf("android/app/Service");
  Service.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int START_CONTINUATION_MASK
  ///
  /// Bits returned by \#onStartCommand describing how to continue
  /// the service if it is killed.  May be \#START_STICKY,
  /// \#START_NOT_STICKY, \#START_REDELIVER_INTENT,
  /// or \#START_STICKY_COMPATIBILITY.
  static const START_CONTINUATION_MASK = 15;

  /// from: static public final int START_FLAG_REDELIVERY
  ///
  /// This flag is set in \#onStartCommand if the Intent is a
  /// re-delivery of a previously delivered intent, because the service
  /// had previously returned \#START_REDELIVER_INTENT but had been
  /// killed before calling \#stopSelf(int) for that Intent.
  static const START_FLAG_REDELIVERY = 1;

  /// from: static public final int START_FLAG_RETRY
  ///
  /// This flag is set in \#onStartCommand if the Intent is a
  /// retry because the original attempt never got to or returned from
  /// \#onStartCommand(Intent, int, int).
  static const START_FLAG_RETRY = 2;

  /// from: static public final int START_NOT_STICKY
  ///
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), and there are no new start intents to
  /// deliver to it, then take the service out of the started state and
  /// don't recreate until a future explicit call to
  /// Context\#startService Context.startService(Intent).  The
  /// service will not receive a \#onStartCommand(Intent, int, int)
  /// call with a null Intent because it will not be re-started if there
  /// are no pending Intents to deliver.
  ///
  /// This mode makes sense for things that want to do some work as a
  /// result of being started, but can be stopped when under memory pressure
  /// and will explicit start themselves again later to do more work.  An
  /// example of such a service would be one that polls for data from
  /// a server: it could schedule an alarm to poll every N minutes by having
  /// the alarm start its service.  When its \#onStartCommand is
  /// called from the alarm, it schedules a new alarm for N minutes later,
  /// and spawns a thread to do its networking.  If its process is killed
  /// while doing that check, the service will not be restarted until the
  /// alarm goes off.
  static const START_NOT_STICKY = 2;

  /// from: static public final int START_REDELIVER_INTENT
  ///
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), then it will be scheduled for a restart
  /// and the last delivered Intent re-delivered to it again via
  /// \#onStartCommand.  This Intent will remain scheduled for
  /// redelivery until the service calls \#stopSelf(int) with the
  /// start ID provided to \#onStartCommand.  The
  /// service will not receive a \#onStartCommand(Intent, int, int)
  /// call with a null Intent because it will will only be re-started if
  /// it is not finished processing all Intents sent to it (and any such
  /// pending events will be delivered at the point of restart).
  static const START_REDELIVER_INTENT = 3;

  /// from: static public final int START_STICKY
  ///
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), then leave it in the started state but
  /// don't retain this delivered intent.  Later the system will try to
  /// re-create the service.  Because it is in the started state, it will
  /// guarantee to call \#onStartCommand after creating the new
  /// service instance; if there are not any pending start commands to be
  /// delivered to the service, it will be called with a null intent
  /// object, so you must take care to check for this.
  ///
  /// This mode makes sense for things that will be explicitly started
  /// and stopped to run for arbitrary periods of time, such as a service
  /// performing background music playback.
  static const START_STICKY = 1;

  /// from: static public final int START_STICKY_COMPATIBILITY
  ///
  /// Constant to return from \#onStartCommand: compatibility
  /// version of \#START_STICKY that does not guarantee that
  /// \#onStartCommand will be called again after being killed.
  static const START_STICKY_COMPATIBILITY = 0;

  /// from: static public final int STOP_FOREGROUND_DETACH
  ///
  /// Flag for \#stopForeground(int): if set, the notification previously provided
  /// to \#startForeground will be detached from the service.  Only makes sense
  /// when \#STOP_FOREGROUND_REMOVE is __not__ set -- in this case, the notification
  /// will remain shown, but be completely detached from the service and so no longer changed
  /// except through direct calls to the notification manager.
  static const STOP_FOREGROUND_DETACH = 2;

  /// from: static public final int STOP_FOREGROUND_REMOVE
  ///
  /// Flag for \#stopForeground(int): if set, the notification previously provided
  /// to \#startForeground will be removed.  Otherwise it will remain
  /// until a later call (to \#startForeground(int, Notification) or
  /// \#stopForeground(int) removes it, or the service is destroyed.
  static const STOP_FOREGROUND_REMOVE = 1;

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Service.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_getApplication = jniAccessors.getMethodIDOf(
      _classRef, "getApplication", "()Landroid/app/Application;");

  /// from: public final android.app.Application getApplication()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the application that owns this service.
  application_.Application getApplication() =>
      application_.Application.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getApplication, jni.JniType.objectType, []).object);

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  ///
  /// Called by the system when the service is first created.  Do not call this method directly.
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onStart = jniAccessors.getMethodIDOf(
      _classRef, "onStart", "(Landroid/content/Intent;I)V");

  /// from: public void onStart(android.content.Intent intent, int startId)
  ///
  /// @deprecated Implement \#onStartCommand(Intent, int, int) instead.
  void onStart(intent_.Intent intent, int startId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStart,
          jni.JniType.voidType, [intent.reference, startId]).check();

  static final _id_onStartCommand = jniAccessors.getMethodIDOf(
      _classRef, "onStartCommand", "(Landroid/content/Intent;II)I");

  /// from: public int onStartCommand(android.content.Intent intent, int flags, int startId)
  ///
  /// Called by the system every time a client explicitly starts the service by calling
  /// android.content.Context\#startService, providing the arguments it supplied and a
  /// unique integer token representing the start request.  Do not call this method directly.
  ///
  /// For backwards compatibility, the default implementation calls
  /// \#onStart and returns either \#START_STICKY
  /// or \#START_STICKY_COMPATIBILITY.
  ///
  /// <p class="caution">Note that the system calls this on your
  /// service's main thread.  A service's main thread is the same
  /// thread where UI operations take place for Activities running in the
  /// same process.  You should always avoid stalling the main
  /// thread's event loop.  When doing long-running operations,
  /// network calls, or heavy disk I/O, you should kick off a new
  /// thread, or use android.os.AsyncTask.
  ///
  ///@param intent The Intent supplied to android.content.Context\#startService,
  /// as given.  This may be null if the service is being restarted after
  /// its process has gone away, and it had previously returned anything
  /// except \#START_STICKY_COMPATIBILITY.
  ///@param flags Additional data about this start request.
  /// Value is either <code>0</code> or a combination of android.app.Service\#START_FLAG_REDELIVERY, and android.app.Service\#START_FLAG_RETRY
  ///@param startId A unique integer representing this specific request to
  /// start.  Use with \#stopSelfResult(int).
  ///@return The return value indicates what semantics the system should
  /// use for the service's current started state.  It may be one of the
  /// constants associated with the \#START_CONTINUATION_MASK bits.
  ///
  /// Value is android.app.Service\#START_STICKY_COMPATIBILITY, android.app.Service\#START_STICKY, android.app.Service\#START_NOT_STICKY, or android.app.Service\#START_REDELIVER_INTENT
  ///@see \#stopSelfResult(int)
  int onStartCommand(intent_.Intent intent, int flags, int startId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartCommand,
          jni.JniType.intType, [intent.reference, flags, startId]).integer;

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  ///
  /// Called by the system to notify a Service that it is no longer used and is being removed.  The
  /// service should clean up any resources it holds (threads, registered
  /// receivers, etc) at this point.  Upon return, there will be no more calls
  /// in to this Service object and it is effectively dead.  Do not call this method directly.
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_onLowMemory =
      jniAccessors.getMethodIDOf(_classRef, "onLowMemory", "()V");

  /// from: public void onLowMemory()
  void onLowMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_onLowMemory, jni.JniType.voidType, []).check();

  static final _id_onTrimMemory =
      jniAccessors.getMethodIDOf(_classRef, "onTrimMemory", "(I)V");

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onTrimMemory, jni.JniType.voidType, [level]).check();

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public abstract android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the communication channel to the service.  May return null if
  /// clients can not bind to the service.  The returned
  /// android.os.IBinder is usually for a complex interface
  /// that has been <a href="{@docRoot}guide/components/aidl.html">described using
  /// aidl</a>.
  ///
  /// _Note that unlike other application components, calls on to the
  /// IBinder interface returned here may not happen on the main thread
  /// of the process_.  More information about the main thread can be found in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html">Processes and
  /// Threads</a>.
  ///
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  ///@return Return an IBinder through which clients can call on to the
  ///         service.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_onUnbind = jniAccessors.getMethodIDOf(
      _classRef, "onUnbind", "(Landroid/content/Intent;)Z");

  /// from: public boolean onUnbind(android.content.Intent intent)
  ///
  /// Called when all clients have disconnected from a particular interface
  /// published by the service.  The default implementation does nothing and
  /// returns false.
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  ///@return Return true if you would like to have the service's
  /// \#onRebind method later called when new clients bind to it.
  bool onUnbind(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onUnbind,
      jni.JniType.booleanType,
      [intent.reference]).boolean;

  static final _id_onRebind = jniAccessors.getMethodIDOf(
      _classRef, "onRebind", "(Landroid/content/Intent;)V");

  /// from: public void onRebind(android.content.Intent intent)
  ///
  /// Called when new clients have connected to the service, after it had
  /// previously been notified that all had disconnected in its
  /// \#onUnbind.  This will only be called if the implementation
  /// of \#onUnbind was overridden to return true.
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  void onRebind(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRebind,
      jni.JniType.voidType,
      [intent.reference]).check();

  static final _id_onTaskRemoved = jniAccessors.getMethodIDOf(
      _classRef, "onTaskRemoved", "(Landroid/content/Intent;)V");

  /// from: public void onTaskRemoved(android.content.Intent rootIntent)
  ///
  /// This is called if the service is currently running and the user has
  /// removed a task that comes from the service's application.  If you have
  /// set android.content.pm.ServiceInfo\#FLAG_STOP_WITH_TASK ServiceInfo.FLAG_STOP_WITH_TASK
  /// then you will not receive this callback; instead, the service will simply
  /// be stopped.
  ///@param rootIntent The original root Intent that was used to launch
  /// the task that is being removed.
  void onTaskRemoved(intent_.Intent rootIntent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTaskRemoved,
          jni.JniType.voidType, [rootIntent.reference]).check();

  static final _id_stopSelf =
      jniAccessors.getMethodIDOf(_classRef, "stopSelf", "()V");

  /// from: public final void stopSelf()
  ///
  /// Stop the service, if it was previously started.  This is the same as
  /// calling android.content.Context\#stopService for this particular service.
  ///@see \#stopSelfResult(int)
  void stopSelf() => jniAccessors.callMethodWithArgs(
      reference, _id_stopSelf, jni.JniType.voidType, []).check();

  static final _id_stopSelf1 =
      jniAccessors.getMethodIDOf(_classRef, "stopSelf", "(I)V");

  /// from: public final void stopSelf(int startId)
  ///
  /// Old version of \#stopSelfResult that doesn't return a result.
  ///@see \#stopSelfResult
  void stopSelf1(int startId) => jniAccessors.callMethodWithArgs(
      reference, _id_stopSelf1, jni.JniType.voidType, [startId]).check();

  static final _id_stopSelfResult =
      jniAccessors.getMethodIDOf(_classRef, "stopSelfResult", "(I)Z");

  /// from: public final boolean stopSelfResult(int startId)
  ///
  /// Stop the service if the most recent time it was started was
  /// <var>startId</var>.  This is the same as calling android.content.Context\#stopService for this particular service but allows you to
  /// safely avoid stopping if there is a start request from a client that you
  /// haven't yet seen in \#onStart.
  ///
  /// _Be careful about ordering of your calls to this function._.
  /// If you call this function with the most-recently received ID before
  /// you have called it for previously received IDs, the service will be
  /// immediately stopped anyway.  If you may end up processing IDs out
  /// of order (such as by dispatching them on separate threads), then you
  /// are responsible for stopping them in the same order you received them.
  ///
  ///@param startId The most recent start identifier received in \#onStart.
  ///@return Returns true if the startId matches the last start request
  /// and the service will be stopped, else false.
  ///@see \#stopSelf()
  bool stopSelfResult(int startId) => jniAccessors.callMethodWithArgs(reference,
      _id_stopSelfResult, jni.JniType.booleanType, [startId]).boolean;

  static final _id_startForeground = jniAccessors.getMethodIDOf(
      _classRef, "startForeground", "(ILandroid/app/Notification;)V");

  /// from: public final void startForeground(int id, android.app.Notification notification)
  ///
  /// If your service is started (running through Context\#startService(Intent)), then
  /// also make this service run in the foreground, supplying the ongoing
  /// notification to be shown to the user while in this state.
  /// By default started services are background, meaning that their process won't be given
  /// foreground CPU scheduling (unless something else in that process is foreground) and,
  /// if the system needs to kill them to reclaim more memory (such as to display a large page in a
  /// web browser), they can be killed without too much harm.  You use
  /// \#startForeground if killing your service would be disruptive to the user, such as
  /// if your service is performing background music playback, so the user
  /// would notice if their music stopped playing.
  ///
  /// Note that calling this method does _not_ put the service in the started state
  /// itself, even though the name sounds like it.  You must always call
  /// \#startService(Intent) first to tell the system it should keep the service running,
  /// and then use this method to tell it to keep it running harder.
  ///
  ///
  /// Apps targeting API android.os.Build.VERSION_CODES\#P or later must request
  /// the permission android.Manifest.permission\#FOREGROUND_SERVICE in order to use
  /// this API.
  ///
  ///@param id The identifier for this notification as per
  /// NotificationManager\#notify(int, Notification) NotificationManager.notify(int, Notification); must not be 0.
  ///@param notification The Notification to be displayed.
  ///@see \#stopForeground(boolean)
  void startForeground(int id, notification_.Notification notification) =>
      jniAccessors.callMethodWithArgs(reference, _id_startForeground,
          jni.JniType.voidType, [id, notification.reference]).check();

  static final _id_stopForeground =
      jniAccessors.getMethodIDOf(_classRef, "stopForeground", "(Z)V");

  /// from: public final void stopForeground(boolean removeNotification)
  ///
  /// Synonym for \#stopForeground(int).
  ///@param removeNotification If true, the \#STOP_FOREGROUND_REMOVE flag
  /// will be supplied.
  ///@see \#stopForeground(int)
  ///@see \#startForeground(int, Notification)
  void stopForeground(bool removeNotification) =>
      jniAccessors.callMethodWithArgs(reference, _id_stopForeground,
          jni.JniType.voidType, [removeNotification]).check();

  static final _id_stopForeground1 =
      jniAccessors.getMethodIDOf(_classRef, "stopForeground", "(I)V");

  /// from: public final void stopForeground(int flags)
  ///
  /// Remove this service from foreground state, allowing it to be killed if
  /// more memory is needed.  This does not stop the service from running (for that
  /// you use \#stopSelf() or related methods), just takes it out of the
  /// foreground state.
  ///@param flags additional behavior options.
  /// Value is either <code>0</code> or a combination of android.app.Service\#STOP_FOREGROUND_REMOVE, and android.app.Service\#STOP_FOREGROUND_DETACH
  ///@see \#startForeground(int, Notification)
  void stopForeground1(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_stopForeground1, jni.JniType.voidType, [flags]).check();

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Service's state into the given stream.  This gets invoked if
  /// you run "adb shell dumpsys activity service &lt;yourservicename&gt;"
  /// (note that for this command to work, the service must be running, and
  /// you must specify a fully-qualified service name).
  /// This is distinct from "dumpsys &lt;servicename&gt;", which only works for
  /// named system services and which invokes the IBinder\#dump method
  /// on the IBinder interface registered with ServiceManager.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniObject fd, jni.JniObject writer, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [fd.reference, writer.reference, args.reference]).check();
}
