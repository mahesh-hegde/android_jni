// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "PendingIntent.dart" as pendingintent_;

import "../os/Handler.dart" as handler_;

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.AlarmManager
///
/// This class provides access to the system alarm services.  These allow you
/// to schedule your application to be run at some point in the future.  When
/// an alarm goes off, the Intent that had been registered for it
/// is broadcast by the system, automatically starting the target application
/// if it is not already running.  Registered alarms are retained while the
/// device is asleep (and can optionally wake the device up if they go off
/// during that time), but will be cleared if it is turned off and rebooted.
///
/// The Alarm Manager holds a CPU wake lock as long as the alarm receiver's
/// onReceive() method is executing. This guarantees that the phone will not sleep
/// until you have finished handling the broadcast. Once onReceive() returns, the
/// Alarm Manager releases this wake lock. This means that the phone will in some
/// cases sleep as soon as your onReceive() method completes.  If your alarm receiver
/// called android.content.Context\#startService Context.startService(), it
/// is possible that the phone will sleep before the requested service is launched.
/// To prevent this, your BroadcastReceiver and Service will need to implement a
/// separate wake lock policy to ensure that the phone continues running until the
/// service becomes available.
///
/// __Note: The Alarm Manager is intended for cases where you want to have
/// your application code run at a specific time, even if your application is
/// not currently running.  For normal timing operations (ticks, timeouts,
/// etc) it is easier and much more efficient to use
/// android.os.Handler.__
///
/// <p class="caution"><strong>Note:</strong> Beginning with API 19
/// (android.os.Build.VERSION_CODES\#KITKAT) alarm delivery is inexact:
/// the OS will shift alarms in order to minimize wakeups and battery use.  There are
/// new APIs to support applications which need strict delivery guarantees; see
/// \#setWindow(int, long, long, PendingIntent) and
/// \#setExact(int, long, PendingIntent).  Applications whose {@code targetSdkVersion}
/// is earlier than API 19 will continue to see the previous behavior in which all
/// alarms are delivered exactly when requested.
class AlarmManager extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/AlarmManager");
  AlarmManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_NEXT_ALARM_CLOCK_CHANGED
  ///
  /// Broadcast Action: Sent after the value returned by
  /// \#getNextAlarmClock() has changed.
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  /// It is only sent to registered receivers.
  ///
  static const ACTION_NEXT_ALARM_CLOCK_CHANGED =
      "android.app.action.NEXT_ALARM_CLOCK_CHANGED";

  /// from: static public final int ELAPSED_REALTIME
  ///
  /// Alarm time in android.os.SystemClock\#elapsedRealtime SystemClock.elapsedRealtime() (time since boot, including sleep).
  /// This alarm does not wake the device up; if it goes off while the device
  /// is asleep, it will not be delivered until the next time the device
  /// wakes up.
  static const ELAPSED_REALTIME = 3;

  /// from: static public final int ELAPSED_REALTIME_WAKEUP
  ///
  /// Alarm time in android.os.SystemClock\#elapsedRealtime SystemClock.elapsedRealtime() (time since boot, including sleep),
  /// which will wake up the device when it goes off.
  static const ELAPSED_REALTIME_WAKEUP = 2;

  /// from: static public final long INTERVAL_DAY
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_DAY = 86400000;

  /// from: static public final long INTERVAL_FIFTEEN_MINUTES
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_FIFTEEN_MINUTES = 900000;

  /// from: static public final long INTERVAL_HALF_DAY
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HALF_DAY = 43200000;

  /// from: static public final long INTERVAL_HALF_HOUR
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HALF_HOUR = 1800000;

  /// from: static public final long INTERVAL_HOUR
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HOUR = 3600000;

  /// from: static public final int RTC
  ///
  /// Alarm time in System\#currentTimeMillis System.currentTimeMillis()
  /// (wall clock time in UTC).  This alarm does not wake the
  /// device up; if it goes off while the device is asleep, it will not be
  /// delivered until the next time the device wakes up.
  static const RTC = 1;

  /// from: static public final int RTC_WAKEUP
  ///
  /// Alarm time in System\#currentTimeMillis System.currentTimeMillis()
  /// (wall clock time in UTC), which will wake up the device when
  /// it goes off.
  static const RTC_WAKEUP = 0;

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(IJLandroid/app/PendingIntent;)V");

  /// from: public void set(int type, long triggerAtMillis, android.app.PendingIntent operation)
  ///
  /// Schedule an alarm.  __Note: for timing operations (ticks, timeouts,
  /// etc) it is easier and much more efficient to use android.os.Handler.__
  /// If there is already an alarm scheduled for the same IntentSender, that previous
  /// alarm will first be canceled.
  ///
  /// If the stated trigger time is in the past, the alarm will be triggered
  /// immediately.  If there is already an alarm for this Intent
  /// scheduled (with the equality of two intents being defined by
  /// Intent\#filterEquals), then it will be removed and replaced by
  /// this one.
  ///
  ///
  /// The alarm is an Intent broadcast that goes to a broadcast receiver that
  /// you registered with android.content.Context\#registerReceiver
  /// or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.
  ///
  ///
  /// Alarm intents are delivered with a data extra of type int called
  /// Intent\#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT that indicates
  /// how many past alarm events have been accumulated into this intent
  /// broadcast.  Recurring alarms that have gone undelivered because the
  /// phone was asleep may have a count greater than one when delivered.
  ///
  /// <div class="note">
  ///
  /// __Note:__ Beginning in API 19, the trigger time passed to this method
  /// is treated as inexact: the alarm will not be delivered before this time, but
  /// may be deferred and delivered some time later.  The OS will use
  /// this policy in order to "batch" alarms together across the entire system,
  /// minimizing the number of times the device needs to "wake up" and minimizing
  /// battery use.  In general, alarms scheduled in the near future will not
  /// be deferred as long as alarms scheduled far in the future.
  ///
  ///
  /// With the new batching policy, delivery ordering guarantees are not as
  /// strong as they were previously.  If the application sets multiple alarms,
  /// it is possible that these alarms' _actual_ delivery ordering may not match
  /// the order of their _requested_ delivery times.  If your application has
  /// strong ordering requirements there are other APIs that you can use to get
  /// the necessary behavior; see \#setWindow(int, long, long, PendingIntent)
  /// and \#setExact(int, long, PendingIntent).
  ///
  ///
  /// Applications whose {@code targetSdkVersion} is before API 19 will
  /// continue to get the previous alarm behavior: all of their scheduled alarms
  /// will be treated as exact.
  /// </div>
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  /// off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#setExact
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void set0(int type, int triggerAtMillis,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(reference, _id_set0, jni.JniType.voidType,
          [type, triggerAtMillis, operation.reference]).check();

  static final _id_set1 = jniAccessors.getMethodIDOf(_classRef, "set",
      "(IJLjava/lang/String;Landroid/app/AlarmManager\$OnAlarmListener;Landroid/os/Handler;)V");

  /// from: public void set(int type, long triggerAtMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  ///
  /// Direct callback version of \#set(int, long, PendingIntent).  Rather than
  /// supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener's OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///         off, using the appropriate clock (depending on the alarm type).
  ///@param tag string describing the alarm, used for logging and battery-use
  ///         attribution
  ///@param listener OnAlarmListener instance whose
  ///         OnAlarmListener\#onAlarm() onAlarm() method will be
  ///         called when the alarm time is reached.  A given OnAlarmListener instance can
  ///         only be the target of a single pending alarm, just as a given PendingIntent
  ///         can only be used with one alarm at a time.
  ///@param targetHandler Handler on which to execute the listener's onAlarm()
  ///         callback, or {@code null} to run that callback on the main looper.
  void set1(
          int type,
          int triggerAtMillis,
          jni.JniString tag,
          AlarmManager_OnAlarmListener listener,
          handler_.Handler targetHandler) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_set1, jni.JniType.voidType, [
        type,
        triggerAtMillis,
        tag.reference,
        listener.reference,
        targetHandler.reference
      ]).check();

  static final _id_setRepeating = jniAccessors.getMethodIDOf(
      _classRef, "setRepeating", "(IJJLandroid/app/PendingIntent;)V");

  /// from: public void setRepeating(int type, long triggerAtMillis, long intervalMillis, android.app.PendingIntent operation)
  ///
  /// Schedule a repeating alarm.  __Note: for timing operations (ticks,
  /// timeouts, etc) it is easier and much more efficient to use
  /// android.os.Handler.__  If there is already an alarm scheduled
  /// for the same IntentSender, it will first be canceled.
  ///
  /// Like \#set, except you can also supply a period at which
  /// the alarm will automatically repeat.  This alarm continues
  /// repeating until explicitly removed with \#cancel.  If the stated
  /// trigger time is in the past, the alarm will be triggered immediately, with an
  /// alarm count depending on how far in the past the trigger time is relative
  /// to the repeat interval.
  ///
  /// If an alarm is delayed (by system sleep, for example, for non
  /// _WAKEUP alarm types), a skipped repeat will be delivered as soon as
  /// possible.  After that, future alarms will be delivered according to the
  /// original schedule; they do not drift over time.  For example, if you have
  /// set a recurring alarm for the top of every hour but the phone was asleep
  /// from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
  /// then the next alarm will be sent at 9:00.
  ///
  /// If your application wants to allow the delivery times to drift in
  /// order to guarantee that at least a certain time interval always elapses
  /// between alarms, then the approach to take is to use one-time alarms,
  /// scheduling the next one yourself when handling each alarm delivery.
  ///
  /// <p class="note">
  /// __Note:__ as of API 19, all repeating alarms are inexact.  If your
  /// application needs precise delivery times then it must use one-time
  /// exact alarms, rescheduling each time as described above. Legacy applications
  /// whose {@code targetSdkVersion} is earlier than API 19 will continue to have all
  /// of their alarms, including repeating alarms, treated as exact.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should first
  /// go off, using the appropriate clock (depending on the alarm type).
  ///@param intervalMillis interval in milliseconds between subsequent repeats
  /// of the alarm.
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#set
  ///@see \#setExact
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setRepeating(int type, int triggerAtMillis, int intervalMillis,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRepeating,
          jni.JniType.voidType,
          [type, triggerAtMillis, intervalMillis, operation.reference]).check();

  static final _id_setWindow = jniAccessors.getMethodIDOf(
      _classRef, "setWindow", "(IJJLandroid/app/PendingIntent;)V");

  /// from: public void setWindow(int type, long windowStartMillis, long windowLengthMillis, android.app.PendingIntent operation)
  ///
  /// Schedule an alarm to be delivered within a given window of time.  This method
  /// is similar to \#set(int, long, PendingIntent), but allows the
  /// application to precisely control the degree to which its delivery might be
  /// adjusted by the OS. This method allows an application to take advantage of the
  /// battery optimizations that arise from delivery batching even when it has
  /// modest timeliness requirements for its alarms.
  ///
  ///
  /// This method can also be used to achieve strict ordering guarantees among
  /// multiple alarms by ensuring that the windows requested for each alarm do
  /// not intersect.
  ///
  ///
  /// When precise delivery is not required, applications should use the standard
  /// \#set(int, long, PendingIntent) method.  This will give the OS the most
  /// flexibility to minimize wakeups and battery use.  For alarms that must be delivered
  /// at precisely-specified times with no acceptable variation, applications can use
  /// \#setExact(int, long, PendingIntent).
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param windowStartMillis The earliest time, in milliseconds, that the alarm should
  ///        be delivered, expressed in the appropriate clock's units (depending on the alarm
  ///        type).
  ///@param windowLengthMillis The length of the requested delivery window,
  ///        in milliseconds.  The alarm will be delivered no later than this many
  ///        milliseconds after {@code windowStartMillis}.  Note that this parameter
  ///        is a <i>duration,</i> not the timestamp of the end of the window.
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setExact
  ///@see \#setRepeating
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setWindow(int type, int windowStartMillis, int windowLengthMillis,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setWindow, jni.JniType.voidType, [
        type,
        windowStartMillis,
        windowLengthMillis,
        operation.reference
      ]).check();

  static final _id_setWindow1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setWindow",
      "(IJJLjava/lang/String;Landroid/app/AlarmManager\$OnAlarmListener;Landroid/os/Handler;)V");

  /// from: public void setWindow(int type, long windowStartMillis, long windowLengthMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  ///
  /// Direct callback version of \#setWindow(int, long, long, PendingIntent).  Rather
  /// than supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  void setWindow1(
          int type,
          int windowStartMillis,
          int windowLengthMillis,
          jni.JniString tag,
          AlarmManager_OnAlarmListener listener,
          handler_.Handler targetHandler) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_setWindow1, jni.JniType.voidType, [
        type,
        windowStartMillis,
        windowLengthMillis,
        tag.reference,
        listener.reference,
        targetHandler.reference
      ]).check();

  static final _id_setExact = jniAccessors.getMethodIDOf(
      _classRef, "setExact", "(IJLandroid/app/PendingIntent;)V");

  /// from: public void setExact(int type, long triggerAtMillis, android.app.PendingIntent operation)
  ///
  /// Schedule an alarm to be delivered precisely at the stated time.
  ///
  ///
  /// This method is like \#set(int, long, PendingIntent), but does not permit
  /// the OS to adjust the delivery time.  The alarm will be delivered as nearly as
  /// possible to the requested trigger time.
  ///
  ///
  /// __Note:__ only alarms for which there is a strong demand for exact-time
  /// delivery (such as an alarm clock ringing at the requested time) should be
  /// scheduled as exact.  Applications are strongly discouraged from using exact
  /// alarms unnecessarily as they reduce the OS's ability to minimize battery use.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///        off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setExact(int type, int triggerAtMillis,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setExact,
          jni.JniType.voidType,
          [type, triggerAtMillis, operation.reference]).check();

  static final _id_setExact1 = jniAccessors.getMethodIDOf(_classRef, "setExact",
      "(IJLjava/lang/String;Landroid/app/AlarmManager\$OnAlarmListener;Landroid/os/Handler;)V");

  /// from: public void setExact(int type, long triggerAtMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  ///
  /// Direct callback version of \#setExact(int, long, PendingIntent).  Rather
  /// than supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener's OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  void setExact1(
          int type,
          int triggerAtMillis,
          jni.JniString tag,
          AlarmManager_OnAlarmListener listener,
          handler_.Handler targetHandler) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_setExact1, jni.JniType.voidType, [
        type,
        triggerAtMillis,
        tag.reference,
        listener.reference,
        targetHandler.reference
      ]).check();

  static final _id_setAlarmClock = jniAccessors.getMethodIDOf(
      _classRef,
      "setAlarmClock",
      "(Landroid/app/AlarmManager\$AlarmClockInfo;Landroid/app/PendingIntent;)V");

  /// from: public void setAlarmClock(android.app.AlarmManager.AlarmClockInfo info, android.app.PendingIntent operation)
  ///
  /// Schedule an alarm that represents an alarm clock, which will be used to notify the user
  /// when it goes off.  The expectation is that when this alarm triggers, the application will
  /// further wake up the device to tell the user about the alarm -- turning on the screen,
  /// playing a sound, vibrating, etc.  As such, the system will typically also use the
  /// information supplied here to tell the user about this upcoming alarm if appropriate.
  ///
  /// Due to the nature of this kind of alarm, similar to \#setExactAndAllowWhileIdle,
  /// these alarms will be allowed to trigger even if the system is in a low-power idle
  /// (a.k.a. doze) mode.  The system may also do some prep-work when it sees that such an
  /// alarm coming up, to reduce the amount of background work that could happen if this
  /// causes the device to fully wake up -- this is to avoid situations such as a large number
  /// of devices having an alarm set at the same time in the morning, all waking up at that
  /// time and suddenly swamping the network with pending background work.  As such, these
  /// types of alarms can be extremely expensive on battery use and should only be used for
  /// their intended purpose.
  ///
  ///
  ///
  /// This method is like \#setExact(int, long, PendingIntent), but implies
  /// \#RTC_WAKEUP.
  ///@param info
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#setExact
  ///@see \#cancel
  ///@see \#getNextAlarmClock()
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  void setAlarmClock(AlarmManager_AlarmClockInfo info,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAlarmClock,
          jni.JniType.voidType, [info.reference, operation.reference]).check();

  static final _id_setInexactRepeating = jniAccessors.getMethodIDOf(
      _classRef, "setInexactRepeating", "(IJJLandroid/app/PendingIntent;)V");

  /// from: public void setInexactRepeating(int type, long triggerAtMillis, long intervalMillis, android.app.PendingIntent operation)
  ///
  /// Schedule a repeating alarm that has inexact trigger time requirements;
  /// for example, an alarm that repeats every hour, but not necessarily at
  /// the top of every hour.  These alarms are more power-efficient than
  /// the strict recurrences traditionally supplied by \#setRepeating, since the
  /// system can adjust alarms' delivery times to cause them to fire simultaneously,
  /// avoiding waking the device from sleep more than necessary.
  ///
  /// Your alarm's first trigger will not be before the requested time,
  /// but it might not occur for almost a full interval after that time.  In
  /// addition, while the overall period of the repeating alarm will be as
  /// requested, the time between any two successive firings of the alarm
  /// may vary.  If your application demands very low jitter, use
  /// one-shot alarms with an appropriate window instead; see \#setWindow(int, long, long, PendingIntent) and
  /// \#setExact(int, long, PendingIntent).
  ///
  /// <p class="note">
  /// As of API 19, all repeating alarms are inexact.  Because this method has
  /// been available since API 3, your application can safely call it and be
  /// assured that it will get similar behavior on both current and older versions
  /// of Android.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should first
  /// go off, using the appropriate clock (depending on the alarm type).  This
  /// is inexact: the alarm will not fire before this time, but there may be a
  /// delay of almost an entire alarm interval before the first invocation of
  /// the alarm.
  ///@param intervalMillis interval in milliseconds between subsequent repeats
  /// of the alarm.  Prior to API 19, if this is one of INTERVAL_FIFTEEN_MINUTES,
  /// INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY
  /// then the alarm will be phase-aligned with other alarms to reduce the
  /// number of wakeups.  Otherwise, the alarm will be set as though the
  /// application had called \#setRepeating.  As of API 19, all repeating
  /// alarms will be inexact and subject to batching with other alarms regardless
  /// of their stated repeat interval.
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#set
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  ///@see \#INTERVAL_FIFTEEN_MINUTES
  ///@see \#INTERVAL_HALF_HOUR
  ///@see \#INTERVAL_HOUR
  ///@see \#INTERVAL_HALF_DAY
  ///@see \#INTERVAL_DAY
  void setInexactRepeating(int type, int triggerAtMillis, int intervalMillis,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setInexactRepeating,
          jni.JniType.voidType,
          [type, triggerAtMillis, intervalMillis, operation.reference]).check();

  static final _id_setAndAllowWhileIdle = jniAccessors.getMethodIDOf(
      _classRef, "setAndAllowWhileIdle", "(IJLandroid/app/PendingIntent;)V");

  /// from: public void setAndAllowWhileIdle(int type, long triggerAtMillis, android.app.PendingIntent operation)
  ///
  /// Like \#set(int, long, PendingIntent), but this alarm will be allowed to execute
  /// even when the system is in low-power idle (a.k.a. doze) modes.  This type of alarm must
  /// __only__ be used for situations where it is actually required that the alarm go off while
  /// in idle -- a reasonable example would be for a calendar notification that should make a
  /// sound so the user is aware of it.  When the alarm is dispatched, the app will also be
  /// added to the system's temporary whitelist for approximately 10 seconds to allow that
  /// application to acquire further wake locks in which to complete its work.
  ///
  ///
  /// These alarms can significantly impact the power use
  /// of the device when idle (and thus cause significant battery blame to the app scheduling
  /// them), so they should be used with care.  To reduce abuse, there are restrictions on how
  /// frequently these alarms will go off for a particular application.
  /// Under normal system operation, it will not dispatch these
  /// alarms more than about every minute (at which point every such pending alarm is
  /// dispatched); when in low-power idle modes this duration may be significantly longer,
  /// such as 15 minutes.
  ///
  ///
  /// Unlike other alarms, the system is free to reschedule this type of alarm to happen
  /// out of order with any other alarms, even those from the same app.  This will clearly happen
  /// when the device is idle (since this alarm can go off while idle, when any other alarms
  /// from the app will be held until later), but may also happen even when not idle.
  ///
  ///
  /// Regardless of the app's target SDK version, this call always allows batching of the
  /// alarm.
  ///
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  /// off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set(int, long, PendingIntent)
  ///@see \#setExactAndAllowWhileIdle
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setAndAllowWhileIdle(int type, int triggerAtMillis,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAndAllowWhileIdle,
          jni.JniType.voidType,
          [type, triggerAtMillis, operation.reference]).check();

  static final _id_setExactAndAllowWhileIdle = jniAccessors.getMethodIDOf(
      _classRef,
      "setExactAndAllowWhileIdle",
      "(IJLandroid/app/PendingIntent;)V");

  /// from: public void setExactAndAllowWhileIdle(int type, long triggerAtMillis, android.app.PendingIntent operation)
  ///
  /// Like \#setExact(int, long, PendingIntent), but this alarm will be allowed to execute
  /// even when the system is in low-power idle modes.  If you don't need exact scheduling of
  /// the alarm but still need to execute while idle, consider using
  /// \#setAndAllowWhileIdle.  This type of alarm must __only__
  /// be used for situations where it is actually required that the alarm go off while in
  /// idle -- a reasonable example would be for a calendar notification that should make a
  /// sound so the user is aware of it.  When the alarm is dispatched, the app will also be
  /// added to the system's temporary whitelist for approximately 10 seconds to allow that
  /// application to acquire further wake locks in which to complete its work.
  ///
  ///
  /// These alarms can significantly impact the power use
  /// of the device when idle (and thus cause significant battery blame to the app scheduling
  /// them), so they should be used with care.  To reduce abuse, there are restrictions on how
  /// frequently these alarms will go off for a particular application.
  /// Under normal system operation, it will not dispatch these
  /// alarms more than about every minute (at which point every such pending alarm is
  /// dispatched); when in low-power idle modes this duration may be significantly longer,
  /// such as 15 minutes.
  ///
  ///
  /// Unlike other alarms, the system is free to reschedule this type of alarm to happen
  /// out of order with any other alarms, even those from the same app.  This will clearly happen
  /// when the device is idle (since this alarm can go off while idle, when any other alarms
  /// from the app will be held until later), but may also happen even when not idle.
  /// Note that the OS will allow itself more flexibility for scheduling these alarms than
  /// regular exact alarms, since the application has opted into this behavior.  When the
  /// device is idle it may take even more liberties with scheduling in order to optimize
  /// for battery life.
  ///
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///        off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setExactAndAllowWhileIdle(int type, int triggerAtMillis,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setExactAndAllowWhileIdle,
          jni.JniType.voidType,
          [type, triggerAtMillis, operation.reference]).check();

  static final _id_cancel = jniAccessors.getMethodIDOf(
      _classRef, "cancel", "(Landroid/app/PendingIntent;)V");

  /// from: public void cancel(android.app.PendingIntent operation)
  ///
  /// Remove any alarms with a matching Intent.
  /// Any alarm, of any type, whose Intent matches this one (as defined by
  /// Intent\#filterEquals), will be canceled.
  ///@param operation IntentSender which matches a previously added
  /// IntentSender. This parameter must not be {@code null}.
  ///@see \#set
  void cancel(pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(reference, _id_cancel,
          jni.JniType.voidType, [operation.reference]).check();

  static final _id_cancel1 = jniAccessors.getMethodIDOf(
      _classRef, "cancel", "(Landroid/app/AlarmManager\$OnAlarmListener;)V");

  /// from: public void cancel(android.app.AlarmManager.OnAlarmListener listener)
  ///
  /// Remove any alarm scheduled to be delivered to the given OnAlarmListener.
  ///@param listener OnAlarmListener instance that is the target of a currently-set alarm.
  void cancel1(AlarmManager_OnAlarmListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_cancel1,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setTime =
      jniAccessors.getMethodIDOf(_classRef, "setTime", "(J)V");

  /// from: public void setTime(long millis)
  ///
  /// Set the system wall clock time.
  /// Requires the permission android.permission.SET_TIME.
  ///@param millis time in milliseconds since the Epoch
  void setTime(int millis) => jniAccessors.callMethodWithArgs(
      reference, _id_setTime, jni.JniType.voidType, [millis]).check();

  static final _id_setTimeZone = jniAccessors.getMethodIDOf(
      _classRef, "setTimeZone", "(Ljava/lang/String;)V");

  /// from: public void setTimeZone(java.lang.String timeZone)
  ///
  /// Sets the system's persistent default time zone. This is the time zone for all apps, even
  /// after a reboot. Use java.util.TimeZone\#setDefault if you just want to change the
  /// time zone within your app, and even then prefer to pass an explicit
  /// java.util.TimeZone to APIs that require it rather than changing the time zone for
  /// all threads.
  ///
  ///  On android M and above, it is an error to pass in a non-Olson timezone to this
  /// function. Note that this is a bad idea on all Android releases because POSIX and
  /// the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
  /// in the same non-Olson ID.
  ///@param timeZone one of the Olson ids from the list returned by
  ///     java.util.TimeZone\#getAvailableIDs
  void setTimeZone(jni.JniString timeZone) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTimeZone,
      jni.JniType.voidType,
      [timeZone.reference]).check();

  static final _id_getNextAlarmClock = jniAccessors.getMethodIDOf(_classRef,
      "getNextAlarmClock", "()Landroid/app/AlarmManager\$AlarmClockInfo;");

  /// from: public android.app.AlarmManager.AlarmClockInfo getNextAlarmClock()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets information about the next alarm clock currently scheduled.
  ///
  /// The alarm clocks considered are those scheduled by any application
  /// using the \#setAlarmClock method.
  ///@return An AlarmClockInfo object describing the next upcoming alarm
  ///   clock event that will occur.  If there are no alarm clock events currently
  ///   scheduled, this method will return {@code null}.
  ///@see \#setAlarmClock
  ///@see AlarmClockInfo
  ///@see \#ACTION_NEXT_ALARM_CLOCK_CHANGED
  AlarmManager_AlarmClockInfo getNextAlarmClock() =>
      AlarmManager_AlarmClockInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNextAlarmClock, jni.JniType.objectType, []).object);
}

/// from: android.app.AlarmManager$OnAlarmListener
///
/// Direct-notification alarms: the requester must be running continuously from the
/// time the alarm is set to the time it is delivered, or delivery will fail.  Only
/// one-shot alarms can be set using this mechanism, not repeating alarms.
class AlarmManager_OnAlarmListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/AlarmManager\$OnAlarmListener");
  AlarmManager_OnAlarmListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onAlarm =
      jniAccessors.getMethodIDOf(_classRef, "onAlarm", "()V");

  /// from: public abstract void onAlarm()
  ///
  /// Callback method that is invoked by the system when the alarm time is reached.
  void onAlarm() => jniAccessors.callMethodWithArgs(
      reference, _id_onAlarm, jni.JniType.voidType, []).check();
}

/// from: android.app.AlarmManager$AlarmClockInfo
///
/// An immutable description of a scheduled "alarm clock" event.
///@see AlarmManager\#setAlarmClock
///@see AlarmManager\#getNextAlarmClock
class AlarmManager_AlarmClockInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/AlarmManager\$AlarmClockInfo");
  AlarmManager_AlarmClockInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.AlarmManager.AlarmClockInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(JLandroid/app/PendingIntent;)V");

  /// from: public void <init>(long triggerTime, android.app.PendingIntent showIntent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new alarm clock description.
  ///@param triggerTime time at which the underlying alarm is triggered in wall time
  ///                    milliseconds since the epoch
  ///@param showIntent an intent that can be used to show or edit details of
  ///                        the alarm clock.
  AlarmManager_AlarmClockInfo(
      int triggerTime, pendingintent_.PendingIntent showIntent)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [triggerTime, showIntent.reference]).object);

  static final _id_getTriggerTime =
      jniAccessors.getMethodIDOf(_classRef, "getTriggerTime", "()J");

  /// from: public long getTriggerTime()
  ///
  /// Returns the time at which the alarm is going to trigger.
  ///
  /// This value is UTC wall clock time in milliseconds, as returned by
  /// System\#currentTimeMillis() for example.
  int getTriggerTime() => jniAccessors.callMethodWithArgs(
      reference, _id_getTriggerTime, jni.JniType.longType, []).long;

  static final _id_getShowIntent = jniAccessors.getMethodIDOf(
      _classRef, "getShowIntent", "()Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getShowIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an intent that can be used to show or edit details of the alarm clock in
  /// the application that scheduled it.
  ///
  /// <p class="note">Beware that any application can retrieve and send this intent,
  /// potentially with additional fields filled in. See
  /// PendingIntent\#send(android.content.Context, int, android.content.Intent) PendingIntent.send() and android.content.Intent\#fillIn Intent.fillIn()
  /// for details.
  pendingintent_.PendingIntent getShowIntent() =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getShowIntent, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
