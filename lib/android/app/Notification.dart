// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../media/AudioAttributes.dart" as audioattributes_;

import "../os/Parcelable.dart" as parcelable_;

import "../widget/RemoteViews.dart" as remoteviews_;

import "PendingIntent.dart" as pendingintent_;

import "../os/Bundle.dart" as bundle_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../net/Uri.dart" as uri_;

import "../os/Parcel.dart" as parcel_;

import "../graphics/drawable/Icon.dart" as icon_;

import "Person.dart" as person_;

import "../media/session/MediaSession.dart" as mediasession_;

import "RemoteInput.dart" as remoteinput_;

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.Notification
///
/// A class that represents how a persistent notification is to be presented to
/// the user using the android.app.NotificationManager.
///
/// The Notification.Builder Notification.Builder has been added to make it
/// easier to construct Notifications.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a guide to creating notifications, read the
/// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html">Status Bar Notifications</a>
/// developer guide.
///
/// </div>
class Notification extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/Notification");
  Notification.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_AUDIO_ATTRIBUTES_DEFAULT = jniAccessors.getStaticFieldIDOf(
      _classRef, "AUDIO_ATTRIBUTES_DEFAULT", "Landroid/media/AudioAttributes;");

  /// from: static public final android.media.AudioAttributes AUDIO_ATTRIBUTES_DEFAULT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default value of \#audioAttributes.
  static audioattributes_.AudioAttributes get AUDIO_ATTRIBUTES_DEFAULT =>
      audioattributes_.AudioAttributes.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_AUDIO_ATTRIBUTES_DEFAULT, jni.JniType.objectType)
          .object);

  /// from: static public final int BADGE_ICON_LARGE
  ///
  /// If this notification is being shown as a badge, use the \#getLargeIcon() to
  /// represent this notification.
  static const BADGE_ICON_LARGE = 2;

  /// from: static public final int BADGE_ICON_NONE
  ///
  /// If this notification is being shown as a badge, always show as a number.
  static const BADGE_ICON_NONE = 0;

  /// from: static public final int BADGE_ICON_SMALL
  ///
  /// If this notification is being shown as a badge, use the \#getSmallIcon() to
  /// represent this notification.
  static const BADGE_ICON_SMALL = 1;

  /// from: static public final java.lang.String CATEGORY_ALARM
  ///
  /// Notification category: alarm or timer.
  static const CATEGORY_ALARM = "alarm";

  /// from: static public final java.lang.String CATEGORY_CALL
  ///
  /// Notification category: incoming call (voice or video) or similar synchronous communication request.
  static const CATEGORY_CALL = "call";

  /// from: static public final java.lang.String CATEGORY_EMAIL
  ///
  /// Notification category: asynchronous bulk message (email).
  static const CATEGORY_EMAIL = "email";

  /// from: static public final java.lang.String CATEGORY_ERROR
  ///
  /// Notification category: error in background operation or authentication status.
  static const CATEGORY_ERROR = "err";

  /// from: static public final java.lang.String CATEGORY_EVENT
  ///
  /// Notification category: calendar event.
  static const CATEGORY_EVENT = "event";

  /// from: static public final java.lang.String CATEGORY_MESSAGE
  ///
  /// Notification category: incoming direct message (SMS, instant message, etc.).
  static const CATEGORY_MESSAGE = "msg";

  /// from: static public final java.lang.String CATEGORY_NAVIGATION
  ///
  /// Notification category: map turn-by-turn navigation.
  static const CATEGORY_NAVIGATION = "navigation";

  /// from: static public final java.lang.String CATEGORY_PROGRESS
  ///
  /// Notification category: progress of a long-running background operation.
  static const CATEGORY_PROGRESS = "progress";

  /// from: static public final java.lang.String CATEGORY_PROMO
  ///
  /// Notification category: promotion or advertisement.
  static const CATEGORY_PROMO = "promo";

  /// from: static public final java.lang.String CATEGORY_RECOMMENDATION
  ///
  /// Notification category: a specific, timely recommendation for a single thing.
  /// For example, a news app might want to recommend a news story it believes the user will
  /// want to read next.
  static const CATEGORY_RECOMMENDATION = "recommendation";

  /// from: static public final java.lang.String CATEGORY_REMINDER
  ///
  /// Notification category: user-scheduled reminder.
  static const CATEGORY_REMINDER = "reminder";

  /// from: static public final java.lang.String CATEGORY_SERVICE
  ///
  /// Notification category: indication of running background service.
  static const CATEGORY_SERVICE = "service";

  /// from: static public final java.lang.String CATEGORY_SOCIAL
  ///
  /// Notification category: social network or sharing update.
  static const CATEGORY_SOCIAL = "social";

  /// from: static public final java.lang.String CATEGORY_STATUS
  ///
  /// Notification category: ongoing information about device or contextual status.
  static const CATEGORY_STATUS = "status";

  /// from: static public final java.lang.String CATEGORY_SYSTEM
  ///
  /// Notification category: system or device status update.  Reserved for system use.
  static const CATEGORY_SYSTEM = "sys";

  /// from: static public final java.lang.String CATEGORY_TRANSPORT
  ///
  /// Notification category: media transport control for playback.
  static const CATEGORY_TRANSPORT = "transport";

  /// from: static public final int COLOR_DEFAULT
  ///
  /// Special value of \#color telling the system not to decorate this notification with
  /// any special color but instead use default colors when presenting this notification.
  static const COLOR_DEFAULT = 0;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.Notification> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parcelable.Creator that instantiates Notification objects
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int DEFAULT_ALL
  ///
  /// Use all default values (where applicable).
  static const DEFAULT_ALL = -1;

  /// from: static public final int DEFAULT_LIGHTS
  ///
  /// Use the default notification lights. This will ignore the
  /// \#FLAG_SHOW_LIGHTS bit, and \#ledARGB, \#ledOffMS, or
  /// \#ledOnMS.
  ///@see \#defaults
  static const DEFAULT_LIGHTS = 4;

  /// from: static public final int DEFAULT_SOUND
  ///
  /// Use the default notification sound. This will ignore any given
  /// \#sound.
  ///
  ///
  /// A notification that is noisy is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@see \#defaults
  static const DEFAULT_SOUND = 1;

  /// from: static public final int DEFAULT_VIBRATE
  ///
  /// Use the default notification vibrate. This will ignore any given
  /// \#vibrate. Using phone vibration requires the
  /// android.Manifest.permission\#VIBRATE VIBRATE permission.
  ///
  ///
  /// A notification that vibrates is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@see \#defaults
  static const DEFAULT_VIBRATE = 2;

  /// from: static public final java.lang.String EXTRA_AUDIO_CONTENTS_URI
  ///
  /// \#extras key: the audio contents of this notification.
  ///
  /// This is for use when rendering the notification on an audio-focused interface;
  /// the audio contents are a complete sound sample that contains the contents/body of the
  /// notification. This may be used in substitute of a Text-to-Speech reading of the
  /// notification. For example if the notification represents a voice message this should point
  /// to the audio of that message.
  ///
  /// The data stored under this key should be a String representation of a Uri that contains the
  /// audio contents in one of the following formats: WAV, PCM 16-bit, AMR-WB.
  ///
  /// This extra is unnecessary if you are using {@code MessagingStyle} since each {@code Message}
  /// has a field for holding data URI. That field can be used for audio.
  /// See {@code Message\#setData}.
  ///
  /// Example usage:
  /// <pre>
  /// {@code
  /// Notification.Builder myBuilder = (build your Notification as normal);
  /// myBuilder.getExtras().putString(EXTRA_AUDIO_CONTENTS_URI, myAudioUri.toString());
  /// }
  /// </pre>
  static const EXTRA_AUDIO_CONTENTS_URI = "android.audioContents";

  /// from: static public final java.lang.String EXTRA_BACKGROUND_IMAGE_URI
  ///
  /// \#extras key: A
  /// android.content.ContentUris content URI pointing to an image that can be displayed
  /// in the background when the notification is selected. Used on television platforms.
  /// The URI must point to an image stream suitable for passing into
  /// android.graphics.BitmapFactory\#decodeStream(java.io.InputStream) BitmapFactory.decodeStream; all other content types will be ignored.
  static const EXTRA_BACKGROUND_IMAGE_URI = "android.backgroundImageUri";

  /// from: static public final java.lang.String EXTRA_BIG_TEXT
  ///
  /// \#extras key: this is the longer text shown in the big form of a
  /// BigTextStyle notification, as supplied to
  /// BigTextStyle\#bigText(CharSequence).
  static const EXTRA_BIG_TEXT = "android.bigText";

  /// from: static public final java.lang.String EXTRA_CHANNEL_GROUP_ID
  ///
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain a NotificationChannelGroup\#getId() group id that can be used to narrow down
  /// what settings should be shown in the target app.
  static const EXTRA_CHANNEL_GROUP_ID = "android.intent.extra.CHANNEL_GROUP_ID";

  /// from: static public final java.lang.String EXTRA_CHANNEL_ID
  ///
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain a NotificationChannel\#getId() channel id that can be used to narrow down
  /// what settings should be shown in the target app.
  static const EXTRA_CHANNEL_ID = "android.intent.extra.CHANNEL_ID";

  /// from: static public final java.lang.String EXTRA_CHRONOMETER_COUNT_DOWN
  ///
  /// \#extras key: whether the chronometer set on the notification should count down
  /// instead of counting up. Is only relevant if key \#EXTRA_SHOW_CHRONOMETER is present.
  /// This extra is a boolean. The default is false.
  static const EXTRA_CHRONOMETER_COUNT_DOWN = "android.chronometerCountDown";

  /// from: static public final java.lang.String EXTRA_COLORIZED
  ///
  /// \#extras key: whether the notification should be colorized as
  /// supplied to Builder\#setColorized(boolean)}.
  static const EXTRA_COLORIZED = "android.colorized";

  /// from: static public final java.lang.String EXTRA_COMPACT_ACTIONS
  ///
  /// \#extras key: the indices of actions to be shown in the compact view,
  /// as supplied to (e.g.) MediaStyle\#setShowActionsInCompactView(int...).
  static const EXTRA_COMPACT_ACTIONS = "android.compactActions";

  /// from: static public final java.lang.String EXTRA_CONVERSATION_TITLE
  ///
  /// \#extras key: a CharSequence to be displayed as the title to a conversation
  /// represented by a android.app.Notification.MessagingStyle
  static const EXTRA_CONVERSATION_TITLE = "android.conversationTitle";

  /// from: static public final java.lang.String EXTRA_HISTORIC_MESSAGES
  ///
  /// \#extras key: an array of
  /// android.app.Notification.MessagingStyle\#addHistoricMessage historic
  /// android.app.Notification.MessagingStyle.Message bundles provided by a
  /// android.app.Notification.MessagingStyle notification. This extra is a parcelable
  /// array of bundles.
  static const EXTRA_HISTORIC_MESSAGES = "android.messages.historic";

  /// from: static public final java.lang.String EXTRA_INFO_TEXT
  ///
  /// \#extras key: this is a small piece of additional text as supplied to
  /// Builder\#setContentInfo(CharSequence).
  static const EXTRA_INFO_TEXT = "android.infoText";

  /// from: static public final java.lang.String EXTRA_IS_GROUP_CONVERSATION
  ///
  /// \#extras key: whether the android.app.Notification.MessagingStyle notification
  /// represents a group conversation.
  static const EXTRA_IS_GROUP_CONVERSATION = "android.isGroupConversation";

  /// from: static public final java.lang.String EXTRA_LARGE_ICON
  ///
  /// \#extras key: this is a bitmap to be used instead of the small icon when showing the
  /// notification payload, as
  /// supplied to Builder\#setLargeIcon(android.graphics.Bitmap).
  ///@deprecated Use \#getLargeIcon(), which supports a wider variety of icon sources.
  static const EXTRA_LARGE_ICON = "android.largeIcon";

  /// from: static public final java.lang.String EXTRA_LARGE_ICON_BIG
  ///
  /// \#extras key: this is a bitmap to be used instead of the one from
  /// Builder\#setLargeIcon(android.graphics.Bitmap) when the notification is
  /// shown in its expanded form, as supplied to
  /// BigPictureStyle\#bigLargeIcon(android.graphics.Bitmap).
  static const EXTRA_LARGE_ICON_BIG = "android.largeIcon.big";

  /// from: static public final java.lang.String EXTRA_MEDIA_SESSION
  ///
  /// \#extras key: A
  /// android.media.session.MediaSession.Token associated with a
  /// android.app.Notification.MediaStyle notification.
  static const EXTRA_MEDIA_SESSION = "android.mediaSession";

  /// from: static public final java.lang.String EXTRA_MESSAGES
  ///
  /// \#extras key: an array of android.app.Notification.MessagingStyle.Message
  /// bundles provided by a
  /// android.app.Notification.MessagingStyle notification. This extra is a parcelable
  /// array of bundles.
  static const EXTRA_MESSAGES = "android.messages";

  /// from: static public final java.lang.String EXTRA_MESSAGING_PERSON
  ///
  /// \#extras key: the person to be displayed for all messages sent by the user including
  /// direct replies
  /// android.app.Notification.MessagingStyle notification. This extra is a
  /// Person
  static const EXTRA_MESSAGING_PERSON = "android.messagingUser";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_ID
  ///
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain the id provided to NotificationManager\#notify(String, int, Notification)
  /// that can be used to narrow down what settings should be shown in the target app.
  static const EXTRA_NOTIFICATION_ID = "android.intent.extra.NOTIFICATION_ID";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_TAG
  ///
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain the tag provided to NotificationManager\#notify(String, int, Notification)
  /// that can be used to narrow down what settings should be shown in the target app.
  static const EXTRA_NOTIFICATION_TAG = "android.intent.extra.NOTIFICATION_TAG";

  /// from: static public final java.lang.String EXTRA_PEOPLE
  ///
  /// \#extras key: A String array containing the people that this notification relates to,
  /// each of which was supplied to Builder\#addPerson(String).
  ///@deprecated the actual objects are now in \#EXTRA_PEOPLE_LIST
  static const EXTRA_PEOPLE = "android.people";

  /// from: static public final java.lang.String EXTRA_PEOPLE_LIST
  ///
  /// \#extras key: An arrayList of Person objects containing the people that
  /// this notification relates to.
  static const EXTRA_PEOPLE_LIST = "android.people.list";

  /// from: static public final java.lang.String EXTRA_PICTURE
  ///
  /// \#extras key: this is a bitmap to be shown in BigPictureStyle expanded
  /// notifications, supplied to BigPictureStyle\#bigPicture(android.graphics.Bitmap).
  static const EXTRA_PICTURE = "android.picture";

  /// from: static public final java.lang.String EXTRA_PROGRESS
  ///
  /// \#extras key: this is the progress value supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS = "android.progress";

  /// from: static public final java.lang.String EXTRA_PROGRESS_INDETERMINATE
  ///
  /// \#extras key: whether the progress bar is indeterminate, supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS_INDETERMINATE = "android.progressIndeterminate";

  /// from: static public final java.lang.String EXTRA_PROGRESS_MAX
  ///
  /// \#extras key: this is the maximum value supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS_MAX = "android.progressMax";

  /// from: static public final java.lang.String EXTRA_REMOTE_INPUT_DRAFT
  ///
  /// If the notification contained an unsent draft for a RemoteInput when the user clicked on it,
  /// we're adding the draft as a String extra to the \#contentIntent using this key.
  ///
  /// Apps may use this extra to prepopulate text fields in the app, where the user usually
  /// sends messages.
  ///
  static const EXTRA_REMOTE_INPUT_DRAFT = "android.remoteInputDraft";

  /// from: static public final java.lang.String EXTRA_REMOTE_INPUT_HISTORY
  ///
  /// \#extras key: this is the remote input history, as supplied to
  /// Builder\#setRemoteInputHistory(CharSequence[]).
  ///
  /// Apps can fill this through Builder\#setRemoteInputHistory(CharSequence[])
  /// with the most recent inputs that have been sent through a RemoteInput of this
  /// Notification and are expected to clear it once the it is no longer relevant (e.g. for chat
  /// notifications once the other party has responded).
  ///
  /// The extra with this key is of type CharSequence[] and contains the most recent entry at
  /// the 0 index, the second most recent at the 1 index, etc.
  ///@see Builder\#setRemoteInputHistory(CharSequence[])
  static const EXTRA_REMOTE_INPUT_HISTORY = "android.remoteInputHistory";

  /// from: static public final java.lang.String EXTRA_SELF_DISPLAY_NAME
  ///
  /// \#extras key: the username to be displayed for all messages sent by the user including
  /// direct replies
  /// android.app.Notification.MessagingStyle notification. This extra is a
  /// CharSequence
  ///@deprecated use \#EXTRA_MESSAGING_PERSON
  static const EXTRA_SELF_DISPLAY_NAME = "android.selfDisplayName";

  /// from: static public final java.lang.String EXTRA_SHOW_CHRONOMETER
  ///
  /// \#extras key: whether \#when should be shown as a count-up timer (specifically
  /// a android.widget.Chronometer) instead of a timestamp, as supplied to
  /// Builder\#setUsesChronometer(boolean).
  static const EXTRA_SHOW_CHRONOMETER = "android.showChronometer";

  /// from: static public final java.lang.String EXTRA_SHOW_WHEN
  ///
  /// \#extras key: whether \#when should be shown,
  /// as supplied to Builder\#setShowWhen(boolean).
  static const EXTRA_SHOW_WHEN = "android.showWhen";

  /// from: static public final java.lang.String EXTRA_SMALL_ICON
  ///
  /// \#extras key: this is the resource ID of the notification's main small icon, as
  /// supplied to Builder\#setSmallIcon(int).
  ///@deprecated Use \#getSmallIcon(), which supports a wider variety of icon sources.
  static const EXTRA_SMALL_ICON = "android.icon";

  /// from: static public final java.lang.String EXTRA_SUB_TEXT
  ///
  /// \#extras key: this is a third line of text, as supplied to
  /// Builder\#setSubText(CharSequence).
  static const EXTRA_SUB_TEXT = "android.subText";

  /// from: static public final java.lang.String EXTRA_SUMMARY_TEXT
  ///
  /// \#extras key: this is a line of summary information intended to be shown
  /// alongside expanded notifications, as supplied to (e.g.)
  /// BigTextStyle\#setSummaryText(CharSequence).
  static const EXTRA_SUMMARY_TEXT = "android.summaryText";

  /// from: static public final java.lang.String EXTRA_TEMPLATE
  ///
  /// \#extras key: A string representing the name of the specific
  /// android.app.Notification.Style used to create this notification.
  static const EXTRA_TEMPLATE = "android.template";

  /// from: static public final java.lang.String EXTRA_TEXT
  ///
  /// \#extras key: this is the main text payload, as supplied to
  /// Builder\#setContentText(CharSequence).
  static const EXTRA_TEXT = "android.text";

  /// from: static public final java.lang.String EXTRA_TEXT_LINES
  ///
  /// \#extras key: An array of CharSequences to show in InboxStyle expanded
  /// notifications, each of which was supplied to InboxStyle\#addLine(CharSequence).
  static const EXTRA_TEXT_LINES = "android.textLines";

  /// from: static public final java.lang.String EXTRA_TITLE
  ///
  /// \#extras key: this is the title of the notification,
  /// as supplied to Builder\#setContentTitle(CharSequence).
  static const EXTRA_TITLE = "android.title";

  /// from: static public final java.lang.String EXTRA_TITLE_BIG
  ///
  /// \#extras key: this is the title of the notification when shown in expanded form,
  /// e.g.&nbsp;as supplied to BigTextStyle\#setBigContentTitle(CharSequence).
  static const EXTRA_TITLE_BIG = "android.title.big";

  /// from: static public final int FLAG_AUTO_CANCEL
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if the notification should be canceled when it is clicked by the
  /// user.
  static const FLAG_AUTO_CANCEL = 16;

  /// from: static public final int FLAG_FOREGROUND_SERVICE
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if this notification represents a currently running service.  This
  /// will normally be set for you by Service\#startForeground.
  static const FLAG_FOREGROUND_SERVICE = 64;

  /// from: static public final int FLAG_GROUP_SUMMARY
  ///
  /// Bit to be bitswise-ored into the \#flags field that should be
  /// set if this notification is the group summary for a group of notifications.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering. Requires a group key also be set using Builder\#setGroup.
  static const FLAG_GROUP_SUMMARY = 512;

  /// from: static public final int FLAG_HIGH_PRIORITY
  ///
  /// Obsolete flag indicating high-priority notifications; use the priority field instead.
  ///@deprecated Use \#priority with a positive value.
  static const FLAG_HIGH_PRIORITY = 128;

  /// from: static public final int FLAG_INSISTENT
  ///
  /// Bit to be bitwise-ored into the \#flags field that if set,
  /// the audio will be repeated until the notification is
  /// cancelled or the notification window is opened.
  static const FLAG_INSISTENT = 4;

  /// from: static public final int FLAG_LOCAL_ONLY
  ///
  /// Bit to be bitswise-ored into the \#flags field that should be
  /// set if this notification is relevant to the current device only
  /// and it is not recommended that it bridge to other devices.
  static const FLAG_LOCAL_ONLY = 256;

  /// from: static public final int FLAG_NO_CLEAR
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if the notification should not be canceled when the user clicks
  /// the Clear all button.
  static const FLAG_NO_CLEAR = 32;

  /// from: static public final int FLAG_ONGOING_EVENT
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if this notification is in reference to something that is ongoing,
  /// like a phone call.  It should not be set if this notification is in
  /// reference to something that happened at a particular point in time,
  /// like a missed phone call.
  static const FLAG_ONGOING_EVENT = 2;

  /// from: static public final int FLAG_ONLY_ALERT_ONCE
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if you would only like the sound, vibrate and ticker to be played
  /// if the notification was not already showing.
  static const FLAG_ONLY_ALERT_ONCE = 8;

  /// from: static public final int FLAG_SHOW_LIGHTS
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if you want the LED on for this notification.
  /// <ul>
  /// <li>To turn the LED off, pass 0 in the alpha channel for colorARGB
  ///      or 0 for both ledOnMS and ledOffMS.</li>
  /// <li>To turn the LED on, pass 1 for ledOnMS and 0 for ledOffMS.</li>
  /// <li>To flash the LED, pass the number of milliseconds that it should
  ///      be on and off to ledOnMS and ledOffMS.</li>
  /// </ul>
  ///
  /// Since hardware varies, you are not guaranteed that any of the values
  /// you pass are honored exactly.  Use the system defaults if possible
  /// because they will be set to values that work on any given hardware.
  ///
  /// The alpha channel must be set for forward compatibility.
  ///@deprecated use NotificationChannel\#shouldShowLights().
  static const FLAG_SHOW_LIGHTS = 1;

  /// from: static public final int GROUP_ALERT_ALL
  ///
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that all notifications in a
  /// group with sound or vibration ought to make sound or vibrate (respectively), so this
  /// notification will not be muted when it is in a group.
  static const GROUP_ALERT_ALL = 0;

  /// from: static public final int GROUP_ALERT_CHILDREN
  ///
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that the summary
  /// notification in a group should be silenced (no sound or vibration) even if they are
  /// posted to a NotificationChannel that has sound and/or vibration. Use this constant
  /// to mute this notification if this notification is a group summary.
  ///
  /// For example, you might want to use this constant if only the children notifications
  /// in your group have content and the summary is only used to visually group notifications
  /// rather than to alert the user that new information is available.
  static const GROUP_ALERT_CHILDREN = 2;

  /// from: static public final int GROUP_ALERT_SUMMARY
  ///
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that all children
  /// notification in a group should be silenced (no sound or vibration) even if they are posted
  /// to a NotificationChannel that has sound and/or vibration. Use this constant to
  /// mute this notification if this notification is a group child. This must be applied to all
  /// children notifications you want to mute.
  ///
  ///  For example, you might want to use this constant if you post a number of children
  /// notifications at once (say, after a periodic sync), and only need to notify the user
  /// audibly once.
  static const GROUP_ALERT_SUMMARY = 1;

  /// from: static public final java.lang.String INTENT_CATEGORY_NOTIFICATION_PREFERENCES
  ///
  /// An activity that provides a user interface for adjusting notification preferences for its
  /// containing application.
  static const INTENT_CATEGORY_NOTIFICATION_PREFERENCES =
      "android.intent.category.NOTIFICATION_PREFERENCES";

  /// from: static public final int PRIORITY_DEFAULT
  ///
  /// Default notification \#priority. If your application does not prioritize its own
  /// notifications, use this value for all notifications.
  ///@deprecated use NotificationManager\#IMPORTANCE_DEFAULT instead.
  static const PRIORITY_DEFAULT = 0;

  /// from: static public final int PRIORITY_HIGH
  ///
  /// Higher \#priority, for more important notifications or alerts. The UI may choose to
  /// show these items larger, or at a different position in notification lists, compared with
  /// your app's \#PRIORITY_DEFAULT items.
  ///@deprecated use NotificationManager\#IMPORTANCE_HIGH instead.
  static const PRIORITY_HIGH = 1;

  /// from: static public final int PRIORITY_LOW
  ///
  /// Lower \#priority, for items that are less important. The UI may choose to show these
  /// items smaller, or at a different position in the list, compared with your app's
  /// \#PRIORITY_DEFAULT items.
  ///@deprecated use NotificationManager\#IMPORTANCE_LOW instead.
  static const PRIORITY_LOW = -1;

  /// from: static public final int PRIORITY_MAX
  ///
  /// Highest \#priority, for your application's most important items that require the
  /// user's prompt attention or input.
  ///@deprecated use NotificationManager\#IMPORTANCE_HIGH instead.
  static const PRIORITY_MAX = 2;

  /// from: static public final int PRIORITY_MIN
  ///
  /// Lowest \#priority; these items might not be shown to the user except under special
  /// circumstances, such as detailed notification logs.
  ///@deprecated use NotificationManager\#IMPORTANCE_MIN instead.
  static const PRIORITY_MIN = -2;

  /// from: static public final int STREAM_DEFAULT
  ///
  /// Use this constant as the value for audioStreamType to request that
  /// the default stream type for notifications be used.  Currently the
  /// default stream type is AudioManager\#STREAM_NOTIFICATION.
  ///@deprecated Use NotificationChannel\#getAudioAttributes() instead.
  static const STREAM_DEFAULT = -1;

  /// from: static public final int VISIBILITY_PRIVATE
  ///
  /// Notification visibility: Show this notification on all lockscreens, but conceal sensitive or
  /// private information on secure lockscreens.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_PRIVATE = 0;

  /// from: static public final int VISIBILITY_PUBLIC
  ///
  /// Notification visibility: Show this notification in its entirety on all lockscreens.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_PUBLIC = 1;

  /// from: static public final int VISIBILITY_SECRET
  ///
  /// Notification visibility: Do not reveal any part of this notification on a secure lockscreen.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_SECRET = -1;

  static final _id_actions = jniAccessors.getFieldIDOf(
      _classRef, "actions", "[Landroid/app/Notification\$Action;");

  /// from: public android.app.Notification.Action[] actions
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Array of all Action structures attached to this notification by
  /// Builder\#addAction(int, CharSequence, PendingIntent). Mostly useful for instances of
  /// android.service.notification.NotificationListenerService that provide an alternative
  /// interface for invoking actions.
  jni.JniObject get actions => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_actions, jni.JniType.objectType)
      .object);

  /// from: public android.app.Notification.Action[] actions
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Array of all Action structures attached to this notification by
  /// Builder\#addAction(int, CharSequence, PendingIntent). Mostly useful for instances of
  /// android.service.notification.NotificationListenerService that provide an alternative
  /// interface for invoking actions.
  set actions(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_actions, value.reference);

  static final _id_audioAttributes = jniAccessors.getFieldIDOf(
      _classRef, "audioAttributes", "Landroid/media/AudioAttributes;");

  /// from: public android.media.AudioAttributes audioAttributes
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The AudioAttributes audio attributes to use when playing the sound.
  ///@deprecated use NotificationChannel\#getAudioAttributes() instead.
  audioattributes_.AudioAttributes get audioAttributes =>
      audioattributes_.AudioAttributes.fromRef(jniAccessors
          .getField(reference, _id_audioAttributes, jni.JniType.objectType)
          .object);

  /// from: public android.media.AudioAttributes audioAttributes
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The AudioAttributes audio attributes to use when playing the sound.
  ///@deprecated use NotificationChannel\#getAudioAttributes() instead.
  set audioAttributes(audioattributes_.AudioAttributes value) =>
      jniEnv.SetObjectField(reference, _id_audioAttributes, value.reference);

  static final _id_audioStreamType =
      jniAccessors.getFieldIDOf(_classRef, "audioStreamType", "I");

  /// from: public int audioStreamType
  ///
  /// The audio stream type to use when playing the sound.
  /// Should be one of the STREAM_ constants from
  /// android.media.AudioManager.
  ///@deprecated Use \#audioAttributes instead.
  int get audioStreamType => jniAccessors
      .getField(reference, _id_audioStreamType, jni.JniType.intType)
      .integer;

  /// from: public int audioStreamType
  ///
  /// The audio stream type to use when playing the sound.
  /// Should be one of the STREAM_ constants from
  /// android.media.AudioManager.
  ///@deprecated Use \#audioAttributes instead.
  set audioStreamType(int value) =>
      jniEnv.SetIntField(reference, _id_audioStreamType, value);

  static final _id_bigContentView = jniAccessors.getFieldIDOf(
      _classRef, "bigContentView", "Landroid/widget/RemoteViews;");

  /// from: public android.widget.RemoteViews bigContentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A large-format version of \#contentView, giving the Notification an
  /// opportunity to show more detail. The system UI may choose to show this
  /// instead of the normal content view at its discretion.
  ///
  /// As of N, this field may be null. The expanded notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomBigContentView(RemoteViews).
  remoteviews_.RemoteViews get bigContentView =>
      remoteviews_.RemoteViews.fromRef(jniAccessors
          .getField(reference, _id_bigContentView, jni.JniType.objectType)
          .object);

  /// from: public android.widget.RemoteViews bigContentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A large-format version of \#contentView, giving the Notification an
  /// opportunity to show more detail. The system UI may choose to show this
  /// instead of the normal content view at its discretion.
  ///
  /// As of N, this field may be null. The expanded notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomBigContentView(RemoteViews).
  set bigContentView(remoteviews_.RemoteViews value) =>
      jniEnv.SetObjectField(reference, _id_bigContentView, value.reference);

  static final _id_category =
      jniAccessors.getFieldIDOf(_classRef, "category", "Ljava/lang/String;");

  /// from: public java.lang.String category
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// One of the predefined notification categories (see the <code>CATEGORY_*</code> constants)
  /// that best describes this Notification.  May be used by the system for ranking and filtering.
  jni.JniString get category => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_category, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String category
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// One of the predefined notification categories (see the <code>CATEGORY_*</code> constants)
  /// that best describes this Notification.  May be used by the system for ranking and filtering.
  set category(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_category, value.reference);

  static final _id_color = jniAccessors.getFieldIDOf(_classRef, "color", "I");

  /// from: public int color
  ///
  /// Accent color (an ARGB integer like the constants in android.graphics.Color)
  /// to be applied by the standard Style templates when presenting this notification.
  ///
  /// The current template design constructs a colorful header image by overlaying the
  /// \#icon image (stenciled in white) atop a field of this color. Alpha components are
  /// ignored.
  int get color =>
      jniAccessors.getField(reference, _id_color, jni.JniType.intType).integer;

  /// from: public int color
  ///
  /// Accent color (an ARGB integer like the constants in android.graphics.Color)
  /// to be applied by the standard Style templates when presenting this notification.
  ///
  /// The current template design constructs a colorful header image by overlaying the
  /// \#icon image (stenciled in white) atop a field of this color. Alpha components are
  /// ignored.
  set color(int value) => jniEnv.SetIntField(reference, _id_color, value);

  static final _id_contentIntent = jniAccessors.getFieldIDOf(
      _classRef, "contentIntent", "Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent contentIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The intent to execute when the expanded status entry is clicked.  If
  /// this is an activity, it must include the
  /// android.content.Intent\#FLAG_ACTIVITY_NEW_TASK flag, which requires
  /// that you take care of task management as described in the
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> document.  In particular, make sure to read the notification section
  /// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html\#HandlingNotifications">Handling
  /// Notifications</a> for the correct ways to launch an application from a
  /// notification.
  pendingintent_.PendingIntent get contentIntent =>
      pendingintent_.PendingIntent.fromRef(jniAccessors
          .getField(reference, _id_contentIntent, jni.JniType.objectType)
          .object);

  /// from: public android.app.PendingIntent contentIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The intent to execute when the expanded status entry is clicked.  If
  /// this is an activity, it must include the
  /// android.content.Intent\#FLAG_ACTIVITY_NEW_TASK flag, which requires
  /// that you take care of task management as described in the
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> document.  In particular, make sure to read the notification section
  /// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html\#HandlingNotifications">Handling
  /// Notifications</a> for the correct ways to launch an application from a
  /// notification.
  set contentIntent(pendingintent_.PendingIntent value) =>
      jniEnv.SetObjectField(reference, _id_contentIntent, value.reference);

  static final _id_contentView = jniAccessors.getFieldIDOf(
      _classRef, "contentView", "Landroid/widget/RemoteViews;");

  /// from: public android.widget.RemoteViews contentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The view that will represent this notification in the notification list (which is pulled
  /// down from the status bar).
  ///
  /// As of N, this field may be null. The notification view is determined by the inputs
  /// to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomContentView(RemoteViews).
  remoteviews_.RemoteViews get contentView =>
      remoteviews_.RemoteViews.fromRef(jniAccessors
          .getField(reference, _id_contentView, jni.JniType.objectType)
          .object);

  /// from: public android.widget.RemoteViews contentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The view that will represent this notification in the notification list (which is pulled
  /// down from the status bar).
  ///
  /// As of N, this field may be null. The notification view is determined by the inputs
  /// to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomContentView(RemoteViews).
  set contentView(remoteviews_.RemoteViews value) =>
      jniEnv.SetObjectField(reference, _id_contentView, value.reference);

  static final _id_defaults =
      jniAccessors.getFieldIDOf(_classRef, "defaults", "I");

  /// from: public int defaults
  ///
  /// Specifies which values should be taken from the defaults.
  ///
  /// To set, OR the desired from \#DEFAULT_SOUND,
  /// \#DEFAULT_VIBRATE, \#DEFAULT_LIGHTS. For all default
  /// values, use \#DEFAULT_ALL.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound() and
  /// NotificationChannel\#shouldShowLights() and
  /// NotificationChannel\#shouldVibrate().
  int get defaults => jniAccessors
      .getField(reference, _id_defaults, jni.JniType.intType)
      .integer;

  /// from: public int defaults
  ///
  /// Specifies which values should be taken from the defaults.
  ///
  /// To set, OR the desired from \#DEFAULT_SOUND,
  /// \#DEFAULT_VIBRATE, \#DEFAULT_LIGHTS. For all default
  /// values, use \#DEFAULT_ALL.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound() and
  /// NotificationChannel\#shouldShowLights() and
  /// NotificationChannel\#shouldVibrate().
  set defaults(int value) => jniEnv.SetIntField(reference, _id_defaults, value);

  static final _id_deleteIntent = jniAccessors.getFieldIDOf(
      _classRef, "deleteIntent", "Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent deleteIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The intent to execute when the notification is explicitly dismissed by the user, either with
  /// the "Clear All" button or by swiping it away individually.
  ///
  /// This probably shouldn't be launching an activity since several of those will be sent
  /// at the same time.
  pendingintent_.PendingIntent get deleteIntent =>
      pendingintent_.PendingIntent.fromRef(jniAccessors
          .getField(reference, _id_deleteIntent, jni.JniType.objectType)
          .object);

  /// from: public android.app.PendingIntent deleteIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The intent to execute when the notification is explicitly dismissed by the user, either with
  /// the "Clear All" button or by swiping it away individually.
  ///
  /// This probably shouldn't be launching an activity since several of those will be sent
  /// at the same time.
  set deleteIntent(pendingintent_.PendingIntent value) =>
      jniEnv.SetObjectField(reference, _id_deleteIntent, value.reference);

  static final _id_extras =
      jniAccessors.getFieldIDOf(_classRef, "extras", "Landroid/os/Bundle;");

  /// from: public android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Additional semantic data to be carried around with this Notification.
  ///
  /// The extras keys defined here are intended to capture the original inputs to Builder
  /// APIs, and are intended to be used by
  /// android.service.notification.NotificationListenerService implementations to extract
  /// detailed information from notification objects.
  bundle_.Bundle get extras => bundle_.Bundle.fromRef(jniAccessors
      .getField(reference, _id_extras, jni.JniType.objectType)
      .object);

  /// from: public android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Additional semantic data to be carried around with this Notification.
  ///
  /// The extras keys defined here are intended to capture the original inputs to Builder
  /// APIs, and are intended to be used by
  /// android.service.notification.NotificationListenerService implementations to extract
  /// detailed information from notification objects.
  set extras(bundle_.Bundle value) =>
      jniEnv.SetObjectField(reference, _id_extras, value.reference);

  static final _id_flags = jniAccessors.getFieldIDOf(_classRef, "flags", "I");

  /// from: public int flags
  int get flags =>
      jniAccessors.getField(reference, _id_flags, jni.JniType.intType).integer;

  /// from: public int flags
  set flags(int value) => jniEnv.SetIntField(reference, _id_flags, value);

  static final _id_fullScreenIntent = jniAccessors.getFieldIDOf(
      _classRef, "fullScreenIntent", "Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent fullScreenIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An intent to launch instead of posting the notification to the status bar.
  ///
  ///
  /// The system UI may choose to display a heads-up notification, instead of
  /// launching this intent, while the user is using the device.
  ///
  ///
  ///@see Notification.Builder\#setFullScreenIntent
  pendingintent_.PendingIntent get fullScreenIntent =>
      pendingintent_.PendingIntent.fromRef(jniAccessors
          .getField(reference, _id_fullScreenIntent, jni.JniType.objectType)
          .object);

  /// from: public android.app.PendingIntent fullScreenIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An intent to launch instead of posting the notification to the status bar.
  ///
  ///
  /// The system UI may choose to display a heads-up notification, instead of
  /// launching this intent, while the user is using the device.
  ///
  ///
  ///@see Notification.Builder\#setFullScreenIntent
  set fullScreenIntent(pendingintent_.PendingIntent value) =>
      jniEnv.SetObjectField(reference, _id_fullScreenIntent, value.reference);

  static final _id_headsUpContentView = jniAccessors.getFieldIDOf(
      _classRef, "headsUpContentView", "Landroid/widget/RemoteViews;");

  /// from: public android.widget.RemoteViews headsUpContentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A medium-format version of \#contentView, providing the Notification an
  /// opportunity to add action buttons to contentView. At its discretion, the system UI may
  /// choose to show this as a heads-up notification, which will pop up so the user can see
  /// it without leaving their current activity.
  ///
  /// As of N, this field may be null. The heads-up notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomHeadsUpContentView(RemoteViews).
  remoteviews_.RemoteViews get headsUpContentView =>
      remoteviews_.RemoteViews.fromRef(jniAccessors
          .getField(reference, _id_headsUpContentView, jni.JniType.objectType)
          .object);

  /// from: public android.widget.RemoteViews headsUpContentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A medium-format version of \#contentView, providing the Notification an
  /// opportunity to add action buttons to contentView. At its discretion, the system UI may
  /// choose to show this as a heads-up notification, which will pop up so the user can see
  /// it without leaving their current activity.
  ///
  /// As of N, this field may be null. The heads-up notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomHeadsUpContentView(RemoteViews).
  set headsUpContentView(remoteviews_.RemoteViews value) =>
      jniEnv.SetObjectField(reference, _id_headsUpContentView, value.reference);

  static final _id_icon = jniAccessors.getFieldIDOf(_classRef, "icon", "I");

  /// from: public int icon
  ///
  /// The resource id of a drawable to use as the icon in the status bar.
  ///@deprecated Use Builder\#setSmallIcon(Icon) instead.
  int get icon =>
      jniAccessors.getField(reference, _id_icon, jni.JniType.intType).integer;

  /// from: public int icon
  ///
  /// The resource id of a drawable to use as the icon in the status bar.
  ///@deprecated Use Builder\#setSmallIcon(Icon) instead.
  set icon(int value) => jniEnv.SetIntField(reference, _id_icon, value);

  static final _id_iconLevel =
      jniAccessors.getFieldIDOf(_classRef, "iconLevel", "I");

  /// from: public int iconLevel
  ///
  /// If the icon in the status bar is to have more than one level, you can set this.  Otherwise,
  /// leave it at its default value of 0.
  ///@see android.widget.ImageView\#setImageLevel
  ///@see android.graphics.drawable.Drawable\#setLevel
  int get iconLevel => jniAccessors
      .getField(reference, _id_iconLevel, jni.JniType.intType)
      .integer;

  /// from: public int iconLevel
  ///
  /// If the icon in the status bar is to have more than one level, you can set this.  Otherwise,
  /// leave it at its default value of 0.
  ///@see android.widget.ImageView\#setImageLevel
  ///@see android.graphics.drawable.Drawable\#setLevel
  set iconLevel(int value) =>
      jniEnv.SetIntField(reference, _id_iconLevel, value);

  static final _id_largeIcon = jniAccessors.getFieldIDOf(
      _classRef, "largeIcon", "Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap largeIcon
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A large bitmap to be shown in the notification content area.
  ///@deprecated Use Builder\#setLargeIcon(Icon) instead.
  bitmap_.Bitmap get largeIcon => bitmap_.Bitmap.fromRef(jniAccessors
      .getField(reference, _id_largeIcon, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.Bitmap largeIcon
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A large bitmap to be shown in the notification content area.
  ///@deprecated Use Builder\#setLargeIcon(Icon) instead.
  set largeIcon(bitmap_.Bitmap value) =>
      jniEnv.SetObjectField(reference, _id_largeIcon, value.reference);

  static final _id_ledARGB =
      jniAccessors.getFieldIDOf(_classRef, "ledARGB", "I");

  /// from: public int ledARGB
  ///
  /// The color of the led.  The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  int get ledARGB => jniAccessors
      .getField(reference, _id_ledARGB, jni.JniType.intType)
      .integer;

  /// from: public int ledARGB
  ///
  /// The color of the led.  The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  set ledARGB(int value) => jniEnv.SetIntField(reference, _id_ledARGB, value);

  static final _id_ledOffMS =
      jniAccessors.getFieldIDOf(_classRef, "ledOffMS", "I");

  /// from: public int ledOffMS
  ///
  /// The number of milliseconds for the LED to be off while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  int get ledOffMS => jniAccessors
      .getField(reference, _id_ledOffMS, jni.JniType.intType)
      .integer;

  /// from: public int ledOffMS
  ///
  /// The number of milliseconds for the LED to be off while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  set ledOffMS(int value) => jniEnv.SetIntField(reference, _id_ledOffMS, value);

  static final _id_ledOnMS =
      jniAccessors.getFieldIDOf(_classRef, "ledOnMS", "I");

  /// from: public int ledOnMS
  ///
  /// The number of milliseconds for the LED to be on while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  int get ledOnMS => jniAccessors
      .getField(reference, _id_ledOnMS, jni.JniType.intType)
      .integer;

  /// from: public int ledOnMS
  ///
  /// The number of milliseconds for the LED to be on while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  set ledOnMS(int value) => jniEnv.SetIntField(reference, _id_ledOnMS, value);

  static final _id_number = jniAccessors.getFieldIDOf(_classRef, "number", "I");

  /// from: public int number
  ///
  /// The number of events that this notification represents. For example, in a new mail
  /// notification, this could be the number of unread messages.
  ///
  /// The system may or may not use this field to modify the appearance of the notification.
  /// Starting with android.os.Build.VERSION_CODES\#O, the number may be displayed as a
  /// badge icon in Launchers that support badging.
  int get number =>
      jniAccessors.getField(reference, _id_number, jni.JniType.intType).integer;

  /// from: public int number
  ///
  /// The number of events that this notification represents. For example, in a new mail
  /// notification, this could be the number of unread messages.
  ///
  /// The system may or may not use this field to modify the appearance of the notification.
  /// Starting with android.os.Build.VERSION_CODES\#O, the number may be displayed as a
  /// badge icon in Launchers that support badging.
  set number(int value) => jniEnv.SetIntField(reference, _id_number, value);

  static final _id_priority =
      jniAccessors.getFieldIDOf(_classRef, "priority", "I");

  /// from: public int priority
  ///
  /// Relative priority for this notification.
  ///
  /// Priority is an indication of how much of the user's valuable attention should be consumed by
  /// this notification. Low-priority notifications may be hidden from the user in certain
  /// situations, while the user might be interrupted for a higher-priority notification. The
  /// system will make a determination about how to interpret this priority when presenting
  /// the notification.
  ///
  ///
  /// A notification that is at least \#PRIORITY_HIGH is more likely to be presented
  /// as a heads-up notification.
  ///
  ///
  ///
  /// Value is android.app.Notification\#PRIORITY_DEFAULT, android.app.Notification\#PRIORITY_LOW, android.app.Notification\#PRIORITY_MIN, android.app.Notification\#PRIORITY_HIGH, or android.app.Notification\#PRIORITY_MAX
  ///@deprecated use NotificationChannel\#getImportance() instead.
  int get priority => jniAccessors
      .getField(reference, _id_priority, jni.JniType.intType)
      .integer;

  /// from: public int priority
  ///
  /// Relative priority for this notification.
  ///
  /// Priority is an indication of how much of the user's valuable attention should be consumed by
  /// this notification. Low-priority notifications may be hidden from the user in certain
  /// situations, while the user might be interrupted for a higher-priority notification. The
  /// system will make a determination about how to interpret this priority when presenting
  /// the notification.
  ///
  ///
  /// A notification that is at least \#PRIORITY_HIGH is more likely to be presented
  /// as a heads-up notification.
  ///
  ///
  ///
  /// Value is android.app.Notification\#PRIORITY_DEFAULT, android.app.Notification\#PRIORITY_LOW, android.app.Notification\#PRIORITY_MIN, android.app.Notification\#PRIORITY_HIGH, or android.app.Notification\#PRIORITY_MAX
  ///@deprecated use NotificationChannel\#getImportance() instead.
  set priority(int value) => jniEnv.SetIntField(reference, _id_priority, value);

  static final _id_publicVersion = jniAccessors.getFieldIDOf(
      _classRef, "publicVersion", "Landroid/app/Notification;");

  /// from: public android.app.Notification publicVersion
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Replacement version of this notification whose content will be shown
  /// in an insecure context such as atop a secure keyguard. See \#visibility
  /// and \#VISIBILITY_PUBLIC.
  Notification get publicVersion => Notification.fromRef(jniAccessors
      .getField(reference, _id_publicVersion, jni.JniType.objectType)
      .object);

  /// from: public android.app.Notification publicVersion
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Replacement version of this notification whose content will be shown
  /// in an insecure context such as atop a secure keyguard. See \#visibility
  /// and \#VISIBILITY_PUBLIC.
  set publicVersion(Notification value) =>
      jniEnv.SetObjectField(reference, _id_publicVersion, value.reference);

  static final _id_sound =
      jniAccessors.getFieldIDOf(_classRef, "sound", "Landroid/net/Uri;");

  /// from: public android.net.Uri sound
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The sound to play.
  ///
  ///
  /// A notification that is noisy is more likely to be presented as a heads-up notification.
  ///
  ///
  ///
  ///
  /// To play the default notification sound, see \#defaults.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound().
  uri_.Uri get sound => uri_.Uri.fromRef(jniAccessors
      .getField(reference, _id_sound, jni.JniType.objectType)
      .object);

  /// from: public android.net.Uri sound
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The sound to play.
  ///
  ///
  /// A notification that is noisy is more likely to be presented as a heads-up notification.
  ///
  ///
  ///
  ///
  /// To play the default notification sound, see \#defaults.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound().
  set sound(uri_.Uri value) =>
      jniEnv.SetObjectField(reference, _id_sound, value.reference);

  static final _id_tickerText = jniAccessors.getFieldIDOf(
      _classRef, "tickerText", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence tickerText
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Text that summarizes this notification for accessibility services.
  ///
  /// As of the L release, this text is no longer shown on screen, but it is still useful to
  /// accessibility services (where it serves as an audible announcement of the notification's
  /// appearance).
  ///@see \#tickerView
  jni.JniObject get tickerText => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_tickerText, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence tickerText
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Text that summarizes this notification for accessibility services.
  ///
  /// As of the L release, this text is no longer shown on screen, but it is still useful to
  /// accessibility services (where it serves as an audible announcement of the notification's
  /// appearance).
  ///@see \#tickerView
  set tickerText(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_tickerText, value.reference);

  static final _id_tickerView = jniAccessors.getFieldIDOf(
      _classRef, "tickerView", "Landroid/widget/RemoteViews;");

  /// from: public android.widget.RemoteViews tickerView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formerly, a view showing the \#tickerText.
  ///
  /// No longer displayed in the status bar as of API 21.
  remoteviews_.RemoteViews get tickerView =>
      remoteviews_.RemoteViews.fromRef(jniAccessors
          .getField(reference, _id_tickerView, jni.JniType.objectType)
          .object);

  /// from: public android.widget.RemoteViews tickerView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formerly, a view showing the \#tickerText.
  ///
  /// No longer displayed in the status bar as of API 21.
  set tickerView(remoteviews_.RemoteViews value) =>
      jniEnv.SetObjectField(reference, _id_tickerView, value.reference);

  static final _id_vibrate =
      jniAccessors.getFieldIDOf(_classRef, "vibrate", "[J");

  /// from: public long[] vibrate
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The pattern with which to vibrate.
  ///
  ///
  /// To vibrate the default pattern, see \#defaults.
  ///
  ///
  ///@see android.os.Vibrator\#vibrate(long[],int)
  ///@deprecated use NotificationChannel\#getVibrationPattern().
  jni.JniObject get vibrate => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_vibrate, jni.JniType.objectType)
      .object);

  /// from: public long[] vibrate
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The pattern with which to vibrate.
  ///
  ///
  /// To vibrate the default pattern, see \#defaults.
  ///
  ///
  ///@see android.os.Vibrator\#vibrate(long[],int)
  ///@deprecated use NotificationChannel\#getVibrationPattern().
  set vibrate(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_vibrate, value.reference);

  static final _id_visibility =
      jniAccessors.getFieldIDOf(_classRef, "visibility", "I");

  /// from: public int visibility
  ///
  /// Sphere of visibility of this notification, which affects how and when the SystemUI reveals
  /// the notification's presence and contents in untrusted situations (namely, on the secure
  /// lockscreen).
  ///
  /// The default level, \#VISIBILITY_PRIVATE, behaves exactly as notifications have always
  /// done on Android: The notification's \#icon and \#tickerText (if available) are
  /// shown in all situations, but the contents are only available if the device is unlocked for
  /// the appropriate user.
  ///
  /// A more permissive policy can be expressed by \#VISIBILITY_PUBLIC; such a notification
  /// can be read even in an "insecure" context (that is, above a secure lockscreen).
  /// To modify the public version of this notification\u2014for example, to redact some portions\u2014see
  /// Builder\#setPublicVersion(Notification).
  ///
  /// Finally, a notification can be made \#VISIBILITY_SECRET, which will suppress its icon
  /// and ticker until the user has bypassed the lockscreen.
  ///
  /// Value is android.app.Notification\#VISIBILITY_PUBLIC, android.app.Notification\#VISIBILITY_PRIVATE, or android.app.Notification\#VISIBILITY_SECRET
  int get visibility => jniAccessors
      .getField(reference, _id_visibility, jni.JniType.intType)
      .integer;

  /// from: public int visibility
  ///
  /// Sphere of visibility of this notification, which affects how and when the SystemUI reveals
  /// the notification's presence and contents in untrusted situations (namely, on the secure
  /// lockscreen).
  ///
  /// The default level, \#VISIBILITY_PRIVATE, behaves exactly as notifications have always
  /// done on Android: The notification's \#icon and \#tickerText (if available) are
  /// shown in all situations, but the contents are only available if the device is unlocked for
  /// the appropriate user.
  ///
  /// A more permissive policy can be expressed by \#VISIBILITY_PUBLIC; such a notification
  /// can be read even in an "insecure" context (that is, above a secure lockscreen).
  /// To modify the public version of this notification\u2014for example, to redact some portions\u2014see
  /// Builder\#setPublicVersion(Notification).
  ///
  /// Finally, a notification can be made \#VISIBILITY_SECRET, which will suppress its icon
  /// and ticker until the user has bypassed the lockscreen.
  ///
  /// Value is android.app.Notification\#VISIBILITY_PUBLIC, android.app.Notification\#VISIBILITY_PRIVATE, or android.app.Notification\#VISIBILITY_SECRET
  set visibility(int value) =>
      jniEnv.SetIntField(reference, _id_visibility, value);

  static final _id_when = jniAccessors.getFieldIDOf(_classRef, "when", "J");

  /// from: public long when
  ///
  /// A timestamp related to this notification, in milliseconds since the epoch.
  ///
  /// Default value: System\#currentTimeMillis() Now.
  ///
  /// Choose a timestamp that will be most relevant to the user. For most finite events, this
  /// corresponds to the time the event happened (or will happen, in the case of events that have
  /// yet to occur but about which the user is being informed). Indefinite events should be
  /// timestamped according to when the activity began.
  ///
  /// Some examples:
  ///
  /// <ul>
  ///   <li>Notification of a new chat message should be stamped when the message was received.</li>
  ///   <li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
  ///   <li>Notification of a completed file download should be stamped when the download finished.</li>
  ///   <li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
  ///   <li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch's start time.
  ///   <li>Notification of an ongoing countdown timer should be stamped with the timer's end time.
  /// </ul>
  ///
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this time is not shown
  /// anymore by default and must be opted into by using
  /// android.app.Notification.Builder\#setShowWhen(boolean)
  int get when =>
      jniAccessors.getField(reference, _id_when, jni.JniType.longType).long;

  /// from: public long when
  ///
  /// A timestamp related to this notification, in milliseconds since the epoch.
  ///
  /// Default value: System\#currentTimeMillis() Now.
  ///
  /// Choose a timestamp that will be most relevant to the user. For most finite events, this
  /// corresponds to the time the event happened (or will happen, in the case of events that have
  /// yet to occur but about which the user is being informed). Indefinite events should be
  /// timestamped according to when the activity began.
  ///
  /// Some examples:
  ///
  /// <ul>
  ///   <li>Notification of a new chat message should be stamped when the message was received.</li>
  ///   <li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
  ///   <li>Notification of a completed file download should be stamped when the download finished.</li>
  ///   <li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
  ///   <li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch's start time.
  ///   <li>Notification of an ongoing countdown timer should be stamped with the timer's end time.
  /// </ul>
  ///
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this time is not shown
  /// anymore by default and must be opted into by using
  /// android.app.Notification.Builder\#setShowWhen(boolean)
  set when(int value) => jniEnv.SetLongField(reference, _id_when, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a Notification object with default values.
  /// You might want to consider using Builder instead.
  Notification()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILjava/lang/CharSequence;J)V");

  /// from: public void <init>(int icon, java.lang.CharSequence tickerText, long when)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a Notification object with the information needed to
  /// have a status bar icon without the standard expanded view.
  ///@param icon The resource id of the icon to put in the status bar.
  ///@param tickerText The text that flows by in the status bar when the notification first
  ///                      activates.
  ///@param when The time to show in the time field.  In the System.currentTimeMillis
  ///                      timebase.
  ///@deprecated Use Builder instead.
  Notification.ctor1(int icon, jni.JniObject tickerText, int when)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [icon, tickerText.reference, when]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel parcel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Unflatten the notification from a parcel.
  Notification.ctor2(parcel_.Parcel parcel)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [parcel.reference]).object);

  static final _id_getGroup =
      jniAccessors.getMethodIDOf(_classRef, "getGroup", "()Ljava/lang/String;");

  /// from: public java.lang.String getGroup()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the key used to group this notification into a cluster or stack
  /// with other notifications on devices which support such rendering.
  jni.JniString getGroup() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getGroup, jni.JniType.objectType, []).object);

  static final _id_getSortKey = jniAccessors.getMethodIDOf(
      _classRef, "getSortKey", "()Ljava/lang/String;");

  /// from: public java.lang.String getSortKey()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a sort key that orders this notification among other notifications from the
  /// same package. This can be useful if an external sort was already applied and an app
  /// would like to preserve this. Notifications will be sorted lexicographically using this
  /// value, although providing different priorities in addition to providing sort key may
  /// cause this value to be ignored.
  ///
  /// This sort key can also be used to order members of a notification group. See
  /// Builder\#setGroup.
  ///@see String\#compareTo(String)
  jni.JniString getSortKey() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSortKey, jni.JniType.objectType, []).object);

  static final _id_clone = jniAccessors.getMethodIDOf(
      _classRef, "clone", "()Landroid/app/Notification;");

  /// from: public android.app.Notification clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification clone() => Notification.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  ///
  /// Flatten this notification into a parcel.
  void writeToParcel(parcel_.Parcel parcel, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [parcel.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_getChannelId = jniAccessors.getMethodIDOf(
      _classRef, "getChannelId", "()Ljava/lang/String;");

  /// from: public java.lang.String getChannelId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the id of the channel this notification posts to.
  jni.JniString getChannelId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getChannelId, jni.JniType.objectType, []).object);

  static final _id_getTimeoutAfter =
      jniAccessors.getMethodIDOf(_classRef, "getTimeoutAfter", "()J");

  /// from: public long getTimeoutAfter()
  ///
  /// Returns the duration from posting after which this notification should be canceled by the
  /// system, if it's not canceled already.
  int getTimeoutAfter() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimeoutAfter, jni.JniType.longType, []).long;

  static final _id_getBadgeIconType =
      jniAccessors.getMethodIDOf(_classRef, "getBadgeIconType", "()I");

  /// from: public int getBadgeIconType()
  ///
  /// Returns what icon should be shown for this notification if it is being displayed in a
  /// Launcher that supports badging. Will be one of \#BADGE_ICON_NONE,
  /// \#BADGE_ICON_SMALL, or \#BADGE_ICON_LARGE.
  int getBadgeIconType() => jniAccessors.callMethodWithArgs(
      reference, _id_getBadgeIconType, jni.JniType.intType, []).integer;

  static final _id_getShortcutId = jniAccessors.getMethodIDOf(
      _classRef, "getShortcutId", "()Ljava/lang/String;");

  /// from: public java.lang.String getShortcutId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ShortcutInfo\#getId() id that this notification supersedes, if any.
  ///
  /// Used by some Launchers that display notification content to hide shortcuts that duplicate
  /// notifications.
  jni.JniString getShortcutId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getShortcutId, jni.JniType.objectType, []).object);

  static final _id_getSettingsText = jniAccessors.getMethodIDOf(
      _classRef, "getSettingsText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getSettingsText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the settings text provided to Builder\#setSettingsText(CharSequence).
  jni.JniObject getSettingsText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSettingsText, jni.JniType.objectType, []).object);

  static final _id_getGroupAlertBehavior =
      jniAccessors.getMethodIDOf(_classRef, "getGroupAlertBehavior", "()I");

  /// from: public int getGroupAlertBehavior()
  ///
  /// Returns which type of notifications in a group are responsible for audibly alerting the
  /// user. See \#GROUP_ALERT_ALL, \#GROUP_ALERT_CHILDREN,
  /// \#GROUP_ALERT_SUMMARY.
  ///@return Value is android.app.Notification\#GROUP_ALERT_ALL, android.app.Notification\#GROUP_ALERT_CHILDREN, or android.app.Notification\#GROUP_ALERT_SUMMARY
  int getGroupAlertBehavior() => jniAccessors.callMethodWithArgs(
      reference, _id_getGroupAlertBehavior, jni.JniType.intType, []).integer;

  static final _id_getSmallIcon = jniAccessors.getMethodIDOf(
      _classRef, "getSmallIcon", "()Landroid/graphics/drawable/Icon;");

  /// from: public android.graphics.drawable.Icon getSmallIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The small icon representing this notification in the status bar and content view.
  ///@return the small icon representing this notification.
  ///@see Builder\#getSmallIcon()
  ///@see Builder\#setSmallIcon(Icon)
  icon_.Icon getSmallIcon() =>
      icon_.Icon.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSmallIcon, jni.JniType.objectType, []).object);

  static final _id_getLargeIcon = jniAccessors.getMethodIDOf(
      _classRef, "getLargeIcon", "()Landroid/graphics/drawable/Icon;");

  /// from: public android.graphics.drawable.Icon getLargeIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The large icon shown in this notification's content view.
  ///@see Builder\#getLargeIcon()
  ///@see Builder\#setLargeIcon(Icon)
  icon_.Icon getLargeIcon() =>
      icon_.Icon.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLargeIcon, jni.JniType.objectType, []).object);
}

/// from: android.app.Notification$WearableExtender
///
/// Helper class to add wearable extensions to notifications.
/// <p class="note"> See
/// <a href="{@docRoot}wear/notifications/creating.html">Creating Notifications
/// for Android Wear</a> for more information on how to use this class.
///
/// To create a notification with wearable extensions:
/// <ol>
///   <li>Create a android.app.Notification.Builder, setting any desired
///   properties.
///   <li>Create a android.app.Notification.WearableExtender.
///   <li>Set wearable-specific properties using the
///   {@code add} and {@code set} methods of android.app.Notification.WearableExtender.
///   <li>Call android.app.Notification.Builder\#extend to apply the extensions to a
///   notification.
///   <li>Post the notification to the notification system with the
///   {@code NotificationManager.notify(...)} methods.
/// </ol>
///
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///         .setContentTitle(&quot;New mail from &quot; + sender.toString())
///         .setContentText(subject)
///         .setSmallIcon(R.drawable.new_mail)
///         .extend(new Notification.WearableExtender()
///                 .setContentIcon(R.drawable.new_mail))
///         .build();
/// NotificationManager notificationManger =
///         (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
/// notificationManger.notify(0, notif);</pre>
///
/// Wearable extensions can be accessed on an existing notification by using the
/// {@code WearableExtender(Notification)} constructor,
/// and then using the {@code get} methods to access values.
///
/// <pre class="prettyprint">
/// Notification.WearableExtender wearableExtender = new Notification.WearableExtender(
///         notification);
/// List&lt;Notification&gt; pages = wearableExtender.getPages();</pre>
class Notification_WearableExtender extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$WearableExtender");
  Notification_WearableExtender.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SCREEN_TIMEOUT_LONG
  ///
  /// Sentinel value for use with \#setHintScreenTimeout to keep the screen on
  /// for a longer amount of time when this notification is displayed on the screen.
  static const SCREEN_TIMEOUT_LONG = -1;

  /// from: static public final int SCREEN_TIMEOUT_SHORT
  ///
  /// Sentinel value for use with \#setHintScreenTimeout to keep the screen on for a
  /// short amount of time when this notification is displayed on the screen. This
  /// is the default value.
  static const SCREEN_TIMEOUT_SHORT = 0;

  /// from: static public final int SIZE_DEFAULT
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification with
  /// default sizing.
  /// For custom display notifications created using \#setDisplayIntent,
  /// the default is \#SIZE_MEDIUM. All other notifications size automatically based
  /// on their content.
  static const SIZE_DEFAULT = 0;

  /// from: static public final int SIZE_FULL_SCREEN
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// full screen.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_FULL_SCREEN = 5;

  /// from: static public final int SIZE_LARGE
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a large size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_LARGE = 4;

  /// from: static public final int SIZE_MEDIUM
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a medium size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_MEDIUM = 3;

  /// from: static public final int SIZE_SMALL
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a small size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_SMALL = 2;

  /// from: static public final int SIZE_XSMALL
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with an extra small size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_XSMALL = 1;

  /// from: static public final int UNSET_ACTION_INDEX
  ///
  /// Sentinel value for an action index that is unset.
  static const UNSET_ACTION_INDEX = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a android.app.Notification.WearableExtender with default
  /// options.
  Notification_WearableExtender()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Notification;)V");

  /// from: public void <init>(android.app.Notification notif)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_WearableExtender.ctor1(Notification notif)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [notif.reference]).object);

  static final _id_extend = jniAccessors.getMethodIDOf(_classRef, "extend",
      "(Landroid/app/Notification\$Builder;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply wearable extensions to a notification that is being built. This is typically
  /// called by the android.app.Notification.Builder\#extend method of
  /// android.app.Notification.Builder.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_extend, jni.JniType.objectType, [builder.reference]).object);

  static final _id_clone = jniAccessors.getMethodIDOf(
      _classRef, "clone", "()Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_WearableExtender clone() =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_addAction = jniAccessors.getMethodIDOf(
      _classRef,
      "addAction",
      "(Landroid/app/Notification\$Action;)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender addAction(android.app.Notification.Action action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a wearable action to this notification.
  ///
  /// When wearable actions are added using this method, the set of actions that
  /// show on a wearable device splits from devices that only show actions added
  /// using android.app.Notification.Builder\#addAction. This allows for customization
  /// of which actions display on different devices.
  ///@param action the action to add to this notification
  ///@return this object for method chaining
  ///@see android.app.Notification.Action
  Notification_WearableExtender addAction(Notification_Action action) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addAction,
          jni.JniType.objectType,
          [action.reference]).object);

  static final _id_addActions = jniAccessors.getMethodIDOf(
      _classRef,
      "addActions",
      "(Ljava/util/List;)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender addActions(java.util.List<android.app.Notification.Action> actions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds wearable actions to this notification.
  ///
  /// When wearable actions are added using this method, the set of actions that
  /// show on a wearable device splits from devices that only show actions added
  /// using android.app.Notification.Builder\#addAction. This allows for customization
  /// of which actions display on different devices.
  ///@param actions the actions to add to this notification
  ///@return this object for method chaining
  ///@see android.app.Notification.Action
  Notification_WearableExtender addActions(jni.JniObject actions) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addActions,
          jni.JniType.objectType,
          [actions.reference]).object);

  static final _id_clearActions = jniAccessors.getMethodIDOf(_classRef,
      "clearActions", "()Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender clearActions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clear all wearable actions present on this builder.
  ///@return this object for method chaining.
  ///@see \#addAction
  Notification_WearableExtender clearActions() =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clearActions, jni.JniType.objectType, []).object);

  static final _id_getActions =
      jniAccessors.getMethodIDOf(_classRef, "getActions", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.Notification.Action> getActions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the wearable actions present on this notification.
  jni.JniObject getActions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActions, jni.JniType.objectType, []).object);

  static final _id_setDisplayIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "setDisplayIntent",
      "(Landroid/app/PendingIntent;)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setDisplayIntent(android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an intent to launch inside of an activity view when displaying
  /// this notification. The PendingIntent provided should be for an activity.
  ///
  /// <pre class="prettyprint">
  /// Intent displayIntent = new Intent(context, MyDisplayActivity.class);
  /// PendingIntent displayPendingIntent = PendingIntent.getActivity(context,
  ///         0, displayIntent, PendingIntent.FLAG_UPDATE_CURRENT);
  /// Notification notif = new Notification.Builder(context)
  ///         .extend(new Notification.WearableExtender()
  ///                 .setDisplayIntent(displayPendingIntent)
  ///                 .setCustomSizePreset(Notification.WearableExtender.SIZE_MEDIUM))
  ///         .build();</pre>
  ///
  /// The activity to launch needs to allow embedding, must be exported, and
  /// should have an empty task affinity. It is also recommended to use the device
  /// default light theme.
  ///
  /// Example AndroidManifest.xml entry:
  /// <pre class="prettyprint">
  /// &lt;activity android:name=&quot;com.example.MyDisplayActivity&quot;
  ///     android:exported=&quot;true&quot;
  ///     android:allowEmbedded=&quot;true&quot;
  ///     android:taskAffinity=&quot;&quot;
  ///     android:theme=&quot;@android:style/Theme.DeviceDefault.Light&quot; /&gt;</pre>
  ///@param intent the PendingIntent for an activity
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getDisplayIntent
  Notification_WearableExtender setDisplayIntent(
          pendingintent_.PendingIntent intent) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDisplayIntent,
          jni.JniType.objectType,
          [intent.reference]).object);

  static final _id_getDisplayIntent = jniAccessors.getMethodIDOf(
      _classRef, "getDisplayIntent", "()Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getDisplayIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the intent to launch inside of an activity view when displaying this
  /// notification. This {@code PendingIntent} should be for an activity.
  pendingintent_.PendingIntent getDisplayIntent() =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDisplayIntent, jni.JniType.objectType, []).object);

  static final _id_addPage = jniAccessors.getMethodIDOf(_classRef, "addPage",
      "(Landroid/app/Notification;)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender addPage(android.app.Notification page)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an additional page of content to display with this notification. The current
  /// notification forms the first page, and pages added using this function form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@param page the notification to add as another page
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getPages
  Notification_WearableExtender addPage(Notification page) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addPage,
          jni.JniType.objectType,
          [page.reference]).object);

  static final _id_addPages = jniAccessors.getMethodIDOf(_classRef, "addPages",
      "(Ljava/util/List;)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender addPages(java.util.List<android.app.Notification> pages)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add additional pages of content to display with this notification. The current
  /// notification forms the first page, and pages added using this function form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@param pages a list of notifications
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getPages
  Notification_WearableExtender addPages(jni.JniObject pages) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addPages,
          jni.JniType.objectType,
          [pages.reference]).object);

  static final _id_clearPages = jniAccessors.getMethodIDOf(_classRef,
      "clearPages", "()Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender clearPages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clear all additional pages present on this builder.
  ///@return this object for method chaining.
  ///@see \#addPage
  Notification_WearableExtender clearPages() =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clearPages, jni.JniType.objectType, []).object);

  static final _id_getPages =
      jniAccessors.getMethodIDOf(_classRef, "getPages", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.Notification> getPages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the array of additional pages of content for displaying this notification. The
  /// current notification forms the first page, and elements within this array form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@return the pages for this notification
  jni.JniObject getPages() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPages, jni.JniType.objectType, []).object);

  static final _id_setBackground = jniAccessors.getMethodIDOf(
      _classRef,
      "setBackground",
      "(Landroid/graphics/Bitmap;)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setBackground(android.graphics.Bitmap background)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a background image to be displayed behind the notification content.
  /// Contrary to the android.app.Notification.BigPictureStyle, this background
  /// will work with any notification style.
  ///@param background the background bitmap
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getBackground
  Notification_WearableExtender setBackground(bitmap_.Bitmap background) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setBackground,
          jni.JniType.objectType,
          [background.reference]).object);

  static final _id_getBackground = jniAccessors.getMethodIDOf(
      _classRef, "getBackground", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getBackground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a background image to be displayed behind the notification content.
  /// Contrary to the android.app.Notification.BigPictureStyle, this background
  /// will work with any notification style.
  ///@return the background image
  ///@see android.app.Notification.WearableExtender\#setBackground
  bitmap_.Bitmap getBackground() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBackground, jni.JniType.objectType, []).object);

  static final _id_setContentIcon = jniAccessors.getMethodIDOf(_classRef,
      "setContentIcon", "(I)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setContentIcon(int icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an icon that goes with the content of this notification.
  Notification_WearableExtender setContentIcon(int icon) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentIcon,
          jni.JniType.objectType,
          [icon]).object);

  static final _id_getContentIcon =
      jniAccessors.getMethodIDOf(_classRef, "getContentIcon", "()I");

  /// from: public int getContentIcon()
  ///
  /// Get an icon that goes with the content of this notification.
  int getContentIcon() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentIcon, jni.JniType.intType, []).integer;

  static final _id_setContentIconGravity = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentIconGravity",
      "(I)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setContentIconGravity(int contentIconGravity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the gravity that the content icon should have within the notification display.
  /// Supported values include android.view.Gravity\#START and
  /// android.view.Gravity\#END. The default value is android.view.Gravity\#END.
  ///@see \#setContentIcon
  Notification_WearableExtender setContentIconGravity(int contentIconGravity) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentIconGravity,
          jni.JniType.objectType,
          [contentIconGravity]).object);

  static final _id_getContentIconGravity =
      jniAccessors.getMethodIDOf(_classRef, "getContentIconGravity", "()I");

  /// from: public int getContentIconGravity()
  ///
  /// Get the gravity that the content icon should have within the notification display.
  /// Supported values include android.view.Gravity\#START and
  /// android.view.Gravity\#END. The default value is android.view.Gravity\#END.
  ///@see \#getContentIcon
  int getContentIconGravity() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentIconGravity, jni.JniType.intType, []).integer;

  static final _id_setContentAction = jniAccessors.getMethodIDOf(_classRef,
      "setContentAction", "(I)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setContentAction(int actionIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an action from this notification's actions to be clickable with the content of
  /// this notification. This action will no longer display separately from the
  /// notification's content.
  ///
  /// For notifications with multiple pages, child pages can also have content actions
  /// set, although the list of available actions comes from the main notification and not
  /// from the child page's notification.
  ///@param actionIndex The index of the action to hoist onto the current notification page.
  ///                    If wearable actions were added to the main notification, this index
  ///                    will apply to that list, otherwise it will apply to the regular
  ///                    actions list.
  Notification_WearableExtender setContentAction(int actionIndex) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentAction,
          jni.JniType.objectType,
          [actionIndex]).object);

  static final _id_getContentAction =
      jniAccessors.getMethodIDOf(_classRef, "getContentAction", "()I");

  /// from: public int getContentAction()
  ///
  /// Get the index of the notification action, if any, that was specified as being clickable
  /// with the content of this notification. This action will no longer display separately
  /// from the notification's content.
  ///
  /// For notifications with multiple pages, child pages can also have content actions
  /// set, although the list of available actions comes from the main notification and not
  /// from the child page's notification.
  ///
  /// If wearable specific actions were added to the main notification, this index will
  /// apply to that list, otherwise it will apply to the regular actions list.
  ///@return the action index or \#UNSET_ACTION_INDEX if no action was selected.
  int getContentAction() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentAction, jni.JniType.intType, []).integer;

  static final _id_setGravity = jniAccessors.getMethodIDOf(_classRef,
      "setGravity", "(I)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setGravity(int gravity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the gravity that this notification should have within the available viewport space.
  /// Supported values include android.view.Gravity\#TOP,
  /// android.view.Gravity\#CENTER_VERTICAL and android.view.Gravity\#BOTTOM.
  /// The default value is android.view.Gravity\#BOTTOM.
  Notification_WearableExtender setGravity(int gravity) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setGravity, jni.JniType.objectType, [gravity]).object);

  static final _id_getGravity =
      jniAccessors.getMethodIDOf(_classRef, "getGravity", "()I");

  /// from: public int getGravity()
  ///
  /// Get the gravity that this notification should have within the available viewport space.
  /// Supported values include android.view.Gravity\#TOP,
  /// android.view.Gravity\#CENTER_VERTICAL and android.view.Gravity\#BOTTOM.
  /// The default value is android.view.Gravity\#BOTTOM.
  int getGravity() => jniAccessors.callMethodWithArgs(
      reference, _id_getGravity, jni.JniType.intType, []).integer;

  static final _id_setCustomSizePreset = jniAccessors.getMethodIDOf(_classRef,
      "setCustomSizePreset", "(I)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setCustomSizePreset(int sizePreset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the custom size preset for the display of this notification out of the available
  /// presets found in android.app.Notification.WearableExtender, e.g.
  /// \#SIZE_LARGE.
  /// Some custom size presets are only applicable for custom display notifications created
  /// using android.app.Notification.WearableExtender\#setDisplayIntent. Check the
  /// documentation for the preset in question. See also
  /// \#setCustomContentHeight and \#getCustomSizePreset.
  Notification_WearableExtender setCustomSizePreset(int sizePreset) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCustomSizePreset,
          jni.JniType.objectType,
          [sizePreset]).object);

  static final _id_getCustomSizePreset =
      jniAccessors.getMethodIDOf(_classRef, "getCustomSizePreset", "()I");

  /// from: public int getCustomSizePreset()
  ///
  /// Get the custom size preset for the display of this notification out of the available
  /// presets found in android.app.Notification.WearableExtender, e.g.
  /// \#SIZE_LARGE.
  /// Some custom size presets are only applicable for custom display notifications created
  /// using \#setDisplayIntent. Check the documentation for the preset in question.
  /// See also \#setCustomContentHeight and \#setCustomSizePreset.
  int getCustomSizePreset() => jniAccessors.callMethodWithArgs(
      reference, _id_getCustomSizePreset, jni.JniType.intType, []).integer;

  static final _id_setCustomContentHeight = jniAccessors.getMethodIDOf(
      _classRef,
      "setCustomContentHeight",
      "(I)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setCustomContentHeight(int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the custom height in pixels for the display of this notification's content.
  /// This option is only available for custom display notifications created
  /// using android.app.Notification.WearableExtender\#setDisplayIntent. See also
  /// android.app.Notification.WearableExtender\#setCustomSizePreset and
  /// \#getCustomContentHeight.
  Notification_WearableExtender setCustomContentHeight(int height) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCustomContentHeight,
          jni.JniType.objectType,
          [height]).object);

  static final _id_getCustomContentHeight =
      jniAccessors.getMethodIDOf(_classRef, "getCustomContentHeight", "()I");

  /// from: public int getCustomContentHeight()
  ///
  /// Get the custom height in pixels for the display of this notification's content.
  /// This option is only available for custom display notifications created
  /// using \#setDisplayIntent. See also \#setCustomSizePreset and
  /// \#setCustomContentHeight.
  int getCustomContentHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getCustomContentHeight, jni.JniType.intType, []).integer;

  static final _id_setStartScrollBottom = jniAccessors.getMethodIDOf(
      _classRef,
      "setStartScrollBottom",
      "(Z)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setStartScrollBottom(boolean startScrollBottom)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether the scrolling position for the contents of this notification should start
  /// at the bottom of the contents instead of the top when the contents are too long to
  /// display within the screen.  Default is false (start scroll at the top).
  Notification_WearableExtender setStartScrollBottom(bool startScrollBottom) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setStartScrollBottom,
          jni.JniType.objectType,
          [startScrollBottom]).object);

  static final _id_getStartScrollBottom =
      jniAccessors.getMethodIDOf(_classRef, "getStartScrollBottom", "()Z");

  /// from: public boolean getStartScrollBottom()
  ///
  /// Get whether the scrolling position for the contents of this notification should start
  /// at the bottom of the contents instead of the top when the contents are too long to
  /// display within the screen. Default is false (start scroll at the top).
  bool getStartScrollBottom() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartScrollBottom, jni.JniType.booleanType, []).boolean;

  static final _id_setContentIntentAvailableOffline =
      jniAccessors.getMethodIDOf(_classRef, "setContentIntentAvailableOffline",
          "(Z)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setContentIntentAvailableOffline(boolean contentIntentAvailableOffline)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether the content intent is available when the wearable device is not connected
  /// to a companion device.  The user can still trigger this intent when the wearable device
  /// is offline, but a visual hint will indicate that the content intent may not be available.
  /// Defaults to true.
  Notification_WearableExtender setContentIntentAvailableOffline(
          bool contentIntentAvailableOffline) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentIntentAvailableOffline,
          jni.JniType.objectType,
          [contentIntentAvailableOffline]).object);

  static final _id_getContentIntentAvailableOffline = jniAccessors
      .getMethodIDOf(_classRef, "getContentIntentAvailableOffline", "()Z");

  /// from: public boolean getContentIntentAvailableOffline()
  ///
  /// Get whether the content intent is available when the wearable device is not connected
  /// to a companion device.  The user can still trigger this intent when the wearable device
  /// is offline, but a visual hint will indicate that the content intent may not be available.
  /// Defaults to true.
  bool getContentIntentAvailableOffline() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getContentIntentAvailableOffline,
      jni.JniType.booleanType, []).boolean;

  static final _id_setHintHideIcon = jniAccessors.getMethodIDOf(_classRef,
      "setHintHideIcon", "(Z)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setHintHideIcon(boolean hintHideIcon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this notification's icon should not be displayed.
  ///@param hintHideIcon {@code true} to hide the icon, {@code false} otherwise.
  ///@return this object for method chaining
  Notification_WearableExtender setHintHideIcon(bool hintHideIcon) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setHintHideIcon,
          jni.JniType.objectType,
          [hintHideIcon]).object);

  static final _id_getHintHideIcon =
      jniAccessors.getMethodIDOf(_classRef, "getHintHideIcon", "()Z");

  /// from: public boolean getHintHideIcon()
  ///
  /// Get a hint that this notification's icon should not be displayed.
  ///@return {@code true} if this icon should not be displayed, false otherwise.
  /// The default value is {@code false} if this was never set.
  bool getHintHideIcon() => jniAccessors.callMethodWithArgs(
      reference, _id_getHintHideIcon, jni.JniType.booleanType, []).boolean;

  static final _id_setHintShowBackgroundOnly = jniAccessors.getMethodIDOf(
      _classRef,
      "setHintShowBackgroundOnly",
      "(Z)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setHintShowBackgroundOnly(boolean hintShowBackgroundOnly)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a visual hint that only the background image of this notification should be
  /// displayed, and other semantic content should be hidden. This hint is only applicable
  /// to sub-pages added using \#addPage.
  Notification_WearableExtender setHintShowBackgroundOnly(
          bool hintShowBackgroundOnly) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setHintShowBackgroundOnly,
          jni.JniType.objectType,
          [hintShowBackgroundOnly]).object);

  static final _id_getHintShowBackgroundOnly =
      jniAccessors.getMethodIDOf(_classRef, "getHintShowBackgroundOnly", "()Z");

  /// from: public boolean getHintShowBackgroundOnly()
  ///
  /// Get a visual hint that only the background image of this notification should be
  /// displayed, and other semantic content should be hidden. This hint is only applicable
  /// to sub-pages added using android.app.Notification.WearableExtender\#addPage.
  bool getHintShowBackgroundOnly() => jniAccessors.callMethodWithArgs(reference,
      _id_getHintShowBackgroundOnly, jni.JniType.booleanType, []).boolean;

  static final _id_setHintAvoidBackgroundClipping = jniAccessors.getMethodIDOf(
      _classRef,
      "setHintAvoidBackgroundClipping",
      "(Z)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setHintAvoidBackgroundClipping(boolean hintAvoidBackgroundClipping)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this notification's background should not be clipped if possible,
  /// and should instead be resized to fully display on the screen, retaining the aspect
  /// ratio of the image. This can be useful for images like barcodes or qr codes.
  ///@param hintAvoidBackgroundClipping {@code true} to avoid clipping if possible.
  ///@return this object for method chaining
  Notification_WearableExtender setHintAvoidBackgroundClipping(
          bool hintAvoidBackgroundClipping) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setHintAvoidBackgroundClipping,
          jni.JniType.objectType,
          [hintAvoidBackgroundClipping]).object);

  static final _id_getHintAvoidBackgroundClipping = jniAccessors.getMethodIDOf(
      _classRef, "getHintAvoidBackgroundClipping", "()Z");

  /// from: public boolean getHintAvoidBackgroundClipping()
  ///
  /// Get a hint that this notification's background should not be clipped if possible,
  /// and should instead be resized to fully display on the screen, retaining the aspect
  /// ratio of the image. This can be useful for images like barcodes or qr codes.
  ///@return {@code true} if it's ok if the background is clipped on the screen, false
  /// otherwise. The default value is {@code false} if this was never set.
  bool getHintAvoidBackgroundClipping() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHintAvoidBackgroundClipping,
      jni.JniType.booleanType, []).boolean;

  static final _id_setHintScreenTimeout = jniAccessors.getMethodIDOf(
      _classRef,
      "setHintScreenTimeout",
      "(I)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setHintScreenTimeout(int timeout)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that the screen should remain on for at least this duration when
  /// this notification is displayed on the screen.
  ///@param timeout The requested screen timeout in milliseconds. Can also be either
  ///     \#SCREEN_TIMEOUT_SHORT or \#SCREEN_TIMEOUT_LONG.
  ///@return this object for method chaining
  Notification_WearableExtender setHintScreenTimeout(int timeout) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setHintScreenTimeout,
          jni.JniType.objectType,
          [timeout]).object);

  static final _id_getHintScreenTimeout =
      jniAccessors.getMethodIDOf(_classRef, "getHintScreenTimeout", "()I");

  /// from: public int getHintScreenTimeout()
  ///
  /// Get the duration, in milliseconds, that the screen should remain on for
  /// when this notification is displayed.
  ///@return the duration in milliseconds if > 0, or either one of the sentinel values
  ///     \#SCREEN_TIMEOUT_SHORT or \#SCREEN_TIMEOUT_LONG.
  int getHintScreenTimeout() => jniAccessors.callMethodWithArgs(
      reference, _id_getHintScreenTimeout, jni.JniType.intType, []).integer;

  static final _id_setHintAmbientBigPicture = jniAccessors.getMethodIDOf(
      _classRef,
      "setHintAmbientBigPicture",
      "(Z)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setHintAmbientBigPicture(boolean hintAmbientBigPicture)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this notification's BigPictureStyle (if present) should be
  /// converted to low-bit and displayed in ambient mode, especially useful for barcodes and
  /// qr codes, as well as other simple black-and-white tickets.
  ///@param hintAmbientBigPicture {@code true} to enable converstion and ambient.
  ///@return this object for method chaining
  Notification_WearableExtender setHintAmbientBigPicture(
          bool hintAmbientBigPicture) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setHintAmbientBigPicture,
          jni.JniType.objectType,
          [hintAmbientBigPicture]).object);

  static final _id_getHintAmbientBigPicture =
      jniAccessors.getMethodIDOf(_classRef, "getHintAmbientBigPicture", "()Z");

  /// from: public boolean getHintAmbientBigPicture()
  ///
  /// Get a hint that this notification's BigPictureStyle (if present) should be
  /// converted to low-bit and displayed in ambient mode, especially useful for barcodes and
  /// qr codes, as well as other simple black-and-white tickets.
  ///@return {@code true} if it should be displayed in ambient, false otherwise
  /// otherwise. The default value is {@code false} if this was never set.
  bool getHintAmbientBigPicture() => jniAccessors.callMethodWithArgs(reference,
      _id_getHintAmbientBigPicture, jni.JniType.booleanType, []).boolean;

  static final _id_setHintContentIntentLaunchesActivity =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setHintContentIntentLaunchesActivity",
          "(Z)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setHintContentIntentLaunchesActivity(boolean hintContentIntentLaunchesActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this notification's content intent will launch an Activity
  /// directly, telling the platform that it can generate the appropriate transitions.
  ///@param hintContentIntentLaunchesActivity {@code true} if the content intent will launch
  /// an activity and transitions should be generated, false otherwise.
  ///@return this object for method chaining
  Notification_WearableExtender setHintContentIntentLaunchesActivity(
          bool hintContentIntentLaunchesActivity) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setHintContentIntentLaunchesActivity,
          jni.JniType.objectType,
          [hintContentIntentLaunchesActivity]).object);

  static final _id_getHintContentIntentLaunchesActivity = jniAccessors
      .getMethodIDOf(_classRef, "getHintContentIntentLaunchesActivity", "()Z");

  /// from: public boolean getHintContentIntentLaunchesActivity()
  ///
  /// Get a hint that this notification's content intent will launch an Activity
  /// directly, telling the platform that it can generate the appropriate transitions
  ///@return {@code true} if the content intent will launch an activity and transitions should
  /// be generated, false otherwise. The default value is {@code false} if this was never set.
  bool getHintContentIntentLaunchesActivity() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getHintContentIntentLaunchesActivity,
          jni.JniType.booleanType, []).boolean;

  static final _id_setDismissalId = jniAccessors.getMethodIDOf(
      _classRef,
      "setDismissalId",
      "(Ljava/lang/String;)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setDismissalId(java.lang.String dismissalId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the dismissal id for this notification. If a notification is posted with a
  /// dismissal id, then when that notification is canceled, notifications on other wearables
  /// and the paired Android phone having that same dismissal id will also be canceled. See
  /// <a href="{@docRoot}wear/notifications/index.html">Adding Wearable Features to
  /// Notifications</a> for more information.
  ///@param dismissalId the dismissal id of the notification.
  ///@return this object for method chaining
  Notification_WearableExtender setDismissalId(jni.JniString dismissalId) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDismissalId,
          jni.JniType.objectType,
          [dismissalId.reference]).object);

  static final _id_getDismissalId = jniAccessors.getMethodIDOf(
      _classRef, "getDismissalId", "()Ljava/lang/String;");

  /// from: public java.lang.String getDismissalId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the dismissal id of the notification.
  ///@return the dismissal id of the notification or null if it has not been set.
  jni.JniString getDismissalId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDismissalId, jni.JniType.objectType, []).object);

  static final _id_setBridgeTag = jniAccessors.getMethodIDOf(
      _classRef,
      "setBridgeTag",
      "(Ljava/lang/String;)Landroid/app/Notification\$WearableExtender;");

  /// from: public android.app.Notification.WearableExtender setBridgeTag(java.lang.String bridgeTag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a bridge tag for this notification. A bridge tag can be set for notifications
  /// posted from a phone to provide finer-grained control on what notifications are bridged
  /// to wearables. See <a href="{@docRoot}wear/notifications/index.html">Adding Wearable
  /// Features to Notifications</a> for more information.
  ///@param bridgeTag the bridge tag of the notification.
  ///@return this object for method chaining
  Notification_WearableExtender setBridgeTag(jni.JniString bridgeTag) =>
      Notification_WearableExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setBridgeTag,
          jni.JniType.objectType,
          [bridgeTag.reference]).object);

  static final _id_getBridgeTag = jniAccessors.getMethodIDOf(
      _classRef, "getBridgeTag", "()Ljava/lang/String;");

  /// from: public java.lang.String getBridgeTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the bridge tag of the notification.
  ///@return the bridge tag or null if not present.
  jni.JniString getBridgeTag() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBridgeTag, jni.JniType.objectType, []).object);
}

/// from: android.app.Notification$Style
///
/// An object that can apply a rich notification style to a Notification.Builder
/// object.
class Notification_Style extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$Style");
  Notification_Style.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_mBuilder = jniAccessors.getFieldIDOf(
      _classRef, "mBuilder", "Landroid/app/Notification\$Builder;");

  /// from: protected android.app.Notification.Builder mBuilder
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_Builder get mBuilder => Notification_Builder.fromRef(jniAccessors
      .getField(reference, _id_mBuilder, jni.JniType.objectType)
      .object);

  /// from: protected android.app.Notification.Builder mBuilder
  /// The returned object must be deleted after use, by calling the `delete` method.
  set mBuilder(Notification_Builder value) =>
      jniEnv.SetObjectField(reference, _id_mBuilder, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_Style()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_internalSetBigContentTitle = jniAccessors.getMethodIDOf(
      _classRef, "internalSetBigContentTitle", "(Ljava/lang/CharSequence;)V");

  /// from: protected void internalSetBigContentTitle(java.lang.CharSequence title)
  ///
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  void internalSetBigContentTitle(jni.JniObject title) =>
      jniAccessors.callMethodWithArgs(reference, _id_internalSetBigContentTitle,
          jni.JniType.voidType, [title.reference]).check();

  static final _id_internalSetSummaryText = jniAccessors.getMethodIDOf(
      _classRef, "internalSetSummaryText", "(Ljava/lang/CharSequence;)V");

  /// from: protected void internalSetSummaryText(java.lang.CharSequence cs)
  ///
  /// Set the first line of text after the detail section in the big form of the template.
  void internalSetSummaryText(jni.JniObject cs) =>
      jniAccessors.callMethodWithArgs(reference, _id_internalSetSummaryText,
          jni.JniType.voidType, [cs.reference]).check();

  static final _id_setBuilder = jniAccessors.getMethodIDOf(
      _classRef, "setBuilder", "(Landroid/app/Notification\$Builder;)V");

  /// from: public void setBuilder(android.app.Notification.Builder builder)
  void setBuilder(Notification_Builder builder) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBuilder,
          jni.JniType.voidType, [builder.reference]).check();

  static final _id_checkBuilder =
      jniAccessors.getMethodIDOf(_classRef, "checkBuilder", "()V");

  /// from: protected void checkBuilder()
  void checkBuilder() => jniAccessors.callMethodWithArgs(
      reference, _id_checkBuilder, jni.JniType.voidType, []).check();

  static final _id_getStandardView = jniAccessors.getMethodIDOf(
      _classRef, "getStandardView", "(I)Landroid/widget/RemoteViews;");

  /// from: protected android.widget.RemoteViews getStandardView(int layoutId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  remoteviews_.RemoteViews getStandardView(int layoutId) =>
      remoteviews_.RemoteViews.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStandardView,
          jni.JniType.objectType,
          [layoutId]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/app/Notification;");

  /// from: public android.app.Notification build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calls android.app.Notification.Builder\#build() on the Builder this Style is
  /// attached to.
  ///@return the fully constructed Notification.
  Notification build() => Notification.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_build, jni.JniType.objectType, []).object);
}

/// from: android.app.Notification$MessagingStyle
///
/// Helper class for generating large-format notifications that include multiple back-and-forth
/// messages of varying types between any number of people.
///
///
/// If the platform does not provide large-format notifications, this method has no effect. The
/// user will always see the normal notification view.
///
///
/// If the app is targeting Android P and above, it is required to use the Person
/// class in order to get an optimal rendering of the notification and its avatars. For
/// conversations involving multiple people, the app should also make sure that it marks the
/// conversation as a group with \#setGroupConversation(boolean).
///
///
/// This class is a "rebuilder": It attaches to a Builder object and modifies its behavior.
/// Here's an example of how this may be used:
/// <pre class="prettyprint">
///
/// Person user = new Person.Builder().setIcon(userIcon).setName(userName).build();
/// MessagingStyle style = new MessagingStyle(user)
///      .addMessage(messages[1].getText(), messages[1].getTime(), messages[1].getPerson())
///      .addMessage(messages[2].getText(), messages[2].getTime(), messages[2].getPerson())
///      .setGroupConversation(hasMultiplePeople());
///
/// Notification noti = new Notification.Builder()
///     .setContentTitle(&quot;2 new messages with &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_message)
///     .setLargeIcon(aBitmap)
///     .setStyle(style)
///     .build();
/// </pre>
class Notification_MessagingStyle extends Notification_Style {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$MessagingStyle");
  Notification_MessagingStyle.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MAXIMUM_RETAINED_MESSAGES
  ///
  /// The maximum number of messages that will be retained in the Notification itself (the
  /// number displayed is up to the platform).
  static const MAXIMUM_RETAINED_MESSAGES = 25;

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/CharSequence;)V");

  /// from: public void <init>(java.lang.CharSequence userDisplayName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param userDisplayName Required - the name to be displayed for any replies sent by the
  /// user before the posting app reposts the notification with those messages after they've
  /// been actually sent and in previous messages sent by the user added in
  /// \#addMessage(Notification.MessagingStyle.Message)
  ///
  /// This value must never be {@code null}.
  ///@deprecated use {@code MessagingStyle(Person)}
  Notification_MessagingStyle.ctor1(jni.JniObject userDisplayName)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [userDisplayName.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Person;)V");

  /// from: public void <init>(android.app.Person user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param user Required - The person displayed for any messages that are sent by the
  /// user. Any messages added with \#addMessage(Notification.MessagingStyle.Message)
  /// who don't have a Person associated with it will be displayed as if they were sent
  /// by this user. The user also needs to have a valid name associated with it, which will
  /// be enforced starting in Android P.
  ///
  /// This value must never be {@code null}.
  Notification_MessagingStyle.ctor2(person_.Person user)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [user.reference]).object);

  static final _id_getUser = jniAccessors.getMethodIDOf(
      _classRef, "getUser", "()Landroid/app/Person;");

  /// from: public android.app.Person getUser()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the user to be displayed for any replies sent by the user
  ///
  /// This value will never be {@code null}.
  person_.Person getUser() =>
      person_.Person.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUser, jni.JniType.objectType, []).object);

  static final _id_getUserDisplayName = jniAccessors.getMethodIDOf(
      _classRef, "getUserDisplayName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getUserDisplayName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name to be displayed for any replies sent by the user
  ///@deprecated use \#getUser() instead
  jni.JniObject getUserDisplayName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getUserDisplayName, jni.JniType.objectType, []).object);

  static final _id_setConversationTitle = jniAccessors.getMethodIDOf(
      _classRef,
      "setConversationTitle",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$MessagingStyle;");

  /// from: public android.app.Notification.MessagingStyle setConversationTitle(java.lang.CharSequence conversationTitle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the title to be displayed on this conversation. May be set to {@code null}.
  ///
  /// This API's behavior was changed in SDK version Build.VERSION_CODES\#P. If your
  /// application's target version is less than Build.VERSION_CODES\#P, setting a
  /// conversation title to a non-null value will make \#isGroupConversation() return
  /// {@code true} and passing {@code null} will make it return {@code false}. In
  /// Build.VERSION_CODES\#P and beyond, use \#setGroupConversation(boolean)
  /// to set group conversation status.
  ///@param conversationTitle Title displayed for this conversation
  /// This value may be {@code null}.
  ///@return this object for method chaining
  Notification_MessagingStyle setConversationTitle(
          jni.JniObject conversationTitle) =>
      Notification_MessagingStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setConversationTitle,
          jni.JniType.objectType,
          [conversationTitle.reference]).object);

  static final _id_getConversationTitle = jniAccessors.getMethodIDOf(
      _classRef, "getConversationTitle", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getConversationTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the title to be displayed on this conversation. May return {@code null}.
  jni.JniObject getConversationTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConversationTitle, jni.JniType.objectType, []).object);

  static final _id_addMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "addMessage",
      "(Ljava/lang/CharSequence;JLjava/lang/CharSequence;)Landroid/app/Notification\$MessagingStyle;");

  /// from: public android.app.Notification.MessagingStyle addMessage(java.lang.CharSequence text, long timestamp, java.lang.CharSequence sender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a message for display by this notification. Convenience call for a simple
  /// Message in \#addMessage(Notification.MessagingStyle.Message).
  ///@param text A CharSequence to be displayed as the message content
  ///@param timestamp Time at which the message arrived
  ///@param sender A CharSequence to be used for displaying the name of the
  /// sender. Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert \#getUserDisplayName().
  /// Should be unique amongst all individuals in the conversation, and should be
  /// consistent during re-posts of the notification.
  ///@see Message\#Message(CharSequence, long, CharSequence)
  ///@return this object for method chaining
  ///@deprecated use \#addMessage(CharSequence, long, Person)
  Notification_MessagingStyle addMessage(
          jni.JniObject text, int timestamp, jni.JniObject sender) =>
      Notification_MessagingStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addMessage,
          jni.JniType.objectType,
          [text.reference, timestamp, sender.reference]).object);

  static final _id_addMessage1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addMessage",
      "(Ljava/lang/CharSequence;JLandroid/app/Person;)Landroid/app/Notification\$MessagingStyle;");

  /// from: public android.app.Notification.MessagingStyle addMessage(java.lang.CharSequence text, long timestamp, android.app.Person sender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a message for display by this notification. Convenience call for a simple
  /// Message in \#addMessage(Notification.MessagingStyle.Message).
  ///@param text A CharSequence to be displayed as the message content
  /// This value must never be {@code null}.
  ///@param timestamp Time at which the message arrived
  ///@param sender The Person who sent the message.
  /// Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert the user set in {@code MessagingStyle(Person)}.
  ///
  /// This value may be {@code null}.
  ///@see Message\#Message(CharSequence, long, CharSequence)
  ///@return this object for method chaining
  Notification_MessagingStyle addMessage1(
          jni.JniObject text, int timestamp, person_.Person sender) =>
      Notification_MessagingStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addMessage1,
          jni.JniType.objectType,
          [text.reference, timestamp, sender.reference]).object);

  static final _id_addMessage2 = jniAccessors.getMethodIDOf(
      _classRef,
      "addMessage",
      "(Landroid/app/Notification\$MessagingStyle\$Message;)Landroid/app/Notification\$MessagingStyle;");

  /// from: public android.app.Notification.MessagingStyle addMessage(android.app.Notification.MessagingStyle.Message message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a Message for display in this notification.
  ///
  /// The messages should be added in chronologic order, i.e. the oldest first,
  /// the newest last.
  ///@param message The Message to be displayed
  ///@return this object for method chaining
  Notification_MessagingStyle addMessage2(
          Notification_MessagingStyle_Message message) =>
      Notification_MessagingStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addMessage2,
          jni.JniType.objectType,
          [message.reference]).object);

  static final _id_addHistoricMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "addHistoricMessage",
      "(Landroid/app/Notification\$MessagingStyle\$Message;)Landroid/app/Notification\$MessagingStyle;");

  /// from: public android.app.Notification.MessagingStyle addHistoricMessage(android.app.Notification.MessagingStyle.Message message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a Message for historic context in this notification.
  ///
  /// Messages should be added as historic if they are not the main subject of the
  /// notification but may give context to a conversation. The system may choose to present
  /// them only when relevant, e.g. when replying to a message through a RemoteInput.
  ///
  /// The messages should be added in chronologic order, i.e. the oldest first,
  /// the newest last.
  ///@param message The historic Message to be added
  ///@return this object for method chaining
  Notification_MessagingStyle addHistoricMessage(
          Notification_MessagingStyle_Message message) =>
      Notification_MessagingStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addHistoricMessage,
          jni.JniType.objectType,
          [message.reference]).object);

  static final _id_getMessages = jniAccessors.getMethodIDOf(
      _classRef, "getMessages", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.Notification.MessagingStyle.Message> getMessages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of {@code Message} objects that represent the notification
  jni.JniObject getMessages() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMessages, jni.JniType.objectType, []).object);

  static final _id_getHistoricMessages = jniAccessors.getMethodIDOf(
      _classRef, "getHistoricMessages", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.Notification.MessagingStyle.Message> getHistoricMessages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of historic {@code Message}s in the notification.
  jni.JniObject getHistoricMessages() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getHistoricMessages, jni.JniType.objectType, []).object);

  static final _id_setGroupConversation = jniAccessors.getMethodIDOf(_classRef,
      "setGroupConversation", "(Z)Landroid/app/Notification\$MessagingStyle;");

  /// from: public android.app.Notification.MessagingStyle setGroupConversation(boolean isGroupConversation)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether this conversation notification represents a group. If the app is targeting
  /// Android P, this is required if the app wants to display the largeIcon set with
  /// Notification.Builder\#setLargeIcon(Bitmap), otherwise it will be hidden.
  ///@param isGroupConversation {@code true} if the conversation represents a group,
  /// {@code false} otherwise.
  ///@return this object for method chaining
  Notification_MessagingStyle setGroupConversation(bool isGroupConversation) =>
      Notification_MessagingStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setGroupConversation,
          jni.JniType.objectType,
          [isGroupConversation]).object);

  static final _id_isGroupConversation =
      jniAccessors.getMethodIDOf(_classRef, "isGroupConversation", "()Z");

  /// from: public boolean isGroupConversation()
  ///
  /// Returns {@code true} if this notification represents a group conversation, otherwise
  /// {@code false}.
  ///
  ///  If the application that generated this MessagingStyle targets an SDK version
  /// less than Build.VERSION_CODES\#P, this method becomes dependent on whether or
  /// not the conversation title is set; returning {@code true} if the conversation title is
  /// a non-null value, or {@code false} otherwise. From Build.VERSION_CODES\#P forward,
  /// this method returns what's set by \#setGroupConversation(boolean) allowing for
  /// named, non-group conversations.
  ///@see \#setConversationTitle(CharSequence)
  bool isGroupConversation() => jniAccessors.callMethodWithArgs(
      reference, _id_isGroupConversation, jni.JniType.booleanType, []).boolean;
}

/// from: android.app.Notification$MessagingStyle$Message
class Notification_MessagingStyle_Message extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/Notification\$MessagingStyle\$Message");
  Notification_MessagingStyle_Message.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/CharSequence;JLjava/lang/CharSequence;)V");

  /// from: public void <init>(java.lang.CharSequence text, long timestamp, java.lang.CharSequence sender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor
  ///@param text A CharSequence to be displayed as the message content
  ///@param timestamp Time at which the message arrived
  ///@param sender A CharSequence to be used for displaying the name of the
  /// sender. Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert MessagingStyle\#getUserDisplayName().
  /// Should be unique amongst all individuals in the conversation, and should be
  /// consistent during re-posts of the notification.
  ///@deprecated use {@code Message(CharSequence, long, Person)}
  Notification_MessagingStyle_Message(
      jni.JniObject text, int timestamp, jni.JniObject sender)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [text.reference, timestamp, sender.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/CharSequence;JLandroid/app/Person;)V");

  /// from: public void <init>(java.lang.CharSequence text, long timestamp, android.app.Person sender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor
  ///@param text A CharSequence to be displayed as the message content
  /// This value must never be {@code null}.
  ///@param timestamp Time at which the message arrived
  ///@param sender The Person who sent the message.
  /// Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert the user set in {@code MessagingStyle(Person)}.
  ///
  /// The person provided should contain an Icon, set with
  /// Person.Builder\#setIcon(Icon) and also have a name provided
  /// with Person.Builder\#setName(CharSequence). If multiple users have the same
  /// name, consider providing a key with Person.Builder\#setKey(String) in order
  /// to differentiate between the different users.
  ///
  ///
  ///
  /// This value may be {@code null}.
  Notification_MessagingStyle_Message.ctor1(
      jni.JniObject text, int timestamp, person_.Person sender)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [text.reference, timestamp, sender.reference]).object);

  static final _id_setData = jniAccessors.getMethodIDOf(_classRef, "setData",
      "(Ljava/lang/String;Landroid/net/Uri;)Landroid/app/Notification\$MessagingStyle\$Message;");

  /// from: public android.app.Notification.MessagingStyle.Message setData(java.lang.String dataMimeType, android.net.Uri dataUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a binary blob of data and an associated MIME type for a message. In the case
  /// where the platform doesn't support the MIME type, the original text provided in the
  /// constructor will be used.
  ///@param dataMimeType The MIME type of the content. See
  /// <a href="{@docRoot}notifications/messaging.html"> for the list of supported MIME
  /// types on Android and Android Wear.
  ///@param dataUri The uri containing the content whose type is given by the MIME type.
  /// <p class="note">
  /// <ol>
  ///   <li>Notification Listeners including the System UI need permission to access the
  ///       data the Uri points to. The recommended ways to do this are:</li>
  ///   <li>Store the data in your own ContentProvider, making sure that other apps have
  ///       the correct permission to access your provider. The preferred mechanism for
  ///       providing access is to use per-URI permissions which are temporary and only
  ///       grant access to the receiving application. An easy way to create a
  ///       ContentProvider like this is to use the FileProvider helper class.</li>
  ///   <li>Use the system MediaStore. The MediaStore is primarily aimed at video, audio
  ///       and image MIME types, however beginning with Android 3.0 (API level 11) it can
  ///       also store non-media types (see MediaStore.Files for more info). Files can be
  ///       inserted into the MediaStore using scanFile() after which a content:// style
  ///       Uri suitable for sharing is passed to the provided onScanCompleted() callback.
  ///       Note that once added to the system MediaStore the content is accessible to any
  ///       app on the device.</li>
  /// </ol>
  ///@return this object for method chaining
  Notification_MessagingStyle_Message setData(
          jni.JniString dataMimeType, uri_.Uri dataUri) =>
      Notification_MessagingStyle_Message.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setData, jni.JniType.objectType,
              [dataMimeType.reference, dataUri.reference]).object);

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the text to be used for this message, or the fallback text if a type and content
  /// Uri have been set
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_getTimestamp =
      jniAccessors.getMethodIDOf(_classRef, "getTimestamp", "()J");

  /// from: public long getTimestamp()
  ///
  /// Get the time at which this message arrived
  int getTimestamp() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimestamp, jni.JniType.longType, []).long;

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the extras Bundle for this message.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_getSender = jniAccessors.getMethodIDOf(
      _classRef, "getSender", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getSender()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the text used to display the contact's name in the messaging experience
  ///@deprecated use \#getSenderPerson()
  jni.JniObject getSender() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSender, jni.JniType.objectType, []).object);

  static final _id_getSenderPerson = jniAccessors.getMethodIDOf(
      _classRef, "getSenderPerson", "()Landroid/app/Person;");

  /// from: public android.app.Person getSenderPerson()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the sender associated with this message.
  ///@return This value may be {@code null}.
  person_.Person getSenderPerson() =>
      person_.Person.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSenderPerson, jni.JniType.objectType, []).object);

  static final _id_getDataMimeType = jniAccessors.getMethodIDOf(
      _classRef, "getDataMimeType", "()Ljava/lang/String;");

  /// from: public java.lang.String getDataMimeType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the MIME type of the data pointed to by the Uri
  jni.JniString getDataMimeType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDataMimeType, jni.JniType.objectType, []).object);

  static final _id_getDataUri = jniAccessors.getMethodIDOf(
      _classRef, "getDataUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getDataUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the the Uri pointing to the content of the message. Can be null, in which case
  /// {@see \#getText()} is used.
  uri_.Uri getDataUri() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getDataUri, jni.JniType.objectType, []).object);
}

/// from: android.app.Notification$MediaStyle
///
/// Notification style for media playback notifications.
///
/// In the expanded form, Notification\#bigContentView, up to 5
/// Notification.Actions specified with
/// Notification.Builder\#addAction(Action) addAction will be
/// shown as icon-only pushbuttons, suitable for transport controls. The Bitmap given to
/// Notification.Builder\#setLargeIcon(android.graphics.Bitmap) setLargeIcon() will be
/// treated as album artwork.
///
/// Unlike the other styles provided here, MediaStyle can also modify the standard-size
/// Notification\#contentView; by providing action indices to
/// \#setShowActionsInCompactView(int...) you can promote up to 3 actions to be displayed
/// in the standard view alongside the usual content.
///
/// Notifications created with MediaStyle will have their category set to
/// Notification\#CATEGORY_TRANSPORT CATEGORY_TRANSPORT unless you set a different
/// category using Notification.Builder\#setCategory(String) setCategory().
///
/// Finally, if you attach a android.media.session.MediaSession.Token using
/// android.app.Notification.MediaStyle\#setMediaSession(MediaSession.Token),
/// the System UI can identify this as a notification representing an active media session
/// and respond accordingly (by showing album artwork in the lockscreen, for example).
///
///
/// Starting at android.os.Build.VERSION_CODES\#O Android O any notification that has a
/// media session attached with \#setMediaSession(MediaSession.Token) will be colorized.
/// You can opt-out of this behavior by using Notification.Builder\#setColorized(boolean).
///
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setContentTitle(&quot;Track title&quot;)
///     .setContentText(&quot;Artist - Album&quot;)
///     .setLargeIcon(albumArtBitmap))
///     .setStyle(__new Notification.MediaStyle()__
///         .setMediaSession(mySession))
///     .build();
/// </pre>
///@see Notification\#bigContentView
///@see Notification.Builder\#setColorized(boolean)
class Notification_MediaStyle extends Notification_Style {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$MediaStyle");
  Notification_MediaStyle.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_MediaStyle()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Notification\$Builder;)V");

  /// from: public void <init>(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated use {@code MediaStyle()}.
  Notification_MediaStyle.ctor1(Notification_Builder builder)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [builder.reference]).object);

  static final _id_setShowActionsInCompactView = jniAccessors.getMethodIDOf(
      _classRef,
      "setShowActionsInCompactView",
      "([I)Landroid/app/Notification\$MediaStyle;");

  /// from: public android.app.Notification.MediaStyle setShowActionsInCompactView(int[] actions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request up to 3 actions (by index in the order of addition) to be shown in the compact
  /// notification view.
  ///@param actions the indices of the actions to show in the compact notification view
  Notification_MediaStyle setShowActionsInCompactView(jni.JniObject actions) =>
      Notification_MediaStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setShowActionsInCompactView,
          jni.JniType.objectType,
          [actions.reference]).object);

  static final _id_setMediaSession = jniAccessors.getMethodIDOf(
      _classRef,
      "setMediaSession",
      "(Landroid/media/session/MediaSession\$Token;)Landroid/app/Notification\$MediaStyle;");

  /// from: public android.app.Notification.MediaStyle setMediaSession(android.media.session.MediaSession.Token token)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attach a android.media.session.MediaSession.Token to this Notification
  /// to provide additional playback information and control to the SystemUI.
  Notification_MediaStyle setMediaSession(
          mediasession_.MediaSession_Token token) =>
      Notification_MediaStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setMediaSession,
          jni.JniType.objectType,
          [token.reference]).object);
}

/// from: android.app.Notification$InboxStyle
///
/// Helper class for generating large-format notifications that include a list of (up to 5) strings.
///
/// Here's how you'd set the <code>InboxStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;5 New mails from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_mail)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.InboxStyle()
///         .addLine(str1)
///         .addLine(str2)
///         .setContentTitle(&quot;&quot;)
///         .setSummaryText(&quot;+3 more&quot;))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_InboxStyle extends Notification_Style {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$InboxStyle");
  Notification_InboxStyle.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_InboxStyle()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Notification\$Builder;)V");

  /// from: public void <init>(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated use {@code InboxStyle()}.
  Notification_InboxStyle.ctor1(Notification_Builder builder)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [builder.reference]).object);

  static final _id_setBigContentTitle = jniAccessors.getMethodIDOf(
      _classRef,
      "setBigContentTitle",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$InboxStyle;");

  /// from: public android.app.Notification.InboxStyle setBigContentTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_InboxStyle setBigContentTitle(jni.JniObject title) =>
      Notification_InboxStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setBigContentTitle,
          jni.JniType.objectType,
          [title.reference]).object);

  static final _id_setSummaryText = jniAccessors.getMethodIDOf(
      _classRef,
      "setSummaryText",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$InboxStyle;");

  /// from: public android.app.Notification.InboxStyle setSummaryText(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_InboxStyle setSummaryText(jni.JniObject cs) =>
      Notification_InboxStyle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setSummaryText, jni.JniType.objectType, [cs.reference]).object);

  static final _id_addLine = jniAccessors.getMethodIDOf(_classRef, "addLine",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$InboxStyle;");

  /// from: public android.app.Notification.InboxStyle addLine(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Append a line to the digest section of the Inbox notification.
  Notification_InboxStyle addLine(jni.JniObject cs) =>
      Notification_InboxStyle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addLine, jni.JniType.objectType, [cs.reference]).object);
}

/// from: android.app.Notification$Extender
///
/// Extender interface for use with Builder\#extend. Extenders may be used to add
/// metadata or change options on a notification builder.
class Notification_Extender extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$Extender");
  Notification_Extender.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_extend = jniAccessors.getMethodIDOf(_classRef, "extend",
      "(Landroid/app/Notification\$Builder;)Landroid/app/Notification\$Builder;");

  /// from: public abstract android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply this extender to a notification builder.
  ///@param builder the builder to be modified.
  ///@return the build object for chaining.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_extend, jni.JniType.objectType, [builder.reference]).object);
}

/// from: android.app.Notification$DecoratedMediaCustomViewStyle
///
/// Notification style for media custom views that are decorated by the system
///
/// Instead of providing a media notification that is completely custom, a developer can set
/// this style and still obtain system decorations like the notification header with the expand
/// affordance and actions.
///
/// Use android.app.Notification.Builder\#setCustomContentView(RemoteViews),
/// android.app.Notification.Builder\#setCustomBigContentView(RemoteViews) and
/// android.app.Notification.Builder\#setCustomHeadsUpContentView(RemoteViews) to set the
/// corresponding custom views to display.
///
/// Contrary to MediaStyle a developer has to opt-in to the colorizing of the
/// notification by using Notification.Builder\#setColorized(boolean).
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setLargeIcon(albumArtBitmap))
///     .setCustomContentView(contentView);
///     .setStyle(__new Notification.DecoratedMediaCustomViewStyle()__
///          .setMediaSession(mySession))
///     .build();
/// </pre>
///@see android.app.Notification.DecoratedCustomViewStyle
///@see android.app.Notification.MediaStyle
class Notification_DecoratedMediaCustomViewStyle
    extends Notification_MediaStyle {
  static final _classRef = jniAccessors
      .getClassOf("android/app/Notification\$DecoratedMediaCustomViewStyle");
  Notification_DecoratedMediaCustomViewStyle.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_DecoratedMediaCustomViewStyle()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.app.Notification$DecoratedCustomViewStyle
///
/// Notification style for custom views that are decorated by the system
///
/// Instead of providing a notification that is completely custom, a developer can set this
/// style and still obtain system decorations like the notification header with the expand
/// affordance and actions.
///
/// Use android.app.Notification.Builder\#setCustomContentView(RemoteViews),
/// android.app.Notification.Builder\#setCustomBigContentView(RemoteViews) and
/// android.app.Notification.Builder\#setCustomHeadsUpContentView(RemoteViews) to set the
/// corresponding custom views to display.
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setLargeIcon(albumArtBitmap))
///     .setCustomContentView(contentView);
///     .setStyle(__new Notification.DecoratedCustomViewStyle()__)
///     .build();
/// </pre>
class Notification_DecoratedCustomViewStyle extends Notification_Style {
  static final _classRef = jniAccessors
      .getClassOf("android/app/Notification\$DecoratedCustomViewStyle");
  Notification_DecoratedCustomViewStyle.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_DecoratedCustomViewStyle()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.app.Notification$CarExtender
///
/// Helper class to add Android Auto extensions to notifications. To create a notification
/// with car extensions:
///
/// <ol>
///  <li>Create an Notification.Builder, setting any desired
///  properties.
///  <li>Create a CarExtender.
///  <li>Set car-specific properties using the {@code add} and {@code set} methods of
///  CarExtender.
///  <li>Call Notification.Builder\#extend(Notification.Extender)
///  to apply the extensions to a notification.
/// </ol>
///
/// <pre class="prettyprint">
/// Notification notification = new Notification.Builder(context)
///         ...
///         .extend(new CarExtender()
///                 .set*(...))
///         .build();
/// </pre>
///
/// Car extensions can be accessed on an existing notification by using the
/// {@code CarExtender(Notification)} constructor, and then using the {@code get} methods
/// to access values.
class Notification_CarExtender extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$CarExtender");
  Notification_CarExtender.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a CarExtender with default options.
  Notification_CarExtender()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Notification;)V");

  /// from: public void <init>(android.app.Notification notif)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a CarExtender from the CarExtender options of an existing Notification.
  ///@param notif The notification from which to copy options.
  Notification_CarExtender.ctor1(Notification notif)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [notif.reference]).object);

  static final _id_extend = jniAccessors.getMethodIDOf(_classRef, "extend",
      "(Landroid/app/Notification\$Builder;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply car extensions to a notification that is being built. This is typically called by
  /// the Notification.Builder\#extend(Notification.Extender)
  /// method of Notification.Builder.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_extend, jni.JniType.objectType, [builder.reference]).object);

  static final _id_setColor = jniAccessors.getMethodIDOf(
      _classRef, "setColor", "(I)Landroid/app/Notification\$CarExtender;");

  /// from: public android.app.Notification.CarExtender setColor(int color)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the accent color to use when Android Auto presents the notification.
  ///
  /// Android Auto uses the color set with Notification.Builder\#setColor(int)
  /// to accent the displayed notification. However, not all colors are acceptable in an
  /// automotive setting. This method can be used to override the color provided in the
  /// notification in such a situation.
  Notification_CarExtender setColor(int color) =>
      Notification_CarExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setColor, jni.JniType.objectType, [color]).object);

  static final _id_getColor =
      jniAccessors.getMethodIDOf(_classRef, "getColor", "()I");

  /// from: public int getColor()
  ///
  /// Gets the accent color.
  ///@see \#setColor
  int getColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getColor, jni.JniType.intType, []).integer;

  static final _id_setLargeIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "setLargeIcon",
      "(Landroid/graphics/Bitmap;)Landroid/app/Notification\$CarExtender;");

  /// from: public android.app.Notification.CarExtender setLargeIcon(android.graphics.Bitmap largeIcon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the large icon of the car notification.
  ///
  /// If no large icon is set in the extender, Android Auto will display the icon
  /// specified by Notification.Builder\#setLargeIcon(android.graphics.Bitmap)
  ///@param largeIcon The large icon to use in the car notification.
  ///@return This object for method chaining.
  Notification_CarExtender setLargeIcon(bitmap_.Bitmap largeIcon) =>
      Notification_CarExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setLargeIcon,
          jni.JniType.objectType,
          [largeIcon.reference]).object);

  static final _id_getLargeIcon = jniAccessors.getMethodIDOf(
      _classRef, "getLargeIcon", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getLargeIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the large icon used in this car notification, or null if no icon has been set.
  ///@return The large icon for the car notification.
  ///@see CarExtender\#setLargeIcon
  bitmap_.Bitmap getLargeIcon() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLargeIcon, jni.JniType.objectType, []).object);

  static final _id_setUnreadConversation = jniAccessors.getMethodIDOf(
      _classRef,
      "setUnreadConversation",
      "(Landroid/app/Notification\$CarExtender\$UnreadConversation;)Landroid/app/Notification\$CarExtender;");

  /// from: public android.app.Notification.CarExtender setUnreadConversation(android.app.Notification.CarExtender.UnreadConversation unreadConversation)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the unread conversation in a message notification.
  ///@param unreadConversation The unread part of the conversation this notification conveys.
  ///@return This object for method chaining.
  Notification_CarExtender setUnreadConversation(
          Notification_CarExtender_UnreadConversation unreadConversation) =>
      Notification_CarExtender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setUnreadConversation,
          jni.JniType.objectType,
          [unreadConversation.reference]).object);

  static final _id_getUnreadConversation = jniAccessors.getMethodIDOf(
      _classRef,
      "getUnreadConversation",
      "()Landroid/app/Notification\$CarExtender\$UnreadConversation;");

  /// from: public android.app.Notification.CarExtender.UnreadConversation getUnreadConversation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the unread conversation conveyed by this notification.
  ///@see \#setUnreadConversation(UnreadConversation)
  Notification_CarExtender_UnreadConversation getUnreadConversation() =>
      Notification_CarExtender_UnreadConversation.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getUnreadConversation,
              jni.JniType.objectType, []).object);
}

/// from: android.app.Notification$CarExtender$UnreadConversation
///
/// A class which holds the unread messages from a conversation.
class Notification_CarExtender_UnreadConversation extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/Notification\$CarExtender\$UnreadConversation");
  Notification_CarExtender_UnreadConversation.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_getMessages = jniAccessors.getMethodIDOf(
      _classRef, "getMessages", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getMessages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of messages conveyed by this notification.
  jni.JniObject getMessages() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMessages, jni.JniType.objectType, []).object);

  static final _id_getRemoteInput = jniAccessors.getMethodIDOf(
      _classRef, "getRemoteInput", "()Landroid/app/RemoteInput;");

  /// from: public android.app.RemoteInput getRemoteInput()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the remote input that will be used to convey the response to a message list, or
  /// null if no such remote input exists.
  remoteinput_.RemoteInput getRemoteInput() =>
      remoteinput_.RemoteInput.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRemoteInput, jni.JniType.objectType, []).object);

  static final _id_getReplyPendingIntent = jniAccessors.getMethodIDOf(
      _classRef, "getReplyPendingIntent", "()Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getReplyPendingIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the pending intent that will be triggered when the user replies to this
  /// notification.
  pendingintent_.PendingIntent getReplyPendingIntent() =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getReplyPendingIntent,
          jni.JniType.objectType, []).object);

  static final _id_getReadPendingIntent = jniAccessors.getMethodIDOf(
      _classRef, "getReadPendingIntent", "()Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getReadPendingIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the pending intent that Android Auto will send after it reads aloud all messages
  /// in this object's message list.
  pendingintent_.PendingIntent getReadPendingIntent() =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getReadPendingIntent,
          jni.JniType.objectType, []).object);

  static final _id_getParticipants = jniAccessors.getMethodIDOf(
      _classRef, "getParticipants", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getParticipants()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the participants in the conversation.
  jni.JniObject getParticipants() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getParticipants, jni.JniType.objectType, []).object);

  static final _id_getParticipant = jniAccessors.getMethodIDOf(
      _classRef, "getParticipant", "()Ljava/lang/String;");

  /// from: public java.lang.String getParticipant()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the firs participant in the conversation.
  jni.JniString getParticipant() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getParticipant, jni.JniType.objectType, []).object);

  static final _id_getLatestTimestamp =
      jniAccessors.getMethodIDOf(_classRef, "getLatestTimestamp", "()J");

  /// from: public long getLatestTimestamp()
  ///
  /// Gets the timestamp of the conversation.
  int getLatestTimestamp() => jniAccessors.callMethodWithArgs(
      reference, _id_getLatestTimestamp, jni.JniType.longType, []).long;
}

/// from: android.app.Notification$CarExtender$Builder
///
/// Builder class for CarExtender.UnreadConversation objects.
class Notification_CarExtender_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$CarExtender\$Builder");
  Notification_CarExtender_Builder.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new builder for CarExtender.UnreadConversation.
  ///@param name The name of the other participant in the conversation.
  Notification_CarExtender_Builder(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [name.reference]).object);

  static final _id_addMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "addMessage",
      "(Ljava/lang/String;)Landroid/app/Notification\$CarExtender\$Builder;");

  /// from: public android.app.Notification.CarExtender.Builder addMessage(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Appends a new unread message to the list of messages for this conversation.
  ///
  /// The messages should be added from oldest to newest.
  ///@param message The text of the new unread message.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder addMessage(jni.JniString message) =>
      Notification_CarExtender_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addMessage,
          jni.JniType.objectType,
          [message.reference]).object);

  static final _id_setReplyAction = jniAccessors.getMethodIDOf(
      _classRef,
      "setReplyAction",
      "(Landroid/app/PendingIntent;Landroid/app/RemoteInput;)Landroid/app/Notification\$CarExtender\$Builder;");

  /// from: public android.app.Notification.CarExtender.Builder setReplyAction(android.app.PendingIntent pendingIntent, android.app.RemoteInput remoteInput)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the pending intent and remote input which will convey the reply to this
  /// notification.
  ///@param pendingIntent The pending intent which will be triggered on a reply.
  ///@param remoteInput The remote input parcelable which will carry the reply.
  ///@return This object for method chaining.
  ///@see CarExtender.UnreadConversation\#getRemoteInput
  ///@see CarExtender.UnreadConversation\#getReplyPendingIntent
  Notification_CarExtender_Builder setReplyAction(
          pendingintent_.PendingIntent pendingIntent,
          remoteinput_.RemoteInput remoteInput) =>
      Notification_CarExtender_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setReplyAction,
          jni.JniType.objectType,
          [pendingIntent.reference, remoteInput.reference]).object);

  static final _id_setReadPendingIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "setReadPendingIntent",
      "(Landroid/app/PendingIntent;)Landroid/app/Notification\$CarExtender\$Builder;");

  /// from: public android.app.Notification.CarExtender.Builder setReadPendingIntent(android.app.PendingIntent pendingIntent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the pending intent that will be sent once the messages in this notification
  /// are read.
  ///@param pendingIntent The pending intent to use.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder setReadPendingIntent(
          pendingintent_.PendingIntent pendingIntent) =>
      Notification_CarExtender_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setReadPendingIntent,
          jni.JniType.objectType,
          [pendingIntent.reference]).object);

  static final _id_setLatestTimestamp = jniAccessors.getMethodIDOf(
      _classRef,
      "setLatestTimestamp",
      "(J)Landroid/app/Notification\$CarExtender\$Builder;");

  /// from: public android.app.Notification.CarExtender.Builder setLatestTimestamp(long timestamp)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the timestamp of the most recent message in an unread conversation.
  ///
  /// If a messaging notification has been posted by your application and has not
  /// yet been cancelled, posting a later notification with the same id and tag
  /// but without a newer timestamp may result in Android Auto not displaying a
  /// heads up notification for the later notification.
  ///@param timestamp The timestamp of the most recent message in the conversation.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder setLatestTimestamp(int timestamp) =>
      Notification_CarExtender_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setLatestTimestamp,
          jni.JniType.objectType,
          [timestamp]).object);

  static final _id_build = jniAccessors.getMethodIDOf(_classRef, "build",
      "()Landroid/app/Notification\$CarExtender\$UnreadConversation;");

  /// from: public android.app.Notification.CarExtender.UnreadConversation build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds a new unread conversation object.
  ///@return The new unread conversation object.
  Notification_CarExtender_UnreadConversation build() =>
      Notification_CarExtender_UnreadConversation.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_build, jni.JniType.objectType, []).object);
}

/// from: android.app.Notification$Builder
///
/// Builder class for Notification objects.
///
/// Provides a convenient way to set the various fields of a Notification and generate
/// content views using the platform's notification layout template. If your app supports
/// versions of Android as old as API level 4, you can instead use
/// android.support.v4.app.NotificationCompat.Builder NotificationCompat.Builder,
/// available in the <a href="{@docRoot}tools/extras/support-library.html">Android Support
/// library</a>.
///
/// Example:
///
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder(mContext)
///         .setContentTitle(&quot;New mail from &quot; + sender.toString())
///         .setContentText(subject)
///         .setSmallIcon(R.drawable.new_mail)
///         .setLargeIcon(aBitmap)
///         .build();
/// </pre>
class Notification_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$Builder");
  Notification_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Ljava/lang/String;)V");

  /// from: public void <init>(android.content.Context context, java.lang.String channelId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new Builder with the defaults:
  ///@param context A Context that will be used by the Builder to construct the
  ///            RemoteViews. The Context will not be held past the lifetime of this Builder
  ///            object.
  ///@param channelId The constructed Notification will be posted on this
  ///            NotificationChannel. To use a NotificationChannel, it must first be
  ///            created using NotificationManager\#createNotificationChannel.
  Notification_Builder(context_.Context context, jni.JniString channelId)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [context.reference, channelId.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated use Notification.Builder\#Notification.Builder(Context, String)
  /// instead. All posted Notifications must specify a NotificationChannel Id.
  Notification_Builder.ctor1(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference]).object);

  static final _id_setShortcutId = jniAccessors.getMethodIDOf(
      _classRef,
      "setShortcutId",
      "(Ljava/lang/String;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setShortcutId(java.lang.String shortcutId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this notification is duplicative of a Launcher shortcut, sets the
  /// ShortcutInfo\#getId() id of the shortcut, in case the Launcher wants to hide
  /// the shortcut.
  ///
  /// This field will be ignored by Launchers that don't support badging, don't show
  /// notification content, or don't show android.content.pm.ShortcutManager shortcuts.
  ///@param shortcutId the ShortcutInfo\#getId() id of the shortcut this notification
  ///                   supersedes
  Notification_Builder setShortcutId(jni.JniString shortcutId) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setShortcutId,
          jni.JniType.objectType,
          [shortcutId.reference]).object);

  static final _id_setBadgeIconType = jniAccessors.getMethodIDOf(
      _classRef, "setBadgeIconType", "(I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setBadgeIconType(int icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets which icon to display as a badge for this notification.
  ///
  /// Must be one of \#BADGE_ICON_NONE, \#BADGE_ICON_SMALL,
  /// \#BADGE_ICON_LARGE.
  ///
  /// Note: This value might be ignored, for launchers that don't support badge icons.
  Notification_Builder setBadgeIconType(int icon) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setBadgeIconType, jni.JniType.objectType, [icon]).object);

  static final _id_setGroupAlertBehavior = jniAccessors.getMethodIDOf(_classRef,
      "setGroupAlertBehavior", "(I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setGroupAlertBehavior(int groupAlertBehavior)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the group alert behavior for this notification. Use this method to mute this
  /// notification if alerts for this notification's group should be handled by a different
  /// notification. This is only applicable for notifications that belong to a
  /// \#setGroup(String) group. This must be called on all notifications you want to
  /// mute. For example, if you want only the summary of your group to make noise, all
  /// children in the group should have the group alert behavior \#GROUP_ALERT_SUMMARY.
  ///
  ///  The default value is \#GROUP_ALERT_ALL.
  ///
  ///@param groupAlertBehavior Value is android.app.Notification\#GROUP_ALERT_ALL, android.app.Notification\#GROUP_ALERT_CHILDREN, or android.app.Notification\#GROUP_ALERT_SUMMARY
  Notification_Builder setGroupAlertBehavior(int groupAlertBehavior) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setGroupAlertBehavior,
          jni.JniType.objectType,
          [groupAlertBehavior]).object);

  static final _id_setChannelId = jniAccessors.getMethodIDOf(
      _classRef,
      "setChannelId",
      "(Ljava/lang/String;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setChannelId(java.lang.String channelId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies the channel the notification should be delivered on.
  Notification_Builder setChannelId(jni.JniString channelId) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setChannelId,
          jni.JniType.objectType,
          [channelId.reference]).object);

  static final _id_setTimeoutAfter = jniAccessors.getMethodIDOf(
      _classRef, "setTimeoutAfter", "(J)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setTimeoutAfter(long durationMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies a duration in milliseconds after which this notification should be canceled,
  /// if it is not already canceled.
  Notification_Builder setTimeoutAfter(int durationMs) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setTimeoutAfter, jni.JniType.objectType, [durationMs]).object);

  static final _id_setWhen = jniAccessors.getMethodIDOf(
      _classRef, "setWhen", "(J)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setWhen(long when)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a timestamp pertaining to the notification (usually the time the event occurred).
  ///
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this time is not
  /// shown anymore by default and must be opted into by using
  /// android.app.Notification.Builder\#setShowWhen(boolean)
  ///@see Notification\#when
  Notification_Builder setWhen(int when) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setWhen, jni.JniType.objectType, [when]).object);

  static final _id_setShowWhen = jniAccessors.getMethodIDOf(
      _classRef, "setShowWhen", "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setShowWhen(boolean show)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Control whether the timestamp set with \#setWhen(long) setWhen is shown
  /// in the content view.
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this defaults to
  /// {@code false}. For earlier apps, the default is {@code true}.
  Notification_Builder setShowWhen(bool show0) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setShowWhen, jni.JniType.objectType, [show0]).object);

  static final _id_setUsesChronometer = jniAccessors.getMethodIDOf(_classRef,
      "setUsesChronometer", "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setUsesChronometer(boolean b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Show the Notification\#when field as a stopwatch.
  ///
  /// Instead of presenting <code>when</code> as a timestamp, the notification will show an
  /// automatically updating display of the minutes and seconds since <code>when</code>.
  ///
  /// Useful when showing an elapsed time (like an ongoing phone call).
  ///
  /// The counter can also be set to count down to <code>when</code> when using
  /// \#setChronometerCountDown(boolean).
  ///@see android.widget.Chronometer
  ///@see Notification\#when
  ///@see \#setChronometerCountDown(boolean)
  Notification_Builder setUsesChronometer(bool b) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setUsesChronometer, jni.JniType.objectType, [b]).object);

  static final _id_setChronometerCountDown = jniAccessors.getMethodIDOf(
      _classRef,
      "setChronometerCountDown",
      "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setChronometerCountDown(boolean countDown)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the Chronometer to count down instead of counting up.
  ///
  /// This is only relevant if \#setUsesChronometer(boolean) has been set to true.
  /// If it isn't set the chronometer will count up.
  ///@see \#setUsesChronometer(boolean)
  Notification_Builder setChronometerCountDown(bool countDown) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setChronometerCountDown,
          jni.JniType.objectType,
          [countDown]).object);

  static final _id_setSmallIcon = jniAccessors.getMethodIDOf(
      _classRef, "setSmallIcon", "(I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSmallIcon(int icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the small icon resource, which will be used to represent the notification in the
  /// status bar.
  ///
  ///
  /// The platform template for the expanded view will draw this icon in the left, unless a
  /// \#setLargeIcon(Bitmap) large icon has also been specified, in which case the small
  /// icon will be moved to the right-hand side.
  ///@param icon A resource ID in the application's package of the drawable to use.
  ///@see Notification\#icon
  Notification_Builder setSmallIcon(int icon) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setSmallIcon, jni.JniType.objectType, [icon]).object);

  static final _id_setSmallIcon1 = jniAccessors.getMethodIDOf(
      _classRef, "setSmallIcon", "(II)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSmallIcon(int icon, int level)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A variant of \#setSmallIcon(int) setSmallIcon(int) that takes an additional
  /// level parameter for when the icon is a android.graphics.drawable.LevelListDrawable LevelListDrawable.
  ///@param icon A resource ID in the application's package of the drawable to use.
  ///@param level The level to use for the icon.
  ///@see Notification\#icon
  ///@see Notification\#iconLevel
  Notification_Builder setSmallIcon1(int icon, int level) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setSmallIcon1, jni.JniType.objectType, [icon, level]).object);

  static final _id_setSmallIcon2 = jniAccessors.getMethodIDOf(
      _classRef,
      "setSmallIcon",
      "(Landroid/graphics/drawable/Icon;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSmallIcon(android.graphics.drawable.Icon icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the small icon, which will be used to represent the notification in the
  /// status bar and content view (unless overriden there by a
  /// \#setLargeIcon(Bitmap) large icon).
  ///@param icon An Icon object to use.
  ///@see Notification\#icon
  Notification_Builder setSmallIcon2(icon_.Icon icon) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setSmallIcon2, jni.JniType.objectType, [icon.reference]).object);

  static final _id_setContentTitle = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentTitle",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setContentTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the first line of text in the platform notification template.
  Notification_Builder setContentTitle(jni.JniObject title) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentTitle,
          jni.JniType.objectType,
          [title.reference]).object);

  static final _id_setContentText = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentText",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setContentText(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the second line of text in the platform notification template.
  Notification_Builder setContentText(jni.JniObject text) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setContentText, jni.JniType.objectType, [text.reference]).object);

  static final _id_setSubText = jniAccessors.getMethodIDOf(
      _classRef,
      "setSubText",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSubText(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This provides some additional information that is displayed in the notification. No
  /// guarantees are given where exactly it is displayed.
  ///
  /// This information should only be provided if it provides an essential
  /// benefit to the understanding of the notification. The more text you provide the
  /// less readable it becomes. For example, an email client should only provide the account
  /// name here if more than one email account has been added.
  ///
  ///
  /// As of android.os.Build.VERSION_CODES\#N this information is displayed in the
  /// notification header area.
  ///
  /// On Android versions before android.os.Build.VERSION_CODES\#N
  /// this will be shown in the third line of text in the platform notification template.
  /// You should not be using \#setProgress(int, int, boolean) at the
  /// same time on those versions; they occupy the same place.
  ///
  ///
  Notification_Builder setSubText(jni.JniObject text) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setSubText, jni.JniType.objectType, [text.reference]).object);

  static final _id_setSettingsText = jniAccessors.getMethodIDOf(
      _classRef,
      "setSettingsText",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSettingsText(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides text that will appear as a link to your application's settings.
  ///
  /// This text does not appear within notification Style templates but may
  /// appear when the user uses an affordance to learn more about the notification.
  /// Additionally, this text will not appear unless you provide a valid link target by
  /// handling \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES.
  ///
  /// This text is meant to be concise description about what the user can customize
  /// when they click on this link. The recommended maximum length is 40 characters.
  ///@param text
  ///@return
  Notification_Builder setSettingsText(jni.JniObject text) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSettingsText,
          jni.JniType.objectType,
          [text.reference]).object);

  static final _id_setRemoteInputHistory = jniAccessors.getMethodIDOf(
      _classRef,
      "setRemoteInputHistory",
      "([Ljava/lang/CharSequence;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setRemoteInputHistory(java.lang.CharSequence[] text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the remote input history.
  ///
  /// This should be set to the most recent inputs that have been sent
  /// through a RemoteInput of this Notification and cleared once the it is no
  /// longer relevant (e.g. for chat notifications once the other party has responded).
  ///
  /// The most recent input must be stored at the 0 index, the second most recent at the
  /// 1 index, etc. Note that the system will limit both how far back the inputs will be shown
  /// and how much of each individual input is shown.
  ///
  /// Note: The reply text will only be shown on notifications that have least one action
  /// with a {@code RemoteInput}.
  ///
  Notification_Builder setRemoteInputHistory(jni.JniObject text) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRemoteInputHistory,
          jni.JniType.objectType,
          [text.reference]).object);

  static final _id_setNumber = jniAccessors.getMethodIDOf(
      _classRef, "setNumber", "(I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setNumber(int number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the number of items this notification represents. May be displayed as a badge count
  /// for Launchers that support badging.
  Notification_Builder setNumber(int number) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setNumber, jni.JniType.objectType, [number]).object);

  static final _id_setContentInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentInfo",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setContentInfo(java.lang.CharSequence info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A small piece of additional information pertaining to this notification.
  ///
  /// The platform template will draw this on the last line of the notification, at the far
  /// right (to the right of a smallIcon if it has been placed there).
  ///@deprecated use \#setSubText(CharSequence) instead to set a text in the header.
  /// For legacy apps targeting a version below android.os.Build.VERSION_CODES\#N this
  /// field will still show up, but the subtext will take precedence.
  Notification_Builder setContentInfo(jni.JniObject info) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setContentInfo, jni.JniType.objectType, [info.reference]).object);

  static final _id_setProgress = jniAccessors.getMethodIDOf(
      _classRef, "setProgress", "(IIZ)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setProgress(int max, int progress, boolean indeterminate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the progress this notification represents.
  ///
  /// The platform template will represent this using a ProgressBar.
  Notification_Builder setProgress(int max, int progress, bool indeterminate) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setProgress,
          jni.JniType.objectType,
          [max, progress, indeterminate]).object);

  static final _id_setContent = jniAccessors.getMethodIDOf(
      _classRef,
      "setContent",
      "(Landroid/widget/RemoteViews;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setContent(android.widget.RemoteViews views)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply a custom RemoteViews to use instead of the platform template.
  ///
  /// Use \#setCustomContentView(RemoteViews) instead.
  Notification_Builder setContent(remoteviews_.RemoteViews views) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setContent, jni.JniType.objectType, [views.reference]).object);

  static final _id_setCustomContentView = jniAccessors.getMethodIDOf(
      _classRef,
      "setCustomContentView",
      "(Landroid/widget/RemoteViews;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setCustomContentView(android.widget.RemoteViews contentView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply custom RemoteViews to use instead of the platform template.
  ///
  /// This will override the layout that would otherwise be constructed by this Builder
  /// object.
  Notification_Builder setCustomContentView(
          remoteviews_.RemoteViews contentView) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCustomContentView,
          jni.JniType.objectType,
          [contentView.reference]).object);

  static final _id_setCustomBigContentView = jniAccessors.getMethodIDOf(
      _classRef,
      "setCustomBigContentView",
      "(Landroid/widget/RemoteViews;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setCustomBigContentView(android.widget.RemoteViews contentView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply custom RemoteViews to use instead of the platform template in the expanded form.
  ///
  /// This will override the expanded layout that would otherwise be constructed by this
  /// Builder object.
  Notification_Builder setCustomBigContentView(
          remoteviews_.RemoteViews contentView) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCustomBigContentView,
          jni.JniType.objectType,
          [contentView.reference]).object);

  static final _id_setCustomHeadsUpContentView = jniAccessors.getMethodIDOf(
      _classRef,
      "setCustomHeadsUpContentView",
      "(Landroid/widget/RemoteViews;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setCustomHeadsUpContentView(android.widget.RemoteViews contentView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply custom RemoteViews to use instead of the platform template in the heads up dialog.
  ///
  /// This will override the heads-up layout that would otherwise be constructed by this
  /// Builder object.
  Notification_Builder setCustomHeadsUpContentView(
          remoteviews_.RemoteViews contentView) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCustomHeadsUpContentView,
          jni.JniType.objectType,
          [contentView.reference]).object);

  static final _id_setContentIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentIntent",
      "(Landroid/app/PendingIntent;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setContentIntent(android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply a PendingIntent to be sent when the notification is clicked.
  ///
  /// As of android.os.Build.VERSION_CODES\#HONEYCOMB, if this field is unset and you
  /// have specified a custom RemoteViews with \#setContent(RemoteViews), you can use
  /// RemoteViews\#setOnClickPendingIntent RemoteViews.setOnClickPendingIntent(int,PendingIntent)
  /// to assign PendingIntents to individual views in that custom layout (i.e., to create
  /// clickable buttons inside the notification view).
  ///@see Notification\#contentIntent Notification.contentIntent
  Notification_Builder setContentIntent(pendingintent_.PendingIntent intent) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setContentIntent,
          jni.JniType.objectType,
          [intent.reference]).object);

  static final _id_setDeleteIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "setDeleteIntent",
      "(Landroid/app/PendingIntent;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setDeleteIntent(android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply a PendingIntent to send when the notification is cleared explicitly by the user.
  ///@see Notification\#deleteIntent
  Notification_Builder setDeleteIntent(pendingintent_.PendingIntent intent) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDeleteIntent,
          jni.JniType.objectType,
          [intent.reference]).object);

  static final _id_setFullScreenIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "setFullScreenIntent",
      "(Landroid/app/PendingIntent;Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setFullScreenIntent(android.app.PendingIntent intent, boolean highPriority)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An intent to launch instead of posting the notification to the status bar.
  /// Only for use with extremely high-priority notifications demanding the user's
  /// <strong>immediate</strong> attention, such as an incoming phone call or
  /// alarm clock that the user has explicitly set to a particular time.
  /// If this facility is used for something else, please give the user an option
  /// to turn it off and use a normal notification, as this can be extremely
  /// disruptive.
  ///
  ///
  /// The system UI may choose to display a heads-up notification, instead of
  /// launching this intent, while the user is using the device.
  ///
  ///
  ///@param intent The pending intent to launch.
  ///@param highPriority Passing true will cause this notification to be sent
  ///          even if other notifications are suppressed.
  ///@see Notification\#fullScreenIntent
  Notification_Builder setFullScreenIntent(
          pendingintent_.PendingIntent intent, bool highPriority) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setFullScreenIntent,
          jni.JniType.objectType,
          [intent.reference, highPriority]).object);

  static final _id_setTicker = jniAccessors.getMethodIDOf(
      _classRef,
      "setTicker",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setTicker(java.lang.CharSequence tickerText)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the "ticker" text which is sent to accessibility services.
  ///@see Notification\#tickerText
  Notification_Builder setTicker(jni.JniObject tickerText) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTicker,
          jni.JniType.objectType,
          [tickerText.reference]).object);

  static final _id_setTicker1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setTicker",
      "(Ljava/lang/CharSequence;Landroid/widget/RemoteViews;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setTicker(java.lang.CharSequence tickerText, android.widget.RemoteViews views)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obsolete version of \#setTicker(CharSequence).
  Notification_Builder setTicker1(
          jni.JniObject tickerText, remoteviews_.RemoteViews views) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTicker1,
          jni.JniType.objectType,
          [tickerText.reference, views.reference]).object);

  static final _id_setLargeIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "setLargeIcon",
      "(Landroid/graphics/Bitmap;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setLargeIcon(android.graphics.Bitmap b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a large icon to the notification content view.
  ///
  /// In the platform template, this image will be shown on the left of the notification view
  /// in place of the \#setSmallIcon(Icon) small icon (which will be placed in a small
  /// badge atop the large icon).
  Notification_Builder setLargeIcon(bitmap_.Bitmap b) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setLargeIcon, jni.JniType.objectType, [b.reference]).object);

  static final _id_setLargeIcon1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setLargeIcon",
      "(Landroid/graphics/drawable/Icon;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setLargeIcon(android.graphics.drawable.Icon icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a large icon to the notification content view.
  ///
  /// In the platform template, this image will be shown on the left of the notification view
  /// in place of the \#setSmallIcon(Icon) small icon (which will be placed in a small
  /// badge atop the large icon).
  Notification_Builder setLargeIcon1(icon_.Icon icon) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setLargeIcon1, jni.JniType.objectType, [icon.reference]).object);

  static final _id_setSound = jniAccessors.getMethodIDOf(_classRef, "setSound",
      "(Landroid/net/Uri;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the sound to play.
  ///
  /// It will be played using the \#AUDIO_ATTRIBUTES_DEFAULT default audio attributes
  /// for notifications.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  Notification_Builder setSound(uri_.Uri sound) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setSound, jni.JniType.objectType, [sound.reference]).object);

  static final _id_setSound1 = jniAccessors.getMethodIDOf(_classRef, "setSound",
      "(Landroid/net/Uri;I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound, int streamType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the sound to play, along with a specific stream on which to play it.
  ///
  /// See android.media.AudioManager for the <code>STREAM_</code> constants.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes).
  Notification_Builder setSound1(uri_.Uri sound, int streamType) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSound1,
          jni.JniType.objectType,
          [sound.reference, streamType]).object);

  static final _id_setSound2 = jniAccessors.getMethodIDOf(_classRef, "setSound",
      "(Landroid/net/Uri;Landroid/media/AudioAttributes;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound, android.media.AudioAttributes audioAttributes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the sound to play, along with specific AudioAttributes audio attributes to
  /// use during playback.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  ///@see Notification\#sound
  Notification_Builder setSound2(
          uri_.Uri sound, audioattributes_.AudioAttributes audioAttributes) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSound2,
          jni.JniType.objectType,
          [sound.reference, audioAttributes.reference]).object);

  static final _id_setVibrate = jniAccessors.getMethodIDOf(
      _classRef, "setVibrate", "([J)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setVibrate(long[] pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the vibration pattern to use.
  ///
  /// See android.os.Vibrator\#vibrate(long[], int) for a discussion of the
  /// <code>pattern</code> parameter.
  ///
  ///
  /// A notification that vibrates is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@deprecated use NotificationChannel\#setVibrationPattern(long[]) instead.
  ///@see Notification\#vibrate
  Notification_Builder setVibrate(jni.JniObject pattern) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setVibrate, jni.JniType.objectType, [pattern.reference]).object);

  static final _id_setLights = jniAccessors.getMethodIDOf(
      _classRef, "setLights", "(III)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setLights(int argb, int onMs, int offMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the desired color for the indicator LED on the device, as well as the
  /// blink duty cycle (specified in milliseconds).
  ///
  ///
  /// Not all devices will honor all (or even any) of these values.
  ///@deprecated use NotificationChannel\#enableLights(boolean) instead.
  ///@see Notification\#ledARGB
  ///@see Notification\#ledOnMS
  ///@see Notification\#ledOffMS
  Notification_Builder setLights(int argb, int onMs, int offMs) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setLights, jni.JniType.objectType, [argb, onMs, offMs]).object);

  static final _id_setOngoing = jniAccessors.getMethodIDOf(
      _classRef, "setOngoing", "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setOngoing(boolean ongoing)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this is an "ongoing" notification.
  ///
  ///
  /// Ongoing notifications cannot be dismissed by the user, so your application or service
  /// must take care of canceling them.
  ///
  ///
  /// They are typically used to indicate a background task that the user is actively engaged
  /// with (e.g., playing music) or is pending in some way and therefore occupying the device
  /// (e.g., a file download, sync operation, active network connection).
  ///@see Notification\#FLAG_ONGOING_EVENT
  ///@see Service\#setForeground(boolean)
  Notification_Builder setOngoing(bool ongoing) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setOngoing, jni.JniType.objectType, [ongoing]).object);

  static final _id_setColorized = jniAccessors.getMethodIDOf(
      _classRef, "setColorized", "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setColorized(boolean colorize)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this notification should be colorized. When set, the color set with
  /// \#setColor(int) will be used as the background color of this notification.
  ///
  /// This should only be used for high priority ongoing tasks like navigation, an ongoing
  /// call, or other similarly high-priority events for the user.
  ///
  /// For most styles, the coloring will only be applied if the notification is for a
  /// foreground service notification.
  /// However, for MediaStyle and DecoratedMediaCustomViewStyle notifications
  /// that have a media session attached there is no such requirement.
  ///@see Builder\#setColor(int)
  ///@see MediaStyle\#setMediaSession(MediaSession.Token)
  Notification_Builder setColorized(bool colorize) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setColorized, jni.JniType.objectType, [colorize]).object);

  static final _id_setOnlyAlertOnce = jniAccessors.getMethodIDOf(
      _classRef, "setOnlyAlertOnce", "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setOnlyAlertOnce(boolean onlyAlertOnce)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set this flag if you would only like the sound, vibrate
  /// and ticker to be played if the notification is not already showing.
  ///@see Notification\#FLAG_ONLY_ALERT_ONCE
  Notification_Builder setOnlyAlertOnce(bool onlyAlertOnce) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnlyAlertOnce,
          jni.JniType.objectType,
          [onlyAlertOnce]).object);

  static final _id_setAutoCancel = jniAccessors.getMethodIDOf(
      _classRef, "setAutoCancel", "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setAutoCancel(boolean autoCancel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make this notification automatically dismissed when the user touches it.
  ///@see Notification\#FLAG_AUTO_CANCEL
  Notification_Builder setAutoCancel(bool autoCancel) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setAutoCancel, jni.JniType.objectType, [autoCancel]).object);

  static final _id_setLocalOnly = jniAccessors.getMethodIDOf(
      _classRef, "setLocalOnly", "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setLocalOnly(boolean localOnly)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether or not this notification should not bridge to other devices.
  ///
  /// Some notifications can be bridged to other devices for remote display.
  /// This hint can be set to recommend this notification not be bridged.
  Notification_Builder setLocalOnly(bool localOnly) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setLocalOnly, jni.JniType.objectType, [localOnly]).object);

  static final _id_setDefaults = jniAccessors.getMethodIDOf(
      _classRef, "setDefaults", "(I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setDefaults(int defaults)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set which notification properties will be inherited from system defaults.
  ///
  /// The value should be one or more of the following fields combined with
  /// bitwise-or:
  /// \#DEFAULT_SOUND, \#DEFAULT_VIBRATE, \#DEFAULT_LIGHTS.
  ///
  /// For all default values, use \#DEFAULT_ALL.
  ///@deprecated use NotificationChannel\#enableVibration(boolean) and
  /// NotificationChannel\#enableLights(boolean) and
  /// NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  Notification_Builder setDefaults(int defaults) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setDefaults, jni.JniType.objectType, [defaults]).object);

  static final _id_setPriority = jniAccessors.getMethodIDOf(
      _classRef, "setPriority", "(I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setPriority(int pri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the priority of this notification.
  ///@see Notification\#priority
  ///@deprecated use NotificationChannel\#setImportance(int) instead.
  ///@param pri Value is android.app.Notification\#PRIORITY_DEFAULT, android.app.Notification\#PRIORITY_LOW, android.app.Notification\#PRIORITY_MIN, android.app.Notification\#PRIORITY_HIGH, or android.app.Notification\#PRIORITY_MAX
  Notification_Builder setPriority(int pri) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setPriority, jni.JniType.objectType, [pri]).object);

  static final _id_setCategory = jniAccessors.getMethodIDOf(_classRef,
      "setCategory", "(Ljava/lang/String;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setCategory(java.lang.String category)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the notification category.
  ///@see Notification\#category
  Notification_Builder setCategory(jni.JniString category) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCategory,
          jni.JniType.objectType,
          [category.reference]).object);

  static final _id_addPerson = jniAccessors.getMethodIDOf(_classRef,
      "addPerson", "(Ljava/lang/String;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder addPerson(java.lang.String uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a person that is relevant to this notification.
  ///
  /// <P>
  /// Depending on user preferences, this annotation may allow the notification to pass
  /// through interruption filters, if this notification is of category \#CATEGORY_CALL
  /// or \#CATEGORY_MESSAGE. The addition of people may also cause this notification to
  /// appear more prominently in the user interface.
  /// </P>
  ///
  /// <P>
  /// The person should be specified by the {@code String} representation of a
  /// android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI.
  /// </P>
  ///
  /// <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
  /// URIs.  The path part of these URIs must exist in the contacts database, in the
  /// appropriate column, or the reference will be discarded as invalid. Telephone schema
  /// URIs will be resolved by android.provider.ContactsContract.PhoneLookup.
  /// It is also possible to provide a URI with the schema {@code name:} in order to uniquely
  /// identify a person without an entry in the contacts database.
  /// </P>
  ///@param uri A URI for the person.
  ///@see Notification\#EXTRA_PEOPLE
  ///@deprecated use \#addPerson(Person)
  Notification_Builder addPerson(jni.JniString uri) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addPerson, jni.JniType.objectType, [uri.reference]).object);

  static final _id_addPerson1 = jniAccessors.getMethodIDOf(_classRef,
      "addPerson", "(Landroid/app/Person;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder addPerson(android.app.Person person)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a person that is relevant to this notification.
  ///
  /// <P>
  /// Depending on user preferences, this annotation may allow the notification to pass
  /// through interruption filters, if this notification is of category \#CATEGORY_CALL
  /// or \#CATEGORY_MESSAGE. The addition of people may also cause this notification to
  /// appear more prominently in the user interface.
  /// </P>
  ///
  /// <P>
  /// A person should usually contain a uri in order to benefit from the ranking boost.
  /// However, even if no uri is provided, it's beneficial to provide other people in the
  /// notification, such that listeners and voice only devices can announce and handle them
  /// properly.
  /// </P>
  ///@param person the person to add.
  ///@see Notification\#EXTRA_PEOPLE_LIST
  Notification_Builder addPerson1(person_.Person person) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addPerson1, jni.JniType.objectType, [person.reference]).object);

  static final _id_setGroup = jniAccessors.getMethodIDOf(_classRef, "setGroup",
      "(Ljava/lang/String;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setGroup(java.lang.String groupKey)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set this notification to be part of a group of notifications sharing the same key.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering.
  ///
  /// To make this notification the summary for its group, also call
  /// \#setGroupSummary. A sort order can be specified for group members by using
  /// \#setSortKey.
  ///@param groupKey The group key of the group.
  ///@return this object for method chaining
  Notification_Builder setGroup(jni.JniString groupKey) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setGroup, jni.JniType.objectType, [groupKey.reference]).object);

  static final _id_setGroupSummary = jniAccessors.getMethodIDOf(
      _classRef, "setGroupSummary", "(Z)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setGroupSummary(boolean isGroupSummary)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set this notification to be the group summary for a group of notifications.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering. If thereRequires a group key also be set using \#setGroup.
  /// The group summary may be suppressed if too few notifications are included in the group.
  ///@param isGroupSummary Whether this notification should be a group summary.
  ///@return this object for method chaining
  Notification_Builder setGroupSummary(bool isGroupSummary) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setGroupSummary,
          jni.JniType.objectType,
          [isGroupSummary]).object);

  static final _id_setSortKey = jniAccessors.getMethodIDOf(_classRef,
      "setSortKey", "(Ljava/lang/String;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setSortKey(java.lang.String sortKey)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a sort key that orders this notification among other notifications from the
  /// same package. This can be useful if an external sort was already applied and an app
  /// would like to preserve this. Notifications will be sorted lexicographically using this
  /// value, although providing different priorities in addition to providing sort key may
  /// cause this value to be ignored.
  ///
  /// This sort key can also be used to order members of a notification group. See
  /// \#setGroup.
  ///@see String\#compareTo(String)
  Notification_Builder setSortKey(jni.JniString sortKey) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setSortKey, jni.JniType.objectType, [sortKey.reference]).object);

  static final _id_addExtras = jniAccessors.getMethodIDOf(_classRef,
      "addExtras", "(Landroid/os/Bundle;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder addExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Merge additional metadata into this notification.
  ///
  /// Values within the Bundle will replace existing extras values in this Builder.
  ///@see Notification\#extras
  Notification_Builder addExtras(bundle_.Bundle extras) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addExtras, jni.JniType.objectType, [extras.reference]).object);

  static final _id_setExtras = jniAccessors.getMethodIDOf(_classRef,
      "setExtras", "(Landroid/os/Bundle;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set metadata for this notification.
  ///
  /// A reference to the Bundle is held for the lifetime of this Builder, and the Bundle's
  /// current contents are copied into the Notification each time \#build() is
  /// called.
  ///
  /// Replaces any existing extras values with those from the provided Bundle.
  /// Use \#addExtras to merge in metadata instead.
  ///@see Notification\#extras
  Notification_Builder setExtras(bundle_.Bundle extras) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setExtras, jni.JniType.objectType, [extras.reference]).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the current metadata Bundle used by this notification Builder.
  ///
  /// The returned Bundle is shared with this Builder.
  ///
  /// The current contents of this Bundle are copied into the Notification each time
  /// \#build() is called.
  ///@see Notification\#extras
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_addAction = jniAccessors.getMethodIDOf(
      _classRef,
      "addAction",
      "(ILjava/lang/CharSequence;Landroid/app/PendingIntent;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder addAction(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an action to this notification. Actions are typically displayed by
  /// the system as a button adjacent to the notification content.
  ///
  /// Every action must have an icon (32dp square and matching the
  /// <a href="{@docRoot}design/style/iconography.html\#action-bar">Holo
  /// Dark action bar</a> visual style), a textual label, and a PendingIntent.
  ///
  /// A notification in its expanded form can display up to 3 actions, from left to right in
  /// the order they were added. Actions will not be displayed when the notification is
  /// collapsed, however, so be sure that any essential functions may be accessed by the user
  /// in some other way (for example, in the Activity pointed to by \#contentIntent).
  ///@param icon Resource ID of a drawable that represents the action.
  ///@param title Text describing the action.
  ///@param intent PendingIntent to be fired when the action is invoked.
  ///@deprecated Use \#addAction(Action) instead.
  Notification_Builder addAction(
          int icon, jni.JniObject title, pendingintent_.PendingIntent intent) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addAction,
          jni.JniType.objectType,
          [icon, title.reference, intent.reference]).object);

  static final _id_addAction1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addAction",
      "(Landroid/app/Notification\$Action;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder addAction(android.app.Notification.Action action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an action to this notification. Actions are typically displayed by
  /// the system as a button adjacent to the notification content.
  ///
  /// Every action must have an icon (32dp square and matching the
  /// <a href="{@docRoot}design/style/iconography.html\#action-bar">Holo
  /// Dark action bar</a> visual style), a textual label, and a PendingIntent.
  ///
  /// A notification in its expanded form can display up to 3 actions, from left to right in
  /// the order they were added. Actions will not be displayed when the notification is
  /// collapsed, however, so be sure that any essential functions may be accessed by the user
  /// in some other way (for example, in the Activity pointed to by \#contentIntent).
  ///@param action The action to add.
  Notification_Builder addAction1(Notification_Action action) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addAction1, jni.JniType.objectType, [action.reference]).object);

  static final _id_setActions = jniAccessors.getMethodIDOf(
      _classRef,
      "setActions",
      "([Landroid/app/Notification\$Action;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setActions(android.app.Notification.Action[] actions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Alter the complete list of actions attached to this notification.
  ///@see \#addAction(Action).
  ///@param actions
  ///@return
  Notification_Builder setActions(jni.JniObject actions) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setActions, jni.JniType.objectType, [actions.reference]).object);

  static final _id_setStyle = jniAccessors.getMethodIDOf(_classRef, "setStyle",
      "(Landroid/app/Notification\$Style;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setStyle(android.app.Notification.Style style)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a rich notification style to be applied at build time.
  ///@param style Object responsible for modifying the notification style.
  Notification_Builder setStyle(Notification_Style style) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setStyle, jni.JniType.objectType, [style.reference]).object);

  static final _id_getStyle = jniAccessors.getMethodIDOf(
      _classRef, "getStyle", "()Landroid/app/Notification\$Style;");

  /// from: public android.app.Notification.Style getStyle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the style set by \#setStyle(Style).
  Notification_Style getStyle() =>
      Notification_Style.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStyle, jni.JniType.objectType, []).object);

  static final _id_setVisibility = jniAccessors.getMethodIDOf(
      _classRef, "setVisibility", "(I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setVisibility(int visibility)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify the value of \#visibility.
  ///@param visibility Value is android.app.Notification\#VISIBILITY_PUBLIC, android.app.Notification\#VISIBILITY_PRIVATE, or android.app.Notification\#VISIBILITY_SECRET
  ///@return The same Builder.
  Notification_Builder setVisibility(int visibility) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setVisibility, jni.JniType.objectType, [visibility]).object);

  static final _id_setPublicVersion = jniAccessors.getMethodIDOf(
      _classRef,
      "setPublicVersion",
      "(Landroid/app/Notification;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setPublicVersion(android.app.Notification n)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply a replacement Notification whose contents should be shown in insecure contexts
  /// (i.e. atop the secure lockscreen). See \#visibility and \#VISIBILITY_PUBLIC.
  ///@param n A replacement notification, presumably with some or all info redacted.
  ///@return The same Builder.
  Notification_Builder setPublicVersion(Notification n) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setPublicVersion, jni.JniType.objectType, [n.reference]).object);

  static final _id_extend = jniAccessors.getMethodIDOf(_classRef, "extend",
      "(Landroid/app/Notification\$Extender;)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Extender extender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply an extender to this notification builder. Extenders may be used to add
  /// metadata or change options on this builder.
  Notification_Builder extend(Notification_Extender extender) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_extend, jni.JniType.objectType, [extender.reference]).object);

  static final _id_setColor = jniAccessors.getMethodIDOf(
      _classRef, "setColor", "(I)Landroid/app/Notification\$Builder;");

  /// from: public android.app.Notification.Builder setColor(int argb)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets Notification\#color.
  ///@param argb The accent color to use
  ///@return The same Builder.
  Notification_Builder setColor(int argb) =>
      Notification_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setColor, jni.JniType.objectType, [argb]).object);

  static final _id_createContentView = jniAccessors.getMethodIDOf(
      _classRef, "createContentView", "()Landroid/widget/RemoteViews;");

  /// from: public android.widget.RemoteViews createContentView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a RemoteViews for the final 1U notification layout. In order:
  ///   1. Custom contentView from the caller
  ///   2. Style's proposed content view
  ///   3. Standard template view
  remoteviews_.RemoteViews createContentView() =>
      remoteviews_.RemoteViews.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createContentView, jni.JniType.objectType, []).object);

  static final _id_createBigContentView = jniAccessors.getMethodIDOf(
      _classRef, "createBigContentView", "()Landroid/widget/RemoteViews;");

  /// from: public android.widget.RemoteViews createBigContentView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a RemoteViews for the final big notification layout.
  remoteviews_.RemoteViews createBigContentView() =>
      remoteviews_.RemoteViews.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createBigContentView,
          jni.JniType.objectType, []).object);

  static final _id_createHeadsUpContentView = jniAccessors.getMethodIDOf(
      _classRef, "createHeadsUpContentView", "()Landroid/widget/RemoteViews;");

  /// from: public android.widget.RemoteViews createHeadsUpContentView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a RemoteViews for the final heads-up notification layout.
  remoteviews_.RemoteViews createHeadsUpContentView() =>
      remoteviews_.RemoteViews.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createHeadsUpContentView,
          jni.JniType.objectType, []).object);

  static final _id_recoverBuilder = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "recoverBuilder",
      "(Landroid/content/Context;Landroid/app/Notification;)Landroid/app/Notification\$Builder;");

  /// from: static public android.app.Notification.Builder recoverBuilder(android.content.Context context, android.app.Notification n)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a Builder from an existing notification so further changes can be made.
  ///@param context The context for your application / activity.
  ///@param n The notification to create a Builder from.
  static Notification_Builder recoverBuilder(
          context_.Context context, Notification n) =>
      Notification_Builder.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_recoverBuilder,
          jni.JniType.objectType,
          [context.reference, n.reference]).object);

  static final _id_getNotification = jniAccessors.getMethodIDOf(
      _classRef, "getNotification", "()Landroid/app/Notification;");

  /// from: public android.app.Notification getNotification()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use \#build() instead.
  Notification getNotification() =>
      Notification.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNotification, jni.JniType.objectType, []).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/app/Notification;");

  /// from: public android.app.Notification build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Combine all of the options that have been set and return a new Notification
  /// object.
  Notification build() => Notification.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_build, jni.JniType.objectType, []).object);
}

/// from: android.app.Notification$BigTextStyle
///
/// Helper class for generating large-format notifications that include a lot of text.
///
/// Here's how you'd set the <code>BigTextStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;New mail from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_mail)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.BigTextStyle()
///         .bigText(aVeryLongString))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_BigTextStyle extends Notification_Style {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$BigTextStyle");
  Notification_BigTextStyle.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_BigTextStyle()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Notification\$Builder;)V");

  /// from: public void <init>(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated use {@code BigTextStyle()}.
  Notification_BigTextStyle.ctor1(Notification_Builder builder)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [builder.reference]).object);

  static final _id_setBigContentTitle = jniAccessors.getMethodIDOf(
      _classRef,
      "setBigContentTitle",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$BigTextStyle;");

  /// from: public android.app.Notification.BigTextStyle setBigContentTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_BigTextStyle setBigContentTitle(jni.JniObject title) =>
      Notification_BigTextStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setBigContentTitle,
          jni.JniType.objectType,
          [title.reference]).object);

  static final _id_setSummaryText = jniAccessors.getMethodIDOf(
      _classRef,
      "setSummaryText",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$BigTextStyle;");

  /// from: public android.app.Notification.BigTextStyle setSummaryText(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_BigTextStyle setSummaryText(jni.JniObject cs) =>
      Notification_BigTextStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSummaryText,
          jni.JniType.objectType,
          [cs.reference]).object);

  static final _id_bigText = jniAccessors.getMethodIDOf(_classRef, "bigText",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$BigTextStyle;");

  /// from: public android.app.Notification.BigTextStyle bigText(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide the longer text to be displayed in the big form of the
  /// template in place of the content text.
  Notification_BigTextStyle bigText(jni.JniObject cs) =>
      Notification_BigTextStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_bigText,
          jni.JniType.objectType,
          [cs.reference]).object);
}

/// from: android.app.Notification$BigPictureStyle
///
/// Helper class for generating large-format notifications that include a large image attachment.
///
/// Here's how you'd set the <code>BigPictureStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;New photo from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_post)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.BigPictureStyle()
///         .bigPicture(aBigBitmap))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_BigPictureStyle extends Notification_Style {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$BigPictureStyle");
  Notification_BigPictureStyle.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_BigPictureStyle()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Notification\$Builder;)V");

  /// from: public void <init>(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated use {@code BigPictureStyle()}.
  Notification_BigPictureStyle.ctor1(Notification_Builder builder)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [builder.reference]).object);

  static final _id_setBigContentTitle = jniAccessors.getMethodIDOf(
      _classRef,
      "setBigContentTitle",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$BigPictureStyle;");

  /// from: public android.app.Notification.BigPictureStyle setBigContentTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_BigPictureStyle setBigContentTitle(jni.JniObject title) =>
      Notification_BigPictureStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setBigContentTitle,
          jni.JniType.objectType,
          [title.reference]).object);

  static final _id_setSummaryText = jniAccessors.getMethodIDOf(
      _classRef,
      "setSummaryText",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$BigPictureStyle;");

  /// from: public android.app.Notification.BigPictureStyle setSummaryText(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_BigPictureStyle setSummaryText(jni.JniObject cs) =>
      Notification_BigPictureStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSummaryText,
          jni.JniType.objectType,
          [cs.reference]).object);

  static final _id_bigPicture = jniAccessors.getMethodIDOf(
      _classRef,
      "bigPicture",
      "(Landroid/graphics/Bitmap;)Landroid/app/Notification\$BigPictureStyle;");

  /// from: public android.app.Notification.BigPictureStyle bigPicture(android.graphics.Bitmap b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide the bitmap to be used as the payload for the BigPicture notification.
  Notification_BigPictureStyle bigPicture(bitmap_.Bitmap b) =>
      Notification_BigPictureStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_bigPicture,
          jni.JniType.objectType,
          [b.reference]).object);

  static final _id_bigLargeIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "bigLargeIcon",
      "(Landroid/graphics/Bitmap;)Landroid/app/Notification\$BigPictureStyle;");

  /// from: public android.app.Notification.BigPictureStyle bigLargeIcon(android.graphics.Bitmap b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override the large icon when the big notification is shown.
  Notification_BigPictureStyle bigLargeIcon(bitmap_.Bitmap b) =>
      Notification_BigPictureStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_bigLargeIcon,
          jni.JniType.objectType,
          [b.reference]).object);

  static final _id_bigLargeIcon1 = jniAccessors.getMethodIDOf(
      _classRef,
      "bigLargeIcon",
      "(Landroid/graphics/drawable/Icon;)Landroid/app/Notification\$BigPictureStyle;");

  /// from: public android.app.Notification.BigPictureStyle bigLargeIcon(android.graphics.drawable.Icon icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override the large icon when the big notification is shown.
  Notification_BigPictureStyle bigLargeIcon1(icon_.Icon icon) =>
      Notification_BigPictureStyle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_bigLargeIcon1,
          jni.JniType.objectType,
          [icon.reference]).object);
}

/// from: android.app.Notification$Action
///
/// Structure to encapsulate a named action that can be shown as part of this notification.
/// It must include an icon, a label, and a PendingIntent to be fired when the action is
/// selected by the user.
///
/// Apps should use Notification.Builder\#addAction(int, CharSequence, PendingIntent)
/// or Notification.Builder\#addAction(Notification.Action)
/// to attach actions.
class Notification_Action extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$Action");
  Notification_Action.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.Notification.Action> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int SEMANTIC_ACTION_ARCHIVE
  ///
  /// {@code SemanticAction}: Archive the content associated with the notification. This
  /// could mean archiving an email, message, etc.
  static const SEMANTIC_ACTION_ARCHIVE = 5;

  /// from: static public final int SEMANTIC_ACTION_CALL
  ///
  /// {@code SemanticAction}: Call a contact, group, etc.
  static const SEMANTIC_ACTION_CALL = 10;

  /// from: static public final int SEMANTIC_ACTION_DELETE
  ///
  /// {@code SemanticAction}: Delete the content associated with the notification. This
  /// could mean deleting an email, message, etc.
  static const SEMANTIC_ACTION_DELETE = 4;

  /// from: static public final int SEMANTIC_ACTION_MARK_AS_READ
  ///
  /// {@code SemanticAction}: Mark content as read.
  static const SEMANTIC_ACTION_MARK_AS_READ = 2;

  /// from: static public final int SEMANTIC_ACTION_MARK_AS_UNREAD
  ///
  /// {@code SemanticAction}: Mark content as unread.
  static const SEMANTIC_ACTION_MARK_AS_UNREAD = 3;

  /// from: static public final int SEMANTIC_ACTION_MUTE
  ///
  /// {@code SemanticAction}: Mute the content associated with the notification. This could
  /// mean silencing a conversation or currently playing media.
  static const SEMANTIC_ACTION_MUTE = 6;

  /// from: static public final int SEMANTIC_ACTION_NONE
  ///
  /// /*missing*/: No semantic action defined.
  static const SEMANTIC_ACTION_NONE = 0;

  /// from: static public final int SEMANTIC_ACTION_REPLY
  ///
  /// {@code SemanticAction}: Reply to a conversation, chat, group, or wherever replies
  /// may be appropriate.
  static const SEMANTIC_ACTION_REPLY = 1;

  /// from: static public final int SEMANTIC_ACTION_THUMBS_DOWN
  ///
  /// {@code SemanticAction}: Mark content with a thumbs down.
  static const SEMANTIC_ACTION_THUMBS_DOWN = 9;

  /// from: static public final int SEMANTIC_ACTION_THUMBS_UP
  ///
  /// {@code SemanticAction}: Mark content with a thumbs up.
  static const SEMANTIC_ACTION_THUMBS_UP = 8;

  /// from: static public final int SEMANTIC_ACTION_UNMUTE
  ///
  /// {@code SemanticAction}: Unmute the content associated with the notification. This could
  /// mean un-silencing a conversation or currently playing media.
  static const SEMANTIC_ACTION_UNMUTE = 7;

  static final _id_actionIntent = jniAccessors.getFieldIDOf(
      _classRef, "actionIntent", "Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent actionIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Intent to send when the user invokes this action. May be null, in which case the action
  /// may be rendered in a disabled presentation by the system UI.
  pendingintent_.PendingIntent get actionIntent =>
      pendingintent_.PendingIntent.fromRef(jniAccessors
          .getField(reference, _id_actionIntent, jni.JniType.objectType)
          .object);

  /// from: public android.app.PendingIntent actionIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Intent to send when the user invokes this action. May be null, in which case the action
  /// may be rendered in a disabled presentation by the system UI.
  set actionIntent(pendingintent_.PendingIntent value) =>
      jniEnv.SetObjectField(reference, _id_actionIntent, value.reference);

  static final _id_icon = jniAccessors.getFieldIDOf(_classRef, "icon", "I");

  /// from: public int icon
  ///
  /// Small icon representing the action.
  ///@deprecated Use Action\#getIcon() instead.
  int get icon =>
      jniAccessors.getField(reference, _id_icon, jni.JniType.intType).integer;

  /// from: public int icon
  ///
  /// Small icon representing the action.
  ///@deprecated Use Action\#getIcon() instead.
  set icon(int value) => jniEnv.SetIntField(reference, _id_icon, value);

  static final _id_title =
      jniAccessors.getFieldIDOf(_classRef, "title", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence title
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Title of the action.
  jni.JniObject get title => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_title, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence title
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Title of the action.
  set title(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_title, value.reference);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(ILjava/lang/CharSequence;Landroid/app/PendingIntent;)V");

  /// from: public void <init>(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use android.app.Notification.Action.Builder.
  Notification_Action(
      int icon, jni.JniObject title, pendingintent_.PendingIntent intent)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [icon, title.reference, intent.reference]).object);

  static final _id_getIcon = jniAccessors.getMethodIDOf(
      _classRef, "getIcon", "()Landroid/graphics/drawable/Icon;");

  /// from: public android.graphics.drawable.Icon getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an icon representing the action.
  icon_.Icon getIcon() => icon_.Icon.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getIcon, jni.JniType.objectType, []).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get additional metadata carried around with this Action.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_getAllowGeneratedReplies =
      jniAccessors.getMethodIDOf(_classRef, "getAllowGeneratedReplies", "()Z");

  /// from: public boolean getAllowGeneratedReplies()
  ///
  /// Return whether the platform should automatically generate possible replies for this
  /// Action
  bool getAllowGeneratedReplies() => jniAccessors.callMethodWithArgs(reference,
      _id_getAllowGeneratedReplies, jni.JniType.booleanType, []).boolean;

  static final _id_getRemoteInputs = jniAccessors.getMethodIDOf(
      _classRef, "getRemoteInputs", "()[Landroid/app/RemoteInput;");

  /// from: public android.app.RemoteInput[] getRemoteInputs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of inputs to be collected from the user when this action is sent.
  /// May return null if no remote inputs were added. Only returns inputs which accept
  /// a text input. For inputs which only accept data use \#getDataOnlyRemoteInputs.
  jni.JniObject getRemoteInputs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRemoteInputs, jni.JniType.objectType, []).object);

  static final _id_getSemanticAction =
      jniAccessors.getMethodIDOf(_classRef, "getSemanticAction", "()I");

  /// from: public int getSemanticAction()
  ///
  /// Returns the {@code SemanticAction} associated with this Action. A
  /// {@code SemanticAction} denotes what an Action's PendingIntent will do
  /// (eg. reply, mark as read, delete, etc).
  ///@return Value is android.app.Notification.Action\#SEMANTIC_ACTION_NONE, android.app.Notification.Action\#SEMANTIC_ACTION_REPLY, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_READ, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_UNREAD, android.app.Notification.Action\#SEMANTIC_ACTION_DELETE, android.app.Notification.Action\#SEMANTIC_ACTION_ARCHIVE, android.app.Notification.Action\#SEMANTIC_ACTION_MUTE, android.app.Notification.Action\#SEMANTIC_ACTION_UNMUTE, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_UP, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_DOWN, or android.app.Notification.Action\#SEMANTIC_ACTION_CALL
  int getSemanticAction() => jniAccessors.callMethodWithArgs(
      reference, _id_getSemanticAction, jni.JniType.intType, []).integer;

  static final _id_getDataOnlyRemoteInputs = jniAccessors.getMethodIDOf(
      _classRef, "getDataOnlyRemoteInputs", "()[Landroid/app/RemoteInput;");

  /// from: public android.app.RemoteInput[] getDataOnlyRemoteInputs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of inputs to be collected from the user that ONLY accept data when this
  /// action is sent. These remote inputs are guaranteed to return true on a call to
  /// RemoteInput\#isDataOnly.
  ///
  /// Returns null if there are no data-only remote inputs.
  ///
  /// This method exists so that legacy RemoteInput collectors that pre-date the addition
  /// of non-textual RemoteInputs do not access these remote inputs.
  jni.JniObject getDataOnlyRemoteInputs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDataOnlyRemoteInputs, jni.JniType.objectType, []).object);

  static final _id_clone = jniAccessors.getMethodIDOf(
      _classRef, "clone", "()Landroid/app/Notification\$Action;");

  /// from: public android.app.Notification.Action clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_Action clone() =>
      Notification_Action.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();
}

/// from: android.app.Notification$Action$WearableExtender
///
/// Wearable extender for notification actions. To add extensions to an action,
/// create a new android.app.Notification.Action.WearableExtender object using
/// the {@code WearableExtender()} constructor and apply it to a
/// android.app.Notification.Action.Builder using
/// android.app.Notification.Action.Builder\#extend.
///
/// <pre class="prettyprint">
/// Notification.Action action = new Notification.Action.Builder(
///         R.drawable.archive_all, "Archive all", actionIntent)
///         .extend(new Notification.Action.WearableExtender()
///                 .setAvailableOffline(false))
///         .build();</pre>
class Notification_Action_WearableExtender extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/Notification\$Action\$WearableExtender");
  Notification_Action_WearableExtender.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a android.app.Notification.Action.WearableExtender with default
  /// options.
  Notification_Action_WearableExtender()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Notification\$Action;)V");

  /// from: public void <init>(android.app.Notification.Action action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a android.app.Notification.Action.WearableExtender by reading
  /// wearable options present in an existing notification action.
  ///@param action the notification action to inspect.
  Notification_Action_WearableExtender.ctor1(Notification_Action action)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [action.reference]).object);

  static final _id_extend = jniAccessors.getMethodIDOf(_classRef, "extend",
      "(Landroid/app/Notification\$Action\$Builder;)Landroid/app/Notification\$Action\$Builder;");

  /// from: public android.app.Notification.Action.Builder extend(android.app.Notification.Action.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply wearable extensions to a notification action that is being built. This is
  /// typically called by the android.app.Notification.Action.Builder\#extend
  /// method of android.app.Notification.Action.Builder.
  Notification_Action_Builder extend(Notification_Action_Builder builder) =>
      Notification_Action_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_extend,
          jni.JniType.objectType,
          [builder.reference]).object);

  static final _id_clone = jniAccessors.getMethodIDOf(_classRef, "clone",
      "()Landroid/app/Notification\$Action\$WearableExtender;");

  /// from: public android.app.Notification.Action.WearableExtender clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_Action_WearableExtender clone() =>
      Notification_Action_WearableExtender.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_setAvailableOffline = jniAccessors.getMethodIDOf(
      _classRef,
      "setAvailableOffline",
      "(Z)Landroid/app/Notification\$Action\$WearableExtender;");

  /// from: public android.app.Notification.Action.WearableExtender setAvailableOffline(boolean availableOffline)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this action is available when the wearable device is not connected to
  /// a companion device. The user can still trigger this action when the wearable device is
  /// offline, but a visual hint will indicate that the action may not be available.
  /// Defaults to true.
  Notification_Action_WearableExtender setAvailableOffline(
          bool availableOffline) =>
      Notification_Action_WearableExtender.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setAvailableOffline,
              jni.JniType.objectType, [availableOffline]).object);

  static final _id_isAvailableOffline =
      jniAccessors.getMethodIDOf(_classRef, "isAvailableOffline", "()Z");

  /// from: public boolean isAvailableOffline()
  ///
  /// Get whether this action is available when the wearable device is not connected to
  /// a companion device. The user can still trigger this action when the wearable device is
  /// offline, but a visual hint will indicate that the action may not be available.
  /// Defaults to true.
  bool isAvailableOffline() => jniAccessors.callMethodWithArgs(
      reference, _id_isAvailableOffline, jni.JniType.booleanType, []).boolean;

  static final _id_setInProgressLabel = jniAccessors.getMethodIDOf(
      _classRef,
      "setInProgressLabel",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Action\$WearableExtender;");

  /// from: public android.app.Notification.Action.WearableExtender setInProgressLabel(java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a label to display while the wearable is preparing to automatically execute the
  /// action. This is usually a 'ing' verb ending in ellipsis like "Sending..."
  ///@param label the label to display while the action is being prepared to execute
  ///@return this object for method chaining
  Notification_Action_WearableExtender setInProgressLabel(
          jni.JniObject label) =>
      Notification_Action_WearableExtender.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setInProgressLabel,
              jni.JniType.objectType, [label.reference]).object);

  static final _id_getInProgressLabel = jniAccessors.getMethodIDOf(
      _classRef, "getInProgressLabel", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getInProgressLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the label to display while the wearable is preparing to automatically execute
  /// the action. This is usually a 'ing' verb ending in ellipsis like "Sending..."
  ///@return the label to display while the action is being prepared to execute
  jni.JniObject getInProgressLabel() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInProgressLabel, jni.JniType.objectType, []).object);

  static final _id_setConfirmLabel = jniAccessors.getMethodIDOf(
      _classRef,
      "setConfirmLabel",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Action\$WearableExtender;");

  /// from: public android.app.Notification.Action.WearableExtender setConfirmLabel(java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a label to display to confirm that the action should be executed.
  /// This is usually an imperative verb like "Send".
  ///@param label the label to confirm the action should be executed
  ///@return this object for method chaining
  Notification_Action_WearableExtender setConfirmLabel(jni.JniObject label) =>
      Notification_Action_WearableExtender.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setConfirmLabel,
              jni.JniType.objectType, [label.reference]).object);

  static final _id_getConfirmLabel = jniAccessors.getMethodIDOf(
      _classRef, "getConfirmLabel", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getConfirmLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the label to display to confirm that the action should be executed.
  /// This is usually an imperative verb like "Send".
  ///@return the label to confirm the action should be executed
  jni.JniObject getConfirmLabel() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConfirmLabel, jni.JniType.objectType, []).object);

  static final _id_setCancelLabel = jniAccessors.getMethodIDOf(
      _classRef,
      "setCancelLabel",
      "(Ljava/lang/CharSequence;)Landroid/app/Notification\$Action\$WearableExtender;");

  /// from: public android.app.Notification.Action.WearableExtender setCancelLabel(java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a label to display to cancel the action.
  /// This is usually an imperative verb, like "Cancel".
  ///@param label the label to display to cancel the action
  ///@return this object for method chaining
  Notification_Action_WearableExtender setCancelLabel(jni.JniObject label) =>
      Notification_Action_WearableExtender.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setCancelLabel,
              jni.JniType.objectType, [label.reference]).object);

  static final _id_getCancelLabel = jniAccessors.getMethodIDOf(
      _classRef, "getCancelLabel", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getCancelLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the label to display to cancel the action.
  /// This is usually an imperative verb like "Cancel".
  ///@return the label to display to cancel the action
  jni.JniObject getCancelLabel() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCancelLabel, jni.JniType.objectType, []).object);

  static final _id_setHintLaunchesActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "setHintLaunchesActivity",
      "(Z)Landroid/app/Notification\$Action\$WearableExtender;");

  /// from: public android.app.Notification.Action.WearableExtender setHintLaunchesActivity(boolean hintLaunchesActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this Action will launch an Activity directly, telling the
  /// platform that it can generate the appropriate transitions.
  ///@param hintLaunchesActivity {@code true} if the content intent will launch
  /// an activity and transitions should be generated, false otherwise.
  ///@return this object for method chaining
  Notification_Action_WearableExtender setHintLaunchesActivity(
          bool hintLaunchesActivity) =>
      Notification_Action_WearableExtender.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setHintLaunchesActivity,
              jni.JniType.objectType, [hintLaunchesActivity]).object);

  static final _id_getHintLaunchesActivity =
      jniAccessors.getMethodIDOf(_classRef, "getHintLaunchesActivity", "()Z");

  /// from: public boolean getHintLaunchesActivity()
  ///
  /// Get a hint that this Action will launch an Activity directly, telling the
  /// platform that it can generate the appropriate transitions
  ///@return {@code true} if the content intent will launch an activity and transitions
  /// should be generated, false otherwise. The default value is {@code false} if this was
  /// never set.
  bool getHintLaunchesActivity() => jniAccessors.callMethodWithArgs(reference,
      _id_getHintLaunchesActivity, jni.JniType.booleanType, []).boolean;

  static final _id_setHintDisplayActionInline = jniAccessors.getMethodIDOf(
      _classRef,
      "setHintDisplayActionInline",
      "(Z)Landroid/app/Notification\$Action\$WearableExtender;");

  /// from: public android.app.Notification.Action.WearableExtender setHintDisplayActionInline(boolean hintDisplayInline)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this Action should be displayed inline.
  ///@param hintDisplayInline {@code true} if action should be displayed inline, false
  ///        otherwise
  ///@return this object for method chaining
  Notification_Action_WearableExtender setHintDisplayActionInline(
          bool hintDisplayInline) =>
      Notification_Action_WearableExtender.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_setHintDisplayActionInline,
              jni.JniType.objectType, [hintDisplayInline]).object);

  static final _id_getHintDisplayActionInline = jniAccessors.getMethodIDOf(
      _classRef, "getHintDisplayActionInline", "()Z");

  /// from: public boolean getHintDisplayActionInline()
  ///
  /// Get a hint that this Action should be displayed inline.
  ///@return {@code true} if the Action should be displayed inline, {@code false}
  ///         otherwise. The default value is {@code false} if this was never set.
  bool getHintDisplayActionInline() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getHintDisplayActionInline,
      jni.JniType.booleanType, []).boolean;
}

/// from: android.app.Notification$Action$Extender
///
/// Extender interface for use with Builder\#extend. Extenders may be used to add
/// metadata or change options on an action builder.
class Notification_Action_Extender extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$Action\$Extender");
  Notification_Action_Extender.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_extend = jniAccessors.getMethodIDOf(_classRef, "extend",
      "(Landroid/app/Notification\$Action\$Builder;)Landroid/app/Notification\$Action\$Builder;");

  /// from: public abstract android.app.Notification.Action.Builder extend(android.app.Notification.Action.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply this extender to a notification action builder.
  ///@param builder the builder to be modified.
  ///@return the build object for chaining.
  Notification_Action_Builder extend(Notification_Action_Builder builder) =>
      Notification_Action_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_extend,
          jni.JniType.objectType,
          [builder.reference]).object);
}

/// from: android.app.Notification$Action$Builder
///
/// Builder class for Action objects.
class Notification_Action_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Notification\$Action\$Builder");
  Notification_Action_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(ILjava/lang/CharSequence;Landroid/app/PendingIntent;)V");

  /// from: public void <init>(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new builder for Action object.
  ///@param icon icon to show for this action
  ///@param title the title of the action
  ///@param intent the PendingIntent to fire when users trigger this action
  Notification_Action_Builder(
      int icon, jni.JniObject title, pendingintent_.PendingIntent intent)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [icon, title.reference, intent.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/graphics/drawable/Icon;Ljava/lang/CharSequence;Landroid/app/PendingIntent;)V");

  /// from: public void <init>(android.graphics.drawable.Icon icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new builder for Action object.
  ///@param icon icon to show for this action
  ///@param title the title of the action
  ///@param intent the PendingIntent to fire when users trigger this action
  Notification_Action_Builder.ctor1(
      icon_.Icon icon, jni.JniObject title, pendingintent_.PendingIntent intent)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [icon.reference, title.reference, intent.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Notification\$Action;)V");

  /// from: public void <init>(android.app.Notification.Action action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a new builder for Action object using the fields from an
  /// Action.
  ///@param action the action to read fields from.
  Notification_Action_Builder.ctor2(Notification_Action action)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [action.reference]).object);

  static final _id_addExtras = jniAccessors.getMethodIDOf(
      _classRef,
      "addExtras",
      "(Landroid/os/Bundle;)Landroid/app/Notification\$Action\$Builder;");

  /// from: public android.app.Notification.Action.Builder addExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Merge additional metadata into this builder.
  ///
  /// Values within the Bundle will replace existing extras values in this Builder.
  ///@see Notification.Action\#extras
  Notification_Action_Builder addExtras(bundle_.Bundle extras) =>
      Notification_Action_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addExtras,
          jni.JniType.objectType,
          [extras.reference]).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the metadata Bundle used by this Builder.
  ///
  /// The returned Bundle is shared with this Builder.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_addRemoteInput = jniAccessors.getMethodIDOf(
      _classRef,
      "addRemoteInput",
      "(Landroid/app/RemoteInput;)Landroid/app/Notification\$Action\$Builder;");

  /// from: public android.app.Notification.Action.Builder addRemoteInput(android.app.RemoteInput remoteInput)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an input to be collected from the user when this action is sent.
  /// Response values can be retrieved from the fired intent by using the
  /// RemoteInput\#getResultsFromIntent function.
  ///@param remoteInput a RemoteInput to add to the action
  ///@return this object for method chaining
  Notification_Action_Builder addRemoteInput(
          remoteinput_.RemoteInput remoteInput) =>
      Notification_Action_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addRemoteInput,
          jni.JniType.objectType,
          [remoteInput.reference]).object);

  static final _id_setAllowGeneratedReplies = jniAccessors.getMethodIDOf(
      _classRef,
      "setAllowGeneratedReplies",
      "(Z)Landroid/app/Notification\$Action\$Builder;");

  /// from: public android.app.Notification.Action.Builder setAllowGeneratedReplies(boolean allowGeneratedReplies)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether the platform should automatically generate possible replies to add to
  /// RemoteInput\#getChoices(). If the Action doesn't have a
  /// RemoteInput, this has no effect.
  ///@param allowGeneratedReplies {@code true} to allow generated replies, {@code false}
  /// otherwise
  ///@return this object for method chaining
  /// The default value is {@code true}
  Notification_Action_Builder setAllowGeneratedReplies(
          bool allowGeneratedReplies) =>
      Notification_Action_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setAllowGeneratedReplies,
          jni.JniType.objectType,
          [allowGeneratedReplies]).object);

  static final _id_setSemanticAction = jniAccessors.getMethodIDOf(_classRef,
      "setSemanticAction", "(I)Landroid/app/Notification\$Action\$Builder;");

  /// from: public android.app.Notification.Action.Builder setSemanticAction(int semanticAction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the {@code SemanticAction} for this Action. A
  /// {@code SemanticAction} denotes what an Action's
  /// PendingIntent will do (eg. reply, mark as read, delete, etc).
  ///@param semanticAction a SemanticAction defined within Action with
  /// {@code SEMANTIC_ACTION_} prefixes
  /// Value is android.app.Notification.Action\#SEMANTIC_ACTION_NONE, android.app.Notification.Action\#SEMANTIC_ACTION_REPLY, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_READ, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_UNREAD, android.app.Notification.Action\#SEMANTIC_ACTION_DELETE, android.app.Notification.Action\#SEMANTIC_ACTION_ARCHIVE, android.app.Notification.Action\#SEMANTIC_ACTION_MUTE, android.app.Notification.Action\#SEMANTIC_ACTION_UNMUTE, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_UP, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_DOWN, or android.app.Notification.Action\#SEMANTIC_ACTION_CALL
  ///@return this object for method chaining
  Notification_Action_Builder setSemanticAction(int semanticAction) =>
      Notification_Action_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSemanticAction,
          jni.JniType.objectType,
          [semanticAction]).object);

  static final _id_extend = jniAccessors.getMethodIDOf(_classRef, "extend",
      "(Landroid/app/Notification\$Action\$Extender;)Landroid/app/Notification\$Action\$Builder;");

  /// from: public android.app.Notification.Action.Builder extend(android.app.Notification.Action.Extender extender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply an extender to this action builder. Extenders may be used to add
  /// metadata or change options on this builder.
  Notification_Action_Builder extend(Notification_Action_Extender extender) =>
      Notification_Action_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_extend,
          jni.JniType.objectType,
          [extender.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/app/Notification\$Action;");

  /// from: public android.app.Notification.Action build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Combine all of the options that have been set and return a new Action
  /// object.
  ///@return the built action
  Notification_Action build() =>
      Notification_Action.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}
