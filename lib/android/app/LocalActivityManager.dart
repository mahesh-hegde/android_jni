// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Activity.dart" as activity_;

import "../view/Window.dart" as window_;

import "../content/Intent.dart" as intent_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.LocalActivityManager
///
/// Helper class for managing multiple running embedded activities in the same
/// process. This class is not normally used directly, but rather created for
/// you as part of the android.app.ActivityGroup implementation.
///@see ActivityGroup
///@deprecated Use the new Fragment and FragmentManager APIs
/// instead; these are also
/// available on older platforms through the Android compatibility package.
class LocalActivityManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/LocalActivityManager");
  LocalActivityManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/Activity;Z)V");

  /// from: public void <init>(android.app.Activity parent, boolean singleMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new LocalActivityManager for holding activities running within
  /// the given <var>parent</var>.
  ///@param parent the host of the embedded activities
  ///@param singleMode True if the LocalActivityManger should keep a maximum
  /// of one activity resumed
  LocalActivityManager(activity_.Activity parent, bool singleMode)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [parent.reference, singleMode]).object);

  static final _id_startActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivity",
      "(Ljava/lang/String;Landroid/content/Intent;)Landroid/view/Window;");

  /// from: public android.view.Window startActivity(java.lang.String id, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a new activity running in the group.  Every activity you start
  /// must have a unique string ID associated with it -- this is used to keep
  /// track of the activity, so that if you later call startActivity() again
  /// on it the same activity object will be retained.
  ///
  /// When there had previously been an activity started under this id,
  /// it may either be destroyed and a new one started, or the current
  /// one re-used, based on these conditions, in order:
  ///
  ///
  /// <ul>
  /// <li> If the Intent maps to a different activity component than is
  /// currently running, the current activity is finished and a new one
  /// started.
  /// <li> If the current activity uses a non-multiple launch mode (such
  /// as singleTop), or the Intent has the
  /// Intent\#FLAG_ACTIVITY_SINGLE_TOP flag set, then the current
  /// activity will remain running and its
  /// Activity\#onNewIntent(Intent) Activity.onNewIntent() method
  /// called.
  /// <li> If the new Intent is the same (excluding extras) as the previous
  /// one, and the new Intent does not have the
  /// Intent\#FLAG_ACTIVITY_CLEAR_TOP set, then the current activity
  /// will remain running as-is.
  /// <li> Otherwise, the current activity will be finished and a new
  /// one started.
  /// </ul>
  ///
  /// If the given Intent can not be resolved to an available Activity,
  /// this method throws android.content.ActivityNotFoundException.
  ///
  /// Warning: There is an issue where, if the Intent does not
  /// include an explicit component, we can restore the state for a different
  /// activity class than was previously running when the state was saved (if
  /// the set of available activities changes between those points).
  ///@param id Unique identifier of the activity to be started
  ///@param intent The Intent describing the activity to be started
  ///@return Returns the window of the activity.  The caller needs to take
  /// care of adding this window to a view hierarchy, and likewise dealing
  /// with removing the old window if the activity has changed.
  ///@throws android.content.ActivityNotFoundException
  window_.Window startActivity(jni.JniString id, intent_.Intent intent) =>
      window_.Window.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivity,
          jni.JniType.objectType,
          [id.reference, intent.reference]).object);

  static final _id_destroyActivity = jniAccessors.getMethodIDOf(_classRef,
      "destroyActivity", "(Ljava/lang/String;Z)Landroid/view/Window;");

  /// from: public android.view.Window destroyActivity(java.lang.String id, boolean finish)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Destroy the activity associated with a particular id.  This activity
  /// will go through the normal lifecycle events and fine onDestroy(), and
  /// then the id removed from the group.
  ///@param id Unique identifier of the activity to be destroyed
  ///@param finish If true, this activity will be finished, so its id and
  /// all state are removed from the group.
  ///@return Returns the window that was used to display the activity, or
  /// null if there was none.
  window_.Window destroyActivity(jni.JniString id, bool finish) =>
      window_.Window.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_destroyActivity,
          jni.JniType.objectType,
          [id.reference, finish]).object);

  static final _id_getCurrentActivity = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentActivity", "()Landroid/app/Activity;");

  /// from: public android.app.Activity getCurrentActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Activity that is currently running.
  ///@return the currently running (resumed) Activity, or null if there is
  ///         not one
  ///@see \#startActivity
  ///@see \#getCurrentId
  activity_.Activity getCurrentActivity() =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCurrentActivity, jni.JniType.objectType, []).object);

  static final _id_getCurrentId = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentId", "()Ljava/lang/String;");

  /// from: public java.lang.String getCurrentId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the ID of the activity that is currently running.
  ///@return the ID of the currently running (resumed) Activity, or null if
  ///         there is not one
  ///@see \#startActivity
  ///@see \#getCurrentActivity
  jni.JniString getCurrentId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCurrentId, jni.JniType.objectType, []).object);

  static final _id_getActivity = jniAccessors.getMethodIDOf(
      _classRef, "getActivity", "(Ljava/lang/String;)Landroid/app/Activity;");

  /// from: public android.app.Activity getActivity(java.lang.String id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Activity object associated with a string ID.
  ///@see \#startActivity
  ///@return the associated Activity object, or null if the id is unknown or
  ///         its activity is not currently instantiated
  activity_.Activity getActivity(jni.JniString id) =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getActivity, jni.JniType.objectType, [id.reference]).object);

  static final _id_dispatchCreate = jniAccessors.getMethodIDOf(
      _classRef, "dispatchCreate", "(Landroid/os/Bundle;)V");

  /// from: public void dispatchCreate(android.os.Bundle state)
  ///
  /// Restore a state that was previously returned by \#saveInstanceState.  This
  /// adds to the activity group information about all activity IDs that had
  /// previously been saved, even if they have not been started yet, so if the
  /// user later navigates to them the correct state will be restored.
  ///
  /// Note: This does __not__ change the current running activity, or
  /// start whatever activity was previously running when the state was saved.
  /// That is up to the client to do, in whatever way it thinks is best.
  ///@param state a previously saved state; does nothing if this is null
  ///@see \#saveInstanceState
  void dispatchCreate(bundle_.Bundle state) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchCreate,
      jni.JniType.voidType,
      [state.reference]).check();

  static final _id_saveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "saveInstanceState", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle saveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the state of all activities known by the group.  For
  /// activities that have previously run and are now stopped or finished, the
  /// last saved state is used.  For the current running activity, its
  /// Activity\#onSaveInstanceState is called to retrieve its current state.
  ///@return a Bundle holding the newly created state of all known activities
  ///@see \#dispatchCreate
  bundle_.Bundle saveInstanceState() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_saveInstanceState, jni.JniType.objectType, []).object);

  static final _id_dispatchResume =
      jniAccessors.getMethodIDOf(_classRef, "dispatchResume", "()V");

  /// from: public void dispatchResume()
  ///
  /// Called by the container activity in its Activity\#onResume so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onResume
  void dispatchResume() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchResume, jni.JniType.voidType, []).check();

  static final _id_dispatchPause =
      jniAccessors.getMethodIDOf(_classRef, "dispatchPause", "(Z)V");

  /// from: public void dispatchPause(boolean finishing)
  ///
  /// Called by the container activity in its Activity\#onPause so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@param finishing set to true if the parent activity has been finished;
  ///                  this can be determined by calling
  ///                  Activity.isFinishing()
  ///@see Activity\#onPause
  ///@see Activity\#isFinishing
  void dispatchPause(bool finishing) => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchPause, jni.JniType.voidType, [finishing]).check();

  static final _id_dispatchStop =
      jniAccessors.getMethodIDOf(_classRef, "dispatchStop", "()V");

  /// from: public void dispatchStop()
  ///
  /// Called by the container activity in its Activity\#onStop so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onStop
  void dispatchStop() => jniAccessors.callMethodWithArgs(
      reference, _id_dispatchStop, jni.JniType.voidType, []).check();

  static final _id_removeAllActivities =
      jniAccessors.getMethodIDOf(_classRef, "removeAllActivities", "()V");

  /// from: public void removeAllActivities()
  ///
  /// Remove all activities from this LocalActivityManager, performing an
  /// Activity\#onDestroy on any that are currently instantiated.
  void removeAllActivities() => jniAccessors.callMethodWithArgs(
      reference, _id_removeAllActivities, jni.JniType.voidType, []).check();

  static final _id_dispatchDestroy =
      jniAccessors.getMethodIDOf(_classRef, "dispatchDestroy", "(Z)V");

  /// from: public void dispatchDestroy(boolean finishing)
  ///
  /// Called by the container activity in its Activity\#onDestroy so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onDestroy
  void dispatchDestroy(bool finishing) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDestroy,
      jni.JniType.voidType,
      [finishing]).check();
}
