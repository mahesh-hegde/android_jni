// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Service.dart" as service_;

import "../content/Intent.dart" as intent_;

import "../os/IBinder.dart" as ibinder_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.IntentService
///
/// IntentService is a base class for Services that handle asynchronous
/// requests (expressed as Intents) on demand.  Clients send requests
/// through android.content.Context\#startService(Intent) calls; the
/// service is started as needed, handles each Intent in turn using a worker
/// thread, and stops itself when it runs out of work.
///
/// This "work queue processor" pattern is commonly used to offload tasks
/// from an application's main thread.  The IntentService class exists to
/// simplify this pattern and take care of the mechanics.  To use it, extend
/// IntentService and implement \#onHandleIntent(Intent).  IntentService
/// will receive the Intents, launch a worker thread, and stop the service as
/// appropriate.
///
/// All requests are handled on a single worker thread -- they may take as
/// long as necessary (and will not block the application's main loop), but
/// only one request will be processed at a time.
///
/// <p class="note">__Note:__ IntentService is subject to all the
/// <a href="/preview/features/background.html">background execution limits</a>
/// imposed with Android 8.0 (API level 26). In most cases, you are better off
/// using android.support.v4.app.JobIntentService, which uses jobs
/// instead of services when running on Android 8.0 or higher.
///
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a detailed discussion about how to create services, read the
/// <a href="{@docRoot}guide/components/services.html">Services</a> developer
/// guide.
///
/// </div>
///@see android.support.v4.app.JobIntentService
///@see android.os.AsyncTask
class IntentService extends service_.Service {
  static final _classRef = jniAccessors.getClassOf("android/app/IntentService");
  IntentService.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an IntentService.  Invoked by your subclass's constructor.
  ///@param name Used to name the worker thread, important only for debugging.
  IntentService.ctor3(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [name.reference]).object);

  static final _id_setIntentRedelivery =
      jniAccessors.getMethodIDOf(_classRef, "setIntentRedelivery", "(Z)V");

  /// from: public void setIntentRedelivery(boolean enabled)
  ///
  /// Sets intent redelivery preferences.  Usually called from the constructor
  /// with your preferred semantics.
  ///
  /// If enabled is true,
  /// \#onStartCommand(Intent, int, int) will return
  /// Service\#START_REDELIVER_INTENT, so if this process dies before
  /// \#onHandleIntent(Intent) returns, the process will be restarted
  /// and the intent redelivered.  If multiple Intents have been sent, only
  /// the most recent one is guaranteed to be redelivered.
  ///
  /// If enabled is false (the default),
  /// \#onStartCommand(Intent, int, int) will return
  /// Service\#START_NOT_STICKY, and if the process dies, the Intent
  /// dies along with it.
  void setIntentRedelivery(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIntentRedelivery,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onStart = jniAccessors.getMethodIDOf(
      _classRef, "onStart", "(Landroid/content/Intent;I)V");

  /// from: public void onStart(android.content.Intent intent, int startId)
  ///
  /// @param intent This value may be {@code null}.
  void onStart(intent_.Intent intent, int startId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStart,
          jni.JniType.voidType, [intent.reference, startId]).check();

  static final _id_onStartCommand = jniAccessors.getMethodIDOf(
      _classRef, "onStartCommand", "(Landroid/content/Intent;II)I");

  /// from: public int onStartCommand(android.content.Intent intent, int flags, int startId)
  ///
  /// You should not override this method for your IntentService. Instead,
  /// override \#onHandleIntent, which the system calls when the IntentService
  /// receives a start request.
  ///@see android.app.Service\#onStartCommand
  ///@param intent This value may be {@code null}.
  int onStartCommand(intent_.Intent intent, int flags, int startId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartCommand,
          jni.JniType.intType, [intent.reference, flags, startId]).integer;

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Unless you provide binding for your service, you don't need to implement this
  /// method, because the default implementation returns null.
  ///@see android.app.Service\#onBind
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_onHandleIntent = jniAccessors.getMethodIDOf(
      _classRef, "onHandleIntent", "(Landroid/content/Intent;)V");

  /// from: protected abstract void onHandleIntent(android.content.Intent intent)
  ///
  /// This method is invoked on the worker thread with a request to process.
  /// Only one Intent is processed at a time, but the processing happens on a
  /// worker thread that runs independently from other application logic.
  /// So, if this code takes a long time, it will hold up other requests to
  /// the same IntentService, but it will not hold up anything else.
  /// When all requests have been handled, the IntentService stops itself,
  /// so you should not call \#stopSelf.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param intent The value passed to android.content.Context\#startService(Intent).
  ///               This may be null if the service is being restarted after
  ///               its process has gone away; see
  ///               android.app.Service\#onStartCommand
  ///               for details.
  ///
  /// This value may be {@code null}.
  void onHandleIntent(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onHandleIntent,
      jni.JniType.voidType,
      [intent.reference]).check();
}
