// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../os/Handler.dart" as handler_;

import "../util/Size.dart" as size_;

import "Activity.dart" as activity_;

import "../content/Intent.dart" as intent_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../os/Bundle.dart" as bundle_;

import "PendingIntent.dart" as pendingintent_;

import "../content/ComponentName.dart" as componentname_;

import "../content/pm/ConfigurationInfo.dart" as configurationinfo_;

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.ActivityManager
///
///
/// This class gives information about, and interacts
/// with, activities, services, and the containing
/// process.
///
///
///
///
/// A number of the methods in this class are for
/// debugging or informational purposes and they should
/// not be used to affect any runtime behavior of
/// your app. These methods are called out as such in
/// the method level documentation.
///
///
///
///
/// Most application developers should not have the need to
/// use this class, most of whose methods are for specialized
/// use cases. However, a few methods are more broadly applicable.
/// For instance, android.app.ActivityManager\#isLowRamDevice() isLowRamDevice()
/// enables your app to detect whether it is running on a low-memory device,
/// and behave accordingly.
/// android.app.ActivityManager\#clearApplicationUserData() clearApplicationUserData()
/// is for apps with reset-data functionality.
///
///
///
///
/// In some special use cases, where an app interacts with
/// its Task stack, the app may use the
/// android.app.ActivityManager.AppTask and
/// android.app.ActivityManager.RecentTaskInfo inner
/// classes. However, in general, the methods in this class should
/// be used for testing and debugging purposes only.
///
///
class ActivityManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActivityManager");
  ActivityManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_REPORT_HEAP_LIMIT
  ///
  /// Action an app can implement to handle reports from \#setWatchHeapLimit(long).
  /// If your package has an activity handling this action, it will be launched with the
  /// heap data provided to it the same way as Intent\#ACTION_SEND.  Note that to
  /// match the activty must support this action and a MIME type of "*&\#47;*".
  static const ACTION_REPORT_HEAP_LIMIT =
      "android.app.action.REPORT_HEAP_LIMIT";

  /// from: static public final int LOCK_TASK_MODE_LOCKED
  ///
  /// Full lock task mode is active.
  static const LOCK_TASK_MODE_LOCKED = 1;

  /// from: static public final int LOCK_TASK_MODE_NONE
  ///
  /// Lock task mode is not active.
  static const LOCK_TASK_MODE_NONE = 0;

  /// from: static public final int LOCK_TASK_MODE_PINNED
  ///
  /// App pinning mode is active.
  static const LOCK_TASK_MODE_PINNED = 2;

  /// from: static public final java.lang.String META_HOME_ALTERNATE
  ///
  /// <a href="{@docRoot}guide/topics/manifest/meta-data-element.html">{@code
  /// <meta-data>}</a> name for a 'home' Activity that declares a package that is to be
  /// uninstalled in lieu of the declaring one.  The package named here must be
  /// signed with the same certificate as the one declaring the {@code <meta-data>}.
  static const META_HOME_ALTERNATE = "android.app.home.alternate";

  /// from: static public final int MOVE_TASK_NO_USER_ACTION
  ///
  /// Flag for \#moveTaskToFront(int, int): don't count this as a
  /// user-instigated action, so the current activity will not receive a
  /// hint that the user is leaving.
  static const MOVE_TASK_NO_USER_ACTION = 2;

  /// from: static public final int MOVE_TASK_WITH_HOME
  ///
  /// Flag for \#moveTaskToFront(int, int): also move the "home"
  /// activity along with the task, so it is positioned immediately behind
  /// the task.
  static const MOVE_TASK_WITH_HOME = 1;

  /// from: static public final int RECENT_IGNORE_UNAVAILABLE
  ///
  /// Provides a list that does not contain any
  /// recent tasks that currently are not available to the user.
  static const RECENT_IGNORE_UNAVAILABLE = 2;

  /// from: static public final int RECENT_WITH_EXCLUDED
  ///
  /// Flag for use with \#getRecentTasks: return all tasks, even those
  /// that have set their
  /// android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS flag.
  static const RECENT_WITH_EXCLUDED = 1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Landroid/os/Handler;)V");

  /// from: void <init>(android.content.Context context, android.os.Handler handler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager(context_.Context context, handler_.Handler handler)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [context.reference, handler.reference]).object);

  static final _id_getMemoryClass =
      jniAccessors.getMethodIDOf(_classRef, "getMemoryClass", "()I");

  /// from: public int getMemoryClass()
  ///
  /// Return the approximate per-application memory class of the current
  /// device.  This gives you an idea of how hard a memory limit you should
  /// impose on your application to let the overall system work best.  The
  /// returned value is in megabytes; the baseline Android memory class is
  /// 16 (which happens to be the Java heap limit of those devices); some
  /// devices with more memory may return 24 or even higher numbers.
  int getMemoryClass() => jniAccessors.callMethodWithArgs(
      reference, _id_getMemoryClass, jni.JniType.intType, []).integer;

  static final _id_getLargeMemoryClass =
      jniAccessors.getMethodIDOf(_classRef, "getLargeMemoryClass", "()I");

  /// from: public int getLargeMemoryClass()
  ///
  /// Return the approximate per-application memory class of the current
  /// device when an application is running with a large heap.  This is the
  /// space available for memory-intensive applications; most applications
  /// should not need this amount of memory, and should instead stay with the
  /// \#getMemoryClass() limit.  The returned value is in megabytes.
  /// This may be the same size as \#getMemoryClass() on memory
  /// constrained devices, or it may be significantly larger on devices with
  /// a large amount of available RAM.
  ///
  /// This is the size of the application's Dalvik heap if it has
  /// specified <code>android:largeHeap="true"</code> in its manifest.
  int getLargeMemoryClass() => jniAccessors.callMethodWithArgs(
      reference, _id_getLargeMemoryClass, jni.JniType.intType, []).integer;

  static final _id_isLowRamDevice =
      jniAccessors.getMethodIDOf(_classRef, "isLowRamDevice", "()Z");

  /// from: public boolean isLowRamDevice()
  ///
  /// Returns true if this is a low-RAM device.  Exactly whether a device is low-RAM
  /// is ultimately up to the device configuration, but currently it generally means
  /// something with 1GB or less of RAM.  This is mostly intended to be used by apps
  /// to determine whether they should turn off certain features that require more RAM.
  bool isLowRamDevice() => jniAccessors.callMethodWithArgs(
      reference, _id_isLowRamDevice, jni.JniType.booleanType, []).boolean;

  static final _id_getRecentTasks = jniAccessors.getMethodIDOf(
      _classRef, "getRecentTasks", "(II)Ljava/util/List;");

  /// from: public java.util.List<android.app.ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  ///Return a list of the tasks that the user has recently launched, with
  /// the most recent being first and older ones after in order.
  ///
  /// __Note: this method is only intended for debugging and presenting
  /// task management user interfaces__.  This should never be used for
  /// core logic in an application, such as deciding between different
  /// behaviors based on the information found here.  Such uses are
  /// _not_ supported, and will likely break in the future.  For
  /// example, if multiple applications can be actively running at the
  /// same time, assumptions made about the meaning of the data here for
  /// purposes of control flow will be incorrect.
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this method is
  /// no longer available to third party applications: the introduction of
  /// document-centric recents means
  /// it can leak personal information to the caller.  For backwards compatibility,
  /// it will still return a small subset of its data: at least the caller's
  /// own tasks (though see \#getAppTasks() for the correct supported
  /// way to retrieve that information), and possibly some other tasks
  /// such as home that are known to not be sensitive.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many tasks the
  /// user has started and the maximum number the system can remember.
  ///@param flags Information about what to return.  May be any combination
  /// of \#RECENT_WITH_EXCLUDED and \#RECENT_IGNORE_UNAVAILABLE.
  ///@return Returns a list of RecentTaskInfo records describing each of
  /// the recent tasks.
  jni.JniObject getRecentTasks(int maxNum, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRecentTasks, jni.JniType.objectType, [maxNum, flags]).object);

  static final _id_getAppTasks = jniAccessors.getMethodIDOf(
      _classRef, "getAppTasks", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.ActivityManager.AppTask> getAppTasks()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of tasks associated with the calling application.
  ///@return The list of tasks associated with the application making this call.
  ///@throws SecurityException
  jni.JniObject getAppTasks() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAppTasks, jni.JniType.objectType, []).object);

  static final _id_getAppTaskThumbnailSize = jniAccessors.getMethodIDOf(
      _classRef, "getAppTaskThumbnailSize", "()Landroid/util/Size;");

  /// from: public android.util.Size getAppTaskThumbnailSize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current design dimensions for AppTask thumbnails, for use
  /// with \#addAppTask.
  size_.Size getAppTaskThumbnailSize() =>
      size_.Size.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAppTaskThumbnailSize, jni.JniType.objectType, []).object);

  static final _id_addAppTask = jniAccessors.getMethodIDOf(
      _classRef,
      "addAppTask",
      "(Landroid/app/Activity;Landroid/content/Intent;Landroid/app/ActivityManager\$TaskDescription;Landroid/graphics/Bitmap;)I");

  /// from: public int addAppTask(android.app.Activity activity, android.content.Intent intent, android.app.ActivityManager.TaskDescription description, android.graphics.Bitmap thumbnail)
  ///
  /// Add a new AppTask for the calling application.  This will create a new
  /// recents entry that is added to the __end__ of all existing recents.
  ///@param activity The activity that is adding the entry.   This is used to help determine
  /// the context that the new recents entry will be in.
  /// This value must never be {@code null}.
  ///@param intent The Intent that describes the recents entry.  This is the same Intent that
  /// you would have used to launch the activity for it.  In generally you will want to set
  /// both Intent\#FLAG_ACTIVITY_NEW_DOCUMENT and
  /// Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS; the latter is required since this recents
  /// entry will exist without an activity, so it doesn't make sense to not retain it when
  /// its activity disappears.  The given Intent here also must have an explicit ComponentName
  /// set on it.
  /// This value must never be {@code null}.
  ///@param description Optional additional description information.
  /// This value may be {@code null}.
  ///@param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
  /// \#getAppTaskThumbnailSize().  If the bitmap is not that exact size, it will be
  /// recreated in your process, probably in a way you don't like, before the recents entry
  /// is added.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the task id of the newly added app task, or -1 if the add failed.  The
  /// most likely cause of failure is that there is no more room for more tasks for your app.
  int addAppTask(
          activity_.Activity activity,
          intent_.Intent intent,
          ActivityManager_TaskDescription description,
          bitmap_.Bitmap thumbnail) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_addAppTask, jni.JniType.intType, [
        activity.reference,
        intent.reference,
        description.reference,
        thumbnail.reference
      ]).integer;

  static final _id_getRunningTasks = jniAccessors.getMethodIDOf(
      _classRef, "getRunningTasks", "(I)Ljava/util/List;");

  /// from: public java.util.List<android.app.ActivityManager.RunningTaskInfo> getRunningTasks(int maxNum)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of the tasks that are currently running, with
  /// the most recent being first and older ones after in order.  Note that
  /// "running" does not mean any of the task's code is currently loaded or
  /// activity -- the task may have been frozen by the system, so that it
  /// can be restarted in its previous state when next brought to the
  /// foreground.
  ///
  /// __Note: this method is only intended for debugging and presenting
  /// task management user interfaces__.  This should never be used for
  /// core logic in an application, such as deciding between different
  /// behaviors based on the information found here.  Such uses are
  /// _not_ supported, and will likely break in the future.  For
  /// example, if multiple applications can be actively running at the
  /// same time, assumptions made about the meaning of the data here for
  /// purposes of control flow will be incorrect.
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this method
  /// is no longer available to third party
  /// applications: the introduction of document-centric recents means
  /// it can leak person information to the caller.  For backwards compatibility,
  /// it will still return a small subset of its data: at least the caller's
  /// own tasks, and possibly some other tasks
  /// such as home that are known to not be sensitive.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many tasks the
  /// user has started.
  ///@return Returns a list of RunningTaskInfo records describing each of
  /// the running tasks.
  jni.JniObject getRunningTasks(int maxNum) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRunningTasks, jni.JniType.objectType, [maxNum]).object);

  static final _id_moveTaskToFront =
      jniAccessors.getMethodIDOf(_classRef, "moveTaskToFront", "(II)V");

  /// from: public void moveTaskToFront(int taskId, int flags)
  ///
  /// Equivalent to calling \#moveTaskToFront(int, int, Bundle)
  /// with a null options argument.
  ///
  /// Requires android.Manifest.permission\#REORDER_TASKS
  ///@param taskId The identifier of the task to be moved, as found in
  /// RunningTaskInfo or RecentTaskInfo.
  ///@param flags Additional operational flags.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActivityManager\#MOVE_TASK_WITH_HOME, and android.app.ActivityManager\#MOVE_TASK_NO_USER_ACTION
  void moveTaskToFront(int taskId, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_moveTaskToFront,
          jni.JniType.voidType, [taskId, flags]).check();

  static final _id_moveTaskToFront1 = jniAccessors.getMethodIDOf(
      _classRef, "moveTaskToFront", "(IILandroid/os/Bundle;)V");

  /// from: public void moveTaskToFront(int taskId, int flags, android.os.Bundle options)
  ///
  /// Ask that the task associated with a given task ID be moved to the
  /// front of the stack, so it is now visible to the user.
  ///
  /// Requires android.Manifest.permission\#REORDER_TASKS
  ///@param taskId The identifier of the task to be moved, as found in
  /// RunningTaskInfo or RecentTaskInfo.
  ///@param flags Additional operational flags.
  /// Value is either <code>0</code> or a combination of android.app.ActivityManager\#MOVE_TASK_WITH_HOME, and android.app.ActivityManager\#MOVE_TASK_NO_USER_ACTION
  ///@param options Additional options for the operation, either null or
  /// as per Context\#startActivity(Intent, android.os.Bundle) Context.startActivity(Intent, Bundle).
  void moveTaskToFront1(int taskId, int flags, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(reference, _id_moveTaskToFront1,
          jni.JniType.voidType, [taskId, flags, options.reference]).check();

  static final _id_getRunningServices = jniAccessors.getMethodIDOf(
      _classRef, "getRunningServices", "(I)Ljava/util/List;");

  /// from: public java.util.List<android.app.ActivityManager.RunningServiceInfo> getRunningServices(int maxNum)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of the services that are currently running.
  ///
  /// __Note: this method is only intended for debugging or implementing
  /// service management type user interfaces.__
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#O, this method
  /// is no longer available to third party applications.  For backwards compatibility,
  /// it will still return the caller's own services.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many services
  /// are running.
  ///@return Returns a list of RunningServiceInfo records describing each of
  /// the running tasks.
  jni.JniObject getRunningServices(int maxNum) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRunningServices, jni.JniType.objectType, [maxNum]).object);

  static final _id_getRunningServiceControlPanel = jniAccessors.getMethodIDOf(
      _classRef,
      "getRunningServiceControlPanel",
      "(Landroid/content/ComponentName;)Landroid/app/PendingIntent;");

  /// from: public android.app.PendingIntent getRunningServiceControlPanel(android.content.ComponentName service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a PendingIntent you can start to show a control panel for the
  /// given running service.  If the service does not have a control panel,
  /// null is returned.
  pendingintent_.PendingIntent getRunningServiceControlPanel(
          componentname_.ComponentName service) =>
      pendingintent_.PendingIntent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getRunningServiceControlPanel,
          jni.JniType.objectType,
          [service.reference]).object);

  static final _id_getMemoryInfo = jniAccessors.getMethodIDOf(_classRef,
      "getMemoryInfo", "(Landroid/app/ActivityManager\$MemoryInfo;)V");

  /// from: public void getMemoryInfo(android.app.ActivityManager.MemoryInfo outInfo)
  ///
  /// Return general information about the memory state of the system.  This
  /// can be used to help decide how to manage your own memory, though note
  /// that polling is not recommended and
  /// android.content.ComponentCallbacks2\#onTrimMemory(int) ComponentCallbacks2.onTrimMemory(int) is the preferred way to do this.
  /// Also see \#getMyMemoryState for how to retrieve the current trim
  /// level of your process as needed, which gives a better hint for how to
  /// manage its memory.
  void getMemoryInfo(ActivityManager_MemoryInfo outInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_getMemoryInfo,
          jni.JniType.voidType, [outInfo.reference]).check();

  static final _id_clearApplicationUserData =
      jniAccessors.getMethodIDOf(_classRef, "clearApplicationUserData", "()Z");

  /// from: public boolean clearApplicationUserData()
  ///
  /// Permits an application to erase its own data from disk.  This is equivalent to
  /// the user choosing to clear the app's data from within the device settings UI.  It
  /// erases all dynamic data associated with the app -- its private data and data in its
  /// private area on external storage -- but does not remove the installed application
  /// itself, nor any OBB files. It also revokes all runtime permissions that the app has acquired,
  /// clears all notifications and removes all Uri grants related to this application.
  ///@return {@code true} if the application successfully requested that the application's
  ///     data be erased; {@code false} otherwise.
  bool clearApplicationUserData() => jniAccessors.callMethodWithArgs(reference,
      _id_clearApplicationUserData, jni.JniType.booleanType, []).boolean;

  static final _id_getProcessesInErrorState = jniAccessors.getMethodIDOf(
      _classRef, "getProcessesInErrorState", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.ActivityManager.ProcessErrorStateInfo> getProcessesInErrorState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of any processes that are currently in an error condition.  The result
  /// will be null if all processes are running properly at this time.
  ///@return Returns a list of ProcessErrorStateInfo records, or null if there are no
  /// current error conditions (it will not return an empty list).  This list ordering is not
  /// specified.
  jni.JniObject getProcessesInErrorState() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getProcessesInErrorState, jni.JniType.objectType, []).object);

  static final _id_isBackgroundRestricted =
      jniAccessors.getMethodIDOf(_classRef, "isBackgroundRestricted", "()Z");

  /// from: public boolean isBackgroundRestricted()
  ///
  /// Query whether the user has enabled background restrictions for this app.
  ///
  ///  The user may chose to do this, if they see that an app is consuming an unreasonable
  /// amount of battery while in the background.
  ///
  ///
  ///  If true, any work that the app tries to do will be aggressively restricted while it is in
  /// the background. At a minimum, jobs and alarms will not execute and foreground services
  /// cannot be started unless an app activity is in the foreground.
  ///
  ///
  /// __ Note that these restrictions stay in effect even when the device is charging.__
  ///
  ///@return true if user has enforced background restrictions for this app, false otherwise.
  bool isBackgroundRestricted() => jniAccessors.callMethodWithArgs(reference,
      _id_isBackgroundRestricted, jni.JniType.booleanType, []).boolean;

  static final _id_getRunningAppProcesses = jniAccessors.getMethodIDOf(
      _classRef, "getRunningAppProcesses", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.ActivityManager.RunningAppProcessInfo> getRunningAppProcesses()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of application processes that are running on the device.
  ///
  /// __Note: this method is only intended for debugging or building
  /// a user-facing process management UI.__
  ///
  ///@return Returns a list of RunningAppProcessInfo records, or null if there are no
  /// running processes (it will not return an empty list).  This list ordering is not
  /// specified.
  jni.JniObject getRunningAppProcesses() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRunningAppProcesses, jni.JniType.objectType, []).object);

  static final _id_getMyMemoryState = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getMyMemoryState",
      "(Landroid/app/ActivityManager\$RunningAppProcessInfo;)V");

  /// from: static public void getMyMemoryState(android.app.ActivityManager.RunningAppProcessInfo outState)
  ///
  /// Return global memory state information for the calling process.  This
  /// does not fill in all fields of the RunningAppProcessInfo.  The
  /// only fields that will be filled in are
  /// RunningAppProcessInfo\#pid,
  /// RunningAppProcessInfo\#uid,
  /// RunningAppProcessInfo\#lastTrimLevel,
  /// RunningAppProcessInfo\#importance,
  /// RunningAppProcessInfo\#lru, and
  /// RunningAppProcessInfo\#importanceReasonCode.
  static void getMyMemoryState(
          ActivityManager_RunningAppProcessInfo outState) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getMyMemoryState,
          jni.JniType.voidType, [outState.reference]).check();

  static final _id_getProcessMemoryInfo = jniAccessors.getMethodIDOf(
      _classRef, "getProcessMemoryInfo", "([I)[Landroid/os/Debug\$MemoryInfo;");

  /// from: public android.os.Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return information about the memory usage of one or more processes.
  ///
  /// __Note: this method is only intended for debugging or building
  /// a user-facing process management UI.__
  ///
  ///@param pids The pids of the processes whose memory usage is to be
  /// retrieved.
  ///@return Returns an array of memory information, one for each
  /// requested pid.
  jni.JniObject getProcessMemoryInfo(jni.JniObject pids) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getProcessMemoryInfo,
          jni.JniType.objectType,
          [pids.reference]).object);

  static final _id_restartPackage = jniAccessors.getMethodIDOf(
      _classRef, "restartPackage", "(Ljava/lang/String;)V");

  /// from: public void restartPackage(java.lang.String packageName)
  ///
  /// @deprecated This is now just a wrapper for
  /// \#killBackgroundProcesses(String); the previous behavior here
  /// is no longer available to applications because it allows them to
  /// break other applications by removing their alarms, stopping their
  /// services, etc.
  void restartPackage(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_restartPackage,
          jni.JniType.voidType, [packageName.reference]).check();

  static final _id_killBackgroundProcesses = jniAccessors.getMethodIDOf(
      _classRef, "killBackgroundProcesses", "(Ljava/lang/String;)V");

  /// from: public void killBackgroundProcesses(java.lang.String packageName)
  ///
  /// Have the system immediately kill all background processes associated
  /// with the given package.  This is the same as the kernel killing those
  /// processes to reclaim memory; the system will take care of restarting
  /// these processes in the future as needed.
  ///
  /// Requires android.Manifest.permission\#KILL_BACKGROUND_PROCESSES
  ///@param packageName The name of the package whose processes are to
  /// be killed.
  void killBackgroundProcesses(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_killBackgroundProcesses,
          jni.JniType.voidType, [packageName.reference]).check();

  static final _id_getDeviceConfigurationInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getDeviceConfigurationInfo",
      "()Landroid/content/pm/ConfigurationInfo;");

  /// from: public android.content.pm.ConfigurationInfo getDeviceConfigurationInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the device configuration attributes.
  configurationinfo_.ConfigurationInfo getDeviceConfigurationInfo() =>
      configurationinfo_.ConfigurationInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getDeviceConfigurationInfo,
              jni.JniType.objectType, []).object);

  static final _id_getLauncherLargeIconDensity = jniAccessors.getMethodIDOf(
      _classRef, "getLauncherLargeIconDensity", "()I");

  /// from: public int getLauncherLargeIconDensity()
  ///
  /// Get the preferred density of icons for the launcher. This is used when
  /// custom drawables are created (e.g., for shortcuts).
  ///@return density in terms of DPI
  int getLauncherLargeIconDensity() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLauncherLargeIconDensity,
      jni.JniType.intType, []).integer;

  static final _id_getLauncherLargeIconSize =
      jniAccessors.getMethodIDOf(_classRef, "getLauncherLargeIconSize", "()I");

  /// from: public int getLauncherLargeIconSize()
  ///
  /// Get the preferred launcher icon size. This is used when custom drawables
  /// are created (e.g., for shortcuts).
  ///@return dimensions of square icons in terms of pixels
  int getLauncherLargeIconSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getLauncherLargeIconSize, jni.JniType.intType, []).integer;

  static final _id_isUserAMonkey =
      jniAccessors.getStaticMethodIDOf(_classRef, "isUserAMonkey", "()Z");

  /// from: static public boolean isUserAMonkey()
  ///
  /// Returns "true" if the user interface is currently being messed with
  /// by a monkey.
  static bool isUserAMonkey() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isUserAMonkey, jni.JniType.booleanType, []).boolean;

  static final _id_isRunningInTestHarness = jniAccessors.getStaticMethodIDOf(
      _classRef, "isRunningInTestHarness", "()Z");

  /// from: static public boolean isRunningInTestHarness()
  ///
  /// Returns "true" if device is running in a test harness.
  static bool isRunningInTestHarness() => jniAccessors.callStaticMethodWithArgs(
      _classRef,
      _id_isRunningInTestHarness,
      jni.JniType.booleanType, []).boolean;

  static final _id_dumpPackageState = jniAccessors.getMethodIDOf(_classRef,
      "dumpPackageState", "(Ljava/io/FileDescriptor;Ljava/lang/String;)V");

  /// from: public void dumpPackageState(java.io.FileDescriptor fd, java.lang.String packageName)
  ///
  /// Perform a system dump of various state associated with the given application
  /// package name.  This call blocks while the dump is being performed, so should
  /// not be done on a UI thread.  The data will be written to the given file
  /// descriptor as text.
  /// Requires android.Manifest.permission\#DUMP
  ///@param fd The file descriptor that the dump should be written to.  The file
  /// descriptor is _not_ closed by this function; the caller continues to
  /// own it.
  ///@param packageName The name of the package that is to be dumped.
  void dumpPackageState(jni.JniObject fd, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_dumpPackageState,
          jni.JniType.voidType, [fd.reference, packageName.reference]).check();

  static final _id_setWatchHeapLimit =
      jniAccessors.getMethodIDOf(_classRef, "setWatchHeapLimit", "(J)V");

  /// from: public void setWatchHeapLimit(long pssSize)
  ///
  /// Request that the system start watching for the calling process to exceed a pss
  /// size as given here.  Once called, the system will look for any occasions where it
  /// sees the associated process with a larger pss size and, when this happens, automatically
  /// pull a heap dump from it and allow the user to share the data.  Note that this request
  /// continues running even if the process is killed and restarted.  To remove the watch,
  /// use \#clearWatchHeapLimit().
  ///
  /// This API only work if the calling process has been marked as
  /// ApplicationInfo\#FLAG_DEBUGGABLE or this is running on a debuggable
  /// (userdebug or eng) build.
  ///
  ///
  /// Callers can optionally implement \#ACTION_REPORT_HEAP_LIMIT to directly
  /// handle heap limit reports themselves.
  ///
  ///@param pssSize The size in bytes to set the limit at.
  void setWatchHeapLimit(int pssSize) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWatchHeapLimit,
      jni.JniType.voidType,
      [pssSize]).check();

  static final _id_clearWatchHeapLimit =
      jniAccessors.getMethodIDOf(_classRef, "clearWatchHeapLimit", "()V");

  /// from: public void clearWatchHeapLimit()
  ///
  /// Clear a heap watch limit previously set by \#setWatchHeapLimit(long).
  void clearWatchHeapLimit() => jniAccessors.callMethodWithArgs(
      reference, _id_clearWatchHeapLimit, jni.JniType.voidType, []).check();

  static final _id_isInLockTaskMode =
      jniAccessors.getMethodIDOf(_classRef, "isInLockTaskMode", "()Z");

  /// from: public boolean isInLockTaskMode()
  ///
  /// Return whether currently in lock task mode.  When in this mode
  /// no new tasks can be created or switched to.
  ///@see Activity\#startLockTask()
  ///@deprecated Use \#getLockTaskModeState instead.
  bool isInLockTaskMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isInLockTaskMode, jni.JniType.booleanType, []).boolean;

  static final _id_getLockTaskModeState =
      jniAccessors.getMethodIDOf(_classRef, "getLockTaskModeState", "()I");

  /// from: public int getLockTaskModeState()
  ///
  /// Return the current state of task locking. The three possible outcomes
  /// are \#LOCK_TASK_MODE_NONE, \#LOCK_TASK_MODE_LOCKED
  /// and \#LOCK_TASK_MODE_PINNED.
  ///@see Activity\#startLockTask()
  int getLockTaskModeState() => jniAccessors.callMethodWithArgs(
      reference, _id_getLockTaskModeState, jni.JniType.intType, []).integer;

  static final _id_setVrThread =
      jniAccessors.getStaticMethodIDOf(_classRef, "setVrThread", "(I)V");

  /// from: static public void setVrThread(int tid)
  ///
  /// Enable more aggressive scheduling for latency-sensitive low-runtime VR threads. Only one
  /// thread can be a VR thread in a process at a time, and that thread may be subject to
  /// restrictions on the amount of time it can run.
  ///
  /// If persistent VR mode is set, whatever thread has been granted aggressive scheduling via this
  /// method will return to normal operation, and calling this method will do nothing while
  /// persistent VR mode is enabled.
  ///
  /// To reset the VR thread for an application, a tid of 0 can be passed.
  ///@see android.os.Process\#myTid()
  ///@param tid tid of the VR thread
  static void setVrThread(int tid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_setVrThread, jni.JniType.voidType, [tid]).check();
}

/// from: android.app.ActivityManager$TaskDescription
///
/// Information you can set and retrieve about the current activity within the recent task list.
class ActivityManager_TaskDescription extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActivityManager\$TaskDescription");
  ActivityManager_TaskDescription.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.TaskDescription> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Landroid/graphics/Bitmap;I)V");

  /// from: public void <init>(java.lang.String label, android.graphics.Bitmap icon, int colorPrimary)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this task.
  ///@param icon An icon that represents the current state of this task.
  ///@param colorPrimary A color to override the theme's primary color.  This color must be
  ///                     opaque.
  ///@deprecated use TaskDescription constructor with icon resource instead
  ActivityManager_TaskDescription(
      jni.JniString label, bitmap_.Bitmap icon, int colorPrimary)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [label.reference, icon.reference, colorPrimary]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;II)V");

  /// from: public void <init>(java.lang.String label, int iconRes, int colorPrimary)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this task.
  ///@param iconRes A drawable resource of an icon that represents the current state of this
  ///                activity.
  ///@param colorPrimary A color to override the theme's primary color.  This color must be
  ///                     opaque.
  ActivityManager_TaskDescription.ctor1(
      jni.JniString label, int iconRes, int colorPrimary)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [label.reference, iconRes, colorPrimary]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Landroid/graphics/Bitmap;)V");

  /// from: public void <init>(java.lang.String label, android.graphics.Bitmap icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ///@param icon An icon that represents the current state of this activity.
  ///@deprecated use TaskDescription constructor with icon resource instead
  ActivityManager_TaskDescription.ctor2(
      jni.JniString label, bitmap_.Bitmap icon)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [label.reference, icon.reference]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;I)V");

  /// from: public void <init>(java.lang.String label, int iconRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ///@param iconRes A drawable resource of an icon that represents the current state of this
  ///                activity.
  ActivityManager_TaskDescription.ctor3(jni.JniString label, int iconRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [label.reference, iconRes]).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ActivityManager_TaskDescription.ctor4(jni.JniString label)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor4, [label.reference]).object);

  static final _id_ctor5 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an empty TaskDescription.
  ActivityManager_TaskDescription.ctor5()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor5, []).object);

  static final _id_ctor6 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/app/ActivityManager\$TaskDescription;)V");

  /// from: public void <init>(android.app.ActivityManager.TaskDescription td)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a copy of another TaskDescription.
  ActivityManager_TaskDescription.ctor6(ActivityManager_TaskDescription td)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor6, [td.reference]).object);

  static final _id_getLabel =
      jniAccessors.getMethodIDOf(_classRef, "getLabel", "()Ljava/lang/String;");

  /// from: public java.lang.String getLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The label and description of the current state of this task.
  jni.JniString getLabel() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLabel, jni.JniType.objectType, []).object);

  static final _id_getIcon = jniAccessors.getMethodIDOf(
      _classRef, "getIcon", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The icon that represents the current state of this task.
  bitmap_.Bitmap getIcon() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIcon, jni.JniType.objectType, []).object);

  static final _id_getPrimaryColor =
      jniAccessors.getMethodIDOf(_classRef, "getPrimaryColor", "()I");

  /// from: public int getPrimaryColor()
  ///
  /// @return The color override on the theme's primary color.
  int getPrimaryColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getPrimaryColor, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.app.ActivityManager$RunningTaskInfo
///
/// Information you can retrieve about a particular task that is currently
/// "running" in the system.  Note that a running task does not mean the
/// given task actually has a process it is actively running in; it simply
/// means that the user has gone to it and never closed it, but currently
/// the system may have killed its process and is only holding on to its
/// last state in order to restart it when the user returns.
class ActivityManager_RunningTaskInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActivityManager\$RunningTaskInfo");
  ActivityManager_RunningTaskInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningTaskInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_baseActivity = jniAccessors.getFieldIDOf(
      _classRef, "baseActivity", "Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName baseActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The component launched as the first activity in the task.  This can
  /// be considered the "application" of this task.
  componentname_.ComponentName get baseActivity =>
      componentname_.ComponentName.fromRef(jniAccessors
          .getField(reference, _id_baseActivity, jni.JniType.objectType)
          .object);

  /// from: public android.content.ComponentName baseActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The component launched as the first activity in the task.  This can
  /// be considered the "application" of this task.
  set baseActivity(componentname_.ComponentName value) =>
      jniEnv.SetObjectField(reference, _id_baseActivity, value.reference);

  static final _id_description = jniAccessors.getFieldIDOf(
      _classRef, "description", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence description
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the task's current state.
  jni.JniObject get description => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_description, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence description
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the task's current state.
  set description(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_description, value.reference);

  static final _id_id = jniAccessors.getFieldIDOf(_classRef, "id", "I");

  /// from: public int id
  ///
  /// A unique identifier for this task.
  int get id =>
      jniAccessors.getField(reference, _id_id, jni.JniType.intType).integer;

  /// from: public int id
  ///
  /// A unique identifier for this task.
  set id(int value) => jniEnv.SetIntField(reference, _id_id, value);

  static final _id_numActivities =
      jniAccessors.getFieldIDOf(_classRef, "numActivities", "I");

  /// from: public int numActivities
  ///
  /// Number of activities in this task.
  int get numActivities => jniAccessors
      .getField(reference, _id_numActivities, jni.JniType.intType)
      .integer;

  /// from: public int numActivities
  ///
  /// Number of activities in this task.
  set numActivities(int value) =>
      jniEnv.SetIntField(reference, _id_numActivities, value);

  static final _id_numRunning =
      jniAccessors.getFieldIDOf(_classRef, "numRunning", "I");

  /// from: public int numRunning
  ///
  /// Number of activities that are currently running (not stopped
  /// and persisted) in this task.
  int get numRunning => jniAccessors
      .getField(reference, _id_numRunning, jni.JniType.intType)
      .integer;

  /// from: public int numRunning
  ///
  /// Number of activities that are currently running (not stopped
  /// and persisted) in this task.
  set numRunning(int value) =>
      jniEnv.SetIntField(reference, _id_numRunning, value);

  static final _id_thumbnail = jniAccessors.getFieldIDOf(
      _classRef, "thumbnail", "Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap thumbnail
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Thumbnail representation of the task's current state.  Currently
  /// always null.
  bitmap_.Bitmap get thumbnail => bitmap_.Bitmap.fromRef(jniAccessors
      .getField(reference, _id_thumbnail, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.Bitmap thumbnail
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Thumbnail representation of the task's current state.  Currently
  /// always null.
  set thumbnail(bitmap_.Bitmap value) =>
      jniEnv.SetObjectField(reference, _id_thumbnail, value.reference);

  static final _id_topActivity = jniAccessors.getFieldIDOf(
      _classRef, "topActivity", "Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName topActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  componentname_.ComponentName get topActivity =>
      componentname_.ComponentName.fromRef(jniAccessors
          .getField(reference, _id_topActivity, jni.JniType.objectType)
          .object);

  /// from: public android.content.ComponentName topActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  set topActivity(componentname_.ComponentName value) =>
      jniEnv.SetObjectField(reference, _id_topActivity, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager_RunningTaskInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();
}

/// from: android.app.ActivityManager$RunningServiceInfo
///
/// Information you can retrieve about a particular Service that is
/// currently running in the system.
class ActivityManager_RunningServiceInfo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/ActivityManager\$RunningServiceInfo");
  ActivityManager_RunningServiceInfo.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningServiceInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int FLAG_FOREGROUND
  ///
  /// Bit for \#flags: set if the service has asked to
  /// run as a foreground process.
  static const FLAG_FOREGROUND = 2;

  /// from: static public final int FLAG_PERSISTENT_PROCESS
  ///
  /// Bit for \#flags: set if the service is running in a
  /// persistent process.
  static const FLAG_PERSISTENT_PROCESS = 8;

  /// from: static public final int FLAG_STARTED
  ///
  /// Bit for \#flags: set if this service has been
  /// explicitly started.
  static const FLAG_STARTED = 1;

  /// from: static public final int FLAG_SYSTEM_PROCESS
  ///
  /// Bit for \#flags: set if the service is running in a
  /// core system process.
  static const FLAG_SYSTEM_PROCESS = 4;

  static final _id_activeSince =
      jniAccessors.getFieldIDOf(_classRef, "activeSince", "J");

  /// from: public long activeSince
  ///
  /// The time when the service was first made active, either by someone
  /// starting or binding to it.  This
  /// is in units of android.os.SystemClock\#elapsedRealtime().
  int get activeSince => jniAccessors
      .getField(reference, _id_activeSince, jni.JniType.longType)
      .long;

  /// from: public long activeSince
  ///
  /// The time when the service was first made active, either by someone
  /// starting or binding to it.  This
  /// is in units of android.os.SystemClock\#elapsedRealtime().
  set activeSince(int value) =>
      jniEnv.SetLongField(reference, _id_activeSince, value);

  static final _id_clientCount =
      jniAccessors.getFieldIDOf(_classRef, "clientCount", "I");

  /// from: public int clientCount
  ///
  /// Number of clients connected to the service.
  int get clientCount => jniAccessors
      .getField(reference, _id_clientCount, jni.JniType.intType)
      .integer;

  /// from: public int clientCount
  ///
  /// Number of clients connected to the service.
  set clientCount(int value) =>
      jniEnv.SetIntField(reference, _id_clientCount, value);

  static final _id_clientLabel =
      jniAccessors.getFieldIDOf(_classRef, "clientLabel", "I");

  /// from: public int clientLabel
  ///
  /// For special services that are bound to by system code, this is
  /// a string resource providing a user-visible label for who the
  /// client is.
  int get clientLabel => jniAccessors
      .getField(reference, _id_clientLabel, jni.JniType.intType)
      .integer;

  /// from: public int clientLabel
  ///
  /// For special services that are bound to by system code, this is
  /// a string resource providing a user-visible label for who the
  /// client is.
  set clientLabel(int value) =>
      jniEnv.SetIntField(reference, _id_clientLabel, value);

  static final _id_clientPackage = jniAccessors.getFieldIDOf(
      _classRef, "clientPackage", "Ljava/lang/String;");

  /// from: public java.lang.String clientPackage
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For special services that are bound to by system code, this is
  /// the package that holds the binding.
  jni.JniString get clientPackage => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_clientPackage, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String clientPackage
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For special services that are bound to by system code, this is
  /// the package that holds the binding.
  set clientPackage(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_clientPackage, value.reference);

  static final _id_crashCount =
      jniAccessors.getFieldIDOf(_classRef, "crashCount", "I");

  /// from: public int crashCount
  ///
  /// Number of times the service's process has crashed while the service
  /// is running.
  int get crashCount => jniAccessors
      .getField(reference, _id_crashCount, jni.JniType.intType)
      .integer;

  /// from: public int crashCount
  ///
  /// Number of times the service's process has crashed while the service
  /// is running.
  set crashCount(int value) =>
      jniEnv.SetIntField(reference, _id_crashCount, value);

  static final _id_flags = jniAccessors.getFieldIDOf(_classRef, "flags", "I");

  /// from: public int flags
  ///
  /// Running flags.
  int get flags =>
      jniAccessors.getField(reference, _id_flags, jni.JniType.intType).integer;

  /// from: public int flags
  ///
  /// Running flags.
  set flags(int value) => jniEnv.SetIntField(reference, _id_flags, value);

  static final _id_foreground =
      jniAccessors.getFieldIDOf(_classRef, "foreground", "Z");

  /// from: public boolean foreground
  ///
  /// Set to true if the service has asked to run as a foreground process.
  bool get foreground => jniAccessors
      .getField(reference, _id_foreground, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean foreground
  ///
  /// Set to true if the service has asked to run as a foreground process.
  set foreground(bool value) =>
      jniEnv.SetBooleanField(reference, _id_foreground, value ? 1 : 0);

  static final _id_lastActivityTime =
      jniAccessors.getFieldIDOf(_classRef, "lastActivityTime", "J");

  /// from: public long lastActivityTime
  ///
  /// The time when there was last activity in the service (either
  /// explicit requests to start it or clients binding to it).  This
  /// is in units of android.os.SystemClock\#uptimeMillis().
  int get lastActivityTime => jniAccessors
      .getField(reference, _id_lastActivityTime, jni.JniType.longType)
      .long;

  /// from: public long lastActivityTime
  ///
  /// The time when there was last activity in the service (either
  /// explicit requests to start it or clients binding to it).  This
  /// is in units of android.os.SystemClock\#uptimeMillis().
  set lastActivityTime(int value) =>
      jniEnv.SetLongField(reference, _id_lastActivityTime, value);

  static final _id_pid = jniAccessors.getFieldIDOf(_classRef, "pid", "I");

  /// from: public int pid
  ///
  /// If non-zero, this is the process the service is running in.
  int get pid =>
      jniAccessors.getField(reference, _id_pid, jni.JniType.intType).integer;

  /// from: public int pid
  ///
  /// If non-zero, this is the process the service is running in.
  set pid(int value) => jniEnv.SetIntField(reference, _id_pid, value);

  static final _id_process =
      jniAccessors.getFieldIDOf(_classRef, "process", "Ljava/lang/String;");

  /// from: public java.lang.String process
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process this service runs in.
  jni.JniString get process => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_process, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String process
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process this service runs in.
  set process(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_process, value.reference);

  static final _id_restarting =
      jniAccessors.getFieldIDOf(_classRef, "restarting", "J");

  /// from: public long restarting
  ///
  /// If non-zero, this service is not currently running, but scheduled to
  /// restart at the given time.
  int get restarting => jniAccessors
      .getField(reference, _id_restarting, jni.JniType.longType)
      .long;

  /// from: public long restarting
  ///
  /// If non-zero, this service is not currently running, but scheduled to
  /// restart at the given time.
  set restarting(int value) =>
      jniEnv.SetLongField(reference, _id_restarting, value);

  static final _id_service = jniAccessors.getFieldIDOf(
      _classRef, "service", "Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName service
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The service component.
  componentname_.ComponentName get service =>
      componentname_.ComponentName.fromRef(jniAccessors
          .getField(reference, _id_service, jni.JniType.objectType)
          .object);

  /// from: public android.content.ComponentName service
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The service component.
  set service(componentname_.ComponentName value) =>
      jniEnv.SetObjectField(reference, _id_service, value.reference);

  static final _id_started =
      jniAccessors.getFieldIDOf(_classRef, "started", "Z");

  /// from: public boolean started
  ///
  /// Set to true if this service has been explicitly started.
  bool get started => jniAccessors
      .getField(reference, _id_started, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean started
  ///
  /// Set to true if this service has been explicitly started.
  set started(bool value) =>
      jniEnv.SetBooleanField(reference, _id_started, value ? 1 : 0);

  static final _id_uid = jniAccessors.getFieldIDOf(_classRef, "uid", "I");

  /// from: public int uid
  ///
  /// The UID that owns this service.
  int get uid =>
      jniAccessors.getField(reference, _id_uid, jni.JniType.intType).integer;

  /// from: public int uid
  ///
  /// The UID that owns this service.
  set uid(int value) => jniEnv.SetIntField(reference, _id_uid, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager_RunningServiceInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();
}

/// from: android.app.ActivityManager$RunningAppProcessInfo
///
/// Information you can retrieve about a running process.
class ActivityManager_RunningAppProcessInfo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/ActivityManager\$RunningAppProcessInfo");
  ActivityManager_RunningAppProcessInfo.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningAppProcessInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int IMPORTANCE_BACKGROUND
  ///
  /// @deprecated Renamed to \#IMPORTANCE_CACHED.
  static const IMPORTANCE_BACKGROUND = 400;

  /// from: static public final int IMPORTANCE_CACHED
  ///
  /// Constant for \#importance: This process process contains
  /// cached code that is expendable, not actively running any app components
  /// we care about.
  static const IMPORTANCE_CACHED = 400;

  /// from: static public final int IMPORTANCE_CANT_SAVE_STATE
  ///
  /// Constant for \#importance: This process is running an
  /// application that can not save its state, and thus can't be killed
  /// while in the background.  This will be used with apps that have
  /// android.R.attr\#cantSaveState set on their application tag.
  static const IMPORTANCE_CANT_SAVE_STATE = 350;

  /// from: static public final int IMPORTANCE_EMPTY
  ///
  /// Constant for \#importance: This process is empty of any
  /// actively running code.
  ///@deprecated This value is no longer reported, use \#IMPORTANCE_CACHED instead.
  static const IMPORTANCE_EMPTY = 500;

  /// from: static public final int IMPORTANCE_FOREGROUND
  ///
  /// Constant for \#importance: This process is running the
  /// foreground UI; that is, it is the thing currently at the top of the screen
  /// that the user is interacting with.
  static const IMPORTANCE_FOREGROUND = 100;

  /// from: static public final int IMPORTANCE_FOREGROUND_SERVICE
  ///
  /// Constant for \#importance: This process is running a foreground
  /// service, for example to perform music playback even while the user is
  /// not immediately in the app.  This generally indicates that the process
  /// is doing something the user actively cares about.
  static const IMPORTANCE_FOREGROUND_SERVICE = 125;

  /// from: static public final int IMPORTANCE_GONE
  ///
  /// Constant for \#importance: This process does not exist.
  static const IMPORTANCE_GONE = 1000;

  /// from: static public final int IMPORTANCE_PERCEPTIBLE
  ///
  /// Constant for \#importance: This process is not something the user
  /// is directly aware of, but is otherwise perceptible to them to some degree.
  static const IMPORTANCE_PERCEPTIBLE = 230;

  /// from: static public final int IMPORTANCE_PERCEPTIBLE_PRE_26
  ///
  /// Constant for \#importance: \#IMPORTANCE_PERCEPTIBLE had this wrong value
  /// before Build.VERSION_CODES\#O.  Since the Build.VERSION_CODES\#O SDK,
  /// the value of \#IMPORTANCE_PERCEPTIBLE has been fixed.
  ///
  /// The system will return this value instead of \#IMPORTANCE_PERCEPTIBLE
  /// on Android versions below Build.VERSION_CODES\#O.
  ///
  /// On Android version Build.VERSION_CODES\#O and later, this value will still be
  /// returned for apps with the target API level below Build.VERSION_CODES\#O.
  /// For apps targeting version Build.VERSION_CODES\#O and later,
  /// the correct value \#IMPORTANCE_PERCEPTIBLE will be returned.
  static const IMPORTANCE_PERCEPTIBLE_PRE_26 = 130;

  /// from: static public final int IMPORTANCE_SERVICE
  ///
  /// Constant for \#importance: This process is contains services
  /// that should remain running.  These are background services apps have
  /// started, not something the user is aware of, so they may be killed by
  /// the system relatively freely (though it is generally desired that they
  /// stay running as long as they want to).
  static const IMPORTANCE_SERVICE = 300;

  /// from: static public final int IMPORTANCE_TOP_SLEEPING
  ///
  /// Constant for \#importance: This process is running the foreground
  /// UI, but the device is asleep so it is not visible to the user.  Though the
  /// system will try hard to keep its process from being killed, in all other
  /// ways we consider it a kind of cached process, with the limitations that go
  /// along with that state: network access, running background services, etc.
  static const IMPORTANCE_TOP_SLEEPING = 325;

  /// from: static public final int IMPORTANCE_TOP_SLEEPING_PRE_28
  ///
  /// @deprecated Pre-android.os.Build.VERSION_CODES\#P version of
  /// \#IMPORTANCE_TOP_SLEEPING.  As of Android
  /// android.os.Build.VERSION_CODES\#P, this is considered much less
  /// important since we want to reduce what apps can do when the screen is off.
  static const IMPORTANCE_TOP_SLEEPING_PRE_28 = 150;

  /// from: static public final int IMPORTANCE_VISIBLE
  ///
  /// Constant for \#importance: This process is running something
  /// that is actively visible to the user, though not in the immediate
  /// foreground.  This may be running a window that is behind the current
  /// foreground (so paused and with its state saved, not interacting with
  /// the user, but visible to them to some degree); it may also be running
  /// other services under the system's control that it inconsiders important.
  static const IMPORTANCE_VISIBLE = 200;

  /// from: static public final int REASON_PROVIDER_IN_USE
  ///
  /// Constant for \#importanceReasonCode: one of the application's
  /// content providers is being used by another process.  The pid of
  /// the client process is in \#importanceReasonPid and the
  /// target provider in this process is in
  /// \#importanceReasonComponent.
  static const REASON_PROVIDER_IN_USE = 1;

  /// from: static public final int REASON_SERVICE_IN_USE
  ///
  /// Constant for \#importanceReasonCode: one of the application's
  /// content providers is being used by another process.  The pid of
  /// the client process is in \#importanceReasonPid and the
  /// target provider in this process is in
  /// \#importanceReasonComponent.
  static const REASON_SERVICE_IN_USE = 2;

  /// from: static public final int REASON_UNKNOWN
  ///
  /// Constant for \#importanceReasonCode: nothing special has
  /// been specified for the reason for this level.
  static const REASON_UNKNOWN = 0;

  static final _id_importance =
      jniAccessors.getFieldIDOf(_classRef, "importance", "I");

  /// from: public int importance
  ///
  /// The relative importance level that the system places on this process.
  /// These constants are numbered so that "more important" values are
  /// always smaller than "less important" values.
  ///
  /// Value is android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_TOP_SLEEPING, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_VISIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_PERCEPTIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CANT_SAVE_STATE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CACHED, or android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_GONE
  int get importance => jniAccessors
      .getField(reference, _id_importance, jni.JniType.intType)
      .integer;

  /// from: public int importance
  ///
  /// The relative importance level that the system places on this process.
  /// These constants are numbered so that "more important" values are
  /// always smaller than "less important" values.
  ///
  /// Value is android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_TOP_SLEEPING, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_VISIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_PERCEPTIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CANT_SAVE_STATE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CACHED, or android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_GONE
  set importance(int value) =>
      jniEnv.SetIntField(reference, _id_importance, value);

  static final _id_importanceReasonCode =
      jniAccessors.getFieldIDOf(_classRef, "importanceReasonCode", "I");

  /// from: public int importanceReasonCode
  ///
  /// The reason for \#importance, if any.
  int get importanceReasonCode => jniAccessors
      .getField(reference, _id_importanceReasonCode, jni.JniType.intType)
      .integer;

  /// from: public int importanceReasonCode
  ///
  /// The reason for \#importance, if any.
  set importanceReasonCode(int value) =>
      jniEnv.SetIntField(reference, _id_importanceReasonCode, value);

  static final _id_importanceReasonComponent = jniAccessors.getFieldIDOf(
      _classRef,
      "importanceReasonComponent",
      "Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName importanceReasonComponent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For the specified values of \#importanceReasonCode, this
  /// is the name of the component that is being used in this process.
  componentname_.ComponentName get importanceReasonComponent =>
      componentname_.ComponentName.fromRef(jniAccessors
          .getField(
              reference, _id_importanceReasonComponent, jni.JniType.objectType)
          .object);

  /// from: public android.content.ComponentName importanceReasonComponent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For the specified values of \#importanceReasonCode, this
  /// is the name of the component that is being used in this process.
  set importanceReasonComponent(componentname_.ComponentName value) =>
      jniEnv.SetObjectField(
          reference, _id_importanceReasonComponent, value.reference);

  static final _id_importanceReasonPid =
      jniAccessors.getFieldIDOf(_classRef, "importanceReasonPid", "I");

  /// from: public int importanceReasonPid
  ///
  /// For the specified values of \#importanceReasonCode, this
  /// is the process ID of the other process that is a client of this
  /// process.  This will be 0 if no other process is using this one.
  int get importanceReasonPid => jniAccessors
      .getField(reference, _id_importanceReasonPid, jni.JniType.intType)
      .integer;

  /// from: public int importanceReasonPid
  ///
  /// For the specified values of \#importanceReasonCode, this
  /// is the process ID of the other process that is a client of this
  /// process.  This will be 0 if no other process is using this one.
  set importanceReasonPid(int value) =>
      jniEnv.SetIntField(reference, _id_importanceReasonPid, value);

  static final _id_lastTrimLevel =
      jniAccessors.getFieldIDOf(_classRef, "lastTrimLevel", "I");

  /// from: public int lastTrimLevel
  ///
  /// Last memory trim level reported to the process: corresponds to
  /// the values supplied to android.content.ComponentCallbacks2\#onTrimMemory(int) ComponentCallbacks2.onTrimMemory(int).
  int get lastTrimLevel => jniAccessors
      .getField(reference, _id_lastTrimLevel, jni.JniType.intType)
      .integer;

  /// from: public int lastTrimLevel
  ///
  /// Last memory trim level reported to the process: corresponds to
  /// the values supplied to android.content.ComponentCallbacks2\#onTrimMemory(int) ComponentCallbacks2.onTrimMemory(int).
  set lastTrimLevel(int value) =>
      jniEnv.SetIntField(reference, _id_lastTrimLevel, value);

  static final _id_lru = jniAccessors.getFieldIDOf(_classRef, "lru", "I");

  /// from: public int lru
  ///
  /// An additional ordering within a particular \#importance
  /// category, providing finer-grained information about the relative
  /// utility of processes within a category.  This number means nothing
  /// except that a smaller values are more recently used (and thus
  /// more important).  Currently an LRU value is only maintained for
  /// the \#IMPORTANCE_CACHED category, though others may
  /// be maintained in the future.
  int get lru =>
      jniAccessors.getField(reference, _id_lru, jni.JniType.intType).integer;

  /// from: public int lru
  ///
  /// An additional ordering within a particular \#importance
  /// category, providing finer-grained information about the relative
  /// utility of processes within a category.  This number means nothing
  /// except that a smaller values are more recently used (and thus
  /// more important).  Currently an LRU value is only maintained for
  /// the \#IMPORTANCE_CACHED category, though others may
  /// be maintained in the future.
  set lru(int value) => jniEnv.SetIntField(reference, _id_lru, value);

  static final _id_pid = jniAccessors.getFieldIDOf(_classRef, "pid", "I");

  /// from: public int pid
  ///
  /// The pid of this process; 0 if none
  int get pid =>
      jniAccessors.getField(reference, _id_pid, jni.JniType.intType).integer;

  /// from: public int pid
  ///
  /// The pid of this process; 0 if none
  set pid(int value) => jniEnv.SetIntField(reference, _id_pid, value);

  static final _id_pkgList =
      jniAccessors.getFieldIDOf(_classRef, "pkgList", "[Ljava/lang/String;");

  /// from: public java.lang.String[] pkgList
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// All packages that have been loaded into the process.
  jni.JniObject get pkgList => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_pkgList, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String[] pkgList
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// All packages that have been loaded into the process.
  set pkgList(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_pkgList, value.reference);

  static final _id_processName =
      jniAccessors.getFieldIDOf(_classRef, "processName", "Ljava/lang/String;");

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process that this object is associated with
  jni.JniString get processName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_processName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process that this object is associated with
  set processName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_processName, value.reference);

  static final _id_uid = jniAccessors.getFieldIDOf(_classRef, "uid", "I");

  /// from: public int uid
  ///
  /// The user id of this process.
  int get uid =>
      jniAccessors.getField(reference, _id_uid, jni.JniType.intType).integer;

  /// from: public int uid
  ///
  /// The user id of this process.
  set uid(int value) => jniEnv.SetIntField(reference, _id_uid, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager_RunningAppProcessInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;I[Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String pProcessName, int pPid, java.lang.String[] pArr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager_RunningAppProcessInfo.ctor1(
      jni.JniString pProcessName, int pPid, jni.JniObject pArr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [pProcessName.reference, pPid, pArr.reference]).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();
}

/// from: android.app.ActivityManager$RecentTaskInfo
///
/// Information you can retrieve about tasks that the user has most recently
/// started or visited.
class ActivityManager_RecentTaskInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActivityManager\$RecentTaskInfo");
  ActivityManager_RecentTaskInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RecentTaskInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_affiliatedTaskId =
      jniAccessors.getFieldIDOf(_classRef, "affiliatedTaskId", "I");

  /// from: public int affiliatedTaskId
  ///
  /// Task affiliation for grouping with other tasks.
  int get affiliatedTaskId => jniAccessors
      .getField(reference, _id_affiliatedTaskId, jni.JniType.intType)
      .integer;

  /// from: public int affiliatedTaskId
  ///
  /// Task affiliation for grouping with other tasks.
  set affiliatedTaskId(int value) =>
      jniEnv.SetIntField(reference, _id_affiliatedTaskId, value);

  static final _id_baseActivity = jniAccessors.getFieldIDOf(
      _classRef, "baseActivity", "Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName baseActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The component launched as the first activity in the task.
  /// This can be considered the "application" of this task.
  componentname_.ComponentName get baseActivity =>
      componentname_.ComponentName.fromRef(jniAccessors
          .getField(reference, _id_baseActivity, jni.JniType.objectType)
          .object);

  /// from: public android.content.ComponentName baseActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The component launched as the first activity in the task.
  /// This can be considered the "application" of this task.
  set baseActivity(componentname_.ComponentName value) =>
      jniEnv.SetObjectField(reference, _id_baseActivity, value.reference);

  static final _id_baseIntent = jniAccessors.getFieldIDOf(
      _classRef, "baseIntent", "Landroid/content/Intent;");

  /// from: public android.content.Intent baseIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The original Intent used to launch the task.  You can use this
  /// Intent to re-launch the task (if it is no longer running) or bring
  /// the current task to the front.
  intent_.Intent get baseIntent => intent_.Intent.fromRef(jniAccessors
      .getField(reference, _id_baseIntent, jni.JniType.objectType)
      .object);

  /// from: public android.content.Intent baseIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The original Intent used to launch the task.  You can use this
  /// Intent to re-launch the task (if it is no longer running) or bring
  /// the current task to the front.
  set baseIntent(intent_.Intent value) =>
      jniEnv.SetObjectField(reference, _id_baseIntent, value.reference);

  static final _id_description = jniAccessors.getFieldIDOf(
      _classRef, "description", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence description
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the task's last state.
  jni.JniObject get description => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_description, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence description
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the task's last state.
  set description(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_description, value.reference);

  static final _id_id = jniAccessors.getFieldIDOf(_classRef, "id", "I");

  /// from: public int id
  ///
  /// If this task is currently running, this is the identifier for it.
  /// If it is not running, this will be -1.
  int get id =>
      jniAccessors.getField(reference, _id_id, jni.JniType.intType).integer;

  /// from: public int id
  ///
  /// If this task is currently running, this is the identifier for it.
  /// If it is not running, this will be -1.
  set id(int value) => jniEnv.SetIntField(reference, _id_id, value);

  static final _id_numActivities =
      jniAccessors.getFieldIDOf(_classRef, "numActivities", "I");

  /// from: public int numActivities
  ///
  /// Number of activities in this task.
  int get numActivities => jniAccessors
      .getField(reference, _id_numActivities, jni.JniType.intType)
      .integer;

  /// from: public int numActivities
  ///
  /// Number of activities in this task.
  set numActivities(int value) =>
      jniEnv.SetIntField(reference, _id_numActivities, value);

  static final _id_origActivity = jniAccessors.getFieldIDOf(
      _classRef, "origActivity", "Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName origActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this task was started from an alias, this is the actual
  /// activity component that was initially started; the component of
  /// the baseIntent in this case is the name of the actual activity
  /// implementation that the alias referred to.  Otherwise, this is null.
  componentname_.ComponentName get origActivity =>
      componentname_.ComponentName.fromRef(jniAccessors
          .getField(reference, _id_origActivity, jni.JniType.objectType)
          .object);

  /// from: public android.content.ComponentName origActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this task was started from an alias, this is the actual
  /// activity component that was initially started; the component of
  /// the baseIntent in this case is the name of the actual activity
  /// implementation that the alias referred to.  Otherwise, this is null.
  set origActivity(componentname_.ComponentName value) =>
      jniEnv.SetObjectField(reference, _id_origActivity, value.reference);

  static final _id_persistentId =
      jniAccessors.getFieldIDOf(_classRef, "persistentId", "I");

  /// from: public int persistentId
  ///
  /// The true identifier of this task, valid even if it is not running.
  int get persistentId => jniAccessors
      .getField(reference, _id_persistentId, jni.JniType.intType)
      .integer;

  /// from: public int persistentId
  ///
  /// The true identifier of this task, valid even if it is not running.
  set persistentId(int value) =>
      jniEnv.SetIntField(reference, _id_persistentId, value);

  static final _id_taskDescription = jniAccessors.getFieldIDOf(_classRef,
      "taskDescription", "Landroid/app/ActivityManager\$TaskDescription;");

  /// from: public android.app.ActivityManager.TaskDescription taskDescription
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The recent activity values for the highest activity in the stack to have set the values.
  /// Activity\#setTaskDescription(android.app.ActivityManager.TaskDescription).
  ActivityManager_TaskDescription get taskDescription =>
      ActivityManager_TaskDescription.fromRef(jniAccessors
          .getField(reference, _id_taskDescription, jni.JniType.objectType)
          .object);

  /// from: public android.app.ActivityManager.TaskDescription taskDescription
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The recent activity values for the highest activity in the stack to have set the values.
  /// Activity\#setTaskDescription(android.app.ActivityManager.TaskDescription).
  set taskDescription(ActivityManager_TaskDescription value) =>
      jniEnv.SetObjectField(reference, _id_taskDescription, value.reference);

  static final _id_topActivity = jniAccessors.getFieldIDOf(
      _classRef, "topActivity", "Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName topActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  componentname_.ComponentName get topActivity =>
      componentname_.ComponentName.fromRef(jniAccessors
          .getField(reference, _id_topActivity, jni.JniType.objectType)
          .object);

  /// from: public android.content.ComponentName topActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  set topActivity(componentname_.ComponentName value) =>
      jniEnv.SetObjectField(reference, _id_topActivity, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager_RecentTaskInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();
}

/// from: android.app.ActivityManager$ProcessErrorStateInfo
///
/// Information you can retrieve about any processes that are in an error condition.
class ActivityManager_ProcessErrorStateInfo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/ActivityManager\$ProcessErrorStateInfo");
  ActivityManager_ProcessErrorStateInfo.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int CRASHED
  static const CRASHED = 1;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.ProcessErrorStateInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int NOT_RESPONDING
  static const NOT_RESPONDING = 2;

  /// from: static public final int NO_ERROR
  ///
  /// Condition codes
  static const NO_ERROR = 0;

  static final _id_condition =
      jniAccessors.getFieldIDOf(_classRef, "condition", "I");

  /// from: public int condition
  ///
  /// The condition that the process is in.
  int get condition => jniAccessors
      .getField(reference, _id_condition, jni.JniType.intType)
      .integer;

  /// from: public int condition
  ///
  /// The condition that the process is in.
  set condition(int value) =>
      jniEnv.SetIntField(reference, _id_condition, value);

  static final _id_crashData =
      jniAccessors.getFieldIDOf(_classRef, "crashData", "[B");

  /// from: public byte[] crashData
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// to be deprecated: This value will always be null.
  jni.JniObject get crashData => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_crashData, jni.JniType.objectType)
      .object);

  /// from: public byte[] crashData
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// to be deprecated: This value will always be null.
  set crashData(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_crashData, value.reference);

  static final _id_longMsg =
      jniAccessors.getFieldIDOf(_classRef, "longMsg", "Ljava/lang/String;");

  /// from: public java.lang.String longMsg
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A long message describing the error condition.
  jni.JniString get longMsg => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_longMsg, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String longMsg
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A long message describing the error condition.
  set longMsg(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_longMsg, value.reference);

  static final _id_pid = jniAccessors.getFieldIDOf(_classRef, "pid", "I");

  /// from: public int pid
  ///
  /// The pid of this process; 0 if none
  int get pid =>
      jniAccessors.getField(reference, _id_pid, jni.JniType.intType).integer;

  /// from: public int pid
  ///
  /// The pid of this process; 0 if none
  set pid(int value) => jniEnv.SetIntField(reference, _id_pid, value);

  static final _id_processName =
      jniAccessors.getFieldIDOf(_classRef, "processName", "Ljava/lang/String;");

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The process name in which the crash or error occurred.
  jni.JniString get processName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_processName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The process name in which the crash or error occurred.
  set processName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_processName, value.reference);

  static final _id_shortMsg =
      jniAccessors.getFieldIDOf(_classRef, "shortMsg", "Ljava/lang/String;");

  /// from: public java.lang.String shortMsg
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A short message describing the error condition.
  jni.JniString get shortMsg => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_shortMsg, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String shortMsg
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A short message describing the error condition.
  set shortMsg(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_shortMsg, value.reference);

  static final _id_stackTrace =
      jniAccessors.getFieldIDOf(_classRef, "stackTrace", "Ljava/lang/String;");

  /// from: public java.lang.String stackTrace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The stack trace where the error originated.  May be null.
  jni.JniString get stackTrace => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_stackTrace, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String stackTrace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The stack trace where the error originated.  May be null.
  set stackTrace(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_stackTrace, value.reference);

  static final _id_tag =
      jniAccessors.getFieldIDOf(_classRef, "tag", "Ljava/lang/String;");

  /// from: public java.lang.String tag
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity name associated with the error, if known.  May be null.
  jni.JniString get tag => jni.JniString.fromRef(
      jniAccessors.getField(reference, _id_tag, jni.JniType.objectType).object);

  /// from: public java.lang.String tag
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity name associated with the error, if known.  May be null.
  set tag(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_tag, value.reference);

  static final _id_uid = jniAccessors.getFieldIDOf(_classRef, "uid", "I");

  /// from: public int uid
  ///
  /// The kernel user-ID that has been assigned to this process;
  /// currently this is not a unique ID (multiple applications can have
  /// the same uid).
  int get uid =>
      jniAccessors.getField(reference, _id_uid, jni.JniType.intType).integer;

  /// from: public int uid
  ///
  /// The kernel user-ID that has been assigned to this process;
  /// currently this is not a unique ID (multiple applications can have
  /// the same uid).
  set uid(int value) => jniEnv.SetIntField(reference, _id_uid, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager_ProcessErrorStateInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();
}

/// from: android.app.ActivityManager$MemoryInfo
///
/// Information you can retrieve about the available memory through
/// ActivityManager\#getMemoryInfo.
class ActivityManager_MemoryInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActivityManager\$MemoryInfo");
  ActivityManager_MemoryInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.MemoryInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_availMem =
      jniAccessors.getFieldIDOf(_classRef, "availMem", "J");

  /// from: public long availMem
  ///
  /// The available memory on the system.  This number should not
  /// be considered absolute: due to the nature of the kernel, a significant
  /// portion of this memory is actually in use and needed for the overall
  /// system to run well.
  int get availMem =>
      jniAccessors.getField(reference, _id_availMem, jni.JniType.longType).long;

  /// from: public long availMem
  ///
  /// The available memory on the system.  This number should not
  /// be considered absolute: due to the nature of the kernel, a significant
  /// portion of this memory is actually in use and needed for the overall
  /// system to run well.
  set availMem(int value) =>
      jniEnv.SetLongField(reference, _id_availMem, value);

  static final _id_lowMemory =
      jniAccessors.getFieldIDOf(_classRef, "lowMemory", "Z");

  /// from: public boolean lowMemory
  ///
  /// Set to true if the system considers itself to currently be in a low
  /// memory situation.
  bool get lowMemory => jniAccessors
      .getField(reference, _id_lowMemory, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean lowMemory
  ///
  /// Set to true if the system considers itself to currently be in a low
  /// memory situation.
  set lowMemory(bool value) =>
      jniEnv.SetBooleanField(reference, _id_lowMemory, value ? 1 : 0);

  static final _id_threshold =
      jniAccessors.getFieldIDOf(_classRef, "threshold", "J");

  /// from: public long threshold
  ///
  /// The threshold of \#availMem at which we consider memory to be
  /// low and start killing background services and other non-extraneous
  /// processes.
  int get threshold => jniAccessors
      .getField(reference, _id_threshold, jni.JniType.longType)
      .long;

  /// from: public long threshold
  ///
  /// The threshold of \#availMem at which we consider memory to be
  /// low and start killing background services and other non-extraneous
  /// processes.
  set threshold(int value) =>
      jniEnv.SetLongField(reference, _id_threshold, value);

  static final _id_totalMem =
      jniAccessors.getFieldIDOf(_classRef, "totalMem", "J");

  /// from: public long totalMem
  ///
  /// The total memory accessible by the kernel.  This is basically the
  /// RAM size of the device, not including below-kernel fixed allocations
  /// like DMA buffers, RAM for the baseband CPU, etc.
  int get totalMem =>
      jniAccessors.getField(reference, _id_totalMem, jni.JniType.longType).long;

  /// from: public long totalMem
  ///
  /// The total memory accessible by the kernel.  This is basically the
  /// RAM size of the device, not including below-kernel fixed allocations
  /// like DMA buffers, RAM for the baseband CPU, etc.
  set totalMem(int value) =>
      jniEnv.SetLongField(reference, _id_totalMem, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager_MemoryInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();
}

/// from: android.app.ActivityManager$AppTask
///
/// The AppTask allows you to manage your own application's tasks.
/// See android.app.ActivityManager\#getAppTasks()
class ActivityManager_AppTask extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/ActivityManager\$AppTask");
  ActivityManager_AppTask.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityManager_AppTask()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_finishAndRemoveTask =
      jniAccessors.getMethodIDOf(_classRef, "finishAndRemoveTask", "()V");

  /// from: public void finishAndRemoveTask()
  ///
  /// Finishes all activities in this task and removes it from the recent tasks list.
  void finishAndRemoveTask() => jniAccessors.callMethodWithArgs(
      reference, _id_finishAndRemoveTask, jni.JniType.voidType, []).check();

  static final _id_getTaskInfo = jniAccessors.getMethodIDOf(_classRef,
      "getTaskInfo", "()Landroid/app/ActivityManager\$RecentTaskInfo;");

  /// from: public android.app.ActivityManager.RecentTaskInfo getTaskInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the RecentTaskInfo associated with this task.
  ///@return The RecentTaskInfo for this task, or null if the task no longer exists.
  ActivityManager_RecentTaskInfo getTaskInfo() =>
      ActivityManager_RecentTaskInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTaskInfo, jni.JniType.objectType, []).object);

  static final _id_moveToFront =
      jniAccessors.getMethodIDOf(_classRef, "moveToFront", "()V");

  /// from: public void moveToFront()
  ///
  /// Bring this task to the foreground.  If it contains activities, they will be
  /// brought to the foreground with it and their instances re-created if needed.
  /// If it doesn't contain activities, the root activity of the task will be
  /// re-launched.
  void moveToFront() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToFront, jni.JniType.voidType, []).check();

  static final _id_startActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivity",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/Bundle;)V");

  /// from: public void startActivity(android.content.Context context, android.content.Intent intent, android.os.Bundle options)
  ///
  /// Start an activity in this task.  Brings the task to the foreground.  If this task
  /// is not currently active (that is, its id < 0), then a new activity for the given
  /// Intent will be launched as the root of the task and the task brought to the
  /// foreground.  Otherwise, if this task is currently active and the Intent does not specify
  /// an activity to launch in a new task, then a new activity for the given Intent will
  /// be launched on top of the task and the task brought to the foreground.  If this
  /// task is currently active and the Intent specifies Intent\#FLAG_ACTIVITY_NEW_TASK
  /// or would otherwise be launched in to a new task, then the activity not launched but
  /// this task be brought to the foreground and a new intent delivered to the top
  /// activity if appropriate.
  ///
  /// In other words, you generally want to use an Intent here that does not specify
  /// Intent\#FLAG_ACTIVITY_NEW_TASK or Intent\#FLAG_ACTIVITY_NEW_DOCUMENT,
  /// and let the system do the right thing.
  ///
  ///@param intent The Intent describing the new activity to be launched on the task.
  ///@param options Optional launch options.
  ///@see Activity\#startActivity(android.content.Intent, android.os.Bundle)
  void startActivity(context_.Context context, intent_.Intent intent,
          bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivity,
          jni.JniType.voidType,
          [context.reference, intent.reference, options.reference]).check();

  static final _id_setExcludeFromRecents =
      jniAccessors.getMethodIDOf(_classRef, "setExcludeFromRecents", "(Z)V");

  /// from: public void setExcludeFromRecents(boolean exclude)
  ///
  /// Modify the Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS flag in the root
  /// Intent of this AppTask.
  ///@param exclude If true, Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS will
  /// be set; otherwise, it will be cleared.
  void setExcludeFromRecents(bool exclude) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExcludeFromRecents,
      jni.JniType.voidType,
      [exclude]).check();
}
