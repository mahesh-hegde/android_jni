// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Intent.dart" as intent_;

import "Activity.dart" as activity_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.KeyguardManager
///
/// Class that can be used to lock and unlock the keyboard. The
/// actual class to control the keyboard locking is
/// android.app.KeyguardManager.KeyguardLock.
class KeyguardManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/KeyguardManager");
  KeyguardManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_createConfirmDeviceCredentialIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "createConfirmDeviceCredentialIntent",
      "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Landroid/content/Intent;");

  /// from: public android.content.Intent createConfirmDeviceCredentialIntent(java.lang.CharSequence title, java.lang.CharSequence description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an intent to prompt the user to confirm credentials (pin, pattern or password)
  /// for the current user of the device. The caller is expected to launch this activity using
  /// android.app.Activity\#startActivityForResult(Intent, int) and check for
  /// android.app.Activity\#RESULT_OK if the user successfully completes the challenge.
  ///@return the intent for launching the activity or null if no password is required.
  intent_.Intent createConfirmDeviceCredentialIntent(
          jni.JniObject title, jni.JniObject description) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createConfirmDeviceCredentialIntent,
          jni.JniType.objectType,
          [title.reference, description.reference]).object);

  static final _id_newKeyguardLock = jniAccessors.getMethodIDOf(
      _classRef,
      "newKeyguardLock",
      "(Ljava/lang/String;)Landroid/app/KeyguardManager\$KeyguardLock;");

  /// from: public android.app.KeyguardManager.KeyguardLock newKeyguardLock(java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
  /// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
  /// instead; this allows you to seamlessly hide the keyguard as your application
  /// moves in and out of the foreground and does not require that any special
  /// permissions be requested.
  ///
  /// Enables you to lock or unlock the keyboard. Get an instance of this class by
  /// calling android.content.Context\#getSystemService(java.lang.String) Context.getSystemService().
  /// This class is wrapped by android.app.KeyguardManager KeyguardManager.
  ///@param tag A tag that informally identifies who you are (for debugging who
  ///   is disabling he keyguard).
  ///@return A KeyguardLock handle to use to disable and reenable the
  ///   keyguard.
  KeyguardManager_KeyguardLock newKeyguardLock(jni.JniString tag) =>
      KeyguardManager_KeyguardLock.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_newKeyguardLock,
          jni.JniType.objectType,
          [tag.reference]).object);

  static final _id_isKeyguardLocked =
      jniAccessors.getMethodIDOf(_classRef, "isKeyguardLocked", "()Z");

  /// from: public boolean isKeyguardLocked()
  ///
  /// Return whether the keyguard is currently locked.
  ///@return true if keyguard is locked.
  bool isKeyguardLocked() => jniAccessors.callMethodWithArgs(
      reference, _id_isKeyguardLocked, jni.JniType.booleanType, []).boolean;

  static final _id_isKeyguardSecure =
      jniAccessors.getMethodIDOf(_classRef, "isKeyguardSecure", "()Z");

  /// from: public boolean isKeyguardSecure()
  ///
  /// Return whether the keyguard is secured by a PIN, pattern or password or a SIM card
  /// is currently locked.
  ///
  /// See also \#isDeviceSecure() which ignores SIM locked states.
  ///@return true if a PIN, pattern or password is set or a SIM card is locked.
  bool isKeyguardSecure() => jniAccessors.callMethodWithArgs(
      reference, _id_isKeyguardSecure, jni.JniType.booleanType, []).boolean;

  static final _id_inKeyguardRestrictedInputMode = jniAccessors.getMethodIDOf(
      _classRef, "inKeyguardRestrictedInputMode", "()Z");

  /// from: public boolean inKeyguardRestrictedInputMode()
  ///
  /// @deprecated Use \#isKeyguardLocked() instead.
  ///
  /// If keyguard screen is showing or in restricted key input mode (i.e. in
  /// keyguard password emergency screen). When in such mode, certain keys,
  /// such as the Home key and the right soft keys, don't work.
  ///@return true if in keyguard restricted input mode.
  bool inKeyguardRestrictedInputMode() => jniAccessors.callMethodWithArgs(
      reference,
      _id_inKeyguardRestrictedInputMode,
      jni.JniType.booleanType, []).boolean;

  static final _id_isDeviceLocked =
      jniAccessors.getMethodIDOf(_classRef, "isDeviceLocked", "()Z");

  /// from: public boolean isDeviceLocked()
  ///
  /// Returns whether the device is currently locked and requires a PIN, pattern or
  /// password to unlock.
  ///@return true if unlocking the device currently requires a PIN, pattern or
  /// password.
  bool isDeviceLocked() => jniAccessors.callMethodWithArgs(
      reference, _id_isDeviceLocked, jni.JniType.booleanType, []).boolean;

  static final _id_isDeviceSecure =
      jniAccessors.getMethodIDOf(_classRef, "isDeviceSecure", "()Z");

  /// from: public boolean isDeviceSecure()
  ///
  /// Returns whether the device is secured with a PIN, pattern or
  /// password.
  ///
  /// See also \#isKeyguardSecure which treats SIM locked states as secure.
  ///@return true if a PIN, pattern or password was set.
  bool isDeviceSecure() => jniAccessors.callMethodWithArgs(
      reference, _id_isDeviceSecure, jni.JniType.booleanType, []).boolean;

  static final _id_requestDismissKeyguard = jniAccessors.getMethodIDOf(
      _classRef,
      "requestDismissKeyguard",
      "(Landroid/app/Activity;Landroid/app/KeyguardManager\$KeyguardDismissCallback;)V");

  /// from: public void requestDismissKeyguard(android.app.Activity activity, android.app.KeyguardManager.KeyguardDismissCallback callback)
  ///
  /// If the device is currently locked (see \#isKeyguardLocked(), requests the Keyguard to
  /// be dismissed.
  ///
  /// If the Keyguard is not secure or the device is currently in a trusted state, calling this
  /// method will immediately dismiss the Keyguard without any user interaction.
  ///
  /// If the Keyguard is secure and the device is not in a trusted state, this will bring up the
  /// UI so the user can enter their credentials.
  ///
  /// If the value set for the Activity attr android.R.attr\#turnScreenOn is true,
  /// the screen will turn on when the keyguard is dismissed.
  ///@param activity The activity requesting the dismissal. The activity must be either visible
  ///                 by using LayoutParams\#FLAG_SHOW_WHEN_LOCKED or must be in a state in
  ///                 which it would be visible if Keyguard would not be hiding it. If that's not
  ///                 the case, the request will fail immediately and
  ///                 KeyguardDismissCallback\#onDismissError will be invoked.
  /// This value must never be {@code null}.
  ///@param callback The callback to be called if the request to dismiss Keyguard was successful
  ///                 or {@code null} if the caller isn't interested in knowing the result. The
  ///                 callback will not be invoked if the activity was destroyed before the
  ///                 callback was received.
  ///
  /// This value may be {@code null}.
  void requestDismissKeyguard(activity_.Activity activity,
          KeyguardManager_KeyguardDismissCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestDismissKeyguard,
          jni.JniType.voidType,
          [activity.reference, callback.reference]).check();

  static final _id_exitKeyguardSecurely = jniAccessors.getMethodIDOf(
      _classRef,
      "exitKeyguardSecurely",
      "(Landroid/app/KeyguardManager\$OnKeyguardExitResult;)V");

  /// from: public void exitKeyguardSecurely(android.app.KeyguardManager.OnKeyguardExitResult callback)
  ///
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
  /// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
  /// instead; this allows you to seamlessly hide the keyguard as your application
  /// moves in and out of the foreground and does not require that any special
  /// permissions be requested.
  ///
  /// Exit the keyguard securely.  The use case for this api is that, after
  /// disabling the keyguard, your app, which was granted permission to
  /// disable the keyguard and show a limited amount of information deemed
  /// safe without the user getting past the keyguard, needs to navigate to
  /// something that is not safe to view without getting past the keyguard.
  ///
  /// This will, if the keyguard is secure, bring up the unlock screen of
  /// the keyguard.
  ///@param callback Let's you know whether the operation was succesful and
  ///   it is safe to launch anything that would normally be considered safe
  ///   once the user has gotten past the keyguard.
  void exitKeyguardSecurely(KeyguardManager_OnKeyguardExitResult callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_exitKeyguardSecurely,
          jni.JniType.voidType, [callback.reference]).check();
}

/// from: android.app.KeyguardManager$OnKeyguardExitResult
///
/// @deprecated Use KeyguardDismissCallback
/// Callback passed to KeyguardManager\#exitKeyguardSecurely to notify
/// caller of result.
class KeyguardManager_OnKeyguardExitResult extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/KeyguardManager\$OnKeyguardExitResult");
  KeyguardManager_OnKeyguardExitResult.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onKeyguardExitResult =
      jniAccessors.getMethodIDOf(_classRef, "onKeyguardExitResult", "(Z)V");

  /// from: public abstract void onKeyguardExitResult(boolean success)
  ///
  /// @param success True if the user was able to authenticate, false if
  ///   not.
  void onKeyguardExitResult(bool success) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onKeyguardExitResult,
      jni.JniType.voidType,
      [success]).check();
}

/// from: android.app.KeyguardManager$KeyguardLock
///
/// @deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
/// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
/// instead; this allows you to seamlessly hide the keyguard as your application
/// moves in and out of the foreground and does not require that any special
/// permissions be requested.
///
/// Handle returned by KeyguardManager\#newKeyguardLock that allows
/// you to disable / reenable the keyguard.
class KeyguardManager_KeyguardLock extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/KeyguardManager\$KeyguardLock");
  KeyguardManager_KeyguardLock.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_disableKeyguard =
      jniAccessors.getMethodIDOf(_classRef, "disableKeyguard", "()V");

  /// from: public void disableKeyguard()
  ///
  /// Disable the keyguard from showing.  If the keyguard is currently
  /// showing, hide it.  The keyguard will be prevented from showing again
  /// until \#reenableKeyguard() is called.
  ///
  /// A good place to call this is from android.app.Activity\#onResume()
  ///
  /// Note: This call has no effect while any android.app.admin.DevicePolicyManager
  /// is enabled that requires a password.
  ///
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@see \#reenableKeyguard()
  void disableKeyguard() => jniAccessors.callMethodWithArgs(
      reference, _id_disableKeyguard, jni.JniType.voidType, []).check();

  static final _id_reenableKeyguard =
      jniAccessors.getMethodIDOf(_classRef, "reenableKeyguard", "()V");

  /// from: public void reenableKeyguard()
  ///
  /// Reenable the keyguard.  The keyguard will reappear if the previous
  /// call to \#disableKeyguard() caused it to be hidden.
  ///
  /// A good place to call this is from android.app.Activity\#onPause()
  ///
  /// Note: This call has no effect while any android.app.admin.DevicePolicyManager
  /// is enabled that requires a password.
  ///
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@see \#disableKeyguard()
  void reenableKeyguard() => jniAccessors.callMethodWithArgs(
      reference, _id_reenableKeyguard, jni.JniType.voidType, []).check();
}

/// from: android.app.KeyguardManager$KeyguardDismissCallback
///
/// Callback passed to
/// KeyguardManager\#requestDismissKeyguard(Activity, KeyguardDismissCallback)
/// to notify caller of result.
class KeyguardManager_KeyguardDismissCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/KeyguardManager\$KeyguardDismissCallback");
  KeyguardManager_KeyguardDismissCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  KeyguardManager_KeyguardDismissCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onDismissError =
      jniAccessors.getMethodIDOf(_classRef, "onDismissError", "()V");

  /// from: public void onDismissError()
  ///
  /// Called when dismissing Keyguard is currently not feasible, i.e. when Keyguard is not
  /// available, not showing or when the activity requesting the Keyguard dismissal isn't
  /// showing or isn't showing behind Keyguard.
  void onDismissError() => jniAccessors.callMethodWithArgs(
      reference, _id_onDismissError, jni.JniType.voidType, []).check();

  static final _id_onDismissSucceeded =
      jniAccessors.getMethodIDOf(_classRef, "onDismissSucceeded", "()V");

  /// from: public void onDismissSucceeded()
  ///
  /// Called when dismissing Keyguard has succeeded and the device is now unlocked.
  void onDismissSucceeded() => jniAccessors.callMethodWithArgs(
      reference, _id_onDismissSucceeded, jni.JniType.voidType, []).check();

  static final _id_onDismissCancelled =
      jniAccessors.getMethodIDOf(_classRef, "onDismissCancelled", "()V");

  /// from: public void onDismissCancelled()
  ///
  /// Called when dismissing Keyguard has been cancelled, i.e. when the user cancelled the
  /// operation or the bouncer was hidden for some other reason.
  void onDismissCancelled() => jniAccessors.callMethodWithArgs(
      reference, _id_onDismissCancelled, jni.JniType.voidType, []).check();
}
