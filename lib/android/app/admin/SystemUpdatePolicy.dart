// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.admin.SystemUpdatePolicy
///
/// Determines when over-the-air system updates are installed on a device. Only a device policy
/// controller (DPC) running in device owner mode can set an update policy for the device\u2014by calling
/// the {@code DevicePolicyManager} method
/// DevicePolicyManager\#setSystemUpdatePolicy setSystemUpdatePolicy(). An update
/// policy affects the pending system update (if there is one) and any future updates for the device.
///
/// If a policy is set on a device, the system doesn't notify the user about updates.
///
/// <h3>Example</h3>
///
/// The example below shows how a DPC might set a maintenance window for system updates:
///
/// <pre><code>
/// private final MAINTENANCE_WINDOW_START = 1380; // 11pm
/// private final MAINTENANCE_WINDOW_END = 120; // 2am
///
/// // ...
///
/// // Create the system update policy
/// SystemUpdatePolicy policy = SystemUpdatePolicy.createWindowedInstallPolicy(
///     MAINTENANCE_WINDOW_START, MAINTENANCE_WINDOW_END);
///
/// // Get a DevicePolicyManager instance to set the policy on the device
/// DevicePolicyManager dpm =
///     (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
/// ComponentName adminComponent = getComponentName(context);
/// dpm.setSystemUpdatePolicy(adminComponent, policy);
/// </code></pre>
///
/// <h3>Developer guide</h3>
/// To learn more about managing system updates, read
/// <a href="{@docRoot}/work/dpc/security.html\#control_remote_software_updates">Control remote
/// software updates</a>.
///@see DevicePolicyManager\#setSystemUpdatePolicy
///@see DevicePolicyManager\#getSystemUpdatePolicy
class SystemUpdatePolicy extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/admin/SystemUpdatePolicy");
  SystemUpdatePolicy.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.SystemUpdatePolicy> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int TYPE_INSTALL_AUTOMATIC
  ///
  /// Installs system updates (without user interaction) as soon as they become available. Setting
  /// this policy type immediately installs any pending updates that might be postponed or waiting
  /// for a maintenance window.
  static const TYPE_INSTALL_AUTOMATIC = 1;

  /// from: static public final int TYPE_INSTALL_WINDOWED
  ///
  /// Installs system updates (without user interaction) during a daily maintenance window. Set the
  /// start and end of the daily maintenance window, as minutes of the day, when creating a new
  /// {@code TYPE_INSTALL_WINDOWED} policy. See
  /// \#createWindowedInstallPolicy createWindowedInstallPolicy().
  ///
  /// No connectivity, not enough disk space, or a low battery are typical reasons Android might
  /// not install a system update in the daily maintenance window. After 30 days trying to install
  /// an update in the maintenance window (regardless of policy changes in this period), the system
  /// prompts the device user to install the update.
  static const TYPE_INSTALL_WINDOWED = 2;

  /// from: static public final int TYPE_POSTPONE
  ///
  /// Postpones the installation of system updates for 30 days. After the 30-day period has ended,
  /// the system prompts the device user to install the update.
  ///
  /// The system limits each update to one 30-day postponement. The period begins when the
  /// system first postpones the update and setting new {@code TYPE_POSTPONE} policies won\u2019t extend
  /// the period. If, after 30 days the update isn\u2019t installed (through policy changes), the system
  /// prompts the user to install the update.
  ///
  /// <strong>Note</strong>: Device manufacturers or carriers might choose to exempt important
  /// security updates from a postponement policy. Exempted updates notify the device user when
  /// they become available.
  static const TYPE_POSTPONE = 3;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SystemUpdatePolicy()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_createAutomaticInstallPolicy =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "createAutomaticInstallPolicy",
          "()Landroid/app/admin/SystemUpdatePolicy;");

  /// from: static public android.app.admin.SystemUpdatePolicy createAutomaticInstallPolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a policy object and set it to install update automatically as soon as one is
  /// available.
  ///@see \#TYPE_INSTALL_AUTOMATIC
  static SystemUpdatePolicy createAutomaticInstallPolicy() =>
      SystemUpdatePolicy.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createAutomaticInstallPolicy,
          jni.JniType.objectType, []).object);

  static final _id_createWindowedInstallPolicy =
      jniAccessors.getStaticMethodIDOf(_classRef, "createWindowedInstallPolicy",
          "(II)Landroid/app/admin/SystemUpdatePolicy;");

  /// from: static public android.app.admin.SystemUpdatePolicy createWindowedInstallPolicy(int startTime, int endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a policy object and set it to: new system update will only be installed automatically
  /// when the system clock is inside a daily maintenance window. If the start and end times are
  /// the same, the window is considered to include the <i>whole 24 hours</i>. That is, updates can
  /// install at any time. If start time is later than end time, the window is considered spanning
  /// midnight (i.e. the end time denotes a time on the next day). The maintenance window will last
  /// for 30 days for any given update, after which the window will no longer be effective and
  /// the pending update will be made available for manual installation as if no system update
  /// policy were set on the device. See \#TYPE_INSTALL_WINDOWED for the details of this
  /// policy's behavior.
  ///@param startTime the start of the maintenance window, measured as the number of minutes from
  ///            midnight in the device's local time. Must be in the range of [0, 1440).
  ///@param endTime the end of the maintenance window, measured as the number of minutes from
  ///            midnight in the device's local time. Must be in the range of [0, 1440).
  ///@throws IllegalArgumentException If the {@code startTime} or {@code endTime} isn't in the
  ///            accepted range.
  ///@return The configured policy.
  ///@see \#TYPE_INSTALL_WINDOWED
  static SystemUpdatePolicy createWindowedInstallPolicy(
          int startTime, int endTime) =>
      SystemUpdatePolicy.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createWindowedInstallPolicy,
          jni.JniType.objectType,
          [startTime, endTime]).object);

  static final _id_createPostponeInstallPolicy =
      jniAccessors.getStaticMethodIDOf(_classRef, "createPostponeInstallPolicy",
          "()Landroid/app/admin/SystemUpdatePolicy;");

  /// from: static public android.app.admin.SystemUpdatePolicy createPostponeInstallPolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a policy object and set it to block installation for a maximum period of 30 days.
  /// To learn more about this policy's behavior, see \#TYPE_POSTPONE.
  ///
  /// __Note: __ security updates (e.g. monthly security patches) will <i>not</i> be affected
  /// by this policy.
  ///@see \#TYPE_POSTPONE
  static SystemUpdatePolicy createPostponeInstallPolicy() =>
      SystemUpdatePolicy.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createPostponeInstallPolicy,
          jni.JniType.objectType, []).object);

  static final _id_getPolicyType =
      jniAccessors.getMethodIDOf(_classRef, "getPolicyType", "()I");

  /// from: public int getPolicyType()
  ///
  /// Returns the type of system update policy, or -1 if no policy has been set.
  ///@return The policy type or -1 if the type isn't set.
  ///
  /// Value is android.app.admin.SystemUpdatePolicy\#TYPE_INSTALL_AUTOMATIC, android.app.admin.SystemUpdatePolicy\#TYPE_INSTALL_WINDOWED, or android.app.admin.SystemUpdatePolicy\#TYPE_POSTPONE
  int getPolicyType() => jniAccessors.callMethodWithArgs(
      reference, _id_getPolicyType, jni.JniType.intType, []).integer;

  static final _id_getInstallWindowStart =
      jniAccessors.getMethodIDOf(_classRef, "getInstallWindowStart", "()I");

  /// from: public int getInstallWindowStart()
  ///
  /// Get the start of the maintenance window.
  ///@return the start of the maintenance window measured as the number of minutes from midnight,
  /// or -1 if the policy does not have a maintenance window.
  int getInstallWindowStart() => jniAccessors.callMethodWithArgs(
      reference, _id_getInstallWindowStart, jni.JniType.intType, []).integer;

  static final _id_getInstallWindowEnd =
      jniAccessors.getMethodIDOf(_classRef, "getInstallWindowEnd", "()I");

  /// from: public int getInstallWindowEnd()
  ///
  /// Get the end of the maintenance window.
  ///@return the end of the maintenance window measured as the number of minutes from midnight,
  /// or -1 if the policy does not have a maintenance window.
  int getInstallWindowEnd() => jniAccessors.callMethodWithArgs(
      reference, _id_getInstallWindowEnd, jni.JniType.intType, []).integer;

  static final _id_setFreezePeriods = jniAccessors.getMethodIDOf(
      _classRef,
      "setFreezePeriods",
      "(Ljava/util/List;)Landroid/app/admin/SystemUpdatePolicy;");

  /// from: public android.app.admin.SystemUpdatePolicy setFreezePeriods(java.util.List<android.app.admin.FreezePeriod> freezePeriods)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Configure a list of freeze periods on top of the current policy. When the device's clock is
  /// within any of the freeze periods, all incoming system updates including security patches will
  /// be blocked and cannot be installed. When the device is outside the freeze periods, the normal
  /// policy behavior will apply.
  ///
  /// Each individual freeze period is allowed to be at most 90 days long, and adjacent freeze
  /// periods need to be at least 60 days apart. Also, the list of freeze periods should not
  /// contain duplicates or overlap with each other. If any of these conditions is not met, a
  /// ValidationFailedException will be thrown.
  ///
  /// Handling of leap year: we ignore leap years in freeze period calculations, in particular,
  /// <ul>
  /// <li>When a freeze period is defined, February 29th is disregarded so even though a freeze
  /// period can be specified to start or end on February 29th, it will be treated as if the period
  /// started or ended on February 28th.</li>
  /// <li>When applying freeze period behavior to the device, a system clock of February 29th is
  /// treated as if it were February 28th</li>
  /// <li>When calculating the number of days of a freeze period or separation between two freeze
  /// periods, February 29th is also ignored and not counted as one day.</li>
  /// </ul>
  ///@param freezePeriods the list of freeze periods
  ///@throws ValidationFailedException if the supplied freeze periods do not meet the
  ///         requirement set above
  ///@return this instance
  SystemUpdatePolicy setFreezePeriods(jni.JniObject freezePeriods) =>
      SystemUpdatePolicy.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setFreezePeriods,
          jni.JniType.objectType,
          [freezePeriods.reference]).object);

  static final _id_getFreezePeriods = jniAccessors.getMethodIDOf(
      _classRef, "getFreezePeriods", "()Ljava/util/List;");

  /// from: public java.util.List<android.app.admin.FreezePeriod> getFreezePeriods()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of freeze periods previously set on this system update policy object.
  ///@return the list of freeze periods, or an empty list if none was set.
  jni.JniObject getFreezePeriods() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFreezePeriods, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.app.admin.SystemUpdatePolicy$ValidationFailedException
///
/// An exception class that represents various validation errors thrown from
/// SystemUpdatePolicy\#setFreezePeriods and
/// DevicePolicyManager\#setSystemUpdatePolicy
class SystemUpdatePolicy_ValidationFailedException extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/app/admin/SystemUpdatePolicy\$ValidationFailedException");
  SystemUpdatePolicy_ValidationFailedException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.SystemUpdatePolicy.ValidationFailedException> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int ERROR_COMBINED_FREEZE_PERIOD_TOO_CLOSE
  ///
  /// The device has been in a freeze period and some new freeze period to be set is less
  /// than 60 days from the end of the last freeze period the device went through.
  static const ERROR_COMBINED_FREEZE_PERIOD_TOO_CLOSE = 6;

  /// from: static public final int ERROR_COMBINED_FREEZE_PERIOD_TOO_LONG
  ///
  /// The device has been in a freeze period and when combining with the new freeze period
  /// to be set, it will result in the total freeze period being longer than 90 days.
  static const ERROR_COMBINED_FREEZE_PERIOD_TOO_LONG = 5;

  /// from: static public final int ERROR_DUPLICATE_OR_OVERLAP
  ///
  /// The freeze periods contains duplicates, periods that overlap with each
  /// other or periods whose start and end joins.
  static const ERROR_DUPLICATE_OR_OVERLAP = 2;

  /// from: static public final int ERROR_NEW_FREEZE_PERIOD_TOO_CLOSE
  ///
  /// There exists some freeze period which starts within 60 days of the preceding period's
  /// end time.
  static const ERROR_NEW_FREEZE_PERIOD_TOO_CLOSE = 4;

  /// from: static public final int ERROR_NEW_FREEZE_PERIOD_TOO_LONG
  ///
  /// There exists at least one freeze period whose length exceeds 90 days.
  static const ERROR_NEW_FREEZE_PERIOD_TOO_LONG = 3;

  /// from: static public final int ERROR_UNKNOWN
  ///
  /// Validation failed with unknown error.
  static const ERROR_UNKNOWN = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(ILjava/lang/String;)V");

  /// from: void <init>(int errorCode, java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SystemUpdatePolicy_ValidationFailedException(
      int errorCode, jni.JniString message)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [errorCode, message.reference]).object);

  static final _id_getErrorCode =
      jniAccessors.getMethodIDOf(_classRef, "getErrorCode", "()I");

  /// from: public int getErrorCode()
  ///
  /// Returns the type of validation error associated with this exception.
  ///@return Value is android.app.admin.SystemUpdatePolicy.ValidationFailedException.ERROR_NONE, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_DUPLICATE_OR_OVERLAP, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_NEW_FREEZE_PERIOD_TOO_LONG, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_NEW_FREEZE_PERIOD_TOO_CLOSE, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_COMBINED_FREEZE_PERIOD_TOO_LONG, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_COMBINED_FREEZE_PERIOD_TOO_CLOSE, or android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_UNKNOWN
  int getErrorCode() => jniAccessors.callMethodWithArgs(
      reference, _id_getErrorCode, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
