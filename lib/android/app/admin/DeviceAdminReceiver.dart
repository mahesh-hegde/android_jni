// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/BroadcastReceiver.dart" as broadcastreceiver_;

import "DevicePolicyManager.dart" as devicepolicymanager_;

import "../../content/Context.dart" as context_;

import "../../content/ComponentName.dart" as componentname_;

import "../../content/Intent.dart" as intent_;

import "../../os/UserHandle.dart" as userhandle_;

import "../../net/Uri.dart" as uri_;

import "../../os/PersistableBundle.dart" as persistablebundle_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.admin.DeviceAdminReceiver
///
/// Base class for implementing a device administration component.  This
/// class provides a convenience for interpreting the raw intent actions
/// that are sent by the system.
///
/// The callback methods, like the base
/// BroadcastReceiver\#onReceive(Context, Intent) BroadcastReceiver.onReceive()
/// method, happen on the main thread of the process.  Thus long running
/// operations must be done on another thread.  Note that because a receiver
/// is done once returning from its receive function, such long-running operations
/// should probably be done in a Service.
///
/// When publishing your DeviceAdmin subclass as a receiver, it must
/// handle \#ACTION_DEVICE_ADMIN_ENABLED and require the
/// android.Manifest.permission\#BIND_DEVICE_ADMIN permission.  A typical
/// manifest entry would look like:
///
///
/// {@sample development/samples/ApiDemos/AndroidManifest.xml device_admin_declaration}
///
/// The meta-data referenced here provides addition information specific
/// to the device administrator, as parsed by the DeviceAdminInfo class.
/// A typical file would be:
///
///
/// {@sample development/samples/ApiDemos/res/xml/device_admin_sample.xml meta_data}
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about device administration, read the
/// <a href="{@docRoot}guide/topics/admin/device-admin.html">Device Administration</a>
/// developer guide.
///
/// </div>
class DeviceAdminReceiver extends broadcastreceiver_.BroadcastReceiver {
  static final _classRef =
      jniAccessors.getClassOf("android/app/admin/DeviceAdminReceiver");
  DeviceAdminReceiver.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_DEVICE_ADMIN_DISABLED
  ///
  /// Action sent to a device administrator when the user has disabled
  /// it.  Upon return, the application no longer has access to the
  /// protected device policy manager APIs.  You will generally
  /// handle this in DeviceAdminReceiver\#onDisabled(Context, Intent).  Note
  /// that this action will be
  /// sent the receiver regardless of whether it is explicitly listed in
  /// its intent filter.
  static const ACTION_DEVICE_ADMIN_DISABLED =
      "android.app.action.DEVICE_ADMIN_DISABLED";

  /// from: static public final java.lang.String ACTION_DEVICE_ADMIN_DISABLE_REQUESTED
  ///
  /// Action sent to a device administrator when the user has requested to
  /// disable it, but before this has actually been done.  This gives you
  /// a chance to supply a message to the user about the impact of
  /// disabling your admin, by setting the extra field
  /// \#EXTRA_DISABLE_WARNING in the result Intent.  If not set,
  /// no warning will be displayed.  If set, the given text will be shown
  /// to the user before they disable your admin.
  static const ACTION_DEVICE_ADMIN_DISABLE_REQUESTED =
      "android.app.action.DEVICE_ADMIN_DISABLE_REQUESTED";

  /// from: static public final java.lang.String ACTION_DEVICE_ADMIN_ENABLED
  ///
  /// This is the primary action that a device administrator must implement to be
  /// allowed to manage a device.  This will be set to the receiver
  /// when the user enables it for administration.  You will generally
  /// handle this in DeviceAdminReceiver\#onEnabled(Context, Intent).  To be
  /// supported, the receiver must also require the
  /// android.Manifest.permission\#BIND_DEVICE_ADMIN permission so
  /// that other applications can not abuse it.
  static const ACTION_DEVICE_ADMIN_ENABLED =
      "android.app.action.DEVICE_ADMIN_ENABLED";

  /// from: static public final java.lang.String ACTION_LOCK_TASK_ENTERING
  ///
  /// Action sent to a device administrator to notify that the device is entering
  /// lock task mode.  The extra \#EXTRA_LOCK_TASK_PACKAGE
  /// will describe the package using lock task mode.
  ///
  /// The calling device admin must be the device owner or profile
  /// owner to receive this broadcast.
  ///@see DevicePolicyManager\#isLockTaskPermitted(String)
  static const ACTION_LOCK_TASK_ENTERING =
      "android.app.action.LOCK_TASK_ENTERING";

  /// from: static public final java.lang.String ACTION_LOCK_TASK_EXITING
  ///
  /// Action sent to a device administrator to notify that the device is exiting
  /// lock task mode.
  ///
  /// The calling device admin must be the device owner or profile
  /// owner to receive this broadcast.
  ///@see DevicePolicyManager\#isLockTaskPermitted(String)
  static const ACTION_LOCK_TASK_EXITING =
      "android.app.action.LOCK_TASK_EXITING";

  /// from: static public final java.lang.String ACTION_PASSWORD_CHANGED
  ///
  /// Action sent to a device administrator when the user has changed the password of their device
  /// or profile challenge.  You can at this point check the characteristics
  /// of the new password with DevicePolicyManager\#isActivePasswordSufficient() DevicePolicyManager.isActivePasswordSufficient().
  /// You will generally
  /// handle this in DeviceAdminReceiver\#onPasswordChanged(Context, Intent, UserHandle).
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to receive
  /// this broadcast.
  static const ACTION_PASSWORD_CHANGED =
      "android.app.action.ACTION_PASSWORD_CHANGED";

  /// from: static public final java.lang.String ACTION_PASSWORD_EXPIRING
  ///
  /// Action periodically sent to a device administrator when the device or profile challenge
  /// password is expiring.  You will generally
  /// handle this in DeviceAdminReceiver\#onPasswordExpiring(Context, Intent, UserHandle).
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_EXPIRE_PASSWORD to receive
  /// this broadcast.
  static const ACTION_PASSWORD_EXPIRING =
      "android.app.action.ACTION_PASSWORD_EXPIRING";

  /// from: static public final java.lang.String ACTION_PASSWORD_FAILED
  ///
  /// Action sent to a device administrator when the user has entered an incorrect device
  /// or profile challenge password.  You can at this point check the
  /// number of failed password attempts there have been with
  /// DevicePolicyManager\#getCurrentFailedPasswordAttempts DevicePolicyManager.getCurrentFailedPasswordAttempts().  You will generally
  /// handle this in DeviceAdminReceiver\#onPasswordFailed(Context, Intent, UserHandle).
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN to receive
  /// this broadcast.
  static const ACTION_PASSWORD_FAILED =
      "android.app.action.ACTION_PASSWORD_FAILED";

  /// from: static public final java.lang.String ACTION_PASSWORD_SUCCEEDED
  ///
  /// Action sent to a device administrator when the user has successfully entered their device
  /// or profile challenge password, after failing one or more times.  You will generally
  /// handle this in DeviceAdminReceiver\#onPasswordSucceeded(Context, Intent, UserHandle).
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN to receive
  /// this broadcast.
  static const ACTION_PASSWORD_SUCCEEDED =
      "android.app.action.ACTION_PASSWORD_SUCCEEDED";

  /// from: static public final java.lang.String ACTION_PROFILE_PROVISIONING_COMPLETE
  ///
  /// Broadcast Action: This broadcast is sent to indicate that provisioning of a managed profile
  /// or managed device has completed successfully.
  ///
  /// The broadcast is limited to the profile that will be managed by the application that
  /// requested provisioning. In the device owner case the profile is the primary user.
  /// The broadcast will also be limited to the DeviceAdminReceiver component
  /// specified in the original intent or NFC bump that started the provisioning process
  /// (see DevicePolicyManager\#ACTION_PROVISION_MANAGED_PROFILE DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE).
  ///
  /// A device admin application which listens to this intent can find out if the device was
  /// provisioned for the device owner or profile owner case by calling respectively
  /// android.app.admin.DevicePolicyManager\#isDeviceOwnerApp and
  /// android.app.admin.DevicePolicyManager\#isProfileOwnerApp. You will generally handle
  /// this in DeviceAdminReceiver\#onProfileProvisioningComplete.
  ///@see DevicePolicyManager\#ACTION_PROVISIONING_SUCCESSFUL
  static const ACTION_PROFILE_PROVISIONING_COMPLETE =
      "android.app.action.PROFILE_PROVISIONING_COMPLETE";

  /// from: static public final int BUGREPORT_FAILURE_FAILED_COMPLETING
  ///
  /// Bugreport completion process failed.
  ///
  /// If this error code is received, the requesting of bugreport can be retried.
  ///@see DevicePolicyManager\#requestBugreport
  static const BUGREPORT_FAILURE_FAILED_COMPLETING = 0;

  /// from: static public final int BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE
  ///
  /// Bugreport has been created, but is no longer available for collection.
  ///
  /// This error likely occurs because the user of the device hasn't consented to share
  /// the bugreport for a long period after its creation.
  ///
  /// If this error code is received, the requesting of bugreport can be retried.
  ///@see DevicePolicyManager\#requestBugreport
  static const BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE = 1;

  /// from: static public final java.lang.String DEVICE_ADMIN_META_DATA
  ///
  /// Name under which a DevicePolicy component publishes information
  /// about itself.  This meta-data must reference an XML resource containing
  /// a device-admin tag.
  static const DEVICE_ADMIN_META_DATA = "android.app.device_admin";

  /// from: static public final java.lang.String EXTRA_DISABLE_WARNING
  ///
  /// A CharSequence that can be shown to the user informing them of the
  /// impact of disabling your admin.
  ///@see \#ACTION_DEVICE_ADMIN_DISABLE_REQUESTED
  static const EXTRA_DISABLE_WARNING = "android.app.extra.DISABLE_WARNING";

  /// from: static public final java.lang.String EXTRA_LOCK_TASK_PACKAGE
  ///
  /// A string containing the name of the package entering lock task mode.
  ///@see \#ACTION_LOCK_TASK_ENTERING
  static const EXTRA_LOCK_TASK_PACKAGE = "android.app.extra.LOCK_TASK_PACKAGE";

  /// from: static public final java.lang.String EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE
  ///
  /// A android.os.Parcelable extra of type android.os.PersistableBundle that
  /// allows a mobile device management application to pass data to the management application
  /// instance after owner transfer.
  ///
  /// If the transfer is successful, the new owner receives the data in
  /// DeviceAdminReceiver\#onTransferOwnershipComplete(Context, PersistableBundle).
  /// The bundle is not changed during the ownership transfer.
  ///@see DevicePolicyManager\#transferOwnership(ComponentName, ComponentName, PersistableBundle)
  static const EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE =
      "android.app.extra.TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DeviceAdminReceiver()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getManager = jniAccessors.getMethodIDOf(
      _classRef,
      "getManager",
      "(Landroid/content/Context;)Landroid/app/admin/DevicePolicyManager;");

  /// from: public android.app.admin.DevicePolicyManager getManager(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the DevicePolicyManager interface for this administrator to work
  /// with the system.
  devicepolicymanager_.DevicePolicyManager getManager(
          context_.Context context) =>
      devicepolicymanager_.DevicePolicyManager.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getManager, jni.JniType.objectType,
              [context.reference]).object);

  static final _id_getWho = jniAccessors.getMethodIDOf(_classRef, "getWho",
      "(Landroid/content/Context;)Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getWho(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the ComponentName describing who this device administrator is, for
  /// use in DevicePolicyManager APIs that require the administrator to
  /// identify itself.
  componentname_.ComponentName getWho(context_.Context context) =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getWho,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_onEnabled = jniAccessors.getMethodIDOf(_classRef,
      "onEnabled", "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onEnabled(android.content.Context context, android.content.Intent intent)
  ///
  /// Called after the administrator is first enabled, as a result of
  /// receiving \#ACTION_DEVICE_ADMIN_ENABLED.  At this point you
  /// can use DevicePolicyManager to set your desired policies.
  ///
  ///  If the admin is activated by a device owner, then the intent
  /// may contain private extras that are relevant to user setup.
  /// {@see DevicePolicyManager\#createAndManageUser(ComponentName, String, ComponentName,
  ///      PersistableBundle, int)}
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  void onEnabled(context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onEnabled,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onDisableRequested = jniAccessors.getMethodIDOf(
      _classRef,
      "onDisableRequested",
      "(Landroid/content/Context;Landroid/content/Intent;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence onDisableRequested(android.content.Context context, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when the user has asked to disable the administrator, as a result of
  /// receiving \#ACTION_DEVICE_ADMIN_DISABLE_REQUESTED, giving you
  /// a chance to present a warning message to them.  The message is returned
  /// as the result; if null is returned (the default implementation), no
  /// message will be displayed.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@return Return the warning message to display to the user before
  /// being disabled; if null is returned, no message is displayed.
  jni.JniObject onDisableRequested(
          context_.Context context, intent_.Intent intent) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onDisableRequested,
          jni.JniType.objectType,
          [context.reference, intent.reference]).object);

  static final _id_onDisabled = jniAccessors.getMethodIDOf(_classRef,
      "onDisabled", "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onDisabled(android.content.Context context, android.content.Intent intent)
  ///
  /// Called prior to the administrator being disabled, as a result of
  /// receiving \#ACTION_DEVICE_ADMIN_DISABLED.  Upon return, you
  /// can no longer use the protected parts of the DevicePolicyManager
  /// API.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  void onDisabled(context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDisabled,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onPasswordChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onPasswordChanged",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onPasswordChanged(android.content.Context context, android.content.Intent intent)
  ///
  /// Called after the user has changed their device or profile challenge password, as a result of
  /// receiving \#ACTION_PASSWORD_CHANGED.  At this point you
  /// can use DevicePolicyManager\#getPasswordQuality(android.content.ComponentName)
  /// to retrieve the active password characteristics.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated From android.os.Build.VERSION_CODES\#O, use
  ///             \#onPasswordChanged(Context, Intent, UserHandle) instead.
  void onPasswordChanged(context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPasswordChanged,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onPasswordChanged1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onPasswordChanged",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onPasswordChanged(android.content.Context context, android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Called after the user has changed their device or profile challenge password, as a result of
  /// receiving \#ACTION_PASSWORD_CHANGED.  At this point you
  /// can use DevicePolicyManager\#getPasswordQuality(android.content.ComponentName)
  /// to retrieve the active password characteristics.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param user The user or profile for whom the password changed. To see whether this
  ///        user is the current profile or a parent user, check for equality with
  ///        Process\#myUserHandle.
  void onPasswordChanged1(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPasswordChanged1,
          jni.JniType.voidType,
          [context.reference, intent.reference, user.reference]).check();

  static final _id_onPasswordFailed = jniAccessors.getMethodIDOf(
      _classRef,
      "onPasswordFailed",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onPasswordFailed(android.content.Context context, android.content.Intent intent)
  ///
  /// Called after the user has failed at entering their device or profile challenge password,
  /// as a result of receiving \#ACTION_PASSWORD_FAILED.  At this point you can use
  /// DevicePolicyManager\#getCurrentFailedPasswordAttempts() to retrieve the number of
  /// failed password attempts.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated From android.os.Build.VERSION_CODES\#O, use
  ///             \#onPasswordFailed(Context, Intent, UserHandle) instead.
  void onPasswordFailed(context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPasswordFailed,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onPasswordFailed1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onPasswordFailed",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onPasswordFailed(android.content.Context context, android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Called after the user has failed at entering their device or profile challenge password,
  /// as a result of receiving \#ACTION_PASSWORD_FAILED.  At this point you can use
  /// DevicePolicyManager\#getCurrentFailedPasswordAttempts() to retrieve the number of
  /// failed password attempts.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param user The user or profile for whom the password check failed. To see whether this
  ///        user is the current profile or a parent user, check for equality with
  ///        Process\#myUserHandle.
  void onPasswordFailed1(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPasswordFailed1,
          jni.JniType.voidType,
          [context.reference, intent.reference, user.reference]).check();

  static final _id_onPasswordSucceeded = jniAccessors.getMethodIDOf(
      _classRef,
      "onPasswordSucceeded",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onPasswordSucceeded(android.content.Context context, android.content.Intent intent)
  ///
  /// Called after the user has succeeded at entering their device or profile challenge password,
  /// as a result of receiving \#ACTION_PASSWORD_SUCCEEDED.  This will
  /// only be received the first time they succeed after having previously
  /// failed.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated From android.os.Build.VERSION_CODES\#O, use
  ///             \#onPasswordSucceeded(Context, Intent, UserHandle) instead.
  void onPasswordSucceeded(context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPasswordSucceeded,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onPasswordSucceeded1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onPasswordSucceeded",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onPasswordSucceeded(android.content.Context context, android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Called after the user has succeeded at entering their device or profile challenge password,
  /// as a result of receiving \#ACTION_PASSWORD_SUCCEEDED.  This will
  /// only be received the first time they succeed after having previously
  /// failed.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param user The user of profile for whom the password check succeeded.  To see whether this
  ///        user is the current profile or a parent user, check for equality with
  ///        Process\#myUserHandle.
  void onPasswordSucceeded1(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPasswordSucceeded1,
          jni.JniType.voidType,
          [context.reference, intent.reference, user.reference]).check();

  static final _id_onPasswordExpiring = jniAccessors.getMethodIDOf(
      _classRef,
      "onPasswordExpiring",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onPasswordExpiring(android.content.Context context, android.content.Intent intent)
  ///
  /// Called periodically when the device or profile challenge password is about to expire
  /// or has expired.  It will typically be called at these times: on device boot, once per day
  /// before the password expires, and at the time when the password expires.
  ///
  /// If the password is not updated by the user, this method will continue to be called
  /// once per day until the password is changed or the device admin disables password expiration.
  ///
  /// The admin will typically post a notification requesting the user to change their password
  /// in response to this call. The actual password expiration time can be obtained by calling
  /// DevicePolicyManager\#getPasswordExpiration(ComponentName)
  ///
  /// The admin should be sure to take down any notifications it posted in response to this call
  /// when it receives DeviceAdminReceiver\#onPasswordChanged(Context, Intent).
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated From android.os.Build.VERSION_CODES\#O, use
  ///             \#onPasswordExpiring(Context, Intent, UserHandle) instead.
  void onPasswordExpiring(context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPasswordExpiring,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onPasswordExpiring1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onPasswordExpiring",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onPasswordExpiring(android.content.Context context, android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Called periodically when the device or profile challenge password is about to expire
  /// or has expired.  It will typically be called at these times: on device boot, once per day
  /// before the password expires, and at the time when the password expires.
  ///
  /// If the password is not updated by the user, this method will continue to be called
  /// once per day until the password is changed or the device admin disables password expiration.
  ///
  /// The admin will typically post a notification requesting the user to change their password
  /// in response to this call. The actual password expiration time can be obtained by calling
  /// DevicePolicyManager\#getPasswordExpiration(ComponentName)
  ///
  /// The admin should be sure to take down any notifications it posted in response to this call
  /// when it receives DeviceAdminReceiver\#onPasswordChanged(Context, Intent, UserHandle).
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param user The user or profile for whom the password is expiring. To see whether this
  ///        user is the current profile or a parent user, check for equality with
  ///        Process\#myUserHandle.
  void onPasswordExpiring1(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPasswordExpiring1,
          jni.JniType.voidType,
          [context.reference, intent.reference, user.reference]).check();

  static final _id_onProfileProvisioningComplete = jniAccessors.getMethodIDOf(
      _classRef,
      "onProfileProvisioningComplete",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onProfileProvisioningComplete(android.content.Context context, android.content.Intent intent)
  ///
  /// Called when provisioning of a managed profile or managed device has completed successfully.
  ///
  ///  As a prerequisite for the execution of this callback the DeviceAdminReceiver has
  /// to declare an intent filter for \#ACTION_PROFILE_PROVISIONING_COMPLETE.
  /// Its component must also be specified in the DevicePolicyManager\#EXTRA_DEVICE_ADMIN
  /// of the DevicePolicyManager\#ACTION_PROVISION_MANAGED_PROFILE intent that started the
  /// managed provisioning.
  ///
  /// When provisioning of a managed profile is complete, the managed profile is hidden until
  /// the profile owner calls DevicePolicyManager\#setProfileEnabled(ComponentName admin).
  /// Typically a profile owner will enable the profile when it has finished any additional setup
  /// such as adding an account by using the AccountManager and calling APIs to bring the
  /// profile into the desired state.
  ///
  ///  Note that provisioning completes without waiting for any server interactions, so the
  /// profile owner needs to wait for data to be available if required (e.g. Android device IDs or
  /// other data that is set as a result of server interactions).
  ///
  /// From version android.os.Build.VERSION_CODES\#O, when managed provisioning has
  /// completed, along with this callback the activity intent
  /// DevicePolicyManager\#ACTION_PROVISIONING_SUCCESSFUL will also be sent to the same
  /// application.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  void onProfileProvisioningComplete(
          context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onProfileProvisioningComplete,
          jni.JniType.voidType,
          [context.reference, intent.reference]).check();

  static final _id_onReadyForUserInitialization = jniAccessors.getMethodIDOf(
      _classRef,
      "onReadyForUserInitialization",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onReadyForUserInitialization(android.content.Context context, android.content.Intent intent)
  ///
  /// Called during provisioning of a managed device to allow the device initializer to perform
  /// user setup steps.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated Do not use
  void onReadyForUserInitialization(
          context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onReadyForUserInitialization,
          jni.JniType.voidType,
          [context.reference, intent.reference]).check();

  static final _id_onLockTaskModeEntering = jniAccessors.getMethodIDOf(
      _classRef,
      "onLockTaskModeEntering",
      "(Landroid/content/Context;Landroid/content/Intent;Ljava/lang/String;)V");

  /// from: public void onLockTaskModeEntering(android.content.Context context, android.content.Intent intent, java.lang.String pkg)
  ///
  /// Called when a device is entering lock task mode.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param pkg If entering, the authorized package using lock task mode, otherwise null.
  void onLockTaskModeEntering(
          context_.Context context, intent_.Intent intent, jni.JniString pkg) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onLockTaskModeEntering,
          jni.JniType.voidType,
          [context.reference, intent.reference, pkg.reference]).check();

  static final _id_onLockTaskModeExiting = jniAccessors.getMethodIDOf(
      _classRef,
      "onLockTaskModeExiting",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onLockTaskModeExiting(android.content.Context context, android.content.Intent intent)
  ///
  /// Called when a device is exiting lock task mode.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  void onLockTaskModeExiting(context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLockTaskModeExiting,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onChoosePrivateKeyAlias = jniAccessors.getMethodIDOf(
      _classRef,
      "onChoosePrivateKeyAlias",
      "(Landroid/content/Context;Landroid/content/Intent;ILandroid/net/Uri;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String onChoosePrivateKeyAlias(android.content.Context context, android.content.Intent intent, int uid, android.net.Uri uri, java.lang.String alias)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Allows this receiver to select the alias for a private key and certificate pair for
  /// authentication. If this method returns null, the default android.app.Activity will be
  /// shown that lets the user pick a private key and certificate pair.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param uid The uid asking for the private key and certificate pair.
  ///@param uri The URI to authenticate, may be null.
  ///@param alias The alias preselected by the client, or null.
  ///@return The private key alias to return and grant access to.
  ///@see KeyChain\#choosePrivateKeyAlias
  jni.JniString onChoosePrivateKeyAlias(context_.Context context,
          intent_.Intent intent, int uid, uri_.Uri uri, jni.JniString alias) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onChoosePrivateKeyAlias, jni.JniType.objectType, [
        context.reference,
        intent.reference,
        uid,
        uri.reference,
        alias.reference
      ]).object);

  static final _id_onSystemUpdatePending = jniAccessors.getMethodIDOf(
      _classRef,
      "onSystemUpdatePending",
      "(Landroid/content/Context;Landroid/content/Intent;J)V");

  /// from: public void onSystemUpdatePending(android.content.Context context, android.content.Intent intent, long receivedTime)
  ///
  /// Called when the information about a pending system update is available.
  ///
  /// Allows the receiver to be notified when information about a pending system update is
  /// available from the system update service. The same pending system update can trigger multiple
  /// calls to this method, so it is necessary to examine the incoming parameters for details about
  /// the update.
  ///
  /// This callback is only applicable to device owners and profile owners.
  ///
  /// To get further information about a pending system update (for example, whether or not the
  /// update is a security patch), the device owner or profile owner can call
  /// DevicePolicyManager\#getPendingSystemUpdate.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param receivedTime The time as given by System\#currentTimeMillis() indicating when
  ///        the current pending update was first available. -1 if no pending update is available.
  ///@see DevicePolicyManager\#getPendingSystemUpdate
  void onSystemUpdatePending(
          context_.Context context, intent_.Intent intent, int receivedTime) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSystemUpdatePending,
          jni.JniType.voidType,
          [context.reference, intent.reference, receivedTime]).check();

  static final _id_onBugreportSharingDeclined = jniAccessors.getMethodIDOf(
      _classRef,
      "onBugreportSharingDeclined",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onBugreportSharingDeclined(android.content.Context context, android.content.Intent intent)
  ///
  /// Called when sharing a bugreport has been cancelled by the user of the device.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@see DevicePolicyManager\#requestBugreport
  void onBugreportSharingDeclined(
          context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onBugreportSharingDeclined,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onBugreportShared = jniAccessors.getMethodIDOf(
      _classRef,
      "onBugreportShared",
      "(Landroid/content/Context;Landroid/content/Intent;Ljava/lang/String;)V");

  /// from: public void onBugreportShared(android.content.Context context, android.content.Intent intent, java.lang.String bugreportHash)
  ///
  /// Called when the bugreport has been shared with the device administrator app.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive. Contains the URI of
  /// the bugreport file (with MIME type "application/vnd.android.bugreport"), that can be accessed
  /// by calling Intent\#getData()
  ///@param bugreportHash SHA-256 hash of the bugreport file.
  ///@see DevicePolicyManager\#requestBugreport
  void onBugreportShared(context_.Context context, intent_.Intent intent,
          jni.JniString bugreportHash) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onBugreportShared, jni.JniType.voidType, [
        context.reference,
        intent.reference,
        bugreportHash.reference
      ]).check();

  static final _id_onBugreportFailed = jniAccessors.getMethodIDOf(
      _classRef,
      "onBugreportFailed",
      "(Landroid/content/Context;Landroid/content/Intent;I)V");

  /// from: public void onBugreportFailed(android.content.Context context, android.content.Intent intent, int failureCode)
  ///
  /// Called when the bugreport collection flow has failed.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param failureCode int containing failure code. One of
  /// \#BUGREPORT_FAILURE_FAILED_COMPLETING
  /// or \#BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE
  /// Value is android.app.admin.DeviceAdminReceiver\#BUGREPORT_FAILURE_FAILED_COMPLETING, or android.app.admin.DeviceAdminReceiver\#BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE
  ///@see DevicePolicyManager\#requestBugreport
  void onBugreportFailed(
          context_.Context context, intent_.Intent intent, int failureCode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onBugreportFailed,
          jni.JniType.voidType,
          [context.reference, intent.reference, failureCode]).check();

  static final _id_onSecurityLogsAvailable = jniAccessors.getMethodIDOf(
      _classRef,
      "onSecurityLogsAvailable",
      "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onSecurityLogsAvailable(android.content.Context context, android.content.Intent intent)
  ///
  /// Called when a new batch of security logs can be retrieved.
  ///
  /// If a secondary user or profile is created, this callback won't be received until all users
  /// become affiliated again (even if security logging is enabled).
  /// See DevicePolicyManager\#setAffiliationIds
  ///
  /// This callback will be re-triggered if the logs are not retrieved.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@see DevicePolicyManager\#retrieveSecurityLogs(ComponentName)
  void onSecurityLogsAvailable(
          context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSecurityLogsAvailable,
          jni.JniType.voidType, [context.reference, intent.reference]).check();

  static final _id_onNetworkLogsAvailable = jniAccessors.getMethodIDOf(
      _classRef,
      "onNetworkLogsAvailable",
      "(Landroid/content/Context;Landroid/content/Intent;JI)V");

  /// from: public void onNetworkLogsAvailable(android.content.Context context, android.content.Intent intent, long batchToken, int networkLogsCount)
  ///
  /// Called each time a new batch of network logs can be retrieved. This callback method will only
  /// ever be called when network logging is enabled. The logs can only be retrieved while network
  /// logging is enabled.
  ///
  /// If a secondary user or profile is created, this callback won't be received until all users
  /// become affiliated again (even if network logging is enabled). It will also no longer be
  /// possible to retrieve the network logs batch with the most recent {@code batchToken} provided
  /// by this callback. See DevicePolicyManager\#setAffiliationIds.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param batchToken The token representing the current batch of network logs.
  ///@param networkLogsCount The total count of events in the current batch of network logs.
  ///@see DevicePolicyManager\#retrieveNetworkLogs
  void onNetworkLogsAvailable(context_.Context context, intent_.Intent intent,
          int batchToken, int networkLogsCount) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onNetworkLogsAvailable, jni.JniType.voidType, [
        context.reference,
        intent.reference,
        batchToken,
        networkLogsCount
      ]).check();

  static final _id_onUserAdded = jniAccessors.getMethodIDOf(
      _classRef,
      "onUserAdded",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onUserAdded(android.content.Context context, android.content.Intent intent, android.os.UserHandle newUser)
  ///
  /// Called when a user or profile is created.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param newUser The UserHandle of the user that has just been added.
  ///
  /// This value must never be {@code null}.
  void onUserAdded(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle newUser) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onUserAdded,
          jni.JniType.voidType,
          [context.reference, intent.reference, newUser.reference]).check();

  static final _id_onUserRemoved = jniAccessors.getMethodIDOf(
      _classRef,
      "onUserRemoved",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onUserRemoved(android.content.Context context, android.content.Intent intent, android.os.UserHandle removedUser)
  ///
  /// Called when a user or profile is removed.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param removedUser The UserHandle of the user that has just been removed.
  ///
  /// This value must never be {@code null}.
  void onUserRemoved(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle removedUser) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onUserRemoved,
          jni.JniType.voidType,
          [context.reference, intent.reference, removedUser.reference]).check();

  static final _id_onUserStarted = jniAccessors.getMethodIDOf(
      _classRef,
      "onUserStarted",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onUserStarted(android.content.Context context, android.content.Intent intent, android.os.UserHandle startedUser)
  ///
  /// Called when a user or profile is started.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param startedUser The UserHandle of the user that has just been started.
  ///
  /// This value must never be {@code null}.
  void onUserStarted(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle startedUser) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onUserStarted,
          jni.JniType.voidType,
          [context.reference, intent.reference, startedUser.reference]).check();

  static final _id_onUserStopped = jniAccessors.getMethodIDOf(
      _classRef,
      "onUserStopped",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onUserStopped(android.content.Context context, android.content.Intent intent, android.os.UserHandle stoppedUser)
  ///
  /// Called when a user or profile is stopped.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param stoppedUser The UserHandle of the user that has just been stopped.
  ///
  /// This value must never be {@code null}.
  void onUserStopped(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle stoppedUser) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onUserStopped,
          jni.JniType.voidType,
          [context.reference, intent.reference, stoppedUser.reference]).check();

  static final _id_onUserSwitched = jniAccessors.getMethodIDOf(
      _classRef,
      "onUserSwitched",
      "(Landroid/content/Context;Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public void onUserSwitched(android.content.Context context, android.content.Intent intent, android.os.UserHandle switchedUser)
  ///
  /// Called when a user or profile is switched to.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param switchedUser The UserHandle of the user that has just been switched to.
  ///
  /// This value must never be {@code null}.
  void onUserSwitched(context_.Context context, intent_.Intent intent,
          userhandle_.UserHandle switchedUser) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onUserSwitched, jni.JniType.voidType, [
        context.reference,
        intent.reference,
        switchedUser.reference
      ]).check();

  static final _id_onTransferOwnershipComplete = jniAccessors.getMethodIDOf(
      _classRef,
      "onTransferOwnershipComplete",
      "(Landroid/content/Context;Landroid/os/PersistableBundle;)V");

  /// from: public void onTransferOwnershipComplete(android.content.Context context, android.os.PersistableBundle bundle)
  ///
  /// Called on the newly assigned owner (either device owner or profile owner) when the ownership
  /// transfer has completed successfully.
  ///
  ///  The {@code bundle} parameter allows the original owner to pass data
  /// to the new one.
  ///@param context the running context as per \#onReceive
  /// This value must never be {@code null}.
  ///@param bundle the data to be passed to the new owner
  ///
  /// This value may be {@code null}.
  void onTransferOwnershipComplete(context_.Context context,
          persistablebundle_.PersistableBundle bundle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTransferOwnershipComplete,
          jni.JniType.voidType,
          [context.reference, bundle.reference]).check();

  static final _id_onTransferAffiliatedProfileOwnershipComplete =
      jniAccessors.getMethodIDOf(
          _classRef,
          "onTransferAffiliatedProfileOwnershipComplete",
          "(Landroid/content/Context;Landroid/os/UserHandle;)V");

  /// from: public void onTransferAffiliatedProfileOwnershipComplete(android.content.Context context, android.os.UserHandle user)
  ///
  /// Called on the device owner when the ownership of one of its affiliated profiles is
  /// transferred.
  ///
  /// This can be used when transferring both device and profile ownership when using
  /// work profile on a fully managed device. The process would look like this:
  /// <ol>
  /// <li>Transfer profile ownership</li>
  /// <li>The device owner gets notified with this callback</li>
  /// <li>Transfer device ownership</li>
  /// <li>Both profile and device ownerships have been transferred</li>
  /// </ol>
  ///@param context the running context as per \#onReceive
  ///@param user the UserHandle of the affiliated user
  ///@see DevicePolicyManager\#transferOwnership(ComponentName, ComponentName, PersistableBundle)
  void onTransferAffiliatedProfileOwnershipComplete(
          context_.Context context, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTransferAffiliatedProfileOwnershipComplete,
          jni.JniType.voidType,
          [context.reference, user.reference]).check();

  static final _id_onReceive = jniAccessors.getMethodIDOf(_classRef,
      "onReceive", "(Landroid/content/Context;Landroid/content/Intent;)V");

  /// from: public void onReceive(android.content.Context context, android.content.Intent intent)
  ///
  /// Intercept standard device administrator broadcasts.  Implementations
  /// should not override this method; it is better to implement the
  /// convenience callbacks for each action.
  void onReceive(context_.Context context, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onReceive,
          jni.JniType.voidType, [context.reference, intent.reference]).check();
}
