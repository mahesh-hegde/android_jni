// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/ComponentName.dart" as componentname_;

import "../../net/ProxyInfo.dart" as proxyinfo_;

import "../../security/AttestedKeyPair.dart" as attestedkeypair_;

import "../../security/keystore/KeyGenParameterSpec.dart"
    as keygenparameterspec_;

import "../../content/IntentFilter.dart" as intentfilter_;

import "../../os/Bundle.dart" as bundle_;

import "../../os/PersistableBundle.dart" as persistablebundle_;

import "../../os/UserHandle.dart" as userhandle_;

import "../../content/Intent.dart" as intent_;

import "../../graphics/Bitmap.dart" as bitmap_;

import "SystemUpdatePolicy.dart" as systemupdatepolicy_;

import "SystemUpdateInfo.dart" as systemupdateinfo_;

import "../../content/ServiceConnection.dart" as serviceconnection_;

import "../../telephony/data/ApnSetting.dart" as apnsetting_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.admin.DevicePolicyManager
///
/// Public interface for managing policies enforced on a device. Most clients of this class must be
/// registered with the system as a <a href="{@docRoot}guide/topics/admin/device-admin.html">device
/// administrator</a>. Additionally, a device administrator may be registered as either a profile or
/// device owner. A given method is accessible to all device administrators unless the documentation
/// for that method specifies that it is restricted to either device or profile owners. Any
/// application calling an api may only pass as an argument a device administrator component it
/// owns. Otherwise, a SecurityException will be thrown.
/// <div class="special reference">
/// <h3>Developer Guides</h3>
///
/// For more information about managing policies for device administration, read the <a href="{@docRoot}guide/topics/admin/device-admin.html">Device Administration</a> developer
/// guide. </div>
///
/// Requires the android.content.pm.PackageManager\#FEATURE_DEVICE_ADMIN PackageManager\#FEATURE_DEVICE_ADMIN feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
class DevicePolicyManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/admin/DevicePolicyManager");
  DevicePolicyManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_ADD_DEVICE_ADMIN
  ///
  /// Activity action: ask the user to add a new device administrator to the system.
  /// The desired policy is the ComponentName of the policy in the
  /// \#EXTRA_DEVICE_ADMIN extra field.  This will invoke a UI to
  /// bring the user through adding the device administrator to the system (or
  /// allowing them to reject it).
  ///
  /// You can optionally include the \#EXTRA_ADD_EXPLANATION
  /// field to provide the user with additional explanation (in addition
  /// to your component's description) about what is being added.
  ///
  /// If your administrator is already active, this will ordinarily return immediately (without
  /// user intervention).  However, if your administrator has been updated and is requesting
  /// additional uses-policy flags, the user will be presented with the new list.  New policies
  /// will not be available to the updated administrator until the user has accepted the new list.
  static const ACTION_ADD_DEVICE_ADMIN = "android.app.action.ADD_DEVICE_ADMIN";

  /// from: static public final java.lang.String ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED
  ///
  /// Broadcast Action: Sent after application delegation scopes are changed. The new delegation
  /// scopes will be sent in an {@code ArrayList<String>} extra identified by the
  /// \#EXTRA_DELEGATION_SCOPES key.
  ///
  /// <p class=\u201dnote\u201d> Note: This is a protected intent that can only be sent by the system.
  ///
  static const ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED =
      "android.app.action.APPLICATION_DELEGATION_SCOPES_CHANGED";

  /// from: static public final java.lang.String ACTION_DEVICE_ADMIN_SERVICE
  ///
  /// Service action: Action for a service that device owner and profile owner can optionally
  /// own.  If a device owner or a profile owner has such a service, the system tries to keep
  /// a bound connection to it, in order to keep their process always running.
  /// The service must be protected with the android.Manifest.permission\#BIND_DEVICE_ADMIN
  /// permission.
  static const ACTION_DEVICE_ADMIN_SERVICE =
      "android.app.action.DEVICE_ADMIN_SERVICE";

  /// from: static public final java.lang.String ACTION_DEVICE_OWNER_CHANGED
  ///
  /// Broadcast action: sent when the device owner is set, changed or cleared.
  ///
  /// This broadcast is sent only to the primary user.
  ///@see \#ACTION_PROVISION_MANAGED_DEVICE
  ///@see DevicePolicyManager\#transferOwnership(ComponentName, ComponentName, PersistableBundle)
  static const ACTION_DEVICE_OWNER_CHANGED =
      "android.app.action.DEVICE_OWNER_CHANGED";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_PROVISIONED
  ///
  /// Broadcast Action: This broadcast is sent to indicate that provisioning of a managed profile
  /// has completed successfully.
  ///
  /// The broadcast is limited to the primary profile, to the app specified in the provisioning
  /// intent with action \#ACTION_PROVISION_MANAGED_PROFILE.
  ///
  /// This intent will contain the following extras
  /// <ul>
  /// <li>Intent\#EXTRA_USER, corresponds to the UserHandle of the managed
  /// profile.</li>
  /// <li>\#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE, corresponds to the account requested to
  /// be migrated at provisioning time, if any.</li>
  /// </ul>
  static const ACTION_MANAGED_PROFILE_PROVISIONED =
      "android.app.action.MANAGED_PROFILE_PROVISIONED";

  /// from: static public final java.lang.String ACTION_PROFILE_OWNER_CHANGED
  ///
  /// Broadcast action: sent when the profile owner is set, changed or cleared.
  ///
  /// This broadcast is sent only to the user managed by the new profile owner.
  ///@see DevicePolicyManager\#transferOwnership(ComponentName, ComponentName, PersistableBundle)
  static const ACTION_PROFILE_OWNER_CHANGED =
      "android.app.action.PROFILE_OWNER_CHANGED";

  /// from: static public final java.lang.String ACTION_PROVISIONING_SUCCESSFUL
  ///
  /// Activity action: This activity action is sent to indicate that provisioning of a managed
  /// profile or managed device has completed successfully. It'll be sent at the same time as
  /// DeviceAdminReceiver\#ACTION_PROFILE_PROVISIONING_COMPLETE broadcast but this will be
  /// delivered faster as it's an activity intent.
  ///
  /// The intent is only sent to the new device or profile owner.
  ///@see \#ACTION_PROVISION_MANAGED_PROFILE
  ///@see \#ACTION_PROVISION_MANAGED_DEVICE
  static const ACTION_PROVISIONING_SUCCESSFUL =
      "android.app.action.PROVISIONING_SUCCESSFUL";

  /// from: static public final java.lang.String ACTION_PROVISION_MANAGED_DEVICE
  ///
  /// Activity action: Starts the provisioning flow which sets up a managed device.
  /// Must be started with android.app.Activity\#startActivityForResult(Intent, int).
  ///
  ///  During device owner provisioning a device admin app is set as the owner of the device.
  /// A device owner has full control over the device. The device owner can not be modified by the
  /// user.
  ///
  ///  A typical use case would be a device that is owned by a company, but used by either an
  /// employee or client.
  ///
  ///  An intent with this action can be sent only on an unprovisioned device.
  /// It is possible to check if provisioning is allowed or not by querying the method
  /// \#isProvisioningAllowed(String).
  ///
  /// The intent contains the following extras:
  /// <ul>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME</li>
  /// <li>\#EXTRA_PROVISIONING_SKIP_ENCRYPTION, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED, optional</li>
  /// <li>\#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LOGO_URI, optional</li>
  /// <li>\#EXTRA_PROVISIONING_MAIN_COLOR, optional</li>
  /// <li>\#EXTRA_PROVISIONING_DISCLAIMERS, optional</li>
  /// </ul>
  ///
  /// When device owner provisioning has completed, an intent of the type
  /// DeviceAdminReceiver\#ACTION_PROFILE_PROVISIONING_COMPLETE is broadcast to the
  /// device owner.
  ///
  /// From version android.os.Build.VERSION_CODES\#O, when device owner provisioning has
  /// completed, along with the above broadcast, activity intent
  /// \#ACTION_PROVISIONING_SUCCESSFUL will also be sent to the device owner.
  ///
  /// If provisioning fails, the device is factory reset.
  ///
  /// A result code of android.app.Activity\#RESULT_OK implies that the synchronous part
  /// of the provisioning flow was successful, although this doesn't guarantee the full flow will
  /// succeed. Conversely a result code of android.app.Activity\#RESULT_CANCELED implies
  /// that the user backed-out of provisioning, or some precondition for provisioning wasn't met.
  static const ACTION_PROVISION_MANAGED_DEVICE =
      "android.app.action.PROVISION_MANAGED_DEVICE";

  /// from: static public final java.lang.String ACTION_PROVISION_MANAGED_PROFILE
  ///
  /// Activity action: Starts the provisioning flow which sets up a managed profile.
  ///
  /// A managed profile allows data separation for example for the usage of a
  /// device as a personal and corporate device. The user which provisioning is started from and
  /// the managed profile share a launcher.
  ///
  /// This intent will typically be sent by a mobile device management application (MDM).
  /// Provisioning adds a managed profile and sets the MDM as the profile owner who has full
  /// control over the profile.
  ///
  /// It is possible to check if provisioning is allowed or not by querying the method
  /// \#isProvisioningAllowed(String).
  ///
  /// In version android.os.Build.VERSION_CODES\#LOLLIPOP, this intent must contain the
  /// extra \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME.
  /// As of android.os.Build.VERSION_CODES\#M, it should contain the extra
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME instead, although specifying only
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME is still supported.
  ///
  /// The intent may also contain the following extras:
  /// <ul>
  /// <li>\#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE, optional </li>
  /// <li>\#EXTRA_PROVISIONING_SKIP_ENCRYPTION, optional, supported from
  /// android.os.Build.VERSION_CODES\#N</li>
  /// <li>\#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LOGO_URI, optional</li>
  /// <li>\#EXTRA_PROVISIONING_MAIN_COLOR, optional</li>
  /// <li>\#EXTRA_PROVISIONING_SKIP_USER_CONSENT, optional</li>
  /// <li>\#EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION, optional</li>
  /// <li>\#EXTRA_PROVISIONING_DISCLAIMERS, optional</li>
  /// </ul>
  ///
  /// When managed provisioning has completed, broadcasts are sent to the application specified
  /// in the provisioning intent. The
  /// DeviceAdminReceiver\#ACTION_PROFILE_PROVISIONING_COMPLETE broadcast is sent in the
  /// managed profile and the \#ACTION_MANAGED_PROFILE_PROVISIONED broadcast is sent in
  /// the primary profile.
  ///
  /// From version android.os.Build.VERSION_CODES\#O, when managed provisioning has
  /// completed, along with the above broadcast, activity intent
  /// \#ACTION_PROVISIONING_SUCCESSFUL will also be sent to the profile owner.
  ///
  /// If provisioning fails, the managedProfile is removed so the device returns to its
  /// previous state.
  ///
  /// If launched with android.app.Activity\#startActivityForResult(Intent, int) a
  /// result code of android.app.Activity\#RESULT_OK implies that the synchronous part of
  /// the provisioning flow was successful, although this doesn't guarantee the full flow will
  /// succeed. Conversely a result code of android.app.Activity\#RESULT_CANCELED implies
  /// that the user backed-out of provisioning, or some precondition for provisioning wasn't met.
  static const ACTION_PROVISION_MANAGED_PROFILE =
      "android.app.action.PROVISION_MANAGED_PROFILE";

  /// from: static public final java.lang.String ACTION_SET_NEW_PARENT_PROFILE_PASSWORD
  ///
  /// Activity action: have the user enter a new password for the parent profile.
  /// If the intent is launched from within a managed profile, this will trigger
  /// entering a new password for the parent of the profile. In all other cases
  /// the behaviour is identical to \#ACTION_SET_NEW_PASSWORD.
  static const ACTION_SET_NEW_PARENT_PROFILE_PASSWORD =
      "android.app.action.SET_NEW_PARENT_PROFILE_PASSWORD";

  /// from: static public final java.lang.String ACTION_SET_NEW_PASSWORD
  ///
  /// Activity action: have the user enter a new password. This activity should
  /// be launched after using \#setPasswordQuality(ComponentName, int),
  /// or \#setPasswordMinimumLength(ComponentName, int) to have the user
  /// enter a new password that meets the current requirements. You can use
  /// \#isActivePasswordSufficient() to determine whether you need to
  /// have the user select a new password in order to meet the current
  /// constraints. Upon being resumed from this activity, you can check the new
  /// password characteristics to see if they are sufficient.
  ///
  /// If the intent is launched from within a managed profile with a profile
  /// owner built against android.os.Build.VERSION_CODES\#M or before,
  /// this will trigger entering a new password for the parent of the profile.
  /// For all other cases it will trigger entering a new password for the user
  /// or profile it is launched from.
  ///@see \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD
  static const ACTION_SET_NEW_PASSWORD = "android.app.action.SET_NEW_PASSWORD";

  /// from: static public final java.lang.String ACTION_START_ENCRYPTION
  ///
  /// Activity action: begin the process of encrypting data on the device.  This activity should
  /// be launched after using \#setStorageEncryption to request encryption be activated.
  /// After resuming from this activity, use \#getStorageEncryption
  /// to check encryption status.  However, on some devices this activity may never return, as
  /// it may trigger a reboot and in some cases a complete data wipe of the device.
  static const ACTION_START_ENCRYPTION = "android.app.action.START_ENCRYPTION";

  /// from: static public final java.lang.String ACTION_SYSTEM_UPDATE_POLICY_CHANGED
  ///
  /// Broadcast action: notify that a new local system update policy has been set by the device
  /// owner. The new policy can be retrieved by \#getSystemUpdatePolicy().
  static const ACTION_SYSTEM_UPDATE_POLICY_CHANGED =
      "android.app.action.SYSTEM_UPDATE_POLICY_CHANGED";

  /// from: static public final java.lang.String DELEGATION_APP_RESTRICTIONS
  ///
  /// Delegation of application restrictions management. This scope grants access to the
  /// \#setApplicationRestrictions and \#getApplicationRestrictions APIs.
  static const DELEGATION_APP_RESTRICTIONS = "delegation-app-restrictions";

  /// from: static public final java.lang.String DELEGATION_BLOCK_UNINSTALL
  ///
  /// Delegation of application uninstall block. This scope grants access to the
  /// \#setUninstallBlocked API.
  static const DELEGATION_BLOCK_UNINSTALL = "delegation-block-uninstall";

  /// from: static public final java.lang.String DELEGATION_CERT_INSTALL
  ///
  /// Delegation of certificate installation and management. This scope grants access to the
  /// \#getInstalledCaCerts, \#hasCaCertInstalled, \#installCaCert,
  /// \#uninstallCaCert, \#uninstallAllUserCaCerts and \#installKeyPair APIs.
  static const DELEGATION_CERT_INSTALL = "delegation-cert-install";

  /// from: static public final java.lang.String DELEGATION_ENABLE_SYSTEM_APP
  ///
  /// Delegation for enabling system apps. This scope grants access to the \#enableSystemApp
  /// API.
  static const DELEGATION_ENABLE_SYSTEM_APP = "delegation-enable-system-app";

  /// from: static public final java.lang.String DELEGATION_INSTALL_EXISTING_PACKAGE
  ///
  /// Delegation for installing existing packages. This scope grants access to the
  /// \#installExistingPackage API.
  static const DELEGATION_INSTALL_EXISTING_PACKAGE =
      "delegation-install-existing-package";

  /// from: static public final java.lang.String DELEGATION_KEEP_UNINSTALLED_PACKAGES
  ///
  /// Delegation of management of uninstalled packages. This scope grants access to the
  /// {@code \#setKeepUninstalledPackages} and {@code \#getKeepUninstalledPackages} APIs.
  static const DELEGATION_KEEP_UNINSTALLED_PACKAGES =
      "delegation-keep-uninstalled-packages";

  /// from: static public final java.lang.String DELEGATION_PACKAGE_ACCESS
  ///
  /// Delegation of package access state. This scope grants access to the
  /// \#isApplicationHidden, \#setApplicationHidden, \#isPackageSuspended, and
  /// \#setPackagesSuspended APIs.
  static const DELEGATION_PACKAGE_ACCESS = "delegation-package-access";

  /// from: static public final java.lang.String DELEGATION_PERMISSION_GRANT
  ///
  /// Delegation of permission policy and permission grant state. This scope grants access to the
  /// \#setPermissionPolicy, \#getPermissionGrantState,
  /// and \#setPermissionGrantState APIs.
  static const DELEGATION_PERMISSION_GRANT = "delegation-permission-grant";

  /// from: static public final int ENCRYPTION_STATUS_ACTIVATING
  ///
  /// Result code for \#getStorageEncryptionStatus:
  /// indicating that encryption is not currently active, but is currently
  /// being activated.  This is only reported by devices that support
  /// encryption of data and only when the storage is currently
  /// undergoing a process of becoming encrypted.  A device that must reboot and/or wipe data
  /// to become encrypted will never return this value.
  static const ENCRYPTION_STATUS_ACTIVATING = 2;

  /// from: static public final int ENCRYPTION_STATUS_ACTIVE
  ///
  /// Result code for \#setStorageEncryption and \#getStorageEncryptionStatus:
  /// indicating that encryption is active.
  ///
  /// Also see \#ENCRYPTION_STATUS_ACTIVE_PER_USER.
  static const ENCRYPTION_STATUS_ACTIVE = 3;

  /// from: static public final int ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY
  ///
  /// Result code for \#getStorageEncryptionStatus:
  /// indicating that encryption is active, but an encryption key has not
  /// been set by the user.
  static const ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY = 4;

  /// from: static public final int ENCRYPTION_STATUS_ACTIVE_PER_USER
  ///
  /// Result code for \#getStorageEncryptionStatus:
  /// indicating that encryption is active and the encryption key is tied to the user or profile.
  ///
  /// This value is only returned to apps targeting API level 24 and above. For apps targeting
  /// earlier API levels, \#ENCRYPTION_STATUS_ACTIVE is returned, even if the
  /// encryption key is specific to the user or profile.
  static const ENCRYPTION_STATUS_ACTIVE_PER_USER = 5;

  /// from: static public final int ENCRYPTION_STATUS_INACTIVE
  ///
  /// Result code for \#setStorageEncryption and \#getStorageEncryptionStatus:
  /// indicating that encryption is supported, but is not currently active.
  static const ENCRYPTION_STATUS_INACTIVE = 1;

  /// from: static public final int ENCRYPTION_STATUS_UNSUPPORTED
  ///
  /// Result code for \#setStorageEncryption and \#getStorageEncryptionStatus:
  /// indicating that encryption is not supported.
  static const ENCRYPTION_STATUS_UNSUPPORTED = 0;

  /// from: static public final java.lang.String EXTRA_ADD_EXPLANATION
  ///
  /// An optional CharSequence providing additional explanation for why the
  /// admin is being added.
  ///@see \#ACTION_ADD_DEVICE_ADMIN
  static const EXTRA_ADD_EXPLANATION = "android.app.extra.ADD_EXPLANATION";

  /// from: static public final java.lang.String EXTRA_DELEGATION_SCOPES
  ///
  /// An {@code ArrayList<String>} corresponding to the delegation scopes given to an app in the
  /// \#ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED broadcast.
  static const EXTRA_DELEGATION_SCOPES = "android.app.extra.DELEGATION_SCOPES";

  /// from: static public final java.lang.String EXTRA_DEVICE_ADMIN
  ///
  /// The ComponentName of the administrator component.
  ///@see \#ACTION_ADD_DEVICE_ADMIN
  static const EXTRA_DEVICE_ADMIN = "android.app.extra.DEVICE_ADMIN";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE
  ///
  /// An android.accounts.Account extra holding the account to migrate during managed
  /// profile provisioning. If the account supplied is present in the primary user, it will be
  /// copied, along with its credentials to the managed profile and removed from the primary user.
  ///
  /// Use with \#ACTION_PROVISION_MANAGED_PROFILE.
  static const EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE =
      "android.app.extra.PROVISIONING_ACCOUNT_TO_MIGRATE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE
  ///
  /// A android.os.Parcelable extra of type android.os.PersistableBundle that
  /// allows a mobile device management application or NFC programmer application which starts
  /// managed provisioning to pass data to the management application instance after provisioning.
  ///
  /// If used with \#ACTION_PROVISION_MANAGED_PROFILE it can be used by the application that
  /// sends the intent to pass data to itself on the newly created profile.
  /// If used with \#ACTION_PROVISION_MANAGED_DEVICE it allows passing data to the same
  /// instance of the app on the primary user.
  /// Starting from android.os.Build.VERSION_CODES\#M, if used with
  /// \#MIME_TYPE_PROVISIONING_NFC as part of NFC managed device provisioning, the NFC
  /// message should contain a stringified java.util.Properties instance, whose string
  /// properties will be converted into a android.os.PersistableBundle and passed to the
  /// management application after provisioning.
  ///
  ///
  /// In both cases the application receives the data in
  /// DeviceAdminReceiver\#onProfileProvisioningComplete via an intent with the action
  /// DeviceAdminReceiver\#ACTION_PROFILE_PROVISIONING_COMPLETE. The bundle is not changed
  /// during the managed provisioning.
  static const EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE =
      "android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME
  ///
  /// A ComponentName extra indicating the device admin receiver of the mobile device management
  /// application that will be set as the profile owner or device owner and active admin.
  ///
  /// If an application starts provisioning directly via an intent with action
  /// \#ACTION_PROVISION_MANAGED_PROFILE or
  /// \#ACTION_PROVISION_MANAGED_DEVICE the package name of this
  /// component has to match the package name of the application that started provisioning.
  ///
  /// This component is set as device owner and active admin when device owner provisioning is
  /// started by an intent with action \#ACTION_PROVISION_MANAGED_DEVICE or by an NFC
  /// message containing an NFC record with MIME type
  /// \#MIME_TYPE_PROVISIONING_NFC. For the NFC record, the component name must be
  /// flattened to a string, via ComponentName\#flattenToShortString().
  ///@see DeviceAdminReceiver
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE
  ///
  /// An int extra holding a minimum required version code for the device admin package. If the
  /// device admin is already installed on the device, it will only be re-downloaded from
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION if the version of the
  /// installed package is less than this version code.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM
  ///
  /// A String extra holding the URL-safe base64 encoded SHA-256 or SHA-1 hash (see notes below) of
  /// the file at download location specified in
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION.
  ///
  /// Either this extra or \#EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM must be
  /// present. The provided checksum must match the checksum of the file at the download
  /// location. If the checksum doesn't match an error will be shown to the user and the user will
  /// be asked to factory reset the device.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  ///
  /// <strong>Note:</strong> for devices running android.os.Build.VERSION_CODES\#LOLLIPOP
  /// and android.os.Build.VERSION_CODES\#LOLLIPOP_MR1 only SHA-1 hash is supported.
  /// Starting from android.os.Build.VERSION_CODES\#M, this parameter accepts SHA-256 in
  /// addition to SHA-1. Support for SHA-1 is likely to be removed in future OS releases.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER
  ///
  /// A String extra holding a http cookie header which should be used in the http request to the
  /// url specified in \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION
  ///
  /// A String extra holding a url that specifies the download location of the device admin
  /// package. When not provided it is assumed that the device admin package is already installed.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME
  ///
  /// A String extra holding the package name of the mobile device management application that
  /// will be set as the profile owner or device owner.
  ///
  /// If an application starts provisioning directly via an intent with action
  /// \#ACTION_PROVISION_MANAGED_PROFILE this package has to match the package name of the
  /// application that started provisioning. The package will be set as profile owner in that case.
  ///
  /// This package is set as device owner when device owner provisioning is started by an NFC
  /// message containing an NFC record with MIME type \#MIME_TYPE_PROVISIONING_NFC.
  ///
  ///  When this extra is set, the application must have exactly one device admin receiver.
  /// This receiver will be set as the profile or device owner and active admin.
  ///@see DeviceAdminReceiver
  ///@deprecated Use \#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME. This extra is still
  /// supported, but only if there is only one device admin receiver in the package that requires
  /// the permission android.Manifest.permission\#BIND_DEVICE_ADMIN.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM
  ///
  /// A String extra holding the URL-safe base64 encoded SHA-256 checksum of any signature of the
  /// android package archive at the download location specified in \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION.
  ///
  /// The signatures of an android package archive can be obtained using
  /// android.content.pm.PackageManager\#getPackageArchiveInfo with flag
  /// android.content.pm.PackageManager\#GET_SIGNATURES.
  ///
  /// Either this extra or \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM must be
  /// present. The provided checksum must match the checksum of any signature of the file at
  /// the download location. If the checksum does not match an error will be shown to the user and
  /// the user will be asked to factory reset the device.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DISCLAIMERS
  ///
  /// A Bundle[] extra consisting of list of disclaimer headers and disclaimer contents.
  /// Each Bundle must have both \#EXTRA_PROVISIONING_DISCLAIMER_HEADER
  /// as disclaimer header, and \#EXTRA_PROVISIONING_DISCLAIMER_CONTENT as disclaimer
  /// content.
  ///
  ///  The extra typically contains one disclaimer from the company of mobile device
  /// management application (MDM), and one disclaimer from the organization.
  ///
  ///  Call Bundle\#putParcelableArray(String, Parcelable[]) to put the Bundle[]
  ///
  ///  Maximum 3 key-value pairs can be specified. The rest will be ignored.
  ///
  ///  Use in an intent with action \#ACTION_PROVISION_MANAGED_PROFILE or
  /// \#ACTION_PROVISION_MANAGED_DEVICE
  static const EXTRA_PROVISIONING_DISCLAIMERS =
      "android.app.extra.PROVISIONING_DISCLAIMERS";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DISCLAIMER_CONTENT
  ///
  /// A Uri extra pointing to disclaimer content.
  ///
  /// <h5>The following URI schemes are accepted:</h5>
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// </ul>
  ///
  ///  Styled text is supported in the disclaimer content. The content is parsed by
  /// android.text.Html\#fromHtml(String) and displayed in a
  /// android.widget.TextView.
  ///
  ///  If a <code>content:</code> URI is passed, URI is passed, the intent should have the flag
  /// Intent\#FLAG_GRANT_READ_URI_PERMISSION and the uri should be added to the
  /// android.content.ClipData of the intent too.
  ///
  ///  Use in Bundle \#EXTRA_PROVISIONING_DISCLAIMERS
  ///
  ///  System app, i.e. application with ApplicationInfo\#FLAG_SYSTEM, can also insert a
  /// disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.
  /// Must use it with \#EXTRA_PROVISIONING_DISCLAIMER_HEADER. Here is the example:
  ///
  /// <pre>
  ///  &lt;meta-data
  ///      android:name="android.app.extra.PROVISIONING_DISCLAIMER_CONTENT"
  ///      android:resource="@string/disclaimer_content"
  /// /&gt;</pre>
  static const EXTRA_PROVISIONING_DISCLAIMER_CONTENT =
      "android.app.extra.PROVISIONING_DISCLAIMER_CONTENT";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DISCLAIMER_HEADER
  ///
  /// A String extra of localized disclaimer header.
  ///
  ///  The extra is typically the company name of mobile device management application (MDM)
  /// or the organization name.
  ///
  ///  Use in Bundle \#EXTRA_PROVISIONING_DISCLAIMERS
  ///
  ///  System app, i.e. application with ApplicationInfo\#FLAG_SYSTEM, can also insert a
  /// disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.
  /// Must use it with \#EXTRA_PROVISIONING_DISCLAIMER_CONTENT. Here is the example:
  ///
  /// <pre>
  ///  &lt;meta-data
  ///      android:name="android.app.extra.PROVISIONING_DISCLAIMER_HEADER"
  ///      android:resource="@string/disclaimer_header"
  /// /&gt;</pre>
  static const EXTRA_PROVISIONING_DISCLAIMER_HEADER =
      "android.app.extra.PROVISIONING_DISCLAIMER_HEADER";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_EMAIL_ADDRESS
  ///
  /// @deprecated From android.os.Build.VERSION_CODES\#O, never used while provisioning the
  /// device.
  static const EXTRA_PROVISIONING_EMAIL_ADDRESS =
      "android.app.extra.PROVISIONING_EMAIL_ADDRESS";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION
  ///
  /// Boolean extra to indicate that the migrated account should be kept. This is used in
  /// conjunction with \#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE. If it's set to {@code true},
  /// the account will not be removed from the primary user after it is migrated to the newly
  /// created user or profile.
  ///
  ///  Defaults to {@code false}
  ///
  ///  Use with \#ACTION_PROVISION_MANAGED_PROFILE and
  /// \#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE
  static const EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION =
      "android.app.extra.PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED
  ///
  /// A Boolean extra that can be used by the mobile device management application to skip the
  /// disabling of system apps during provisioning when set to {@code true}.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC or an intent with action
  /// \#ACTION_PROVISION_MANAGED_DEVICE that starts device owner provisioning.
  static const EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED =
      "android.app.extra.PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_LOCALE
  ///
  /// A String extra holding the java.util.Locale that the device will be set to.
  /// Format: xx_yy, where xx is the language code, and yy the country code.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_LOCALE =
      "android.app.extra.PROVISIONING_LOCALE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_LOCAL_TIME
  ///
  /// A Long extra holding the wall clock time (in milliseconds) to be set on the device's
  /// android.app.AlarmManager.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_LOCAL_TIME =
      "android.app.extra.PROVISIONING_LOCAL_TIME";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_LOGO_URI
  ///
  /// A Uri extra pointing to a logo image. This image will be shown during the
  /// provisioning. If this extra is not passed, a default image will be shown.
  /// <h5>The following URI schemes are accepted:</h5>
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// </ul>
  ///
  ///  It is the responsibility of the caller to provide an image with a reasonable
  /// pixel density for the device.
  ///
  ///  If a content: URI is passed, the intent should have the flag
  /// Intent\#FLAG_GRANT_READ_URI_PERMISSION and the uri should be added to the
  /// android.content.ClipData of the intent too.
  ///
  /// Use in an intent with action \#ACTION_PROVISION_MANAGED_PROFILE or
  /// \#ACTION_PROVISION_MANAGED_DEVICE
  static const EXTRA_PROVISIONING_LOGO_URI =
      "android.app.extra.PROVISIONING_LOGO_URI";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_MAIN_COLOR
  ///
  /// A integer extra indicating the predominant color to show during the provisioning.
  /// Refer to android.graphics.Color for how the color is represented.
  ///
  /// Use with \#ACTION_PROVISION_MANAGED_PROFILE or
  /// \#ACTION_PROVISION_MANAGED_DEVICE.
  static const EXTRA_PROVISIONING_MAIN_COLOR =
      "android.app.extra.PROVISIONING_MAIN_COLOR";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_SKIP_ENCRYPTION
  ///
  /// A boolean extra indicating whether device encryption can be skipped as part of device owner
  /// or managed profile provisioning.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC or an intent with action
  /// \#ACTION_PROVISION_MANAGED_DEVICE that starts device owner provisioning.
  ///
  /// From android.os.Build.VERSION_CODES\#N onwards, this is also supported for an
  /// intent with action \#ACTION_PROVISION_MANAGED_PROFILE.
  static const EXTRA_PROVISIONING_SKIP_ENCRYPTION =
      "android.app.extra.PROVISIONING_SKIP_ENCRYPTION";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_SKIP_USER_CONSENT
  ///
  /// A boolean extra indicating if the user consent steps from the provisioning flow should be
  /// skipped. If unspecified, defaults to {@code false}.
  ///
  /// It can only be used by an existing device owner trying to create a managed profile via
  /// \#ACTION_PROVISION_MANAGED_PROFILE. Otherwise it is ignored.
  static const EXTRA_PROVISIONING_SKIP_USER_CONSENT =
      "android.app.extra.PROVISIONING_SKIP_USER_CONSENT";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_TIME_ZONE
  ///
  /// A String extra holding the time zone android.app.AlarmManager that the device
  /// will be set to.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_TIME_ZONE =
      "android.app.extra.PROVISIONING_TIME_ZONE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_HIDDEN
  ///
  /// A boolean extra indicating whether the wifi network in \#EXTRA_PROVISIONING_WIFI_SSID
  /// is hidden or not.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_HIDDEN =
      "android.app.extra.PROVISIONING_WIFI_HIDDEN";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PAC_URL
  ///
  /// A String extra holding the proxy auto-config (PAC) URL for the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PAC_URL =
      "android.app.extra.PROVISIONING_WIFI_PAC_URL";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PASSWORD
  ///
  /// A String extra holding the password of the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PASSWORD =
      "android.app.extra.PROVISIONING_WIFI_PASSWORD";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PROXY_BYPASS
  ///
  /// A String extra holding the proxy bypass for the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PROXY_BYPASS =
      "android.app.extra.PROVISIONING_WIFI_PROXY_BYPASS";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PROXY_HOST
  ///
  /// A String extra holding the proxy host for the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PROXY_HOST =
      "android.app.extra.PROVISIONING_WIFI_PROXY_HOST";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PROXY_PORT
  ///
  /// An int extra holding the proxy port for the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PROXY_PORT =
      "android.app.extra.PROVISIONING_WIFI_PROXY_PORT";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_SECURITY_TYPE
  ///
  /// A String extra indicating the security type of the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID and could be one of {@code NONE}, {@code WPA} or
  /// {@code WEP}.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_SECURITY_TYPE =
      "android.app.extra.PROVISIONING_WIFI_SECURITY_TYPE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_SSID
  ///
  /// A String extra holding the ssid of the wifi network that should be used during nfc device
  /// owner provisioning for downloading the mobile device management application.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_SSID =
      "android.app.extra.PROVISIONING_WIFI_SSID";

  /// from: static public final int FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY
  ///
  /// Flag for \#lockNow(int): also evict the user's credential encryption key from the
  /// keyring. The user's credential will need to be entered again in order to derive the
  /// credential encryption key that will be stored back in the keyring for future use.
  ///
  /// This flag can only be used by a profile owner when locking a managed profile when
  /// \#getStorageEncryptionStatus returns \#ENCRYPTION_STATUS_ACTIVE_PER_USER.
  ///
  /// In order to secure user data, the user will be stopped and restarted so apps should wait
  /// until they are next run to perform further actions.
  static const FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY = 1;

  /// from: static public final int FLAG_MANAGED_CAN_ACCESS_PARENT
  ///
  /// Flag used by \#addCrossProfileIntentFilter to allow activities in
  /// the managed profile to access intents sent from the parent profile.
  /// That is, when an app in the parent profile calls
  /// Activity\#startActivity(Intent), the intent can be resolved by a
  /// matching activity in the managed profile.
  static const FLAG_MANAGED_CAN_ACCESS_PARENT = 2;

  /// from: static public final int FLAG_PARENT_CAN_ACCESS_MANAGED
  ///
  /// Flag used by \#addCrossProfileIntentFilter to allow activities in
  /// the parent profile to access intents sent from the managed profile.
  /// That is, when an app in the managed profile calls
  /// Activity\#startActivity(Intent), the intent can be resolved by a
  /// matching activity in the parent profile.
  static const FLAG_PARENT_CAN_ACCESS_MANAGED = 1;

  /// from: static public final int ID_TYPE_BASE_INFO
  ///
  /// Specifies that the device should attest its manufacturer details. For use with
  /// \#generateKeyPair.
  ///@see \#generateKeyPair
  static const ID_TYPE_BASE_INFO = 1;

  /// from: static public final int ID_TYPE_IMEI
  ///
  /// Specifies that the device should attest its IMEI. For use with \#generateKeyPair.
  ///@see \#generateKeyPair
  static const ID_TYPE_IMEI = 4;

  /// from: static public final int ID_TYPE_MEID
  ///
  /// Specifies that the device should attest its MEID. For use with \#generateKeyPair.
  ///@see \#generateKeyPair
  static const ID_TYPE_MEID = 8;

  /// from: static public final int ID_TYPE_SERIAL
  ///
  /// Specifies that the device should attest its serial number. For use with
  /// \#generateKeyPair.
  ///@see \#generateKeyPair
  static const ID_TYPE_SERIAL = 2;

  /// from: static public final int INSTALLKEY_REQUEST_CREDENTIALS_ACCESS
  ///
  /// Specifies that the calling app should be granted access to the installed credentials
  /// immediately. Otherwise, access to the credentials will be gated by user approval.
  /// For use with \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
  ///@see \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
  static const INSTALLKEY_REQUEST_CREDENTIALS_ACCESS = 1;

  /// from: static public final int INSTALLKEY_SET_USER_SELECTABLE
  ///
  /// Specifies that a user can select the key via the Certificate Selection prompt.
  /// If this flag is not set when calling \#installKeyPair, the key can only be granted
  /// access by implementing android.app.admin.DeviceAdminReceiver\#onChoosePrivateKeyAlias.
  /// For use with \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
  ///@see \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
  static const INSTALLKEY_SET_USER_SELECTABLE = 2;

  /// from: static public final int KEYGUARD_DISABLE_BIOMETRICS
  ///
  /// Disable all biometric authentication on keyguard secure screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_BIOMETRICS = 416;

  /// from: static public final int KEYGUARD_DISABLE_FACE
  ///
  /// Disable face authentication on keyguard secure screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_FACE = 128;

  /// from: static public final int KEYGUARD_DISABLE_FEATURES_ALL
  ///
  /// Disable all current and future keyguard customizations.
  static const KEYGUARD_DISABLE_FEATURES_ALL = 2147483647;

  /// from: static public final int KEYGUARD_DISABLE_FEATURES_NONE
  ///
  /// Widgets are enabled in keyguard
  static const KEYGUARD_DISABLE_FEATURES_NONE = 0;

  /// from: static public final int KEYGUARD_DISABLE_FINGERPRINT
  ///
  /// Disable fingerprint authentication on keyguard secure screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_FINGERPRINT = 32;

  /// from: static public final int KEYGUARD_DISABLE_IRIS
  ///
  /// Disable iris authentication on keyguard secure screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_IRIS = 256;

  /// from: static public final int KEYGUARD_DISABLE_REMOTE_INPUT
  ///
  /// Disable text entry into notifications on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_REMOTE_INPUT = 64;

  /// from: static public final int KEYGUARD_DISABLE_SECURE_CAMERA
  ///
  /// Disable the camera on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password)
  static const KEYGUARD_DISABLE_SECURE_CAMERA = 2;

  /// from: static public final int KEYGUARD_DISABLE_SECURE_NOTIFICATIONS
  ///
  /// Disable showing all notifications on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password)
  static const KEYGUARD_DISABLE_SECURE_NOTIFICATIONS = 4;

  /// from: static public final int KEYGUARD_DISABLE_TRUST_AGENTS
  ///
  /// Disable trust agents on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password).
  /// By setting this flag alone, all trust agents are disabled. If the admin then wants to
  /// whitelist specific features of some trust agent, \#setTrustAgentConfiguration can be
  /// used in conjuction to set trust-agent-specific configurations.
  static const KEYGUARD_DISABLE_TRUST_AGENTS = 16;

  /// from: static public final int KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS
  ///
  /// Only allow redacted notifications on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password)
  static const KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS = 8;

  /// from: static public final int KEYGUARD_DISABLE_WIDGETS_ALL
  ///
  /// Disable all keyguard widgets. Has no effect starting from
  /// android.os.Build.VERSION_CODES\#LOLLIPOP since keyguard widget is only supported
  /// on Android versions lower than 5.0.
  static const KEYGUARD_DISABLE_WIDGETS_ALL = 1;

  /// from: static public final int LEAVE_ALL_SYSTEM_APPS_ENABLED
  ///
  /// Flag used by \#createAndManageUser to specify that the newly created user should skip
  /// the disabling of system apps during provisioning.
  static const LEAVE_ALL_SYSTEM_APPS_ENABLED = 16;

  /// from: static public final int LOCK_TASK_FEATURE_GLOBAL_ACTIONS
  ///
  /// Enable the global actions dialog during LockTask mode. This is the dialog that shows up when
  /// the user long-presses the power button, for example. Note that the user may not be able to
  /// power off the device if this flag is not set.
  ///
  /// This flag is enabled by default until \#setLockTaskFeatures(ComponentName, int) is
  /// called for the first time.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_GLOBAL_ACTIONS = 16;

  /// from: static public final int LOCK_TASK_FEATURE_HOME
  ///
  /// Enable the Home button during LockTask mode. Note that if a custom launcher is used, it has
  /// to be registered as the default launcher with
  /// \#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName), and its
  /// package needs to be whitelisted for LockTask with
  /// \#setLockTaskPackages(ComponentName, String[]).
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_HOME = 4;

  /// from: static public final int LOCK_TASK_FEATURE_KEYGUARD
  ///
  /// Enable the keyguard during LockTask mode. Note that if the keyguard is already disabled with
  /// \#setKeyguardDisabled(ComponentName, boolean), setting this flag will have no effect.
  /// If this flag is not set, the keyguard will not be shown even if the user has a lock screen
  /// credential.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_KEYGUARD = 32;

  /// from: static public final int LOCK_TASK_FEATURE_NONE
  ///
  /// Disable all configurable SystemUI features during LockTask mode. This includes,
  /// <ul>
  ///     <li>system info area in the status bar (connectivity icons, clock, etc.)
  ///     <li>notifications (including alerts, icons, and the notification shade)
  ///     <li>Home button
  ///     <li>Recents button and UI
  ///     <li>global actions menu (i.e. power button menu)
  ///     <li>keyguard
  /// </ul>
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_NONE = 0;

  /// from: static public final int LOCK_TASK_FEATURE_NOTIFICATIONS
  ///
  /// Enable notifications during LockTask mode. This includes notification icons on the status
  /// bar, heads-up notifications, and the expandable notification shade. Note that the Quick
  /// Settings panel remains disabled. This feature flag can only be used in combination with
  /// \#LOCK_TASK_FEATURE_HOME. \#setLockTaskFeatures(ComponentName, int)
  /// throws an IllegalArgumentException if this feature flag is defined without
  /// \#LOCK_TASK_FEATURE_HOME.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_NOTIFICATIONS = 2;

  /// from: static public final int LOCK_TASK_FEATURE_OVERVIEW
  ///
  /// Enable the Overview button and the Overview screen during LockTask mode. This feature flag
  /// can only be used in combination with \#LOCK_TASK_FEATURE_HOME, and
  /// \#setLockTaskFeatures(ComponentName, int) will throw an
  /// IllegalArgumentException if this feature flag is defined without
  /// \#LOCK_TASK_FEATURE_HOME.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_OVERVIEW = 8;

  /// from: static public final int LOCK_TASK_FEATURE_SYSTEM_INFO
  ///
  /// Enable the system info area in the status bar during LockTask mode. The system info area
  /// usually occupies the right side of the status bar (although this can differ across OEMs). It
  /// includes all system information indicators, such as date and time, connectivity, battery,
  /// vibration mode, etc.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_SYSTEM_INFO = 1;

  /// from: static public final int MAKE_USER_EPHEMERAL
  ///
  /// Flag used by \#createAndManageUser to specify that the user should be created
  /// ephemeral. Ephemeral users will be removed after switching to another user or rebooting the
  /// device.
  static const MAKE_USER_EPHEMERAL = 2;

  /// from: static public final java.lang.String MIME_TYPE_PROVISIONING_NFC
  ///
  /// This MIME type is used for starting the device owner provisioning.
  ///
  /// During device owner provisioning a device admin app is set as the owner of the device.
  /// A device owner has full control over the device. The device owner can not be modified by the
  /// user and the only way of resetting the device is if the device owner app calls a factory
  /// reset.
  ///
  ///  A typical use case would be a device that is owned by a company, but used by either an
  /// employee or client.
  ///
  ///  The NFC message must be sent to an unprovisioned device.
  ///
  /// The NFC record must contain a serialized java.util.Properties object which
  /// contains the following properties:
  /// <ul>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME</li>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION, optional</li>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER, optional</li>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LOCAL_TIME (convert to String), optional</li>
  /// <li>\#EXTRA_PROVISIONING_TIME_ZONE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LOCALE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_SSID, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_HIDDEN (convert to String), optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PASSWORD, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PROXY_HOST, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PROXY_PORT (convert to String), optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PROXY_BYPASS, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PAC_URL, optional</li>
  /// <li>\#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE, optional, supported from
  /// android.os.Build.VERSION_CODES\#M </li></ul>
  ///
  ///
  /// As of android.os.Build.VERSION_CODES\#M, the properties should contain
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME instead of
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME, (although specifying only
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME is still supported).
  static const MIME_TYPE_PROVISIONING_NFC =
      "application/com.android.managedprovisioning";

  /// from: static public final int PASSWORD_QUALITY_ALPHABETIC
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least alphabetic (or other symbol) characters.
  /// Note that quality constants are ordered so that higher values are more
  /// restrictive.
  static const PASSWORD_QUALITY_ALPHABETIC = 262144;

  /// from: static public final int PASSWORD_QUALITY_ALPHANUMERIC
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least _both>_ numeric _and_
  /// alphabetic (or other symbol) characters.  Note that quality constants are
  /// ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_ALPHANUMERIC = 327680;

  /// from: static public final int PASSWORD_QUALITY_BIOMETRIC_WEAK
  ///
  /// Constant for \#setPasswordQuality: the policy allows for low-security biometric
  /// recognition technology.  This implies technologies that can recognize the identity of
  /// an individual to about a 3 digit PIN (false detection is less than 1 in 1,000).
  /// Note that quality constants are ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_BIOMETRIC_WEAK = 32768;

  /// from: static public final int PASSWORD_QUALITY_COMPLEX
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least a letter, a numerical digit and a special
  /// symbol, by default. With this password quality, passwords can be
  /// restricted to contain various sets of characters, like at least an
  /// uppercase letter, etc. These are specified using various methods,
  /// like \#setPasswordMinimumLowerCase(ComponentName, int). Note
  /// that quality constants are ordered so that higher values are more
  /// restrictive.
  static const PASSWORD_QUALITY_COMPLEX = 393216;

  /// from: static public final int PASSWORD_QUALITY_NUMERIC
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least numeric characters.  Note that quality
  /// constants are ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_NUMERIC = 131072;

  /// from: static public final int PASSWORD_QUALITY_NUMERIC_COMPLEX
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least numeric characters with no repeating (4444)
  /// or ordered (1234, 4321, 2468) sequences.  Note that quality
  /// constants are ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_NUMERIC_COMPLEX = 196608;

  /// from: static public final int PASSWORD_QUALITY_SOMETHING
  ///
  /// Constant for \#setPasswordQuality: the policy requires some kind
  /// of password or pattern, but doesn't care what it is. Note that quality constants
  /// are ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_SOMETHING = 65536;

  /// from: static public final int PASSWORD_QUALITY_UNSPECIFIED
  ///
  /// Constant for \#setPasswordQuality: the policy has no requirements
  /// for the password.  Note that quality constants are ordered so that higher
  /// values are more restrictive.
  static const PASSWORD_QUALITY_UNSPECIFIED = 0;

  /// from: static public final int PERMISSION_GRANT_STATE_DEFAULT
  ///
  /// Runtime permission state: The user can manage the permission
  /// through the UI.
  static const PERMISSION_GRANT_STATE_DEFAULT = 0;

  /// from: static public final int PERMISSION_GRANT_STATE_DENIED
  ///
  /// Runtime permission state: The permission is denied to the app
  /// and the user cannot manage the permission through the UI.
  static const PERMISSION_GRANT_STATE_DENIED = 2;

  /// from: static public final int PERMISSION_GRANT_STATE_GRANTED
  ///
  /// Runtime permission state: The permission is granted to the app
  /// and the user cannot manage the permission through the UI.
  static const PERMISSION_GRANT_STATE_GRANTED = 1;

  /// from: static public final int PERMISSION_POLICY_AUTO_DENY
  ///
  /// Permission policy to always deny new permission requests for runtime permissions.
  /// Already granted or denied permissions are not affected by this.
  static const PERMISSION_POLICY_AUTO_DENY = 2;

  /// from: static public final int PERMISSION_POLICY_AUTO_GRANT
  ///
  /// Permission policy to always grant new permission requests for runtime permissions.
  /// Already granted or denied permissions are not affected by this.
  static const PERMISSION_POLICY_AUTO_GRANT = 1;

  /// from: static public final int PERMISSION_POLICY_PROMPT
  ///
  /// Permission policy to prompt user for new permission requests for runtime permissions.
  /// Already granted or denied permissions are not affected by this.
  static const PERMISSION_POLICY_PROMPT = 0;

  /// from: static public final java.lang.String POLICY_DISABLE_CAMERA
  ///
  /// Constant to indicate the feature of disabling the camera. Used as argument to
  /// \#createAdminSupportIntent(String).
  ///@see \#setCameraDisabled(ComponentName, boolean)
  static const POLICY_DISABLE_CAMERA = "policy_disable_camera";

  /// from: static public final java.lang.String POLICY_DISABLE_SCREEN_CAPTURE
  ///
  /// Constant to indicate the feature of disabling screen captures. Used as argument to
  /// \#createAdminSupportIntent(String).
  ///@see \#setScreenCaptureDisabled(ComponentName, boolean)
  static const POLICY_DISABLE_SCREEN_CAPTURE = "policy_disable_screen_capture";

  /// from: static public final int RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT
  ///
  /// Flag for \#resetPasswordWithToken and \#resetPassword: don't ask for user
  /// credentials on device boot.
  /// If the flag is set, the device can be booted without asking for user password.
  /// The absence of this flag does not change the current boot requirements. This flag
  /// can be set by the device owner only. If the app is not the device owner, the flag
  /// is ignored. Once the flag is set, it cannot be reverted back without resetting the
  /// device to factory defaults.
  static const RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT = 2;

  /// from: static public final int RESET_PASSWORD_REQUIRE_ENTRY
  ///
  /// Flag for \#resetPasswordWithToken and \#resetPassword: don't allow other admins
  /// to change the password again until the user has entered it.
  static const RESET_PASSWORD_REQUIRE_ENTRY = 1;

  /// from: static public final int SKIP_SETUP_WIZARD
  ///
  /// Flag used by \#createAndManageUser to skip setup wizard after creating a new user.
  static const SKIP_SETUP_WIZARD = 1;

  /// from: static public final int WIPE_EUICC
  ///
  /// Flag for \#wipeData(int): also erase the device's eUICC data.
  static const WIPE_EUICC = 4;

  /// from: static public final int WIPE_EXTERNAL_STORAGE
  ///
  /// Flag for \#wipeData(int): also erase the device's external
  /// storage (such as SD cards).
  static const WIPE_EXTERNAL_STORAGE = 1;

  /// from: static public final int WIPE_RESET_PROTECTION_DATA
  ///
  /// Flag for \#wipeData(int): also erase the factory reset protection
  /// data.
  ///
  /// This flag may only be set by device owner admins; if it is set by
  /// other admins a SecurityException will be thrown.
  static const WIPE_RESET_PROTECTION_DATA = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DevicePolicyManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_isAdminActive = jniAccessors.getMethodIDOf(
      _classRef, "isAdminActive", "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isAdminActive(android.content.ComponentName admin)
  ///
  /// Return true if the given administrator component is currently active (enabled) in the system.
  ///@param admin The administrator component to check for.
  /// This value must never be {@code null}.
  ///@return {@code true} if {@code admin} is currently enabled in the system, {@code false}
  ///         otherwise
  bool isAdminActive(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isAdminActive,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_getActiveAdmins = jniAccessors.getMethodIDOf(
      _classRef, "getActiveAdmins", "()Ljava/util/List;");

  /// from: public java.util.List<android.content.ComponentName> getActiveAdmins()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of all currently active device administrators' component
  /// names.  If there are no administrators {@code null} may be
  /// returned.
  jni.JniObject getActiveAdmins() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActiveAdmins, jni.JniType.objectType, []).object);

  static final _id_removeActiveAdmin = jniAccessors.getMethodIDOf(
      _classRef, "removeActiveAdmin", "(Landroid/content/ComponentName;)V");

  /// from: public void removeActiveAdmin(android.content.ComponentName admin)
  ///
  /// Remove a current administration component.  This can only be called
  /// by the application that owns the administration component; if you
  /// try to remove someone else's component, a security exception will be
  /// thrown.
  ///
  /// Note that the operation is not synchronous and the admin might still be active (as
  /// indicated by \#getActiveAdmins()) by the time this method returns.
  ///@param admin The administration compononent to remove.
  /// This value must never be {@code null}.
  ///@throws SecurityException if the caller is not in the owner application of {@code admin}.
  void removeActiveAdmin(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeActiveAdmin,
          jni.JniType.voidType, [admin.reference]).check();

  static final _id_hasGrantedPolicy = jniAccessors.getMethodIDOf(
      _classRef, "hasGrantedPolicy", "(Landroid/content/ComponentName;I)Z");

  /// from: public boolean hasGrantedPolicy(android.content.ComponentName admin, int usesPolicy)
  ///
  /// Returns true if an administrator has been granted a particular device policy. This can be
  /// used to check whether the administrator was activated under an earlier set of policies, but
  /// requires additional policies after an upgrade.
  ///@param admin Which DeviceAdminReceiver this request is associated with. Must be an
  ///            active administrator, or an exception will be thrown.
  /// This value must never be {@code null}.
  ///@param usesPolicy Which uses-policy to check, as defined in DeviceAdminInfo.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  bool hasGrantedPolicy(componentname_.ComponentName admin, int usesPolicy) =>
      jniAccessors.callMethodWithArgs(reference, _id_hasGrantedPolicy,
          jni.JniType.booleanType, [admin.reference, usesPolicy]).boolean;

  static final _id_setPasswordQuality = jniAccessors.getMethodIDOf(
      _classRef, "setPasswordQuality", "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordQuality(android.content.ComponentName admin, int quality)
  ///
  /// Called by an application that is administering the device to set the password restrictions it
  /// is imposing. After setting this, the user will not be able to enter a new password that is
  /// not at least as restrictive as what has been set. Note that the current password will remain
  /// until the user has set a new one, so the change does not take place immediately. To prompt
  /// the user for a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after calling this method.
  ///
  /// Quality constants are ordered so that higher values are more restrictive; thus the highest
  /// requested quality constant (between the policy set here, the user's preference, and any other
  /// considerations) is the one that is in effect.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param quality The new desired quality. One of \#PASSWORD_QUALITY_UNSPECIFIED,
  ///            \#PASSWORD_QUALITY_SOMETHING, \#PASSWORD_QUALITY_NUMERIC,
  ///            \#PASSWORD_QUALITY_NUMERIC_COMPLEX, \#PASSWORD_QUALITY_ALPHABETIC,
  ///            \#PASSWORD_QUALITY_ALPHANUMERIC or \#PASSWORD_QUALITY_COMPLEX.
  ///@throws SecurityException if {@code admin} is not an active administrator or if {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordQuality(componentname_.ComponentName admin, int quality) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPasswordQuality,
          jni.JniType.voidType, [admin.reference, quality]).check();

  static final _id_getPasswordQuality = jniAccessors.getMethodIDOf(
      _classRef, "getPasswordQuality", "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordQuality(android.content.ComponentName admin)
  ///
  /// Retrieve the current minimum password quality for a particular admin or all admins that set
  /// restrictions on this user and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  ///
  /// This value may be {@code null}.
  int getPasswordQuality(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPasswordQuality,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_setPasswordMinimumLength = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordMinimumLength",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordMinimumLength(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum allowed password
  /// length. After setting this, the user will not be able to enter a new password that is not at
  /// least as restrictive as what has been set. Note that the current password will remain until
  /// the user has set a new one, so the change does not take place immediately. To prompt the user
  /// for a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
  /// only imposed if the administrator has also requested either \#PASSWORD_QUALITY_NUMERIC
  /// , \#PASSWORD_QUALITY_NUMERIC_COMPLEX, \#PASSWORD_QUALITY_ALPHABETIC,
  /// \#PASSWORD_QUALITY_ALPHANUMERIC, or \#PASSWORD_QUALITY_COMPLEX with
  /// \#setPasswordQuality.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum password length. A value of 0 means there is no
  ///            restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumLength(
          componentname_.ComponentName admin, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPasswordMinimumLength,
          jni.JniType.voidType, [admin.reference, length]).check();

  static final _id_getPasswordMinimumLength = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordMinimumLength",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordMinimumLength(android.content.ComponentName admin)
  ///
  /// Retrieve the current minimum password length for a particular admin or all admins that set
  /// restrictions on this user and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///
  /// user and its profiles or a particular one.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  ///
  /// This value may be {@code null}.
  int getPasswordMinimumLength(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPasswordMinimumLength,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_setPasswordMinimumUpperCase = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordMinimumUpperCase",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordMinimumUpperCase(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of upper
  /// case letters required in the password. After setting this, the user will not be able to enter
  /// a new password that is not at least as restrictive as what has been set. Note that the
  /// current password will remain until the user has set a new one, so the change does not take
  /// place immediately. To prompt the user for a new password, use
  /// \#ACTION_SET_NEW_PASSWORD or \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
  /// setting this value. This constraint is only imposed if the administrator has also requested
  /// \#PASSWORD_QUALITY_COMPLEX with \#setPasswordQuality. The default value is 0.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of upper case letters required in the password.
  ///            A value of 0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumUpperCase(
          componentname_.ComponentName admin, int length) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPasswordMinimumUpperCase,
          jni.JniType.voidType,
          [admin.reference, length]).check();

  static final _id_getPasswordMinimumUpperCase = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordMinimumUpperCase",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordMinimumUpperCase(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of upper case letters required in the password
  /// for a particular admin or all admins that set restrictions on this user and
  /// its participating profiles. Restrictions on profiles that have a separate challenge
  /// are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumUpperCase(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of upper case letters required in the
  ///         password.
  int getPasswordMinimumUpperCase(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPasswordMinimumUpperCase,
          jni.JniType.intType,
          [admin.reference]).integer;

  static final _id_setPasswordMinimumLowerCase = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordMinimumLowerCase",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordMinimumLowerCase(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of lower
  /// case letters required in the password. After setting this, the user will not be able to enter
  /// a new password that is not at least as restrictive as what has been set. Note that the
  /// current password will remain until the user has set a new one, so the change does not take
  /// place immediately. To prompt the user for a new password, use
  /// \#ACTION_SET_NEW_PASSWORD or \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
  /// setting this value. This constraint is only imposed if the administrator has also requested
  /// \#PASSWORD_QUALITY_COMPLEX with \#setPasswordQuality. The default value is 0.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of lower case letters required in the password.
  ///            A value of 0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumLowerCase(
          componentname_.ComponentName admin, int length) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPasswordMinimumLowerCase,
          jni.JniType.voidType,
          [admin.reference, length]).check();

  static final _id_getPasswordMinimumLowerCase = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordMinimumLowerCase",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordMinimumLowerCase(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of lower case letters required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumLowerCase(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of lower case letters required in the
  ///         password.
  int getPasswordMinimumLowerCase(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPasswordMinimumLowerCase,
          jni.JniType.intType,
          [admin.reference]).integer;

  static final _id_setPasswordMinimumLetters = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordMinimumLetters",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordMinimumLetters(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of
  /// letters required in the password. After setting this, the user will not be able to enter a
  /// new password that is not at least as restrictive as what has been set. Note that the current
  /// password will remain until the user has set a new one, so the change does not take place
  /// immediately. To prompt the user for a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
  /// only imposed if the administrator has also requested \#PASSWORD_QUALITY_COMPLEX with
  /// \#setPasswordQuality. The default value is 1.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of letters required in the password. A value of
  ///            0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumLetters(
          componentname_.ComponentName admin, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPasswordMinimumLetters,
          jni.JniType.voidType, [admin.reference, length]).check();

  static final _id_getPasswordMinimumLetters = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordMinimumLetters",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordMinimumLetters(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of letters required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumLetters(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of letters required in the password.
  int getPasswordMinimumLetters(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPasswordMinimumLetters,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_setPasswordMinimumNumeric = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordMinimumNumeric",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordMinimumNumeric(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of
  /// numerical digits required in the password. After setting this, the user will not be able to
  /// enter a new password that is not at least as restrictive as what has been set. Note that the
  /// current password will remain until the user has set a new one, so the change does not take
  /// place immediately. To prompt the user for a new password, use
  /// \#ACTION_SET_NEW_PASSWORD or \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
  /// setting this value. This constraint is only imposed if the administrator has also requested
  /// \#PASSWORD_QUALITY_COMPLEX with \#setPasswordQuality. The default value is 1.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of numerical digits required in the password. A
  ///            value of 0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumNumeric(
          componentname_.ComponentName admin, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPasswordMinimumNumeric,
          jni.JniType.voidType, [admin.reference, length]).check();

  static final _id_getPasswordMinimumNumeric = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordMinimumNumeric",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordMinimumNumeric(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of numerical digits required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumNumeric(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of numerical digits required in the password.
  int getPasswordMinimumNumeric(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPasswordMinimumNumeric,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_setPasswordMinimumSymbols = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordMinimumSymbols",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordMinimumSymbols(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of
  /// symbols required in the password. After setting this, the user will not be able to enter a
  /// new password that is not at least as restrictive as what has been set. Note that the current
  /// password will remain until the user has set a new one, so the change does not take place
  /// immediately. To prompt the user for a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
  /// only imposed if the administrator has also requested \#PASSWORD_QUALITY_COMPLEX with
  /// \#setPasswordQuality. The default value is 1.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of symbols required in the password. A value of
  ///            0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumSymbols(
          componentname_.ComponentName admin, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPasswordMinimumSymbols,
          jni.JniType.voidType, [admin.reference, length]).check();

  static final _id_getPasswordMinimumSymbols = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordMinimumSymbols",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordMinimumSymbols(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of symbols required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account. This is the same value as
  /// set by \#setPasswordMinimumSymbols(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of symbols required in the password.
  int getPasswordMinimumSymbols(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPasswordMinimumSymbols,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_setPasswordMinimumNonLetter = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordMinimumNonLetter",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordMinimumNonLetter(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of
  /// non-letter characters (numerical digits or symbols) required in the password. After setting
  /// this, the user will not be able to enter a new password that is not at least as restrictive
  /// as what has been set. Note that the current password will remain until the user has set a new
  /// one, so the change does not take place immediately. To prompt the user for a new password,
  /// use \#ACTION_SET_NEW_PASSWORD or \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
  /// setting this value. This constraint is only imposed if the administrator has also requested
  /// \#PASSWORD_QUALITY_COMPLEX with \#setPasswordQuality. The default value is 0.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of letters required in the password. A value of
  ///            0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumNonLetter(
          componentname_.ComponentName admin, int length) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPasswordMinimumNonLetter,
          jni.JniType.voidType,
          [admin.reference, length]).check();

  static final _id_getPasswordMinimumNonLetter = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordMinimumNonLetter",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordMinimumNonLetter(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of non-letter characters required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumNonLetter(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of letters required in the password.
  int getPasswordMinimumNonLetter(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPasswordMinimumNonLetter,
          jni.JniType.intType,
          [admin.reference]).integer;

  static final _id_setPasswordHistoryLength = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordHistoryLength",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setPasswordHistoryLength(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the length of the password
  /// history. After setting this, the user will not be able to enter a new password that is the
  /// same as any password in the history. Note that the current password will remain until the
  /// user has set a new one, so the change does not take place immediately. To prompt the user for
  /// a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
  /// only imposed if the administrator has also requested either \#PASSWORD_QUALITY_NUMERIC
  /// , \#PASSWORD_QUALITY_NUMERIC_COMPLEX \#PASSWORD_QUALITY_ALPHABETIC, or
  /// \#PASSWORD_QUALITY_ALPHANUMERIC with \#setPasswordQuality.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired length of password history. A value of 0 means there is no
  ///            restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordHistoryLength(
          componentname_.ComponentName admin, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPasswordHistoryLength,
          jni.JniType.voidType, [admin.reference, length]).check();

  static final _id_setPasswordExpirationTimeout = jniAccessors.getMethodIDOf(
      _classRef,
      "setPasswordExpirationTimeout",
      "(Landroid/content/ComponentName;J)V");

  /// from: public void setPasswordExpirationTimeout(android.content.ComponentName admin, long timeout)
  ///
  /// Called by a device admin to set the password expiration timeout. Calling this method will
  /// restart the countdown for password expiration for the given admin, as will changing the
  /// device password (for all admins).
  ///
  /// The provided timeout is the time delta in ms and will be added to the current time. For
  /// example, to have the password expire 5 days from now, timeout would be 5 * 86400 * 1000 =
  /// 432000000 ms for timeout.
  ///
  /// To disable password expiration, a value of 0 may be used for timeout.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_EXPIRE_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// Note that setting the password will automatically reset the expiration time for all active
  /// admins. Active admins do not need to explicitly call this method in that case.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param timeout The limit (in ms) that a password can remain in effect. A value of 0 means
  ///            there is no restriction (unlimited).
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_EXPIRE_PASSWORD
  void setPasswordExpirationTimeout(
          componentname_.ComponentName admin, int timeout) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPasswordExpirationTimeout,
          jni.JniType.voidType,
          [admin.reference, timeout]).check();

  static final _id_getPasswordExpirationTimeout = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordExpirationTimeout",
      "(Landroid/content/ComponentName;)J");

  /// from: public long getPasswordExpirationTimeout(android.content.ComponentName admin)
  ///
  /// Get the password expiration timeout for the given admin. The expiration timeout is the
  /// recurring expiration timeout provided in the call to
  /// \#setPasswordExpirationTimeout(ComponentName, long) for the given admin or the
  /// aggregate of all participating policy administrators if {@code admin} is null. Admins that
  /// have set restrictions on profiles that have a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate all admins.
  /// This value may be {@code null}.
  ///@return The timeout for the given admin or the minimum of all timeouts
  int getPasswordExpirationTimeout(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPasswordExpirationTimeout,
          jni.JniType.longType,
          [admin.reference]).long;

  static final _id_getPasswordExpiration = jniAccessors.getMethodIDOf(
      _classRef, "getPasswordExpiration", "(Landroid/content/ComponentName;)J");

  /// from: public long getPasswordExpiration(android.content.ComponentName admin)
  ///
  /// Get the current password expiration time for a particular admin or all admins that set
  /// restrictions on this user and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account. If admin is {@code null}, then a composite
  /// of all expiration times is returned - which will be the minimum of all of them.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// the password expiration for the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate all admins.
  /// This value may be {@code null}.
  ///@return The password expiration time, in milliseconds since epoch.
  int getPasswordExpiration(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPasswordExpiration,
          jni.JniType.longType, [admin.reference]).long;

  static final _id_getPasswordHistoryLength = jniAccessors.getMethodIDOf(
      _classRef,
      "getPasswordHistoryLength",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getPasswordHistoryLength(android.content.ComponentName admin)
  ///
  /// Retrieve the current password history length for a particular admin or all admins that
  /// set restrictions on this user and its participating profiles. Restrictions on profiles that
  /// have a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  /// This value may be {@code null}.
  ///@return The length of the password history
  int getPasswordHistoryLength(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPasswordHistoryLength,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_getPasswordMaximumLength =
      jniAccessors.getMethodIDOf(_classRef, "getPasswordMaximumLength", "(I)I");

  /// from: public int getPasswordMaximumLength(int quality)
  ///
  /// Return the maximum password length that the device supports for a
  /// particular password quality.
  ///@param quality The quality being interrogated.
  ///@return Returns the maximum length that the user can enter.
  int getPasswordMaximumLength(int quality) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPasswordMaximumLength,
      jni.JniType.intType,
      [quality]).integer;

  static final _id_isActivePasswordSufficient = jniAccessors.getMethodIDOf(
      _classRef, "isActivePasswordSufficient", "()Z");

  /// from: public boolean isActivePasswordSufficient()
  ///
  /// Determine whether the current password the user has set is sufficient to meet the policy
  /// requirements (e.g.&nbsp;quality, minimum length) that have been requested by the admins of this
  /// user and its participating profiles. Restrictions on profiles that have a separate challenge
  /// are not taken into account. The user must be unlocked in order to perform the check.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to determine if the password set on
  /// the parent profile is sufficient.
  ///@return Returns true if the password meets the current requirements, else false.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  ///@throws IllegalStateException if the user is not unlocked.
  bool isActivePasswordSufficient() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isActivePasswordSufficient,
      jni.JniType.booleanType, []).boolean;

  static final _id_isUsingUnifiedPassword = jniAccessors.getMethodIDOf(
      _classRef,
      "isUsingUnifiedPassword",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isUsingUnifiedPassword(android.content.ComponentName admin)
  ///
  /// When called by a profile owner of a managed profile returns true if the profile uses unified
  /// challenge with its parent user.
  ///
  /// <strong>Note</strong>: This method is not concerned with password quality and will return
  /// false if the profile has empty password as a separate challenge.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner of a managed profile.
  ///@see UserManager\#DISALLOW_UNIFIED_PASSWORD
  bool isUsingUnifiedPassword(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isUsingUnifiedPassword,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_getCurrentFailedPasswordAttempts = jniAccessors
      .getMethodIDOf(_classRef, "getCurrentFailedPasswordAttempts", "()I");

  /// from: public int getCurrentFailedPasswordAttempts()
  ///
  /// Retrieve the number of times the user has failed at entering a password since that last
  /// successful password entry.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to retrieve the number of failed
  /// password attemts for the parent user.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN
  /// to be able to call this method; if it has not, a security exception will be thrown.
  ///@return The number of times user has entered an incorrect password since the last correct
  ///         password entry.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN
  int getCurrentFailedPasswordAttempts() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCurrentFailedPasswordAttempts,
      jni.JniType.intType, []).integer;

  static final _id_setMaximumFailedPasswordsForWipe =
      jniAccessors.getMethodIDOf(_classRef, "setMaximumFailedPasswordsForWipe",
          "(Landroid/content/ComponentName;I)V");

  /// from: public void setMaximumFailedPasswordsForWipe(android.content.ComponentName admin, int num)
  ///
  /// Setting this to a value greater than zero enables a built-in policy that will perform a
  /// device or profile wipe after too many incorrect device-unlock passwords have been entered.
  /// This built-in policy combines watching for failed passwords and wiping the device, and
  /// requires that you request both DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN and
  /// DeviceAdminInfo\#USES_POLICY_WIPE_DATA}.
  ///
  /// To implement any other policy (e.g. wiping data for a particular application only, erasing or
  /// revoking credentials, or reporting the failure to a server), you should implement
  /// DeviceAdminReceiver\#onPasswordFailed(Context, android.content.Intent) instead. Do not
  /// use this API, because if the maximum count is reached, the device or profile will be wiped
  /// immediately, and your callback will not be invoked.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set a value on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param num The number of failed password attempts at which point the device or profile will
  ///            be wiped.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not use
  ///             both DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN and
  ///             DeviceAdminInfo\#USES_POLICY_WIPE_DATA.
  void setMaximumFailedPasswordsForWipe(
          componentname_.ComponentName admin, int num) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setMaximumFailedPasswordsForWipe,
          jni.JniType.voidType,
          [admin.reference, num]).check();

  static final _id_getMaximumFailedPasswordsForWipe =
      jniAccessors.getMethodIDOf(_classRef, "getMaximumFailedPasswordsForWipe",
          "(Landroid/content/ComponentName;)I");

  /// from: public int getMaximumFailedPasswordsForWipe(android.content.ComponentName admin)
  ///
  /// Retrieve the current maximum number of login attempts that are allowed before the device
  /// or profile is wiped, for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have a separate challenge are
  /// not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// the value for the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  ///
  /// This value may be {@code null}.
  int getMaximumFailedPasswordsForWipe(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getMaximumFailedPasswordsForWipe,
          jni.JniType.intType,
          [admin.reference]).integer;

  static final _id_resetPassword = jniAccessors.getMethodIDOf(
      _classRef, "resetPassword", "(Ljava/lang/String;I)Z");

  /// from: public boolean resetPassword(java.lang.String password, int flags)
  ///
  /// Force a new password for device unlock (the password needed to access the entire device) or
  /// the work profile challenge on the current user. This takes effect immediately.
  ///
  /// _For device owner and profile owners targeting SDK level
  /// android.os.Build.VERSION_CODES\#O or above, this API is no longer available and will
  /// throw SecurityException. Please use the new API \#resetPasswordWithToken
  /// instead. _
  ///
  /// _Note: This API has been limited as of android.os.Build.VERSION_CODES\#N for
  /// device admins that are not device owner and not profile owner.
  /// The password can now only be changed if there is currently no password set.  Device owner
  /// and profile owner can still do this when user is unlocked and does not have a managed
  /// profile._
  ///
  /// The given password must be sufficient for the current password quality and length constraints
  /// as returned by \#getPasswordQuality(ComponentName) and
  /// \#getPasswordMinimumLength(ComponentName); if it does not meet these constraints, then
  /// it will be rejected and false returned. Note that the password may be a stronger quality
  /// (containing alphanumeric characters when the requested quality is only numeric), in which
  /// case the currently active quality will be increased to match.
  ///
  /// Calling with a null or empty password will clear any existing PIN, pattern or password if the
  /// current password constraints allow it. _Note: This will not work in
  /// android.os.Build.VERSION_CODES\#N and later for managed profiles, or for device admins
  /// that are not device owner or profile owner.  Once set, the password cannot be changed to null
  /// or empty except by these admins._
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_RESET_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///@param password The new password for the user. Null or empty clears the password.
  ///@param flags May be 0 or combination of \#RESET_PASSWORD_REQUIRE_ENTRY and
  ///            \#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT.
  ///@return Returns true if the password was applied, or false if it is not acceptable for the
  ///         current constraints or if the user has not been decrypted yet.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_RESET_PASSWORD
  ///@throws IllegalStateException if the calling user is locked or has a managed profile.
  bool resetPassword(jni.JniString password, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_resetPassword,
          jni.JniType.booleanType, [password.reference, flags]).boolean;

  static final _id_setResetPasswordToken = jniAccessors.getMethodIDOf(_classRef,
      "setResetPasswordToken", "(Landroid/content/ComponentName;[B)Z");

  /// from: public boolean setResetPasswordToken(android.content.ComponentName admin, byte[] token)
  ///
  /// Called by a profile or device owner to provision a token which can later be used to reset the
  /// device lockscreen password (if called by device owner), or managed profile challenge (if
  /// called by profile owner), via \#resetPasswordWithToken.
  ///
  /// If the user currently has a lockscreen password, the provisioned token will not be
  /// immediately usable; it only becomes active after the user performs a confirm credential
  /// operation, which can be triggered by KeyguardManager\#createConfirmDeviceCredentialIntent.
  /// If the user has no lockscreen password, the token is activated immediately. In all cases,
  /// the active state of the current token can be checked by \#isResetPasswordTokenActive.
  /// For security reasons, un-activated tokens are only stored in memory and will be lost once
  /// the device reboots. In this case a new token needs to be provisioned again.
  ///
  /// Once provisioned and activated, the token will remain effective even if the user changes
  /// or clears the lockscreen password.
  ///
  /// _This token is highly sensitive and should be treated at the same level as user
  /// credentials. In particular, NEVER store this token on device in plaintext. Do not store
  /// the plaintext token in device-encrypted storage if it will be needed to reset password on
  /// file-based encryption devices before user unlocks. Consider carefully how any password token
  /// will be stored on your server and who will need access to them. Tokens may be the subject of
  /// legal access requests.
  /// _
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  ///@param token a secure token a least 32-byte long, which must be generated by a
  ///        cryptographically strong random number generator.
  ///@return true if the operation is successful, false otherwise.
  ///@throws SecurityException if admin is not a device or profile owner.
  ///@throws IllegalArgumentException if the supplied token is invalid.
  bool setResetPasswordToken(
          componentname_.ComponentName admin, jni.JniObject token) =>
      jniAccessors.callMethodWithArgs(reference, _id_setResetPasswordToken,
          jni.JniType.booleanType, [admin.reference, token.reference]).boolean;

  static final _id_clearResetPasswordToken = jniAccessors.getMethodIDOf(
      _classRef,
      "clearResetPasswordToken",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean clearResetPasswordToken(android.content.ComponentName admin)
  ///
  /// Called by a profile or device owner to revoke the current password reset token.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  ///@return true if the operation is successful, false otherwise.
  ///@throws SecurityException if admin is not a device or profile owner.
  bool clearResetPasswordToken(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearResetPasswordToken,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_isResetPasswordTokenActive = jniAccessors.getMethodIDOf(
      _classRef,
      "isResetPasswordTokenActive",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isResetPasswordTokenActive(android.content.ComponentName admin)
  ///
  /// Called by a profile or device owner to check if the current reset password token is active.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  ///@return true if the token is active, false otherwise.
  ///@throws SecurityException if admin is not a device or profile owner.
  ///@throws IllegalStateException if no token has been set.
  bool isResetPasswordTokenActive(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isResetPasswordTokenActive,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_resetPasswordWithToken = jniAccessors.getMethodIDOf(
      _classRef,
      "resetPasswordWithToken",
      "(Landroid/content/ComponentName;Ljava/lang/String;[BI)Z");

  /// from: public boolean resetPasswordWithToken(android.content.ComponentName admin, java.lang.String password, byte[] token, int flags)
  ///
  /// Called by device or profile owner to force set a new device unlock password or a managed
  /// profile challenge on current user. This takes effect immediately.
  ///
  /// Unlike \#resetPassword, this API can change the password even before the user or
  /// device is unlocked or decrypted. The supplied token must have been previously provisioned via
  /// \#setResetPasswordToken, and in active state \#isResetPasswordTokenActive.
  ///
  /// The given password must be sufficient for the current password quality and length constraints
  /// as returned by \#getPasswordQuality(ComponentName) and
  /// \#getPasswordMinimumLength(ComponentName); if it does not meet these constraints, then
  /// it will be rejected and false returned. Note that the password may be a stronger quality, for
  /// example, a password containing alphanumeric characters when the requested quality is only
  /// numeric.
  ///
  /// Calling with a {@code null} or empty password will clear any existing PIN, pattern or
  /// password if the current password constraints allow it.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param password The new password for the user. {@code null} or empty clears the password.
  ///@param token the password reset token previously provisioned by
  ///        \#setResetPasswordToken.
  ///@param flags May be 0 or combination of \#RESET_PASSWORD_REQUIRE_ENTRY and
  ///        \#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT.
  ///@return Returns true if the password was applied, or false if it is not acceptable for the
  ///         current constraints.
  ///@throws SecurityException if admin is not a device or profile owner.
  ///@throws IllegalStateException if the provided token is not valid.
  bool resetPasswordWithToken(componentname_.ComponentName admin,
          jni.JniString password, jni.JniObject token, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_resetPasswordWithToken, jni.JniType.booleanType, [
        admin.reference,
        password.reference,
        token.reference,
        flags
      ]).boolean;

  static final _id_setMaximumTimeToLock = jniAccessors.getMethodIDOf(
      _classRef, "setMaximumTimeToLock", "(Landroid/content/ComponentName;J)V");

  /// from: public void setMaximumTimeToLock(android.content.ComponentName admin, long timeMs)
  ///
  /// Called by an application that is administering the device to set the maximum time for user
  /// activity until the device will lock. This limits the length that the user can set. It takes
  /// effect immediately.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  /// to be able to call this method; if it has not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param timeMs The new desired maximum time to lock in milliseconds. A value of 0 means there
  ///            is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or it does not use
  ///             DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  void setMaximumTimeToLock(componentname_.ComponentName admin, int timeMs) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMaximumTimeToLock,
          jni.JniType.voidType, [admin.reference, timeMs]).check();

  static final _id_getMaximumTimeToLock = jniAccessors.getMethodIDOf(
      _classRef, "getMaximumTimeToLock", "(Landroid/content/ComponentName;)J");

  /// from: public long getMaximumTimeToLock(android.content.ComponentName admin)
  ///
  /// Retrieve the current maximum time to unlock for a particular admin or all admins that set
  /// restrictions on this user and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  /// This value may be {@code null}.
  ///@return time in milliseconds for the given admin or the minimum value (strictest) of
  /// all admins if admin is null. Returns 0 if there are no restrictions.
  int getMaximumTimeToLock(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getMaximumTimeToLock,
          jni.JniType.longType, [admin.reference]).long;

  static final _id_setRequiredStrongAuthTimeout = jniAccessors.getMethodIDOf(
      _classRef,
      "setRequiredStrongAuthTimeout",
      "(Landroid/content/ComponentName;J)V");

  /// from: public void setRequiredStrongAuthTimeout(android.content.ComponentName admin, long timeoutMs)
  ///
  /// Called by a device/profile owner to set the timeout after which unlocking with secondary, non
  /// strong auth (e.g.&nbsp;fingerprint, trust agents) times out, i.e. the user has to use a strong
  /// authentication method like password, pin or pattern.
  ///
  /// This timeout is used internally to reset the timer to require strong auth again after
  /// specified timeout each time it has been successfully used.
  ///
  /// Fingerprint can also be disabled altogether using \#KEYGUARD_DISABLE_FINGERPRINT.
  ///
  /// Trust agents can also be disabled altogether using \#KEYGUARD_DISABLE_TRUST_AGENTS.
  ///
  /// The calling device admin must be a device or profile owner. If it is not,
  /// a SecurityException will be thrown.
  ///
  /// The calling device admin can verify the value it has set by calling
  /// \#getRequiredStrongAuthTimeout(ComponentName) and passing in its instance.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param timeoutMs The new timeout in milliseconds, after which the user will have to unlock
  ///         with strong authentication method. A value of 0 means the admin is not participating
  ///         in controlling the timeout.
  ///         The minimum and maximum timeouts are platform-defined and are typically 1 hour and
  ///         72 hours, respectively. Though discouraged, the admin may choose to require strong
  ///         auth at all times using \#KEYGUARD_DISABLE_FINGERPRINT and/or
  ///         \#KEYGUARD_DISABLE_TRUST_AGENTS.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setRequiredStrongAuthTimeout(
          componentname_.ComponentName admin, int timeoutMs) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiredStrongAuthTimeout,
          jni.JniType.voidType,
          [admin.reference, timeoutMs]).check();

  static final _id_getRequiredStrongAuthTimeout = jniAccessors.getMethodIDOf(
      _classRef,
      "getRequiredStrongAuthTimeout",
      "(Landroid/content/ComponentName;)J");

  /// from: public long getRequiredStrongAuthTimeout(android.content.ComponentName admin)
  ///
  /// Determine for how long the user will be able to use secondary, non strong auth for
  /// authentication, since last strong method authentication (password, pin or pattern) was used.
  /// After the returned timeout the user is required to use strong authentication method.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  ///         accross all participating admins.
  /// This value may be {@code null}.
  ///@return The timeout in milliseconds or 0 if not configured for the provided admin.
  int getRequiredStrongAuthTimeout(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getRequiredStrongAuthTimeout,
          jni.JniType.longType,
          [admin.reference]).long;

  static final _id_lockNow =
      jniAccessors.getMethodIDOf(_classRef, "lockNow", "()V");

  /// from: public void lockNow()
  ///
  /// Make the device lock immediately, as if the lock screen timeout has expired at the point of
  /// this call.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  /// to be able to call this method; if it has not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to lock the parent profile.
  ///
  /// Equivalent to calling \#lockNow(int) with no flags.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  void lockNow() => jniAccessors.callMethodWithArgs(
      reference, _id_lockNow, jni.JniType.voidType, []).check();

  static final _id_lockNow1 =
      jniAccessors.getMethodIDOf(_classRef, "lockNow", "(I)V");

  /// from: public void lockNow(int flags)
  ///
  /// Make the device lock immediately, as if the lock screen timeout has expired at the point of
  /// this call.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  /// to be able to call this method; if it has not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to lock the parent profile.
  ///@param flags May be 0 or \#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY.
  /// Value is either <code>0</code> or android.app.admin.DevicePolicyManager\#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_FORCE_LOCK or the
  ///             \#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY flag is passed by an application
  ///             that is not a profile
  ///             owner of a managed profile.
  ///@throws IllegalArgumentException if the \#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY flag is
  ///             passed when locking the parent profile.
  ///@throws UnsupportedOperationException if the \#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY
  ///             flag is passed when \#getStorageEncryptionStatus does not return
  ///             \#ENCRYPTION_STATUS_ACTIVE_PER_USER.
  void lockNow1(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_lockNow1, jni.JniType.voidType, [flags]).check();

  static final _id_wipeData =
      jniAccessors.getMethodIDOf(_classRef, "wipeData", "(I)V");

  /// from: public void wipeData(int flags)
  ///
  /// Ask that all user data be wiped. If called as a secondary user, the user will be removed and
  /// other users will remain unaffected. Calling from the primary user will cause the device to
  /// reboot, erasing all device data - including all the secondary users and their data - while
  /// booting up.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_WIPE_DATA to
  /// be able to call this method; if it has not, a security exception will be thrown.
  ///@param flags Bit mask of additional options: currently supported flags are
  ///            \#WIPE_EXTERNAL_STORAGE and \#WIPE_RESET_PROTECTION_DATA.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_WIPE_DATA
  void wipeData(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_wipeData, jni.JniType.voidType, [flags]).check();

  static final _id_wipeData1 = jniAccessors.getMethodIDOf(
      _classRef, "wipeData", "(ILjava/lang/CharSequence;)V");

  /// from: public void wipeData(int flags, java.lang.CharSequence reason)
  ///
  /// Ask that all user data be wiped. If called as a secondary user, the user will be removed and
  /// other users will remain unaffected, the provided reason for wiping data can be shown to
  /// user. Calling from the primary user will cause the device to reboot, erasing all device data
  /// - including all the secondary users and their data - while booting up. In this case, we don't
  /// show the reason to the user since the device would be factory reset.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_WIPE_DATA to
  /// be able to call this method; if it has not, a security exception will be thrown.
  ///@param flags Bit mask of additional options: currently supported flags are
  ///            \#WIPE_EXTERNAL_STORAGE and \#WIPE_RESET_PROTECTION_DATA.
  ///@param reason a string that contains the reason for wiping data, which can be
  ///                          presented to the user.
  /// This value must never be {@code null}.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_WIPE_DATA
  ///@throws IllegalArgumentException if the input reason string is null or empty.
  void wipeData1(int flags, jni.JniObject reason) =>
      jniAccessors.callMethodWithArgs(reference, _id_wipeData1,
          jni.JniType.voidType, [flags, reason.reference]).check();

  static final _id_setRecommendedGlobalProxy = jniAccessors.getMethodIDOf(
      _classRef,
      "setRecommendedGlobalProxy",
      "(Landroid/content/ComponentName;Landroid/net/ProxyInfo;)V");

  /// from: public void setRecommendedGlobalProxy(android.content.ComponentName admin, android.net.ProxyInfo proxyInfo)
  ///
  /// Set a network-independent global HTTP proxy. This is not normally what you want for typical
  /// HTTP proxies - they are generally network dependent. However if you're doing something
  /// unusual like general internal filtering this may be useful. On a private network where the
  /// proxy is not accessible, you may break HTTP using this.
  ///
  /// This method requires the caller to be the device owner.
  ///
  /// This proxy is only a recommendation and it is possible that some apps will ignore it.
  ///@see ProxyInfo
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param proxyInfo The a ProxyInfo object defining the new global HTTP proxy. A
  ///            {@code null} value will clear the global HTTP proxy.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not the device owner.
  void setRecommendedGlobalProxy(
          componentname_.ComponentName admin, proxyinfo_.ProxyInfo proxyInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRecommendedGlobalProxy,
          jni.JniType.voidType, [admin.reference, proxyInfo.reference]).check();

  static final _id_setStorageEncryption = jniAccessors.getMethodIDOf(
      _classRef, "setStorageEncryption", "(Landroid/content/ComponentName;Z)I");

  /// from: public int setStorageEncryption(android.content.ComponentName admin, boolean encrypt)
  ///
  /// Called by an application that is administering the device to request that the storage system
  /// be encrypted. Does nothing if the caller is on a secondary user or a managed profile.
  ///
  /// When multiple device administrators attempt to control device encryption, the most secure,
  /// supported setting will always be used. If any device administrator requests device
  /// encryption, it will be enabled; Conversely, if a device administrator attempts to disable
  /// device encryption while another device administrator has enabled it, the call to disable will
  /// fail (most commonly returning \#ENCRYPTION_STATUS_ACTIVE).
  ///
  /// This policy controls encryption of the secure (application data) storage area. Data written
  /// to other storage areas may or may not be encrypted, and this policy does not require or
  /// control the encryption of any other storage areas. There is one exception: If
  /// android.os.Environment\#isExternalStorageEmulated() is {@code true}, then the
  /// directory returned by android.os.Environment\#getExternalStorageDirectory() must be
  /// written to disk within the encrypted storage area.
  ///
  /// Important Note: On some devices, it is possible to encrypt storage without requiring the user
  /// to create a device PIN or Password. In this case, the storage is encrypted, but the
  /// encryption key may not be fully secured. For maximum security, the administrator should also
  /// require (and check for) a pattern, PIN, or password.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param encrypt true to request encryption, false to release any previous request
  ///@return the new total request status (for all active admins), or DevicePolicyManager\#ENCRYPTION_STATUS_UNSUPPORTED if called for a non-system user.
  ///         Will be one of \#ENCRYPTION_STATUS_UNSUPPORTED, \#ENCRYPTION_STATUS_INACTIVE, or \#ENCRYPTION_STATUS_ACTIVE. This is the value
  ///         of the requests; use \#getStorageEncryptionStatus() to query the actual device
  ///         state.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not use
  ///             DeviceAdminInfo\#USES_ENCRYPTED_STORAGE
  int setStorageEncryption(componentname_.ComponentName admin, bool encrypt) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStorageEncryption,
          jni.JniType.intType, [admin.reference, encrypt]).integer;

  static final _id_getStorageEncryption = jniAccessors.getMethodIDOf(
      _classRef, "getStorageEncryption", "(Landroid/content/ComponentName;)Z");

  /// from: public boolean getStorageEncryption(android.content.ComponentName admin)
  ///
  /// Called by an application that is administering the device to
  /// determine the requested setting for secure storage.
  ///@param admin Which DeviceAdminReceiver this request is associated with.  If null,
  /// this will return the requested encryption setting as an aggregate of all active
  /// administrators.
  /// This value may be {@code null}.
  ///@return true if the admin(s) are requesting encryption, false if not.
  bool getStorageEncryption(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getStorageEncryption,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_getStorageEncryptionStatus = jniAccessors.getMethodIDOf(
      _classRef, "getStorageEncryptionStatus", "()I");

  /// from: public int getStorageEncryptionStatus()
  ///
  /// Called by an application that is administering the device to
  /// determine the current encryption status of the device.
  ///
  /// Depending on the returned status code, the caller may proceed in different
  /// ways.  If the result is \#ENCRYPTION_STATUS_UNSUPPORTED, the
  /// storage system does not support encryption.  If the
  /// result is \#ENCRYPTION_STATUS_INACTIVE, use \#ACTION_START_ENCRYPTION to begin the process of encrypting or decrypting the
  /// storage.  If the result is \#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY, the
  /// storage system has enabled encryption but no password is set so further action
  /// may be required.  If the result is \#ENCRYPTION_STATUS_ACTIVATING,
  /// \#ENCRYPTION_STATUS_ACTIVE or \#ENCRYPTION_STATUS_ACTIVE_PER_USER,
  /// no further action is required.
  ///@return current status of encryption. The value will be one of
  /// \#ENCRYPTION_STATUS_UNSUPPORTED, \#ENCRYPTION_STATUS_INACTIVE,
  /// \#ENCRYPTION_STATUS_ACTIVATING, \#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY,
  /// \#ENCRYPTION_STATUS_ACTIVE, or \#ENCRYPTION_STATUS_ACTIVE_PER_USER.
  int getStorageEncryptionStatus() => jniAccessors.callMethodWithArgs(reference,
      _id_getStorageEncryptionStatus, jni.JniType.intType, []).integer;

  static final _id_installCaCert = jniAccessors.getMethodIDOf(
      _classRef, "installCaCert", "(Landroid/content/ComponentName;[B)Z");

  /// from: public boolean installCaCert(android.content.ComponentName admin, byte[] certBuffer)
  ///
  /// Installs the given certificate as a user CA.
  ///
  /// The caller must be a profile or device owner on that user, or a delegate package given the
  /// \#DELEGATION_CERT_INSTALL scope via \#setDelegatedScopes; otherwise a
  /// security exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param certBuffer encoded form of the certificate to install.
  ///@return false if the certBuffer cannot be parsed or installation is
  ///         interrupted, true otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool installCaCert(
          componentname_.ComponentName admin, jni.JniObject certBuffer) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_installCaCert,
          jni.JniType.booleanType,
          [admin.reference, certBuffer.reference]).boolean;

  static final _id_uninstallCaCert = jniAccessors.getMethodIDOf(
      _classRef, "uninstallCaCert", "(Landroid/content/ComponentName;[B)V");

  /// from: public void uninstallCaCert(android.content.ComponentName admin, byte[] certBuffer)
  ///
  /// Uninstalls the given certificate from trusted user CAs, if present.
  ///
  /// The caller must be a profile or device owner on that user, or a delegate package given the
  /// \#DELEGATION_CERT_INSTALL scope via \#setDelegatedScopes; otherwise a
  /// security exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param certBuffer encoded form of the certificate to remove.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  void uninstallCaCert(
          componentname_.ComponentName admin, jni.JniObject certBuffer) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_uninstallCaCert,
          jni.JniType.voidType,
          [admin.reference, certBuffer.reference]).check();

  static final _id_getInstalledCaCerts = jniAccessors.getMethodIDOf(
      _classRef,
      "getInstalledCaCerts",
      "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<byte[]> getInstalledCaCerts(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all CA certificates that are currently trusted, excluding system CA certificates.
  /// If a user has installed any certificates by other means than device policy these will be
  /// included too.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@return a List of byte[] arrays, each encoding one user CA certificate.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  jni.JniObject getInstalledCaCerts(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getInstalledCaCerts,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_uninstallAllUserCaCerts = jniAccessors.getMethodIDOf(
      _classRef,
      "uninstallAllUserCaCerts",
      "(Landroid/content/ComponentName;)V");

  /// from: public void uninstallAllUserCaCerts(android.content.ComponentName admin)
  ///
  /// Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
  /// means other than device policy will also be removed, except for system CA certificates.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  void uninstallAllUserCaCerts(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_uninstallAllUserCaCerts,
          jni.JniType.voidType, [admin.reference]).check();

  static final _id_hasCaCertInstalled = jniAccessors.getMethodIDOf(
      _classRef, "hasCaCertInstalled", "(Landroid/content/ComponentName;[B)Z");

  /// from: public boolean hasCaCertInstalled(android.content.ComponentName admin, byte[] certBuffer)
  ///
  /// Returns whether this certificate is installed as a trusted CA.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param certBuffer encoded form of the certificate to look up.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  bool hasCaCertInstalled(
          componentname_.ComponentName admin, jni.JniObject certBuffer) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_hasCaCertInstalled,
          jni.JniType.booleanType,
          [admin.reference, certBuffer.reference]).boolean;

  static final _id_installKeyPair = jniAccessors.getMethodIDOf(
      _classRef,
      "installKeyPair",
      "(Landroid/content/ComponentName;Ljava/security/PrivateKey;Ljava/security/cert/Certificate;Ljava/lang/String;)Z");

  /// from: public boolean installKeyPair(android.content.ComponentName admin, java.security.PrivateKey privKey, java.security.cert.Certificate cert, java.lang.String alias)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to install a
  /// certificate and corresponding private key. All apps within the profile will be able to access
  /// the certificate and use the private key, given direct user approval.
  ///
  /// Access to the installed credentials will not be granted to the caller of this API without
  /// direct user approval. This is for security - should a certificate installer become
  /// compromised, certificates it had already installed will be protected.
  ///
  /// If the installer must have access to the credentials, call
  /// \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, boolean) instead.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param privKey The private key to install.
  /// This value must never be {@code null}.
  ///@param cert The certificate to install.
  /// This value must never be {@code null}.
  ///@param alias The private key alias under which to install the certificate. If a certificate
  /// with that alias already exists, it will be overwritten.
  /// This value must never be {@code null}.
  ///@return {@code true} if the keys were installed, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool installKeyPair(componentname_.ComponentName admin, jni.JniObject privKey,
          jni.JniObject cert, jni.JniString alias) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_installKeyPair, jni.JniType.booleanType, [
        admin.reference,
        privKey.reference,
        cert.reference,
        alias.reference
      ]).boolean;

  static final _id_installKeyPair1 = jniAccessors.getMethodIDOf(
      _classRef,
      "installKeyPair",
      "(Landroid/content/ComponentName;Ljava/security/PrivateKey;[Ljava/security/cert/Certificate;Ljava/lang/String;Z)Z");

  /// from: public boolean installKeyPair(android.content.ComponentName admin, java.security.PrivateKey privKey, java.security.cert.Certificate[] certs, java.lang.String alias, boolean requestAccess)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to install a
  /// certificate chain and corresponding private key for the leaf certificate. All apps within the
  /// profile will be able to access the certificate chain and use the private key, given direct
  /// user approval.
  ///
  /// The caller of this API may grant itself access to the certificate and private key
  /// immediately, without user approval. It is a best practice not to request this unless strictly
  /// necessary since it opens up additional security vulnerabilities.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///        {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param privKey The private key to install.
  /// This value must never be {@code null}.
  ///@param certs The certificate chain to install. The chain should start with the leaf
  ///        certificate and include the chain of trust in order. This will be returned by
  ///        android.security.KeyChain\#getCertificateChain.
  /// This value must never be {@code null}.
  ///@param alias The private key alias under which to install the certificate. If a certificate
  ///        with that alias already exists, it will be overwritten.
  /// This value must never be {@code null}.
  ///@param requestAccess {@code true} to request that the calling app be granted access to the
  ///        credentials immediately. Otherwise, access to the credentials will be gated by user
  ///        approval.
  ///@return {@code true} if the keys were installed, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see android.security.KeyChain\#getCertificateChain
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool installKeyPair1(
          componentname_.ComponentName admin,
          jni.JniObject privKey,
          jni.JniObject certs,
          jni.JniString alias,
          bool requestAccess) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_installKeyPair1, jni.JniType.booleanType, [
        admin.reference,
        privKey.reference,
        certs.reference,
        alias.reference,
        requestAccess
      ]).boolean;

  static final _id_installKeyPair2 = jniAccessors.getMethodIDOf(
      _classRef,
      "installKeyPair",
      "(Landroid/content/ComponentName;Ljava/security/PrivateKey;[Ljava/security/cert/Certificate;Ljava/lang/String;I)Z");

  /// from: public boolean installKeyPair(android.content.ComponentName admin, java.security.PrivateKey privKey, java.security.cert.Certificate[] certs, java.lang.String alias, int flags)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to install a
  /// certificate chain and corresponding private key for the leaf certificate. All apps within the
  /// profile will be able to access the certificate chain and use the private key, given direct
  /// user approval (if the user is allowed to select the private key).
  ///
  /// The caller of this API may grant itself access to the certificate and private key
  /// immediately, without user approval. It is a best practice not to request this unless strictly
  /// necessary since it opens up additional security vulnerabilities.
  ///
  /// Include \#INSTALLKEY_SET_USER_SELECTABLE in the {@code flags} argument to allow
  /// the user to select the key from a dialog.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///        {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param privKey The private key to install.
  /// This value must never be {@code null}.
  ///@param certs The certificate chain to install. The chain should start with the leaf
  ///        certificate and include the chain of trust in order. This will be returned by
  ///        android.security.KeyChain\#getCertificateChain.
  /// This value must never be {@code null}.
  ///@param alias The private key alias under which to install the certificate. If a certificate
  ///        with that alias already exists, it will be overwritten.
  /// This value must never be {@code null}.
  ///@param flags Flags to request that the calling app be granted access to the credentials
  ///        and set the key to be user-selectable. See \#INSTALLKEY_SET_USER_SELECTABLE and
  ///        \#INSTALLKEY_REQUEST_CREDENTIALS_ACCESS.
  ///@return {@code true} if the keys were installed, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see android.security.KeyChain\#getCertificateChain
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool installKeyPair2(
          componentname_.ComponentName admin,
          jni.JniObject privKey,
          jni.JniObject certs,
          jni.JniString alias,
          int flags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_installKeyPair2, jni.JniType.booleanType, [
        admin.reference,
        privKey.reference,
        certs.reference,
        alias.reference,
        flags
      ]).boolean;

  static final _id_removeKeyPair = jniAccessors.getMethodIDOf(_classRef,
      "removeKeyPair", "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean removeKeyPair(android.content.ComponentName admin, java.lang.String alias)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to remove a
  /// certificate and private key pair installed under a given alias.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///        {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param alias The private key alias under which the certificate is installed.
  /// This value must never be {@code null}.
  ///@return {@code true} if the private key alias no longer exists, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool removeKeyPair(componentname_.ComponentName admin, jni.JniString alias) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeKeyPair,
          jni.JniType.booleanType, [admin.reference, alias.reference]).boolean;

  static final _id_generateKeyPair = jniAccessors.getMethodIDOf(
      _classRef,
      "generateKeyPair",
      "(Landroid/content/ComponentName;Ljava/lang/String;Landroid/security/keystore/KeyGenParameterSpec;I)Landroid/security/AttestedKeyPair;");

  /// from: public android.security.AttestedKeyPair generateKeyPair(android.content.ComponentName admin, java.lang.String algorithm, android.security.keystore.KeyGenParameterSpec keySpec, int idAttestationFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to generate a
  /// new private/public key pair. If the device supports key generation via secure hardware,
  /// this method is useful for creating a key in KeyChain that never left the secure hardware.
  ///
  /// Access to the key is controlled the same way as in \#installKeyPair.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param algorithm The key generation algorithm, see java.security.KeyPairGenerator.
  /// This value must never be {@code null}.
  ///@param keySpec Specification of the key to generate, see
  /// java.security.KeyPairGenerator.
  /// This value must never be {@code null}.
  ///@param idAttestationFlags A bitmask of all the identifiers that should be included in the
  ///        attestation record ({@code ID_TYPE_BASE_INFO}, {@code ID_TYPE_SERIAL},
  ///        {@code ID_TYPE_IMEI} and {@code ID_TYPE_MEID}), or {@code 0} if no device
  ///        identification is required in the attestation record.
  ///        Device owner, profile owner and their delegated certificate installer can use
  ///        \#ID_TYPE_BASE_INFO to request inclusion of the general device information
  ///        including manufacturer, model, brand, device and product in the attestation record.
  ///        Only device owner and their delegated certificate installer can use
  ///        \#ID_TYPE_SERIAL, \#ID_TYPE_IMEI and \#ID_TYPE_MEID to request
  ///        unique device identifiers to be attested.
  ///
  ///        If any of \#ID_TYPE_SERIAL, \#ID_TYPE_IMEI and \#ID_TYPE_MEID
  ///        is set, it is implicitly assumed that \#ID_TYPE_BASE_INFO is also set.
  ///
  ///        If any flag is specified, then an attestation challenge must be included in the
  ///        {@code keySpec}.
  /// Value is either <code>0</code> or a combination of android.app.admin.DevicePolicyManager\#ID_TYPE_BASE_INFO, android.app.admin.DevicePolicyManager\#ID_TYPE_SERIAL, android.app.admin.DevicePolicyManager\#ID_TYPE_IMEI, and android.app.admin.DevicePolicyManager\#ID_TYPE_MEID
  ///@return A non-null {@code AttestedKeyPair} if the key generation succeeded, null otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner. If Device ID attestation is requested (using \#ID_TYPE_SERIAL,
  ///         \#ID_TYPE_IMEI or \#ID_TYPE_MEID), the caller must be the Device Owner
  ///         or the Certificate Installer delegate.
  ///@throws IllegalArgumentException if the alias in {@code keySpec} is empty, if the
  ///         algorithm specification in {@code keySpec} is not {@code RSAKeyGenParameterSpec}
  ///         or {@code ECGenParameterSpec}, or if Device ID attestation was requested but the
  ///         {@code keySpec} does not contain an attestation challenge.
  ///@throws UnsupportedOperationException if Device ID attestation was requested but the
  ///         underlying hardware does not support it.
  ///@see KeyGenParameterSpec.Builder\#setAttestationChallenge(byte[])
  attestedkeypair_.AttestedKeyPair generateKeyPair(
          componentname_.ComponentName admin,
          jni.JniString algorithm,
          keygenparameterspec_.KeyGenParameterSpec keySpec,
          int idAttestationFlags) =>
      attestedkeypair_.AttestedKeyPair.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_generateKeyPair, jni.JniType.objectType, [
        admin.reference,
        algorithm.reference,
        keySpec.reference,
        idAttestationFlags
      ]).object);

  static final _id_isDeviceIdAttestationSupported = jniAccessors.getMethodIDOf(
      _classRef, "isDeviceIdAttestationSupported", "()Z");

  /// from: public boolean isDeviceIdAttestationSupported()
  ///
  /// Returns {@code true} if the device supports attestation of device identifiers in addition
  /// to key attestation.
  ///@return {@code true} if Device ID attestation is supported.
  bool isDeviceIdAttestationSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isDeviceIdAttestationSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_setKeyPairCertificate = jniAccessors.getMethodIDOf(
      _classRef,
      "setKeyPairCertificate",
      "(Landroid/content/ComponentName;Ljava/lang/String;Ljava/util/List;Z)Z");

  /// from: public boolean setKeyPairCertificate(android.content.ComponentName admin, java.lang.String alias, java.util.List<java.security.cert.Certificate> certs, boolean isUserSelectable)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to associate
  /// certificates with a key pair that was generated using \#generateKeyPair, and
  /// set whether the key is available for the user to choose in the certificate selection
  /// prompt.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param alias The private key alias under which to install the certificate. The {@code alias}
  ///        should denote an existing private key. If a certificate with that alias already
  ///        exists, it will be overwritten.
  /// This value must never be {@code null}.
  ///@param certs The certificate chain to install. The chain should start with the leaf
  ///        certificate and include the chain of trust in order. This will be returned by
  ///        android.security.KeyChain\#getCertificateChain.
  /// This value must never be {@code null}.
  ///@param isUserSelectable {@code true} to indicate that a user can select this key via the
  ///        certificate selection prompt, {@code false} to indicate that this key can only be
  ///        granted access by implementing
  ///        android.app.admin.DeviceAdminReceiver\#onChoosePrivateKeyAlias.
  ///@return {@code true} if the provided {@code alias} exists and the certificates has been
  ///        successfully associated with it, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner, or {@code admin} is null but the calling application is not a delegated
  ///         certificate installer.
  bool setKeyPairCertificate(componentname_.ComponentName admin,
          jni.JniString alias, jni.JniObject certs, bool isUserSelectable) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setKeyPairCertificate, jni.JniType.booleanType, [
        admin.reference,
        alias.reference,
        certs.reference,
        isUserSelectable
      ]).boolean;

  static final _id_setCertInstallerPackage = jniAccessors.getMethodIDOf(
      _classRef,
      "setCertInstallerPackage",
      "(Landroid/content/ComponentName;Ljava/lang/String;)V");

  /// from: public void setCertInstallerPackage(android.content.ComponentName admin, java.lang.String installerPackage)
  ///
  /// Called by a profile owner or device owner to grant access to privileged certificate
  /// manipulation APIs to a third-party certificate installer app. Granted APIs include
  /// \#getInstalledCaCerts, \#hasCaCertInstalled, \#installCaCert,
  /// \#uninstallCaCert, \#uninstallAllUserCaCerts and \#installKeyPair.
  ///
  /// Delegated certificate installer is a per-user state. The delegated access is persistent until
  /// it is later cleared by calling this method with a null value or uninstallling the certificate
  /// installer.
  ///
  /// __Note:__Starting from android.os.Build.VERSION_CODES\#N, if the caller
  /// application's target SDK version is android.os.Build.VERSION_CODES\#N or newer, the
  /// supplied certificate installer package must be installed when calling this API, otherwise an
  /// IllegalArgumentException will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param installerPackage The package name of the certificate installer which will be given
  ///            access. If {@code null} is given the current package will be cleared.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#setDelegatedScopes
  /// with the \#DELEGATION_CERT_INSTALL scope instead.
  void setCertInstallerPackage(
          componentname_.ComponentName admin, jni.JniString installerPackage) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCertInstallerPackage,
          jni.JniType.voidType,
          [admin.reference, installerPackage.reference]).check();

  static final _id_getCertInstallerPackage = jniAccessors.getMethodIDOf(
      _classRef,
      "getCertInstallerPackage",
      "(Landroid/content/ComponentName;)Ljava/lang/String;");

  /// from: public java.lang.String getCertInstallerPackage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner or device owner to retrieve the certificate installer for the user,
  /// or {@code null} if none is set. If there are multiple delegates this function will return one
  /// of them.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The package name of the current delegated certificate installer, or {@code null} if
  ///         none is set.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#getDelegatePackages
  /// with the \#DELEGATION_CERT_INSTALL scope instead.
  jni.JniString getCertInstallerPackage(componentname_.ComponentName admin) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCertInstallerPackage,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setDelegatedScopes = jniAccessors.getMethodIDOf(
      _classRef,
      "setDelegatedScopes",
      "(Landroid/content/ComponentName;Ljava/lang/String;Ljava/util/List;)V");

  /// from: public void setDelegatedScopes(android.content.ComponentName admin, java.lang.String delegatePackage, java.util.List<java.lang.String> scopes)
  ///
  /// Called by a profile owner or device owner to grant access to privileged APIs to another app.
  /// Granted APIs are determined by {@code scopes}, which is a list of the {@code DELEGATION_*}
  /// constants.
  ///
  /// A broadcast with the \#ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED action will be
  /// sent to the {@code delegatePackage} with its new scopes in an {@code ArrayList<String>} extra
  /// under the \#EXTRA_DELEGATION_SCOPES key. The broadcast is sent with the
  /// Intent\#FLAG_RECEIVER_REGISTERED_ONLY flag.
  ///
  /// Delegated scopes are a per-user state. The delegated access is persistent until it is later
  /// cleared by calling this method with an empty {@code scopes} list or uninstalling the
  /// {@code delegatePackage}.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param delegatePackage The package name of the app which will be given access.
  /// This value must never be {@code null}.
  ///@param scopes The groups of privileged APIs whose access should be granted to
  ///            {@code delegatedPackage}.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  void setDelegatedScopes(componentname_.ComponentName admin,
          jni.JniString delegatePackage, jni.JniObject scopes) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setDelegatedScopes, jni.JniType.voidType, [
        admin.reference,
        delegatePackage.reference,
        scopes.reference
      ]).check();

  static final _id_getDelegatedScopes = jniAccessors.getMethodIDOf(
      _classRef,
      "getDelegatedScopes",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getDelegatedScopes(android.content.ComponentName admin, java.lang.String delegatedPackage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner or device owner to retrieve a list of the scopes given to a
  /// delegate package. Other apps can use this method to retrieve their own delegated scopes by
  /// passing {@code null} for {@code admin} and their own package name as
  /// {@code delegatedPackage}.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is {@code delegatedPackage}.
  /// This value may be {@code null}.
  ///@param delegatedPackage The package name of the app whose scopes should be retrieved.
  /// This value must never be {@code null}.
  ///@return A list containing the scopes given to {@code delegatedPackage}.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  jni.JniObject getDelegatedScopes(
          componentname_.ComponentName admin, jni.JniString delegatedPackage) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDelegatedScopes,
          jni.JniType.objectType,
          [admin.reference, delegatedPackage.reference]).object);

  static final _id_getDelegatePackages = jniAccessors.getMethodIDOf(
      _classRef,
      "getDelegatePackages",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getDelegatePackages(android.content.ComponentName admin, java.lang.String delegationScope)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner or device owner to retrieve a list of delegate packages that were
  /// granted a delegation scope.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param delegationScope The scope whose delegates should be retrieved.
  /// This value must never be {@code null}.
  ///@return A list of package names of the current delegated packages for
  ///       {@code delegationScope}.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  jni.JniObject getDelegatePackages(
          componentname_.ComponentName admin, jni.JniString delegationScope) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDelegatePackages,
          jni.JniType.objectType,
          [admin.reference, delegationScope.reference]).object);

  static final _id_setAlwaysOnVpnPackage = jniAccessors.getMethodIDOf(
      _classRef,
      "setAlwaysOnVpnPackage",
      "(Landroid/content/ComponentName;Ljava/lang/String;Z)V");

  /// from: public void setAlwaysOnVpnPackage(android.content.ComponentName admin, java.lang.String vpnPackage, boolean lockdownEnabled)
  ///
  /// Called by a device or profile owner to configure an always-on VPN connection through a
  /// specific application for the current user. This connection is automatically granted and
  /// persisted after a reboot.
  ///
  /// To support the always-on feature, an app must
  /// <ul>
  ///     <li>declare a android.net.VpnService in its manifest, guarded by
  ///         android.Manifest.permission\#BIND_VPN_SERVICE;</li>
  ///     <li>target android.os.Build.VERSION_CODES\#N API 24 or above; and</li>
  ///     <li><i>not</i> explicitly opt out of the feature through
  ///         android.net.VpnService\#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON.</li>
  /// </ul>
  /// The call will fail if called with the package name of an unsupported VPN app.
  ///@param vpnPackage The package name for an installed VPN app on the device, or {@code null} to
  ///        remove an existing always-on VPN configuration.
  /// This value may be {@code null}.
  ///@param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or
  ///        {@code false} otherwise. This carries the risk that any failure of the VPN provider
  ///        could break networking for all apps. This has no effect when clearing.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  ///@throws NameNotFoundException if {@code vpnPackage} is not installed.
  ///@throws UnsupportedOperationException if {@code vpnPackage} exists but does not support being
  ///         set as always-on, or if always-on VPN is not available.
  ///@param admin This value must never be {@code null}.
  void setAlwaysOnVpnPackage(componentname_.ComponentName admin,
          jni.JniString vpnPackage, bool lockdownEnabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAlwaysOnVpnPackage,
          jni.JniType.voidType,
          [admin.reference, vpnPackage.reference, lockdownEnabled]).check();

  static final _id_getAlwaysOnVpnPackage = jniAccessors.getMethodIDOf(
      _classRef,
      "getAlwaysOnVpnPackage",
      "(Landroid/content/ComponentName;)Ljava/lang/String;");

  /// from: public java.lang.String getAlwaysOnVpnPackage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device or profile owner to read the name of the package administering an
  /// always-on VPN connection for the current user. If there is no such package, or the always-on
  /// VPN is provided by the system instead of by an application, {@code null} will be returned.
  ///@param admin This value must never be {@code null}.
  ///@return Package name of VPN controller responsible for always-on VPN, or {@code null} if none
  ///         is set.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  jni.JniString getAlwaysOnVpnPackage(componentname_.ComponentName admin) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAlwaysOnVpnPackage,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setCameraDisabled = jniAccessors.getMethodIDOf(
      _classRef, "setCameraDisabled", "(Landroid/content/ComponentName;Z)V");

  /// from: public void setCameraDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by an application that is administering the device to disable all cameras on the
  /// device, for this user. After setting this, no applications running as this user will be able
  /// to access any cameras on the device.
  ///
  /// If the caller is device owner, then the restriction will be applied to all users.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_DISABLE_CAMERA to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled Whether or not the camera should be disabled.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not use
  ///             DeviceAdminInfo\#USES_POLICY_DISABLE_CAMERA.
  void setCameraDisabled(componentname_.ComponentName admin, bool disabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCameraDisabled,
          jni.JniType.voidType, [admin.reference, disabled]).check();

  static final _id_getCameraDisabled = jniAccessors.getMethodIDOf(
      _classRef, "getCameraDisabled", "(Landroid/content/ComponentName;)Z");

  /// from: public boolean getCameraDisabled(android.content.ComponentName admin)
  ///
  /// Determine whether or not the device's cameras have been disabled for this user,
  /// either by the calling admin, if specified, or all admins.
  ///@param admin The name of the admin component to check, or {@code null} to check whether any admins
  /// have disabled the camera
  ///
  /// This value may be {@code null}.
  bool getCameraDisabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getCameraDisabled,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_requestBugreport = jniAccessors.getMethodIDOf(
      _classRef, "requestBugreport", "(Landroid/content/ComponentName;)Z");

  /// from: public boolean requestBugreport(android.content.ComponentName admin)
  ///
  /// Called by a device owner to request a bugreport.
  ///
  /// If the device contains secondary users or profiles, they must be affiliated with the device.
  /// Otherwise a SecurityException will be thrown. See \#isAffiliatedUser.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return {@code true} if the bugreport collection started successfully, or {@code false} if it
  ///         wasn't triggered because a previous bugreport operation is still active (either the
  ///         bugreport is still running or waiting for the user to share or decline)
  ///@throws SecurityException if {@code admin} is not a device owner, or there is at least one
  ///         profile or secondary user that is not affiliated with the device.
  ///@see \#isAffiliatedUser
  bool requestBugreport(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestBugreport,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_setScreenCaptureDisabled = jniAccessors.getMethodIDOf(
      _classRef,
      "setScreenCaptureDisabled",
      "(Landroid/content/ComponentName;Z)V");

  /// from: public void setScreenCaptureDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a device/profile owner to set whether the screen capture is disabled. Disabling
  /// screen capture also prevents the content from being shown on display devices that do not have
  /// a secure video output. See android.view.Display\#FLAG_SECURE for more details about
  /// secure surfaces and secure displays.
  ///
  /// The calling device admin must be a device or profile owner. If it is not, a security
  /// exception will be thrown.
  ///
  /// From version android.os.Build.VERSION_CODES\#M disabling screen capture also blocks
  /// assist requests for all activities of the relevant user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled Whether screen capture is disabled or not.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setScreenCaptureDisabled(
          componentname_.ComponentName admin, bool disabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScreenCaptureDisabled,
          jni.JniType.voidType, [admin.reference, disabled]).check();

  static final _id_getScreenCaptureDisabled = jniAccessors.getMethodIDOf(
      _classRef,
      "getScreenCaptureDisabled",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean getScreenCaptureDisabled(android.content.ComponentName admin)
  ///
  /// Determine whether or not screen capture has been disabled by the calling
  /// admin, if specified, or all admins.
  ///@param admin The name of the admin component to check, or {@code null} to check whether any admins
  /// have disabled screen capture.
  ///
  /// This value may be {@code null}.
  bool getScreenCaptureDisabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getScreenCaptureDisabled,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_setAutoTimeRequired = jniAccessors.getMethodIDOf(
      _classRef, "setAutoTimeRequired", "(Landroid/content/ComponentName;Z)V");

  /// from: public void setAutoTimeRequired(android.content.ComponentName admin, boolean required)
  ///
  /// Called by a device or profile owner to set whether auto time is required. If auto time is
  /// required, no user will be able set the date and time and network date and time will be used.
  ///
  /// Note: if auto time is required the user can still manually set the time zone.
  ///
  /// The calling device admin must be a device or profile owner. If it is not, a security
  /// exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param required Whether auto time is set required or not.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setAutoTimeRequired(
          componentname_.ComponentName admin, bool required0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAutoTimeRequired,
          jni.JniType.voidType, [admin.reference, required0]).check();

  static final _id_getAutoTimeRequired =
      jniAccessors.getMethodIDOf(_classRef, "getAutoTimeRequired", "()Z");

  /// from: public boolean getAutoTimeRequired()
  ///
  /// @return true if auto time is required.
  bool getAutoTimeRequired() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutoTimeRequired, jni.JniType.booleanType, []).boolean;

  static final _id_setKeyguardDisabledFeatures = jniAccessors.getMethodIDOf(
      _classRef,
      "setKeyguardDisabledFeatures",
      "(Landroid/content/ComponentName;I)V");

  /// from: public void setKeyguardDisabledFeatures(android.content.ComponentName admin, int which)
  ///
  /// Called by an application that is administering the device to disable keyguard customizations,
  /// such as widgets. After setting this, keyguard features will be disabled according to the
  /// provided feature list.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_DISABLE_KEYGUARD_FEATURES to be able to call this method;
  /// if it has not, a security exception will be thrown.
  ///
  /// Calling this from a managed profile before version android.os.Build.VERSION_CODES\#M
  /// will throw a security exception. From version android.os.Build.VERSION_CODES\#M the
  /// profile owner of a managed profile can set:
  /// <ul>
  /// <li>\#KEYGUARD_DISABLE_TRUST_AGENTS, which affects the parent user, but only if there
  /// is no separate challenge set on the managed profile.
  /// <li>\#KEYGUARD_DISABLE_FINGERPRINT, \#KEYGUARD_DISABLE_FACE or
  /// \#KEYGUARD_DISABLE_IRIS which affects the managed profile challenge if
  /// there is one, or the parent user otherwise.
  /// <li>\#KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS which affects notifications generated
  /// by applications in the managed profile.
  /// </ul>
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS, \#KEYGUARD_DISABLE_FINGERPRINT,
  /// \#KEYGUARD_DISABLE_FACE and \#KEYGUARD_DISABLE_IRIS can also be
  /// set on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///
  /// Requests to disable other features on a managed profile will be ignored.
  ///
  /// The admin can check which features have been disabled by calling
  /// \#getKeyguardDisabledFeatures(ComponentName)
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param which The disabled features flag which can be either
  ///            \#KEYGUARD_DISABLE_FEATURES_NONE (default),
  ///            \#KEYGUARD_DISABLE_FEATURES_ALL, or a combination of
  ///            \#KEYGUARD_DISABLE_WIDGETS_ALL, \#KEYGUARD_DISABLE_SECURE_CAMERA,
  ///            \#KEYGUARD_DISABLE_SECURE_NOTIFICATIONS,
  ///            \#KEYGUARD_DISABLE_TRUST_AGENTS,
  ///            \#KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS,
  ///            \#KEYGUARD_DISABLE_FINGERPRINT,
  ///            \#KEYGUARD_DISABLE_FACE,
  ///            \#KEYGUARD_DISABLE_IRIS.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not user
  ///             DeviceAdminInfo\#USES_POLICY_DISABLE_KEYGUARD_FEATURES
  void setKeyguardDisabledFeatures(
          componentname_.ComponentName admin, int which) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setKeyguardDisabledFeatures,
          jni.JniType.voidType,
          [admin.reference, which]).check();

  static final _id_getKeyguardDisabledFeatures = jniAccessors.getMethodIDOf(
      _classRef,
      "getKeyguardDisabledFeatures",
      "(Landroid/content/ComponentName;)I");

  /// from: public int getKeyguardDisabledFeatures(android.content.ComponentName admin)
  ///
  /// Determine whether or not features have been disabled in keyguard either by the calling
  /// admin, if specified, or all admins that set restrictions on this user and its participating
  /// profiles. Restrictions on profiles that have a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to check whether any
  /// admins have disabled features in keyguard.
  /// This value may be {@code null}.
  ///@return bitfield of flags. See \#setKeyguardDisabledFeatures(ComponentName, int)
  /// for a list.
  int getKeyguardDisabledFeatures(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getKeyguardDisabledFeatures,
          jni.JniType.intType,
          [admin.reference]).integer;

  static final _id_isDeviceOwnerApp = jniAccessors.getMethodIDOf(
      _classRef, "isDeviceOwnerApp", "(Ljava/lang/String;)Z");

  /// from: public boolean isDeviceOwnerApp(java.lang.String packageName)
  ///
  /// Used to determine if a particular package has been registered as a Device Owner app.
  /// A device owner app is a special device admin that cannot be deactivated by the user, once
  /// activated as a device admin. It also cannot be uninstalled. To check whether a particular
  /// package is currently registered as the device owner app, pass in the package name from
  /// Context\#getPackageName() to this method.<p/>This is useful for device
  /// admin apps that want to check whether they are also registered as the device owner app. The
  /// exact mechanism by which a device admin app is registered as a device owner app is defined by
  /// the setup process.
  ///@param packageName the package name of the app, to compare with the registered device owner
  /// app, if any.
  ///@return whether or not the package is registered as the device owner app.
  bool isDeviceOwnerApp(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_isDeviceOwnerApp,
          jni.JniType.booleanType, [packageName.reference]).boolean;

  static final _id_clearDeviceOwnerApp = jniAccessors.getMethodIDOf(
      _classRef, "clearDeviceOwnerApp", "(Ljava/lang/String;)V");

  /// from: public void clearDeviceOwnerApp(java.lang.String packageName)
  ///
  /// Clears the current device owner. The caller must be the device owner. This function should be
  /// used cautiously as once it is called it cannot be undone. The device owner can only be set as
  /// a part of device setup, before it completes.
  ///
  /// While some policies previously set by the device owner will be cleared by this method, it is
  /// a best-effort process and some other policies will still remain in place after the device
  /// owner is cleared.
  ///@param packageName The package name of the device owner.
  ///@throws SecurityException if the caller is not in {@code packageName} or {@code packageName}
  ///             does not own the current device owner component.
  ///@deprecated This method is expected to be used for testing purposes only. The device owner
  /// will lose control of the device and its data after calling it. In order to protect any
  /// sensitive data that remains on the device, it is advised that the device owner factory resets
  /// the device instead of calling this method. See \#wipeData(int).
  void clearDeviceOwnerApp(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearDeviceOwnerApp,
          jni.JniType.voidType, [packageName.reference]).check();

  static final _id_clearProfileOwner = jniAccessors.getMethodIDOf(
      _classRef, "clearProfileOwner", "(Landroid/content/ComponentName;)V");

  /// from: public void clearProfileOwner(android.content.ComponentName admin)
  ///
  /// Clears the active profile owner. The caller must be the profile owner of this user, otherwise
  /// a SecurityException will be thrown. This method is not available to managed profile owners.
  ///
  /// While some policies previously set by the profile owner will be cleared by this method, it is
  /// a best-effort process and some other policies will still remain in place after the profile
  /// owner is cleared.
  ///@param admin The component to remove as the profile owner.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not an active profile owner, or the method is
  /// being called from a managed profile.
  ///@deprecated This method is expected to be used for testing purposes only. The profile owner
  /// will lose control of the user and its data after calling it. In order to protect any
  /// sensitive data that remains on this user, it is advised that the profile owner deletes it
  /// instead of calling this method. See \#wipeData(int).
  void clearProfileOwner(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearProfileOwner,
          jni.JniType.voidType, [admin.reference]).check();

  static final _id_setDeviceOwnerLockScreenInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "setDeviceOwnerLockScreenInfo",
      "(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V");

  /// from: public void setDeviceOwnerLockScreenInfo(android.content.ComponentName admin, java.lang.CharSequence info)
  ///
  /// Sets the device owner information to be shown on the lock screen.
  ///
  /// If the device owner information is {@code null} or empty then the device owner info is
  /// cleared and the user owner info is shown on the lock screen if it is set.
  ///
  /// If the device owner information contains only whitespaces then the message on the lock screen
  /// will be blank and the user will not be allowed to change it.
  ///
  /// If the device owner information needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this string accordingly.
  ///@param admin The name of the admin component to check.
  /// This value must never be {@code null}.
  ///@param info Device owner information which will be displayed instead of the user owner info.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setDeviceOwnerLockScreenInfo(
          componentname_.ComponentName admin, jni.JniObject info) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDeviceOwnerLockScreenInfo,
          jni.JniType.voidType,
          [admin.reference, info.reference]).check();

  static final _id_getDeviceOwnerLockScreenInfo = jniAccessors.getMethodIDOf(
      _classRef, "getDeviceOwnerLockScreenInfo", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getDeviceOwnerLockScreenInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The device owner information. If it is not set returns {@code null}.
  jni.JniObject getDeviceOwnerLockScreenInfo() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDeviceOwnerLockScreenInfo, jni.JniType.objectType, []).object);

  static final _id_setPackagesSuspended = jniAccessors.getMethodIDOf(
      _classRef,
      "setPackagesSuspended",
      "(Landroid/content/ComponentName;[Ljava/lang/String;Z)[Ljava/lang/String;");

  /// from: public java.lang.String[] setPackagesSuspended(android.content.ComponentName admin, java.lang.String[] packageNames, boolean suspended)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device or profile owners to suspend packages for this user. This function can be
  /// called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_PACKAGE_ACCESS scope via \#setDelegatedScopes.
  ///
  /// A suspended package will not be able to start activities. Its notifications will be hidden,
  /// it will not show up in recents, will not be able to show toasts or dialogs or ring the
  /// device.
  ///
  /// The package must already be installed. If the package is uninstalled while suspended the
  /// package will no longer be suspended. The admin can block this by using
  /// \#setUninstallBlocked.
  ///@param admin The name of the admin component to check, or {@code null} if the caller is a
  ///            package access delegate.
  /// This value must never be {@code null}.
  ///@param packageNames The package names to suspend or unsuspend.
  /// This value must never be {@code null}.
  ///@param suspended If set to {@code true} than the packages will be suspended, if set to
  ///            {@code false} the packages will be unsuspended.
  ///@return an array of package names for which the suspended status is not set as requested in
  ///         this method.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  jni.JniObject setPackagesSuspended(componentname_.ComponentName admin,
          jni.JniObject packageNames, bool suspended) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setPackagesSuspended,
          jni.JniType.objectType,
          [admin.reference, packageNames.reference, suspended]).object);

  static final _id_isPackageSuspended = jniAccessors.getMethodIDOf(
      _classRef,
      "isPackageSuspended",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean isPackageSuspended(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Determine if a package is suspended. This function can be called by a device owner, profile
  /// owner, or by a delegate given the \#DELEGATION_PACKAGE_ACCESS scope via
  /// \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a package access delegate.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package to retrieve the suspended status of.
  ///@return {@code true} if the package is suspended or {@code false} if the package is not
  ///         suspended, could not be found or an error occurred.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@throws NameNotFoundException if the package could not be found.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  bool isPackageSuspended(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isPackageSuspended,
          jni.JniType.booleanType,
          [admin.reference, packageName.reference]).boolean;

  static final _id_setProfileEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setProfileEnabled", "(Landroid/content/ComponentName;)V");

  /// from: public void setProfileEnabled(android.content.ComponentName admin)
  ///
  /// Sets the enabled state of the profile. A profile should be enabled only once it is ready to
  /// be used. Only the profile owner can call this.
  ///@see \#isProfileOwnerApp
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setProfileEnabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProfileEnabled,
          jni.JniType.voidType, [admin.reference]).check();

  static final _id_setProfileName = jniAccessors.getMethodIDOf(_classRef,
      "setProfileName", "(Landroid/content/ComponentName;Ljava/lang/String;)V");

  /// from: public void setProfileName(android.content.ComponentName admin, java.lang.String profileName)
  ///
  /// Sets the name of the profile. In the device owner case it sets the name of the user which it
  /// is called from. Only a profile owner or device owner can call this. If this is never called
  /// by the profile or device owner, the name will be set to default values.
  ///@see \#isProfileOwnerApp
  ///@see \#isDeviceOwnerApp
  ///@param admin Which DeviceAdminReceiver this request is associate with.
  /// This value must never be {@code null}.
  ///@param profileName The name of the profile.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setProfileName(
          componentname_.ComponentName admin, jni.JniString profileName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setProfileName,
          jni.JniType.voidType,
          [admin.reference, profileName.reference]).check();

  static final _id_isProfileOwnerApp = jniAccessors.getMethodIDOf(
      _classRef, "isProfileOwnerApp", "(Ljava/lang/String;)Z");

  /// from: public boolean isProfileOwnerApp(java.lang.String packageName)
  ///
  /// Used to determine if a particular package is registered as the profile owner for the
  /// user. A profile owner is a special device admin that has additional privileges
  /// within the profile.
  ///@param packageName The package name of the app to compare with the registered profile owner.
  ///@return Whether or not the package is registered as the profile owner.
  bool isProfileOwnerApp(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_isProfileOwnerApp,
          jni.JniType.booleanType, [packageName.reference]).boolean;

  static final _id_addPersistentPreferredActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "addPersistentPreferredActivity",
      "(Landroid/content/ComponentName;Landroid/content/IntentFilter;Landroid/content/ComponentName;)V");

  /// from: public void addPersistentPreferredActivity(android.content.ComponentName admin, android.content.IntentFilter filter, android.content.ComponentName activity)
  ///
  /// Called by a profile owner or device owner to set a default activity that the system selects
  /// to handle intents that match the given IntentFilter. This activity will remain the
  /// default intent handler even if the set of potential event handlers for the intent filter
  /// changes and if the intent preferences are reset.
  ///
  /// Note that the caller should still declare the activity in the manifest, the API just sets
  /// the activity to be the default one to handle the given intent filter.
  ///
  /// The default disambiguation mechanism takes over if the activity is not installed (anymore).
  /// When the activity is (re)installed, it is automatically reset as default intent handler for
  /// the filter.
  ///
  /// The calling device admin must be a profile owner or device owner. If it is not, a security
  /// exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param filter The IntentFilter for which a default handler is added.
  ///@param activity The Activity that is added as default intent handler.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void addPersistentPreferredActivity(
          componentname_.ComponentName admin,
          intentfilter_.IntentFilter filter,
          componentname_.ComponentName activity) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addPersistentPreferredActivity,
          jni.JniType.voidType,
          [admin.reference, filter.reference, activity.reference]).check();

  static final _id_clearPackagePersistentPreferredActivities =
      jniAccessors.getMethodIDOf(
          _classRef,
          "clearPackagePersistentPreferredActivities",
          "(Landroid/content/ComponentName;Ljava/lang/String;)V");

  /// from: public void clearPackagePersistentPreferredActivities(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Called by a profile owner or device owner to remove all persistent intent handler preferences
  /// associated with the given package that were set by \#addPersistentPreferredActivity.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package for which preferences are removed.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void clearPackagePersistentPreferredActivities(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_clearPackagePersistentPreferredActivities,
          jni.JniType.voidType,
          [admin.reference, packageName.reference]).check();

  static final _id_setApplicationRestrictionsManagingPackage =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setApplicationRestrictionsManagingPackage",
          "(Landroid/content/ComponentName;Ljava/lang/String;)V");

  /// from: public void setApplicationRestrictionsManagingPackage(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Called by a profile owner or device owner to grant permission to a package to manage
  /// application restrictions for the calling user via \#setApplicationRestrictions and
  /// \#getApplicationRestrictions.
  ///
  /// This permission is persistent until it is later cleared by calling this method with a
  /// {@code null} value or uninstalling the managing package.
  ///
  /// The supplied application restriction managing package must be installed when calling this
  /// API, otherwise an NameNotFoundException will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The package name which will be given access to application restrictions
  ///            APIs. If {@code null} is given the current package will be cleared.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@throws NameNotFoundException if {@code packageName} is not found
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#setDelegatedScopes
  /// with the \#DELEGATION_APP_RESTRICTIONS scope instead.
  void setApplicationRestrictionsManagingPackage(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setApplicationRestrictionsManagingPackage,
          jni.JniType.voidType,
          [admin.reference, packageName.reference]).check();

  static final _id_getApplicationRestrictionsManagingPackage =
      jniAccessors.getMethodIDOf(
          _classRef,
          "getApplicationRestrictionsManagingPackage",
          "(Landroid/content/ComponentName;)Ljava/lang/String;");

  /// from: public java.lang.String getApplicationRestrictionsManagingPackage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner or device owner to retrieve the application restrictions managing
  /// package for the current user, or {@code null} if none is set. If there are multiple
  /// delegates this function will return one of them.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The package name allowed to manage application restrictions on the current user, or
  ///         {@code null} if none is set.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#getDelegatePackages
  /// with the \#DELEGATION_APP_RESTRICTIONS scope instead.
  jni.JniString getApplicationRestrictionsManagingPackage(
          componentname_.ComponentName admin) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationRestrictionsManagingPackage,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_isCallerApplicationRestrictionsManagingPackage =
      jniAccessors.getMethodIDOf(
          _classRef, "isCallerApplicationRestrictionsManagingPackage", "()Z");

  /// from: public boolean isCallerApplicationRestrictionsManagingPackage()
  ///
  /// Called by any application to find out whether it has been granted permission via
  /// \#setApplicationRestrictionsManagingPackage to manage application restrictions
  /// for the calling user.
  ///
  /// This is done by comparing the calling Linux uid with the uid of the package specified by
  /// that method.
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#getDelegatedScopes
  /// instead.
  bool isCallerApplicationRestrictionsManagingPackage() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isCallerApplicationRestrictionsManagingPackage,
          jni.JniType.booleanType, []).boolean;

  static final _id_setApplicationRestrictions = jniAccessors.getMethodIDOf(
      _classRef,
      "setApplicationRestrictions",
      "(Landroid/content/ComponentName;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void setApplicationRestrictions(android.content.ComponentName admin, java.lang.String packageName, android.os.Bundle settings)
  ///
  /// Sets the application restrictions for a given target application running in the calling user.
  ///
  /// The caller must be a profile or device owner on that user, or the package allowed to manage
  /// application restrictions via \#setDelegatedScopes with the
  /// \#DELEGATION_APP_RESTRICTIONS scope; otherwise a security exception will be thrown.
  ///
  /// The provided Bundle consists of key-value pairs, where the types of values may be:
  /// <ul>
  /// <li>{@code boolean}
  /// <li>{@code int}
  /// <li>{@code String} or {@code String[]}
  /// <li>From android.os.Build.VERSION_CODES\#M, {@code Bundle} or {@code Bundle[]}
  /// </ul>
  ///
  /// If the restrictions are not available yet, but may be applied in the near future, the caller
  /// can notify the target application of that by adding
  /// UserManager\#KEY_RESTRICTIONS_PENDING to the settings parameter.
  ///
  /// The application restrictions are only made visible to the target application via
  /// UserManager\#getApplicationRestrictions(String), in addition to the profile or device
  /// owner, and the application restrictions managing package via
  /// \#getApplicationRestrictions.
  ///
  /// NOTE: The method performs disk I/O and shouldn't be called on the main thread
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if called by the application restrictions managing package.
  /// This value may be {@code null}.
  ///@param packageName The name of the package to update restricted settings for.
  ///@param settings A Bundle to be parsed by the receiving application, conveying a new
  ///            set of active restrictions.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_APP_RESTRICTIONS
  ///@see UserManager\#KEY_RESTRICTIONS_PENDING
  void setApplicationRestrictions(componentname_.ComponentName admin,
          jni.JniString packageName, bundle_.Bundle settings) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setApplicationRestrictions,
          jni.JniType.voidType,
          [admin.reference, packageName.reference, settings.reference]).check();

  static final _id_setTrustAgentConfiguration = jniAccessors.getMethodIDOf(
      _classRef,
      "setTrustAgentConfiguration",
      "(Landroid/content/ComponentName;Landroid/content/ComponentName;Landroid/os/PersistableBundle;)V");

  /// from: public void setTrustAgentConfiguration(android.content.ComponentName admin, android.content.ComponentName target, android.os.PersistableBundle configuration)
  ///
  /// Sets a list of configuration features to enable for a trust agent component. This is meant to
  /// be used in conjunction with \#KEYGUARD_DISABLE_TRUST_AGENTS, which disables all trust
  /// agents but those enabled by this function call. If flag
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS is not set, then this call has no effect.
  ///
  /// For any specific trust agent, whether it is disabled or not depends on the aggregated state
  /// of each admin's \#KEYGUARD_DISABLE_TRUST_AGENTS setting and its trust agent
  /// configuration as set by this function call. In particular: if any admin sets
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS and does not additionally set any
  /// trust agent configuration, the trust agent is disabled completely. Otherwise, the trust agent
  /// will receive the list of configurations from all admins who set
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS and aggregate the configurations to determine its
  /// behavior. The exact meaning of aggregation is trust-agent-specific.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_DISABLE_KEYGUARD_FEATURES to be able to call this method;
  /// if not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set the configuration for
  /// the parent profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param target Component name of the agent to be configured.
  /// This value must never be {@code null}.
  ///@param configuration Trust-agent-specific feature configuration bundle. Please consult
  ///        documentation of the specific trust agent to determine the interpretation of this
  ///        bundle.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not use
  ///             DeviceAdminInfo\#USES_POLICY_DISABLE_KEYGUARD_FEATURES
  void setTrustAgentConfiguration(
          componentname_.ComponentName admin,
          componentname_.ComponentName target,
          persistablebundle_.PersistableBundle configuration) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTrustAgentConfiguration,
          jni.JniType.voidType,
          [admin.reference, target.reference, configuration.reference]).check();

  static final _id_getTrustAgentConfiguration = jniAccessors.getMethodIDOf(
      _classRef,
      "getTrustAgentConfiguration",
      "(Landroid/content/ComponentName;Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<android.os.PersistableBundle> getTrustAgentConfiguration(android.content.ComponentName admin, android.content.ComponentName agent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets configuration for the given trust agent based on aggregating all calls to
  /// \#setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle) for
  /// all device admins.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to retrieve the configuration set
  /// on the parent profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with. If null,
  /// this function returns a list of configurations for all admins that declare
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS. If any admin declares
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS but doesn't call
  /// \#setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)
  /// for this {@param agent} or calls it with a null configuration, null is returned.
  /// This value may be {@code null}.
  ///@param agent Which component to get enabled features for.
  /// This value must never be {@code null}.
  ///@return configuration for the given trust agent.
  jni.JniObject getTrustAgentConfiguration(componentname_.ComponentName admin,
          componentname_.ComponentName agent) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTrustAgentConfiguration,
          jni.JniType.objectType,
          [admin.reference, agent.reference]).object);

  static final _id_setCrossProfileCallerIdDisabled = jniAccessors.getMethodIDOf(
      _classRef,
      "setCrossProfileCallerIdDisabled",
      "(Landroid/content/ComponentName;Z)V");

  /// from: public void setCrossProfileCallerIdDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a profile owner of a managed profile to set whether caller-Id information from the
  /// managed profile will be shown in the parent profile, for incoming calls.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled If true caller-Id information in the managed profile is not displayed.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setCrossProfileCallerIdDisabled(
          componentname_.ComponentName admin, bool disabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCrossProfileCallerIdDisabled,
          jni.JniType.voidType,
          [admin.reference, disabled]).check();

  static final _id_getCrossProfileCallerIdDisabled = jniAccessors.getMethodIDOf(
      _classRef,
      "getCrossProfileCallerIdDisabled",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean getCrossProfileCallerIdDisabled(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to determine whether or not caller-Id
  /// information has been disabled.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  bool getCrossProfileCallerIdDisabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getCrossProfileCallerIdDisabled,
          jni.JniType.booleanType,
          [admin.reference]).boolean;

  static final _id_setCrossProfileContactsSearchDisabled =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setCrossProfileContactsSearchDisabled",
          "(Landroid/content/ComponentName;Z)V");

  /// from: public void setCrossProfileContactsSearchDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a profile owner of a managed profile to set whether contacts search from the
  /// managed profile will be shown in the parent profile, for incoming calls.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled If true contacts search in the managed profile is not displayed.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setCrossProfileContactsSearchDisabled(
          componentname_.ComponentName admin, bool disabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCrossProfileContactsSearchDisabled,
          jni.JniType.voidType,
          [admin.reference, disabled]).check();

  static final _id_getCrossProfileContactsSearchDisabled =
      jniAccessors.getMethodIDOf(
          _classRef,
          "getCrossProfileContactsSearchDisabled",
          "(Landroid/content/ComponentName;)Z");

  /// from: public boolean getCrossProfileContactsSearchDisabled(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to determine whether or not contacts search
  /// has been disabled.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  bool getCrossProfileContactsSearchDisabled(
          componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getCrossProfileContactsSearchDisabled,
          jni.JniType.booleanType,
          [admin.reference]).boolean;

  static final _id_setBluetoothContactSharingDisabled =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setBluetoothContactSharingDisabled",
          "(Landroid/content/ComponentName;Z)V");

  /// from: public void setBluetoothContactSharingDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a profile owner of a managed profile to set whether bluetooth devices can access
  /// enterprise contacts.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///
  /// This API works on managed profile only.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled If true, bluetooth devices cannot access enterprise contacts.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setBluetoothContactSharingDisabled(
          componentname_.ComponentName admin, bool disabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setBluetoothContactSharingDisabled,
          jni.JniType.voidType,
          [admin.reference, disabled]).check();

  static final _id_getBluetoothContactSharingDisabled =
      jniAccessors.getMethodIDOf(
          _classRef,
          "getBluetoothContactSharingDisabled",
          "(Landroid/content/ComponentName;)Z");

  /// from: public boolean getBluetoothContactSharingDisabled(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to determine whether or not Bluetooth devices
  /// cannot access enterprise contacts.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///
  /// This API works on managed profile only.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  bool getBluetoothContactSharingDisabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getBluetoothContactSharingDisabled,
          jni.JniType.booleanType,
          [admin.reference]).boolean;

  static final _id_addCrossProfileIntentFilter = jniAccessors.getMethodIDOf(
      _classRef,
      "addCrossProfileIntentFilter",
      "(Landroid/content/ComponentName;Landroid/content/IntentFilter;I)V");

  /// from: public void addCrossProfileIntentFilter(android.content.ComponentName admin, android.content.IntentFilter filter, int flags)
  ///
  /// Called by the profile owner of a managed profile so that some intents sent in the managed
  /// profile can also be resolved in the parent, or vice versa. Only activity intents are
  /// supported.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param filter The IntentFilter the intent has to match to be also resolved in the
  ///            other profile
  ///@param flags DevicePolicyManager\#FLAG_MANAGED_CAN_ACCESS_PARENT and
  ///            DevicePolicyManager\#FLAG_PARENT_CAN_ACCESS_MANAGED are supported.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void addCrossProfileIntentFilter(componentname_.ComponentName admin,
          intentfilter_.IntentFilter filter, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addCrossProfileIntentFilter,
          jni.JniType.voidType,
          [admin.reference, filter.reference, flags]).check();

  static final _id_clearCrossProfileIntentFilters = jniAccessors.getMethodIDOf(
      _classRef,
      "clearCrossProfileIntentFilters",
      "(Landroid/content/ComponentName;)V");

  /// from: public void clearCrossProfileIntentFilters(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to remove the cross-profile intent filters
  /// that go from the managed profile to the parent, or from the parent to the managed profile.
  /// Only removes those that have been set by the profile owner.
  ///
  /// _Note_: A list of default cross profile intent filters are set up by the system when
  /// the profile is created, some of them ensure the proper functioning of the profile, while
  /// others enable sharing of data from the parent to the managed profile for user convenience.
  /// These default intent filters are not cleared when this API is called. If the default cross
  /// profile data sharing is not desired, they can be disabled with
  /// UserManager\#DISALLOW_SHARE_INTO_MANAGED_PROFILE.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void clearCrossProfileIntentFilters(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_clearCrossProfileIntentFilters,
          jni.JniType.voidType,
          [admin.reference]).check();

  static final _id_setPermittedAccessibilityServices =
      jniAccessors.getMethodIDOf(_classRef, "setPermittedAccessibilityServices",
          "(Landroid/content/ComponentName;Ljava/util/List;)Z");

  /// from: public boolean setPermittedAccessibilityServices(android.content.ComponentName admin, java.util.List<java.lang.String> packageNames)
  ///
  /// Called by a profile or device owner to set the permitted
  /// android.accessibilityservice.AccessibilityService. When set by
  /// a device owner or profile owner the restriction applies to all profiles of the user the
  /// device owner or profile owner is an admin for. By default, the user can use any accessibility
  /// service. When zero or more packages have been added, accessibility services that are not in
  /// the list and not part of the system can not be enabled by the user.
  ///
  /// Calling with a null value for the list disables the restriction so that all services can be
  /// used, calling with an empty list only allows the built-in system services. Any non-system
  /// accessibility service that's currently enabled must be included in the list.
  ///
  /// System accessibility services are always available to the user the list can't modify this.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageNames List of accessibility service package names.
  ///@return {@code true} if the operation succeeded, or {@code false} if the list didn't
  ///         contain every enabled non-system accessibility service.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  bool setPermittedAccessibilityServices(
          componentname_.ComponentName admin, jni.JniObject packageNames) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPermittedAccessibilityServices,
          jni.JniType.booleanType,
          [admin.reference, packageNames.reference]).boolean;

  static final _id_getPermittedAccessibilityServices =
      jniAccessors.getMethodIDOf(_classRef, "getPermittedAccessibilityServices",
          "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getPermittedAccessibilityServices(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of permitted accessibility services set by this device or profile owner.
  ///
  /// An empty list means no accessibility services except system services are allowed. Null means
  /// all accessibility services are allowed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return List of accessiblity service package names.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  jni.JniObject getPermittedAccessibilityServices(
          componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPermittedAccessibilityServices,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setPermittedInputMethods = jniAccessors.getMethodIDOf(
      _classRef,
      "setPermittedInputMethods",
      "(Landroid/content/ComponentName;Ljava/util/List;)Z");

  /// from: public boolean setPermittedInputMethods(android.content.ComponentName admin, java.util.List<java.lang.String> packageNames)
  ///
  /// Called by a profile or device owner to set the permitted input methods services. When set by
  /// a device owner or profile owner the restriction applies to all profiles of the user the
  /// device owner or profile owner is an admin for. By default, the user can use any input method.
  /// When zero or more packages have been added, input method that are not in the list and not
  /// part of the system can not be enabled by the user. This method will fail if it is called for
  /// a admin that is not for the foreground user or a profile of the foreground user. Any
  /// non-system input method service that's currently enabled must be included in the list.
  ///
  /// Calling with a null value for the list disables the restriction so that all input methods can
  /// be used, calling with an empty list disables all but the system's own input methods.
  ///
  /// System input methods are always available to the user this method can't modify this.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageNames List of input method package names.
  ///@return {@code true} if the operation succeeded, or {@code false} if the list didn't
  ///        contain every enabled non-system input method service.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  bool setPermittedInputMethods(
          componentname_.ComponentName admin, jni.JniObject packageNames) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPermittedInputMethods,
          jni.JniType.booleanType,
          [admin.reference, packageNames.reference]).boolean;

  static final _id_getPermittedInputMethods = jniAccessors.getMethodIDOf(
      _classRef,
      "getPermittedInputMethods",
      "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getPermittedInputMethods(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of permitted input methods set by this device or profile owner.
  ///
  /// An empty list means no input methods except system input methods are allowed. Null means all
  /// input methods are allowed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return List of input method package names.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  jni.JniObject getPermittedInputMethods(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPermittedInputMethods,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setPermittedCrossProfileNotificationListeners =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setPermittedCrossProfileNotificationListeners",
          "(Landroid/content/ComponentName;Ljava/util/List;)Z");

  /// from: public boolean setPermittedCrossProfileNotificationListeners(android.content.ComponentName admin, java.util.List<java.lang.String> packageList)
  ///
  /// Called by a profile owner of a managed profile to set the packages that are allowed to use
  /// a android.service.notification.NotificationListenerService in the primary user to
  /// see notifications from the managed profile. By default all packages are permitted by this
  /// policy. When zero or more packages have been added, notification listeners installed on the
  /// primary user that are not in the list and are not part of the system won't receive events
  /// for managed profile notifications.
  ///
  /// Calling with a {@code null} value for the list disables the restriction so that all
  /// notification listener services be used. Calling with an empty list disables all but the
  /// system's own notification listeners. System notification listener services are always
  /// available to the user.
  ///
  /// If a device or profile owner want to stop notification listeners in their user from seeing
  /// that user's notifications they should prevent that service from running instead (e.g. via
  /// \#setApplicationHidden(ComponentName, String, boolean))
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageList List of package names to whitelist
  /// This value may be {@code null}.
  ///@return true if setting the restriction succeeded. It will fail if called outside a managed
  /// profile
  ///@throws SecurityException if {@code admin} is not a profile owner.
  ///@see android.service.notification.NotificationListenerService
  bool setPermittedCrossProfileNotificationListeners(
          componentname_.ComponentName admin, jni.JniObject packageList) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPermittedCrossProfileNotificationListeners,
          jni.JniType.booleanType,
          [admin.reference, packageList.reference]).boolean;

  static final _id_getPermittedCrossProfileNotificationListeners =
      jniAccessors.getMethodIDOf(
          _classRef,
          "getPermittedCrossProfileNotificationListeners",
          "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getPermittedCrossProfileNotificationListeners(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of packages installed on the primary user that allowed to use a
  /// android.service.notification.NotificationListenerService to receive
  /// notifications from this managed profile, as set by the profile owner.
  ///
  /// An empty list means no notification listener services except system ones are allowed.
  /// A {@code null} return value indicates that all notification listeners are allowed.
  ///@param admin This value must never be {@code null}.
  jni.JniObject getPermittedCrossProfileNotificationListeners(
          componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPermittedCrossProfileNotificationListeners,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_getKeepUninstalledPackages = jniAccessors.getMethodIDOf(
      _classRef,
      "getKeepUninstalledPackages",
      "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getKeepUninstalledPackages(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of apps to keep around as APKs even if no user has currently installed it. This
  /// function can be called by a device owner or by a delegate given the
  /// \#DELEGATION_KEEP_UNINSTALLED_PACKAGES scope via \#setDelegatedScopes.
  ///
  /// Please note that packages returned in this method are not automatically pre-cached.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a keep uninstalled packages delegate.
  /// This value may be {@code null}.
  ///@return List of package names to keep cached.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_KEEP_UNINSTALLED_PACKAGES
  jni.JniObject getKeepUninstalledPackages(
          componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getKeepUninstalledPackages,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setKeepUninstalledPackages = jniAccessors.getMethodIDOf(
      _classRef,
      "setKeepUninstalledPackages",
      "(Landroid/content/ComponentName;Ljava/util/List;)V");

  /// from: public void setKeepUninstalledPackages(android.content.ComponentName admin, java.util.List<java.lang.String> packageNames)
  ///
  /// Set a list of apps to keep around as APKs even if no user has currently installed it. This
  /// function can be called by a device owner or by a delegate given the
  /// \#DELEGATION_KEEP_UNINSTALLED_PACKAGES scope via \#setDelegatedScopes.
  ///
  /// Please note that setting this policy does not imply that specified apps will be
  /// automatically pre-cached.
  ///
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a keep uninstalled packages delegate.
  /// This value may be {@code null}.
  ///@param packageNames List of package names to keep cached.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_KEEP_UNINSTALLED_PACKAGES
  void setKeepUninstalledPackages(
          componentname_.ComponentName admin, jni.JniObject packageNames) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setKeepUninstalledPackages,
          jni.JniType.voidType,
          [admin.reference, packageNames.reference]).check();

  static final _id_createAndManageUser = jniAccessors.getMethodIDOf(
      _classRef,
      "createAndManageUser",
      "(Landroid/content/ComponentName;Ljava/lang/String;Landroid/content/ComponentName;Landroid/os/PersistableBundle;I)Landroid/os/UserHandle;");

  /// from: public android.os.UserHandle createAndManageUser(android.content.ComponentName admin, java.lang.String name, android.content.ComponentName profileOwner, android.os.PersistableBundle adminExtras, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device owner to create a user with the specified name and a given component of
  /// the calling package as profile owner. The UserHandle returned by this method should not be
  /// persisted as user handles are recycled as users are removed and created. If you need to
  /// persist an identifier for this user, use UserManager\#getSerialNumberForUser. The new
  /// user will not be started in the background.
  ///
  /// admin is the DeviceAdminReceiver which is the device owner. profileOwner is also a
  /// DeviceAdminReceiver in the same package as admin, and will become the profile owner and will
  /// be registered as an active admin on the new user. The profile owner package will be installed
  /// on the new user.
  ///
  /// If the adminExtras are not null, they will be stored on the device until the user is started
  /// for the first time. Then the extras will be passed to the admin when onEnable is called.
  /// From android.os.Build.VERSION_CODES\#P onwards, if targeting
  /// android.os.Build.VERSION_CODES\#P, throws UserOperationException instead of
  /// returning {@code null} on failure.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param name The user's name.
  /// This value must never be {@code null}.
  ///@param profileOwner Which DeviceAdminReceiver will be profile owner. Has to be in the
  ///            same package as admin, otherwise no user is created and an
  ///            IllegalArgumentException is thrown.
  /// This value must never be {@code null}.
  ///@param adminExtras Extras that will be passed to onEnable of the admin receiver on the new
  ///            user.
  /// This value may be {@code null}.
  ///@param flags \#SKIP_SETUP_WIZARD, \#MAKE_USER_EPHEMERAL and
  ///        \#LEAVE_ALL_SYSTEM_APPS_ENABLED are supported.
  /// Value is either <code>0</code> or a combination of android.app.admin.DevicePolicyManager\#SKIP_SETUP_WIZARD, android.app.admin.DevicePolicyManager\#MAKE_USER_EPHEMERAL, android.app.admin.DevicePolicyManager.MAKE_USER_DEMO, and android.app.admin.DevicePolicyManager\#LEAVE_ALL_SYSTEM_APPS_ENABLED
  ///@see UserHandle
  ///@return the android.os.UserHandle object for the created user, or {@code null} if the
  ///         user could not be created.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@throws UserOperationException if the user could not be created and the calling app is
  /// targeting android.os.Build.VERSION_CODES\#P and running on
  /// android.os.Build.VERSION_CODES\#P.
  userhandle_.UserHandle createAndManageUser(
          componentname_.ComponentName admin,
          jni.JniString name,
          componentname_.ComponentName profileOwner,
          persistablebundle_.PersistableBundle adminExtras,
          int flags) =>
      userhandle_.UserHandle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createAndManageUser, jni.JniType.objectType, [
        admin.reference,
        name.reference,
        profileOwner.reference,
        adminExtras.reference,
        flags
      ]).object);

  static final _id_removeUser = jniAccessors.getMethodIDOf(
      _classRef,
      "removeUser",
      "(Landroid/content/ComponentName;Landroid/os/UserHandle;)Z");

  /// from: public boolean removeUser(android.content.ComponentName admin, android.os.UserHandle userHandle)
  ///
  /// Called by a device owner to remove a user/profile and all associated data. The primary user
  /// can not be removed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param userHandle the user to remove.
  /// This value must never be {@code null}.
  ///@return {@code true} if the user was removed, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  bool removeUser(componentname_.ComponentName admin,
          userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeUser,
          jni.JniType.booleanType,
          [admin.reference, userHandle.reference]).boolean;

  static final _id_switchUser = jniAccessors.getMethodIDOf(
      _classRef,
      "switchUser",
      "(Landroid/content/ComponentName;Landroid/os/UserHandle;)Z");

  /// from: public boolean switchUser(android.content.ComponentName admin, android.os.UserHandle userHandle)
  ///
  /// Called by a device owner to switch the specified secondary user to the foreground.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param userHandle the user to switch to; null will switch to primary.
  /// This value may be {@code null}.
  ///@return {@code true} if the switch was successful, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see Intent\#ACTION_USER_FOREGROUND
  ///@see \#getSecondaryUsers(ComponentName)
  bool switchUser(componentname_.ComponentName admin,
          userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_switchUser,
          jni.JniType.booleanType,
          [admin.reference, userHandle.reference]).boolean;

  static final _id_startUserInBackground = jniAccessors.getMethodIDOf(
      _classRef,
      "startUserInBackground",
      "(Landroid/content/ComponentName;Landroid/os/UserHandle;)I");

  /// from: public int startUserInBackground(android.content.ComponentName admin, android.os.UserHandle userHandle)
  ///
  /// Called by a device owner to start the specified secondary user in background.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param userHandle the user to be started in background.
  /// This value must never be {@code null}.
  ///@return one of the following result codes:
  /// UserManager\#USER_OPERATION_ERROR_UNKNOWN,
  /// UserManager\#USER_OPERATION_SUCCESS,
  /// UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE,
  /// UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS,
  /// Value is android.os.UserManager\#USER_OPERATION_SUCCESS, android.os.UserManager\#USER_OPERATION_ERROR_UNKNOWN, android.os.UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE, android.os.UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS, android.os.UserManager\#USER_OPERATION_ERROR_CURRENT_USER, android.os.UserManager\#USER_OPERATION_ERROR_LOW_STORAGE, or android.os.UserManager\#USER_OPERATION_ERROR_MAX_USERS
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#getSecondaryUsers(ComponentName)
  int startUserInBackground(componentname_.ComponentName admin,
          userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(reference, _id_startUserInBackground,
          jni.JniType.intType, [admin.reference, userHandle.reference]).integer;

  static final _id_stopUser = jniAccessors.getMethodIDOf(_classRef, "stopUser",
      "(Landroid/content/ComponentName;Landroid/os/UserHandle;)I");

  /// from: public int stopUser(android.content.ComponentName admin, android.os.UserHandle userHandle)
  ///
  /// Called by a device owner to stop the specified secondary user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param userHandle the user to be stopped.
  /// This value must never be {@code null}.
  ///@return one of the following result codes:
  /// UserManager\#USER_OPERATION_ERROR_UNKNOWN,
  /// UserManager\#USER_OPERATION_SUCCESS,
  /// UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE,
  /// UserManager\#USER_OPERATION_ERROR_CURRENT_USER
  /// Value is android.os.UserManager\#USER_OPERATION_SUCCESS, android.os.UserManager\#USER_OPERATION_ERROR_UNKNOWN, android.os.UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE, android.os.UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS, android.os.UserManager\#USER_OPERATION_ERROR_CURRENT_USER, android.os.UserManager\#USER_OPERATION_ERROR_LOW_STORAGE, or android.os.UserManager\#USER_OPERATION_ERROR_MAX_USERS
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#getSecondaryUsers(ComponentName)
  int stopUser(componentname_.ComponentName admin,
          userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(reference, _id_stopUser,
          jni.JniType.intType, [admin.reference, userHandle.reference]).integer;

  static final _id_logoutUser = jniAccessors.getMethodIDOf(
      _classRef, "logoutUser", "(Landroid/content/ComponentName;)I");

  /// from: public int logoutUser(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of secondary user that is affiliated with the device to stop the
  /// calling user and switch back to primary.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return one of the following result codes:
  /// UserManager\#USER_OPERATION_ERROR_UNKNOWN,
  /// UserManager\#USER_OPERATION_SUCCESS,
  /// UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE,
  /// UserManager\#USER_OPERATION_ERROR_CURRENT_USER
  /// Value is android.os.UserManager\#USER_OPERATION_SUCCESS, android.os.UserManager\#USER_OPERATION_ERROR_UNKNOWN, android.os.UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE, android.os.UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS, android.os.UserManager\#USER_OPERATION_ERROR_CURRENT_USER, android.os.UserManager\#USER_OPERATION_ERROR_LOW_STORAGE, or android.os.UserManager\#USER_OPERATION_ERROR_MAX_USERS
  ///@throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
  ///@see \#getSecondaryUsers(ComponentName)
  int logoutUser(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_logoutUser,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_getSecondaryUsers = jniAccessors.getMethodIDOf(_classRef,
      "getSecondaryUsers", "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<android.os.UserHandle> getSecondaryUsers(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device owner to list all secondary users on the device. Managed profiles are not
  /// considered as secondary users.
  ///  Used for various user management APIs, including \#switchUser, \#removeUser
  /// and \#stopUser.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return list of other UserHandles on the device.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#removeUser(ComponentName, UserHandle)
  ///@see \#switchUser(ComponentName, UserHandle)
  ///@see \#startUserInBackground(ComponentName, UserHandle)
  ///@see \#stopUser(ComponentName, UserHandle)
  jni.JniObject getSecondaryUsers(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSecondaryUsers,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_isEphemeralUser = jniAccessors.getMethodIDOf(
      _classRef, "isEphemeralUser", "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isEphemeralUser(android.content.ComponentName admin)
  ///
  /// Checks if the profile owner is running in an ephemeral user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return whether the profile owner is running in an ephemeral user.
  bool isEphemeralUser(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isEphemeralUser,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_getApplicationRestrictions = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationRestrictions",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getApplicationRestrictions(android.content.ComponentName admin, java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the application restrictions for a given target application running in the calling
  /// user.
  ///
  /// The caller must be a profile or device owner on that user, or the package allowed to manage
  /// application restrictions via \#setDelegatedScopes with the
  /// \#DELEGATION_APP_RESTRICTIONS scope; otherwise a security exception will be thrown.
  ///
  /// NOTE: The method performs disk I/O and shouldn't be called on the main thread
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if called by the application restrictions managing package.
  /// This value may be {@code null}.
  ///@param packageName The name of the package to fetch restricted settings of.
  ///@return Bundle of settings corresponding to what was set last time
  ///         DevicePolicyManager\#setApplicationRestrictions was called, or an empty
  ///         Bundle if no restrictions have been set.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_APP_RESTRICTIONS
  bundle_.Bundle getApplicationRestrictions(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationRestrictions,
          jni.JniType.objectType,
          [admin.reference, packageName.reference]).object);

  static final _id_addUserRestriction = jniAccessors.getMethodIDOf(
      _classRef,
      "addUserRestriction",
      "(Landroid/content/ComponentName;Ljava/lang/String;)V");

  /// from: public void addUserRestriction(android.content.ComponentName admin, java.lang.String key)
  ///
  /// Called by a profile or device owner to set a user restriction specified by the key.
  ///
  /// The calling device admin must be a profile or device owner; if it is not, a security
  /// exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param key The key of the restriction. See the constants in android.os.UserManager
  ///            for the list of keys.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void addUserRestriction(
          componentname_.ComponentName admin, jni.JniString key) =>
      jniAccessors.callMethodWithArgs(reference, _id_addUserRestriction,
          jni.JniType.voidType, [admin.reference, key.reference]).check();

  static final _id_clearUserRestriction = jniAccessors.getMethodIDOf(
      _classRef,
      "clearUserRestriction",
      "(Landroid/content/ComponentName;Ljava/lang/String;)V");

  /// from: public void clearUserRestriction(android.content.ComponentName admin, java.lang.String key)
  ///
  /// Called by a profile or device owner to clear a user restriction specified by the key.
  ///
  /// The calling device admin must be a profile or device owner; if it is not, a security
  /// exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param key The key of the restriction. See the constants in android.os.UserManager
  ///            for the list of keys.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void clearUserRestriction(
          componentname_.ComponentName admin, jni.JniString key) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearUserRestriction,
          jni.JniType.voidType, [admin.reference, key.reference]).check();

  static final _id_getUserRestrictions = jniAccessors.getMethodIDOf(
      _classRef,
      "getUserRestrictions",
      "(Landroid/content/ComponentName;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getUserRestrictions(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile or device owner to get user restrictions set with
  /// \#addUserRestriction(ComponentName, String).
  ///
  /// The target user may have more restrictions set by the system or other device owner / profile
  /// owner. To get all the user restrictions currently set, use
  /// UserManager\#getUserRestrictions().
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@return This value will never be {@code null}.
  bundle_.Bundle getUserRestrictions(componentname_.ComponentName admin) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getUserRestrictions,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_createAdminSupportIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "createAdminSupportIntent",
      "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent createAdminSupportIntent(java.lang.String restriction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by any app to display a support dialog when a feature was disabled by an admin.
  /// This returns an intent that can be used with Context\#startActivity(Intent) to
  /// display the dialog. It will tell the user that the feature indicated by {@code restriction}
  /// was disabled by an admin, and include a link for more information. The default content of
  /// the dialog can be changed by the restricting admin via
  /// \#setShortSupportMessage(ComponentName, CharSequence). If the restriction is not
  /// set (i.e. the feature is available), then the return value will be {@code null}.
  ///@param restriction Indicates for which feature the dialog should be displayed. Can be a
  ///            user restriction from UserManager, e.g.
  ///            UserManager\#DISALLOW_ADJUST_VOLUME, or one of the constants
  ///            \#POLICY_DISABLE_CAMERA, \#POLICY_DISABLE_SCREEN_CAPTURE.
  /// This value must never be {@code null}.
  ///@return Intent An intent to be used to start the dialog-activity if the restriction is
  ///            set by an admin, or null if the restriction does not exist or no admin set it.
  intent_.Intent createAdminSupportIntent(jni.JniString restriction) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createAdminSupportIntent,
          jni.JniType.objectType,
          [restriction.reference]).object);

  static final _id_setApplicationHidden = jniAccessors.getMethodIDOf(
      _classRef,
      "setApplicationHidden",
      "(Landroid/content/ComponentName;Ljava/lang/String;Z)Z");

  /// from: public boolean setApplicationHidden(android.content.ComponentName admin, java.lang.String packageName, boolean hidden)
  ///
  /// Hide or unhide packages. When a package is hidden it is unavailable for use, but the data and
  /// actual package file remain. This function can be called by a device owner, profile owner, or
  /// by a delegate given the \#DELEGATION_PACKAGE_ACCESS scope via
  /// \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a package access delegate.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package to hide or unhide.
  ///@param hidden {@code true} if the package should be hidden, {@code false} if it should be
  ///            unhidden.
  ///@return boolean Whether the hidden setting of the package was successfully updated.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  bool setApplicationHidden(componentname_.ComponentName admin,
          jni.JniString packageName, bool hidden) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setApplicationHidden,
          jni.JniType.booleanType,
          [admin.reference, packageName.reference, hidden]).boolean;

  static final _id_isApplicationHidden = jniAccessors.getMethodIDOf(
      _classRef,
      "isApplicationHidden",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean isApplicationHidden(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Determine if a package is hidden. This function can be called by a device owner, profile
  /// owner, or by a delegate given the \#DELEGATION_PACKAGE_ACCESS scope via
  /// \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a package access delegate.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package to retrieve the hidden status of.
  ///@return boolean {@code true} if the package is hidden, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  bool isApplicationHidden(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isApplicationHidden,
          jni.JniType.booleanType,
          [admin.reference, packageName.reference]).boolean;

  static final _id_enableSystemApp = jniAccessors.getMethodIDOf(
      _classRef,
      "enableSystemApp",
      "(Landroid/content/ComponentName;Ljava/lang/String;)V");

  /// from: public void enableSystemApp(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Re-enable a system app that was disabled by default when the user was initialized. This
  /// function can be called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_ENABLE_SYSTEM_APP scope via \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is an enable system app delegate.
  /// This value must never be {@code null}.
  ///@param packageName The package to be re-enabled in the calling profile.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  void enableSystemApp(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enableSystemApp,
          jni.JniType.voidType,
          [admin.reference, packageName.reference]).check();

  static final _id_enableSystemApp1 = jniAccessors.getMethodIDOf(
      _classRef,
      "enableSystemApp",
      "(Landroid/content/ComponentName;Landroid/content/Intent;)I");

  /// from: public int enableSystemApp(android.content.ComponentName admin, android.content.Intent intent)
  ///
  /// Re-enable system apps by intent that were disabled by default when the user was initialized.
  /// This function can be called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_ENABLE_SYSTEM_APP scope via \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is an enable system app delegate.
  /// This value must never be {@code null}.
  ///@param intent An intent matching the app(s) to be installed. All apps that resolve for this
  ///            intent will be re-enabled in the calling profile.
  ///@return int The number of activities that matched the intent and were installed.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  int enableSystemApp1(
          componentname_.ComponentName admin, intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_enableSystemApp1,
          jni.JniType.intType, [admin.reference, intent.reference]).integer;

  static final _id_installExistingPackage = jniAccessors.getMethodIDOf(
      _classRef,
      "installExistingPackage",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean installExistingPackage(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Install an existing package that has been installed in another user, or has been kept after
  /// removal via \#setKeepUninstalledPackages.
  /// This function can be called by a device owner, profile owner or a delegate given
  /// the \#DELEGATION_INSTALL_EXISTING_PACKAGE scope via \#setDelegatedScopes.
  /// When called in a secondary user or managed profile, the user/profile must be affiliated with
  /// the device. See \#isAffiliatedUser.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The package to be installed in the calling profile.
  ///@return {@code true} if the app is installed; {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not the device owner, or the profile owner of
  /// an affiliated user or profile.
  ///@see \#setKeepUninstalledPackages
  ///@see \#setDelegatedScopes
  ///@see \#isAffiliatedUser
  ///@see \#DELEGATION_PACKAGE_ACCESS
  bool installExistingPackage(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_installExistingPackage,
          jni.JniType.booleanType,
          [admin.reference, packageName.reference]).boolean;

  static final _id_setAccountManagementDisabled = jniAccessors.getMethodIDOf(
      _classRef,
      "setAccountManagementDisabled",
      "(Landroid/content/ComponentName;Ljava/lang/String;Z)V");

  /// from: public void setAccountManagementDisabled(android.content.ComponentName admin, java.lang.String accountType, boolean disabled)
  ///
  /// Called by a device owner or profile owner to disable account management for a specific type
  /// of account.
  ///
  /// The calling device admin must be a device owner or profile owner. If it is not, a security
  /// exception will be thrown.
  ///
  /// When account management is disabled for an account type, adding or removing an account of
  /// that type will not be possible.
  ///
  /// From android.os.Build.VERSION_CODES\#N the profile or device owner can still use
  /// android.accounts.AccountManager APIs to add or remove accounts when account
  /// management for a specific type is disabled.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param accountType For which account management is disabled or enabled.
  ///@param disabled The boolean indicating that account management will be disabled (true) or
  ///            enabled (false).
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setAccountManagementDisabled(componentname_.ComponentName admin,
          jni.JniString accountType, bool disabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAccountManagementDisabled,
          jni.JniType.voidType,
          [admin.reference, accountType.reference, disabled]).check();

  static final _id_getAccountTypesWithManagementDisabled =
      jniAccessors.getMethodIDOf(_classRef,
          "getAccountTypesWithManagementDisabled", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getAccountTypesWithManagementDisabled()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the array of accounts for which account management is disabled by the profile owner.
  ///
  ///  Account management can be disabled/enabled by calling
  /// \#setAccountManagementDisabled.
  ///@return a list of account types for which account management has been disabled.
  ///
  /// This value may be {@code null}.
  ///@see \#setAccountManagementDisabled
  jni.JniObject getAccountTypesWithManagementDisabled() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAccountTypesWithManagementDisabled,
          jni.JniType.objectType, []).object);

  static final _id_setLockTaskPackages = jniAccessors.getMethodIDOf(
      _classRef,
      "setLockTaskPackages",
      "(Landroid/content/ComponentName;[Ljava/lang/String;)V");

  /// from: public void setLockTaskPackages(android.content.ComponentName admin, java.lang.String[] packages)
  ///
  /// Sets which packages may enter lock task mode.
  ///
  /// Any packages that share uid with an allowed package will also be allowed to activate lock
  /// task. From android.os.Build.VERSION_CODES\#M removing packages from the lock task
  /// package list results in locked tasks belonging to those packages to be finished.
  ///
  /// This function can only be called by the device owner, a profile owner of an affiliated user
  /// or profile, or the profile owner when no device owner is set. See \#isAffiliatedUser.
  /// Any package set via this method will be cleared if the user becomes unaffiliated.
  ///@param packages The list of packages allowed to enter lock task mode
  /// This value must never be {@code null}.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
  /// affiliated user or profile, or the profile owner when no device owner is set.
  ///@see \#isAffiliatedUser
  ///@see Activity\#startLockTask()
  ///@see DeviceAdminReceiver\#onLockTaskModeEntering(Context, Intent, String)
  ///@see DeviceAdminReceiver\#onLockTaskModeExiting(Context, Intent)
  ///@see UserManager\#DISALLOW_CREATE_WINDOWS
  void setLockTaskPackages(
          componentname_.ComponentName admin, jni.JniObject packages) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLockTaskPackages,
          jni.JniType.voidType, [admin.reference, packages.reference]).check();

  static final _id_getLockTaskPackages = jniAccessors.getMethodIDOf(
      _classRef,
      "getLockTaskPackages",
      "(Landroid/content/ComponentName;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getLockTaskPackages(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of packages allowed to start the lock task mode.
  ///@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
  /// affiliated user or profile, or the profile owner when no device owner is set.
  ///@see \#isAffiliatedUser
  ///@see \#setLockTaskPackages
  ///@param admin This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject getLockTaskPackages(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLockTaskPackages,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_isLockTaskPermitted = jniAccessors.getMethodIDOf(
      _classRef, "isLockTaskPermitted", "(Ljava/lang/String;)Z");

  /// from: public boolean isLockTaskPermitted(java.lang.String pkg)
  ///
  /// This function lets the caller know whether the given component is allowed to start the
  /// lock task mode.
  ///@param pkg The package to check
  bool isLockTaskPermitted(jni.JniString pkg) =>
      jniAccessors.callMethodWithArgs(reference, _id_isLockTaskPermitted,
          jni.JniType.booleanType, [pkg.reference]).boolean;

  static final _id_setLockTaskFeatures = jniAccessors.getMethodIDOf(
      _classRef, "setLockTaskFeatures", "(Landroid/content/ComponentName;I)V");

  /// from: public void setLockTaskFeatures(android.content.ComponentName admin, int flags)
  ///
  /// Sets which system features are enabled when the device runs in lock task mode. This method
  /// doesn't affect the features when lock task mode is inactive. Any system features not included
  /// in {@code flags} are implicitly disabled when calling this method. By default, only
  /// \#LOCK_TASK_FEATURE_GLOBAL_ACTIONS is enabled\u2014all the other features are disabled. To
  /// disable the global actions dialog, call this method omitting
  /// \#LOCK_TASK_FEATURE_GLOBAL_ACTIONS.
  ///
  /// This method can only be called by the device owner, a profile owner of an affiliated
  /// user or profile, or the profile owner when no device owner is set. See
  /// \#isAffiliatedUser.
  /// Any features set using this method are cleared if the user becomes unaffiliated.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param flags The system features enabled during lock task mode.
  /// Value is either <code>0</code> or a combination of android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_NONE, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_SYSTEM_INFO, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_NOTIFICATIONS, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_HOME, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_OVERVIEW, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_GLOBAL_ACTIONS, and android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_KEYGUARD
  ///@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
  /// affiliated user or profile, or the profile owner when no device owner is set.
  ///@see \#isAffiliatedUser
  void setLockTaskFeatures(componentname_.ComponentName admin, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLockTaskFeatures,
          jni.JniType.voidType, [admin.reference, flags]).check();

  static final _id_getLockTaskFeatures = jniAccessors.getMethodIDOf(
      _classRef, "getLockTaskFeatures", "(Landroid/content/ComponentName;)I");

  /// from: public int getLockTaskFeatures(android.content.ComponentName admin)
  ///
  /// Gets which system features are enabled for LockTask mode.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return bitfield of flags. See \#setLockTaskFeatures(ComponentName, int) for a list.
  /// Value is either <code>0</code> or a combination of android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_NONE, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_SYSTEM_INFO, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_NOTIFICATIONS, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_HOME, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_OVERVIEW, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_GLOBAL_ACTIONS, and android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_KEYGUARD
  ///@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
  /// affiliated user or profile, or the profile owner when no device owner is set.
  ///@see \#isAffiliatedUser
  ///@see \#setLockTaskFeatures
  int getLockTaskFeatures(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getLockTaskFeatures,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_setGlobalSetting = jniAccessors.getMethodIDOf(
      _classRef,
      "setGlobalSetting",
      "(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void setGlobalSetting(android.content.ComponentName admin, java.lang.String setting, java.lang.String value)
  ///
  /// Called by device owner to update android.provider.Settings.Global settings.
  /// Validation that the value of the setting is in the correct form for the setting type should
  /// be performed by the caller.
  ///
  /// The settings that can be updated with this method are:
  /// <ul>
  /// <li>android.provider.Settings.Global\#ADB_ENABLED</li>
  /// <li>android.provider.Settings.Global\#AUTO_TIME</li>
  /// <li>android.provider.Settings.Global\#AUTO_TIME_ZONE</li>
  /// <li>android.provider.Settings.Global\#DATA_ROAMING</li>
  /// <li>android.provider.Settings.Global\#USB_MASS_STORAGE_ENABLED</li>
  /// <li>android.provider.Settings.Global\#WIFI_SLEEP_POLICY</li>
  /// <li>android.provider.Settings.Global\#STAY_ON_WHILE_PLUGGED_IN This setting is only
  /// available from android.os.Build.VERSION_CODES\#M onwards and can only be set if
  /// \#setMaximumTimeToLock is not used to set a timeout.</li>
  /// <li>android.provider.Settings.Global\#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</li> This
  /// setting is only available from android.os.Build.VERSION_CODES\#M onwards.</li>
  /// </ul>
  ///
  /// Changing the following settings has no effect as of android.os.Build.VERSION_CODES\#M:
  /// <ul>
  /// <li>android.provider.Settings.Global\#BLUETOOTH_ON. Use
  /// android.bluetooth.BluetoothAdapter\#enable() and
  /// android.bluetooth.BluetoothAdapter\#disable() instead.</li>
  /// <li>android.provider.Settings.Global\#DEVELOPMENT_SETTINGS_ENABLED</li>
  /// <li>android.provider.Settings.Global\#MODE_RINGER. Use
  /// android.media.AudioManager\#setRingerMode(int) instead.</li>
  /// <li>android.provider.Settings.Global\#NETWORK_PREFERENCE</li>
  /// <li>android.provider.Settings.Global\#WIFI_ON. Use
  /// android.net.wifi.WifiManager\#setWifiEnabled(boolean) instead.</li>
  /// </ul>
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param setting The name of the setting to update.
  ///@param value The value to update the setting to.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setGlobalSetting(componentname_.ComponentName admin,
          jni.JniString setting, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setGlobalSetting,
          jni.JniType.voidType,
          [admin.reference, setting.reference, value.reference]).check();

  static final _id_setSystemSetting = jniAccessors.getMethodIDOf(
      _classRef,
      "setSystemSetting",
      "(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void setSystemSetting(android.content.ComponentName admin, java.lang.String setting, java.lang.String value)
  ///
  /// Called by a device or profile owner to update android.provider.Settings.System
  /// settings. Validation that the value of the setting is in the correct form for the setting
  /// type should be performed by the caller.
  ///
  /// The settings that can be updated by a device owner or profile owner of secondary user with
  /// this method are:
  /// <ul>
  /// <li>android.provider.Settings.System\#SCREEN_BRIGHTNESS</li>
  /// <li>android.provider.Settings.System\#SCREEN_BRIGHTNESS_MODE</li>
  /// <li>android.provider.Settings.System\#SCREEN_OFF_TIMEOUT</li>
  /// </ul>
  ///
  ///@see android.provider.Settings.System\#SCREEN_OFF_TIMEOUT
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param setting The name of the setting to update.
  /// This value must never be {@code null}.
  /// Value is android.provider.Settings.System\#SCREEN_BRIGHTNESS_MODE, android.provider.Settings.System\#SCREEN_BRIGHTNESS, or android.provider.Settings.System\#SCREEN_OFF_TIMEOUT
  ///@param value The value to update the setting to.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setSystemSetting(componentname_.ComponentName admin,
          jni.JniString setting, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSystemSetting,
          jni.JniType.voidType,
          [admin.reference, setting.reference, value.reference]).check();

  static final _id_setTime = jniAccessors.getMethodIDOf(
      _classRef, "setTime", "(Landroid/content/ComponentName;J)Z");

  /// from: public boolean setTime(android.content.ComponentName admin, long millis)
  ///
  /// Called by device owner to set the system wall clock time. This only takes effect if called
  /// when android.provider.Settings.Global\#AUTO_TIME is 0, otherwise {@code false} will be
  /// returned.
  ///@param admin Which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param millis time in milliseconds since the Epoch
  ///@return {@code true} if set time succeeded, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  bool setTime(componentname_.ComponentName admin, int millis) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTime,
          jni.JniType.booleanType, [admin.reference, millis]).boolean;

  static final _id_setTimeZone = jniAccessors.getMethodIDOf(_classRef,
      "setTimeZone", "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean setTimeZone(android.content.ComponentName admin, java.lang.String timeZone)
  ///
  /// Called by device owner to set the system's persistent default time zone. This only takes
  /// effect if called when android.provider.Settings.Global\#AUTO_TIME_ZONE is 0, otherwise
  /// {@code false} will be returned.
  ///@see android.app.AlarmManager\#setTimeZone(String)
  ///@param admin Which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param timeZone one of the Olson ids from the list returned by
  ///     java.util.TimeZone\#getAvailableIDs
  ///@return {@code true} if set timezone succeeded, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  bool setTimeZone(
          componentname_.ComponentName admin, jni.JniString timeZone) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTimeZone,
          jni.JniType.booleanType,
          [admin.reference, timeZone.reference]).boolean;

  static final _id_setSecureSetting = jniAccessors.getMethodIDOf(
      _classRef,
      "setSecureSetting",
      "(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void setSecureSetting(android.content.ComponentName admin, java.lang.String setting, java.lang.String value)
  ///
  /// Called by profile or device owners to update android.provider.Settings.Secure
  /// settings. Validation that the value of the setting is in the correct form for the setting
  /// type should be performed by the caller.
  ///
  /// The settings that can be updated by a profile or device owner with this method are:
  /// <ul>
  /// <li>android.provider.Settings.Secure\#DEFAULT_INPUT_METHOD</li>
  /// <li>android.provider.Settings.Secure\#SKIP_FIRST_USE_HINTS</li>
  /// </ul>
  ///
  /// A device owner can additionally update the following settings:
  /// <ul>
  /// <li>android.provider.Settings.Secure\#LOCATION_MODE</li>
  /// </ul>
  ///
  /// <strong>Note: Starting from Android O, apps should no longer call this method with the
  /// setting android.provider.Settings.Secure\#INSTALL_NON_MARKET_APPS, which is
  /// deprecated. Instead, device owners or profile owners should use the restriction
  /// UserManager\#DISALLOW_INSTALL_UNKNOWN_SOURCES.
  /// If any app targeting android.os.Build.VERSION_CODES\#O or higher calls this method
  /// with android.provider.Settings.Secure\#INSTALL_NON_MARKET_APPS,
  /// an UnsupportedOperationException is thrown.
  /// </strong>
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param setting The name of the setting to update.
  ///@param value The value to update the setting to.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setSecureSetting(componentname_.ComponentName admin,
          jni.JniString setting, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSecureSetting,
          jni.JniType.voidType,
          [admin.reference, setting.reference, value.reference]).check();

  static final _id_setRestrictionsProvider = jniAccessors.getMethodIDOf(
      _classRef,
      "setRestrictionsProvider",
      "(Landroid/content/ComponentName;Landroid/content/ComponentName;)V");

  /// from: public void setRestrictionsProvider(android.content.ComponentName admin, android.content.ComponentName provider)
  ///
  /// Designates a specific service component as the provider for making permission requests of a
  /// local or remote administrator of the user.
  /// <p/>
  /// Only a profile owner can designate the restrictions provider.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param provider The component name of the service that implements
  ///            RestrictionsReceiver. If this param is null, it removes the restrictions
  ///            provider previously assigned.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setRestrictionsProvider(componentname_.ComponentName admin,
          componentname_.ComponentName provider) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRestrictionsProvider,
          jni.JniType.voidType, [admin.reference, provider.reference]).check();

  static final _id_setMasterVolumeMuted = jniAccessors.getMethodIDOf(
      _classRef, "setMasterVolumeMuted", "(Landroid/content/ComponentName;Z)V");

  /// from: public void setMasterVolumeMuted(android.content.ComponentName admin, boolean on)
  ///
  /// Called by profile or device owners to set the master volume mute on or off.
  /// This has no effect when set on a managed profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param on {@code true} to mute master volume, {@code false} to turn mute off.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setMasterVolumeMuted(componentname_.ComponentName admin, bool on0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMasterVolumeMuted,
          jni.JniType.voidType, [admin.reference, on0]).check();

  static final _id_isMasterVolumeMuted = jniAccessors.getMethodIDOf(
      _classRef, "isMasterVolumeMuted", "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isMasterVolumeMuted(android.content.ComponentName admin)
  ///
  /// Called by profile or device owners to check whether the master volume mute is on or off.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return {@code true} if master volume is muted, {@code false} if it's not.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  bool isMasterVolumeMuted(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isMasterVolumeMuted,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_setUninstallBlocked = jniAccessors.getMethodIDOf(
      _classRef,
      "setUninstallBlocked",
      "(Landroid/content/ComponentName;Ljava/lang/String;Z)V");

  /// from: public void setUninstallBlocked(android.content.ComponentName admin, java.lang.String packageName, boolean uninstallBlocked)
  ///
  /// Change whether a user can uninstall a package. This function can be called by a device owner,
  /// profile owner, or by a delegate given the \#DELEGATION_BLOCK_UNINSTALL scope via
  /// \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///             {@code null} if the caller is a block uninstall delegate.
  /// This value may be {@code null}.
  ///@param packageName package to change.
  ///@param uninstallBlocked true if the user shouldn't be able to uninstall the package.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_BLOCK_UNINSTALL
  void setUninstallBlocked(componentname_.ComponentName admin,
          jni.JniString packageName, bool uninstallBlocked) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setUninstallBlocked,
          jni.JniType.voidType,
          [admin.reference, packageName.reference, uninstallBlocked]).check();

  static final _id_isUninstallBlocked = jniAccessors.getMethodIDOf(
      _classRef,
      "isUninstallBlocked",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean isUninstallBlocked(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Check whether the user has been blocked by device policy from uninstalling a package.
  /// Requires the caller to be the profile owner if checking a specific admin's policy.
  ///
  /// <strong>Note:</strong> Starting from android.os.Build.VERSION_CODES\#LOLLIPOP_MR1, the
  /// behavior of this API is changed such that passing {@code null} as the {@code admin} parameter
  /// will return if any admin has blocked the uninstallation. Before L MR1, passing {@code null}
  /// will cause a NullPointerException to be raised.
  ///@param admin The name of the admin component whose blocking policy will be checked, or
  ///            {@code null} to check whether any admin has blocked the uninstallation.
  /// This value may be {@code null}.
  ///@param packageName package to check.
  ///@return true if uninstallation is blocked.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  bool isUninstallBlocked(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isUninstallBlocked,
          jni.JniType.booleanType,
          [admin.reference, packageName.reference]).boolean;

  static final _id_addCrossProfileWidgetProvider = jniAccessors.getMethodIDOf(
      _classRef,
      "addCrossProfileWidgetProvider",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean addCrossProfileWidgetProvider(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Called by the profile owner of a managed profile to enable widget providers from a given
  /// package to be available in the parent profile. As a result the user will be able to add
  /// widgets from the white-listed package running under the profile to a widget host which runs
  /// under the parent profile, for example the home screen. Note that a package may have zero or
  /// more provider components, where each component provides a different widget type.
  ///
  /// <strong>Note:</strong> By default no widget provider package is white-listed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The package from which widget providers are white-listed.
  ///@return Whether the package was added.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  ///@see \#removeCrossProfileWidgetProvider(android.content.ComponentName, String)
  ///@see \#getCrossProfileWidgetProviders(android.content.ComponentName)
  bool addCrossProfileWidgetProvider(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addCrossProfileWidgetProvider,
          jni.JniType.booleanType,
          [admin.reference, packageName.reference]).boolean;

  static final _id_removeCrossProfileWidgetProvider =
      jniAccessors.getMethodIDOf(_classRef, "removeCrossProfileWidgetProvider",
          "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean removeCrossProfileWidgetProvider(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Called by the profile owner of a managed profile to disable widget providers from a given
  /// package to be available in the parent profile. For this method to take effect the package
  /// should have been added via
  /// \#addCrossProfileWidgetProvider( android.content.ComponentName, String).
  ///
  /// <strong>Note:</strong> By default no widget provider package is white-listed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The package from which widget providers are no longer white-listed.
  ///@return Whether the package was removed.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  ///@see \#addCrossProfileWidgetProvider(android.content.ComponentName, String)
  ///@see \#getCrossProfileWidgetProviders(android.content.ComponentName)
  bool removeCrossProfileWidgetProvider(
          componentname_.ComponentName admin, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeCrossProfileWidgetProvider,
          jni.JniType.booleanType,
          [admin.reference, packageName.reference]).boolean;

  static final _id_getCrossProfileWidgetProviders = jniAccessors.getMethodIDOf(
      _classRef,
      "getCrossProfileWidgetProviders",
      "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getCrossProfileWidgetProviders(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the profile owner of a managed profile to query providers from which packages are
  /// available in the parent profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The white-listed package list.
  /// This value will never be {@code null}.
  ///@see \#addCrossProfileWidgetProvider(android.content.ComponentName, String)
  ///@see \#removeCrossProfileWidgetProvider(android.content.ComponentName, String)
  ///@throws SecurityException if {@code admin} is not a profile owner.
  jni.JniObject getCrossProfileWidgetProviders(
          componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCrossProfileWidgetProviders,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setUserIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "setUserIcon",
      "(Landroid/content/ComponentName;Landroid/graphics/Bitmap;)V");

  /// from: public void setUserIcon(android.content.ComponentName admin, android.graphics.Bitmap icon)
  ///
  /// Called by profile or device owners to set the user's photo.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param icon the bitmap to set as the photo.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setUserIcon(componentname_.ComponentName admin, bitmap_.Bitmap icon) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUserIcon,
          jni.JniType.voidType, [admin.reference, icon.reference]).check();

  static final _id_setSystemUpdatePolicy = jniAccessors.getMethodIDOf(
      _classRef,
      "setSystemUpdatePolicy",
      "(Landroid/content/ComponentName;Landroid/app/admin/SystemUpdatePolicy;)V");

  /// from: public void setSystemUpdatePolicy(android.content.ComponentName admin, android.app.admin.SystemUpdatePolicy policy)
  ///
  /// Called by device owners to set a local system update policy. When a new policy is set,
  /// \#ACTION_SYSTEM_UPDATE_POLICY_CHANGED is broadcasted.
  ///
  /// If the supplied system update policy has freeze periods set but the freeze periods do not
  /// meet 90-day maximum length or 60-day minimum separation requirement set out in
  /// SystemUpdatePolicy\#setFreezePeriods,
  /// SystemUpdatePolicy.ValidationFailedException will the thrown. Note that the system
  /// keeps a record of freeze periods the device experienced previously, and combines them with
  /// the new freeze periods to be set when checking the maximum freeze length and minimum freeze
  /// separation constraints. As a result, freeze periods that passed validation during
  /// SystemUpdatePolicy\#setFreezePeriods might fail the additional checks here due to
  /// the freeze period history. If this is causing issues during development,
  /// {@code adb shell dpm clear-freeze-period-record} can be used to clear the record.
  ///@param admin Which DeviceAdminReceiver this request is associated with. All
  ///            components in the device owner package can set system update policies and the most
  ///            recent policy takes effect.
  /// This value must never be {@code null}.
  ///@param policy the new policy, or {@code null} to clear the current policy.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@throws IllegalArgumentException if the policy type or maintenance window is not valid.
  ///@throws SystemUpdatePolicy.ValidationFailedException if the policy's freeze period does not
  ///             meet the requirement.
  ///@see SystemUpdatePolicy
  ///@see SystemUpdatePolicy\#setFreezePeriods(List)
  void setSystemUpdatePolicy(componentname_.ComponentName admin,
          systemupdatepolicy_.SystemUpdatePolicy policy) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSystemUpdatePolicy,
          jni.JniType.voidType, [admin.reference, policy.reference]).check();

  static final _id_getSystemUpdatePolicy = jniAccessors.getMethodIDOf(_classRef,
      "getSystemUpdatePolicy", "()Landroid/app/admin/SystemUpdatePolicy;");

  /// from: public android.app.admin.SystemUpdatePolicy getSystemUpdatePolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a local system update policy set previously by \#setSystemUpdatePolicy.
  ///@return The current policy object, or {@code null} if no policy is set.
  systemupdatepolicy_.SystemUpdatePolicy getSystemUpdatePolicy() =>
      systemupdatepolicy_.SystemUpdatePolicy.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getSystemUpdatePolicy,
              jni.JniType.objectType, []).object);

  static final _id_setKeyguardDisabled = jniAccessors.getMethodIDOf(
      _classRef, "setKeyguardDisabled", "(Landroid/content/ComponentName;Z)Z");

  /// from: public boolean setKeyguardDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a device owner or profile owner of secondary users that is affiliated with the
  /// device to disable the keyguard altogether.
  ///
  /// Setting the keyguard to disabled has the same effect as choosing "None" as the screen lock
  /// type. However, this call has no effect if a password, pin or pattern is currently set. If a
  /// password, pin or pattern is set after the keyguard was disabled, the keyguard stops being
  /// disabled.
  ///
  ///
  /// As of android.os.Build.VERSION_CODES\#P, this call also dismisses the
  /// keyguard if it is currently shown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled {@code true} disables the keyguard, {@code false} reenables it.
  ///@return {@code false} if attempting to disable the keyguard while a lock password was in
  ///         place. {@code true} otherwise.
  ///@throws SecurityException if {@code admin} is not the device owner, or a profile owner of
  /// secondary user that is affiliated with the device.
  ///@see \#isAffiliatedUser
  ///@see \#getSecondaryUsers
  bool setKeyguardDisabled(componentname_.ComponentName admin, bool disabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setKeyguardDisabled,
          jni.JniType.booleanType, [admin.reference, disabled]).boolean;

  static final _id_setStatusBarDisabled = jniAccessors.getMethodIDOf(
      _classRef, "setStatusBarDisabled", "(Landroid/content/ComponentName;Z)Z");

  /// from: public boolean setStatusBarDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by device owner or profile owner of secondary users  that is affiliated with the
  /// device to disable the status bar. Disabling the status bar blocks notifications, quick
  /// settings and other screen overlays that allow escaping from a single use device.
  ///
  /// <strong>Note:</strong> This method has no effect for LockTask mode. The behavior of the
  /// status bar in LockTask mode can be configured with
  /// \#setLockTaskFeatures(ComponentName, int). Calls to this method when the device is in
  /// LockTask mode will be registered, but will only take effect when the device leaves LockTask
  /// mode.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled {@code true} disables the status bar, {@code false} reenables it.
  ///@return {@code false} if attempting to disable the status bar failed. {@code true} otherwise.
  ///@throws SecurityException if {@code admin} is not the device owner, or a profile owner of
  /// secondary user that is affiliated with the device.
  ///@see \#isAffiliatedUser
  ///@see \#getSecondaryUsers
  bool setStatusBarDisabled(
          componentname_.ComponentName admin, bool disabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStatusBarDisabled,
          jni.JniType.booleanType, [admin.reference, disabled]).boolean;

  static final _id_getPendingSystemUpdate = jniAccessors.getMethodIDOf(
      _classRef,
      "getPendingSystemUpdate",
      "(Landroid/content/ComponentName;)Landroid/app/admin/SystemUpdateInfo;");

  /// from: public android.app.admin.SystemUpdateInfo getPendingSystemUpdate(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device or profile owners to get information about a pending system update.
  ///@param admin Which profile or device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return Information about a pending system update or {@code null} if no update pending.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see DeviceAdminReceiver\#onSystemUpdatePending(Context, Intent, long)
  systemupdateinfo_.SystemUpdateInfo getPendingSystemUpdate(
          componentname_.ComponentName admin) =>
      systemupdateinfo_.SystemUpdateInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getPendingSystemUpdate,
              jni.JniType.objectType, [admin.reference]).object);

  static final _id_setPermissionPolicy = jniAccessors.getMethodIDOf(
      _classRef, "setPermissionPolicy", "(Landroid/content/ComponentName;I)V");

  /// from: public void setPermissionPolicy(android.content.ComponentName admin, int policy)
  ///
  /// Set the default response for future runtime permission requests by applications. This
  /// function can be called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_PERMISSION_GRANT scope via \#setDelegatedScopes.
  /// The policy can allow for normal operation which prompts the user to grant a permission, or
  /// can allow automatic granting or denying of runtime permission requests by an application.
  /// This also applies to new permissions declared by app updates. When a permission is denied or
  /// granted this way, the effect is equivalent to setting the permission * grant state via
  /// \#setPermissionGrantState.
  /// <p/>
  /// As this policy only acts on runtime permission requests, it only applies to applications
  /// built with a {@code targetSdkVersion} of android.os.Build.VERSION_CODES\#M or later.
  ///@param admin Which profile or device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@param policy One of the policy constants \#PERMISSION_POLICY_PROMPT,
  ///            \#PERMISSION_POLICY_AUTO_GRANT and \#PERMISSION_POLICY_AUTO_DENY.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setPermissionGrantState
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PERMISSION_GRANT
  void setPermissionPolicy(componentname_.ComponentName admin, int policy) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPermissionPolicy,
          jni.JniType.voidType, [admin.reference, policy]).check();

  static final _id_getPermissionPolicy = jniAccessors.getMethodIDOf(
      _classRef, "getPermissionPolicy", "(Landroid/content/ComponentName;)I");

  /// from: public int getPermissionPolicy(android.content.ComponentName admin)
  ///
  /// Returns the current runtime permission policy set by the device or profile owner. The
  /// default is \#PERMISSION_POLICY_PROMPT.
  ///@param admin Which profile or device owner this request is associated with.
  ///@return the current policy for future permission requests.
  int getPermissionPolicy(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPermissionPolicy,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_setPermissionGrantState = jniAccessors.getMethodIDOf(
      _classRef,
      "setPermissionGrantState",
      "(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;I)Z");

  /// from: public boolean setPermissionGrantState(android.content.ComponentName admin, java.lang.String packageName, java.lang.String permission, int grantState)
  ///
  /// Sets the grant state of a runtime permission for a specific application. The state can be
  /// \#PERMISSION_GRANT_STATE_DEFAULT default in which a user can manage it through the UI,
  /// \#PERMISSION_GRANT_STATE_DENIED denied, in which the permission is denied and the user
  /// cannot manage it through the UI, and \#PERMISSION_GRANT_STATE_GRANTED granted in which
  /// the permission is granted and the user cannot manage it through the UI. This method can only
  /// be called by a profile owner, device owner, or a delegate given the
  /// \#DELEGATION_PERMISSION_GRANT scope via \#setDelegatedScopes.
  /// <p/>
  /// Note that user cannot manage other permissions in the affected group through the UI
  /// either and their granted state will be kept as the current value. Thus, it's recommended that
  /// you set the grant state of all the permissions in the affected group.
  /// <p/>
  /// Setting the grant state to \#PERMISSION_GRANT_STATE_DEFAULT default does not revoke
  /// the permission. It retains the previous grant, if any.
  /// <p/>
  /// Permissions can be granted or revoked only for applications built with a
  /// {@code targetSdkVersion} of android.os.Build.VERSION_CODES\#M or later.
  ///@param admin Which profile or device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The application to grant or revoke a permission to.
  ///@param permission The permission to grant or revoke.
  ///@param grantState The permission grant state which is one of
  ///            \#PERMISSION_GRANT_STATE_DENIED, \#PERMISSION_GRANT_STATE_DEFAULT,
  ///            \#PERMISSION_GRANT_STATE_GRANTED,
  ///@return whether the permission was successfully granted or revoked.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#PERMISSION_GRANT_STATE_DENIED
  ///@see \#PERMISSION_GRANT_STATE_DEFAULT
  ///@see \#PERMISSION_GRANT_STATE_GRANTED
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PERMISSION_GRANT
  bool setPermissionGrantState(
          componentname_.ComponentName admin,
          jni.JniString packageName,
          jni.JniString permission,
          int grantState) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setPermissionGrantState, jni.JniType.booleanType, [
        admin.reference,
        packageName.reference,
        permission.reference,
        grantState
      ]).boolean;

  static final _id_getPermissionGrantState = jniAccessors.getMethodIDOf(
      _classRef,
      "getPermissionGrantState",
      "(Landroid/content/ComponentName;Ljava/lang/String;Ljava/lang/String;)I");

  /// from: public int getPermissionGrantState(android.content.ComponentName admin, java.lang.String packageName, java.lang.String permission)
  ///
  /// Returns the current grant state of a runtime permission for a specific application. This
  /// function can be called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_PERMISSION_GRANT scope via \#setDelegatedScopes.
  ///@param admin Which profile or device owner this request is associated with, or {@code null}
  ///            if the caller is a permission grant delegate.
  /// This value may be {@code null}.
  ///@param packageName The application to check the grant state for.
  ///@param permission The permission to check for.
  ///@return the current grant state specified by device policy. If the profile or device owner
  ///         has not set a grant state, the return value is
  ///         \#PERMISSION_GRANT_STATE_DEFAULT. This does not indicate whether or not the
  ///         permission is currently granted for the package.
  ///         <p/>
  ///         If a grant state was set by the profile or device owner, then the return value will
  ///         be one of \#PERMISSION_GRANT_STATE_DENIED or
  ///         \#PERMISSION_GRANT_STATE_GRANTED, which indicates if the permission is
  ///         currently denied or granted.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setPermissionGrantState(ComponentName, String, String, int)
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PERMISSION_GRANT
  int getPermissionGrantState(componentname_.ComponentName admin,
          jni.JniString packageName, jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_getPermissionGrantState, jni.JniType.intType, [
        admin.reference,
        packageName.reference,
        permission.reference
      ]).integer;

  static final _id_isProvisioningAllowed = jniAccessors.getMethodIDOf(
      _classRef, "isProvisioningAllowed", "(Ljava/lang/String;)Z");

  /// from: public boolean isProvisioningAllowed(java.lang.String action)
  ///
  /// Returns whether it is possible for the caller to initiate provisioning of a managed profile
  /// or device, setting itself as the device or profile owner.
  ///@param action One of \#ACTION_PROVISION_MANAGED_DEVICE,
  /// \#ACTION_PROVISION_MANAGED_PROFILE.
  /// This value must never be {@code null}.
  ///@return whether provisioning a managed profile or device is possible.
  ///@throws IllegalArgumentException if the supplied action is not valid.
  bool isProvisioningAllowed(jni.JniString action) =>
      jniAccessors.callMethodWithArgs(reference, _id_isProvisioningAllowed,
          jni.JniType.booleanType, [action.reference]).boolean;

  static final _id_isManagedProfile = jniAccessors.getMethodIDOf(
      _classRef, "isManagedProfile", "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isManagedProfile(android.content.ComponentName admin)
  ///
  /// Return if this user is a managed profile of another user. An admin can become the profile
  /// owner of a managed profile with \#ACTION_PROVISION_MANAGED_PROFILE and of a managed
  /// user with \#createAndManageUser
  ///@param admin Which profile owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return if this user is a managed profile of another user.
  bool isManagedProfile(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isManagedProfile,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_getWifiMacAddress = jniAccessors.getMethodIDOf(
      _classRef,
      "getWifiMacAddress",
      "(Landroid/content/ComponentName;)Ljava/lang/String;");

  /// from: public java.lang.String getWifiMacAddress(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owner to get the MAC address of the Wi-Fi device.
  ///@param admin Which device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return the MAC address of the Wi-Fi device, or null when the information is not available.
  ///         (For example, Wi-Fi hasn't been enabled, or the device doesn't support Wi-Fi.)
  ///
  ///         The address will be in the {@code XX:XX:XX:XX:XX:XX} format.
  ///@throws SecurityException if {@code admin} is not a device owner.
  jni.JniString getWifiMacAddress(componentname_.ComponentName admin) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getWifiMacAddress,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_reboot = jniAccessors.getMethodIDOf(
      _classRef, "reboot", "(Landroid/content/ComponentName;)V");

  /// from: public void reboot(android.content.ComponentName admin)
  ///
  /// Called by device owner to reboot the device. If there is an ongoing call on the device,
  /// throws an IllegalStateException.
  ///@param admin Which device owner the request is associated with.
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if device has an ongoing call.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see TelephonyManager\#CALL_STATE_IDLE
  void reboot(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_reboot,
          jni.JniType.voidType, [admin.reference]).check();

  static final _id_setShortSupportMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "setShortSupportMessage",
      "(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V");

  /// from: public void setShortSupportMessage(android.content.ComponentName admin, java.lang.CharSequence message)
  ///
  /// Called by a device admin to set the short support message. This will be displayed to the user
  /// in settings screens where funtionality has been disabled by the admin. The message should be
  /// limited to a short statement such as "This setting is disabled by your administrator. Contact
  /// someone@example.com for support." If the message is longer than 200 characters it may be
  /// truncated.
  ///
  /// If the short support message needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this string accordingly.
  ///@see \#setLongSupportMessage
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param message Short message to be displayed to the user in settings or null to clear the
  ///            existing message.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  void setShortSupportMessage(
          componentname_.ComponentName admin, jni.JniObject message) =>
      jniAccessors.callMethodWithArgs(reference, _id_setShortSupportMessage,
          jni.JniType.voidType, [admin.reference, message.reference]).check();

  static final _id_getShortSupportMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "getShortSupportMessage",
      "(Landroid/content/ComponentName;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getShortSupportMessage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device admin to get the short support message.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The message set by \#setShortSupportMessage(ComponentName, CharSequence) or
  ///         null if no message has been set.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  jni.JniObject getShortSupportMessage(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getShortSupportMessage,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setLongSupportMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "setLongSupportMessage",
      "(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V");

  /// from: public void setLongSupportMessage(android.content.ComponentName admin, java.lang.CharSequence message)
  ///
  /// Called by a device admin to set the long support message. This will be displayed to the user
  /// in the device administators settings screen.
  ///
  /// If the long support message needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this string accordingly.
  ///@see \#setShortSupportMessage
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param message Long message to be displayed to the user in settings or null to clear the
  ///            existing message.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  void setLongSupportMessage(
          componentname_.ComponentName admin, jni.JniObject message) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLongSupportMessage,
          jni.JniType.voidType, [admin.reference, message.reference]).check();

  static final _id_getLongSupportMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "getLongSupportMessage",
      "(Landroid/content/ComponentName;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getLongSupportMessage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device admin to get the long support message.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The message set by \#setLongSupportMessage(ComponentName, CharSequence) or
  ///         null if no message has been set.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  jni.JniObject getLongSupportMessage(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLongSupportMessage,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_getParentProfileInstance = jniAccessors.getMethodIDOf(
      _classRef,
      "getParentProfileInstance",
      "(Landroid/content/ComponentName;)Landroid/app/admin/DevicePolicyManager;");

  /// from: public android.app.admin.DevicePolicyManager getParentProfileInstance(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the profile owner of a managed profile to obtain a DevicePolicyManager
  /// whose calls act on the parent profile.
  ///
  /// The following methods are supported for the parent instance, all other methods will
  /// throw a SecurityException when called on the parent instance:
  /// <ul>
  /// <li>\#getPasswordQuality</li>
  /// <li>\#setPasswordQuality</li>
  /// <li>\#getPasswordMinimumLength</li>
  /// <li>\#setPasswordMinimumLength</li>
  /// <li>\#getPasswordMinimumUpperCase</li>
  /// <li>\#setPasswordMinimumUpperCase</li>
  /// <li>\#getPasswordMinimumLowerCase</li>
  /// <li>\#setPasswordMinimumLowerCase</li>
  /// <li>\#getPasswordMinimumLetters</li>
  /// <li>\#setPasswordMinimumLetters</li>
  /// <li>\#getPasswordMinimumNumeric</li>
  /// <li>\#setPasswordMinimumNumeric</li>
  /// <li>\#getPasswordMinimumSymbols</li>
  /// <li>\#setPasswordMinimumSymbols</li>
  /// <li>\#getPasswordMinimumNonLetter</li>
  /// <li>\#setPasswordMinimumNonLetter</li>
  /// <li>\#getPasswordHistoryLength</li>
  /// <li>\#setPasswordHistoryLength</li>
  /// <li>\#getPasswordExpirationTimeout</li>
  /// <li>\#setPasswordExpirationTimeout</li>
  /// <li>\#getPasswordExpiration</li>
  /// <li>\#getPasswordMaximumLength</li>
  /// <li>\#isActivePasswordSufficient</li>
  /// <li>\#getCurrentFailedPasswordAttempts</li>
  /// <li>\#getMaximumFailedPasswordsForWipe</li>
  /// <li>\#setMaximumFailedPasswordsForWipe</li>
  /// <li>\#getMaximumTimeToLock</li>
  /// <li>\#setMaximumTimeToLock</li>
  /// <li>\#lockNow</li>
  /// <li>\#getKeyguardDisabledFeatures</li>
  /// <li>\#setKeyguardDisabledFeatures</li>
  /// <li>\#getTrustAgentConfiguration</li>
  /// <li>\#setTrustAgentConfiguration</li>
  /// <li>\#getRequiredStrongAuthTimeout</li>
  /// <li>\#setRequiredStrongAuthTimeout</li>
  /// </ul>
  ///@param admin This value must never be {@code null}.
  ///@return a new instance of DevicePolicyManager that acts on the parent profile.
  /// This value will never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  DevicePolicyManager getParentProfileInstance(
          componentname_.ComponentName admin) =>
      DevicePolicyManager.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getParentProfileInstance,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setSecurityLoggingEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "setSecurityLoggingEnabled",
      "(Landroid/content/ComponentName;Z)V");

  /// from: public void setSecurityLoggingEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Called by device owner to control the security logging feature.
  ///
  ///  Security logs contain various information intended for security auditing purposes.
  /// See SecurityEvent for details.
  ///
  /// <strong>Note:</strong> The device owner won't be able to retrieve security logs if there
  /// are unaffiliated secondary users or profiles on the device, regardless of whether the
  /// feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
  /// all users to become affiliated. Therefore it's recommended that affiliation ids are set for
  /// new users as soon as possible after provisioning via \#setAffiliationIds.
  ///@param admin Which device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@param enabled whether security logging should be enabled or not.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setAffiliationIds
  ///@see \#retrieveSecurityLogs
  void setSecurityLoggingEnabled(
          componentname_.ComponentName admin, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSecurityLoggingEnabled,
          jni.JniType.voidType, [admin.reference, enabled]).check();

  static final _id_isSecurityLoggingEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "isSecurityLoggingEnabled",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isSecurityLoggingEnabled(android.content.ComponentName admin)
  ///
  /// Return whether security logging is enabled or not by the device owner.
  ///
  /// Can only be called by the device owner, otherwise a SecurityException will be
  /// thrown.
  ///@param admin Which device owner this request is associated with.
  /// This value may be {@code null}.
  ///@return {@code true} if security logging is enabled by device owner, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  bool isSecurityLoggingEnabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isSecurityLoggingEnabled,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_retrieveSecurityLogs = jniAccessors.getMethodIDOf(
      _classRef,
      "retrieveSecurityLogs",
      "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<android.app.admin.SecurityLog.SecurityEvent> retrieveSecurityLogs(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owner to retrieve all new security logging entries since the last call to
  /// this API after device boots.
  ///
  ///  Access to the logs is rate limited and it will only return new logs after the device
  /// owner has been notified via DeviceAdminReceiver\#onSecurityLogsAvailable.
  ///
  /// If there is any other user or profile on the device, it must be affiliated with the
  /// device. Otherwise a SecurityException will be thrown. See \#isAffiliatedUser.
  ///@param admin Which device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return the new batch of security logs which is a list of SecurityEvent,
  /// or {@code null} if rate limitation is exceeded or if logging is currently disabled.
  ///@throws SecurityException if {@code admin} is not a device owner, or there is at least one
  /// profile or secondary user that is not affiliated with the device.
  ///@see \#isAffiliatedUser
  ///@see DeviceAdminReceiver\#onSecurityLogsAvailable
  jni.JniObject retrieveSecurityLogs(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_retrieveSecurityLogs,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setMeteredDataDisabledPackages = jniAccessors.getMethodIDOf(
      _classRef,
      "setMeteredDataDisabledPackages",
      "(Landroid/content/ComponentName;Ljava/util/List;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> setMeteredDataDisabledPackages(android.content.ComponentName admin, java.util.List<java.lang.String> packageNames)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device or profile owner to restrict packages from using metered data.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageNames the list of package names to be restricted.
  /// This value must never be {@code null}.
  ///@return a list of package names which could not be restricted.
  /// This value will never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  jni.JniObject setMeteredDataDisabledPackages(
          componentname_.ComponentName admin, jni.JniObject packageNames) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setMeteredDataDisabledPackages,
          jni.JniType.objectType,
          [admin.reference, packageNames.reference]).object);

  static final _id_getMeteredDataDisabledPackages = jniAccessors.getMethodIDOf(
      _classRef,
      "getMeteredDataDisabledPackages",
      "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getMeteredDataDisabledPackages(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device or profile owner to retrieve the list of packages which are restricted
  /// by the admin from using metered data.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return the list of restricted package names.
  /// This value will never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  jni.JniObject getMeteredDataDisabledPackages(
          componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getMeteredDataDisabledPackages,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_retrievePreRebootSecurityLogs = jniAccessors.getMethodIDOf(
      _classRef,
      "retrievePreRebootSecurityLogs",
      "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<android.app.admin.SecurityLog.SecurityEvent> retrievePreRebootSecurityLogs(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owners to retrieve device logs from before the device's last reboot.
  ///
  /// <strong> This API is not supported on all devices. Calling this API on unsupported devices
  /// will result in {@code null} being returned. The device logs are retrieved from a RAM region
  /// which is not guaranteed to be corruption-free during power cycles, as a result be cautious
  /// about data corruption when parsing. </strong>
  ///
  /// If there is any other user or profile on the device, it must be affiliated with the
  /// device. Otherwise a SecurityException will be thrown. See \#isAffiliatedUser.
  ///@param admin Which device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return Device logs from before the latest reboot of the system, or {@code null} if this API
  ///         is not supported on the device.
  ///@throws SecurityException if {@code admin} is not a device owner, or there is at least one
  /// profile or secondary user that is not affiliated with the device.
  ///@see \#isAffiliatedUser
  ///@see \#retrieveSecurityLogs
  jni.JniObject retrievePreRebootSecurityLogs(
          componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_retrievePreRebootSecurityLogs,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setOrganizationColor = jniAccessors.getMethodIDOf(
      _classRef, "setOrganizationColor", "(Landroid/content/ComponentName;I)V");

  /// from: public void setOrganizationColor(android.content.ComponentName admin, int color)
  ///
  /// Called by a profile owner of a managed profile to set the color used for customization. This
  /// color is used as background color of the confirm credentials screen for that user. The
  /// default color is teal (\#00796B).
  ///
  /// The confirm credentials screen can be created using
  /// android.app.KeyguardManager\#createConfirmDeviceCredentialIntent.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param color The 24bit (0xRRGGBB) representation of the color to be used.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setOrganizationColor(componentname_.ComponentName admin, int color) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOrganizationColor,
          jni.JniType.voidType, [admin.reference, color]).check();

  static final _id_getOrganizationColor = jniAccessors.getMethodIDOf(
      _classRef, "getOrganizationColor", "(Landroid/content/ComponentName;)I");

  /// from: public int getOrganizationColor(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to retrieve the color used for customization.
  /// This color is used as background color of the confirm credentials screen for that user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The 24bit (0xRRGGBB) representation of the color to be used.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  int getOrganizationColor(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_getOrganizationColor,
          jni.JniType.intType, [admin.reference]).integer;

  static final _id_setOrganizationName = jniAccessors.getMethodIDOf(
      _classRef,
      "setOrganizationName",
      "(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V");

  /// from: public void setOrganizationName(android.content.ComponentName admin, java.lang.CharSequence title)
  ///
  /// Called by the device owner (since API 26) or profile owner (since API 24) to set the name of
  /// the organization under management.
  ///
  /// If the organization name needs to be localized, it is the responsibility of the DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast and set
  /// a new version of this string accordingly.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param title The organization name or {@code null} to clear a previously set name.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setOrganizationName(
          componentname_.ComponentName admin, jni.JniObject title) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOrganizationName,
          jni.JniType.voidType, [admin.reference, title.reference]).check();

  static final _id_getOrganizationName = jniAccessors.getMethodIDOf(
      _classRef,
      "getOrganizationName",
      "(Landroid/content/ComponentName;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getOrganizationName(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner of a managed profile to retrieve the name of the organization under
  /// management.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The organization name or {@code null} if none is set.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  jni.JniObject getOrganizationName(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getOrganizationName,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setAffiliationIds = jniAccessors.getMethodIDOf(_classRef,
      "setAffiliationIds", "(Landroid/content/ComponentName;Ljava/util/Set;)V");

  /// from: public void setAffiliationIds(android.content.ComponentName admin, java.util.Set<java.lang.String> ids)
  ///
  /// Indicates the entity that controls the device or profile owner. Two users/profiles are
  /// affiliated if the set of ids set by their device or profile owners intersect.
  ///
  /// A user/profile that is affiliated with the device owner user is considered to be
  /// affiliated with the device.
  ///
  /// <strong>Note:</strong> Features that depend on user affiliation (such as security logging
  /// or \#bindDeviceAdminServiceAsUser) won't be available when a secondary user or profile
  /// is created, until it becomes affiliated. Therefore it is recommended that the appropriate
  /// affiliation ids are set by its profile owner as soon as possible after the user/profile is
  /// created.
  ///@param admin Which profile or device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@param ids A set of opaque non-empty affiliation ids.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if {@code ids} is null or contains an empty string.
  ///@see \#isAffiliatedUser
  void setAffiliationIds(
          componentname_.ComponentName admin, jni.JniObject ids) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAffiliationIds,
          jni.JniType.voidType, [admin.reference, ids.reference]).check();

  static final _id_getAffiliationIds = jniAccessors.getMethodIDOf(_classRef,
      "getAffiliationIds", "(Landroid/content/ComponentName;)Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> getAffiliationIds(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of affiliation ids previously set via \#setAffiliationIds, or an
  /// empty set if none have been set.
  ///@param admin This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject getAffiliationIds(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAffiliationIds,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_isAffiliatedUser =
      jniAccessors.getMethodIDOf(_classRef, "isAffiliatedUser", "()Z");

  /// from: public boolean isAffiliatedUser()
  ///
  /// Returns whether this user/profile is affiliated with the device.
  ///
  /// By definition, the user that the device owner runs on is always affiliated with the device.
  /// Any other user/profile is considered affiliated with the device if the set specified by its
  /// profile owner via \#setAffiliationIds intersects with the device owner's.
  ///@see \#setAffiliationIds
  bool isAffiliatedUser() => jniAccessors.callMethodWithArgs(
      reference, _id_isAffiliatedUser, jni.JniType.booleanType, []).boolean;

  static final _id_setBackupServiceEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "setBackupServiceEnabled",
      "(Landroid/content/ComponentName;Z)V");

  /// from: public void setBackupServiceEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Allows the device owner to enable or disable the backup service.
  ///
  ///  Backup service manages all backup and restore mechanisms on the device. Setting this to
  /// false will prevent data from being backed up or restored.
  ///
  ///  Backup service is off by default when device owner is present.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param enabled {@code true} to enable the backup service, {@code false} to disable it.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setBackupServiceEnabled(
          componentname_.ComponentName admin, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBackupServiceEnabled,
          jni.JniType.voidType, [admin.reference, enabled]).check();

  static final _id_isBackupServiceEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "isBackupServiceEnabled",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isBackupServiceEnabled(android.content.ComponentName admin)
  ///
  /// Return whether the backup service is enabled by the device owner.
  ///
  ///  Backup service manages all backup and restore mechanisms on the device.
  ///@param admin This value must never be {@code null}.
  ///@return {@code true} if backup service is enabled, {@code false} otherwise.
  ///@see \#setBackupServiceEnabled
  bool isBackupServiceEnabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isBackupServiceEnabled,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_setNetworkLoggingEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "setNetworkLoggingEnabled",
      "(Landroid/content/ComponentName;Z)V");

  /// from: public void setNetworkLoggingEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Called by a device owner to control the network logging feature.
  ///
  ///  Network logs contain DNS lookup and connect() library call events. The following library
  ///     functions are recorded while network logging is active:
  ///     <ul>
  ///       <li>{@code getaddrinfo()}</li>
  ///       <li>{@code gethostbyname()}</li>
  ///       <li>{@code connect()}</li>
  ///     </ul>
  ///
  ///  Network logging is a low-overhead tool for forensics but it is not guaranteed to use
  ///     full system call logging; event reporting is enabled by default for all processes but not
  ///     strongly enforced.
  ///     Events from applications using alternative implementations of libc, making direct kernel
  ///     calls, or deliberately obfuscating traffic may not be recorded.
  ///
  ///  Some common network events may not be reported. For example:
  ///     <ul>
  ///       <li>Applications may hardcode IP addresses to reduce the number of DNS lookups, or use
  ///           an alternative system for name resolution, and so avoid calling
  ///           {@code getaddrinfo()} or {@code gethostbyname}.</li>
  ///       <li>Applications may use datagram sockets for performance reasons, for example
  ///           for a game client. Calling {@code connect()} is unnecessary for this kind of
  ///           socket, so it will not trigger a network event.</li>
  ///     </ul>
  ///
  ///  It is possible to directly intercept layer 3 traffic leaving the device using an
  ///     always-on VPN service.
  ///     See \#setAlwaysOnVpnPackage(ComponentName, String, boolean)
  ///     and android.net.VpnService for details.
  ///
  /// <strong>Note:</strong> The device owner won't be able to retrieve network logs if there
  /// are unaffiliated secondary users or profiles on the device, regardless of whether the
  /// feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
  /// all users to become affiliated. Therefore it's recommended that affiliation ids are set for
  /// new users as soon as possible after provisioning via \#setAffiliationIds.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param enabled whether network logging should be enabled or not.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setAffiliationIds
  ///@see \#retrieveNetworkLogs
  void setNetworkLoggingEnabled(
          componentname_.ComponentName admin, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNetworkLoggingEnabled,
          jni.JniType.voidType, [admin.reference, enabled]).check();

  static final _id_isNetworkLoggingEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "isNetworkLoggingEnabled",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isNetworkLoggingEnabled(android.content.ComponentName admin)
  ///
  /// Return whether network logging is enabled by a device owner.
  ///@param admin Which DeviceAdminReceiver this request is associated with. Can only
  /// be {@code null} if the caller has MANAGE_USERS permission.
  /// This value may be {@code null}.
  ///@return {@code true} if network logging is enabled by device owner, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner and caller has
  /// no MANAGE_USERS permission
  bool isNetworkLoggingEnabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isNetworkLoggingEnabled,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_retrieveNetworkLogs = jniAccessors.getMethodIDOf(
      _classRef,
      "retrieveNetworkLogs",
      "(Landroid/content/ComponentName;J)Ljava/util/List;");

  /// from: public java.util.List<android.app.admin.NetworkEvent> retrieveNetworkLogs(android.content.ComponentName admin, long batchToken)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owner to retrieve the most recent batch of network logging events.
  /// A device owner has to provide a batchToken provided as part of
  /// DeviceAdminReceiver\#onNetworkLogsAvailable callback. If the token doesn't match the
  /// token of the most recent available batch of logs, {@code null} will be returned.
  ///
  ///  NetworkEvent can be one of DnsEvent or ConnectEvent.
  ///
  ///  The list of network events is sorted chronologically, and contains at most 1200 events.
  ///
  ///  Access to the logs is rate limited and this method will only return a new batch of logs
  /// after the device device owner has been notified via
  /// DeviceAdminReceiver\#onNetworkLogsAvailable.
  ///
  /// If a secondary user or profile is created, calling this method will throw a
  /// SecurityException until all users become affiliated again. It will also no longer be
  /// possible to retrieve the network logs batch with the most recent batchToken provided
  /// by DeviceAdminReceiver\#onNetworkLogsAvailable. See
  /// DevicePolicyManager\#setAffiliationIds.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param batchToken A token of the batch to retrieve
  ///@return A new batch of network logs which is a list of NetworkEvent. Returns
  ///        {@code null} if the batch represented by batchToken is no longer available or if
  ///        logging is disabled.
  ///@throws SecurityException if {@code admin} is not a device owner, or there is at least one
  /// profile or secondary user that is not affiliated with the device.
  ///@see \#setAffiliationIds
  ///@see DeviceAdminReceiver\#onNetworkLogsAvailable
  jni.JniObject retrieveNetworkLogs(
          componentname_.ComponentName admin, int batchToken) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_retrieveNetworkLogs,
          jni.JniType.objectType,
          [admin.reference, batchToken]).object);

  static final _id_bindDeviceAdminServiceAsUser = jniAccessors.getMethodIDOf(
      _classRef,
      "bindDeviceAdminServiceAsUser",
      "(Landroid/content/ComponentName;Landroid/content/Intent;Landroid/content/ServiceConnection;ILandroid/os/UserHandle;)Z");

  /// from: public boolean bindDeviceAdminServiceAsUser(android.content.ComponentName admin, android.content.Intent serviceIntent, android.content.ServiceConnection conn, int flags, android.os.UserHandle targetUser)
  ///
  /// Called by a device owner to bind to a service from a profile owner or vice versa.
  /// See \#getBindDeviceAdminTargetUsers for a definition of which
  /// device/profile owners are allowed to bind to services of another profile/device owner.
  ///
  /// The service must be protected by android.Manifest.permission\#BIND_DEVICE_ADMIN.
  /// Note that the Context used to obtain this
  /// DevicePolicyManager instance via Context\#getSystemService(Class) will be used
  /// to bind to the android.app.Service.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param serviceIntent Identifies the service to connect to.  The Intent must specify either an
  ///        explicit component name or a package name to match an
  ///        IntentFilter published by a service.
  ///@param conn Receives information as the service is started and stopped in main thread. This
  ///        must be a valid ServiceConnection object; it must not be {@code null}.
  /// This value must never be {@code null}.
  ///@param flags Operation options for the binding operation. See
  ///        Context\#bindService(Intent, ServiceConnection, int).
  /// Value is either <code>0</code> or a combination of android.content.Context\#BIND_AUTO_CREATE, android.content.Context\#BIND_DEBUG_UNBIND, android.content.Context\#BIND_NOT_FOREGROUND, android.content.Context\#BIND_ABOVE_CLIENT, android.content.Context\#BIND_ALLOW_OOM_MANAGEMENT, android.content.Context\#BIND_WAIVE_PRIORITY, android.content.Context\#BIND_IMPORTANT, and android.content.Context\#BIND_ADJUST_WITH_ACTIVITY
  ///@param targetUser Which user to bind to. Must be one of the users returned by
  ///        \#getBindDeviceAdminTargetUsers, otherwise a SecurityException will
  ///        be thrown.
  /// This value must never be {@code null}.
  ///@return If you have successfully bound to the service, {@code true} is returned;
  ///         {@code false} is returned if the connection is not made and you will not
  ///         receive the service object.
  ///@see Context\#bindService(Intent, ServiceConnection, int)
  ///@see \#getBindDeviceAdminTargetUsers(ComponentName)
  bool bindDeviceAdminServiceAsUser(
          componentname_.ComponentName admin,
          intent_.Intent serviceIntent,
          serviceconnection_.ServiceConnection conn,
          int flags,
          userhandle_.UserHandle targetUser) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_bindDeviceAdminServiceAsUser, jni.JniType.booleanType, [
        admin.reference,
        serviceIntent.reference,
        conn.reference,
        flags,
        targetUser.reference
      ]).boolean;

  static final _id_getBindDeviceAdminTargetUsers = jniAccessors.getMethodIDOf(
      _classRef,
      "getBindDeviceAdminTargetUsers",
      "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<android.os.UserHandle> getBindDeviceAdminTargetUsers(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of target users that the calling device or profile owner can use when
  /// calling \#bindDeviceAdminServiceAsUser.
  ///
  /// A device owner can bind to a service from a profile owner and vice versa, provided that:
  /// <ul>
  /// <li>Both belong to the same package name.
  /// <li>Both users are affiliated. See \#setAffiliationIds.
  /// </ul>
  ///@param admin This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject getBindDeviceAdminTargetUsers(
          componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBindDeviceAdminTargetUsers,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_clearApplicationUserData = jniAccessors.getMethodIDOf(
      _classRef,
      "clearApplicationUserData",
      "(Landroid/content/ComponentName;Ljava/lang/String;Ljava/util/concurrent/Executor;Landroid/app/admin/DevicePolicyManager\$OnClearApplicationUserDataListener;)V");

  /// from: public void clearApplicationUserData(android.content.ComponentName admin, java.lang.String packageName, java.util.concurrent.Executor executor, android.app.admin.DevicePolicyManager.OnClearApplicationUserDataListener listener)
  ///
  /// Called by the device owner or profile owner to clear application user data of a given
  /// package. The behaviour of this is equivalent to the target application calling
  /// android.app.ActivityManager\#clearApplicationUserData().
  ///
  /// <strong>Note:</strong> an application can store data outside of its application data, e.g.
  /// external storage or user dictionary. This data will not be wiped by calling this API.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package which will have its user data wiped.
  /// This value must never be {@code null}.
  ///@param executor The executor through which the listener should be invoked.
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param listener A callback object that will inform the caller when the clearing is done.
  /// This value must never be {@code null}.
  ///@throws SecurityException if the caller is not the device owner/profile owner.
  void clearApplicationUserData(
          componentname_.ComponentName admin,
          jni.JniString packageName,
          jni.JniObject executor,
          DevicePolicyManager_OnClearApplicationUserDataListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_clearApplicationUserData, jni.JniType.voidType, [
        admin.reference,
        packageName.reference,
        executor.reference,
        listener.reference
      ]).check();

  static final _id_setLogoutEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setLogoutEnabled", "(Landroid/content/ComponentName;Z)V");

  /// from: public void setLogoutEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Called by a device owner to specify whether logout is enabled for all secondary users. The
  /// system may show a logout button that stops the user and switches back to the primary user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param enabled whether logout should be enabled or not.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setLogoutEnabled(componentname_.ComponentName admin, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLogoutEnabled,
          jni.JniType.voidType, [admin.reference, enabled]).check();

  static final _id_isLogoutEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isLogoutEnabled", "()Z");

  /// from: public boolean isLogoutEnabled()
  ///
  /// Returns whether logout is enabled by a device owner.
  ///@return {@code true} if logout is enabled by device owner, {@code false} otherwise.
  bool isLogoutEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isLogoutEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_transferOwnership = jniAccessors.getMethodIDOf(
      _classRef,
      "transferOwnership",
      "(Landroid/content/ComponentName;Landroid/content/ComponentName;Landroid/os/PersistableBundle;)V");

  /// from: public void transferOwnership(android.content.ComponentName admin, android.content.ComponentName target, android.os.PersistableBundle bundle)
  ///
  /// Changes the current administrator to another one. All policies from the current
  /// administrator are migrated to the new administrator. The whole operation is atomic -
  /// the transfer is either complete or not done at all.
  ///
  /// Depending on the current administrator (device owner, profile owner), you have the
  /// following expected behaviour:
  /// <ul>
  ///     <li>A device owner can only be transferred to a new device owner</li>
  ///     <li>A profile owner can only be transferred to a new profile owner</li>
  /// </ul>
  ///
  /// Use the {@code bundle} parameter to pass data to the new administrator. The data
  /// will be received in the
  /// DeviceAdminReceiver\#onTransferOwnershipComplete(Context, PersistableBundle)
  /// callback of the new administrator.
  ///
  /// The transfer has failed if the original administrator is still the corresponding owner
  /// after calling this method.
  ///
  /// The incoming target administrator must have the
  /// <code>&lt;support-transfer-ownership /&gt;</code> tag inside the
  /// <code>&lt;device-admin&gt;&lt;/device-admin&gt;</code> tags in the xml file referenced by
  /// DeviceAdminReceiver\#DEVICE_ADMIN_META_DATA. Otherwise an
  /// IllegalArgumentException will be thrown.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param target which DeviceAdminReceiver we want the new administrator to be
  /// This value must never be {@code null}.
  ///@param bundle data to be sent to the new administrator
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner nor a profile owner
  ///@throws IllegalArgumentException if {@code admin} or {@code target} is {@code null}, they
  /// are components in the same package or {@code target} is not an active admin
  void transferOwnership(
          componentname_.ComponentName admin,
          componentname_.ComponentName target,
          persistablebundle_.PersistableBundle bundle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_transferOwnership,
          jni.JniType.voidType,
          [admin.reference, target.reference, bundle.reference]).check();

  static final _id_setStartUserSessionMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "setStartUserSessionMessage",
      "(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V");

  /// from: public void setStartUserSessionMessage(android.content.ComponentName admin, java.lang.CharSequence startUserSessionMessage)
  ///
  /// Called by a device owner to specify the user session start message. This may be displayed
  /// during a user switch.
  ///
  /// The message should be limited to a short statement or it may be truncated.
  ///
  /// If the message needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this message accordingly.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param startUserSessionMessage message for starting user session, or {@code null} to use
  /// system default message.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setStartUserSessionMessage(componentname_.ComponentName admin,
          jni.JniObject startUserSessionMessage) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setStartUserSessionMessage,
          jni.JniType.voidType,
          [admin.reference, startUserSessionMessage.reference]).check();

  static final _id_setEndUserSessionMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "setEndUserSessionMessage",
      "(Landroid/content/ComponentName;Ljava/lang/CharSequence;)V");

  /// from: public void setEndUserSessionMessage(android.content.ComponentName admin, java.lang.CharSequence endUserSessionMessage)
  ///
  /// Called by a device owner to specify the user session end message. This may be displayed
  /// during a user switch.
  ///
  /// The message should be limited to a short statement or it may be truncated.
  ///
  /// If the message needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this message accordingly.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param endUserSessionMessage message for ending user session, or {@code null} to use system
  /// default message.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setEndUserSessionMessage(componentname_.ComponentName admin,
          jni.JniObject endUserSessionMessage) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setEndUserSessionMessage,
          jni.JniType.voidType,
          [admin.reference, endUserSessionMessage.reference]).check();

  static final _id_getStartUserSessionMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "getStartUserSessionMessage",
      "(Landroid/content/ComponentName;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getStartUserSessionMessage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user session start message.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  jni.JniObject getStartUserSessionMessage(
          componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStartUserSessionMessage,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_getEndUserSessionMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "getEndUserSessionMessage",
      "(Landroid/content/ComponentName;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getEndUserSessionMessage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user session end message.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  jni.JniObject getEndUserSessionMessage(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getEndUserSessionMessage,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_addOverrideApn = jniAccessors.getMethodIDOf(
      _classRef,
      "addOverrideApn",
      "(Landroid/content/ComponentName;Landroid/telephony/data/ApnSetting;)I");

  /// from: public int addOverrideApn(android.content.ComponentName admin, android.telephony.data.ApnSetting apnSetting)
  ///
  /// Called by device owner to add an override APN.
  ///
  /// This method may returns {@code -1} if {@code apnSetting} conflicts with an existing
  /// override APN. Update the existing conflicted APN with
  /// \#updateOverrideApn(ComponentName, int, ApnSetting) instead of adding a new entry.
  /// Two override APNs are considered to conflict when all the following APIs return
  /// the same values on both override APNs:
  /// <ul>
  ///   <li>ApnSetting\#getOperatorNumeric()</li>
  ///   <li>ApnSetting\#getApnName()</li>
  ///   <li>ApnSetting\#getProxyAddress()</li>
  ///   <li>ApnSetting\#getProxyPort()</li>
  ///   <li>ApnSetting\#getMmsProxyAddress()</li>
  ///   <li>ApnSetting\#getMmsProxyPort()</li>
  ///   <li>ApnSetting\#getMmsc()</li>
  ///   <li>ApnSetting\#isEnabled()</li>
  ///   <li>ApnSetting\#getMvnoType()</li>
  ///   <li>ApnSetting\#getProtocol()</li>
  ///   <li>ApnSetting\#getRoamingProtocol()</li>
  /// </ul>
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param apnSetting the override APN to insert
  /// This value must never be {@code null}.
  ///@return The {@code id} of inserted override APN. Or {@code -1} when failed to insert into
  ///         the database.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  int addOverrideApn(componentname_.ComponentName admin,
          apnsetting_.ApnSetting apnSetting) =>
      jniAccessors.callMethodWithArgs(reference, _id_addOverrideApn,
          jni.JniType.intType, [admin.reference, apnSetting.reference]).integer;

  static final _id_updateOverrideApn = jniAccessors.getMethodIDOf(
      _classRef,
      "updateOverrideApn",
      "(Landroid/content/ComponentName;ILandroid/telephony/data/ApnSetting;)Z");

  /// from: public boolean updateOverrideApn(android.content.ComponentName admin, int apnId, android.telephony.data.ApnSetting apnSetting)
  ///
  /// Called by device owner to update an override APN.
  ///
  /// This method may returns {@code false} if there is no override APN with the given
  /// {@code apnId}.
  /// This method may also returns {@code false} if {@code apnSetting} conflicts with an
  /// existing override APN. Update the existing conflicted APN instead.
  /// See \#addOverrideApn for the definition of conflict.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param apnId the {@code id} of the override APN to update
  ///@param apnSetting the override APN to update
  /// This value must never be {@code null}.
  ///@return {@code true} if the required override APN is successfully updated,
  ///         {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  bool updateOverrideApn(componentname_.ComponentName admin, int apnId,
          apnsetting_.ApnSetting apnSetting) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_updateOverrideApn,
          jni.JniType.booleanType,
          [admin.reference, apnId, apnSetting.reference]).boolean;

  static final _id_removeOverrideApn = jniAccessors.getMethodIDOf(
      _classRef, "removeOverrideApn", "(Landroid/content/ComponentName;I)Z");

  /// from: public boolean removeOverrideApn(android.content.ComponentName admin, int apnId)
  ///
  /// Called by device owner to remove an override APN.
  ///
  /// This method may returns {@code false} if there is no override APN with the given
  /// {@code apnId}.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param apnId the {@code id} of the override APN to remove
  ///@return {@code true} if the required override APN is successfully removed, {@code false}
  ///         otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  bool removeOverrideApn(componentname_.ComponentName admin, int apnId) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeOverrideApn,
          jni.JniType.booleanType, [admin.reference, apnId]).boolean;

  static final _id_getOverrideApns = jniAccessors.getMethodIDOf(_classRef,
      "getOverrideApns", "(Landroid/content/ComponentName;)Ljava/util/List;");

  /// from: public java.util.List<android.telephony.data.ApnSetting> getOverrideApns(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owner to get all override APNs inserted by device owner.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@return A list of override APNs inserted by device owner.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  jni.JniObject getOverrideApns(componentname_.ComponentName admin) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getOverrideApns,
          jni.JniType.objectType,
          [admin.reference]).object);

  static final _id_setOverrideApnsEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "setOverrideApnsEnabled",
      "(Landroid/content/ComponentName;Z)V");

  /// from: public void setOverrideApnsEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Called by device owner to set if override APNs should be enabled.
  ///  Override APNs are separated from other APNs on the device, and can only be inserted or
  /// modified by the device owner. When enabled, only override APNs are in use, any other APNs
  /// are ignored.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param enabled {@code true} if override APNs should be enabled, {@code false} otherwise
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setOverrideApnsEnabled(
          componentname_.ComponentName admin, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOverrideApnsEnabled,
          jni.JniType.voidType, [admin.reference, enabled]).check();

  static final _id_isOverrideApnEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isOverrideApnEnabled", "(Landroid/content/ComponentName;)Z");

  /// from: public boolean isOverrideApnEnabled(android.content.ComponentName admin)
  ///
  /// Called by device owner to check if override APNs are currently enabled.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@return {@code true} if override APNs are currently enabled, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  bool isOverrideApnEnabled(componentname_.ComponentName admin) =>
      jniAccessors.callMethodWithArgs(reference, _id_isOverrideApnEnabled,
          jni.JniType.booleanType, [admin.reference]).boolean;

  static final _id_getTransferOwnershipBundle = jniAccessors.getMethodIDOf(
      _classRef,
      "getTransferOwnershipBundle",
      "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getTransferOwnershipBundle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the data passed from the current administrator to the new administrator during an
  /// ownership transfer. This is the same {@code bundle} passed in
  /// \#transferOwnership(ComponentName, ComponentName, PersistableBundle). The bundle is
  /// persisted until the profile owner or device owner is removed.
  ///
  /// This is the same <code>bundle</code> received in the
  /// DeviceAdminReceiver\#onTransferOwnershipComplete(Context, PersistableBundle).
  /// Use this method to retrieve it after the transfer as long as the new administrator is the
  /// active device or profile owner.
  ///
  /// Returns <code>null</code> if no ownership transfer was started for the calling user.
  ///@see \#transferOwnership
  ///@see DeviceAdminReceiver\#onTransferOwnershipComplete(Context, PersistableBundle)
  ///@throws SecurityException if the caller is not a device or profile owner.
  persistablebundle_.PersistableBundle getTransferOwnershipBundle() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getTransferOwnershipBundle,
              jni.JniType.objectType, []).object);
}

/// from: android.app.admin.DevicePolicyManager$OnClearApplicationUserDataListener
///
/// Callback used in \#clearApplicationUserData
/// to indicate that the clearing of an application's user data is done.
class DevicePolicyManager_OnClearApplicationUserDataListener
    extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/app/admin/DevicePolicyManager\$OnClearApplicationUserDataListener");
  DevicePolicyManager_OnClearApplicationUserDataListener.fromRef(
      jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onApplicationUserDataCleared = jniAccessors.getMethodIDOf(
      _classRef, "onApplicationUserDataCleared", "(Ljava/lang/String;Z)V");

  /// from: public abstract void onApplicationUserDataCleared(java.lang.String packageName, boolean succeeded)
  ///
  /// Method invoked when clearing the application user data has completed.
  ///@param packageName The name of the package which had its user data cleared.
  ///@param succeeded Whether the clearing succeeded. Clearing fails for device administrator
  ///                  apps and protected system packages.
  void onApplicationUserDataCleared(
          jni.JniString packageName, bool succeeded) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onApplicationUserDataCleared,
          jni.JniType.voidType,
          [packageName.reference, succeeded]).check();
}
