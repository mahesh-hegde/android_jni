// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.admin.SecurityLog
///
/// Definitions for working with security logs.
///
/// Device owner apps can control the logging with
/// DevicePolicyManager\#setSecurityLoggingEnabled. When security logs are enabled, device
/// owner apps receive periodic callbacks from DeviceAdminReceiver\#onSecurityLogsAvailable,
/// at which time new batch of logs can be collected via
/// DevicePolicyManager\#retrieveSecurityLogs. SecurityEvent describes the type and
/// format of security logs being collected.
class SecurityLog extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/admin/SecurityLog");
  SecurityLog.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int LEVEL_ERROR
  ///
  /// Event severity level indicating that the event requires urgent admin action.
  static const LEVEL_ERROR = 3;

  /// from: static public final int LEVEL_INFO
  ///
  /// Event severity level indicating that the event corresponds to normal workflow.
  static const LEVEL_INFO = 1;

  /// from: static public final int LEVEL_WARNING
  ///
  /// Event severity level indicating that the event may require admin attention.
  static const LEVEL_WARNING = 2;

  /// from: static public final int TAG_ADB_SHELL_CMD
  ///
  /// Indicates that a shell command was issued over ADB via {@code adb shell <command>}
  /// The log entry contains a {@code String} payload containing the shell command, accessible
  /// via SecurityEvent\#getData().
  static const TAG_ADB_SHELL_CMD = 210002;

  /// from: static public final int TAG_ADB_SHELL_INTERACTIVE
  ///
  /// Indicates that an ADB interactive shell was opened via "adb shell".
  /// There is no extra payload in the log event.
  static const TAG_ADB_SHELL_INTERACTIVE = 210001;

  /// from: static public final int TAG_APP_PROCESS_START
  ///
  /// Indicates that an app process was started. The log entry contains the following
  /// information about the process encapsulated in an Object array, accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] process name ({@code String})
  /// <li> [1] exact start time in milliseconds according to {@code System.currentTimeMillis()}
  ///      ({@code Long})
  /// <li> [2] app uid ({@code Integer})
  /// <li> [3] app pid ({@code Integer})
  /// <li> [4] seinfo tag ({@code String})
  /// <li> [5] SHA-256 hash of the base APK in hexadecimal ({@code String})
  static const TAG_APP_PROCESS_START = 210005;

  /// from: static public final int TAG_CERT_AUTHORITY_INSTALLED
  ///
  /// Indicates that a new root certificate has been installed into system's trusted credential
  /// storage. The log entry contains the following information about the event, encapsulated in an
  /// Object array and accessible via SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] subject of the certificate ({@code String}).
  static const TAG_CERT_AUTHORITY_INSTALLED = 210029;

  /// from: static public final int TAG_CERT_AUTHORITY_REMOVED
  ///
  /// Indicates that a new root certificate has been removed from system's trusted credential
  /// storage. The log entry contains the following information about the event, encapsulated in an
  /// Object array and accessible via SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] subject of the certificate ({@code String}).
  static const TAG_CERT_AUTHORITY_REMOVED = 210030;

  /// from: static public final int TAG_CERT_VALIDATION_FAILURE
  ///
  /// Indicates a failure to validate X.509v3 certificate. The log entry contains a {@code String}
  /// payload indicating the failure reason, accessible via SecurityEvent\#getData().
  static const TAG_CERT_VALIDATION_FAILURE = 210033;

  /// from: static public final int TAG_CRYPTO_SELF_TEST_COMPLETED
  ///
  /// Indicates that cryptographic functionality self test has completed. The log entry contains an
  /// {@code Integer} payload, indicating the result of the test (0 if the test failed, 1 if
  /// succeeded) and accessible via SecurityEvent\#getData().
  static const TAG_CRYPTO_SELF_TEST_COMPLETED = 210031;

  /// from: static public final int TAG_KEYGUARD_DISABLED_FEATURES_SET
  ///
  /// Indicates that an admin has set disabled keyguard features. The log entry contains the
  /// following information about the event encapsulated in an Object array, accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] disabled keyguard feature mask ({@code Integer}).
  ///@see DevicePolicyManager\#setKeyguardDisabledFeatures(ComponentName, int)
  static const TAG_KEYGUARD_DISABLED_FEATURES_SET = 210021;

  /// from: static public final int TAG_KEYGUARD_DISMISSED
  ///
  /// Indicates that keyguard has been dismissed.
  /// There is no extra payload in the log event.
  static const TAG_KEYGUARD_DISMISSED = 210006;

  /// from: static public final int TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT
  ///
  /// Indicates that there has been an authentication attempt to dismiss the keyguard. The log
  /// entry contains the following information about the attempt encapsulated in an Object
  /// array, accessible via SecurityEvent\#getData():
  /// <li> [0] attempt result ({@code Integer}, 1 for successful, 0 for unsuccessful)
  /// <li> [1] strength of authentication method ({@code Integer}, 1 if strong authentication
  ///      method was used, 0 otherwise)
  static const TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT = 210007;

  /// from: static public final int TAG_KEYGUARD_SECURED
  ///
  /// Indicates that the device has been locked, either by the user or by a timeout. There is no
  /// extra payload in the log event.
  static const TAG_KEYGUARD_SECURED = 210008;

  /// from: static public final int TAG_KEY_DESTRUCTION
  ///
  /// Indicates that a cryptographic key was destroyed. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] alias of the key ({@code String})
  /// <li> [2] requesting process uid ({@code Integer}).
  static const TAG_KEY_DESTRUCTION = 210026;

  /// from: static public final int TAG_KEY_GENERATED
  ///
  /// Indicates that an authentication key was generated. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] alias of the key ({@code String})
  /// <li> [2] requesting process uid ({@code Integer}).
  static const TAG_KEY_GENERATED = 210024;

  /// from: static public final int TAG_KEY_IMPORT
  ///
  /// Indicates that a cryptographic key was imported. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] alias of the key ({@code String})
  /// <li> [2] requesting process uid ({@code Integer}).
  static const TAG_KEY_IMPORT = 210025;

  /// from: static public final int TAG_KEY_INTEGRITY_VIOLATION
  ///
  /// Indicates a failed cryptographic key integrity check. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] alias of the key ({@code String})
  /// <li> [1] owner application uid ({@code Integer}).
  static const TAG_KEY_INTEGRITY_VIOLATION = 210032;

  /// from: static public final int TAG_LOGGING_STARTED
  ///
  /// Indicates start-up of audit logging. There is no extra payload in the log event.
  static const TAG_LOGGING_STARTED = 210011;

  /// from: static public final int TAG_LOGGING_STOPPED
  ///
  /// Indicates shutdown of audit logging. There is no extra payload in the log event.
  static const TAG_LOGGING_STOPPED = 210012;

  /// from: static public final int TAG_LOG_BUFFER_SIZE_CRITICAL
  ///
  /// Indicates that the audit log buffer has reached 90% of its capacity. There is no extra
  /// payload in the log event.
  static const TAG_LOG_BUFFER_SIZE_CRITICAL = 210015;

  /// from: static public final int TAG_MAX_PASSWORD_ATTEMPTS_SET
  ///
  /// Indicates that an admin has set a maximum number of failed password attempts before wiping
  /// data. The log entry contains the following information about the event encapsulated in an
  /// Object array, accessible via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] new maximum number of failed password attempts ({@code Integer})
  ///@see DevicePolicyManager\#setMaximumFailedPasswordsForWipe(ComponentName, int)
  static const TAG_MAX_PASSWORD_ATTEMPTS_SET = 210020;

  /// from: static public final int TAG_MAX_SCREEN_LOCK_TIMEOUT_SET
  ///
  /// Indicates that an admin has set a maximum screen lock timeout. The log entry contains the
  /// following information about the event encapsulated in an Object array, accessible
  /// via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] new screen lock timeout in milliseconds ({@code Long})
  ///@see DevicePolicyManager\#setMaximumTimeToLock(ComponentName, long)
  static const TAG_MAX_SCREEN_LOCK_TIMEOUT_SET = 210019;

  /// from: static public final int TAG_MEDIA_MOUNT
  ///
  /// Indicates that removable media has been mounted on the device. The log entry contains the
  /// following information about the event, encapsulated in an Object array and
  /// accessible via SecurityEvent\#getData():
  /// <li> [0] mount point ({@code String})
  /// <li> [1] volume label ({@code String}).
  static const TAG_MEDIA_MOUNT = 210013;

  /// from: static public final int TAG_MEDIA_UNMOUNT
  ///
  /// Indicates that removable media was unmounted from the device. The log entry contains the
  /// following information about the event, encapsulated in an Object array and
  /// accessible via SecurityEvent\#getData():
  /// <li> [0] mount point ({@code String})
  /// <li> [1] volume label ({@code String}).
  static const TAG_MEDIA_UNMOUNT = 210014;

  /// from: static public final int TAG_OS_SHUTDOWN
  ///
  /// Indicates that the Android OS has shutdown. There is no extra payload in the log event.
  static const TAG_OS_SHUTDOWN = 210010;

  /// from: static public final int TAG_OS_STARTUP
  ///
  /// Indicates that the Android OS has started. The log entry contains the following information
  /// about the startup time software integrity check encapsulated in an Object array,
  /// accessible via SecurityEvent\#getData():
  /// <li> [0] Verified Boot state ({@code String})
  /// <li> [1] dm-verity mode ({@code String}).
  /// Verified Boot state can be one of the following:
  /// <li> {@code green} indicates that there is a full chain of trust extending from the
  /// bootloader to verified partitions including the bootloader, boot partition, and all verified
  /// partitions.
  /// <li> {@code yellow} indicates that the boot partition has been verified using the embedded
  /// certificate and the signature is valid.
  /// <li> {@code orange} indicates that the device may be freely modified. Device integrity is
  /// left to the user to verify out-of-band.
  /// dm-verity mode can be one of the following:
  /// <li> {@code enforcing} indicates that the device will be restarted when corruption is
  /// detected.
  /// <li> {@code eio} indicates that an I/O error will be returned for an attempt to read
  /// corrupted data blocks.
  /// For details see Verified Boot documentation.
  static const TAG_OS_STARTUP = 210009;

  /// from: static public final int TAG_PASSWORD_COMPLEXITY_SET
  ///
  /// Indicates that an admin has set a requirement for password complexity. The log entry contains
  /// the following information about the event, encapsulated in an Object array and
  /// accessible via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] minimum password length ({@code Integer})
  /// <li> [4] password quality constraint ({@code Integer})
  /// <li> [5] minimum number of letters ({@code Integer})
  /// <li> [6] minimum number of non-letters ({@code Integer})
  /// <li> [7] minimum number of digits ({@code Integer})
  /// <li> [8] minimum number of uppercase letters ({@code Integer})
  /// <li> [9] minimum number of lowercase letters ({@code Integer})
  /// <li> [10] minimum number of symbols ({@code Integer})
  ///@see DevicePolicyManager\#setPasswordMinimumLength(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordQuality(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumLetters(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumNonLetter(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumLowerCase(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumUpperCase(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumNumeric(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumSymbols(ComponentName, int)
  static const TAG_PASSWORD_COMPLEXITY_SET = 210017;

  /// from: static public final int TAG_PASSWORD_EXPIRATION_SET
  ///
  /// Indicates that an admin has set a password expiration timeout. The log entry contains the
  /// following information about the event, encapsulated in an Object array and accessible
  /// via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] new password expiration timeout in milliseconds ({@code Long}).
  ///@see DevicePolicyManager\#setPasswordExpirationTimeout(ComponentName, long)
  static const TAG_PASSWORD_EXPIRATION_SET = 210016;

  /// from: static public final int TAG_PASSWORD_HISTORY_LENGTH_SET
  ///
  /// Indicates that an admin has set a password history length. The log entry contains the
  /// following information about the event encapsulated in an Object array, accessible
  /// via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] new password history length value ({@code Integer})
  ///@see DevicePolicyManager\#setPasswordHistoryLength(ComponentName, int)
  static const TAG_PASSWORD_HISTORY_LENGTH_SET = 210018;

  /// from: static public final int TAG_REMOTE_LOCK
  ///
  /// Indicates that an admin remotely locked the device or profile. The log entry contains the
  /// following information about the event encapsulated in an Object array, accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String}),
  /// <li> [1] admin user ID ({@code Integer}).
  /// <li> [2] target user ID ({@code Integer})
  static const TAG_REMOTE_LOCK = 210022;

  /// from: static public final int TAG_SYNC_RECV_FILE
  ///
  /// Indicates that a file was pulled from the device via the adb daemon, for example via
  /// {@code adb pull}. The log entry contains a {@code String} payload containing the path of the
  /// pulled file on the device, accessible via SecurityEvent\#getData().
  static const TAG_SYNC_RECV_FILE = 210003;

  /// from: static public final int TAG_SYNC_SEND_FILE
  ///
  /// Indicates that a file was pushed to the device via the adb daemon, for example via
  /// {@code adb push}. The log entry contains a {@code String} payload containing the destination
  /// path of the pushed file, accessible via SecurityEvent\#getData().
  static const TAG_SYNC_SEND_FILE = 210004;

  /// from: static public final int TAG_USER_RESTRICTION_ADDED
  ///
  /// Indicates that an admin has set a user restriction. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] user restriction ({@code String})
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  static const TAG_USER_RESTRICTION_ADDED = 210027;

  /// from: static public final int TAG_USER_RESTRICTION_REMOVED
  ///
  /// Indicates that an admin has removed a user restriction. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] user restriction ({@code String})
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  static const TAG_USER_RESTRICTION_REMOVED = 210028;

  /// from: static public final int TAG_WIPE_FAILURE
  ///
  /// Indicates a failure to wipe device or user data. There is no extra payload in the log event.
  static const TAG_WIPE_FAILURE = 210023;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SecurityLog()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.app.admin.SecurityLog$SecurityEvent
///
/// A class representing a security event log entry.
class SecurityLog_SecurityEvent extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/admin/SecurityLog\$SecurityEvent");
  SecurityLog_SecurityEvent.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.SecurityLog.SecurityEvent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([B)V");

  /// from: void <init>(byte[] data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor used by native classes to generate SecurityEvent instances.
  ///@hide
  SecurityLog_SecurityEvent(jni.JniObject data)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [data.reference]).object);

  static final _id_getTimeNanos =
      jniAccessors.getMethodIDOf(_classRef, "getTimeNanos", "()J");

  /// from: public long getTimeNanos()
  ///
  /// Returns the timestamp in nano seconds when this event was logged.
  int getTimeNanos() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimeNanos, jni.JniType.longType, []).long;

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()I");

  /// from: public int getTag()
  ///
  /// Returns the tag of this log entry, which specifies entry's semantics.
  ///@return Value is android.app.admin.SecurityLog\#TAG_ADB_SHELL_INTERACTIVE, android.app.admin.SecurityLog\#TAG_ADB_SHELL_CMD, android.app.admin.SecurityLog\#TAG_SYNC_RECV_FILE, android.app.admin.SecurityLog\#TAG_SYNC_SEND_FILE, android.app.admin.SecurityLog\#TAG_APP_PROCESS_START, android.app.admin.SecurityLog\#TAG_KEYGUARD_DISMISSED, android.app.admin.SecurityLog\#TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, android.app.admin.SecurityLog\#TAG_KEYGUARD_SECURED, android.app.admin.SecurityLog\#TAG_OS_STARTUP, android.app.admin.SecurityLog\#TAG_OS_SHUTDOWN, android.app.admin.SecurityLog\#TAG_LOGGING_STARTED, android.app.admin.SecurityLog\#TAG_LOGGING_STOPPED, android.app.admin.SecurityLog\#TAG_MEDIA_MOUNT, android.app.admin.SecurityLog\#TAG_MEDIA_UNMOUNT, android.app.admin.SecurityLog\#TAG_LOG_BUFFER_SIZE_CRITICAL, android.app.admin.SecurityLog\#TAG_PASSWORD_EXPIRATION_SET, android.app.admin.SecurityLog\#TAG_PASSWORD_COMPLEXITY_SET, android.app.admin.SecurityLog\#TAG_PASSWORD_HISTORY_LENGTH_SET, android.app.admin.SecurityLog\#TAG_MAX_SCREEN_LOCK_TIMEOUT_SET, android.app.admin.SecurityLog\#TAG_MAX_PASSWORD_ATTEMPTS_SET, android.app.admin.SecurityLog\#TAG_KEYGUARD_DISABLED_FEATURES_SET, android.app.admin.SecurityLog\#TAG_REMOTE_LOCK, android.app.admin.SecurityLog\#TAG_USER_RESTRICTION_ADDED, android.app.admin.SecurityLog\#TAG_USER_RESTRICTION_REMOVED, android.app.admin.SecurityLog\#TAG_WIPE_FAILURE, android.app.admin.SecurityLog\#TAG_KEY_GENERATED, android.app.admin.SecurityLog\#TAG_KEY_IMPORT, android.app.admin.SecurityLog\#TAG_KEY_DESTRUCTION, android.app.admin.SecurityLog\#TAG_CERT_AUTHORITY_INSTALLED, android.app.admin.SecurityLog\#TAG_CERT_AUTHORITY_REMOVED, android.app.admin.SecurityLog\#TAG_CRYPTO_SELF_TEST_COMPLETED, android.app.admin.SecurityLog\#TAG_KEY_INTEGRITY_VIOLATION, or android.app.admin.SecurityLog\#TAG_CERT_VALIDATION_FAILURE
  int getTag() => jniAccessors.callMethodWithArgs(
      reference, _id_getTag, jni.JniType.intType, []).integer;

  static final _id_getData =
      jniAccessors.getMethodIDOf(_classRef, "getData", "()Ljava/lang/Object;");

  /// from: public java.lang.Object getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the payload contained in this log entry or {@code null} if there is no payload.
  jni.JniObject getData() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getData, jni.JniType.objectType, []).object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()J");

  /// from: public long getId()
  ///
  /// Returns the id of the event, where the id monotonically increases for each event. The id
  /// is reset when the device reboots, and when security logging is enabled.
  int getId() => jniAccessors
      .callMethodWithArgs(reference, _id_getId, jni.JniType.longType, []).long;

  static final _id_getLogLevel =
      jniAccessors.getMethodIDOf(_classRef, "getLogLevel", "()I");

  /// from: public int getLogLevel()
  ///
  /// Returns severity level for the event.
  ///@return Value is android.app.admin.SecurityLog\#LEVEL_INFO, android.app.admin.SecurityLog\#LEVEL_WARNING, or android.app.admin.SecurityLog\#LEVEL_ERROR
  int getLogLevel() => jniAccessors.callMethodWithArgs(
      reference, _id_getLogLevel, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  ///
  /// @hide
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// @hide
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
