// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../content/DialogInterface.dart" as dialoginterface_;

import "ActionBar.dart" as actionbar_;

import "Activity.dart" as activity_;

import "../os/Bundle.dart" as bundle_;

import "../view/Window.dart" as window_;

import "../view/View.dart" as view_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../view/KeyEvent.dart" as keyevent_;

import "../view/MotionEvent.dart" as motionevent_;

import "../view/WindowManager.dart" as windowmanager_;

import "../view/accessibility/AccessibilityEvent.dart" as accessibilityevent_;

import "../view/Menu.dart" as menu_;

import "../view/MenuItem.dart" as menuitem_;

import "../view/ContextMenu.dart" as contextmenu_;

import "../view/SearchEvent.dart" as searchevent_;

import "../view/ActionMode.dart" as actionmode_;

import "../net/Uri.dart" as uri_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../view/LayoutInflater.dart" as layoutinflater_;

import "../os/Message.dart" as message_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.Dialog
///
/// Base class for Dialogs.
///
/// Note: Activities provide a facility to manage the creation, saving and
/// restoring of dialogs. See Activity\#onCreateDialog(int),
/// Activity\#onPrepareDialog(int, Dialog),
/// Activity\#showDialog(int), and Activity\#dismissDialog(int). If
/// these methods are used, \#getOwnerActivity() will return the Activity
/// that managed this dialog.
///
/// Often you will want to have a Dialog display on top of the current
/// input method, because there is no reason for it to accept text.  You can
/// do this by setting the WindowManager.LayoutParams\#FLAG_ALT_FOCUSABLE_IM WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM window flag (assuming
/// your Dialog takes input focus, as it the default) with the following code:
///
/// <pre>
/// getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
///         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</pre>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating dialogs, read the
/// <a href="{@docRoot}guide/topics/ui/dialogs.html">Dialogs</a> developer guide.
///
/// </div>
class Dialog extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/Dialog");
  Dialog.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a dialog window that uses the default dialog theme.
  ///
  /// The supplied {@code context} is used to obtain the window manager and
  /// base theme used to present the dialog.
  ///@param context the context in which the dialog should run
  /// This value must never be {@code null}.
  ///@see android.R.styleable\#Theme_dialogTheme
  Dialog(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;I)V");

  /// from: public void <init>(android.content.Context context, int themeResId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a dialog window that uses a custom dialog style.
  ///
  /// The supplied {@code context} is used to obtain the window manager and
  /// base theme used to present the dialog.
  ///
  /// The supplied {@code theme} is applied on top of the context's theme. See
  /// <a href="{@docRoot}guide/topics/resources/available-resources.html\#stylesandthemes">
  /// Style and Theme Resources</a> for more information about defining and
  /// using styles.
  ///@param context the context in which the dialog should run
  /// This value must never be {@code null}.
  ///@param themeResId a style resource describing the theme to use for the
  ///              window, or {@code 0} to use the default dialog theme
  Dialog.ctor1(context_.Context context, int themeResId)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, themeResId]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;ZLandroid/content/DialogInterface\$OnCancelListener;)V");

  /// from: protected void <init>(android.content.Context context, boolean cancelable, android.content.DialogInterface.OnCancelListener cancelListener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param context This value must never be {@code null}.
  ///@param cancelListener This value may be {@code null}.
  Dialog.ctor2(context_.Context context, bool cancelable,
      dialoginterface_.DialogInterface_OnCancelListener cancelListener)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, cancelable, cancelListener.reference]).object);

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public final android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Context this Dialog is running in.
  ///@return Context The Context used by the Dialog.
  ///
  /// This value will never be {@code null}.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getActionBar = jniAccessors.getMethodIDOf(
      _classRef, "getActionBar", "()Landroid/app/ActionBar;");

  /// from: public android.app.ActionBar getActionBar()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the ActionBar attached to this dialog, if present.
  ///@return The ActionBar attached to the dialog or null if no ActionBar is present.
  actionbar_.ActionBar getActionBar() =>
      actionbar_.ActionBar.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActionBar, jni.JniType.objectType, []).object);

  static final _id_setOwnerActivity = jniAccessors.getMethodIDOf(
      _classRef, "setOwnerActivity", "(Landroid/app/Activity;)V");

  /// from: public final void setOwnerActivity(android.app.Activity activity)
  ///
  /// Sets the Activity that owns this dialog. An example use: This Dialog will
  /// use the suggested volume control stream of the Activity.
  ///@param activity The Activity that owns this dialog.
  ///
  /// This value must never be {@code null}.
  void setOwnerActivity(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOwnerActivity,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_getOwnerActivity = jniAccessors.getMethodIDOf(
      _classRef, "getOwnerActivity", "()Landroid/app/Activity;");

  /// from: public final android.app.Activity getOwnerActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Activity that owns this Dialog. For example, if
  /// Activity\#showDialog(int) is used to show this Dialog, that
  /// Activity will be the owner (by default). Depending on how this dialog was
  /// created, this may return null.
  ///@return The Activity that owns this Dialog.
  activity_.Activity getOwnerActivity() =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOwnerActivity, jni.JniType.objectType, []).object);

  static final _id_isShowing =
      jniAccessors.getMethodIDOf(_classRef, "isShowing", "()Z");

  /// from: public boolean isShowing()
  ///
  /// @return Whether the dialog is currently showing.
  bool isShowing() => jniAccessors.callMethodWithArgs(
      reference, _id_isShowing, jni.JniType.booleanType, []).boolean;

  static final _id_create =
      jniAccessors.getMethodIDOf(_classRef, "create", "()V");

  /// from: public void create()
  ///
  /// Forces immediate creation of the dialog.
  ///
  /// Note that you should not override this method to perform dialog creation.
  /// Rather, override \#onCreate(Bundle).
  void create() => jniAccessors.callMethodWithArgs(
      reference, _id_create, jni.JniType.voidType, []).check();

  static final _id_show0 = jniAccessors.getMethodIDOf(_classRef, "show", "()V");

  /// from: public void show()
  ///
  /// Start the dialog and display it on screen.  The window is placed in the
  /// application layer and opaque.  Note that you should not override this
  /// method to do initialization when the dialog is shown, instead implement
  /// that in \#onStart.
  void show0() => jniAccessors.callMethodWithArgs(
      reference, _id_show0, jni.JniType.voidType, []).check();

  static final _id_hide0 = jniAccessors.getMethodIDOf(_classRef, "hide", "()V");

  /// from: public void hide()
  ///
  /// Hide the dialog, but do not dismiss it.
  void hide0() => jniAccessors.callMethodWithArgs(
      reference, _id_hide0, jni.JniType.voidType, []).check();

  static final _id_dismiss =
      jniAccessors.getMethodIDOf(_classRef, "dismiss", "()V");

  /// from: public void dismiss()
  ///
  /// Dismiss this dialog, removing it from the screen. This method can be
  /// invoked safely from any thread.  Note that you should not override this
  /// method to do cleanup when the dialog is dismissed, instead implement
  /// that in \#onStop.
  void dismiss() => jniAccessors.callMethodWithArgs(
      reference, _id_dismiss, jni.JniType.voidType, []).check();

  static final _id_onCreate = jniAccessors.getMethodIDOf(
      _classRef, "onCreate", "(Landroid/os/Bundle;)V");

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  ///
  /// Similar to Activity\#onCreate, you should initialize your dialog
  /// in this method, including calling \#setContentView.
  ///@param savedInstanceState If this dialog is being reinitialized after a
  ///     the hosting activity was previously shut down, holds the result from
  ///     the most recent call to \#onSaveInstanceState, or null if this
  ///     is the first time.
  void onCreate(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreate,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onStart =
      jniAccessors.getMethodIDOf(_classRef, "onStart", "()V");

  /// from: protected void onStart()
  ///
  /// Called when the dialog is starting.
  void onStart() => jniAccessors.callMethodWithArgs(
      reference, _id_onStart, jni.JniType.voidType, []).check();

  static final _id_onStop =
      jniAccessors.getMethodIDOf(_classRef, "onStop", "()V");

  /// from: protected void onStop()
  ///
  /// Called to tell you that you're stopping.
  void onStop() => jniAccessors.callMethodWithArgs(
      reference, _id_onStop, jni.JniType.voidType, []).check();

  static final _id_onSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Saves the state of the dialog into a bundle.
  ///
  /// The default implementation saves the state of its view hierarchy, so you'll
  /// likely want to call through to super if you override this to save additional
  /// state.
  ///@return A bundle with the state of the dialog.
  ///
  /// This value will never be {@code null}.
  bundle_.Bundle onSaveInstanceState() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState, jni.JniType.objectType, []).object);

  static final _id_onRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Bundle;)V");

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  ///
  /// Restore the state of the dialog from a previously saved bundle.
  ///
  /// The default implementation restores the state of the dialog's view
  /// hierarchy that was saved in the default implementation of \#onSaveInstanceState(),
  /// so be sure to call through to super when overriding unless you want to
  /// do all restoring of state yourself.
  ///@param savedInstanceState The state of the dialog previously saved by
  ///     \#onSaveInstanceState().
  ///
  /// This value must never be {@code null}.
  void onRestoreInstanceState(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_getWindow = jniAccessors.getMethodIDOf(
      _classRef, "getWindow", "()Landroid/view/Window;");

  /// from: public android.view.Window getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current Window for the activity.  This can be used to
  /// directly access parts of the Window API that are not available
  /// through Activity/Screen.
  ///@return Window The current window, or null if the activity is not
  ///         visual.
  window_.Window getWindow() =>
      window_.Window.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_getCurrentFocus = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentFocus", "()Landroid/view/View;");

  /// from: public android.view.View getCurrentFocus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call android.view.Window\#getCurrentFocus on the
  /// Window if this Activity to return the currently focused view.
  ///@return View The current View with focus or null.
  ///@see \#getWindow
  ///@see android.view.Window\#getCurrentFocus
  view_.View getCurrentFocus() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCurrentFocus, jni.JniType.objectType, []).object);

  static final _id_setContentView =
      jniAccessors.getMethodIDOf(_classRef, "setContentView", "(I)V");

  /// from: public void setContentView(int layoutResID)
  ///
  /// Set the screen content from a layout resource.  The resource will be
  /// inflated, adding all top-level views to the screen.
  ///@param layoutResID Resource ID to be inflated.
  void setContentView(int layoutResID) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView,
      jni.JniType.voidType,
      [layoutResID]).check();

  static final _id_setContentView1 = jniAccessors.getMethodIDOf(
      _classRef, "setContentView", "(Landroid/view/View;)V");

  /// from: public void setContentView(android.view.View view)
  ///
  /// Set the screen content to an explicit view.  This view is placed
  /// directly into the screen's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  ///
  /// This value must never be {@code null}.
  void setContentView1(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView1,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setContentView2 = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void setContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Set the screen content to an explicit view.  This view is placed
  /// directly into the screen's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  /// This value must never be {@code null}.
  ///@param params Layout parameters for the view.
  ///
  /// This value may be {@code null}.
  void setContentView2(
          view_.View view, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentView2,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_addContentView = jniAccessors.getMethodIDOf(
      _classRef,
      "addContentView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void addContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Add an additional content view to the screen.  Added after any existing
  /// ones in the screen -- existing views are NOT removed.
  ///@param view The desired content to display.
  /// This value must never be {@code null}.
  ///@param params Layout parameters for the view.
  ///
  /// This value may be {@code null}.
  void addContentView(
          view_.View view, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_addContentView,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_setTitle = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public void setTitle(java.lang.CharSequence title)
  ///
  /// Set the title text for this dialog's window.
  ///@param title The new text to display in the title.
  ///
  /// This value may be {@code null}.
  void setTitle(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle, jni.JniType.voidType, [title.reference]).check();

  static final _id_setTitle1 =
      jniAccessors.getMethodIDOf(_classRef, "setTitle", "(I)V");

  /// from: public void setTitle(int titleId)
  ///
  /// Set the title text for this dialog's window. The text is retrieved
  /// from the resources with the supplied identifier.
  ///@param titleId the title's text resource identifier
  void setTitle1(int titleId) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle1, jni.JniType.voidType, [titleId]).check();

  static final _id_onKeyDown = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  ///
  /// A key was pressed down.
  ///
  /// If the focused view didn't want this event, this method is called.
  ///
  /// Default implementation consumes KeyEvent\#KEYCODE_BACK KEYCODE_BACK
  /// and, as of android.os.Build.VERSION_CODES\#P P, KeyEvent\#KEYCODE_ESCAPE KEYCODE_ESCAPE to later handle them in \#onKeyUp.
  ///@see \#onKeyUp
  ///@see android.view.KeyEvent
  ///@param event This value must never be {@code null}.
  bool onKeyDown(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyLongPress = jniAccessors.getMethodIDOf(
      _classRef, "onKeyLongPress", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle
  /// the event).
  ///@param event This value must never be {@code null}.
  bool onKeyLongPress(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyLongPress,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyUp = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  ///
  /// A key was released.
  ///
  /// Default implementation consumes KeyEvent\#KEYCODE_BACK KEYCODE_BACK
  /// and, as of android.os.Build.VERSION_CODES\#P P, KeyEvent\#KEYCODE_ESCAPE KEYCODE_ESCAPE to close the dialog.
  ///@see \#onKeyDown
  ///@see android.view.KeyEvent
  ///@param event This value must never be {@code null}.
  bool onKeyUp(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyMultiple = jniAccessors.getMethodIDOf(
      _classRef, "onKeyMultiple", "(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyMultiple(int, int, KeyEvent) KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle
  /// the event).
  ///@param event This value must never be {@code null}.
  bool onKeyMultiple(int keyCode, int repeatCount, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onKeyMultiple,
          jni.JniType.booleanType,
          [keyCode, repeatCount, event.reference]).boolean;

  static final _id_onBackPressed =
      jniAccessors.getMethodIDOf(_classRef, "onBackPressed", "()V");

  /// from: public void onBackPressed()
  ///
  /// Called when the dialog has detected the user's press of the back
  /// key.  The default implementation simply cancels the dialog (only if
  /// it is cancelable), but you can override this to do whatever you want.
  void onBackPressed() => jniAccessors.callMethodWithArgs(
      reference, _id_onBackPressed, jni.JniType.voidType, []).check();

  static final _id_onKeyShortcut = jniAccessors.getMethodIDOf(
      _classRef, "onKeyShortcut", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyShortcut(int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key shortcut event is not handled by any of the views in the Dialog.
  /// Override this method to implement global key shortcuts for the Dialog.
  /// Key shortcuts can also be implemented by setting the
  /// MenuItem\#setShortcut(char, char) shortcut property of menu items.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  /// This value must never be {@code null}.
  ///@return True if the key shortcut was handled.
  bool onKeyShortcut(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyShortcut,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  ///
  /// Called when a touch screen event was not handled by any of the views
  /// under it. This is most useful to process touch events that happen outside
  /// of your window bounds, where there is no view to receive it.
  ///@param event The touch screen event being processed.
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  ///         The default implementation will cancel the dialog when a touch
  ///         happens outside of the window bounds.
  bool onTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  ///
  /// Called when the trackball was moved and not handled by any of the
  /// views inside of the activity.  So, for example, if the trackball moves
  /// while focus is on a button, you will receive a call here because
  /// buttons do not normally do anything with trackball events.  The call
  /// here happens _before_ trackball movements are converted to
  /// DPAD key events, which then get sent back to the view hierarchy, and
  /// will be processed at the point for things like focus navigation.
  ///@param event The trackball event being processed.
  ///
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Called when a generic motion event was not handled by any of the
  /// views inside of the dialog.
  ///
  /// Generic motion events describe joystick movements, mouse hovers, track pad
  /// touches, scroll wheel movements and other input events.  The
  /// MotionEvent\#getSource() source of the motion event specifies
  /// the class of input that was received.  Implementations of this method
  /// must examine the bits in the source before processing the event.
  /// The following code example shows how this is done.
  ///
  ///
  /// Generic motion events with source class
  /// android.view.InputDevice\#SOURCE_CLASS_POINTER
  /// are delivered to the view under the pointer.  All other generic motion events are
  /// delivered to the focused view.
  ///
  ///
  /// See View\#onGenericMotionEvent(MotionEvent) for an example of how to
  /// handle this event.
  ///
  ///
  ///@param event The generic motion event being processed.
  ///
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onWindowAttributesChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowAttributesChanged",
      "(Landroid/view/WindowManager\$LayoutParams;)V");

  /// from: public void onWindowAttributesChanged(android.view.WindowManager.LayoutParams params)
  void onWindowAttributesChanged(
          windowmanager_.WindowManager_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowAttributesChanged,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_onContentChanged =
      jniAccessors.getMethodIDOf(_classRef, "onContentChanged", "()V");

  /// from: public void onContentChanged()
  void onContentChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_onContentChanged, jni.JniType.voidType, []).check();

  static final _id_onWindowFocusChanged =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  void onWindowFocusChanged(bool hasFocus) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onWindowFocusChanged,
      jni.JniType.voidType,
      [hasFocus]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: public void onAttachedToWindow()
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: public void onDetachedFromWindow()
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_dispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  ///
  /// Called to process key events.  You can override this to intercept all
  /// key events before they are dispatched to the window.  Be sure to call
  /// this implementation for key events that should be handled normally.
  ///@param event The key event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchKeyShortcutEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyShortcutEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  ///
  /// Called to process a key shortcut event.
  /// You can override this to intercept all key shortcut events before they are
  /// dispatched to the window.  Be sure to call this implementation for key shortcut
  /// events that should be handled normally.
  ///@param event The key shortcut event.
  /// This value must never be {@code null}.
  ///@return True if this event was consumed.
  bool dispatchKeyShortcutEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyShortcutEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent ev)
  ///
  /// Called to process touch screen events.  You can override this to
  /// intercept all touch screen events before they are dispatched to the
  /// window.  Be sure to call this implementation for touch screen events
  /// that should be handled normally.
  ///@param ev The touch screen event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTouchEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTouchEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_dispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent ev)
  ///
  /// Called to process trackball events.  You can override this to
  /// intercept all trackball events before they are dispatched to the
  /// window.  Be sure to call this implementation for trackball events
  /// that should be handled normally.
  ///@param ev The trackball event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTrackballEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTrackballEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_dispatchGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent ev)
  ///
  /// Called to process generic motion events.  You can override this to
  /// intercept all generic motion events before they are dispatched to the
  /// window.  Be sure to call this implementation for generic motion events
  /// that should be handled normally.
  ///@param ev The generic motion event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchGenericMotionEvent(motionevent_.MotionEvent ev) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchGenericMotionEvent,
          jni.JniType.booleanType, [ev.reference]).boolean;

  static final _id_dispatchPopulateAccessibilityEvent =
      jniAccessors.getMethodIDOf(
          _classRef,
          "dispatchPopulateAccessibilityEvent",
          "(Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// @param event This value must never be {@code null}.
  bool dispatchPopulateAccessibilityEvent(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPopulateAccessibilityEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_onCreatePanelView = jniAccessors.getMethodIDOf(
      _classRef, "onCreatePanelView", "(I)Landroid/view/View;");

  /// from: public android.view.View onCreatePanelView(int featureId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see Activity\#onCreatePanelView(int)
  view_.View onCreatePanelView(int featureId) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreatePanelView, jni.JniType.objectType, [featureId]).object);

  static final _id_onCreatePanelMenu = jniAccessors.getMethodIDOf(
      _classRef, "onCreatePanelMenu", "(ILandroid/view/Menu;)Z");

  /// from: public boolean onCreatePanelMenu(int featureId, android.view.Menu menu)
  ///
  /// @see Activity\#onCreatePanelMenu(int, Menu)
  ///@param menu This value must never be {@code null}.
  bool onCreatePanelMenu(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreatePanelMenu,
          jni.JniType.booleanType, [featureId, menu.reference]).boolean;

  static final _id_onPreparePanel = jniAccessors.getMethodIDOf(_classRef,
      "onPreparePanel", "(ILandroid/view/View;Landroid/view/Menu;)Z");

  /// from: public boolean onPreparePanel(int featureId, android.view.View view, android.view.Menu menu)
  ///
  /// @see Activity\#onPreparePanel(int, View, Menu)
  bool onPreparePanel(int featureId, view_.View view, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPreparePanel,
          jni.JniType.booleanType,
          [featureId, view.reference, menu.reference]).boolean;

  static final _id_onMenuOpened = jniAccessors.getMethodIDOf(
      _classRef, "onMenuOpened", "(ILandroid/view/Menu;)Z");

  /// from: public boolean onMenuOpened(int featureId, android.view.Menu menu)
  ///
  /// @see Activity\#onMenuOpened(int, Menu)
  bool onMenuOpened(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuOpened,
          jni.JniType.booleanType, [featureId, menu.reference]).boolean;

  static final _id_onMenuItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onMenuItemSelected", "(ILandroid/view/MenuItem;)Z");

  /// from: public boolean onMenuItemSelected(int featureId, android.view.MenuItem item)
  ///
  /// @see Activity\#onMenuItemSelected(int, MenuItem)
  bool onMenuItemSelected(int featureId, menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuItemSelected,
          jni.JniType.booleanType, [featureId, item.reference]).boolean;

  static final _id_onPanelClosed = jniAccessors.getMethodIDOf(
      _classRef, "onPanelClosed", "(ILandroid/view/Menu;)V");

  /// from: public void onPanelClosed(int featureId, android.view.Menu menu)
  ///
  /// @see Activity\#onPanelClosed(int, Menu)
  void onPanelClosed(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPanelClosed,
          jni.JniType.voidType, [featureId, menu.reference]).check();

  static final _id_onCreateOptionsMenu = jniAccessors.getMethodIDOf(
      _classRef, "onCreateOptionsMenu", "(Landroid/view/Menu;)Z");

  /// from: public boolean onCreateOptionsMenu(android.view.Menu menu)
  ///
  /// It is usually safe to proxy this call to the owner activity's
  /// Activity\#onCreateOptionsMenu(Menu) if the client desires the same
  /// menu for this Dialog.
  ///@see Activity\#onCreateOptionsMenu(Menu)
  ///@see \#getOwnerActivity()
  ///@param menu This value must never be {@code null}.
  bool onCreateOptionsMenu(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCreateOptionsMenu,
      jni.JniType.booleanType,
      [menu.reference]).boolean;

  static final _id_onPrepareOptionsMenu = jniAccessors.getMethodIDOf(
      _classRef, "onPrepareOptionsMenu", "(Landroid/view/Menu;)Z");

  /// from: public boolean onPrepareOptionsMenu(android.view.Menu menu)
  ///
  /// It is usually safe to proxy this call to the owner activity's
  /// Activity\#onPrepareOptionsMenu(Menu) if the client desires the
  /// same menu for this Dialog.
  ///@see Activity\#onPrepareOptionsMenu(Menu)
  ///@see \#getOwnerActivity()
  ///@param menu This value must never be {@code null}.
  bool onPrepareOptionsMenu(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onPrepareOptionsMenu,
      jni.JniType.booleanType,
      [menu.reference]).boolean;

  static final _id_onOptionsItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onOptionsItemSelected", "(Landroid/view/MenuItem;)Z");

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  ///
  /// @see Activity\#onOptionsItemSelected(MenuItem)
  ///@param item This value must never be {@code null}.
  bool onOptionsItemSelected(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onOptionsItemSelected,
          jni.JniType.booleanType, [item.reference]).boolean;

  static final _id_onOptionsMenuClosed = jniAccessors.getMethodIDOf(
      _classRef, "onOptionsMenuClosed", "(Landroid/view/Menu;)V");

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  ///
  /// @see Activity\#onOptionsMenuClosed(Menu)
  ///@param menu This value must never be {@code null}.
  void onOptionsMenuClosed(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onOptionsMenuClosed,
      jni.JniType.voidType,
      [menu.reference]).check();

  static final _id_openOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "openOptionsMenu", "()V");

  /// from: public void openOptionsMenu()
  ///
  /// @see Activity\#openOptionsMenu()
  void openOptionsMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_openOptionsMenu, jni.JniType.voidType, []).check();

  static final _id_closeOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "closeOptionsMenu", "()V");

  /// from: public void closeOptionsMenu()
  ///
  /// @see Activity\#closeOptionsMenu()
  void closeOptionsMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_closeOptionsMenu, jni.JniType.voidType, []).check();

  static final _id_invalidateOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "invalidateOptionsMenu", "()V");

  /// from: public void invalidateOptionsMenu()
  ///
  /// @see Activity\#invalidateOptionsMenu()
  void invalidateOptionsMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_invalidateOptionsMenu, jni.JniType.voidType, []).check();

  static final _id_onCreateContextMenu = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateContextMenu",
      "(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu\$ContextMenuInfo;)V");

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  ///
  /// @see Activity\#onCreateContextMenu(ContextMenu, View, ContextMenuInfo)
  void onCreateContextMenu(contextmenu_.ContextMenu menu, view_.View v,
          contextmenu_.ContextMenu_ContextMenuInfo menuInfo) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateContextMenu,
          jni.JniType.voidType,
          [menu.reference, v.reference, menuInfo.reference]).check();

  static final _id_registerForContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "registerForContextMenu", "(Landroid/view/View;)V");

  /// from: public void registerForContextMenu(android.view.View view)
  ///
  /// @see Activity\#registerForContextMenu(View)
  ///@param view This value must never be {@code null}.
  void registerForContextMenu(view_.View view) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerForContextMenu,
          jni.JniType.voidType, [view.reference]).check();

  static final _id_unregisterForContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "unregisterForContextMenu", "(Landroid/view/View;)V");

  /// from: public void unregisterForContextMenu(android.view.View view)
  ///
  /// @see Activity\#unregisterForContextMenu(View)
  ///@param view This value must never be {@code null}.
  void unregisterForContextMenu(view_.View view) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterForContextMenu,
          jni.JniType.voidType, [view.reference]).check();

  static final _id_openContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "openContextMenu", "(Landroid/view/View;)V");

  /// from: public void openContextMenu(android.view.View view)
  ///
  /// @see Activity\#openContextMenu(View)
  ///@param view This value must never be {@code null}.
  void openContextMenu(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_openContextMenu,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_onContextItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onContextItemSelected", "(Landroid/view/MenuItem;)Z");

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  ///
  /// @see Activity\#onContextItemSelected(MenuItem)
  ///@param item This value must never be {@code null}.
  bool onContextItemSelected(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onContextItemSelected,
          jni.JniType.booleanType, [item.reference]).boolean;

  static final _id_onContextMenuClosed = jniAccessors.getMethodIDOf(
      _classRef, "onContextMenuClosed", "(Landroid/view/Menu;)V");

  /// from: public void onContextMenuClosed(android.view.Menu menu)
  ///
  /// @see Activity\#onContextMenuClosed(Menu)
  ///@param menu This value must never be {@code null}.
  void onContextMenuClosed(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onContextMenuClosed,
      jni.JniType.voidType,
      [menu.reference]).check();

  static final _id_onSearchRequested = jniAccessors.getMethodIDOf(
      _classRef, "onSearchRequested", "(Landroid/view/SearchEvent;)Z");

  /// from: public boolean onSearchRequested(android.view.SearchEvent searchEvent)
  ///
  /// This hook is called when the user signals the desire to start a search.
  ///@param searchEvent This value must never be {@code null}.
  bool onSearchRequested(searchevent_.SearchEvent searchEvent) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSearchRequested,
          jni.JniType.booleanType, [searchEvent.reference]).boolean;

  static final _id_onSearchRequested1 =
      jniAccessors.getMethodIDOf(_classRef, "onSearchRequested", "()Z");

  /// from: public boolean onSearchRequested()
  ///
  /// This hook is called when the user signals the desire to start a search.
  bool onSearchRequested1() => jniAccessors.callMethodWithArgs(
      reference, _id_onSearchRequested1, jni.JniType.booleanType, []).boolean;

  static final _id_getSearchEvent = jniAccessors.getMethodIDOf(
      _classRef, "getSearchEvent", "()Landroid/view/SearchEvent;");

  /// from: public final android.view.SearchEvent getSearchEvent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// During the onSearchRequested() callbacks, this function will return the
  /// SearchEvent that triggered the callback, if it exists.
  ///@return SearchEvent The SearchEvent that triggered the \#onSearchRequested callback.
  ///
  /// This value may be {@code null}.
  searchevent_.SearchEvent getSearchEvent() =>
      searchevent_.SearchEvent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSearchEvent, jni.JniType.objectType, []).object);

  static final _id_onWindowStartingActionMode = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowStartingActionMode",
      "(Landroid/view/ActionMode\$Callback;)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  actionmode_.ActionMode onWindowStartingActionMode(
          actionmode_.ActionMode_Callback callback) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowStartingActionMode,
          jni.JniType.objectType,
          [callback.reference]).object);

  static final _id_onWindowStartingActionMode1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowStartingActionMode",
      "(Landroid/view/ActionMode\$Callback;I)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  actionmode_.ActionMode onWindowStartingActionMode1(
          actionmode_.ActionMode_Callback callback, int type) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowStartingActionMode1,
          jni.JniType.objectType,
          [callback.reference, type]).object);

  static final _id_onActionModeStarted = jniAccessors.getMethodIDOf(
      _classRef, "onActionModeStarted", "(Landroid/view/ActionMode;)V");

  /// from: public void onActionModeStarted(android.view.ActionMode mode)
  ///
  /// {@inheritDoc}
  ///
  /// Note that if you override this method you should always call through
  /// to the superclass implementation by calling super.onActionModeStarted(mode).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onActionModeStarted(actionmode_.ActionMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionModeStarted,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_onActionModeFinished = jniAccessors.getMethodIDOf(
      _classRef, "onActionModeFinished", "(Landroid/view/ActionMode;)V");

  /// from: public void onActionModeFinished(android.view.ActionMode mode)
  ///
  /// {@inheritDoc}
  ///
  /// Note that if you override this method you should always call through
  /// to the superclass implementation by calling super.onActionModeFinished(mode).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onActionModeFinished(actionmode_.ActionMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionModeFinished,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_takeKeyEvents =
      jniAccessors.getMethodIDOf(_classRef, "takeKeyEvents", "(Z)V");

  /// from: public void takeKeyEvents(boolean get)
  ///
  /// Request that key events come to this dialog. Use this if your
  /// dialog has no views with focus, but the dialog still wants
  /// a chance to process key events.
  ///@param get true if the dialog should receive key events, false otherwise
  ///@see android.view.Window\#takeKeyEvents
  void takeKeyEvents(bool get0) => jniAccessors.callMethodWithArgs(
      reference, _id_takeKeyEvents, jni.JniType.voidType, [get0]).check();

  static final _id_requestWindowFeature =
      jniAccessors.getMethodIDOf(_classRef, "requestWindowFeature", "(I)Z");

  /// from: public final boolean requestWindowFeature(int featureId)
  ///
  /// Enable extended window features.  This is a convenience for calling
  /// android.view.Window\#requestFeature getWindow().requestFeature().
  ///@param featureId The desired feature as defined in
  ///                  android.view.Window.
  ///@return Returns true if the requested feature is supported and now
  ///         enabled.
  ///@see android.view.Window\#requestFeature
  bool requestWindowFeature(int featureId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestWindowFeature,
      jni.JniType.booleanType,
      [featureId]).boolean;

  static final _id_setFeatureDrawableResource = jniAccessors.getMethodIDOf(
      _classRef, "setFeatureDrawableResource", "(II)V");

  /// from: public final void setFeatureDrawableResource(int featureId, int resId)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableResource.
  void setFeatureDrawableResource(int featureId, int resId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableResource,
          jni.JniType.voidType, [featureId, resId]).check();

  static final _id_setFeatureDrawableUri = jniAccessors.getMethodIDOf(
      _classRef, "setFeatureDrawableUri", "(ILandroid/net/Uri;)V");

  /// from: public final void setFeatureDrawableUri(int featureId, android.net.Uri uri)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableUri.
  ///@param uri This value may be {@code null}.
  void setFeatureDrawableUri(int featureId, uri_.Uri uri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableUri,
          jni.JniType.voidType, [featureId, uri.reference]).check();

  static final _id_setFeatureDrawable = jniAccessors.getMethodIDOf(_classRef,
      "setFeatureDrawable", "(ILandroid/graphics/drawable/Drawable;)V");

  /// from: public final void setFeatureDrawable(int featureId, android.graphics.drawable.Drawable drawable)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawable(int, Drawable).
  ///@param drawable This value may be {@code null}.
  void setFeatureDrawable(int featureId, drawable_.Drawable drawable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawable,
          jni.JniType.voidType, [featureId, drawable.reference]).check();

  static final _id_setFeatureDrawableAlpha =
      jniAccessors.getMethodIDOf(_classRef, "setFeatureDrawableAlpha", "(II)V");

  /// from: public final void setFeatureDrawableAlpha(int featureId, int alpha)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableAlpha.
  void setFeatureDrawableAlpha(int featureId, int alpha) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFeatureDrawableAlpha,
          jni.JniType.voidType, [featureId, alpha]).check();

  static final _id_getLayoutInflater = jniAccessors.getMethodIDOf(
      _classRef, "getLayoutInflater", "()Landroid/view/LayoutInflater;");

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This value will never be {@code null}.
  layoutinflater_.LayoutInflater getLayoutInflater() =>
      layoutinflater_.LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLayoutInflater, jni.JniType.objectType, []).object);

  static final _id_setCancelable =
      jniAccessors.getMethodIDOf(_classRef, "setCancelable", "(Z)V");

  /// from: public void setCancelable(boolean flag)
  ///
  /// Sets whether this dialog is cancelable with the
  /// KeyEvent\#KEYCODE_BACK BACK key.
  void setCancelable(bool flag) => jniAccessors.callMethodWithArgs(
      reference, _id_setCancelable, jni.JniType.voidType, [flag]).check();

  static final _id_setCanceledOnTouchOutside = jniAccessors.getMethodIDOf(
      _classRef, "setCanceledOnTouchOutside", "(Z)V");

  /// from: public void setCanceledOnTouchOutside(boolean cancel)
  ///
  /// Sets whether this dialog is canceled when touched outside the window's
  /// bounds. If setting to true, the dialog is set to be cancelable if not
  /// already set.
  ///@param cancel Whether the dialog should be canceled when touched outside
  ///            the window.
  void setCanceledOnTouchOutside(bool cancel) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCanceledOnTouchOutside,
          jni.JniType.voidType, [cancel]).check();

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "()V");

  /// from: public void cancel()
  ///
  /// Cancel the dialog.  This is essentially the same as calling \#dismiss(), but it will
  /// also call your DialogInterface.OnCancelListener (if registered).
  void cancel() => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, []).check();

  static final _id_setOnCancelListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnCancelListener",
      "(Landroid/content/DialogInterface\$OnCancelListener;)V");

  /// from: public void setOnCancelListener(android.content.DialogInterface.OnCancelListener listener)
  ///
  /// Set a listener to be invoked when the dialog is canceled.
  ///
  /// This will only be invoked when the dialog is canceled.
  /// Cancel events alone will not capture all ways that
  /// the dialog might be dismissed. If the creator needs
  /// to know when a dialog is dismissed in general, use
  /// \#setOnDismissListener.
  ///
  ///@param listener The DialogInterface.OnCancelListener to use.
  ///
  /// This value may be {@code null}.
  void setOnCancelListener(
          dialoginterface_.DialogInterface_OnCancelListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnCancelListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setCancelMessage = jniAccessors.getMethodIDOf(
      _classRef, "setCancelMessage", "(Landroid/os/Message;)V");

  /// from: public void setCancelMessage(android.os.Message msg)
  ///
  /// Set a message to be sent when the dialog is canceled.
  ///@param msg The msg to send when the dialog is canceled.
  /// This value may be {@code null}.
  ///@see \#setOnCancelListener(android.content.DialogInterface.OnCancelListener)
  void setCancelMessage(message_.Message msg) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCancelMessage,
          jni.JniType.voidType, [msg.reference]).check();

  static final _id_setOnDismissListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnDismissListener",
      "(Landroid/content/DialogInterface\$OnDismissListener;)V");

  /// from: public void setOnDismissListener(android.content.DialogInterface.OnDismissListener listener)
  ///
  /// Set a listener to be invoked when the dialog is dismissed.
  ///@param listener The DialogInterface.OnDismissListener to use.
  ///
  /// This value may be {@code null}.
  void setOnDismissListener(
          dialoginterface_.DialogInterface_OnDismissListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnDismissListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setOnShowListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnShowListener",
      "(Landroid/content/DialogInterface\$OnShowListener;)V");

  /// from: public void setOnShowListener(android.content.DialogInterface.OnShowListener listener)
  ///
  /// Sets a listener to be invoked when the dialog is shown.
  ///@param listener The DialogInterface.OnShowListener to use.
  ///
  /// This value may be {@code null}.
  void setOnShowListener(
          dialoginterface_.DialogInterface_OnShowListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnShowListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setDismissMessage = jniAccessors.getMethodIDOf(
      _classRef, "setDismissMessage", "(Landroid/os/Message;)V");

  /// from: public void setDismissMessage(android.os.Message msg)
  ///
  /// Set a message to be sent when the dialog is dismissed.
  ///@param msg The msg to send when the dialog is dismissed.
  ///
  /// This value may be {@code null}.
  void setDismissMessage(message_.Message msg) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDismissMessage,
          jni.JniType.voidType, [msg.reference]).check();

  static final _id_setVolumeControlStream =
      jniAccessors.getMethodIDOf(_classRef, "setVolumeControlStream", "(I)V");

  /// from: public final void setVolumeControlStream(int streamType)
  ///
  /// By default, this will use the owner Activity's suggested stream type.
  ///@see Activity\#setVolumeControlStream(int)
  ///@see \#setOwnerActivity(Activity)
  void setVolumeControlStream(int streamType) =>
      jniAccessors.callMethodWithArgs(reference, _id_setVolumeControlStream,
          jni.JniType.voidType, [streamType]).check();

  static final _id_getVolumeControlStream =
      jniAccessors.getMethodIDOf(_classRef, "getVolumeControlStream", "()I");

  /// from: public final int getVolumeControlStream()
  ///
  /// @see Activity\#getVolumeControlStream()
  int getVolumeControlStream() => jniAccessors.callMethodWithArgs(
      reference, _id_getVolumeControlStream, jni.JniType.intType, []).integer;

  static final _id_setOnKeyListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnKeyListener",
      "(Landroid/content/DialogInterface\$OnKeyListener;)V");

  /// from: public void setOnKeyListener(android.content.DialogInterface.OnKeyListener onKeyListener)
  ///
  /// Sets the callback that will be called if a key is dispatched to the dialog.
  ///@param onKeyListener This value may be {@code null}.
  void setOnKeyListener(
          dialoginterface_.DialogInterface_OnKeyListener onKeyListener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOnKeyListener,
          jni.JniType.voidType, [onKeyListener.reference]).check();
}
