// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/ContextWrapper.dart" as contextwrapper_;

import "../content/res/Configuration.dart" as configuration_;

import "../content/ComponentCallbacks.dart" as componentcallbacks_;

import "Activity.dart" as activity_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.Application
///
/// Base class for maintaining global application state. You can provide your own
/// implementation by creating a subclass and specifying the fully-qualified name
/// of this subclass as the <code>"android:name"</code> attribute in your
/// AndroidManifest.xml's <code>&lt;application&gt;</code> tag. The Application
/// class, or your subclass of the Application class, is instantiated before any
/// other class when the process for your application/package is created.
///
/// <p class="note"><strong>Note: </strong>There is normally no need to subclass
/// Application.  In most situations, static singletons can provide the same
/// functionality in a more modular way.  If your singleton needs a global
/// context (for example to register broadcast receivers), include
/// android.content.Context\#getApplicationContext() Context.getApplicationContext()
/// as a android.content.Context argument when invoking your singleton's
/// <code>getInstance()</code> method.
///
///
class Application extends contextwrapper_.ContextWrapper {
  static final _classRef = jniAccessors.getClassOf("android/app/Application");
  Application.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Application.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  ///
  /// Called when the application is starting, before any activity, service,
  /// or receiver objects (excluding content providers) have been created.
  ///
  /// Implementations should be as quick as possible (for example using
  /// lazy initialization of state) since the time spent in this function
  /// directly impacts the performance of starting the first activity,
  /// service, or receiver in a process.
  ///
  ///
  /// If you override this method, be sure to call {@code super.onCreate()}.
  ///
  ///
  /// <p class="note">Be aware that direct boot may also affect callback order on
  /// Android android.os.Build.VERSION_CODES\#N and later devices.
  /// Until the user unlocks the device, only direct boot aware components are
  /// allowed to run. You should consider that all direct boot unaware
  /// components, including such android.content.ContentProvider, are
  /// disabled until user unlock happens, especially when component callback
  /// order matters.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onTerminate =
      jniAccessors.getMethodIDOf(_classRef, "onTerminate", "()V");

  /// from: public void onTerminate()
  ///
  /// This method is for use in emulated process environments.  It will
  /// never be called on a production Android device, where processes are
  /// removed by simply killing them; no user code (including this callback)
  /// is executed when doing so.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onTerminate() => jniAccessors.callMethodWithArgs(
      reference, _id_onTerminate, jni.JniType.voidType, []).check();

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_onLowMemory =
      jniAccessors.getMethodIDOf(_classRef, "onLowMemory", "()V");

  /// from: public void onLowMemory()
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onLowMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_onLowMemory, jni.JniType.voidType, []).check();

  static final _id_onTrimMemory =
      jniAccessors.getMethodIDOf(_classRef, "onTrimMemory", "(I)V");

  /// from: public void onTrimMemory(int level)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onTrimMemory(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onTrimMemory, jni.JniType.voidType, [level]).check();

  static final _id_registerComponentCallbacks1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerComponentCallbacks",
      "(Landroid/content/ComponentCallbacks;)V");

  /// from: public void registerComponentCallbacks(android.content.ComponentCallbacks callback)
  void registerComponentCallbacks1(
          componentcallbacks_.ComponentCallbacks callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerComponentCallbacks1,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_unregisterComponentCallbacks1 = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterComponentCallbacks",
      "(Landroid/content/ComponentCallbacks;)V");

  /// from: public void unregisterComponentCallbacks(android.content.ComponentCallbacks callback)
  void unregisterComponentCallbacks1(
          componentcallbacks_.ComponentCallbacks callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterComponentCallbacks1,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_registerActivityLifecycleCallbacks =
      jniAccessors.getMethodIDOf(
          _classRef,
          "registerActivityLifecycleCallbacks",
          "(Landroid/app/Application\$ActivityLifecycleCallbacks;)V");

  /// from: public void registerActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks callback)
  void registerActivityLifecycleCallbacks(
          Application_ActivityLifecycleCallbacks callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerActivityLifecycleCallbacks,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_unregisterActivityLifecycleCallbacks =
      jniAccessors.getMethodIDOf(
          _classRef,
          "unregisterActivityLifecycleCallbacks",
          "(Landroid/app/Application\$ActivityLifecycleCallbacks;)V");

  /// from: public void unregisterActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks callback)
  void unregisterActivityLifecycleCallbacks(
          Application_ActivityLifecycleCallbacks callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterActivityLifecycleCallbacks,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_registerOnProvideAssistDataListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "registerOnProvideAssistDataListener",
          "(Landroid/app/Application\$OnProvideAssistDataListener;)V");

  /// from: public void registerOnProvideAssistDataListener(android.app.Application.OnProvideAssistDataListener callback)
  void registerOnProvideAssistDataListener(
          Application_OnProvideAssistDataListener callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerOnProvideAssistDataListener,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_unregisterOnProvideAssistDataListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "unregisterOnProvideAssistDataListener",
          "(Landroid/app/Application\$OnProvideAssistDataListener;)V");

  /// from: public void unregisterOnProvideAssistDataListener(android.app.Application.OnProvideAssistDataListener callback)
  void unregisterOnProvideAssistDataListener(
          Application_OnProvideAssistDataListener callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterOnProvideAssistDataListener,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_getProcessName = jniAccessors.getStaticMethodIDOf(
      _classRef, "getProcessName", "()Ljava/lang/String;");

  /// from: static public java.lang.String getProcessName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of the current process. A package's default process name
  /// is the same as its package name. Non-default processes will look like
  /// "$PACKAGE_NAME:$NAME", where $NAME corresponds to an android:process
  /// attribute within AndroidManifest.xml.
  static jni.JniString getProcessName() =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getProcessName, jni.JniType.objectType, []).object);
}

/// from: android.app.Application$OnProvideAssistDataListener
///
/// Callback interface for use with Application\#registerOnProvideAssistDataListener
/// and Application\#unregisterOnProvideAssistDataListener.
class Application_OnProvideAssistDataListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/Application\$OnProvideAssistDataListener");
  Application_OnProvideAssistDataListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onProvideAssistData = jniAccessors.getMethodIDOf(_classRef,
      "onProvideAssistData", "(Landroid/app/Activity;Landroid/os/Bundle;)V");

  /// from: public abstract void onProvideAssistData(android.app.Activity activity, android.os.Bundle data)
  ///
  /// This is called when the user is requesting an assist, to build a full
  /// Intent\#ACTION_ASSIST Intent with all of the context of the current
  /// application.  You can override this method to place into the bundle anything
  /// you would like to appear in the Intent\#EXTRA_ASSIST_CONTEXT part
  /// of the assist Intent.
  void onProvideAssistData(activity_.Activity activity, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideAssistData,
          jni.JniType.voidType, [activity.reference, data.reference]).check();
}

/// from: android.app.Application$ActivityLifecycleCallbacks
class Application_ActivityLifecycleCallbacks extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/Application\$ActivityLifecycleCallbacks");
  Application_ActivityLifecycleCallbacks.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onActivityCreated = jniAccessors.getMethodIDOf(_classRef,
      "onActivityCreated", "(Landroid/app/Activity;Landroid/os/Bundle;)V");

  /// from: public abstract void onActivityCreated(android.app.Activity activity, android.os.Bundle savedInstanceState)
  void onActivityCreated(
          activity_.Activity activity, bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onActivityCreated,
          jni.JniType.voidType,
          [activity.reference, savedInstanceState.reference]).check();

  static final _id_onActivityStarted = jniAccessors.getMethodIDOf(
      _classRef, "onActivityStarted", "(Landroid/app/Activity;)V");

  /// from: public abstract void onActivityStarted(android.app.Activity activity)
  void onActivityStarted(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActivityStarted,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_onActivityResumed = jniAccessors.getMethodIDOf(
      _classRef, "onActivityResumed", "(Landroid/app/Activity;)V");

  /// from: public abstract void onActivityResumed(android.app.Activity activity)
  void onActivityResumed(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActivityResumed,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_onActivityPaused = jniAccessors.getMethodIDOf(
      _classRef, "onActivityPaused", "(Landroid/app/Activity;)V");

  /// from: public abstract void onActivityPaused(android.app.Activity activity)
  void onActivityPaused(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActivityPaused,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_onActivityStopped = jniAccessors.getMethodIDOf(
      _classRef, "onActivityStopped", "(Landroid/app/Activity;)V");

  /// from: public abstract void onActivityStopped(android.app.Activity activity)
  void onActivityStopped(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActivityStopped,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_onActivitySaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef,
      "onActivitySaveInstanceState",
      "(Landroid/app/Activity;Landroid/os/Bundle;)V");

  /// from: public abstract void onActivitySaveInstanceState(android.app.Activity activity, android.os.Bundle outState)
  void onActivitySaveInstanceState(
          activity_.Activity activity, bundle_.Bundle outState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onActivitySaveInstanceState,
          jni.JniType.voidType,
          [activity.reference, outState.reference]).check();

  static final _id_onActivityDestroyed = jniAccessors.getMethodIDOf(
      _classRef, "onActivityDestroyed", "(Landroid/app/Activity;)V");

  /// from: public abstract void onActivityDestroyed(android.app.Activity activity)
  void onActivityDestroyed(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActivityDestroyed,
          jni.JniType.voidType, [activity.reference]).check();
}
