// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;

import "../os/Handler.dart" as handler_;

import "WallpaperColors.dart" as wallpapercolors_;

import "WallpaperInfo.dart" as wallpaperinfo_;

import "../content/Intent.dart" as intent_;

import "../net/Uri.dart" as uri_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../graphics/Rect.dart" as rect_;

import "../os/IBinder.dart" as ibinder_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.WallpaperManager
///
/// Provides access to the system wallpaper. With WallpaperManager, you can
/// get the current wallpaper, get the desired dimensions for the wallpaper, set
/// the wallpaper, and more.
///
///  An app can check whether wallpapers are supported for the current user, by calling
/// \#isWallpaperSupported(), and whether setting of wallpapers is allowed, by calling
/// \#isSetWallpaperAllowed().
class WallpaperManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/WallpaperManager");
  WallpaperManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CHANGE_LIVE_WALLPAPER
  ///
  /// Directly launch live wallpaper preview, allowing the user to immediately
  /// confirm to switch to a specific live wallpaper.  You must specify
  /// \#EXTRA_LIVE_WALLPAPER_COMPONENT with the ComponentName of
  /// a live wallpaper component that is to be shown.
  static const ACTION_CHANGE_LIVE_WALLPAPER =
      "android.service.wallpaper.CHANGE_LIVE_WALLPAPER";

  /// from: static public final java.lang.String ACTION_CROP_AND_SET_WALLPAPER
  ///
  /// Activity Action: Show settings for choosing wallpaper. Do not use directly to construct
  /// an intent; instead, use \#getCropAndSetWallpaperIntent.
  /// Input:  Intent\#getData is the URI of the image to crop and set as wallpaper.
  /// Output: RESULT_OK if user decided to crop/set the wallpaper, RESULT_CANCEL otherwise
  /// Activities that support this intent should specify a MIME filter of "image/*"
  static const ACTION_CROP_AND_SET_WALLPAPER =
      "android.service.wallpaper.CROP_AND_SET_WALLPAPER";

  /// from: static public final java.lang.String ACTION_LIVE_WALLPAPER_CHOOSER
  ///
  /// Launch an activity for the user to pick the current global live
  /// wallpaper.
  static const ACTION_LIVE_WALLPAPER_CHOOSER =
      "android.service.wallpaper.LIVE_WALLPAPER_CHOOSER";

  /// from: static public final java.lang.String COMMAND_DROP
  ///
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user drops an object into an area of the host.  The x
  /// and y arguments are the location of the drop.
  static const COMMAND_DROP = "android.home.drop";

  /// from: static public final java.lang.String COMMAND_SECONDARY_TAP
  ///
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user releases a secondary pointer on an empty area
  /// (not performing an action in the host).  The x and y arguments are
  /// the location of the secondary tap in screen coordinates.
  static const COMMAND_SECONDARY_TAP = "android.wallpaper.secondaryTap";

  /// from: static public final java.lang.String COMMAND_TAP
  ///
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user taps on an empty area (not performing an action
  /// in the host).  The x and y arguments are the location of the tap in
  /// screen coordinates.
  static const COMMAND_TAP = "android.wallpaper.tap";

  /// from: static public final java.lang.String EXTRA_LIVE_WALLPAPER_COMPONENT
  ///
  /// Extra in \#ACTION_CHANGE_LIVE_WALLPAPER that specifies the
  /// ComponentName of a live wallpaper that should be shown as a preview,
  /// for the user to confirm.
  static const EXTRA_LIVE_WALLPAPER_COMPONENT =
      "android.service.wallpaper.extra.LIVE_WALLPAPER_COMPONENT";

  /// from: static public final int FLAG_LOCK
  ///
  /// Flag: set or retrieve the lock-screen-specific wallpaper.
  static const FLAG_LOCK = 2;

  /// from: static public final int FLAG_SYSTEM
  ///
  /// Flag: set or retrieve the general system wallpaper.
  static const FLAG_SYSTEM = 1;

  /// from: static public final java.lang.String WALLPAPER_PREVIEW_META_DATA
  ///
  /// Manifest entry for activities that respond to Intent\#ACTION_SET_WALLPAPER
  /// which allows them to provide a custom large icon associated with this action.
  static const WALLPAPER_PREVIEW_META_DATA = "android.wallpaper.preview";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WallpaperManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/content/Context;)Landroid/app/WallpaperManager;");

  /// from: static public android.app.WallpaperManager getInstance(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a WallpaperManager associated with the given Context.
  static WallpaperManager getInstance(context_.Context context) =>
      WallpaperManager.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance, jni.JniType.objectType, [context.reference]).object);

  static final _id_getDrawable = jniAccessors.getMethodIDOf(
      _classRef, "getDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current system wallpaper; if
  /// no wallpaper is set, the system built-in static wallpaper is returned.
  /// This is returned as an
  /// abstract Drawable that you can install in a View to display whatever
  /// wallpaper the user has currently set.
  ///
  /// This method can return null if there is no system wallpaper available, if
  /// wallpapers are not supported in the current user, or if the calling app is not
  /// permitted to access the system wallpaper.
  ///@return Returns a Drawable object that will draw the system wallpaper,
  ///     or {@code null} if no system wallpaper exists or if the calling application
  ///     is not able to access the wallpaper.
  drawable_.Drawable getDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrawable, jni.JniType.objectType, []).object);

  static final _id_getBuiltInDrawable = jniAccessors.getMethodIDOf(_classRef,
      "getBuiltInDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a drawable for the built-in static system wallpaper.
  drawable_.Drawable getBuiltInDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBuiltInDrawable, jni.JniType.objectType, []).object);

  static final _id_getBuiltInDrawable1 = jniAccessors.getMethodIDOf(_classRef,
      "getBuiltInDrawable", "(I)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int which)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a drawable for the specified built-in static system wallpaper.
  ///@param which The {@code FLAG_*} identifier of a valid wallpaper type.  Throws
  ///     IllegalArgumentException if an invalid wallpaper is requested.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return A Drawable presenting the specified wallpaper image, or {@code null}
  ///     if no built-in default image for that wallpaper type exists.
  drawable_.Drawable getBuiltInDrawable1(int which) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBuiltInDrawable1, jni.JniType.objectType, [which]).object);

  static final _id_getBuiltInDrawable2 = jniAccessors.getMethodIDOf(_classRef,
      "getBuiltInDrawable", "(IIZFF)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int outWidth, int outHeight, boolean scaleToFit, float horizontalAlignment, float verticalAlignment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a drawable for the system built-in static wallpaper. Based on the parameters, the
  /// drawable can be cropped and scaled
  ///@param outWidth The width of the returned drawable
  ///@param outWidth The height of the returned drawable
  ///@param scaleToFit If true, scale the wallpaper down rather than just cropping it
  ///@param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
  ///@param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
  ///@return A Drawable presenting the built-in default system wallpaper image,
  ///        or {@code null} if no such default image is defined on this device.
  drawable_.Drawable getBuiltInDrawable2(
          int outWidth,
          int outHeight,
          bool scaleToFit,
          double horizontalAlignment,
          double verticalAlignment) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBuiltInDrawable2, jni.JniType.objectType, [
        outWidth,
        outHeight,
        scaleToFit,
        horizontalAlignment,
        verticalAlignment
      ]).object);

  static final _id_getBuiltInDrawable3 = jniAccessors.getMethodIDOf(_classRef,
      "getBuiltInDrawable", "(IIZFFI)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int outWidth, int outHeight, boolean scaleToFit, float horizontalAlignment, float verticalAlignment, int which)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a drawable for the built-in static wallpaper of the specified type.  Based on the
  /// parameters, the drawable can be cropped and scaled.
  ///@param outWidth The width of the returned drawable
  ///@param outWidth The height of the returned drawable
  ///@param scaleToFit If true, scale the wallpaper down rather than just cropping it
  ///@param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
  ///@param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
  ///@param which The {@code FLAG_*} identifier of a valid wallpaper type.  Throws
  ///     IllegalArgumentException if an invalid wallpaper is requested.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return A Drawable presenting the built-in default wallpaper image of the given type,
  ///        or {@code null} if no default image of that type is defined on this device.
  drawable_.Drawable getBuiltInDrawable3(
          int outWidth,
          int outHeight,
          bool scaleToFit,
          double horizontalAlignment,
          double verticalAlignment,
          int which) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBuiltInDrawable3, jni.JniType.objectType, [
        outWidth,
        outHeight,
        scaleToFit,
        horizontalAlignment,
        verticalAlignment,
        which
      ]).object);

  static final _id_peekDrawable = jniAccessors.getMethodIDOf(
      _classRef, "peekDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable peekDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current system wallpaper; if there is no wallpaper set,
  /// a null pointer is returned. This is returned as an
  /// abstract Drawable that you can install in a View to display whatever
  /// wallpaper the user has currently set.
  ///@return Returns a Drawable object that will draw the wallpaper or a
  /// null pointer if these is none.
  drawable_.Drawable peekDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_peekDrawable, jni.JniType.objectType, []).object);

  static final _id_getFastDrawable = jniAccessors.getMethodIDOf(
      _classRef, "getFastDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getFastDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getDrawable(), but the returned Drawable has a number
  /// of limitations to reduce its overhead as much as possible. It will
  /// never scale the wallpaper (only centering it if the requested bounds
  /// do match the bitmap bounds, which should not be typical), doesn't
  /// allow setting an alpha, color filter, or other attributes, etc.  The
  /// bounds of the returned drawable will be initialized to the same bounds
  /// as the wallpaper, so normally you will not need to touch it.  The
  /// drawable also assumes that it will be used in a context running in
  /// the same density as the screen (not in density compatibility mode).
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@return Returns a Drawable object that will draw the wallpaper.
  drawable_.Drawable getFastDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFastDrawable, jni.JniType.objectType, []).object);

  static final _id_peekFastDrawable = jniAccessors.getMethodIDOf(
      _classRef, "peekFastDrawable", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable peekFastDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getFastDrawable(), but if there is no wallpaper set,
  /// a null pointer is returned.
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@return Returns an optimized Drawable object that will draw the
  /// wallpaper or a null pointer if these is none.
  drawable_.Drawable peekFastDrawable() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_peekFastDrawable, jni.JniType.objectType, []).object);

  static final _id_getWallpaperFile = jniAccessors.getMethodIDOf(
      _classRef, "getWallpaperFile", "(I)Landroid/os/ParcelFileDescriptor;");

  /// from: public android.os.ParcelFileDescriptor getWallpaperFile(int which)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an open, readable file descriptor to the given wallpaper image file.
  /// The caller is responsible for closing the file descriptor when done ingesting the file.
  ///
  /// If no lock-specific wallpaper has been configured for the given user, then
  /// this method will return {@code null} when requesting \#FLAG_LOCK rather than
  /// returning the system wallpaper's image file.
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@param which The wallpaper whose image file is to be retrieved.  Must be a single
  ///     defined kind of wallpaper, either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return An open, readable file desriptor to the requested wallpaper image file;
  ///     or {@code null} if no such wallpaper is configured or if the calling app does
  ///     not have permission to read the current wallpaper.
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  parcelfiledescriptor_.ParcelFileDescriptor getWallpaperFile(int which) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getWallpaperFile,
              jni.JniType.objectType, [which]).object);

  static final _id_addOnColorsChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnColorsChangedListener",
      "(Landroid/app/WallpaperManager\$OnColorsChangedListener;Landroid/os/Handler;)V");

  /// from: public void addOnColorsChangedListener(android.app.WallpaperManager.OnColorsChangedListener listener, android.os.Handler handler)
  ///
  /// Registers a listener to get notified when the wallpaper colors change.
  ///@param listener A listener to register
  /// This value must never be {@code null}.
  ///@param handler Where to call it from. Will be called from the main thread
  ///                if null.
  ///
  /// This value must never be {@code null}.
  void addOnColorsChangedListener(
          WallpaperManager_OnColorsChangedListener listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnColorsChangedListener,
          jni.JniType.voidType,
          [listener.reference, handler.reference]).check();

  static final _id_removeOnColorsChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOnColorsChangedListener",
      "(Landroid/app/WallpaperManager\$OnColorsChangedListener;)V");

  /// from: public void removeOnColorsChangedListener(android.app.WallpaperManager.OnColorsChangedListener callback)
  ///
  /// Stop listening to color updates.
  ///@param callback A callback to unsubscribe.
  ///
  /// This value must never be {@code null}.
  void removeOnColorsChangedListener(
          WallpaperManager_OnColorsChangedListener callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnColorsChangedListener,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_getWallpaperColors = jniAccessors.getMethodIDOf(
      _classRef, "getWallpaperColors", "(I)Landroid/app/WallpaperColors;");

  /// from: public android.app.WallpaperColors getWallpaperColors(int which)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the primary colors of a wallpaper.
  ///
  /// This method can return {@code null} when:
  /// <ul>
  /// <li>Colors are still being processed by the system.</li>
  /// <li>The user has chosen to use a live wallpaper:  live wallpapers might not
  /// implement
  /// android.service.wallpaper.WallpaperService.Engine\#onComputeColors() WallpaperService.Engine\#onComputeColors().</li>
  /// </ul>
  ///@param which Wallpaper type. Must be either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  ///@return Current WallpaperColors or null if colors are unknown.
  ///@see \#addOnColorsChangedListener(OnColorsChangedListener, Handler)
  wallpapercolors_.WallpaperColors getWallpaperColors(int which) =>
      wallpapercolors_.WallpaperColors.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getWallpaperColors,
          jni.JniType.objectType,
          [which]).object);

  static final _id_forgetLoadedWallpaper =
      jniAccessors.getMethodIDOf(_classRef, "forgetLoadedWallpaper", "()V");

  /// from: public void forgetLoadedWallpaper()
  ///
  /// Remove all internal references to the last loaded wallpaper.  Useful
  /// for apps that want to reduce memory usage when they only temporarily
  /// need to have the wallpaper.  After calling, the next request for the
  /// wallpaper will require reloading it again from disk.
  void forgetLoadedWallpaper() => jniAccessors.callMethodWithArgs(
      reference, _id_forgetLoadedWallpaper, jni.JniType.voidType, []).check();

  static final _id_getWallpaperInfo = jniAccessors.getMethodIDOf(
      _classRef, "getWallpaperInfo", "()Landroid/app/WallpaperInfo;");

  /// from: public android.app.WallpaperInfo getWallpaperInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the current wallpaper is a live wallpaper component, return the
  /// information about that wallpaper.  Otherwise, if it is a static image,
  /// simply return null.
  wallpaperinfo_.WallpaperInfo getWallpaperInfo() =>
      wallpaperinfo_.WallpaperInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWallpaperInfo, jni.JniType.objectType, []).object);

  static final _id_getWallpaperId =
      jniAccessors.getMethodIDOf(_classRef, "getWallpaperId", "(I)I");

  /// from: public int getWallpaperId(int which)
  ///
  /// Get the ID of the current wallpaper of the given kind.  If there is no
  /// such wallpaper configured, returns a negative number.
  ///
  /// Every time the wallpaper image is set, a new ID is assigned to it.
  /// This method allows the caller to determine whether the wallpaper imagery
  /// has changed, regardless of how that change happened.
  ///@param which The wallpaper whose ID is to be returned.  Must be a single
  ///     defined kind of wallpaper, either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return The positive numeric ID of the current wallpaper of the given kind,
  ///     or a negative value if no such wallpaper is configured.
  int getWallpaperId(int which) => jniAccessors.callMethodWithArgs(
      reference, _id_getWallpaperId, jni.JniType.intType, [which]).integer;

  static final _id_getCropAndSetWallpaperIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "getCropAndSetWallpaperIntent",
      "(Landroid/net/Uri;)Landroid/content/Intent;");

  /// from: public android.content.Intent getCropAndSetWallpaperIntent(android.net.Uri imageUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an Intent that will launch an activity that crops the given
  /// image and sets the device's wallpaper. If there is a default HOME activity
  /// that supports cropping wallpapers, it will be preferred as the default.
  /// Use this method instead of directly creating a \#ACTION_CROP_AND_SET_WALLPAPER
  /// intent.
  ///@param imageUri The image URI that will be set in the intent. The must be a content
  ///                 URI and its provider must resolve its type to "image/*"
  ///@throws IllegalArgumentException if the URI is not a content URI or its MIME type is
  ///         not "image/*"
  intent_.Intent getCropAndSetWallpaperIntent(uri_.Uri imageUri) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCropAndSetWallpaperIntent,
          jni.JniType.objectType,
          [imageUri.reference]).object);

  static final _id_setResource =
      jniAccessors.getMethodIDOf(_classRef, "setResource", "(I)V");

  /// from: public void setResource(int resid)
  ///
  /// Change the current system wallpaper to the bitmap in the given resource.
  /// The resource is opened as a raw data stream and copied into the
  /// wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param resid The resource ID of the bitmap to be used as the wallpaper image
  ///@throws IOException If an error occurs reverting to the built-in
  /// wallpaper.
  void setResource(int resid) => jniAccessors.callMethodWithArgs(
      reference, _id_setResource, jni.JniType.voidType, [resid]).check();

  static final _id_setResource1 =
      jniAccessors.getMethodIDOf(_classRef, "setResource", "(II)I");

  /// from: public int setResource(int resid, int which)
  ///
  /// Version of \#setResource(int) that allows the caller to specify which
  /// of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param resid The resource ID of the bitmap to be used as the wallpaper image
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery
  ///
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException
  int setResource1(int resid, int which) => jniAccessors.callMethodWithArgs(
      reference, _id_setResource1, jni.JniType.intType, [resid, which]).integer;

  static final _id_setBitmap = jniAccessors.getMethodIDOf(
      _classRef, "setBitmap", "(Landroid/graphics/Bitmap;)V");

  /// from: public void setBitmap(android.graphics.Bitmap bitmap)
  ///
  /// Change the current system wallpaper to a bitmap.  The given bitmap is
  /// converted to a PNG and stored as the wallpaper.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method is equivalent to calling
  /// \#setBitmap(Bitmap, Rect, boolean) and passing {@code null} for the
  /// {@code visibleCrop} rectangle and {@code true} for the {@code allowBackup}
  /// parameter.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmap The bitmap to be used as the new system wallpaper.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     to the provided image.
  void setBitmap(bitmap_.Bitmap bitmap) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBitmap,
      jni.JniType.voidType,
      [bitmap.reference]).check();

  static final _id_setBitmap1 = jniAccessors.getMethodIDOf(_classRef,
      "setBitmap", "(Landroid/graphics/Bitmap;Landroid/graphics/Rect;Z)I");

  /// from: public int setBitmap(android.graphics.Bitmap fullImage, android.graphics.Rect visibleCropHint, boolean allowBackup)
  ///
  /// Change the current system wallpaper to a bitmap, specifying a hint about
  /// which subrectangle of the full image is to be visible.  The OS will then
  /// try to best present the given portion of the full image as the static system
  /// wallpaper image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// Passing {@code null} as the {@code visibleHint} parameter is equivalent to
  /// passing (0, 0, {@code fullImage.getWidth()}, {@code fullImage.getHeight()}).
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param fullImage A bitmap that will supply the wallpaper imagery.
  ///@param visibleCropHint The rectangular subregion of {@code fullImage} that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     to the provided image.
  ///@throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
  ///     empty or invalid.
  int setBitmap1(bitmap_.Bitmap fullImage, rect_.Rect visibleCropHint,
          bool allowBackup) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setBitmap1, jni.JniType.intType, [
        fullImage.reference,
        visibleCropHint.reference,
        allowBackup
      ]).integer;

  static final _id_setBitmap2 = jniAccessors.getMethodIDOf(_classRef,
      "setBitmap", "(Landroid/graphics/Bitmap;Landroid/graphics/Rect;ZI)I");

  /// from: public int setBitmap(android.graphics.Bitmap fullImage, android.graphics.Rect visibleCropHint, boolean allowBackup, int which)
  ///
  /// Version of \#setBitmap(Bitmap, Rect, boolean) that allows the caller
  /// to specify which of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param fullImage A bitmap that will supply the wallpaper imagery.
  ///@param visibleCropHint The rectangular subregion of {@code fullImage} that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery.
  ///
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException
  int setBitmap2(bitmap_.Bitmap fullImage, rect_.Rect visibleCropHint,
          bool allowBackup, int which) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setBitmap2, jni.JniType.intType, [
        fullImage.reference,
        visibleCropHint.reference,
        allowBackup,
        which
      ]).integer;

  static final _id_setStream = jniAccessors.getMethodIDOf(
      _classRef, "setStream", "(Ljava/io/InputStream;)V");

  /// from: public void setStream(java.io.InputStream bitmapData)
  ///
  /// Change the current system wallpaper to a specific byte stream.  The
  /// give InputStream is copied into persistent storage and will now be
  /// used as the wallpaper.  Currently it must be either a JPEG or PNG
  /// image.  On success, the intent Intent\#ACTION_WALLPAPER_CHANGED
  /// is broadcast.
  ///
  /// This method is equivalent to calling
  /// \#setStream(InputStream, Rect, boolean) and passing {@code null} for the
  /// {@code visibleCrop} rectangle and {@code true} for the {@code allowBackup}
  /// parameter.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     based on the provided image data.
  void setStream(jni.JniObject bitmapData) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setStream,
      jni.JniType.voidType,
      [bitmapData.reference]).check();

  static final _id_setStream1 = jniAccessors.getMethodIDOf(_classRef,
      "setStream", "(Ljava/io/InputStream;Landroid/graphics/Rect;Z)I");

  /// from: public int setStream(java.io.InputStream bitmapData, android.graphics.Rect visibleCropHint, boolean allowBackup)
  ///
  /// Change the current system wallpaper to a specific byte stream, specifying a
  /// hint about which subrectangle of the full image is to be visible.  The OS will
  /// then try to best present the given portion of the full image as the static system
  /// wallpaper image.  The data from the given InputStream is copied into persistent
  /// storage and will then be used as the system wallpaper.  Currently the data must
  /// be either a JPEG or PNG image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@param visibleCropHint The rectangular subregion of the streamed image that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@see \#getWallpaperId(int)
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     based on the provided image data.
  ///@throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
  ///     empty or invalid.
  int setStream1(jni.JniObject bitmapData, rect_.Rect visibleCropHint,
          bool allowBackup) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setStream1, jni.JniType.intType, [
        bitmapData.reference,
        visibleCropHint.reference,
        allowBackup
      ]).integer;

  static final _id_setStream2 = jniAccessors.getMethodIDOf(_classRef,
      "setStream", "(Ljava/io/InputStream;Landroid/graphics/Rect;ZI)I");

  /// from: public int setStream(java.io.InputStream bitmapData, android.graphics.Rect visibleCropHint, boolean allowBackup, int which)
  ///
  /// Version of \#setStream(InputStream, Rect, boolean) that allows the caller
  /// to specify which of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@param visibleCropHint The rectangular subregion of the streamed image that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@see \#getWallpaperId(int)
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@throws IOException
  int setStream2(jni.JniObject bitmapData, rect_.Rect visibleCropHint,
          bool allowBackup, int which) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setStream2, jni.JniType.intType, [
        bitmapData.reference,
        visibleCropHint.reference,
        allowBackup,
        which
      ]).integer;

  static final _id_hasResourceWallpaper =
      jniAccessors.getMethodIDOf(_classRef, "hasResourceWallpaper", "(I)Z");

  /// from: public boolean hasResourceWallpaper(int resid)
  ///
  /// Return whether any users are currently set to use the wallpaper
  /// with the given resource ID.  That is, their wallpaper has been
  /// set through \#setResource(int) with the same resource id.
  bool hasResourceWallpaper(int resid) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasResourceWallpaper,
      jni.JniType.booleanType,
      [resid]).boolean;

  static final _id_getDesiredMinimumWidth =
      jniAccessors.getMethodIDOf(_classRef, "getDesiredMinimumWidth", "()I");

  /// from: public int getDesiredMinimumWidth()
  ///
  /// Returns the desired minimum width for the wallpaper. Callers of
  /// \#setBitmap(android.graphics.Bitmap) or
  /// \#setStream(java.io.InputStream) should check this value
  /// beforehand to make sure the supplied wallpaper respects the desired
  /// minimum width.
  ///
  /// If the returned value is <= 0, the caller should use the width of
  /// the default display instead.
  ///@return The desired minimum width for the wallpaper. This value should
  /// be honored by applications that set the wallpaper but it is not
  /// mandatory.
  int getDesiredMinimumWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getDesiredMinimumWidth, jni.JniType.intType, []).integer;

  static final _id_getDesiredMinimumHeight =
      jniAccessors.getMethodIDOf(_classRef, "getDesiredMinimumHeight", "()I");

  /// from: public int getDesiredMinimumHeight()
  ///
  /// Returns the desired minimum height for the wallpaper. Callers of
  /// \#setBitmap(android.graphics.Bitmap) or
  /// \#setStream(java.io.InputStream) should check this value
  /// beforehand to make sure the supplied wallpaper respects the desired
  /// minimum height.
  ///
  /// If the returned value is <= 0, the caller should use the height of
  /// the default display instead.
  ///@return The desired minimum height for the wallpaper. This value should
  /// be honored by applications that set the wallpaper but it is not
  /// mandatory.
  int getDesiredMinimumHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getDesiredMinimumHeight, jni.JniType.intType, []).integer;

  static final _id_suggestDesiredDimensions = jniAccessors.getMethodIDOf(
      _classRef, "suggestDesiredDimensions", "(II)V");

  /// from: public void suggestDesiredDimensions(int minimumWidth, int minimumHeight)
  ///
  /// For use only by the current home application, to specify the size of
  /// wallpaper it would like to use.  This allows such applications to have
  /// a virtual wallpaper that is larger than the physical screen, matching
  /// the size of their workspace.
  ///
  /// Note developers, who don't seem to be reading this.  This is
  /// for _home apps_ to tell what size wallpaper they would like.
  /// Nobody else should be calling this!  Certainly not other non-home
  /// apps that change the wallpaper.  Those apps are supposed to
  /// __retrieve__ the suggested size so they can construct a wallpaper
  /// that matches it.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER_HINTS.
  ///@param minimumWidth Desired minimum width
  ///@param minimumHeight Desired minimum height
  void suggestDesiredDimensions(int minimumWidth, int minimumHeight) =>
      jniAccessors.callMethodWithArgs(reference, _id_suggestDesiredDimensions,
          jni.JniType.voidType, [minimumWidth, minimumHeight]).check();

  static final _id_setDisplayPadding = jniAccessors.getMethodIDOf(
      _classRef, "setDisplayPadding", "(Landroid/graphics/Rect;)V");

  /// from: public void setDisplayPadding(android.graphics.Rect padding)
  ///
  /// Specify extra padding that the wallpaper should have outside of the display.
  /// That is, the given padding supplies additional pixels the wallpaper should extend
  /// outside of the display itself.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER_HINTS.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER_HINTS
  ///@param padding The number of pixels the wallpaper should extend beyond the display,
  /// on its left, top, right, and bottom sides.
  void setDisplayPadding(rect_.Rect padding) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDisplayPadding,
      jni.JniType.voidType,
      [padding.reference]).check();

  static final _id_clearWallpaper =
      jniAccessors.getMethodIDOf(_classRef, "clearWallpaper", "()V");

  /// from: public void clearWallpaper()
  ///
  /// Reset all wallpaper to the factory default.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  void clearWallpaper() => jniAccessors.callMethodWithArgs(
      reference, _id_clearWallpaper, jni.JniType.voidType, []).check();

  static final _id_setWallpaperOffsets = jniAccessors.getMethodIDOf(
      _classRef, "setWallpaperOffsets", "(Landroid/os/IBinder;FF)V");

  /// from: public void setWallpaperOffsets(android.os.IBinder windowToken, float xOffset, float yOffset)
  ///
  /// Set the display position of the current wallpaper within any larger space, when
  /// that wallpaper is visible behind the given window.  The X and Y offsets
  /// are floating point numbers ranging from 0 to 1, representing where the
  /// wallpaper should be positioned within the screen space.  These only
  /// make sense when the wallpaper is larger than the display.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  ///@param xOffset The offset along the X dimension, from 0 to 1.
  ///@param yOffset The offset along the Y dimension, from 0 to 1.
  void setWallpaperOffsets(
          ibinder_.IBinder windowToken, double xOffset, double yOffset) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setWallpaperOffsets,
          jni.JniType.voidType,
          [windowToken.reference, xOffset, yOffset]).check();

  static final _id_setWallpaperOffsetSteps =
      jniAccessors.getMethodIDOf(_classRef, "setWallpaperOffsetSteps", "(FF)V");

  /// from: public void setWallpaperOffsetSteps(float xStep, float yStep)
  ///
  /// For applications that use multiple virtual screens showing a wallpaper,
  /// specify the step size between virtual screens. For example, if the
  /// launcher has 3 virtual screens, it would specify an xStep of 0.5,
  /// since the X offset for those screens are 0.0, 0.5 and 1.0
  ///@param xStep The X offset delta from one screen to the next one
  ///@param yStep The Y offset delta from one screen to the next one
  void setWallpaperOffsetSteps(double xStep, double yStep) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWallpaperOffsetSteps,
          jni.JniType.voidType, [xStep, yStep]).check();

  static final _id_sendWallpaperCommand = jniAccessors.getMethodIDOf(
      _classRef,
      "sendWallpaperCommand",
      "(Landroid/os/IBinder;Ljava/lang/String;IIILandroid/os/Bundle;)V");

  /// from: public void sendWallpaperCommand(android.os.IBinder windowToken, java.lang.String action, int x, int y, int z, android.os.Bundle extras)
  ///
  /// Send an arbitrary command to the current active wallpaper.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  ///@param action Name of the command to perform.  This must be a scoped
  /// name to avoid collisions, such as "com.mycompany.wallpaper.DOIT".
  ///@param x Arbitrary integer argument based on command.
  ///@param y Arbitrary integer argument based on command.
  ///@param z Arbitrary integer argument based on command.
  ///@param extras Optional additional information for the command, or null.
  void sendWallpaperCommand(ibinder_.IBinder windowToken, jni.JniString action,
          int x, int y, int z, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendWallpaperCommand, jni.JniType.voidType, [
        windowToken.reference,
        action.reference,
        x,
        y,
        z,
        extras.reference
      ]).check();

  static final _id_isWallpaperSupported =
      jniAccessors.getMethodIDOf(_classRef, "isWallpaperSupported", "()Z");

  /// from: public boolean isWallpaperSupported()
  ///
  /// Returns whether wallpapers are supported for the calling user. If this function returns
  /// {@code false}, any attempts to changing the wallpaper will have no effect,
  /// and any attempt to obtain of the wallpaper will return {@code null}.
  bool isWallpaperSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_isWallpaperSupported, jni.JniType.booleanType, []).boolean;

  static final _id_isSetWallpaperAllowed =
      jniAccessors.getMethodIDOf(_classRef, "isSetWallpaperAllowed", "()Z");

  /// from: public boolean isSetWallpaperAllowed()
  ///
  /// Returns whether the calling package is allowed to set the wallpaper for the calling user.
  /// If this function returns {@code false}, any attempts to change the wallpaper will have
  /// no effect. Always returns {@code true} for device owner and profile owner.
  ///@see android.os.UserManager\#DISALLOW_SET_WALLPAPER
  bool isSetWallpaperAllowed() => jniAccessors.callMethodWithArgs(reference,
      _id_isSetWallpaperAllowed, jni.JniType.booleanType, []).boolean;

  static final _id_clearWallpaperOffsets = jniAccessors.getMethodIDOf(
      _classRef, "clearWallpaperOffsets", "(Landroid/os/IBinder;)V");

  /// from: public void clearWallpaperOffsets(android.os.IBinder windowToken)
  ///
  /// Clear the offsets previously associated with this window through
  /// \#setWallpaperOffsets(IBinder, float, float).  This reverts
  /// the window to its default state, where it does not cause the wallpaper
  /// to scroll from whatever its last offsets were.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  void clearWallpaperOffsets(ibinder_.IBinder windowToken) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearWallpaperOffsets,
          jni.JniType.voidType, [windowToken.reference]).check();

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Remove any currently set system wallpaper, reverting to the system's built-in
  /// wallpaper. On success, the intent Intent\#ACTION_WALLPAPER_CHANGED
  /// is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@throws IOException If an error occurs reverting to the built-in
  /// wallpaper.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_clear1 =
      jniAccessors.getMethodIDOf(_classRef, "clear", "(I)V");

  /// from: public void clear(int which)
  ///
  /// Remove one or more currently set wallpapers, reverting to the system default
  /// display for each one.  If \#FLAG_SYSTEM is set in the {@code which}
  /// parameter, the intent Intent\#ACTION_WALLPAPER_CHANGED will be broadcast
  /// upon success.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param which A bitwise combination of \#FLAG_SYSTEM or
  ///   \#FLAG_LOCK
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@throws IOException If an error occurs reverting to the built-in wallpaper.
  void clear1(int which) => jniAccessors.callMethodWithArgs(
      reference, _id_clear1, jni.JniType.voidType, [which]).check();
}

/// from: android.app.WallpaperManager$OnColorsChangedListener
///
/// Interface definition for a callback to be invoked when colors change on a wallpaper.
class WallpaperManager_OnColorsChangedListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/app/WallpaperManager\$OnColorsChangedListener");
  WallpaperManager_OnColorsChangedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onColorsChanged = jniAccessors.getMethodIDOf(
      _classRef, "onColorsChanged", "(Landroid/app/WallpaperColors;I)V");

  /// from: public abstract void onColorsChanged(android.app.WallpaperColors colors, int which)
  ///
  /// Called when colors change.
  /// A android.app.WallpaperColors object containing a simplified
  /// color histogram will be given.
  ///@param colors Wallpaper color info
  ///@param which A combination of \#FLAG_LOCK and \#FLAG_SYSTEM
  void onColorsChanged(wallpapercolors_.WallpaperColors colors, int which) =>
      jniAccessors.callMethodWithArgs(reference, _id_onColorsChanged,
          jni.JniType.voidType, [colors.reference, which]).check();
}
