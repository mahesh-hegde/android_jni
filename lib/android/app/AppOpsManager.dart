// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.AppOpsManager
///
/// API for interacting with "application operation" tracking.
///
/// This API is not generally intended for third party application developers; most
/// features are only available to system applications.
class AppOpsManager extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/AppOpsManager");
  AppOpsManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MODE_ALLOWED
  ///
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller is
  /// allowed to perform the given operation.
  static const MODE_ALLOWED = 0;

  /// from: static public final int MODE_DEFAULT
  ///
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller should
  /// use its default security check.  This mode is not normally used; it should only be used
  /// with appop permissions, and callers must explicitly check for it and deal with it.
  static const MODE_DEFAULT = 3;

  /// from: static public final int MODE_ERRORED
  ///
  /// Result from \#checkOpNoThrow, \#noteOpNoThrow, \#startOpNoThrow: the
  /// given caller is not allowed to perform the given operation, and this attempt should
  /// cause it to have a fatal error, typically a SecurityException.
  static const MODE_ERRORED = 2;

  /// from: static public final int MODE_IGNORED
  ///
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller is
  /// not allowed to perform the given operation, and this attempt should
  /// _silently fail_ (it should not cause the app to crash).
  static const MODE_IGNORED = 1;

  /// from: static public final java.lang.String OPSTR_ADD_VOICEMAIL
  ///
  /// Required to access phone state related information.
  static const OPSTR_ADD_VOICEMAIL = "android:add_voicemail";

  /// from: static public final java.lang.String OPSTR_ANSWER_PHONE_CALLS
  ///
  /// Answer incoming phone calls
  static const OPSTR_ANSWER_PHONE_CALLS = "android:answer_phone_calls";

  /// from: static public final java.lang.String OPSTR_BODY_SENSORS
  ///
  /// Access to body sensors such as heart rate, etc.
  static const OPSTR_BODY_SENSORS = "android:body_sensors";

  /// from: static public final java.lang.String OPSTR_CALL_PHONE
  ///
  /// Allows an application to initiate a phone call.
  static const OPSTR_CALL_PHONE = "android:call_phone";

  /// from: static public final java.lang.String OPSTR_CAMERA
  ///
  /// Required to be able to access the camera device.
  static const OPSTR_CAMERA = "android:camera";

  /// from: static public final java.lang.String OPSTR_COARSE_LOCATION
  ///
  /// Access to coarse location information.
  static const OPSTR_COARSE_LOCATION = "android:coarse_location";

  /// from: static public final java.lang.String OPSTR_FINE_LOCATION
  ///
  /// Access to fine location information.
  static const OPSTR_FINE_LOCATION = "android:fine_location";

  /// from: static public final java.lang.String OPSTR_GET_USAGE_STATS
  ///
  /// Access to android.app.usage.UsageStatsManager.
  static const OPSTR_GET_USAGE_STATS = "android:get_usage_stats";

  /// from: static public final java.lang.String OPSTR_MOCK_LOCATION
  ///
  /// Inject mock location into the system.
  static const OPSTR_MOCK_LOCATION = "android:mock_location";

  /// from: static public final java.lang.String OPSTR_MONITOR_HIGH_POWER_LOCATION
  ///
  /// Continually monitoring location data with a relatively high power request.
  static const OPSTR_MONITOR_HIGH_POWER_LOCATION =
      "android:monitor_location_high_power";

  /// from: static public final java.lang.String OPSTR_MONITOR_LOCATION
  ///
  /// Continually monitoring location data.
  static const OPSTR_MONITOR_LOCATION = "android:monitor_location";

  /// from: static public final java.lang.String OPSTR_PICTURE_IN_PICTURE
  ///
  /// Access to picture-in-picture.
  static const OPSTR_PICTURE_IN_PICTURE = "android:picture_in_picture";

  /// from: static public final java.lang.String OPSTR_PROCESS_OUTGOING_CALLS
  ///
  /// Access APIs for diverting outgoing calls
  static const OPSTR_PROCESS_OUTGOING_CALLS = "android:process_outgoing_calls";

  /// from: static public final java.lang.String OPSTR_READ_CALENDAR
  ///
  /// Allows an application to read the user's calendar data.
  static const OPSTR_READ_CALENDAR = "android:read_calendar";

  /// from: static public final java.lang.String OPSTR_READ_CALL_LOG
  ///
  /// Allows an application to read the user's call log.
  static const OPSTR_READ_CALL_LOG = "android:read_call_log";

  /// from: static public final java.lang.String OPSTR_READ_CELL_BROADCASTS
  ///
  /// Read previously received cell broadcast messages.
  static const OPSTR_READ_CELL_BROADCASTS = "android:read_cell_broadcasts";

  /// from: static public final java.lang.String OPSTR_READ_CONTACTS
  ///
  /// Allows an application to read the user's contacts data.
  static const OPSTR_READ_CONTACTS = "android:read_contacts";

  /// from: static public final java.lang.String OPSTR_READ_EXTERNAL_STORAGE
  ///
  /// Read external storage.
  static const OPSTR_READ_EXTERNAL_STORAGE = "android:read_external_storage";

  /// from: static public final java.lang.String OPSTR_READ_PHONE_NUMBERS
  static const OPSTR_READ_PHONE_NUMBERS = "android:read_phone_numbers";

  /// from: static public final java.lang.String OPSTR_READ_PHONE_STATE
  ///
  /// Required to access phone state related information.
  static const OPSTR_READ_PHONE_STATE = "android:read_phone_state";

  /// from: static public final java.lang.String OPSTR_READ_SMS
  ///
  /// Allows an application to read SMS messages.
  static const OPSTR_READ_SMS = "android:read_sms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_MMS
  ///
  /// Allows an application to receive MMS messages.
  static const OPSTR_RECEIVE_MMS = "android:receive_mms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_SMS
  ///
  /// Allows an application to receive SMS messages.
  static const OPSTR_RECEIVE_SMS = "android:receive_sms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_WAP_PUSH
  ///
  /// Allows an application to receive WAP push messages.
  static const OPSTR_RECEIVE_WAP_PUSH = "android:receive_wap_push";

  /// from: static public final java.lang.String OPSTR_RECORD_AUDIO
  ///
  /// Required to be able to access the microphone device.
  static const OPSTR_RECORD_AUDIO = "android:record_audio";

  /// from: static public final java.lang.String OPSTR_SEND_SMS
  ///
  /// Allows an application to send SMS messages.
  static const OPSTR_SEND_SMS = "android:send_sms";

  /// from: static public final java.lang.String OPSTR_SYSTEM_ALERT_WINDOW
  ///
  /// Required to draw on top of other apps.
  static const OPSTR_SYSTEM_ALERT_WINDOW = "android:system_alert_window";

  /// from: static public final java.lang.String OPSTR_USE_FINGERPRINT
  ///
  /// Use the fingerprint API.
  static const OPSTR_USE_FINGERPRINT = "android:use_fingerprint";

  /// from: static public final java.lang.String OPSTR_USE_SIP
  ///
  /// Access APIs for SIP calling over VOIP or WiFi
  static const OPSTR_USE_SIP = "android:use_sip";

  /// from: static public final java.lang.String OPSTR_WRITE_CALENDAR
  ///
  /// Allows an application to write to the user's calendar data.
  static const OPSTR_WRITE_CALENDAR = "android:write_calendar";

  /// from: static public final java.lang.String OPSTR_WRITE_CALL_LOG
  ///
  /// Allows an application to write to the user's call log.
  static const OPSTR_WRITE_CALL_LOG = "android:write_call_log";

  /// from: static public final java.lang.String OPSTR_WRITE_CONTACTS
  ///
  /// Allows an application to write to the user's contacts data.
  static const OPSTR_WRITE_CONTACTS = "android:write_contacts";

  /// from: static public final java.lang.String OPSTR_WRITE_EXTERNAL_STORAGE
  ///
  /// Write external storage.
  static const OPSTR_WRITE_EXTERNAL_STORAGE = "android:write_external_storage";

  /// from: static public final java.lang.String OPSTR_WRITE_SETTINGS
  ///
  /// Required to write/modify/update system settingss.
  static const OPSTR_WRITE_SETTINGS = "android:write_settings";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AppOpsManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_permissionToOp = jniAccessors.getStaticMethodIDOf(
      _classRef, "permissionToOp", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String permissionToOp(java.lang.String permission)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the app op name associated with a given permission.
  /// The app op name is one of the public constants defined
  /// in this class such as \#OPSTR_COARSE_LOCATION.
  /// This API is intended to be used for mapping runtime
  /// permissions to the corresponding app op.
  ///@param permission The permission.
  ///@return The app op associated with the permission or null.
  static jni.JniString permissionToOp(jni.JniString permission) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_permissionToOp,
          jni.JniType.objectType,
          [permission.reference]).object);

  static final _id_startWatchingMode = jniAccessors.getMethodIDOf(
      _classRef,
      "startWatchingMode",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/app/AppOpsManager\$OnOpChangedListener;)V");

  /// from: public void startWatchingMode(java.lang.String op, java.lang.String packageName, android.app.AppOpsManager.OnOpChangedListener callback)
  ///
  /// Monitor for changes to the operating mode for the given op in the given app package.
  /// You can watch op changes only for your UID.
  ///@param op The operation to monitor, one of OPSTR_*.
  ///@param packageName The name of the application to monitor.
  ///@param callback Where to report changes.
  void startWatchingMode(jni.JniString op, jni.JniString packageName,
          AppOpsManager_OnOpChangedListener callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startWatchingMode,
          jni.JniType.voidType,
          [op.reference, packageName.reference, callback.reference]).check();

  static final _id_stopWatchingMode = jniAccessors.getMethodIDOf(
      _classRef,
      "stopWatchingMode",
      "(Landroid/app/AppOpsManager\$OnOpChangedListener;)V");

  /// from: public void stopWatchingMode(android.app.AppOpsManager.OnOpChangedListener callback)
  ///
  /// Stop monitoring that was previously started with \#startWatchingMode.  All
  /// monitoring associated with this callback will be removed.
  void stopWatchingMode(AppOpsManager_OnOpChangedListener callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_stopWatchingMode,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_checkOp = jniAccessors.getMethodIDOf(
      _classRef, "checkOp", "(Ljava/lang/String;ILjava/lang/String;)I");

  /// from: public int checkOp(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Do a quick check for whether an application might be able to perform an operation.
  /// This is _not_ a security check; you must use \#noteOp(String, int, String)
  /// or \#startOp(String, int, String) for your actual security checks, which also
  /// ensure that the given uid and package name are consistent.  This function can just be
  /// used for a quick check to see if an operation has been disabled for the application,
  /// as an early reject of some work.  This does not modify the time stamp or other data
  /// about the operation.
  ///
  /// Important things this will not do (which you need to ultimate use
  /// \#noteOp(String, int, String) or \#startOp(String, int, String) to cover):
  ///
  /// <ul>
  ///     <li>Verifying the uid and package are consistent, so callers can't spoof
  ///     their identity.</li>
  ///     <li>Taking into account the current foreground/background state of the
  ///     app; apps whose mode varies by this state will always be reported
  ///     as \#MODE_ALLOWED.</li>
  /// </ul>
  ///@param op The operation to check.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int checkOp(jni.JniString op, int uid, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_checkOp,
          jni.JniType.intType,
          [op.reference, uid, packageName.reference]).integer;

  static final _id_checkOpNoThrow = jniAccessors.getMethodIDOf(
      _classRef, "checkOpNoThrow", "(Ljava/lang/String;ILjava/lang/String;)I");

  /// from: public int checkOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Like \#checkOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int checkOpNoThrow(jni.JniString op, int uid, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_checkOpNoThrow,
          jni.JniType.intType,
          [op.reference, uid, packageName.reference]).integer;

  static final _id_noteOp = jniAccessors.getMethodIDOf(
      _classRef, "noteOp", "(Ljava/lang/String;ILjava/lang/String;)I");

  /// from: public int noteOp(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Make note of an application performing an operation.  Note that you must pass
  /// in both the uid and name of the application to be checked; this function will verify
  /// that these two match, and if not, return \#MODE_IGNORED.  If this call
  /// succeeds, the last execution time of the operation for this app will be updated to
  /// the current time.
  ///@param op The operation to note.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int noteOp(jni.JniString op, int uid, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_noteOp,
          jni.JniType.intType,
          [op.reference, uid, packageName.reference]).integer;

  static final _id_noteOpNoThrow = jniAccessors.getMethodIDOf(
      _classRef, "noteOpNoThrow", "(Ljava/lang/String;ILjava/lang/String;)I");

  /// from: public int noteOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Like \#noteOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int noteOpNoThrow(jni.JniString op, int uid, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_noteOpNoThrow,
          jni.JniType.intType,
          [op.reference, uid, packageName.reference]).integer;

  static final _id_noteProxyOp = jniAccessors.getMethodIDOf(
      _classRef, "noteProxyOp", "(Ljava/lang/String;Ljava/lang/String;)I");

  /// from: public int noteProxyOp(java.lang.String op, java.lang.String proxiedPackageName)
  ///
  /// Make note of an application performing an operation on behalf of another
  /// application when handling an IPC. Note that you must pass the package name
  /// of the application that is being proxied while its UID will be inferred from
  /// the IPC state; this function will verify that the calling uid and proxied
  /// package name match, and if not, return \#MODE_IGNORED. If this call
  /// succeeds, the last execution time of the operation for the proxied app and
  /// your app will be updated to the current time.
  ///@param op The operation to note.  One of the OPSTR_* constants.
  ///@param proxiedPackageName The name of the application calling into the proxy application.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int noteProxyOp(jni.JniString op, jni.JniString proxiedPackageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_noteProxyOp,
          jni.JniType.intType,
          [op.reference, proxiedPackageName.reference]).integer;

  static final _id_noteProxyOpNoThrow = jniAccessors.getMethodIDOf(_classRef,
      "noteProxyOpNoThrow", "(Ljava/lang/String;Ljava/lang/String;)I");

  /// from: public int noteProxyOpNoThrow(java.lang.String op, java.lang.String proxiedPackageName)
  ///
  /// Like \#noteProxyOp(String, String) but instead
  /// of throwing a SecurityException it returns \#MODE_ERRORED.
  int noteProxyOpNoThrow(jni.JniString op, jni.JniString proxiedPackageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_noteProxyOpNoThrow,
          jni.JniType.intType,
          [op.reference, proxiedPackageName.reference]).integer;

  static final _id_startOp = jniAccessors.getMethodIDOf(
      _classRef, "startOp", "(Ljava/lang/String;ILjava/lang/String;)I");

  /// from: public int startOp(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Report that an application has started executing a long-running operation.  Note that you
  /// must pass in both the uid and name of the application to be checked; this function will
  /// verify that these two match, and if not, return \#MODE_IGNORED.  If this call
  /// succeeds, the last execution time of the operation for this app will be updated to
  /// the current time and the operation will be marked as "running".  In this case you must
  /// later call \#finishOp(String, int, String) to report when the application is no
  /// longer performing the operation.
  ///@param op The operation to start.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int startOp(jni.JniString op, int uid, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startOp,
          jni.JniType.intType,
          [op.reference, uid, packageName.reference]).integer;

  static final _id_startOpNoThrow = jniAccessors.getMethodIDOf(
      _classRef, "startOpNoThrow", "(Ljava/lang/String;ILjava/lang/String;)I");

  /// from: public int startOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Like \#startOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int startOpNoThrow(jni.JniString op, int uid, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startOpNoThrow,
          jni.JniType.intType,
          [op.reference, uid, packageName.reference]).integer;

  static final _id_finishOp = jniAccessors.getMethodIDOf(
      _classRef, "finishOp", "(Ljava/lang/String;ILjava/lang/String;)V");

  /// from: public void finishOp(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Report that an application is no longer performing an operation that had previously
  /// been started with \#startOp(String, int, String).  There is no validation of input
  /// or result; the parameters supplied here must be the exact same ones previously passed
  /// in when starting the operation.
  void finishOp(jni.JniString op, int uid, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_finishOp,
          jni.JniType.voidType,
          [op.reference, uid, packageName.reference]).check();

  static final _id_checkPackage = jniAccessors.getMethodIDOf(
      _classRef, "checkPackage", "(ILjava/lang/String;)V");

  /// from: public void checkPackage(int uid, java.lang.String packageName)
  ///
  /// Do a quick check to validate if a package name belongs to a UID.
  ///@throws SecurityException if the package name doesn't belong to the given
  ///             UID, or if ownership cannot be verified.
  void checkPackage(int uid, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkPackage,
          jni.JniType.voidType, [uid, packageName.reference]).check();
}

/// from: android.app.AppOpsManager$OnOpChangedListener
///
/// Callback for notification of changes to operation state.
class AppOpsManager_OnOpChangedListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/AppOpsManager\$OnOpChangedListener");
  AppOpsManager_OnOpChangedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onOpChanged = jniAccessors.getMethodIDOf(
      _classRef, "onOpChanged", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public abstract void onOpChanged(java.lang.String op, java.lang.String packageName)
  void onOpChanged(jni.JniString op, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_onOpChanged,
          jni.JniType.voidType, [op.reference, packageName.reference]).check();
}
