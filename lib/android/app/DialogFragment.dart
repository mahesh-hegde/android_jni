// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Fragment.dart" as fragment_;

import "FragmentManager.dart" as fragmentmanager_;

import "FragmentTransaction.dart" as fragmenttransaction_;

import "Dialog.dart" as dialog_;

import "../content/Context.dart" as context_;

import "../os/Bundle.dart" as bundle_;

import "../view/LayoutInflater.dart" as layoutinflater_;

import "../content/DialogInterface.dart" as dialoginterface_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.DialogFragment
///
/// A fragment that displays a dialog window, floating on top of its
/// activity's window.  This fragment contains a Dialog object, which it
/// displays as appropriate based on the fragment's state.  Control of
/// the dialog (deciding when to show, hide, dismiss it) should be done through
/// the API here, not with direct calls on the dialog.
///
/// Implementations should override this class and implement
/// \#onCreateView(LayoutInflater, ViewGroup, Bundle) to supply the
/// content of the dialog.  Alternatively, they can override
/// \#onCreateDialog(Bundle) to create an entirely custom dialog, such
/// as an AlertDialog, with its own content.
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#Lifecycle">Lifecycle</a>
/// <li><a href="\#BasicDialog">Basic Dialog</a>
/// <li><a href="\#AlertDialog">Alert Dialog</a>
/// <li><a href="\#DialogOrEmbed">Selecting Between Dialog or Embedding</a>
/// </ol>
///
/// <a name="Lifecycle"></a>
/// <h3>Lifecycle</h3>
///
/// DialogFragment does various things to keep the fragment's lifecycle
/// driving it, instead of the Dialog.  Note that dialogs are generally
/// autonomous entities -- they are their own window, receiving their own
/// input events, and often deciding on their own when to disappear (by
/// receiving a back key event or the user clicking on a button).
///
/// DialogFragment needs to ensure that what is happening with the Fragment
/// and Dialog states remains consistent.  To do this, it watches for dismiss
/// events from the dialog and takes care of removing its own state when they
/// happen.  This means you should use \#show(FragmentManager, String)
/// or \#show(FragmentTransaction, String) to add an instance of
/// DialogFragment to your UI, as these keep track of how DialogFragment should
/// remove itself when the dialog is dismissed.
///
/// <a name="BasicDialog"></a>
/// <h3>Basic Dialog</h3>
///
/// The simplest use of DialogFragment is as a floating container for the
/// fragment's view hierarchy.  A simple implementation may look like this:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialog.java
///      dialog}
///
/// An example showDialog() method on the Activity could be:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialog.java
///      add_dialog}
///
/// This removes any currently shown dialog, creates a new DialogFragment
/// with an argument, and shows it as a new state on the back stack.  When the
/// transaction is popped, the current DialogFragment and its Dialog will be
/// destroyed, and the previous one (if any) re-shown.  Note that in this case
/// DialogFragment will take care of popping the transaction of the Dialog
/// is dismissed separately from it.
///
/// <a name="AlertDialog"></a>
/// <h3>Alert Dialog</h3>
///
/// Instead of (or in addition to) implementing \#onCreateView to
/// generate the view hierarchy inside of a dialog, you may implement
/// \#onCreateDialog(Bundle) to create your own custom Dialog object.
///
/// This is most useful for creating an AlertDialog, allowing you
/// to display standard alerts to the user that are managed by a fragment.
/// A simple example implementation of this is:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentAlertDialog.java
///      dialog}
///
/// The activity creating this fragment may have the following methods to
/// show the dialog and receive results from it:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentAlertDialog.java
///      activity}
///
/// Note that in this case the fragment is not placed on the back stack, it
/// is just added as an indefinitely running fragment.  Because dialogs normally
/// are modal, this will still operate as a back stack, since the dialog will
/// capture user input until it is dismissed.  When it is dismissed, DialogFragment
/// will take care of removing itself from its fragment manager.
///
/// <a name="DialogOrEmbed"></a>
/// <h3>Selecting Between Dialog or Embedding</h3>
///
/// A DialogFragment can still optionally be used as a normal fragment, if
/// desired.  This is useful if you have a fragment that in some cases should
/// be shown as a dialog and others embedded in a larger UI.  This behavior
/// will normally be automatically selected for you based on how you are using
/// the fragment, but can be customized with \#setShowsDialog(boolean).
///
/// For example, here is a simple dialog fragment:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      dialog}
///
/// An instance of this fragment can be created and shown as a dialog:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      show_dialog}
///
/// It can also be added as content in a view hierarchy:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      embed}
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.DialogFragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class DialogFragment extends fragment_.Fragment {
  static final _classRef =
      jniAccessors.getClassOf("android/app/DialogFragment");
  DialogFragment.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int STYLE_NORMAL
  ///
  /// Style for \#setStyle(int, int): a basic,
  /// normal dialog.
  static const STYLE_NORMAL = 0;

  /// from: static public final int STYLE_NO_FRAME
  ///
  /// Style for \#setStyle(int, int): don't draw
  /// any frame at all; the view hierarchy returned by \#onCreateView
  /// is entirely responsible for drawing the dialog.
  static const STYLE_NO_FRAME = 2;

  /// from: static public final int STYLE_NO_INPUT
  ///
  /// Style for \#setStyle(int, int): like
  /// \#STYLE_NO_FRAME, but also disables all input to the dialog.
  /// The user can not touch it, and its window will not receive input focus.
  static const STYLE_NO_INPUT = 3;

  /// from: static public final int STYLE_NO_TITLE
  ///
  /// Style for \#setStyle(int, int): don't include
  /// a title area.
  static const STYLE_NO_TITLE = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DialogFragment()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setStyle =
      jniAccessors.getMethodIDOf(_classRef, "setStyle", "(II)V");

  /// from: public void setStyle(int style, int theme)
  ///
  /// Call to customize the basic appearance and behavior of the
  /// fragment's dialog.  This can be used for some common dialog behaviors,
  /// taking care of selecting flags, theme, and other options for you.  The
  /// same effect can be achieve by manually setting Dialog and Window
  /// attributes yourself.  Calling this after the fragment's Dialog is
  /// created will have no effect.
  ///@param style Selects a standard style: may be \#STYLE_NORMAL,
  /// \#STYLE_NO_TITLE, \#STYLE_NO_FRAME, or
  /// \#STYLE_NO_INPUT.
  ///@param theme Optional custom theme.  If 0, an appropriate theme (based
  /// on the style) will be selected for you.
  void setStyle(int style, int theme) => jniAccessors.callMethodWithArgs(
      reference, _id_setStyle, jni.JniType.voidType, [style, theme]).check();

  static final _id_show0 = jniAccessors.getMethodIDOf(
      _classRef, "show", "(Landroid/app/FragmentManager;Ljava/lang/String;)V");

  /// from: public void show(android.app.FragmentManager manager, java.lang.String tag)
  ///
  /// Display the dialog, adding the fragment to the given FragmentManager.  This
  /// is a convenience for explicitly creating a transaction, adding the
  /// fragment to it with the given tag, and committing it.  This does
  /// _not_ add the transaction to the back stack.  When the fragment
  /// is dismissed, a new transaction will be executed to remove it from
  /// the activity.
  ///@param manager The FragmentManager this fragment will be added to.
  ///@param tag The tag for this fragment, as per
  /// FragmentTransaction\#add(Fragment, String) FragmentTransaction.add.
  void show0(fragmentmanager_.FragmentManager manager, jni.JniString tag) =>
      jniAccessors.callMethodWithArgs(reference, _id_show0,
          jni.JniType.voidType, [manager.reference, tag.reference]).check();

  static final _id_show1 = jniAccessors.getMethodIDOf(_classRef, "show",
      "(Landroid/app/FragmentTransaction;Ljava/lang/String;)I");

  /// from: public int show(android.app.FragmentTransaction transaction, java.lang.String tag)
  ///
  /// Display the dialog, adding the fragment using an existing transaction
  /// and then committing the transaction.
  ///@param transaction An existing transaction in which to add the fragment.
  ///@param tag The tag for this fragment, as per
  /// FragmentTransaction\#add(Fragment, String) FragmentTransaction.add.
  ///@return Returns the identifier of the committed transaction, as per
  /// FragmentTransaction\#commit() FragmentTransaction.commit().
  int show1(fragmenttransaction_.FragmentTransaction transaction,
          jni.JniString tag) =>
      jniAccessors.callMethodWithArgs(reference, _id_show1, jni.JniType.intType,
          [transaction.reference, tag.reference]).integer;

  static final _id_dismiss =
      jniAccessors.getMethodIDOf(_classRef, "dismiss", "()V");

  /// from: public void dismiss()
  ///
  /// Dismiss the fragment and its dialog.  If the fragment was added to the
  /// back stack, all back stack state up to and including this entry will
  /// be popped.  Otherwise, a new transaction will be committed to remove
  /// the fragment.
  void dismiss() => jniAccessors.callMethodWithArgs(
      reference, _id_dismiss, jni.JniType.voidType, []).check();

  static final _id_dismissAllowingStateLoss =
      jniAccessors.getMethodIDOf(_classRef, "dismissAllowingStateLoss", "()V");

  /// from: public void dismissAllowingStateLoss()
  ///
  /// Version of \#dismiss() that uses
  /// FragmentTransaction\#commitAllowingStateLoss() FragmentTransaction.commitAllowingStateLoss().  See linked
  /// documentation for further details.
  void dismissAllowingStateLoss() => jniAccessors.callMethodWithArgs(reference,
      _id_dismissAllowingStateLoss, jni.JniType.voidType, []).check();

  static final _id_getDialog = jniAccessors.getMethodIDOf(
      _classRef, "getDialog", "()Landroid/app/Dialog;");

  /// from: public android.app.Dialog getDialog()
  /// The returned object must be deleted after use, by calling the `delete` method.
  dialog_.Dialog getDialog() =>
      dialog_.Dialog.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDialog, jni.JniType.objectType, []).object);

  static final _id_getTheme =
      jniAccessors.getMethodIDOf(_classRef, "getTheme", "()I");

  /// from: public int getTheme()
  int getTheme() => jniAccessors.callMethodWithArgs(
      reference, _id_getTheme, jni.JniType.intType, []).integer;

  static final _id_setCancelable =
      jniAccessors.getMethodIDOf(_classRef, "setCancelable", "(Z)V");

  /// from: public void setCancelable(boolean cancelable)
  ///
  /// Control whether the shown Dialog is cancelable.  Use this instead of
  /// directly calling Dialog\#setCancelable(boolean) Dialog.setCancelable(boolean), because DialogFragment needs to change
  /// its behavior based on this.
  ///@param cancelable If true, the dialog is cancelable.  The default
  /// is true.
  void setCancelable(bool cancelable) => jniAccessors.callMethodWithArgs(
      reference, _id_setCancelable, jni.JniType.voidType, [cancelable]).check();

  static final _id_isCancelable =
      jniAccessors.getMethodIDOf(_classRef, "isCancelable", "()Z");

  /// from: public boolean isCancelable()
  ///
  /// Return the current value of \#setCancelable(boolean).
  bool isCancelable() => jniAccessors.callMethodWithArgs(
      reference, _id_isCancelable, jni.JniType.booleanType, []).boolean;

  static final _id_setShowsDialog =
      jniAccessors.getMethodIDOf(_classRef, "setShowsDialog", "(Z)V");

  /// from: public void setShowsDialog(boolean showsDialog)
  ///
  /// Controls whether this fragment should be shown in a dialog.  If not
  /// set, no Dialog will be created in \#onActivityCreated(Bundle),
  /// and the fragment's view hierarchy will thus not be added to it.  This
  /// allows you to instead use it as a normal fragment (embedded inside of
  /// its activity).
  ///
  /// This is normally set for you based on whether the fragment is
  /// associated with a container view ID passed to
  /// FragmentTransaction\#add(int, Fragment) FragmentTransaction.add(int, Fragment).
  /// If the fragment was added with a container, setShowsDialog will be
  /// initialized to false; otherwise, it will be true.
  ///@param showsDialog If true, the fragment will be displayed in a Dialog.
  /// If false, no Dialog will be created and the fragment's view hierarchly
  /// left undisturbed.
  void setShowsDialog(bool showsDialog) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setShowsDialog,
      jni.JniType.voidType,
      [showsDialog]).check();

  static final _id_getShowsDialog =
      jniAccessors.getMethodIDOf(_classRef, "getShowsDialog", "()Z");

  /// from: public boolean getShowsDialog()
  ///
  /// Return the current value of \#setShowsDialog(boolean).
  bool getShowsDialog() => jniAccessors.callMethodWithArgs(
      reference, _id_getShowsDialog, jni.JniType.booleanType, []).boolean;

  static final _id_onAttach = jniAccessors.getMethodIDOf(
      _classRef, "onAttach", "(Landroid/content/Context;)V");

  /// from: public void onAttach(android.content.Context context)
  void onAttach(context_.Context context) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onAttach,
      jni.JniType.voidType,
      [context.reference]).check();

  static final _id_onDetach =
      jniAccessors.getMethodIDOf(_classRef, "onDetach", "()V");

  /// from: public void onDetach()
  void onDetach() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetach, jni.JniType.voidType, []).check();

  static final _id_onCreate = jniAccessors.getMethodIDOf(
      _classRef, "onCreate", "(Landroid/os/Bundle;)V");

  /// from: public void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreate,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onGetLayoutInflater = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetLayoutInflater",
      "(Landroid/os/Bundle;)Landroid/view/LayoutInflater;");

  /// from: public android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  layoutinflater_.LayoutInflater onGetLayoutInflater(
          bundle_.Bundle savedInstanceState) =>
      layoutinflater_.LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetLayoutInflater,
          jni.JniType.objectType,
          [savedInstanceState.reference]).object);

  static final _id_onCreateDialog = jniAccessors.getMethodIDOf(
      _classRef, "onCreateDialog", "(Landroid/os/Bundle;)Landroid/app/Dialog;");

  /// from: public android.app.Dialog onCreateDialog(android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override to build your own custom Dialog container.  This is typically
  /// used to show an AlertDialog instead of a generic Dialog; when doing so,
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle) does not need
  /// to be implemented since the AlertDialog takes care of its own content.
  ///
  /// This method will be called after \#onCreate(Bundle) and
  /// before \#onCreateView(LayoutInflater, ViewGroup, Bundle).  The
  /// default implementation simply instantiates and returns a Dialog
  /// class.
  ///
  /// _Note: DialogFragment own the Dialog\#setOnCancelListener Dialog.setOnCancelListener and Dialog\#setOnDismissListener Dialog.setOnDismissListener callbacks.  You must not set them yourself._
  /// To find out about these events, override \#onCancel(DialogInterface)
  /// and \#onDismiss(DialogInterface).
  ///
  ///@param savedInstanceState The last saved instance state of the Fragment,
  /// or null if this is a freshly created Fragment.
  ///@return Return a new Dialog instance to be displayed by the Fragment.
  dialog_.Dialog onCreateDialog(bundle_.Bundle savedInstanceState) =>
      dialog_.Dialog.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateDialog,
          jni.JniType.objectType,
          [savedInstanceState.reference]).object);

  static final _id_onCancel = jniAccessors.getMethodIDOf(
      _classRef, "onCancel", "(Landroid/content/DialogInterface;)V");

  /// from: public void onCancel(android.content.DialogInterface dialog)
  void onCancel(dialoginterface_.DialogInterface dialog) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCancel,
          jni.JniType.voidType, [dialog.reference]).check();

  static final _id_onDismiss = jniAccessors.getMethodIDOf(
      _classRef, "onDismiss", "(Landroid/content/DialogInterface;)V");

  /// from: public void onDismiss(android.content.DialogInterface dialog)
  void onDismiss(dialoginterface_.DialogInterface dialog) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDismiss,
          jni.JniType.voidType, [dialog.reference]).check();

  static final _id_onActivityCreated = jniAccessors.getMethodIDOf(
      _classRef, "onActivityCreated", "(Landroid/os/Bundle;)V");

  /// from: public void onActivityCreated(android.os.Bundle savedInstanceState)
  void onActivityCreated(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActivityCreated,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onStart =
      jniAccessors.getMethodIDOf(_classRef, "onStart", "()V");

  /// from: public void onStart()
  void onStart() => jniAccessors.callMethodWithArgs(
      reference, _id_onStart, jni.JniType.voidType, []).check();

  static final _id_onSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "(Landroid/os/Bundle;)V");

  /// from: public void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(bundle_.Bundle outState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSaveInstanceState,
          jni.JniType.voidType, [outState.reference]).check();

  static final _id_onStop =
      jniAccessors.getMethodIDOf(_classRef, "onStop", "()V");

  /// from: public void onStop()
  void onStop() => jniAccessors.callMethodWithArgs(
      reference, _id_onStop, jni.JniType.voidType, []).check();

  static final _id_onDestroyView =
      jniAccessors.getMethodIDOf(_classRef, "onDestroyView", "()V");

  /// from: public void onDestroyView()
  ///
  /// Remove dialog.
  void onDestroyView() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroyView, jni.JniType.voidType, []).check();

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();
}
