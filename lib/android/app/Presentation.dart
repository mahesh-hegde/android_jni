// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Dialog.dart" as dialog_;

import "../content/Context.dart" as context_;

import "../view/Display.dart" as display_;

import "../content/res/Resources.dart" as resources_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.Presentation
///
/// Base class for presentations.
///
/// A presentation is a special kind of dialog whose purpose is to present
/// content on a secondary display.  A Presentation is associated with
/// the target Display at creation time and configures its context and
/// resource configuration according to the display's metrics.
///
///
/// Notably, the Context of a presentation is different from the context
/// of its containing Activity.  It is important to inflate the layout
/// of a presentation and load other resources using the presentation's own context
/// to ensure that assets of the correct size and density for the target display
/// are loaded.
///
///
/// A presentation is automatically canceled (see Dialog\#cancel()) when
/// the display to which it is attached is removed.  An activity should take
/// care of pausing and resuming whatever content is playing within the presentation
/// whenever the activity itself is paused or resumed.
///
///
///
/// <h3>Choosing a presentation display</h3>
///
/// Before showing a Presentation it's important to choose the Display
/// on which it will appear.  Choosing a presentation display is sometimes difficult
/// because there may be multiple displays attached.  Rather than trying to guess
/// which display is best, an application should let the system choose a suitable
/// presentation display.
///
///
/// There are two main ways to choose a Display.
///
///
///
/// <h4>Using the media router to choose a presentation display</h4>
///
/// The easiest way to choose a presentation display is to use the
/// android.media.MediaRouter MediaRouter API.  The media router service keeps
/// track of which audio and video routes are available on the system.
/// The media router sends notifications whenever routes are selected or unselected
/// or when the preferred presentation display of a route changes.
/// So an application can simply watch for these notifications and show or dismiss
/// a presentation on the preferred presentation display automatically.
///
///
/// The preferred presentation display is the display that the media router recommends
/// that the application should use if it wants to show content on the secondary display.
/// Sometimes there may not be a preferred presentation display in which
/// case the application should show its content locally without using a presentation.
///
///
/// Here's how to use the media router to create and show a presentation on the preferred
/// presentation display using android.media.MediaRouter.RouteInfo\#getPresentationDisplay().
///
///
/// <pre>
/// MediaRouter mediaRouter = (MediaRouter) context.getSystemService(Context.MEDIA_ROUTER_SERVICE);
/// MediaRouter.RouteInfo route = mediaRouter.getSelectedRoute();
/// if (route != null) {
///     Display presentationDisplay = route.getPresentationDisplay();
///     if (presentationDisplay != null) {
///         Presentation presentation = new MyPresentation(context, presentationDisplay);
///         presentation.show();
///     }
/// }</pre>
///
/// The following sample code from <code>ApiDemos</code> demonstrates how to use the media
/// router to automatically switch between showing content in the main activity and showing
/// the content in a presentation when a presentation display is available.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/PresentationWithMediaRouterActivity.java
///      activity}
///
/// <h4>Using the display manager to choose a presentation display</h4>
///
/// Another way to choose a presentation display is to use the DisplayManager API
/// directly.  The display manager service provides functions to enumerate and describe all
/// displays that are attached to the system including displays that may be used
/// for presentations.
///
///
/// The display manager keeps track of all displays in the system.  However, not all
/// displays are appropriate for showing presentations.  For example, if an activity
/// attempted to show a presentation on the main display it might obscure its own content
/// (it's like opening a dialog on top of your activity).
///
///
/// Here's how to identify suitable displays for showing presentations using
/// DisplayManager\#getDisplays(String) and the
/// DisplayManager\#DISPLAY_CATEGORY_PRESENTATION category.
///
///
/// <pre>
/// DisplayManager displayManager = (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
/// Display[] presentationDisplays = displayManager.getDisplays(DisplayManager.DISPLAY_CATEGORY_PRESENTATION);
/// if (presentationDisplays.length > 0) {
///     // If there is more than one suitable presentation display, then we could consider
///     // giving the user a choice.  For this example, we simply choose the first display
///     // which is the one the system recommends as the preferred presentation display.
///     Display display = presentationDisplays[0];
///     Presentation presentation = new MyPresentation(context, presentationDisplay);
///     presentation.show();
/// }</pre>
///
/// The following sample code from <code>ApiDemos</code> demonstrates how to use the display
/// manager to enumerate displays and show content on multiple presentation displays
/// simultaneously.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/PresentationActivity.java
///      activity}
///@see android.media.MediaRouter\#ROUTE_TYPE_LIVE_VIDEO for information on about live
/// video routes and how to obtain the preferred presentation display for the
/// current media route.
///@see DisplayManager for information on how to enumerate displays and receive
/// notifications when displays are added or removed.
class Presentation extends dialog_.Dialog {
  static final _classRef = jniAccessors.getClassOf("android/app/Presentation");
  Presentation.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/Display;)V");

  /// from: public void <init>(android.content.Context outerContext, android.view.Display display)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new presentation that is attached to the specified display
  /// using the default theme.
  ///@param outerContext The context of the application that is showing the presentation.
  /// The presentation will create its own context (see \#getContext()) based
  /// on this context and information about the associated display.
  ///@param display The display to which the presentation should be attached.
  Presentation.ctor3(context_.Context outerContext, display_.Display display)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3,
            [outerContext.reference, display.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/view/Display;I)V");

  /// from: public void <init>(android.content.Context outerContext, android.view.Display display, int theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new presentation that is attached to the specified display
  /// using the optionally specified theme.
  ///@param outerContext The context of the application that is showing the presentation.
  /// The presentation will create its own context (see \#getContext()) based
  /// on this context and information about the associated display.
  ///@param display The display to which the presentation should be attached.
  ///@param theme A style resource describing the theme to use for the window.
  /// See <a href="{@docRoot}guide/topics/resources/available-resources.html\#stylesandthemes">
  /// Style and Theme Resources</a> for more information about defining and using
  /// styles.  This theme is applied on top of the current theme in
  /// <var>outerContext</var>.  If 0, the default presentation theme will be used.
  Presentation.ctor4(
      context_.Context outerContext, display_.Display display, int theme)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor4,
            [outerContext.reference, display.reference, theme]).object);

  static final _id_getDisplay = jniAccessors.getMethodIDOf(
      _classRef, "getDisplay", "()Landroid/view/Display;");

  /// from: public android.view.Display getDisplay()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Display that this presentation appears on.
  ///@return The display.
  display_.Display getDisplay() =>
      display_.Display.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDisplay, jni.JniType.objectType, []).object);

  static final _id_getResources = jniAccessors.getMethodIDOf(
      _classRef, "getResources", "()Landroid/content/res/Resources;");

  /// from: public android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Resources that should be used to inflate the layout of this presentation.
  /// This resources object has been configured according to the metrics of the
  /// display that the presentation appears on.
  ///@return The presentation resources object.
  resources_.Resources getResources() =>
      resources_.Resources.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getResources, jni.JniType.objectType, []).object);

  static final _id_onStart =
      jniAccessors.getMethodIDOf(_classRef, "onStart", "()V");

  /// from: protected void onStart()
  void onStart() => jniAccessors.callMethodWithArgs(
      reference, _id_onStart, jni.JniType.voidType, []).check();

  static final _id_onStop =
      jniAccessors.getMethodIDOf(_classRef, "onStop", "()V");

  /// from: protected void onStop()
  void onStop() => jniAccessors.callMethodWithArgs(
      reference, _id_onStop, jni.JniType.voidType, []).check();

  static final _id_show0 = jniAccessors.getMethodIDOf(_classRef, "show", "()V");

  /// from: public void show()
  ///
  /// Inherited from Dialog\#show. Will throw
  /// android.view.WindowManager.InvalidDisplayException if the specified secondary
  /// Display can't be found.
  void show0() => jniAccessors.callMethodWithArgs(
      reference, _id_show0, jni.JniType.voidType, []).check();

  static final _id_onDisplayRemoved =
      jniAccessors.getMethodIDOf(_classRef, "onDisplayRemoved", "()V");

  /// from: public void onDisplayRemoved()
  ///
  /// Called by the system when the Display to which the presentation
  /// is attached has been removed.
  ///
  /// The system automatically calls \#cancel to dismiss the presentation
  /// after sending this event.
  ///@see \#getDisplay
  void onDisplayRemoved() => jniAccessors.callMethodWithArgs(
      reference, _id_onDisplayRemoved, jni.JniType.voidType, []).check();

  static final _id_onDisplayChanged =
      jniAccessors.getMethodIDOf(_classRef, "onDisplayChanged", "()V");

  /// from: public void onDisplayChanged()
  ///
  /// Called by the system when the properties of the Display to which
  /// the presentation is attached have changed.
  ///
  /// If the display metrics have changed (for example, if the display has been
  /// resized or rotated), then the system automatically calls
  /// \#cancel to dismiss the presentation.
  ///@see \#getDisplay
  void onDisplayChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_onDisplayChanged, jni.JniType.voidType, []).check();
}
