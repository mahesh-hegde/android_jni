// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../database/Cursor.dart" as cursor_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;

import "../net/Uri.dart" as uri_;

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.DownloadManager
///
/// The download manager is a system service that handles long-running HTTP downloads. Clients may
/// request that a URI be downloaded to a particular destination file. The download manager will
/// conduct the download in the background, taking care of HTTP interactions and retrying downloads
/// after failures or across connectivity changes and system reboots.
///
/// Apps that request downloads through this API should register a broadcast receiver for
/// \#ACTION_NOTIFICATION_CLICKED to appropriately handle when the user clicks on a running
/// download in a notification or from the downloads UI.
///
/// Note that the application must have the android.Manifest.permission\#INTERNET
/// permission to use this class.
class DownloadManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/DownloadManager");
  DownloadManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_DOWNLOAD_COMPLETE
  ///
  /// Broadcast intent action sent by the download manager when a download completes.
  static const ACTION_DOWNLOAD_COMPLETE =
      "android.intent.action.DOWNLOAD_COMPLETE";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CLICKED
  ///
  /// Broadcast intent action sent by the download manager when the user clicks on a running
  /// download, either from a system notification or from the downloads UI.
  static const ACTION_NOTIFICATION_CLICKED =
      "android.intent.action.DOWNLOAD_NOTIFICATION_CLICKED";

  /// from: static public final java.lang.String ACTION_VIEW_DOWNLOADS
  ///
  /// Intent action to launch an activity to display all downloads.
  static const ACTION_VIEW_DOWNLOADS = "android.intent.action.VIEW_DOWNLOADS";

  /// from: static public final java.lang.String COLUMN_BYTES_DOWNLOADED_SO_FAR
  ///
  /// Number of bytes download so far.
  static const COLUMN_BYTES_DOWNLOADED_SO_FAR = "bytes_so_far";

  /// from: static public final java.lang.String COLUMN_DESCRIPTION
  ///
  /// The client-supplied description of this download.  This will be displayed in system
  /// notifications.  Defaults to the empty string.
  static const COLUMN_DESCRIPTION = "description";

  /// from: static public final java.lang.String COLUMN_ID
  ///
  /// An identifier for a particular download, unique across the system.  Clients use this ID to
  /// make subsequent calls related to the download.
  static const COLUMN_ID = "_id";

  /// from: static public final java.lang.String COLUMN_LAST_MODIFIED_TIMESTAMP
  ///
  /// Timestamp when the download was last modified, in System\#currentTimeMillis System.currentTimeMillis() (wall clock time in UTC).
  static const COLUMN_LAST_MODIFIED_TIMESTAMP = "last_modified_timestamp";

  /// from: static public final java.lang.String COLUMN_LOCAL_FILENAME
  ///
  /// Path to the downloaded file on disk.
  ///
  /// Note that apps may not have filesystem permissions to directly access
  /// this path. Instead of trying to open this path directly, apps should use
  /// ContentResolver\#openFileDescriptor(Uri, String) to gain access.
  ///@deprecated apps should transition to using
  ///             ContentResolver\#openFileDescriptor(Uri, String)
  ///             instead.
  static const COLUMN_LOCAL_FILENAME = "local_filename";

  /// from: static public final java.lang.String COLUMN_LOCAL_URI
  ///
  /// Uri where downloaded file will be stored.  If a destination is supplied by client, that URI
  /// will be used here.  Otherwise, the value will initially be null and will be filled in with a
  /// generated URI once the download has started.
  static const COLUMN_LOCAL_URI = "local_uri";

  /// from: static public final java.lang.String COLUMN_MEDIAPROVIDER_URI
  ///
  /// The URI to the corresponding entry in MediaProvider for this downloaded entry. It is
  /// used to delete the entries from MediaProvider database when it is deleted from the
  /// downloaded list.
  static const COLUMN_MEDIAPROVIDER_URI = "mediaprovider_uri";

  /// from: static public final java.lang.String COLUMN_MEDIA_TYPE
  ///
  /// Internet Media Type of the downloaded file.  If no value is provided upon creation, this will
  /// initially be null and will be filled in based on the server's response once the download has
  /// started.
  ///@see <a href="http://www.ietf.org/rfc/rfc1590.txt">RFC 1590, defining Media Types</a>
  static const COLUMN_MEDIA_TYPE = "media_type";

  /// from: static public final java.lang.String COLUMN_REASON
  ///
  /// Provides more detail on the status of the download.  Its meaning depends on the value of
  /// \#COLUMN_STATUS.
  ///
  /// When \#COLUMN_STATUS is \#STATUS_FAILED, this indicates the type of error that
  /// occurred.  If an HTTP error occurred, this will hold the HTTP status code as defined in RFC
  /// 2616.  Otherwise, it will hold one of the ERROR_* constants.
  ///
  /// When \#COLUMN_STATUS is \#STATUS_PAUSED, this indicates why the download is
  /// paused.  It will hold one of the PAUSED_* constants.
  ///
  /// If \#COLUMN_STATUS is neither \#STATUS_FAILED nor \#STATUS_PAUSED, this
  /// column's value is undefined.
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html\#sec6.1.1">RFC 2616
  /// status codes</a>
  static const COLUMN_REASON = "reason";

  /// from: static public final java.lang.String COLUMN_STATUS
  ///
  /// Current status of the download, as one of the STATUS_* constants.
  static const COLUMN_STATUS = "status";

  /// from: static public final java.lang.String COLUMN_TITLE
  ///
  /// The client-supplied title for this download.  This will be displayed in system notifications.
  /// Defaults to the empty string.
  static const COLUMN_TITLE = "title";

  /// from: static public final java.lang.String COLUMN_TOTAL_SIZE_BYTES
  ///
  /// Total size of the download in bytes.  This will initially be -1 and will be filled in once
  /// the download starts.
  static const COLUMN_TOTAL_SIZE_BYTES = "total_size";

  /// from: static public final java.lang.String COLUMN_URI
  ///
  /// URI to be downloaded.
  static const COLUMN_URI = "uri";

  /// from: static public final int ERROR_CANNOT_RESUME
  ///
  /// Value of \#COLUMN_REASON when some possibly transient error occurred but we can't
  /// resume the download.
  static const ERROR_CANNOT_RESUME = 1008;

  /// from: static public final int ERROR_DEVICE_NOT_FOUND
  ///
  /// Value of \#COLUMN_REASON when no external storage device was found. Typically,
  /// this is because the SD card is not mounted.
  static const ERROR_DEVICE_NOT_FOUND = 1007;

  /// from: static public final int ERROR_FILE_ALREADY_EXISTS
  ///
  /// Value of \#COLUMN_REASON when the requested destination file already exists (the
  /// download manager will not overwrite an existing file).
  static const ERROR_FILE_ALREADY_EXISTS = 1009;

  /// from: static public final int ERROR_FILE_ERROR
  ///
  /// Value of \#COLUMN_REASON when a storage issue arises which doesn't fit under any
  /// other error code. Use the more specific \#ERROR_INSUFFICIENT_SPACE and
  /// \#ERROR_DEVICE_NOT_FOUND when appropriate.
  static const ERROR_FILE_ERROR = 1001;

  /// from: static public final int ERROR_HTTP_DATA_ERROR
  ///
  /// Value of \#COLUMN_REASON when an error receiving or processing data occurred at
  /// the HTTP level.
  static const ERROR_HTTP_DATA_ERROR = 1004;

  /// from: static public final int ERROR_INSUFFICIENT_SPACE
  ///
  /// Value of \#COLUMN_REASON when there was insufficient storage space. Typically,
  /// this is because the SD card is full.
  static const ERROR_INSUFFICIENT_SPACE = 1006;

  /// from: static public final int ERROR_TOO_MANY_REDIRECTS
  ///
  /// Value of \#COLUMN_REASON when there were too many redirects.
  static const ERROR_TOO_MANY_REDIRECTS = 1005;

  /// from: static public final int ERROR_UNHANDLED_HTTP_CODE
  ///
  /// Value of \#COLUMN_REASON when an HTTP code was received that download manager
  /// can't handle.
  static const ERROR_UNHANDLED_HTTP_CODE = 1002;

  /// from: static public final int ERROR_UNKNOWN
  ///
  /// Value of COLUMN_ERROR_CODE when the download has completed with an error that doesn't fit
  /// under any other error code.
  static const ERROR_UNKNOWN = 1000;

  /// from: static public final java.lang.String EXTRA_DOWNLOAD_ID
  ///
  /// Intent extra included with \#ACTION_DOWNLOAD_COMPLETE intents, indicating the ID (as a
  /// long) of the download that just completed.
  static const EXTRA_DOWNLOAD_ID = "extra_download_id";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS
  ///
  /// When clicks on multiple notifications are received, the following
  /// provides an array of download ids corresponding to the download notification that was
  /// clicked. It can be retrieved by the receiver of this
  /// Intent using android.content.Intent\#getLongArrayExtra(String).
  static const EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS =
      "extra_click_download_ids";

  /// from: static public final java.lang.String INTENT_EXTRAS_SORT_BY_SIZE
  ///
  /// Intent extra included with \#ACTION_VIEW_DOWNLOADS to start DownloadApp in
  /// sort-by-size mode.
  static const INTENT_EXTRAS_SORT_BY_SIZE =
      "android.app.DownloadManager.extra_sortBySize";

  /// from: static public final int PAUSED_QUEUED_FOR_WIFI
  ///
  /// Value of \#COLUMN_REASON when the download exceeds a size limit for downloads over
  /// the mobile network and the download manager is waiting for a Wi-Fi connection to proceed.
  static const PAUSED_QUEUED_FOR_WIFI = 3;

  /// from: static public final int PAUSED_UNKNOWN
  ///
  /// Value of \#COLUMN_REASON when the download is paused for some other reason.
  static const PAUSED_UNKNOWN = 4;

  /// from: static public final int PAUSED_WAITING_FOR_NETWORK
  ///
  /// Value of \#COLUMN_REASON when the download is waiting for network connectivity to
  /// proceed.
  static const PAUSED_WAITING_FOR_NETWORK = 2;

  /// from: static public final int PAUSED_WAITING_TO_RETRY
  ///
  /// Value of \#COLUMN_REASON when the download is paused because some network error
  /// occurred and the download manager is waiting before retrying the request.
  static const PAUSED_WAITING_TO_RETRY = 1;

  /// from: static public final int STATUS_FAILED
  ///
  /// Value of \#COLUMN_STATUS when the download has failed (and will not be retried).
  static const STATUS_FAILED = 16;

  /// from: static public final int STATUS_PAUSED
  ///
  /// Value of \#COLUMN_STATUS when the download is waiting to retry or resume.
  static const STATUS_PAUSED = 4;

  /// from: static public final int STATUS_PENDING
  ///
  /// Value of \#COLUMN_STATUS when the download is waiting to start.
  static const STATUS_PENDING = 1;

  /// from: static public final int STATUS_RUNNING
  ///
  /// Value of \#COLUMN_STATUS when the download is currently running.
  static const STATUS_RUNNING = 2;

  /// from: static public final int STATUS_SUCCESSFUL
  ///
  /// Value of \#COLUMN_STATUS when the download has successfully completed.
  static const STATUS_SUCCESSFUL = 8;

  static final _id_enqueue = jniAccessors.getMethodIDOf(
      _classRef, "enqueue", "(Landroid/app/DownloadManager\$Request;)J");

  /// from: public long enqueue(android.app.DownloadManager.Request request)
  ///
  /// Enqueue a new download.  The download will start automatically once the download manager is
  /// ready to execute it and connectivity is available.
  ///@param request the parameters specifying this download
  ///@return an ID for the download, unique across the system.  This ID is used to make future
  /// calls related to this download.
  int enqueue(DownloadManager_Request request) =>
      jniAccessors.callMethodWithArgs(reference, _id_enqueue,
          jni.JniType.longType, [request.reference]).long;

  static final _id_remove =
      jniAccessors.getMethodIDOf(_classRef, "remove", "([J)I");

  /// from: public int remove(long[] ids)
  ///
  /// Cancel downloads and remove them from the download manager.  Each download will be stopped if
  /// it was running, and it will no longer be accessible through the download manager.
  /// If there is a downloaded file, partial or complete, it is deleted.
  ///@param ids the IDs of the downloads to remove
  ///@return the number of downloads actually removed
  int remove(jni.JniObject ids) => jniAccessors.callMethodWithArgs(
      reference, _id_remove, jni.JniType.intType, [ids.reference]).integer;

  static final _id_query = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/app/DownloadManager\$Query;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(android.app.DownloadManager.Query query)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the download manager about downloads that have been requested.
  ///@param query parameters specifying filters for this query
  ///@return a Cursor over the result set of downloads, with columns consisting of all the
  /// COLUMN_* constants.
  cursor_.Cursor query(DownloadManager_Query query) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_query, jni.JniType.objectType, [query.reference]).object);

  static final _id_openDownloadedFile = jniAccessors.getMethodIDOf(
      _classRef, "openDownloadedFile", "(J)Landroid/os/ParcelFileDescriptor;");

  /// from: public android.os.ParcelFileDescriptor openDownloadedFile(long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a downloaded file for reading.  The download must have completed.
  ///@param id the ID of the download
  ///@return a read-only ParcelFileDescriptor
  ///@throws FileNotFoundException if the destination file does not already exist
  parcelfiledescriptor_.ParcelFileDescriptor openDownloadedFile(int id) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openDownloadedFile,
              jni.JniType.objectType, [id]).object);

  static final _id_getUriForDownloadedFile = jniAccessors.getMethodIDOf(
      _classRef, "getUriForDownloadedFile", "(J)Landroid/net/Uri;");

  /// from: public android.net.Uri getUriForDownloadedFile(long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Uri of the given downloaded file id, if the file is
  /// downloaded successfully. Otherwise, null is returned.
  ///@param id the id of the downloaded file.
  ///@return the Uri of the given downloaded file id, if download was
  ///         successful. null otherwise.
  uri_.Uri getUriForDownloadedFile(int id) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getUriForDownloadedFile, jni.JniType.objectType, [id]).object);

  static final _id_getMimeTypeForDownloadedFile = jniAccessors.getMethodIDOf(
      _classRef, "getMimeTypeForDownloadedFile", "(J)Ljava/lang/String;");

  /// from: public java.lang.String getMimeTypeForDownloadedFile(long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the media type of the given downloaded file id, if the file was
  /// downloaded successfully. Otherwise, null is returned.
  ///@param id the id of the downloaded file.
  ///@return the media type of the given downloaded file id, if download was successful. null
  /// otherwise.
  jni.JniString getMimeTypeForDownloadedFile(int id) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getMimeTypeForDownloadedFile,
          jni.JniType.objectType,
          [id]).object);

  static final _id_getMaxBytesOverMobile = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getMaxBytesOverMobile",
      "(Landroid/content/Context;)Ljava/lang/Long;");

  /// from: static public java.lang.Long getMaxBytesOverMobile(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns maximum size, in bytes, of downloads that may go over a mobile connection; or null if
  /// there's no limit
  ///@param context the Context to use for accessing the ContentResolver
  ///@return maximum size, in bytes, of downloads that may go over a mobile connection; or null if
  /// there's no limit
  static jni.JniObject getMaxBytesOverMobile(context_.Context context) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getMaxBytesOverMobile,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_getRecommendedMaxBytesOverMobile =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "getRecommendedMaxBytesOverMobile",
          "(Landroid/content/Context;)Ljava/lang/Long;");

  /// from: static public java.lang.Long getRecommendedMaxBytesOverMobile(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns recommended maximum size, in bytes, of downloads that may go over a mobile
  /// connection; or null if there's no recommended limit.  The user will have the option to bypass
  /// this limit.
  ///@param context the Context to use for accessing the ContentResolver
  ///@return recommended maximum size, in bytes, of downloads that may go over a mobile
  /// connection; or null if there's no recommended limit.
  static jni.JniObject getRecommendedMaxBytesOverMobile(
          context_.Context context) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRecommendedMaxBytesOverMobile,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_addCompletedDownload = jniAccessors.getMethodIDOf(
      _classRef,
      "addCompletedDownload",
      "(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;JZ)J");

  /// from: public long addCompletedDownload(java.lang.String title, java.lang.String description, boolean isMediaScannerScannable, java.lang.String mimeType, java.lang.String path, long length, boolean showNotification)
  ///
  /// Adds a file to the downloads database system, so it could appear in Downloads App
  /// (and thus become eligible for management by the Downloads App).
  ///
  /// It is helpful to make the file scannable by MediaScanner by setting the param
  /// isMediaScannerScannable to true. It makes the file visible in media managing
  /// applications such as Gallery App, which could be a useful purpose of using this API.
  ///@param title the title that would appear for this file in Downloads App.
  ///@param description the description that would appear for this file in Downloads App.
  ///@param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
  /// scanned by MediaScanner appear in the applications used to view media (for example,
  /// Gallery app).
  ///@param mimeType mimetype of the file.
  ///@param path absolute pathname to the file. The file should be world-readable, so that it can
  /// be managed by the Downloads App and any other app that is used to read it (for example,
  /// Gallery app to display the file, if the file contents represent a video/image).
  ///@param length length of the downloaded file
  ///@param showNotification true if a notification is to be sent, false otherwise
  ///@return an ID for the download entry added to the downloads app, unique across the system
  /// This ID is used to make future calls related to this download.
  int addCompletedDownload(
          jni.JniString title,
          jni.JniString description,
          bool isMediaScannerScannable,
          jni.JniString mimeType,
          jni.JniString path,
          int length,
          bool showNotification) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_addCompletedDownload, jni.JniType.longType, [
        title.reference,
        description.reference,
        isMediaScannerScannable,
        mimeType.reference,
        path.reference,
        length,
        showNotification
      ]).long;

  static final _id_addCompletedDownload1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addCompletedDownload",
      "(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;JZLandroid/net/Uri;Landroid/net/Uri;)J");

  /// from: public long addCompletedDownload(java.lang.String title, java.lang.String description, boolean isMediaScannerScannable, java.lang.String mimeType, java.lang.String path, long length, boolean showNotification, android.net.Uri uri, android.net.Uri referer)
  ///
  /// Adds a file to the downloads database system, so it could appear in Downloads App
  /// (and thus become eligible for management by the Downloads App).
  ///
  /// It is helpful to make the file scannable by MediaScanner by setting the param
  /// isMediaScannerScannable to true. It makes the file visible in media managing
  /// applications such as Gallery App, which could be a useful purpose of using this API.
  ///@param title the title that would appear for this file in Downloads App.
  ///@param description the description that would appear for this file in Downloads App.
  ///@param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
  /// scanned by MediaScanner appear in the applications used to view media (for example,
  /// Gallery app).
  ///@param mimeType mimetype of the file.
  ///@param path absolute pathname to the file. The file should be world-readable, so that it can
  /// be managed by the Downloads App and any other app that is used to read it (for example,
  /// Gallery app to display the file, if the file contents represent a video/image).
  ///@param length length of the downloaded file
  ///@param showNotification true if a notification is to be sent, false otherwise
  ///@param uri the original HTTP URI of the download
  ///@param referer the HTTP Referer for the download
  ///@return an ID for the download entry added to the downloads app, unique across the system
  /// This ID is used to make future calls related to this download.
  int addCompletedDownload1(
          jni.JniString title,
          jni.JniString description,
          bool isMediaScannerScannable,
          jni.JniString mimeType,
          jni.JniString path,
          int length,
          bool showNotification,
          uri_.Uri uri,
          uri_.Uri referer) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_addCompletedDownload1, jni.JniType.longType, [
        title.reference,
        description.reference,
        isMediaScannerScannable,
        mimeType.reference,
        path.reference,
        length,
        showNotification,
        uri.reference,
        referer.reference
      ]).long;
}

/// from: android.app.DownloadManager$Request
///
/// This class contains all the information necessary to request a new download. The URI is the
/// only required parameter.
///
/// Note that the default download destination is a shared volume where the system might delete
/// your file if it needs to reclaim space for system use. If this is a problem, use a location
/// on external storage (see \#setDestinationUri(Uri).
class DownloadManager_Request extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/DownloadManager\$Request");
  DownloadManager_Request.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int NETWORK_MOBILE
  ///
  /// Bit flag for \#setAllowedNetworkTypes corresponding to
  /// ConnectivityManager\#TYPE_MOBILE.
  static const NETWORK_MOBILE = 1;

  /// from: static public final int NETWORK_WIFI
  ///
  /// Bit flag for \#setAllowedNetworkTypes corresponding to
  /// ConnectivityManager\#TYPE_WIFI.
  static const NETWORK_WIFI = 2;

  /// from: static public final int VISIBILITY_HIDDEN
  ///
  /// This download doesn't show in the UI or in the notifications.
  static const VISIBILITY_HIDDEN = 2;

  /// from: static public final int VISIBILITY_VISIBLE
  ///
  /// This download is visible but only shows in the notifications
  /// while it's in progress.
  static const VISIBILITY_VISIBLE = 0;

  /// from: static public final int VISIBILITY_VISIBLE_NOTIFY_COMPLETED
  ///
  /// This download is visible and shows in the notifications while
  /// in progress and after completion.
  static const VISIBILITY_VISIBLE_NOTIFY_COMPLETED = 1;

  /// from: static public final int VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION
  ///
  /// This download shows in the notifications after completion ONLY.
  /// It is usuable only with
  /// DownloadManager\#addCompletedDownload(String, String,
  /// boolean, String, String, long, boolean).
  static const VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION = 3;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/net/Uri;)V");

  /// from: public void <init>(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param uri the HTTP or HTTPS URI to download.
  DownloadManager_Request(uri_.Uri uri)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [uri.reference]).object);

  static final _id_setDestinationUri = jniAccessors.getMethodIDOf(
      _classRef,
      "setDestinationUri",
      "(Landroid/net/Uri;)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setDestinationUri(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the local destination for the downloaded file. Must be a file URI to a path on
  /// external storage, and the calling application must have the WRITE_EXTERNAL_STORAGE
  /// permission.
  ///
  /// The downloaded file is not scanned by MediaScanner.
  /// But it can be made scannable by calling \#allowScanningByMediaScanner().
  ///
  /// By default, downloads are saved to a generated filename in the shared download cache and
  /// may be deleted by the system at any time to reclaim space.
  ///@return this object
  DownloadManager_Request setDestinationUri(uri_.Uri uri) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDestinationUri,
          jni.JniType.objectType,
          [uri.reference]).object);

  static final _id_setDestinationInExternalFilesDir = jniAccessors.getMethodIDOf(
      _classRef,
      "setDestinationInExternalFilesDir",
      "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setDestinationInExternalFilesDir(android.content.Context context, java.lang.String dirType, java.lang.String subPath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the local destination for the downloaded file to a path within
  /// the application's external files directory (as returned by
  /// Context\#getExternalFilesDir(String).
  ///
  /// The downloaded file is not scanned by MediaScanner. But it can be
  /// made scannable by calling \#allowScanningByMediaScanner().
  ///@param context the Context to use in determining the external
  ///            files directory
  ///@param dirType the directory type to pass to
  ///            Context\#getExternalFilesDir(String)
  ///@param subPath the path within the external directory, including the
  ///            destination filename
  ///@return this object
  ///@throws IllegalStateException If the external storage directory
  ///             cannot be found or created.
  DownloadManager_Request setDestinationInExternalFilesDir(
          context_.Context context,
          jni.JniString dirType,
          jni.JniString subPath) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDestinationInExternalFilesDir,
          jni.JniType.objectType,
          [context.reference, dirType.reference, subPath.reference]).object);

  static final _id_setDestinationInExternalPublicDir = jniAccessors.getMethodIDOf(
      _classRef,
      "setDestinationInExternalPublicDir",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setDestinationInExternalPublicDir(java.lang.String dirType, java.lang.String subPath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the local destination for the downloaded file to a path within
  /// the public external storage directory (as returned by
  /// Environment\#getExternalStoragePublicDirectory(String)).
  ///
  /// The downloaded file is not scanned by MediaScanner. But it can be
  /// made scannable by calling \#allowScanningByMediaScanner().
  ///@param dirType the directory type to pass to Environment\#getExternalStoragePublicDirectory(String)
  ///@param subPath the path within the external directory, including the
  ///            destination filename
  ///@return this object
  ///@throws IllegalStateException If the external storage directory
  ///             cannot be found or created.
  DownloadManager_Request setDestinationInExternalPublicDir(
          jni.JniString dirType, jni.JniString subPath) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDestinationInExternalPublicDir,
          jni.JniType.objectType,
          [dirType.reference, subPath.reference]).object);

  static final _id_allowScanningByMediaScanner = jniAccessors.getMethodIDOf(
      _classRef, "allowScanningByMediaScanner", "()V");

  /// from: public void allowScanningByMediaScanner()
  ///
  /// If the file to be downloaded is to be scanned by MediaScanner, this method
  /// should be called before DownloadManager\#enqueue(Request) is called.
  void allowScanningByMediaScanner() => jniAccessors.callMethodWithArgs(
      reference,
      _id_allowScanningByMediaScanner,
      jni.JniType.voidType, []).check();

  static final _id_addRequestHeader = jniAccessors.getMethodIDOf(
      _classRef,
      "addRequestHeader",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request addRequestHeader(java.lang.String header, java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an HTTP header to be included with the download request.  The header will be added to
  /// the end of the list.
  ///@param header HTTP header name
  ///@param value header value
  ///@return this object
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\#sec4.2">HTTP/1.1
  ///      Message Headers</a>
  DownloadManager_Request addRequestHeader(
          jni.JniString header, jni.JniString value) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addRequestHeader,
          jni.JniType.objectType,
          [header.reference, value.reference]).object);

  static final _id_setTitle = jniAccessors.getMethodIDOf(_classRef, "setTitle",
      "(Ljava/lang/CharSequence;)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the title of this download, to be displayed in notifications (if enabled).  If no
  /// title is given, a default one will be assigned based on the download filename, once the
  /// download starts.
  ///@return this object
  DownloadManager_Request setTitle(jni.JniObject title) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setTitle, jni.JniType.objectType, [title.reference]).object);

  static final _id_setDescription = jniAccessors.getMethodIDOf(
      _classRef,
      "setDescription",
      "(Ljava/lang/CharSequence;)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setDescription(java.lang.CharSequence description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a description of this download, to be displayed in notifications (if enabled)
  ///@return this object
  DownloadManager_Request setDescription(jni.JniObject description) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDescription,
          jni.JniType.objectType,
          [description.reference]).object);

  static final _id_setMimeType = jniAccessors.getMethodIDOf(
      _classRef,
      "setMimeType",
      "(Ljava/lang/String;)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setMimeType(java.lang.String mimeType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the MIME content type of this download.  This will override the content type declared
  /// in the server's response.
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html\#sec3.7">HTTP/1.1
  ///      Media Types</a>
  ///@return this object
  DownloadManager_Request setMimeType(jni.JniString mimeType) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setMimeType,
          jni.JniType.objectType,
          [mimeType.reference]).object);

  static final _id_setShowRunningNotification = jniAccessors.getMethodIDOf(
      _classRef,
      "setShowRunningNotification",
      "(Z)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setShowRunningNotification(boolean show)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Control whether a system notification is posted by the download manager while this
  /// download is running. If enabled, the download manager posts notifications about downloads
  /// through the system android.app.NotificationManager. By default, a notification is
  /// shown.
  ///
  /// If set to false, this requires the permission
  /// android.permission.DOWNLOAD_WITHOUT_NOTIFICATION.
  ///@param show whether the download manager should show a notification for this download.
  ///@return this object
  ///@deprecated use \#setNotificationVisibility(int)
  DownloadManager_Request setShowRunningNotification(bool show0) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setShowRunningNotification,
          jni.JniType.objectType,
          [show0]).object);

  static final _id_setNotificationVisibility = jniAccessors.getMethodIDOf(
      _classRef,
      "setNotificationVisibility",
      "(I)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setNotificationVisibility(int visibility)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Control whether a system notification is posted by the download manager while this
  /// download is running or when it is completed.
  /// If enabled, the download manager posts notifications about downloads
  /// through the system android.app.NotificationManager.
  /// By default, a notification is shown only when the download is in progress.
  ///
  /// It can take the following values: \#VISIBILITY_HIDDEN,
  /// \#VISIBILITY_VISIBLE,
  /// \#VISIBILITY_VISIBLE_NOTIFY_COMPLETED.
  ///
  /// If set to \#VISIBILITY_HIDDEN, this requires the permission
  /// android.permission.DOWNLOAD_WITHOUT_NOTIFICATION.
  ///@param visibility the visibility setting value
  ///@return this object
  DownloadManager_Request setNotificationVisibility(int visibility) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setNotificationVisibility,
          jni.JniType.objectType,
          [visibility]).object);

  static final _id_setAllowedNetworkTypes = jniAccessors.getMethodIDOf(
      _classRef,
      "setAllowedNetworkTypes",
      "(I)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setAllowedNetworkTypes(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Restrict the types of networks over which this download may proceed.
  /// By default, all network types are allowed. Consider using
  /// \#setAllowedOverMetered(boolean) instead, since it's more
  /// flexible.
  ///
  /// As of android.os.Build.VERSION_CODES\#N, setting only the
  /// \#NETWORK_WIFI flag here is equivalent to calling
  /// \#setAllowedOverMetered(boolean) with {@code false}.
  ///@param flags any combination of the NETWORK_* bit flags.
  ///@return this object
  DownloadManager_Request setAllowedNetworkTypes(int flags) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setAllowedNetworkTypes, jni.JniType.objectType, [flags]).object);

  static final _id_setAllowedOverRoaming = jniAccessors.getMethodIDOf(_classRef,
      "setAllowedOverRoaming", "(Z)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setAllowedOverRoaming(boolean allowed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this download may proceed over a roaming connection.  By default, roaming is
  /// allowed.
  ///@param allowed whether to allow a roaming connection to be used
  ///@return this object
  DownloadManager_Request setAllowedOverRoaming(bool allowed) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setAllowedOverRoaming, jni.JniType.objectType, [allowed]).object);

  static final _id_setAllowedOverMetered = jniAccessors.getMethodIDOf(_classRef,
      "setAllowedOverMetered", "(Z)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setAllowedOverMetered(boolean allow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this download may proceed over a metered network
  /// connection. By default, metered networks are allowed.
  ///@see ConnectivityManager\#isActiveNetworkMetered()
  DownloadManager_Request setAllowedOverMetered(bool allow) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setAllowedOverMetered, jni.JniType.objectType, [allow]).object);

  static final _id_setRequiresCharging = jniAccessors.getMethodIDOf(_classRef,
      "setRequiresCharging", "(Z)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setRequiresCharging(boolean requiresCharging)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run this download, the device needs to be plugged in.
  /// This defaults to false.
  ///@param requiresCharging Whether or not the device is plugged in.
  ///@see android.app.job.JobInfo.Builder\#setRequiresCharging(boolean)
  DownloadManager_Request setRequiresCharging(bool requiresCharging) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiresCharging,
          jni.JniType.objectType,
          [requiresCharging]).object);

  static final _id_setRequiresDeviceIdle = jniAccessors.getMethodIDOf(_classRef,
      "setRequiresDeviceIdle", "(Z)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setRequiresDeviceIdle(boolean requiresDeviceIdle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run, the download needs the device to be in idle
  /// mode. This defaults to false.
  ///
  /// Idle mode is a loose definition provided by the system, which means
  /// that the device is not in use, and has not been in use for some time.
  ///@param requiresDeviceIdle Whether or not the device need be within an
  ///            idle maintenance window.
  ///@see android.app.job.JobInfo.Builder\#setRequiresDeviceIdle(boolean)
  DownloadManager_Request setRequiresDeviceIdle(bool requiresDeviceIdle) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRequiresDeviceIdle,
          jni.JniType.objectType,
          [requiresDeviceIdle]).object);

  static final _id_setVisibleInDownloadsUi = jniAccessors.getMethodIDOf(
      _classRef,
      "setVisibleInDownloadsUi",
      "(Z)Landroid/app/DownloadManager\$Request;");

  /// from: public android.app.DownloadManager.Request setVisibleInDownloadsUi(boolean isVisible)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this download should be displayed in the system's Downloads UI. True by
  /// default.
  ///@param isVisible whether to display this download in the Downloads UI
  ///@return this object
  DownloadManager_Request setVisibleInDownloadsUi(bool isVisible) =>
      DownloadManager_Request.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setVisibleInDownloadsUi,
          jni.JniType.objectType,
          [isVisible]).object);
}

/// from: android.app.DownloadManager$Query
///
/// This class may be used to filter download manager queries.
class DownloadManager_Query extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/DownloadManager\$Query");
  DownloadManager_Query.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DownloadManager_Query()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setFilterById = jniAccessors.getMethodIDOf(
      _classRef, "setFilterById", "([J)Landroid/app/DownloadManager\$Query;");

  /// from: public android.app.DownloadManager.Query setFilterById(long[] ids)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Include only the downloads with the given IDs.
  ///@return this object
  DownloadManager_Query setFilterById(jni.JniObject ids) =>
      DownloadManager_Query.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setFilterById, jni.JniType.objectType, [ids.reference]).object);

  static final _id_setFilterByStatus = jniAccessors.getMethodIDOf(_classRef,
      "setFilterByStatus", "(I)Landroid/app/DownloadManager\$Query;");

  /// from: public android.app.DownloadManager.Query setFilterByStatus(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Include only downloads with status matching any the given status flags.
  ///@param flags any combination of the STATUS_* bit flags
  ///@return this object
  DownloadManager_Query setFilterByStatus(int flags) =>
      DownloadManager_Query.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setFilterByStatus, jni.JniType.objectType, [flags]).object);
}
