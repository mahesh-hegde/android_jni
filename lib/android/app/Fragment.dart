// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../os/Bundle.dart" as bundle_;

import "Activity.dart" as activity_;

import "../content/res/Resources.dart" as resources_;

import "FragmentManager.dart" as fragmentmanager_;

import "LoaderManager.dart" as loadermanager_;

import "../content/Intent.dart" as intent_;

import "../content/IntentSender.dart" as intentsender_;

import "../view/LayoutInflater.dart" as layoutinflater_;

import "../util/AttributeSet.dart" as attributeset_;

import "../animation/Animator.dart" as animator_;

import "../view/View.dart" as view_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../content/res/Configuration.dart" as configuration_;

import "../view/Menu.dart" as menu_;

import "../view/MenuInflater.dart" as menuinflater_;

import "../view/MenuItem.dart" as menuitem_;

import "../view/ContextMenu.dart" as contextmenu_;

import "SharedElementCallback.dart" as sharedelementcallback_;

import "../transition/Transition.dart" as transition_;

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;

import "../util/AndroidRuntimeException.dart" as androidruntimeexception_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.app.Fragment
///
/// A Fragment is a piece of an application's user interface or behavior
/// that can be placed in an Activity.  Interaction with fragments
/// is done through FragmentManager, which can be obtained via
/// Activity\#getFragmentManager() Activity.getFragmentManager() and
/// Fragment\#getFragmentManager() Fragment.getFragmentManager().
///
/// The Fragment class can be used many ways to achieve a wide variety of
/// results. In its core, it represents a particular operation or interface
/// that is running within a larger Activity.  A Fragment is closely
/// tied to the Activity it is in, and can not be used apart from one.  Though
/// Fragment defines its own lifecycle, that lifecycle is dependent on its
/// activity: if the activity is stopped, no fragments inside of it can be
/// started; when the activity is destroyed, all fragments will be destroyed.
///
/// All subclasses of Fragment must include a public no-argument constructor.
/// The framework will often re-instantiate a fragment class when needed,
/// in particular during state restore, and needs to be able to find this
/// constructor to instantiate it.  If the no-argument constructor is not
/// available, a runtime exception will occur in some cases during state
/// restore.
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#OlderPlatforms">Older Platforms</a>
/// <li><a href="\#Lifecycle">Lifecycle</a>
/// <li><a href="\#Layout">Layout</a>
/// <li><a href="\#BackStack">Back Stack</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
/// </div>
///
/// <a name="OlderPlatforms"></a>
/// <h3>Older Platforms</h3>
///
/// While the Fragment API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///
/// <a name="Lifecycle"></a>
/// <h3>Lifecycle</h3>
///
/// Though a Fragment's lifecycle is tied to its owning activity, it has
/// its own wrinkle on the standard activity lifecycle.  It includes basic
/// activity lifecycle methods such as \#onResume, but also important
/// are methods related to interactions with the activity and UI generation.
///
/// The core series of lifecycle methods that are called to bring a fragment
/// up to resumed state (interacting with the user) are:
///
/// <ol>
/// <li> \#onAttach called once the fragment is associated with its activity.
/// <li> \#onCreate called to do initial creation of the fragment.
/// <li> \#onCreateView creates and returns the view hierarchy associated
/// with the fragment.
/// <li> \#onActivityCreated tells the fragment that its activity has
/// completed its own Activity\#onCreate Activity.onCreate().
/// <li> \#onViewStateRestored tells the fragment that all of the saved
/// state of its view hierarchy has been restored.
/// <li> \#onStart makes the fragment visible to the user (based on its
/// containing activity being started).
/// <li> \#onResume makes the fragment begin interacting with the user
/// (based on its containing activity being resumed).
/// </ol>
///
/// As a fragment is no longer being used, it goes through a reverse
/// series of callbacks:
///
/// <ol>
/// <li> \#onPause fragment is no longer interacting with the user either
/// because its activity is being paused or a fragment operation is modifying it
/// in the activity.
/// <li> \#onStop fragment is no longer visible to the user either
/// because its activity is being stopped or a fragment operation is modifying it
/// in the activity.
/// <li> \#onDestroyView allows the fragment to clean up resources
/// associated with its View.
/// <li> \#onDestroy called to do final cleanup of the fragment's state.
/// <li> \#onDetach called immediately prior to the fragment no longer
/// being associated with its activity.
/// </ol>
///
/// <a name="Layout"></a>
/// <h3>Layout</h3>
///
/// Fragments can be used as part of your application's layout, allowing
/// you to better modularize your code and more easily adjust your user
/// interface to the screen it is running on.  As an example, we can look
/// at a simple program consisting of a list of items, and display of the
/// details of each item.
///
///
/// An activity's layout XML can include <code>&lt;fragment&gt;</code> tags
/// to embed fragment instances inside of the layout.  For example, here is
/// a simple layout that embeds one fragment:
///
///
/// {@sample development/samples/ApiDemos/res/layout/fragment_layout.xml layout}
///
/// The layout is installed in the activity in the normal way:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      main}
///
/// The titles fragment, showing a list of titles, is fairly simple, relying
/// on ListFragment for most of its work.  Note the implementation of
/// clicking an item: depending on the current activity's layout, it can either
/// create and display a new fragment to show the details in-place (more about
/// this later), or start a new activity to show the details.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      titles}
///
/// The details fragment showing the contents of a selected item just
/// displays a string of text based on an index of a string array built in to
/// the app:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      details}
///
/// In this case when the user clicks on a title, there is no details
/// container in the current activity, so the titles fragment's click code will
/// launch a new activity to display the details fragment:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      details_activity}
///
/// However the screen may be large enough to show both the list of titles
/// and details about the currently selected title.  To use such a layout on
/// a landscape screen, this alternative layout can be placed under layout-land:
///
///
/// {@sample development/samples/ApiDemos/res/layout-land/fragment_layout.xml layout}
///
/// Note how the prior code will adjust to this alternative UI flow: the titles
/// fragment will now embed the details fragment inside of this activity, and the
/// details activity will finish itself if it is running in a configuration
/// where the details can be shown in-place.
///
/// When a configuration change causes the activity hosting these fragments
/// to restart, its new instance may use a different layout that doesn't
/// include the same fragments as the previous layout.  In this case all of
/// the previous fragments will still be instantiated and running in the new
/// instance.  However, any that are no longer associated with a &lt;fragment&gt;
/// tag in the view hierarchy will not have their content view created
/// and will return false from \#isInLayout.  (The code here also shows
/// how you can determine if a fragment placed in a container is no longer
/// running in a layout with that container and avoid creating its view hierarchy
/// in that case.)
///
/// The attributes of the &lt;fragment&gt; tag are used to control the
/// LayoutParams provided when attaching the fragment's view to the parent
/// container.  They can also be parsed by the fragment in \#onInflate
/// as parameters.
///
/// The fragment being instantiated must have some kind of unique identifier
/// so that it can be re-associated with a previous instance if the parent
/// activity needs to be destroyed and recreated.  This can be provided these
/// ways:
///
/// <ul>
/// <li>If nothing is explicitly supplied, the view ID of the container will
/// be used.
/// <li><code>android:tag</code> can be used in &lt;fragment&gt; to provide
/// a specific tag name for the fragment.
/// <li><code>android:id</code> can be used in &lt;fragment&gt; to provide
/// a specific identifier for the fragment.
/// </ul>
///
/// <a name="BackStack"></a>
/// <h3>Back Stack</h3>
///
/// The transaction in which fragments are modified can be placed on an
/// internal back-stack of the owning activity.  When the user presses back
/// in the activity, any transactions on the back stack are popped off before
/// the activity itself is finished.
///
/// For example, consider this simple fragment that is instantiated with
/// an integer argument and displays that in a TextView in its UI:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentStack.java
///      fragment}
///
/// A function that creates a new instance of the fragment, replacing
/// whatever current fragment instance is being shown and pushing that change
/// on to the back stack could be written as:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentStack.java
///      add_stack}
///
/// After each call to this function, a new entry is on the stack, and
/// pressing back will pop it to return the user to whatever previous state
/// the activity UI was in.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.Fragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class Fragment extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/app/Fragment");
  Fragment.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default constructor.  <strong>Every</strong> fragment must have an
  /// empty constructor, so it can be instantiated when restoring its
  /// activity's state.  It is strongly recommended that subclasses do not
  /// have other constructors with parameters, since these constructors
  /// will not be called when the fragment is re-instantiated; instead,
  /// arguments can be supplied by the caller with \#setArguments
  /// and later retrieved by the Fragment with \#getArguments.
  ///
  /// Applications should generally not implement a constructor. Prefer
  /// \#onAttach(Context) instead. It is the first place application code can run where
  /// the fragment is ready to be used - the point where the fragment is actually associated with
  /// its context. Some applications may also want to implement \#onInflate to retrieve
  /// attributes from a layout resource, although note this happens when the fragment is attached.
  Fragment()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_instantiate = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "instantiate",
      "(Landroid/content/Context;Ljava/lang/String;)Landroid/app/Fragment;");

  /// from: static public android.app.Fragment instantiate(android.content.Context context, java.lang.String fname)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#instantiate(Context, String, Bundle) but with a null
  /// argument Bundle.
  static Fragment instantiate(context_.Context context, jni.JniString fname) =>
      Fragment.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_instantiate,
          jni.JniType.objectType,
          [context.reference, fname.reference]).object);

  static final _id_instantiate1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "instantiate",
      "(Landroid/content/Context;Ljava/lang/String;Landroid/os/Bundle;)Landroid/app/Fragment;");

  /// from: static public android.app.Fragment instantiate(android.content.Context context, java.lang.String fname, android.os.Bundle args)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new instance of a Fragment with the given class name.  This is
  /// the same as calling its empty constructor.
  ///@param context The calling context being used to instantiate the fragment.
  /// This is currently just used to get its ClassLoader.
  ///@param fname The class name of the fragment to instantiate.
  ///@param args Bundle of arguments to supply to the fragment, which it
  /// can retrieve with \#getArguments().  May be null.
  /// This value may be {@code null}.
  ///@return Returns a new fragment instance.
  ///@throws InstantiationException If there is a failure in instantiating
  /// the given fragment class.  This is a runtime exception; it is not
  /// normally expected to happen.
  static Fragment instantiate1(
          context_.Context context, jni.JniString fname, bundle_.Bundle args) =>
      Fragment.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_instantiate1,
          jni.JniType.objectType,
          [context.reference, fname.reference, args.reference]).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public final boolean equals(java.lang.Object o)
  ///
  /// Subclasses can not override equals().
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public final int hashCode()
  ///
  /// Subclasses can not override hashCode().
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public final int getId()
  ///
  /// Return the identifier this fragment is known by.  This is either
  /// the android:id value supplied in a layout or the container view ID
  /// supplied when adding the fragment.
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Ljava/lang/String;");

  /// from: public final java.lang.String getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the tag name of the fragment, if specified.
  jni.JniString getTag() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_setArguments = jniAccessors.getMethodIDOf(
      _classRef, "setArguments", "(Landroid/os/Bundle;)V");

  /// from: public void setArguments(android.os.Bundle args)
  ///
  /// Supply the construction arguments for this fragment.
  /// The arguments supplied here will be retained across fragment destroy and
  /// creation.
  ///
  /// This method cannot be called if the fragment is added to a FragmentManager and
  /// if \#isStateSaved() would return true. Prior to Build.VERSION_CODES\#O,
  /// this method may only be called if the fragment has not yet been added to a FragmentManager.
  ///
  ///
  void setArguments(bundle_.Bundle args) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setArguments,
      jni.JniType.voidType,
      [args.reference]).check();

  static final _id_getArguments = jniAccessors.getMethodIDOf(
      _classRef, "getArguments", "()Landroid/os/Bundle;");

  /// from: public final android.os.Bundle getArguments()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the arguments supplied to \#setArguments, if any.
  bundle_.Bundle getArguments() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getArguments, jni.JniType.objectType, []).object);

  static final _id_isStateSaved =
      jniAccessors.getMethodIDOf(_classRef, "isStateSaved", "()Z");

  /// from: public final boolean isStateSaved()
  ///
  /// Returns true if this fragment is added and its state has already been saved
  /// by its host. Any operations that would change saved state should not be performed
  /// if this method returns true, and some operations such as \#setArguments(Bundle)
  /// will fail.
  ///@return true if this fragment's state has already been saved by its host
  bool isStateSaved() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateSaved, jni.JniType.booleanType, []).boolean;

  static final _id_setInitialSavedState = jniAccessors.getMethodIDOf(_classRef,
      "setInitialSavedState", "(Landroid/app/Fragment\$SavedState;)V");

  /// from: public void setInitialSavedState(android.app.Fragment.SavedState state)
  ///
  /// Set the initial saved state that this Fragment should restore itself
  /// from when first being constructed, as returned by
  /// FragmentManager\#saveFragmentInstanceState(Fragment) FragmentManager.saveFragmentInstanceState.
  ///@param state The state the fragment should be restored from.
  void setInitialSavedState(Fragment_SavedState state) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInitialSavedState,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_setTargetFragment = jniAccessors.getMethodIDOf(
      _classRef, "setTargetFragment", "(Landroid/app/Fragment;I)V");

  /// from: public void setTargetFragment(android.app.Fragment fragment, int requestCode)
  ///
  /// Optional target for this fragment.  This may be used, for example,
  /// if this fragment is being started by another, and when done wants to
  /// give a result back to the first.  The target set here is retained
  /// across instances via FragmentManager\#putFragment FragmentManager.putFragment().
  ///@param fragment The fragment that is the target of this one.
  ///@param requestCode Optional request code, for convenience if you
  /// are going to call back with \#onActivityResult(int, int, Intent).
  void setTargetFragment(Fragment fragment, int requestCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTargetFragment,
          jni.JniType.voidType, [fragment.reference, requestCode]).check();

  static final _id_getTargetFragment = jniAccessors.getMethodIDOf(
      _classRef, "getTargetFragment", "()Landroid/app/Fragment;");

  /// from: public final android.app.Fragment getTargetFragment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the target fragment set by \#setTargetFragment.
  Fragment getTargetFragment() =>
      Fragment.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTargetFragment, jni.JniType.objectType, []).object);

  static final _id_getTargetRequestCode =
      jniAccessors.getMethodIDOf(_classRef, "getTargetRequestCode", "()I");

  /// from: public final int getTargetRequestCode()
  ///
  /// Return the target request code set by \#setTargetFragment.
  int getTargetRequestCode() => jniAccessors.callMethodWithArgs(
      reference, _id_getTargetRequestCode, jni.JniType.intType, []).integer;

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Context this fragment is currently associated with.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getActivity = jniAccessors.getMethodIDOf(
      _classRef, "getActivity", "()Landroid/app/Activity;");

  /// from: public final android.app.Activity getActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Activity this fragment is currently associated with.
  activity_.Activity getActivity() =>
      activity_.Activity.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActivity, jni.JniType.objectType, []).object);

  static final _id_getHost =
      jniAccessors.getMethodIDOf(_classRef, "getHost", "()Ljava/lang/Object;");

  /// from: public final java.lang.Object getHost()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the host object of this fragment. May return {@code null} if the fragment
  /// isn't currently being hosted.
  jni.JniObject getHost() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHost, jni.JniType.objectType, []).object);

  static final _id_getResources = jniAccessors.getMethodIDOf(
      _classRef, "getResources", "()Landroid/content/res/Resources;");

  /// from: public final android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return <code>getActivity().getResources()</code>.
  resources_.Resources getResources() =>
      resources_.Resources.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getResources, jni.JniType.objectType, []).object);

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "(I)Ljava/lang/CharSequence;");

  /// from: public final java.lang.CharSequence getText(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized, styled CharSequence from the application's package's
  /// default string table.
  ///@param resId Resource id for the CharSequence text
  jni.JniObject getText(int resId) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, [resId]).object);

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(I)Ljava/lang/String;");

  /// from: public final java.lang.String getString(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized string from the application's package's
  /// default string table.
  ///@param resId Resource id for the string
  jni.JniString getString(int resId) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getString, jni.JniType.objectType, [resId]).object);

  static final _id_getString1 = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(I[Ljava/lang/Object;)Ljava/lang/String;");

  /// from: public final java.lang.String getString(int resId, java.lang.Object[] formatArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized formatted string from the application's package's
  /// default string table, substituting the format arguments as defined in
  /// java.util.Formatter and java.lang.String\#format.
  ///@param resId Resource id for the format string
  ///@param formatArgs The format arguments that will be used for substitution.
  jni.JniString getString1(int resId, jni.JniObject formatArgs) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getString1,
          jni.JniType.objectType,
          [resId, formatArgs.reference]).object);

  static final _id_getFragmentManager = jniAccessors.getMethodIDOf(
      _classRef, "getFragmentManager", "()Landroid/app/FragmentManager;");

  /// from: public final android.app.FragmentManager getFragmentManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the FragmentManager for interacting with fragments associated
  /// with this fragment's activity.  Note that this will be non-null slightly
  /// before \#getActivity(), during the time from when the fragment is
  /// placed in a FragmentTransaction until it is committed and
  /// attached to its activity.
  ///
  /// If this Fragment is a child of another Fragment, the FragmentManager
  /// returned here will be the parent's \#getChildFragmentManager().
  fragmentmanager_.FragmentManager getFragmentManager() =>
      fragmentmanager_.FragmentManager.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFragmentManager,
          jni.JniType.objectType, []).object);

  static final _id_getChildFragmentManager = jniAccessors.getMethodIDOf(
      _classRef, "getChildFragmentManager", "()Landroid/app/FragmentManager;");

  /// from: public final android.app.FragmentManager getChildFragmentManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a private FragmentManager for placing and managing Fragments
  /// inside of this Fragment.
  fragmentmanager_.FragmentManager getChildFragmentManager() =>
      fragmentmanager_.FragmentManager.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getChildFragmentManager,
          jni.JniType.objectType, []).object);

  static final _id_getParentFragment = jniAccessors.getMethodIDOf(
      _classRef, "getParentFragment", "()Landroid/app/Fragment;");

  /// from: public final android.app.Fragment getParentFragment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the parent Fragment containing this Fragment.  If this Fragment
  /// is attached directly to an Activity, returns null.
  Fragment getParentFragment() =>
      Fragment.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getParentFragment, jni.JniType.objectType, []).object);

  static final _id_isAdded =
      jniAccessors.getMethodIDOf(_classRef, "isAdded", "()Z");

  /// from: public final boolean isAdded()
  ///
  /// Return true if the fragment is currently added to its activity.
  bool isAdded() => jniAccessors.callMethodWithArgs(
      reference, _id_isAdded, jni.JniType.booleanType, []).boolean;

  static final _id_isDetached =
      jniAccessors.getMethodIDOf(_classRef, "isDetached", "()Z");

  /// from: public final boolean isDetached()
  ///
  /// Return true if the fragment has been explicitly detached from the UI.
  /// That is, FragmentTransaction\#detach(Fragment) FragmentTransaction.detach(Fragment) has been used on it.
  bool isDetached() => jniAccessors.callMethodWithArgs(
      reference, _id_isDetached, jni.JniType.booleanType, []).boolean;

  static final _id_isRemoving =
      jniAccessors.getMethodIDOf(_classRef, "isRemoving", "()Z");

  /// from: public final boolean isRemoving()
  ///
  /// Return true if this fragment is currently being removed from its
  /// activity.  This is  _not_ whether its activity is finishing, but
  /// rather whether it is in the process of being removed from its activity.
  bool isRemoving() => jniAccessors.callMethodWithArgs(
      reference, _id_isRemoving, jni.JniType.booleanType, []).boolean;

  static final _id_isInLayout =
      jniAccessors.getMethodIDOf(_classRef, "isInLayout", "()Z");

  /// from: public final boolean isInLayout()
  ///
  /// Return true if the layout is included as part of an activity view
  /// hierarchy via the &lt;fragment&gt; tag.  This will always be true when
  /// fragments are created through the &lt;fragment&gt; tag, _except_
  /// in the case where an old fragment is restored from a previous state and
  /// it does not appear in the layout of the current state.
  bool isInLayout() => jniAccessors.callMethodWithArgs(
      reference, _id_isInLayout, jni.JniType.booleanType, []).boolean;

  static final _id_isResumed =
      jniAccessors.getMethodIDOf(_classRef, "isResumed", "()Z");

  /// from: public final boolean isResumed()
  ///
  /// Return true if the fragment is in the resumed state.  This is true
  /// for the duration of \#onResume() and \#onPause() as well.
  bool isResumed() => jniAccessors.callMethodWithArgs(
      reference, _id_isResumed, jni.JniType.booleanType, []).boolean;

  static final _id_isVisible =
      jniAccessors.getMethodIDOf(_classRef, "isVisible", "()Z");

  /// from: public final boolean isVisible()
  ///
  /// Return true if the fragment is currently visible to the user.  This means
  /// it: (1) has been added, (2) has its view attached to the window, and
  /// (3) is not hidden.
  bool isVisible() => jniAccessors.callMethodWithArgs(
      reference, _id_isVisible, jni.JniType.booleanType, []).boolean;

  static final _id_isHidden =
      jniAccessors.getMethodIDOf(_classRef, "isHidden", "()Z");

  /// from: public final boolean isHidden()
  ///
  /// Return true if the fragment has been hidden.  By default fragments
  /// are shown.  You can find out about changes to this state with
  /// \#onHiddenChanged.  Note that the hidden state is orthogonal
  /// to other states -- that is, to be visible to the user, a fragment
  /// must be both started and not hidden.
  bool isHidden() => jniAccessors.callMethodWithArgs(
      reference, _id_isHidden, jni.JniType.booleanType, []).boolean;

  static final _id_onHiddenChanged =
      jniAccessors.getMethodIDOf(_classRef, "onHiddenChanged", "(Z)V");

  /// from: public void onHiddenChanged(boolean hidden)
  ///
  /// Called when the hidden state (as returned by \#isHidden() of
  /// the fragment has changed.  Fragments start out not hidden; this will
  /// be called whenever the fragment changes state from that.
  ///@param hidden True if the fragment is now hidden, false otherwise.
  void onHiddenChanged(bool hidden) => jniAccessors.callMethodWithArgs(
      reference, _id_onHiddenChanged, jni.JniType.voidType, [hidden]).check();

  static final _id_setRetainInstance =
      jniAccessors.getMethodIDOf(_classRef, "setRetainInstance", "(Z)V");

  /// from: public void setRetainInstance(boolean retain)
  ///
  /// Control whether a fragment instance is retained across Activity
  /// re-creation (such as from a configuration change).  This can only
  /// be used with fragments not in the back stack.  If set, the fragment
  /// lifecycle will be slightly different when an activity is recreated:
  /// <ul>
  /// <li> \#onDestroy() will not be called (but \#onDetach() still
  /// will be, because the fragment is being detached from its current activity).
  /// <li> \#onCreate(Bundle) will not be called since the fragment
  /// is not being re-created.
  /// <li> \#onAttach(Activity) and \#onActivityCreated(Bundle) __will__
  /// still be called.
  /// </ul>
  void setRetainInstance(bool retain) => jniAccessors.callMethodWithArgs(
      reference, _id_setRetainInstance, jni.JniType.voidType, [retain]).check();

  static final _id_getRetainInstance =
      jniAccessors.getMethodIDOf(_classRef, "getRetainInstance", "()Z");

  /// from: public final boolean getRetainInstance()
  bool getRetainInstance() => jniAccessors.callMethodWithArgs(
      reference, _id_getRetainInstance, jni.JniType.booleanType, []).boolean;

  static final _id_setHasOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "setHasOptionsMenu", "(Z)V");

  /// from: public void setHasOptionsMenu(boolean hasMenu)
  ///
  /// Report that this fragment would like to participate in populating
  /// the options menu by receiving a call to \#onCreateOptionsMenu
  /// and related methods.
  ///@param hasMenu If true, the fragment has menu items to contribute.
  void setHasOptionsMenu(bool hasMenu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setHasOptionsMenu,
      jni.JniType.voidType,
      [hasMenu]).check();

  static final _id_setMenuVisibility =
      jniAccessors.getMethodIDOf(_classRef, "setMenuVisibility", "(Z)V");

  /// from: public void setMenuVisibility(boolean menuVisible)
  ///
  /// Set a hint for whether this fragment's menu should be visible.  This
  /// is useful if you know that a fragment has been placed in your view
  /// hierarchy so that the user can not currently seen it, so any menu items
  /// it has should also not be shown.
  ///@param menuVisible The default is true, meaning the fragment's menu will
  /// be shown as usual.  If false, the user will not see the menu.
  void setMenuVisibility(bool menuVisible) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMenuVisibility,
      jni.JniType.voidType,
      [menuVisible]).check();

  static final _id_setUserVisibleHint =
      jniAccessors.getMethodIDOf(_classRef, "setUserVisibleHint", "(Z)V");

  /// from: public void setUserVisibleHint(boolean isVisibleToUser)
  ///
  /// Set a hint to the system about whether this fragment's UI is currently visible
  /// to the user. This hint defaults to true and is persistent across fragment instance
  /// state save and restore.
  ///
  /// An app may set this to false to indicate that the fragment's UI is
  /// scrolled out of visibility or is otherwise not directly visible to the user.
  /// This may be used by the system to prioritize operations such as fragment lifecycle updates
  /// or loader ordering behavior.
  ///
  ///
  /// <strong>Note:</strong> This method may be called outside of the fragment lifecycle
  /// and thus has no ordering guarantees with regard to fragment lifecycle method calls.
  ///
  ///
  /// <strong>Note:</strong> Prior to Android N there was a platform bug that could cause
  /// <code>setUserVisibleHint</code> to bring a fragment up to the started state before its
  /// <code>FragmentTransaction</code> had been committed. As some apps relied on this behavior,
  /// it is preserved for apps that declare a <code>targetSdkVersion</code> of 23 or lower.
  ///
  ///@param isVisibleToUser true if this fragment's UI is currently visible to the user (default),
  ///                        false if it is not.
  void setUserVisibleHint(bool isVisibleToUser) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUserVisibleHint,
          jni.JniType.voidType, [isVisibleToUser]).check();

  static final _id_getUserVisibleHint =
      jniAccessors.getMethodIDOf(_classRef, "getUserVisibleHint", "()Z");

  /// from: public boolean getUserVisibleHint()
  ///
  /// @return The current value of the user-visible hint on this fragment.
  ///@see \#setUserVisibleHint(boolean)
  bool getUserVisibleHint() => jniAccessors.callMethodWithArgs(
      reference, _id_getUserVisibleHint, jni.JniType.booleanType, []).boolean;

  static final _id_getLoaderManager = jniAccessors.getMethodIDOf(
      _classRef, "getLoaderManager", "()Landroid/app/LoaderManager;");

  /// from: public android.app.LoaderManager getLoaderManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the LoaderManager for this fragment, creating it if needed.
  ///@deprecated Use android.support.v4.app.Fragment\#getLoaderManager()
  loadermanager_.LoaderManager getLoaderManager() =>
      loadermanager_.LoaderManager.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLoaderManager, jni.JniType.objectType, []).object);

  static final _id_startActivity = jniAccessors.getMethodIDOf(
      _classRef, "startActivity", "(Landroid/content/Intent;)V");

  /// from: public void startActivity(android.content.Intent intent)
  ///
  /// Call Activity\#startActivity(Intent) from the fragment's
  /// containing Activity.
  ///@param intent The intent to start.
  void startActivity(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_startActivity,
      jni.JniType.voidType,
      [intent.reference]).check();

  static final _id_startActivity1 = jniAccessors.getMethodIDOf(_classRef,
      "startActivity", "(Landroid/content/Intent;Landroid/os/Bundle;)V");

  /// from: public void startActivity(android.content.Intent intent, android.os.Bundle options)
  ///
  /// Call Activity\#startActivity(Intent, Bundle) from the fragment's
  /// containing Activity.
  ///@param intent The intent to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  void startActivity1(intent_.Intent intent, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivity1,
          jni.JniType.voidType, [intent.reference, options.reference]).check();

  static final _id_startActivityForResult = jniAccessors.getMethodIDOf(
      _classRef, "startActivityForResult", "(Landroid/content/Intent;I)V");

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode)
  ///
  /// Call Activity\#startActivityForResult(Intent, int) from the fragment's
  /// containing Activity.
  void startActivityForResult(intent_.Intent intent, int requestCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivityForResult,
          jni.JniType.voidType, [intent.reference, requestCode]).check();

  static final _id_startActivityForResult1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startActivityForResult",
      "(Landroid/content/Intent;ILandroid/os/Bundle;)V");

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// Call Activity\#startActivityForResult(Intent, int, Bundle) from the fragment's
  /// containing Activity.
  void startActivityForResult1(
          intent_.Intent intent, int requestCode, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startActivityForResult1,
          jni.JniType.voidType,
          [intent.reference, requestCode, options.reference]).check();

  static final _id_startIntentSenderForResult = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSenderForResult",
      "(Landroid/content/IntentSender;ILandroid/content/Intent;IIILandroid/os/Bundle;)V");

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Call Activity\#startIntentSenderForResult(IntentSender, int, Intent, int, int, int,
  /// Bundle) from the fragment's containing Activity.
  ///@param fillInIntent This value may be {@code null}.
  void startIntentSenderForResult(
          intentsender_.IntentSender intent,
          int requestCode,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSenderForResult, jni.JniType.voidType, [
        intent.reference,
        requestCode,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags,
        options.reference
      ]).check();

  static final _id_onActivityResult = jniAccessors.getMethodIDOf(
      _classRef, "onActivityResult", "(IILandroid/content/Intent;)V");

  /// from: public void onActivityResult(int requestCode, int resultCode, android.content.Intent data)
  ///
  /// Receive the result from a previous call to
  /// \#startActivityForResult(Intent, int).  This follows the
  /// related Activity API as described there in
  /// Activity\#onActivityResult(int, int, Intent).
  ///@param requestCode The integer request code originally supplied to
  ///                    startActivityForResult(), allowing you to identify who this
  ///                    result came from.
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  void onActivityResult(int requestCode, int resultCode, intent_.Intent data) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onActivityResult,
          jni.JniType.voidType,
          [requestCode, resultCode, data.reference]).check();

  static final _id_requestPermissions = jniAccessors.getMethodIDOf(
      _classRef, "requestPermissions", "([Ljava/lang/String;I)V");

  /// from: public final void requestPermissions(java.lang.String[] permissions, int requestCode)
  ///
  /// Requests permissions to be granted to this application. These permissions
  /// must be requested in your manifest, they should not be granted to your app,
  /// and they should have protection level android.content.pm.PermissionInfo \#PROTECTION_DANGEROUS dangerous, regardless whether they are declared by
  /// the platform or a third-party app.
  ///
  /// Normal permissions android.content.pm.PermissionInfo\#PROTECTION_NORMAL
  /// are granted at install time if requested in the manifest. Signature permissions
  /// android.content.pm.PermissionInfo\#PROTECTION_SIGNATURE are granted at
  /// install time if requested in the manifest and the signature of your app matches
  /// the signature of the app declaring the permissions.
  ///
  ///
  ///
  /// If your app does not have the requested permissions the user will be presented
  /// with UI for accepting them. After the user has accepted or rejected the
  /// requested permissions you will receive a callback on \#onRequestPermissionsResult(int, String[], int[]) reporting whether the
  /// permissions were granted or not.
  ///
  ///
  ///
  /// Note that requesting a permission does not guarantee it will be granted and
  /// your app should be able to run without having this permission.
  ///
  ///
  ///
  /// This method may start an activity allowing the user to choose which permissions
  /// to grant and which to reject. Hence, you should be prepared that your activity
  /// may be paused and resumed. Further, granting some permissions may require
  /// a restart of you application. In such a case, the system will recreate the
  /// activity stack before delivering the result to \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// When checking whether you have a permission you should use android.content.Context\#checkSelfPermission(String).
  ///
  ///
  ///
  /// Calling this API for permissions already granted to your app would show UI
  /// to the user to decide whether the app can still hold these permissions. This
  /// can be useful if the way your app uses data guarded by the permissions
  /// changes significantly.
  ///
  ///
  ///
  /// You cannot request a permission if your activity sets android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code> because in this case the activity would not receive
  /// result callbacks including \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// A sample permissions request looks like this:
  ///
  ///
  /// <code><pre>
  /// private void showContacts() {
  ///     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)
  ///             != PackageManager.PERMISSION_GRANTED) {
  ///         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},
  ///                 PERMISSIONS_REQUEST_READ_CONTACTS);
  ///     } else {
  ///         doShowContacts();
  ///     }
  /// }
  ///
  /// {@literal @}Override
  /// public void onRequestPermissionsResult(int requestCode, String[] permissions,
  ///         int[] grantResults) {
  ///     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS
  ///             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
  ///         doShowContacts();
  ///     }
  /// }
  /// </code></pre>
  ///
  ///@param permissions The requested permissions. Must me non-null and not empty.
  /// This value must never be {@code null}.
  ///@param requestCode Application specific request code to match with a result
  ///    reported to \#onRequestPermissionsResult(int, String[], int[]).
  ///    Should be >= 0.
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  ///@see android.content.Context\#checkSelfPermission(String)
  void requestPermissions(jni.JniObject permissions, int requestCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestPermissions,
          jni.JniType.voidType, [permissions.reference, requestCode]).check();

  static final _id_onRequestPermissionsResult = jniAccessors.getMethodIDOf(
      _classRef, "onRequestPermissionsResult", "(I[Ljava/lang/String;[I)V");

  /// from: public void onRequestPermissionsResult(int requestCode, java.lang.String[] permissions, int[] grantResults)
  ///
  /// Callback for the result from requesting permissions. This method
  /// is invoked for every call on \#requestPermissions(String[], int).
  ///
  /// <strong>Note:</strong> It is possible that the permissions request interaction
  /// with the user is interrupted. In this case you will receive empty permissions
  /// and results arrays which should be treated as a cancellation.
  ///
  ///
  ///@param requestCode The request code passed in \#requestPermissions(String[], int).
  ///@param permissions The requested permissions. Never null.
  /// This value must never be {@code null}.
  ///@param grantResults The grant results for the corresponding permissions
  ///     which is either android.content.pm.PackageManager\#PERMISSION_GRANTED
  ///     or android.content.pm.PackageManager\#PERMISSION_DENIED. Never null.
  ///
  /// This value must never be {@code null}.
  ///@see \#requestPermissions(String[], int)
  void onRequestPermissionsResult(int requestCode, jni.JniObject permissions,
          jni.JniObject grantResults) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onRequestPermissionsResult,
          jni.JniType.voidType,
          [requestCode, permissions.reference, grantResults.reference]).check();

  static final _id_shouldShowRequestPermissionRationale =
      jniAccessors.getMethodIDOf(_classRef,
          "shouldShowRequestPermissionRationale", "(Ljava/lang/String;)Z");

  /// from: public boolean shouldShowRequestPermissionRationale(java.lang.String permission)
  ///
  /// Gets whether you should show UI with rationale for requesting a permission.
  /// You should do this only if you do not have the permission and the context in
  /// which the permission is requested does not clearly communicate to the user
  /// what would be the benefit from granting this permission.
  ///
  /// For example, if you write a camera app, requesting the camera permission
  /// would be expected by the user and no rationale for why it is requested is
  /// needed. If however, the app needs location for tagging photos then a non-tech
  /// savvy user may wonder how location is related to taking photos. In this case
  /// you may choose to show UI with rationale of requesting this permission.
  ///
  ///
  ///@param permission A permission your app wants to request.
  /// This value must never be {@code null}.
  ///@return Whether you can show permission rationale UI.
  ///@see Context\#checkSelfPermission(String)
  ///@see \#requestPermissions(String[], int)
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  bool shouldShowRequestPermissionRationale(jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_shouldShowRequestPermissionRationale,
          jni.JniType.booleanType,
          [permission.reference]).boolean;

  static final _id_onGetLayoutInflater = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetLayoutInflater",
      "(Landroid/os/Bundle;)Landroid/view/LayoutInflater;");

  /// from: public android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the LayoutInflater used to inflate Views of this Fragment. The default
  /// implementation will throw an exception if the Fragment is not attached.
  ///@return The LayoutInflater used to inflate Views of this Fragment.
  layoutinflater_.LayoutInflater onGetLayoutInflater(
          bundle_.Bundle savedInstanceState) =>
      layoutinflater_.LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetLayoutInflater,
          jni.JniType.objectType,
          [savedInstanceState.reference]).object);

  static final _id_getLayoutInflater = jniAccessors.getMethodIDOf(
      _classRef, "getLayoutInflater", "()Landroid/view/LayoutInflater;");

  /// from: public final android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the cached LayoutInflater used to inflate Views of this Fragment. If
  /// \#onGetLayoutInflater(Bundle) has not been called \#onGetLayoutInflater(Bundle)
  /// will be called with a {@code null} argument and that value will be cached.
  ///
  /// The cached LayoutInflater will be replaced immediately prior to
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle) and cleared immediately after
  /// \#onDetach().
  ///@return The LayoutInflater used to inflate Views of this Fragment.
  layoutinflater_.LayoutInflater getLayoutInflater() =>
      layoutinflater_.LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLayoutInflater, jni.JniType.objectType, []).object);

  static final _id_onInflate = jniAccessors.getMethodIDOf(_classRef,
      "onInflate", "(Landroid/util/AttributeSet;Landroid/os/Bundle;)V");

  /// from: public void onInflate(android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onInflate(Context, AttributeSet, Bundle) instead.
  void onInflate(attributeset_.AttributeSet attrs,
          bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onInflate,
          jni.JniType.voidType,
          [attrs.reference, savedInstanceState.reference]).check();

  static final _id_onInflate1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onInflate",
      "(Landroid/content/Context;Landroid/util/AttributeSet;Landroid/os/Bundle;)V");

  /// from: public void onInflate(android.content.Context context, android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  ///
  /// Called when a fragment is being created as part of a view layout
  /// inflation, typically from setting the content view of an activity.  This
  /// may be called immediately after the fragment is created from a <fragment>
  /// tag in a layout file.  Note this is _before_ the fragment's
  /// \#onAttach(Activity) has been called; all you should do here is
  /// parse the attributes and save them away.
  ///
  /// This is called every time the fragment is inflated, even if it is
  /// being inflated into a new instance with saved state.  It typically makes
  /// sense to re-parse the parameters each time, to allow them to change with
  /// different configurations.
  ///
  ///
  /// Here is a typical implementation of a fragment that can take parameters
  /// both through attributes supplied here as well from \#getArguments():
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentArguments.java
  ///      fragment}
  ///
  /// Note that parsing the XML attributes uses a "styleable" resource.  The
  /// declaration for the styleable used here is:
  ///
  ///
  /// {@sample development/samples/ApiDemos/res/values/attrs.xml fragment_arguments}
  ///
  /// The fragment can then be declared within its activity's content layout
  /// through a tag like this:
  ///
  ///
  /// {@sample development/samples/ApiDemos/res/layout/fragment_arguments.xml from_attributes}
  ///
  /// This fragment can also be created dynamically from arguments given
  /// at runtime in the arguments Bundle; here is an example of doing so at
  /// creation of the containing activity:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentArguments.java
  ///      create}
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param context The Context that is inflating this fragment.
  ///@param attrs The attributes at the tag where the fragment is
  /// being created.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  void onInflate1(context_.Context context, attributeset_.AttributeSet attrs,
          bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onInflate1, jni.JniType.voidType, [
        context.reference,
        attrs.reference,
        savedInstanceState.reference
      ]).check();

  static final _id_onInflate2 = jniAccessors.getMethodIDOf(
      _classRef,
      "onInflate",
      "(Landroid/app/Activity;Landroid/util/AttributeSet;Landroid/os/Bundle;)V");

  /// from: public void onInflate(android.app.Activity activity, android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onInflate(Context, AttributeSet, Bundle) instead.
  void onInflate2(activity_.Activity activity, attributeset_.AttributeSet attrs,
          bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onInflate2, jni.JniType.voidType, [
        activity.reference,
        attrs.reference,
        savedInstanceState.reference
      ]).check();

  static final _id_onAttachFragment = jniAccessors.getMethodIDOf(
      _classRef, "onAttachFragment", "(Landroid/app/Fragment;)V");

  /// from: public void onAttachFragment(android.app.Fragment childFragment)
  ///
  /// Called when a fragment is attached as a child of this fragment.
  ///
  /// This is called after the attached fragment's <code>onAttach</code> and before
  /// the attached fragment's <code>onCreate</code> if the fragment has not yet had a previous
  /// call to <code>onCreate</code>.
  ///
  ///@param childFragment child fragment being attached
  void onAttachFragment(Fragment childFragment) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAttachFragment,
          jni.JniType.voidType, [childFragment.reference]).check();

  static final _id_onAttach = jniAccessors.getMethodIDOf(
      _classRef, "onAttach", "(Landroid/content/Context;)V");

  /// from: public void onAttach(android.content.Context context)
  ///
  /// Called when a fragment is first attached to its context.
  /// \#onCreate(Bundle) will be called after this.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onAttach(context_.Context context) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onAttach,
      jni.JniType.voidType,
      [context.reference]).check();

  static final _id_onAttach1 = jniAccessors.getMethodIDOf(
      _classRef, "onAttach", "(Landroid/app/Activity;)V");

  /// from: public void onAttach(android.app.Activity activity)
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onAttach(Context) instead.
  void onAttach1(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAttach1,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_onCreateAnimator = jniAccessors.getMethodIDOf(
      _classRef, "onCreateAnimator", "(IZI)Landroid/animation/Animator;");

  /// from: public android.animation.Animator onCreateAnimator(int transit, boolean enter, int nextAnim)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when a fragment loads an animation.
  animator_.Animator onCreateAnimator(int transit, bool enter, int nextAnim) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateAnimator,
          jni.JniType.objectType,
          [transit, enter, nextAnim]).object);

  static final _id_onCreate = jniAccessors.getMethodIDOf(
      _classRef, "onCreate", "(Landroid/os/Bundle;)V");

  /// from: public void onCreate(android.os.Bundle savedInstanceState)
  ///
  /// Called to do initial creation of a fragment.  This is called after
  /// \#onAttach(Activity) and before
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle), but is not called if the fragment
  /// instance is retained across Activity re-creation (see \#setRetainInstance(boolean)).
  ///
  /// Note that this can be called while the fragment's activity is
  /// still in the process of being created.  As such, you can not rely
  /// on things like the activity's content view hierarchy being initialized
  /// at this point.  If you want to do work once the activity itself is
  /// created, see \#onActivityCreated(Bundle).
  ///
  /// If your app's <code>targetSdkVersion</code> is android.os.Build.VERSION_CODES\#M
  /// or lower, child fragments being restored from the savedInstanceState are restored after
  /// <code>onCreate</code> returns. When targeting android.os.Build.VERSION_CODES\#N or
  /// above and running on an N or newer platform version
  /// they are restored by <code>Fragment.onCreate</code>.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  ///
  /// This value may be {@code null}.
  void onCreate(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreate,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onCreateView = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateView",
      "(Landroid/view/LayoutInflater;Landroid/view/ViewGroup;Landroid/os/Bundle;)Landroid/view/View;");

  /// from: public android.view.View onCreateView(android.view.LayoutInflater inflater, android.view.ViewGroup container, android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called to have the fragment instantiate its user interface view.
  /// This is optional, and non-graphical fragments can return null (which
  /// is the default implementation).  This will be called between
  /// \#onCreate(Bundle) and \#onActivityCreated(Bundle).
  ///
  /// If you return a View from here, you will later be called in
  /// \#onDestroyView when the view is being released.
  ///@param inflater The LayoutInflater object that can be used to inflate
  /// any views in the fragment,
  ///@param container If non-null, this is the parent view that the fragment's
  /// UI should be attached to.  The fragment should not add the view itself,
  /// but this can be used to generate the LayoutParams of the view.
  /// This value may be {@code null}.
  ///@param savedInstanceState If non-null, this fragment is being re-constructed
  /// from a previous saved state as given here.
  ///@return Return the View for the fragment's UI, or null.
  view_.View onCreateView(layoutinflater_.LayoutInflater inflater,
          viewgroup_.ViewGroup container, bundle_.Bundle savedInstanceState) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCreateView, jni.JniType.objectType, [
        inflater.reference,
        container.reference,
        savedInstanceState.reference
      ]).object);

  static final _id_onViewCreated = jniAccessors.getMethodIDOf(
      _classRef, "onViewCreated", "(Landroid/view/View;Landroid/os/Bundle;)V");

  /// from: public void onViewCreated(android.view.View view, android.os.Bundle savedInstanceState)
  ///
  /// Called immediately after \#onCreateView(LayoutInflater, ViewGroup, Bundle)
  /// has returned, but before any saved state has been restored in to the view.
  /// This gives subclasses a chance to initialize themselves once
  /// they know their view hierarchy has been completely created.  The fragment's
  /// view hierarchy is not however attached to its parent at this point.
  ///@param view The View returned by \#onCreateView(LayoutInflater, ViewGroup, Bundle).
  ///@param savedInstanceState If non-null, this fragment is being re-constructed
  /// from a previous saved state as given here.
  ///
  /// This value may be {@code null}.
  void onViewCreated(view_.View view, bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onViewCreated,
          jni.JniType.voidType,
          [view.reference, savedInstanceState.reference]).check();

  static final _id_getView =
      jniAccessors.getMethodIDOf(_classRef, "getView", "()Landroid/view/View;");

  /// from: public android.view.View getView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the root view for the fragment's layout (the one returned by \#onCreateView),
  /// if provided.
  ///@return The fragment's root view, or null if it has no layout.
  view_.View getView() => view_.View.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getView, jni.JniType.objectType, []).object);

  static final _id_onActivityCreated = jniAccessors.getMethodIDOf(
      _classRef, "onActivityCreated", "(Landroid/os/Bundle;)V");

  /// from: public void onActivityCreated(android.os.Bundle savedInstanceState)
  ///
  /// Called when the fragment's activity has been created and this
  /// fragment's view hierarchy instantiated.  It can be used to do final
  /// initialization once these pieces are in place, such as retrieving
  /// views or restoring state.  It is also useful for fragments that use
  /// \#setRetainInstance(boolean) to retain their instance,
  /// as this callback tells the fragment when it is fully associated with
  /// the new activity instance.  This is called after \#onCreateView
  /// and before \#onViewStateRestored(Bundle).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  ///
  /// This value may be {@code null}.
  void onActivityCreated(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActivityCreated,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onViewStateRestored = jniAccessors.getMethodIDOf(
      _classRef, "onViewStateRestored", "(Landroid/os/Bundle;)V");

  /// from: public void onViewStateRestored(android.os.Bundle savedInstanceState)
  ///
  /// Called when all saved state has been restored into the view hierarchy
  /// of the fragment.  This can be used to do initialization based on saved
  /// state that you are letting the view hierarchy track itself, such as
  /// whether check box widgets are currently checked.  This is called
  /// after \#onActivityCreated(Bundle) and before
  /// \#onStart().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  void onViewStateRestored(bundle_.Bundle savedInstanceState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onViewStateRestored,
          jni.JniType.voidType, [savedInstanceState.reference]).check();

  static final _id_onStart =
      jniAccessors.getMethodIDOf(_classRef, "onStart", "()V");

  /// from: public void onStart()
  ///
  /// Called when the Fragment is visible to the user.  This is generally
  /// tied to Activity\#onStart() Activity.onStart of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onStart() => jniAccessors.callMethodWithArgs(
      reference, _id_onStart, jni.JniType.voidType, []).check();

  static final _id_onResume =
      jniAccessors.getMethodIDOf(_classRef, "onResume", "()V");

  /// from: public void onResume()
  ///
  /// Called when the fragment is visible to the user and actively running.
  /// This is generally
  /// tied to Activity\#onResume() Activity.onResume of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onResume() => jniAccessors.callMethodWithArgs(
      reference, _id_onResume, jni.JniType.voidType, []).check();

  static final _id_onSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "(Landroid/os/Bundle;)V");

  /// from: public void onSaveInstanceState(android.os.Bundle outState)
  ///
  /// Called to ask the fragment to save its current dynamic state, so it
  /// can later be reconstructed in a new instance of its process is
  /// restarted.  If a new instance of the fragment later needs to be
  /// created, the data you place in the Bundle here will be available
  /// in the Bundle given to \#onCreate(Bundle),
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle), and
  /// \#onActivityCreated(Bundle).
  ///
  /// This corresponds to Activity\#onSaveInstanceState(Bundle) Activity.onSaveInstanceState(Bundle) and most of the discussion there
  /// applies here as well.  Note however: _this method may be called
  /// at any time before \#onDestroy()_.  There are many situations
  /// where a fragment may be mostly torn down (such as when placed on the
  /// back stack with no UI showing), but its state will not be saved until
  /// its owning activity actually needs to save its state.
  ///@param outState Bundle in which to place your saved state.
  void onSaveInstanceState(bundle_.Bundle outState) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSaveInstanceState,
          jni.JniType.voidType, [outState.reference]).check();

  static final _id_onMultiWindowModeChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onMultiWindowModeChanged",
      "(ZLandroid/content/res/Configuration;)V");

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  ///
  /// Called when the Fragment's activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This is generally tied to Activity\#onMultiWindowModeChanged of the
  /// containing Activity. This method provides the same configuration that will be sent in the
  /// following \#onConfigurationChanged(Configuration) call after the activity enters this
  /// mode.
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInMultiWindowMode}.
  void onMultiWindowModeChanged(
          bool isInMultiWindowMode, configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onMultiWindowModeChanged,
          jni.JniType.voidType,
          [isInMultiWindowMode, newConfig.reference]).check();

  static final _id_onMultiWindowModeChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onMultiWindowModeChanged", "(Z)V");

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode)
  ///
  /// Called when the Fragment's activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This is generally tied to Activity\#onMultiWindowModeChanged of the
  /// containing Activity.
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@deprecated Use \#onMultiWindowModeChanged(boolean, Configuration) instead.
  void onMultiWindowModeChanged1(bool isInMultiWindowMode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMultiWindowModeChanged1,
          jni.JniType.voidType, [isInMultiWindowMode]).check();

  static final _id_onPictureInPictureModeChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onPictureInPictureModeChanged",
      "(ZLandroid/content/res/Configuration;)V");

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the activity changes to and from picture-in-picture mode. This is
  /// generally tied to Activity\#onPictureInPictureModeChanged of the containing Activity.
  /// This method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInPictureInPictureMode}.
  void onPictureInPictureModeChanged(bool isInPictureInPictureMode,
          configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPictureInPictureModeChanged,
          jni.JniType.voidType,
          [isInPictureInPictureMode, newConfig.reference]).check();

  static final _id_onPictureInPictureModeChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "onPictureInPictureModeChanged", "(Z)V");

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  ///
  /// Called by the system when the activity changes to and from picture-in-picture mode. This is
  /// generally tied to Activity\#onPictureInPictureModeChanged of the containing Activity.
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@deprecated Use \#onPictureInPictureModeChanged(boolean, Configuration) instead.
  void onPictureInPictureModeChanged1(bool isInPictureInPictureMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPictureInPictureModeChanged1,
          jni.JniType.voidType,
          [isInPictureInPictureMode]).check();

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_onPause =
      jniAccessors.getMethodIDOf(_classRef, "onPause", "()V");

  /// from: public void onPause()
  ///
  /// Called when the Fragment is no longer resumed.  This is generally
  /// tied to Activity\#onPause() Activity.onPause of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onPause() => jniAccessors.callMethodWithArgs(
      reference, _id_onPause, jni.JniType.voidType, []).check();

  static final _id_onStop =
      jniAccessors.getMethodIDOf(_classRef, "onStop", "()V");

  /// from: public void onStop()
  ///
  /// Called when the Fragment is no longer started.  This is generally
  /// tied to Activity\#onStop() Activity.onStop of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onStop() => jniAccessors.callMethodWithArgs(
      reference, _id_onStop, jni.JniType.voidType, []).check();

  static final _id_onLowMemory =
      jniAccessors.getMethodIDOf(_classRef, "onLowMemory", "()V");

  /// from: public void onLowMemory()
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onLowMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_onLowMemory, jni.JniType.voidType, []).check();

  static final _id_onTrimMemory =
      jniAccessors.getMethodIDOf(_classRef, "onTrimMemory", "(I)V");

  /// from: public void onTrimMemory(int level)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onTrimMemory(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onTrimMemory, jni.JniType.voidType, [level]).check();

  static final _id_onDestroyView =
      jniAccessors.getMethodIDOf(_classRef, "onDestroyView", "()V");

  /// from: public void onDestroyView()
  ///
  /// Called when the view previously created by \#onCreateView has
  /// been detached from the fragment.  The next time the fragment needs
  /// to be displayed, a new view will be created.  This is called
  /// after \#onStop() and before \#onDestroy().  It is called
  /// _regardless_ of whether \#onCreateView returned a
  /// non-null view.  Internally it is called after the view's state has
  /// been saved but before it has been removed from its parent.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDestroyView() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroyView, jni.JniType.voidType, []).check();

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  ///
  /// Called when the fragment is no longer in use.  This is called
  /// after \#onStop() and before \#onDetach().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_onDetach =
      jniAccessors.getMethodIDOf(_classRef, "onDetach", "()V");

  /// from: public void onDetach()
  ///
  /// Called when the fragment is no longer attached to its activity.  This is called after
  /// \#onDestroy(), except in the cases where the fragment instance is retained across
  /// Activity re-creation (see \#setRetainInstance(boolean)), in which case it is called
  /// after \#onStop().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDetach() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetach, jni.JniType.voidType, []).check();

  static final _id_onCreateOptionsMenu = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateOptionsMenu",
      "(Landroid/view/Menu;Landroid/view/MenuInflater;)V");

  /// from: public void onCreateOptionsMenu(android.view.Menu menu, android.view.MenuInflater inflater)
  ///
  /// Initialize the contents of the Activity's standard options menu.  You
  /// should place your menu items in to <var>menu</var>.  For this method
  /// to be called, you must have first called \#setHasOptionsMenu.  See
  /// Activity\#onCreateOptionsMenu(Menu) Activity.onCreateOptionsMenu
  /// for more information.
  ///@param menu The options menu in which you place your items.
  ///@see \#setHasOptionsMenu
  ///@see \#onPrepareOptionsMenu
  ///@see \#onOptionsItemSelected
  void onCreateOptionsMenu(
          menu_.Menu menu, menuinflater_.MenuInflater inflater) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreateOptionsMenu,
          jni.JniType.voidType, [menu.reference, inflater.reference]).check();

  static final _id_onPrepareOptionsMenu = jniAccessors.getMethodIDOf(
      _classRef, "onPrepareOptionsMenu", "(Landroid/view/Menu;)V");

  /// from: public void onPrepareOptionsMenu(android.view.Menu menu)
  ///
  /// Prepare the Screen's standard options menu to be displayed.  This is
  /// called right before the menu is shown, every time it is shown.  You can
  /// use this method to efficiently enable/disable items or otherwise
  /// dynamically modify the contents.  See
  /// Activity\#onPrepareOptionsMenu(Menu) Activity.onPrepareOptionsMenu
  /// for more information.
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  ///@see \#setHasOptionsMenu
  ///@see \#onCreateOptionsMenu
  void onPrepareOptionsMenu(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onPrepareOptionsMenu,
      jni.JniType.voidType,
      [menu.reference]).check();

  static final _id_onDestroyOptionsMenu =
      jniAccessors.getMethodIDOf(_classRef, "onDestroyOptionsMenu", "()V");

  /// from: public void onDestroyOptionsMenu()
  ///
  /// Called when this fragment's option menu items are no longer being
  /// included in the overall options menu.  Receiving this call means that
  /// the menu needed to be rebuilt, but this fragment's items were not
  /// included in the newly built menu (its \#onCreateOptionsMenu(Menu, MenuInflater)
  /// was not called).
  void onDestroyOptionsMenu() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroyOptionsMenu, jni.JniType.voidType, []).check();

  static final _id_onOptionsItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onOptionsItemSelected", "(Landroid/view/MenuItem;)Z");

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  ///
  /// This hook is called whenever an item in your options menu is selected.
  /// The default implementation simply returns false to have the normal
  /// processing happen (calling the item's Runnable or sending a message to
  /// its Handler as appropriate).  You can use this method for any items
  /// for which you would like to do processing without those other
  /// facilities.
  ///
  /// Derived classes should call through to the base class for it to
  /// perform the default menu handling.
  ///@param item The menu item that was selected.
  ///@return boolean Return false to allow normal menu processing to
  ///         proceed, true to consume it here.
  ///@see \#onCreateOptionsMenu
  bool onOptionsItemSelected(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onOptionsItemSelected,
          jni.JniType.booleanType, [item.reference]).boolean;

  static final _id_onOptionsMenuClosed = jniAccessors.getMethodIDOf(
      _classRef, "onOptionsMenuClosed", "(Landroid/view/Menu;)V");

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  ///
  /// This hook is called whenever the options menu is being closed (either by the user canceling
  /// the menu with the back/menu button, or when an item is selected).
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  void onOptionsMenuClosed(menu_.Menu menu) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onOptionsMenuClosed,
      jni.JniType.voidType,
      [menu.reference]).check();

  static final _id_onCreateContextMenu = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateContextMenu",
      "(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu\$ContextMenuInfo;)V");

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  ///
  /// Called when a context menu for the {@code view} is about to be shown.
  /// Unlike \#onCreateOptionsMenu, this will be called every
  /// time the context menu is about to be shown and should be populated for
  /// the view (or item inside the view for AdapterView subclasses,
  /// this can be found in the {@code menuInfo})).
  ///
  /// Use \#onContextItemSelected(android.view.MenuItem) to know when an
  /// item has been selected.
  ///
  /// The default implementation calls up to
  /// Activity\#onCreateContextMenu Activity.onCreateContextMenu, though
  /// you can not call this implementation if you don't want that behavior.
  ///
  /// It is not safe to hold onto the context menu after this method returns.
  /// {@inheritDoc}
  void onCreateContextMenu(contextmenu_.ContextMenu menu, view_.View v,
          contextmenu_.ContextMenu_ContextMenuInfo menuInfo) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateContextMenu,
          jni.JniType.voidType,
          [menu.reference, v.reference, menuInfo.reference]).check();

  static final _id_registerForContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "registerForContextMenu", "(Landroid/view/View;)V");

  /// from: public void registerForContextMenu(android.view.View view)
  ///
  /// Registers a context menu to be shown for the given view (multiple views
  /// can show the context menu). This method will set the
  /// OnCreateContextMenuListener on the view to this fragment, so
  /// \#onCreateContextMenu(ContextMenu, View, ContextMenuInfo) will be
  /// called when it is time to show the context menu.
  ///@see \#unregisterForContextMenu(View)
  ///@param view The view that should show a context menu.
  void registerForContextMenu(view_.View view) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerForContextMenu,
          jni.JniType.voidType, [view.reference]).check();

  static final _id_unregisterForContextMenu = jniAccessors.getMethodIDOf(
      _classRef, "unregisterForContextMenu", "(Landroid/view/View;)V");

  /// from: public void unregisterForContextMenu(android.view.View view)
  ///
  /// Prevents a context menu to be shown for the given view. This method will
  /// remove the OnCreateContextMenuListener on the view.
  ///@see \#registerForContextMenu(View)
  ///@param view The view that should stop showing a context menu.
  void unregisterForContextMenu(view_.View view) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterForContextMenu,
          jni.JniType.voidType, [view.reference]).check();

  static final _id_onContextItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onContextItemSelected", "(Landroid/view/MenuItem;)Z");

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  ///
  /// This hook is called whenever an item in a context menu is selected. The
  /// default implementation simply returns false to have the normal processing
  /// happen (calling the item's Runnable or sending a message to its Handler
  /// as appropriate). You can use this method for any items for which you
  /// would like to do processing without those other facilities.
  ///
  /// Use MenuItem\#getMenuInfo() to get extra information set by the
  /// View that added this menu item.
  ///
  /// Derived classes should call through to the base class for it to perform
  /// the default menu handling.
  ///@param item The context menu item that was selected.
  ///@return boolean Return false to allow normal context menu processing to
  ///         proceed, true to consume it here.
  bool onContextItemSelected(menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onContextItemSelected,
          jni.JniType.booleanType, [item.reference]).boolean;

  static final _id_setEnterSharedElementCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setEnterSharedElementCallback",
      "(Landroid/app/SharedElementCallback;)V");

  /// from: public void setEnterSharedElementCallback(android.app.SharedElementCallback callback)
  ///
  /// When custom transitions are used with Fragments, the enter transition callback
  /// is called when this Fragment is attached or detached when not popping the back stack.
  ///@param callback Used to manipulate the shared element transitions on this Fragment
  ///                 when added not as a pop from the back stack.
  void setEnterSharedElementCallback(
          sharedelementcallback_.SharedElementCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setEnterSharedElementCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_setExitSharedElementCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setExitSharedElementCallback",
      "(Landroid/app/SharedElementCallback;)V");

  /// from: public void setExitSharedElementCallback(android.app.SharedElementCallback callback)
  ///
  /// When custom transitions are used with Fragments, the exit transition callback
  /// is called when this Fragment is attached or detached when popping the back stack.
  ///@param callback Used to manipulate the shared element transitions on this Fragment
  ///                 when added as a pop from the back stack.
  void setExitSharedElementCallback(
          sharedelementcallback_.SharedElementCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setExitSharedElementCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_setEnterTransition = jniAccessors.getMethodIDOf(
      _classRef, "setEnterTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setEnterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views into the initial scene. The entering
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#INVISIBLE to View\#VISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected.
  ///@param transition The Transition to use to move Views into the initial Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentEnterTransition
  void setEnterTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEnterTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_getEnterTransition = jniAccessors.getMethodIDOf(
      _classRef, "getEnterTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getEnterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views into the initial scene. The entering
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#INVISIBLE to View\#VISIBLE.
  ///@return the Transition to use to move Views into the initial Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentEnterTransition
  transition_.Transition getEnterTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getEnterTransition, jni.JniType.objectType, []).object);

  static final _id_setReturnTransition = jniAccessors.getMethodIDOf(
      _classRef, "setReturnTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setReturnTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views out of the scene when the Fragment is
  /// preparing to be removed, hidden, or detached because of popping the back stack. The exiting
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#VISIBLE to View\#INVISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected. If nothing is set, the default will be to
  /// use the same value as set in \#setEnterTransition(android.transition.Transition).
  ///@param transition The Transition to use to move Views out of the Scene when the Fragment
  ///                   is preparing to close.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  void setReturnTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setReturnTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_getReturnTransition = jniAccessors.getMethodIDOf(
      _classRef, "getReturnTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getReturnTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views out of the scene when the Fragment is
  /// preparing to be removed, hidden, or detached because of popping the back stack. The exiting
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#VISIBLE to View\#INVISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected.
  ///@return the Transition to use to move Views out of the Scene when the Fragment
  ///         is preparing to close.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  transition_.Transition getReturnTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getReturnTransition, jni.JniType.objectType, []).object);

  static final _id_setExitTransition = jniAccessors.getMethodIDOf(
      _classRef, "setExitTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setExitTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views out of the scene when the
  /// fragment is removed, hidden, or detached when not popping the back stack.
  /// The exiting Views will be those that are regular Views or ViewGroups that
  /// have ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as exiting is governed by changing visibility
  /// from View\#VISIBLE to View\#INVISIBLE. If transition is null, the views will
  /// remain unaffected.
  ///@param transition The Transition to use to move Views out of the Scene when the Fragment
  ///                   is being closed not due to popping the back stack.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  void setExitTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setExitTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_getExitTransition = jniAccessors.getMethodIDOf(
      _classRef, "getExitTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getExitTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views out of the scene when the
  /// fragment is removed, hidden, or detached when not popping the back stack.
  /// The exiting Views will be those that are regular Views or ViewGroups that
  /// have ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as exiting is governed by changing visibility
  /// from View\#VISIBLE to View\#INVISIBLE. If transition is null, the views will
  /// remain unaffected.
  ///@return the Transition to use to move Views out of the Scene when the Fragment
  ///         is being closed not due to popping the back stack.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  transition_.Transition getExitTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExitTransition, jni.JniType.objectType, []).object);

  static final _id_setReenterTransition = jniAccessors.getMethodIDOf(
      _classRef, "setReenterTransition", "(Landroid/transition/Transition;)V");

  /// from: public void setReenterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views in to the scene when returning due
  /// to popping a back stack. The entering Views will be those that are regular Views
  /// or ViewGroups that have ViewGroup\#isTransitionGroup return true. Typical Transitions
  /// will extend android.transition.Visibility as exiting is governed by changing
  /// visibility from View\#VISIBLE to View\#INVISIBLE. If transition is null,
  /// the views will remain unaffected. If nothing is set, the default will be to use the same
  /// transition as \#setExitTransition(android.transition.Transition).
  ///@param transition The Transition to use to move Views into the scene when reentering from a
  ///                   previously-started Activity.
  ///@attr ref android.R.styleable\#Fragment_fragmentReenterTransition
  void setReenterTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_setReenterTransition,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_getReenterTransition = jniAccessors.getMethodIDOf(
      _classRef, "getReenterTransition", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getReenterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views in to the scene when returning due
  /// to popping a back stack. The entering Views will be those that are regular Views
  /// or ViewGroups that have ViewGroup\#isTransitionGroup return true. Typical Transitions
  /// will extend android.transition.Visibility as exiting is governed by changing
  /// visibility from View\#VISIBLE to View\#INVISIBLE. If transition is null,
  /// the views will remain unaffected. If nothing is set, the default will be to use the same
  /// transition as \#setExitTransition(android.transition.Transition).
  ///@return the Transition to use to move Views into the scene when reentering from a
  ///                   previously-started Activity.
  ///@attr ref android.R.styleable\#Fragment_fragmentReenterTransition
  transition_.Transition getReenterTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getReenterTransition, jni.JniType.objectType, []).object);

  static final _id_setSharedElementEnterTransition = jniAccessors.getMethodIDOf(
      _classRef,
      "setSharedElementEnterTransition",
      "(Landroid/transition/Transition;)V");

  /// from: public void setSharedElementEnterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used for shared elements transferred into the content
  /// Scene. Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  ///@param transition The Transition to use for shared elements transferred into the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementEnterTransition
  void setSharedElementEnterTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSharedElementEnterTransition,
          jni.JniType.voidType,
          [transition.reference]).check();

  static final _id_getSharedElementEnterTransition = jniAccessors.getMethodIDOf(
      _classRef,
      "getSharedElementEnterTransition",
      "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getSharedElementEnterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used for shared elements transferred into the content
  /// Scene. Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  ///@return The Transition to use for shared elements transferred into the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementEnterTransition
  transition_.Transition getSharedElementEnterTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSharedElementEnterTransition,
          jni.JniType.objectType, []).object);

  static final _id_setSharedElementReturnTransition =
      jniAccessors.getMethodIDOf(_classRef, "setSharedElementReturnTransition",
          "(Landroid/transition/Transition;)V");

  /// from: public void setSharedElementReturnTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used for shared elements transferred back during a
  /// pop of the back stack. This Transition acts in the leaving Fragment.
  /// Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  /// If no value is set, the default will be to use the same value as
  /// \#setSharedElementEnterTransition(android.transition.Transition).
  ///@param transition The Transition to use for shared elements transferred out of the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementReturnTransition
  void setSharedElementReturnTransition(transition_.Transition transition) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSharedElementReturnTransition,
          jni.JniType.voidType,
          [transition.reference]).check();

  static final _id_getSharedElementReturnTransition =
      jniAccessors.getMethodIDOf(_classRef, "getSharedElementReturnTransition",
          "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition getSharedElementReturnTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Transition that will be used for shared elements transferred back during a
  /// pop of the back stack. This Transition acts in the leaving Fragment.
  /// Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  /// If no value is set, the default will be to use the same value as
  /// \#setSharedElementEnterTransition(android.transition.Transition).
  ///@return The Transition to use for shared elements transferred out of the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementReturnTransition
  transition_.Transition getSharedElementReturnTransition() =>
      transition_.Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSharedElementReturnTransition,
          jni.JniType.objectType, []).object);

  static final _id_setAllowEnterTransitionOverlap = jniAccessors.getMethodIDOf(
      _classRef, "setAllowEnterTransitionOverlap", "(Z)V");

  /// from: public void setAllowEnterTransitionOverlap(boolean allow)
  ///
  /// Sets whether the the exit transition and enter transition overlap or not.
  /// When true, the enter transition will start as soon as possible. When false, the
  /// enter transition will wait until the exit transition completes before starting.
  ///@param allow true to start the enter transition when possible or false to
  ///              wait until the exiting transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowEnterTransitionOverlap
  void setAllowEnterTransitionOverlap(bool allow) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAllowEnterTransitionOverlap,
          jni.JniType.voidType,
          [allow]).check();

  static final _id_getAllowEnterTransitionOverlap = jniAccessors.getMethodIDOf(
      _classRef, "getAllowEnterTransitionOverlap", "()Z");

  /// from: public boolean getAllowEnterTransitionOverlap()
  ///
  /// Returns whether the the exit transition and enter transition overlap or not.
  /// When true, the enter transition will start as soon as possible. When false, the
  /// enter transition will wait until the exit transition completes before starting.
  ///@return true when the enter transition should start as soon as possible or false to
  /// when it should wait until the exiting transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowEnterTransitionOverlap
  bool getAllowEnterTransitionOverlap() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAllowEnterTransitionOverlap,
      jni.JniType.booleanType, []).boolean;

  static final _id_setAllowReturnTransitionOverlap = jniAccessors.getMethodIDOf(
      _classRef, "setAllowReturnTransitionOverlap", "(Z)V");

  /// from: public void setAllowReturnTransitionOverlap(boolean allow)
  ///
  /// Sets whether the the return transition and reenter transition overlap or not.
  /// When true, the reenter transition will start as soon as possible. When false, the
  /// reenter transition will wait until the return transition completes before starting.
  ///@param allow true to start the reenter transition when possible or false to wait until the
  ///              return transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowReturnTransitionOverlap
  void setAllowReturnTransitionOverlap(bool allow) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAllowReturnTransitionOverlap,
          jni.JniType.voidType,
          [allow]).check();

  static final _id_getAllowReturnTransitionOverlap = jniAccessors.getMethodIDOf(
      _classRef, "getAllowReturnTransitionOverlap", "()Z");

  /// from: public boolean getAllowReturnTransitionOverlap()
  ///
  /// Returns whether the the return transition and reenter transition overlap or not.
  /// When true, the reenter transition will start as soon as possible. When false, the
  /// reenter transition will wait until the return transition completes before starting.
  ///@return true to start the reenter transition when possible or false to wait until the
  ///         return transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowReturnTransitionOverlap
  bool getAllowReturnTransitionOverlap() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAllowReturnTransitionOverlap,
      jni.JniType.booleanType, []).boolean;

  static final _id_postponeEnterTransition =
      jniAccessors.getMethodIDOf(_classRef, "postponeEnterTransition", "()V");

  /// from: public void postponeEnterTransition()
  ///
  /// Postpone the entering Fragment transition until \#startPostponedEnterTransition()
  /// or FragmentManager\#executePendingTransactions() has been called.
  ///
  /// This method gives the Fragment the ability to delay Fragment animations
  /// until all data is loaded. Until then, the added, shown, and
  /// attached Fragments will be INVISIBLE and removed, hidden, and detached Fragments won't
  /// be have their Views removed. The transaction runs when all postponed added Fragments in the
  /// transaction have called \#startPostponedEnterTransition().
  ///
  /// This method should be called before being added to the FragmentTransaction or
  /// in \#onCreate(Bundle), \#onAttach(Context), or
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle)}.
  /// \#startPostponedEnterTransition() must be called to allow the Fragment to
  /// start the transitions.
  ///
  /// When a FragmentTransaction is started that may affect a postponed FragmentTransaction,
  /// based on which containers are in their operations, the postponed FragmentTransaction
  /// will have its start triggered. The early triggering may result in faulty or nonexistent
  /// animations in the postponed transaction. FragmentTransactions that operate only on
  /// independent containers will not interfere with each other's postponement.
  ///
  /// Calling postponeEnterTransition on Fragments with a null View will not postpone the
  /// transition. Likewise, postponement only works if FragmentTransaction optimizations are
  /// enabled.
  ///@see Activity\#postponeEnterTransition()
  ///@see FragmentTransaction\#setReorderingAllowed(boolean)
  void postponeEnterTransition() => jniAccessors.callMethodWithArgs(
      reference, _id_postponeEnterTransition, jni.JniType.voidType, []).check();

  static final _id_startPostponedEnterTransition = jniAccessors.getMethodIDOf(
      _classRef, "startPostponedEnterTransition", "()V");

  /// from: public void startPostponedEnterTransition()
  ///
  /// Begin postponed transitions after \#postponeEnterTransition() was called.
  /// If postponeEnterTransition() was called, you must call startPostponedEnterTransition()
  /// or FragmentManager\#executePendingTransactions() to complete the FragmentTransaction.
  /// If postponement was interrupted with FragmentManager\#executePendingTransactions(),
  /// before {@code startPostponedEnterTransition()}, animations may not run or may execute
  /// improperly.
  ///@see Activity\#startPostponedEnterTransition()
  void startPostponedEnterTransition() => jniAccessors.callMethodWithArgs(
      reference,
      _id_startPostponedEnterTransition,
      jni.JniType.voidType, []).check();

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Fragments's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();
}

/// from: android.app.Fragment$SavedState
///
/// State information that has been retrieved from a fragment instance
/// through FragmentManager\#saveFragmentInstanceState(Fragment) FragmentManager.saveFragmentInstanceState.
///@deprecated Use android.support.v4.app.Fragment.SavedState
class Fragment_SavedState extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Fragment\$SavedState");
  Fragment_SavedState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$ClassLoaderCreator;");

  /// from: static public final android.os.Parcelable.ClassLoaderCreator<android.app.Fragment.SavedState> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_ClassLoaderCreator get CREATOR =>
      parcelable_.Parcelable_ClassLoaderCreator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Bundle;)V");

  /// from: void <init>(android.os.Bundle state)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Fragment_SavedState(bundle_.Bundle state)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [state.reference]).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.app.Fragment$InstantiationException
///
/// Thrown by Fragment\#instantiate(Context, String, Bundle) when
/// there is an instantiation failure.
///@deprecated Use android.support.v4.app.Fragment.InstantiationException
class Fragment_InstantiationException
    extends androidruntimeexception_.AndroidRuntimeException {
  static final _classRef =
      jniAccessors.getClassOf("android/app/Fragment\$InstantiationException");
  Fragment_InstantiationException.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Ljava/lang/Exception;)V");

  /// from: public void <init>(java.lang.String msg, java.lang.Exception cause)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Fragment_InstantiationException.ctor4(jni.JniString msg, jni.JniObject cause)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [msg.reference, cause.reference]).object);
}
