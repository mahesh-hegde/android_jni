// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "ClipDescription.dart" as clipdescription_;

import "Intent.dart" as intent_;

import "ContentResolver.dart" as contentresolver_;

import "../net/Uri.dart" as uri_;

import "../os/Parcel.dart" as parcel_;

import "Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.ClipData
///
/// Representation of a clipped data on the clipboard.
///
/// ClipData is a complex type containing one or more Item instances,
/// each of which can hold one or more representations of an item of data.
/// For display to the user, it also has a label.
///
///
/// A ClipData contains a ClipDescription, which describes
/// important meta-data about the clip.  In particular, its
/// ClipDescription\#getMimeType(int) getDescription().getMimeType(int)
/// must return correct MIME type(s) describing the data in the clip.  For help
/// in correctly constructing a clip with the correct MIME type, use
/// \#newPlainText(CharSequence, CharSequence),
/// \#newUri(ContentResolver, CharSequence, Uri), and
/// \#newIntent(CharSequence, Intent).
///
/// Each Item instance can be one of three main classes of data: a simple
/// CharSequence of text, a single Intent object, or a Uri.  See Item
/// for more details.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using the clipboard framework, read the
/// <a href="{@docRoot}guide/topics/clipboard/copy-paste.html">Copy and Paste</a>
/// developer guide.
///
/// </div>
///
/// <a name="ImplementingPaste"></a>
/// <h3>Implementing Paste or Drop</h3>
///
/// To implement a paste or drop of a ClipData object into an application,
/// the application must correctly interpret the data for its use.  If the Item
/// it contains is simple text or an Intent, there is little to be done: text
/// can only be interpreted as text, and an Intent will typically be used for
/// creating shortcuts (such as placing icons on the home screen) or other
/// actions.
///
/// If all you want is the textual representation of the clipped data, you
/// can use the convenience method Item\#coerceToText Item.coerceToText.
/// In this case there is generally no need to worry about the MIME types
/// reported by ClipDescription\#getMimeType(int) getDescription().getMimeType(int),
/// since any clip item can always be converted to a string.
///
/// More complicated exchanges will be done through URIs, in particular
/// "content:" URIs.  A content URI allows the recipient of a ClipData item
/// to interact closely with the ContentProvider holding the data in order to
/// negotiate the transfer of that data.  The clip must also be filled in with
/// the available MIME types; \#newUri(ContentResolver, CharSequence, Uri)
/// will take care of correctly doing this.
///
/// For example, here is the paste function of a simple NotePad application.
/// When retrieving the data from the clipboard, it can do either two things:
/// if the clipboard contains a URI reference to an existing note, it copies
/// the entire structure of the note into a new note; otherwise, it simply
/// coerces the clip into text and uses that as the new note's contents.
///
/// {@sample development/samples/NotePad/src/com/example/android/notepad/NoteEditor.java
///      paste}
///
/// In many cases an application can paste various types of streams of data.  For
/// example, an e-mail application may want to allow the user to paste an image
/// or other binary data as an attachment.  This is accomplished through the
/// ContentResolver ContentResolver\#getStreamTypes(Uri, String) and
/// ContentResolver\#openTypedAssetFileDescriptor(Uri, String, android.os.Bundle)
/// methods.  These allow a client to discover the type(s) of data that a particular
/// content URI can make available as a stream and retrieve the stream of data.
///
/// For example, the implementation of Item\#coerceToText Item.coerceToText
/// itself uses this to try to retrieve a URI clip as a stream of text:
///
/// {@sample frameworks/base/core/java/android/content/ClipData.java coerceToText}
///
/// <a name="ImplementingCopy"></a>
/// <h3>Implementing Copy or Drag</h3>
///
/// To be the source of a clip, the application must construct a ClipData
/// object that any recipient can interpret best for their context.  If the clip
/// is to contain a simple text, Intent, or URI, this is easy: an Item
/// containing the appropriate data type can be constructed and used.
///
/// More complicated data types require the implementation of support in
/// a ContentProvider for describing and generating the data for the recipient.
/// A common scenario is one where an application places on the clipboard the
/// content: URI of an object that the user has copied, with the data at that
/// URI consisting of a complicated structure that only other applications with
/// direct knowledge of the structure can use.
///
/// For applications that do not have intrinsic knowledge of the data structure,
/// the content provider holding it can make the data available as an arbitrary
/// number of types of data streams.  This is done by implementing the
/// ContentProvider ContentProvider\#getStreamTypes(Uri, String) and
/// ContentProvider\#openTypedAssetFile(Uri, String, android.os.Bundle)
/// methods.
///
/// Going back to our simple NotePad application, this is the implementation
/// it may have to convert a single note URI (consisting of a title and the note
/// text) into a stream of plain text data.
///
/// {@sample development/samples/NotePad/src/com/example/android/notepad/NotePadProvider.java
///      stream}
///
/// The copy operation in our NotePad application is now just a simple matter
/// of making a clip containing the URI of the note being copied:
///
/// {@sample development/samples/NotePad/src/com/example/android/notepad/NotesList.java
///      copy}
///
/// Note if a paste operation needs this clip as text (for example to paste
/// into an editor), then Item\#coerceToText(Context) will ask the content
/// provider for the clip URI as text and successfully paste the entire note.
class ClipData extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/content/ClipData");
  ClipData.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.ClipData> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/CharSequence;[Ljava/lang/String;Landroid/content/ClipData\$Item;)V");

  /// from: public void <init>(java.lang.CharSequence label, java.lang.String[] mimeTypes, android.content.ClipData.Item item)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new clip.
  ///@param label Label to show to the user describing this clip.
  ///@param mimeTypes An array of MIME types this data is available as.
  ///@param item The contents of the first item in the clip.
  ClipData(jni.JniObject label, jni.JniObject mimeTypes, ClipData_Item item)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [label.reference, mimeTypes.reference, item.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/ClipDescription;Landroid/content/ClipData\$Item;)V");

  /// from: public void <init>(android.content.ClipDescription description, android.content.ClipData.Item item)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new clip.
  ///@param description The ClipDescription describing the clip contents.
  ///@param item The contents of the first item in the clip.
  ClipData.ctor1(
      clipdescription_.ClipDescription description, ClipData_Item item)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [description.reference, item.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/ClipData;)V");

  /// from: public void <init>(android.content.ClipData other)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new clip that is a copy of another clip.  This does a deep-copy
  /// of all items in the clip.
  ///@param other The existing ClipData that is to be copied.
  ClipData.ctor2(ClipData other)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [other.reference]).object);

  static final _id_newPlainText = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newPlainText",
      "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Landroid/content/ClipData;");

  /// from: static public android.content.ClipData newPlainText(java.lang.CharSequence label, java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding data of the type
  /// ClipDescription\#MIMETYPE_TEXT_PLAIN.
  ///@param label User-visible label for the clip data.
  ///@param text The actual text in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newPlainText(jni.JniObject label, jni.JniObject text) =>
      ClipData.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newPlainText,
          jni.JniType.objectType,
          [label.reference, text.reference]).object);

  static final _id_newHtmlText = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newHtmlText",
      "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/String;)Landroid/content/ClipData;");

  /// from: static public android.content.ClipData newHtmlText(java.lang.CharSequence label, java.lang.CharSequence text, java.lang.String htmlText)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding data of the type
  /// ClipDescription\#MIMETYPE_TEXT_HTML.
  ///@param label User-visible label for the clip data.
  ///@param text The text of clip as plain text, for receivers that don't
  /// handle HTML.  This is required.
  ///@param htmlText The actual HTML text in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newHtmlText(
          jni.JniObject label, jni.JniObject text, jni.JniString htmlText) =>
      ClipData.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newHtmlText,
          jni.JniType.objectType,
          [label.reference, text.reference, htmlText.reference]).object);

  static final _id_newIntent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newIntent",
      "(Ljava/lang/CharSequence;Landroid/content/Intent;)Landroid/content/ClipData;");

  /// from: static public android.content.ClipData newIntent(java.lang.CharSequence label, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding an Intent with MIME type
  /// ClipDescription\#MIMETYPE_TEXT_INTENT.
  ///@param label User-visible label for the clip data.
  ///@param intent The actual Intent in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newIntent(jni.JniObject label, intent_.Intent intent) =>
      ClipData.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newIntent,
          jni.JniType.objectType,
          [label.reference, intent.reference]).object);

  static final _id_newUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newUri",
      "(Landroid/content/ContentResolver;Ljava/lang/CharSequence;Landroid/net/Uri;)Landroid/content/ClipData;");

  /// from: static public android.content.ClipData newUri(android.content.ContentResolver resolver, java.lang.CharSequence label, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding a URI.  If the URI is a content: URI,
  /// this will query the content provider for the MIME type of its data and
  /// use that as the MIME type.  Otherwise, it will use the MIME type
  /// ClipDescription\#MIMETYPE_TEXT_URILIST.
  ///@param resolver ContentResolver used to get information about the URI.
  ///@param label User-visible label for the clip data.
  ///@param uri The URI in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newUri(contentresolver_.ContentResolver resolver,
          jni.JniObject label, uri_.Uri uri) =>
      ClipData.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newUri,
          jni.JniType.objectType,
          [resolver.reference, label.reference, uri.reference]).object);

  static final _id_newRawUri = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newRawUri",
      "(Ljava/lang/CharSequence;Landroid/net/Uri;)Landroid/content/ClipData;");

  /// from: static public android.content.ClipData newRawUri(java.lang.CharSequence label, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding an URI with MIME type
  /// ClipDescription\#MIMETYPE_TEXT_URILIST.
  /// Unlike \#newUri(ContentResolver, CharSequence, Uri), nothing
  /// is inferred about the URI -- if it is a content: URI holding a bitmap,
  /// the reported type will still be uri-list.  Use this with care!
  ///@param label User-visible label for the clip data.
  ///@param uri The URI in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newRawUri(jni.JniObject label, uri_.Uri uri) =>
      ClipData.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_newRawUri,
          jni.JniType.objectType,
          [label.reference, uri.reference]).object);

  static final _id_getDescription = jniAccessors.getMethodIDOf(
      _classRef, "getDescription", "()Landroid/content/ClipDescription;");

  /// from: public android.content.ClipDescription getDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the ClipDescription associated with this data, describing
  /// what it contains.
  clipdescription_.ClipDescription getDescription() =>
      clipdescription_.ClipDescription.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDescription, jni.JniType.objectType, []).object);

  static final _id_addItem = jniAccessors.getMethodIDOf(
      _classRef, "addItem", "(Landroid/content/ClipData\$Item;)V");

  /// from: public void addItem(android.content.ClipData.Item item)
  ///
  /// Add a new Item to the overall ClipData container.
  ///  This method will _not_ update the list of available MIME types in the
  /// ClipDescription. It should be used only when adding items which do not add new
  /// MIME types to this clip. If this is not the case, use \#addItem(ContentResolver, Item)
  /// or call \#ClipData(CharSequence, String[], Item) with a complete list of MIME types.
  ///@param item Item to be added.
  void addItem(ClipData_Item item) => jniAccessors.callMethodWithArgs(
      reference, _id_addItem, jni.JniType.voidType, [item.reference]).check();

  static final _id_addItem1 = jniAccessors.getMethodIDOf(_classRef, "addItem",
      "(Landroid/content/ContentResolver;Landroid/content/ClipData\$Item;)V");

  /// from: public void addItem(android.content.ContentResolver resolver, android.content.ClipData.Item item)
  ///
  /// Add a new Item to the overall ClipData container.
  ///  Unlike \#addItem(Item), this method will update the list of available MIME types
  /// in the ClipDescription.
  ///@param resolver ContentResolver used to get information about the URI possibly contained in
  /// the item.
  ///@param item Item to be added.
  void addItem1(
          contentresolver_.ContentResolver resolver, ClipData_Item item) =>
      jniAccessors.callMethodWithArgs(reference, _id_addItem1,
          jni.JniType.voidType, [resolver.reference, item.reference]).check();

  static final _id_getItemCount =
      jniAccessors.getMethodIDOf(_classRef, "getItemCount", "()I");

  /// from: public int getItemCount()
  ///
  /// Return the number of items in the clip data.
  int getItemCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getItemCount, jni.JniType.intType, []).integer;

  static final _id_getItemAt = jniAccessors.getMethodIDOf(
      _classRef, "getItemAt", "(I)Landroid/content/ClipData\$Item;");

  /// from: public android.content.ClipData.Item getItemAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a single item inside of the clip data.  The index can range
  /// from 0 to \#getItemCount()-1.
  ClipData_Item getItemAt(int index) =>
      ClipData_Item.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getItemAt, jni.JniType.objectType, [index]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.content.ClipData$Item
///
/// Description of a single item in a ClipData.
///
/// The types than an individual item can currently contain are:
///
///
/// <ul>
/// <li> Text: a basic string of text.  This is actually a CharSequence,
/// so it can be formatted text supported by corresponding Android built-in
/// style spans.  (Custom application spans are not supported and will be
/// stripped when transporting through the clipboard.)
/// <li> Intent: an arbitrary Intent object.  A typical use is the shortcut
/// to create when pasting a clipped item on to the home screen.
/// <li> Uri: a URI reference.  This may be any URI (such as an http: URI
/// representing a bookmark), however it is often a content: URI.  Using
/// content provider references as clips like this allows an application to
/// share complex or large clips through the standard content provider
/// facilities.
/// </ul>
class ClipData_Item extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/ClipData\$Item");
  ClipData_Item.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/CharSequence;)V");

  /// from: public void <init>(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an Item consisting of a single block of (possibly styled) text.
  ClipData_Item(jni.JniObject text)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [text.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/CharSequence;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.CharSequence text, java.lang.String htmlText)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an Item consisting of a single block of (possibly styled) text,
  /// with an alternative HTML formatted representation.  You _must_
  /// supply a plain text representation in addition to HTML text; coercion
  /// will not be done from HTML formated text into plain text.
  ClipData_Item.ctor1(jni.JniObject text, jni.JniString htmlText)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [text.reference, htmlText.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Intent;)V");

  /// from: public void <init>(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an Item consisting of an arbitrary Intent.
  ClipData_Item.ctor2(intent_.Intent intent)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [intent.reference]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/net/Uri;)V");

  /// from: public void <init>(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an Item consisting of an arbitrary URI.
  ClipData_Item.ctor3(uri_.Uri uri)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [uri.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/CharSequence;Landroid/content/Intent;Landroid/net/Uri;)V");

  /// from: public void <init>(java.lang.CharSequence text, android.content.Intent intent, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a complex Item, containing multiple representations of
  /// text, Intent, and/or URI.
  ClipData_Item.ctor4(jni.JniObject text, intent_.Intent intent, uri_.Uri uri)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor4,
            [text.reference, intent.reference, uri.reference]).object);

  static final _id_ctor5 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/CharSequence;Ljava/lang/String;Landroid/content/Intent;Landroid/net/Uri;)V");

  /// from: public void <init>(java.lang.CharSequence text, java.lang.String htmlText, android.content.Intent intent, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a complex Item, containing multiple representations of
  /// text, HTML text, Intent, and/or URI.  If providing HTML text, you
  /// _must_ supply a plain text representation as well; coercion
  /// will not be done from HTML formated text into plain text.
  ClipData_Item.ctor5(jni.JniObject text, jni.JniString htmlText,
      intent_.Intent intent, uri_.Uri uri)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor5, [
          text.reference,
          htmlText.reference,
          intent.reference,
          uri.reference
        ]).object);

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw text contained in this Item.
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_getHtmlText = jniAccessors.getMethodIDOf(
      _classRef, "getHtmlText", "()Ljava/lang/String;");

  /// from: public java.lang.String getHtmlText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw HTML text contained in this Item.
  jni.JniString getHtmlText() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHtmlText, jni.JniType.objectType, []).object);

  static final _id_getIntent = jniAccessors.getMethodIDOf(
      _classRef, "getIntent", "()Landroid/content/Intent;");

  /// from: public android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw Intent contained in this Item.
  intent_.Intent getIntent() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIntent, jni.JniType.objectType, []).object);

  static final _id_getUri =
      jniAccessors.getMethodIDOf(_classRef, "getUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw URI contained in this Item.
  uri_.Uri getUri() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getUri, jni.JniType.objectType, []).object);

  static final _id_coerceToText = jniAccessors.getMethodIDOf(_classRef,
      "coerceToText", "(Landroid/content/Context;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence coerceToText(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Turn this item into text, regardless of the type of data it
  /// actually contains.
  ///
  /// The algorithm for deciding what text to return is:
  /// <ul>
  /// <li> If \#getText is non-null, return that.
  /// <li> If \#getUri is non-null, try to retrieve its data
  /// as a text stream from its content provider.  If this succeeds, copy
  /// the text into a String and return it.  If it is not a content: URI or
  /// the content provider does not supply a text representation, return
  /// the raw URI as a string.
  /// <li> If \#getIntent is non-null, convert that to an intent:
  /// URI and return it.
  /// <li> Otherwise, return an empty string.
  /// </ul>
  ///@param context The caller's Context, from which its ContentResolver
  /// and other things can be retrieved.
  ///@return Returns the item's textual representation.
  jni.JniObject coerceToText(context_.Context context) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_coerceToText,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_coerceToStyledText = jniAccessors.getMethodIDOf(
      _classRef,
      "coerceToStyledText",
      "(Landroid/content/Context;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence coerceToStyledText(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#coerceToHtmlText(Context), but any text that would
  /// be returned as HTML formatting will be returned as text with
  /// style spans.
  ///@param context The caller's Context, from which its ContentResolver
  /// and other things can be retrieved.
  ///@return Returns the item's textual representation.
  jni.JniObject coerceToStyledText(context_.Context context) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_coerceToStyledText,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_coerceToHtmlText = jniAccessors.getMethodIDOf(_classRef,
      "coerceToHtmlText", "(Landroid/content/Context;)Ljava/lang/String;");

  /// from: public java.lang.String coerceToHtmlText(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Turn this item into HTML text, regardless of the type of data it
  /// actually contains.
  ///
  /// The algorithm for deciding what text to return is:
  /// <ul>
  /// <li> If \#getHtmlText is non-null, return that.
  /// <li> If \#getText is non-null, return that, converting to
  /// valid HTML text.  If this text contains style spans,
  /// Html\#toHtml(Spanned) Html.toHtml(Spanned) is used to
  /// convert them to HTML formatting.
  /// <li> If \#getUri is non-null, try to retrieve its data
  /// as a text stream from its content provider.  If the provider can
  /// supply text/html data, that will be preferred and returned as-is.
  /// Otherwise, any text/* data will be returned and escaped to HTML.
  /// If it is not a content: URI or the content provider does not supply
  /// a text representation, HTML text containing a link to the URI
  /// will be returned.
  /// <li> If \#getIntent is non-null, convert that to an intent:
  /// URI and return as an HTML link.
  /// <li> Otherwise, return an empty string.
  /// </ul>
  ///@param context The caller's Context, from which its ContentResolver
  /// and other things can be retrieved.
  ///@return Returns the item's representation as HTML text.
  jni.JniString coerceToHtmlText(context_.Context context) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_coerceToHtmlText,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
