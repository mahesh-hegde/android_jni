// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Context.dart" as context_;

import "../database/ContentObserver.dart" as contentobserver_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.Loader
///
/// A class that performs asynchronous loading of data. While Loaders are active
/// they should monitor the source of their data and deliver new results when the contents
/// change.  See android.app.LoaderManager for more detail.
///
/// __Note on threading:__ Clients of loaders should as a rule perform
/// any calls on to a Loader from the main thread of their process (that is,
/// the thread the Activity callbacks and other things occur on).  Subclasses
/// of Loader (such as AsyncTaskLoader) will often perform their work
/// in a separate thread, but when delivering their results this too should
/// be done on the main thread.
///
///
/// Subclasses generally must implement at least \#onStartLoading(),
/// \#onStopLoading(), \#onForceLoad(), and \#onReset().
///
///
/// Most implementations should not derive directly from this class, but
/// instead inherit from AsyncTaskLoader.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using loaders, read the
/// <a href="{@docRoot}guide/components/loaders.html">Loaders</a> developer guide.
///
/// </div>
///@param <D> The result returned when the load is complete
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.content.Loader
class Loader extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/content/Loader");
  Loader.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Stores away the application context associated with context.
  /// Since Loaders can be used across multiple activities it's dangerous to
  /// store the context directly; always use \#getContext() to retrieve
  /// the Loader's Context, don't use the constructor argument directly.
  /// The Context returned by \#getContext is safe to use across
  /// Activity instances.
  ///@param context used to retrieve the application context.
  Loader(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_deliverCancellation =
      jniAccessors.getMethodIDOf(_classRef, "deliverCancellation", "()V");

  /// from: public void deliverCancellation()
  ///
  /// Informs the registered OnLoadCanceledListener that the load has been canceled.
  /// Should only be called by subclasses.
  ///
  /// Must be called from the process's main thread.
  void deliverCancellation() => jniAccessors.callMethodWithArgs(
      reference, _id_deliverCancellation, jni.JniType.voidType, []).check();

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return an application context retrieved from the Context passed to the constructor.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()I");

  /// from: public int getId()
  ///
  /// @return the ID of this loader
  int getId() => jniAccessors.callMethodWithArgs(
      reference, _id_getId, jni.JniType.intType, []).integer;

  static final _id_registerListener = jniAccessors.getMethodIDOf(
      _classRef,
      "registerListener",
      "(ILandroid/content/Loader\$OnLoadCompleteListener;)V");

  /// from: public void registerListener(int id, android.content.Loader.OnLoadCompleteListener<D> listener)
  ///
  /// Registers a class that will receive callbacks when a load is complete.
  /// The callback will be called on the process's main thread so it's safe to
  /// pass the results to widgets.
  ///
  /// Must be called from the process's main thread.
  void registerListener(int id, Loader_OnLoadCompleteListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerListener,
          jni.JniType.voidType, [id, listener.reference]).check();

  static final _id_unregisterListener = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterListener",
      "(Landroid/content/Loader\$OnLoadCompleteListener;)V");

  /// from: public void unregisterListener(android.content.Loader.OnLoadCompleteListener<D> listener)
  ///
  /// Remove a listener that was previously added with \#registerListener.
  ///
  /// Must be called from the process's main thread.
  void unregisterListener(Loader_OnLoadCompleteListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_registerOnLoadCanceledListener = jniAccessors.getMethodIDOf(
      _classRef,
      "registerOnLoadCanceledListener",
      "(Landroid/content/Loader\$OnLoadCanceledListener;)V");

  /// from: public void registerOnLoadCanceledListener(android.content.Loader.OnLoadCanceledListener<D> listener)
  ///
  /// Registers a listener that will receive callbacks when a load is canceled.
  /// The callback will be called on the process's main thread so it's safe to
  /// pass the results to widgets.
  ///
  /// Must be called from the process's main thread.
  ///@param listener The listener to register.
  void registerOnLoadCanceledListener(Loader_OnLoadCanceledListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerOnLoadCanceledListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_unregisterOnLoadCanceledListener =
      jniAccessors.getMethodIDOf(_classRef, "unregisterOnLoadCanceledListener",
          "(Landroid/content/Loader\$OnLoadCanceledListener;)V");

  /// from: public void unregisterOnLoadCanceledListener(android.content.Loader.OnLoadCanceledListener<D> listener)
  ///
  /// Unregisters a listener that was previously added with
  /// \#registerOnLoadCanceledListener.
  ///
  /// Must be called from the process's main thread.
  ///@param listener The listener to unregister.
  void unregisterOnLoadCanceledListener(
          Loader_OnLoadCanceledListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterOnLoadCanceledListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_isStarted =
      jniAccessors.getMethodIDOf(_classRef, "isStarted", "()Z");

  /// from: public boolean isStarted()
  ///
  /// Return whether this load has been started.  That is, its \#startLoading()
  /// has been called and no calls to \#stopLoading() or
  /// \#reset() have yet been made.
  bool isStarted() => jniAccessors.callMethodWithArgs(
      reference, _id_isStarted, jni.JniType.booleanType, []).boolean;

  static final _id_isAbandoned =
      jniAccessors.getMethodIDOf(_classRef, "isAbandoned", "()Z");

  /// from: public boolean isAbandoned()
  ///
  /// Return whether this loader has been abandoned.  In this state, the
  /// loader _must not_ report any new data, and _must_ keep
  /// its last reported data valid until it is finally reset.
  bool isAbandoned() => jniAccessors.callMethodWithArgs(
      reference, _id_isAbandoned, jni.JniType.booleanType, []).boolean;

  static final _id_isReset =
      jniAccessors.getMethodIDOf(_classRef, "isReset", "()Z");

  /// from: public boolean isReset()
  ///
  /// Return whether this load has been reset.  That is, either the loader
  /// has not yet been started for the first time, or its \#reset()
  /// has been called.
  bool isReset() => jniAccessors.callMethodWithArgs(
      reference, _id_isReset, jni.JniType.booleanType, []).boolean;

  static final _id_startLoading =
      jniAccessors.getMethodIDOf(_classRef, "startLoading", "()V");

  /// from: public final void startLoading()
  ///
  /// This function will normally be called for you automatically by
  /// android.app.LoaderManager when the associated fragment/activity
  /// is being started.  When using a Loader with android.app.LoaderManager,
  /// you _must not_ call this method yourself, or you will conflict
  /// with its management of the Loader.
  ///
  /// Starts an asynchronous load of the Loader's data. When the result
  /// is ready the callbacks will be called on the process's main thread.
  /// If a previous load has been completed and is still valid
  /// the result may be passed to the callbacks immediately.
  /// The loader will monitor the source of
  /// the data set and may deliver future callbacks if the source changes.
  /// Calling \#stopLoading will stop the delivery of callbacks.
  ///
  /// This updates the Loader's internal state so that
  /// \#isStarted() and \#isReset() will return the correct
  /// values, and then calls the implementation's \#onStartLoading().
  ///
  /// Must be called from the process's main thread.
  void startLoading() => jniAccessors.callMethodWithArgs(
      reference, _id_startLoading, jni.JniType.voidType, []).check();

  static final _id_onStartLoading =
      jniAccessors.getMethodIDOf(_classRef, "onStartLoading", "()V");

  /// from: protected void onStartLoading()
  ///
  /// Subclasses must implement this to take care of loading their data,
  /// as per \#startLoading().  This is not called by clients directly,
  /// but as a result of a call to \#startLoading().
  void onStartLoading() => jniAccessors.callMethodWithArgs(
      reference, _id_onStartLoading, jni.JniType.voidType, []).check();

  static final _id_cancelLoad =
      jniAccessors.getMethodIDOf(_classRef, "cancelLoad", "()Z");

  /// from: public boolean cancelLoad()
  ///
  /// Attempt to cancel the current load task.
  /// Must be called on the main thread of the process.
  ///
  /// Cancellation is not an immediate operation, since the load is performed
  /// in a background thread.  If there is currently a load in progress, this
  /// method requests that the load be canceled, and notes this is the case;
  /// once the background thread has completed its work its remaining state
  /// will be cleared.  If another load request comes in during this time,
  /// it will be held until the canceled load is complete.
  ///@return Returns <tt>false</tt> if the task could not be canceled,
  /// typically because it has already completed normally, or
  /// because \#startLoading() hasn't been called; returns
  /// <tt>true</tt> otherwise.  When <tt>true</tt> is returned, the task
  /// is still running and the OnLoadCanceledListener will be called
  /// when the task completes.
  bool cancelLoad() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelLoad, jni.JniType.booleanType, []).boolean;

  static final _id_onCancelLoad =
      jniAccessors.getMethodIDOf(_classRef, "onCancelLoad", "()Z");

  /// from: protected boolean onCancelLoad()
  ///
  /// Subclasses must implement this to take care of requests to \#cancelLoad().
  /// This will always be called from the process's main thread.
  ///@return Returns <tt>false</tt> if the task could not be canceled,
  /// typically because it has already completed normally, or
  /// because \#startLoading() hasn't been called; returns
  /// <tt>true</tt> otherwise.  When <tt>true</tt> is returned, the task
  /// is still running and the OnLoadCanceledListener will be called
  /// when the task completes.
  bool onCancelLoad() => jniAccessors.callMethodWithArgs(
      reference, _id_onCancelLoad, jni.JniType.booleanType, []).boolean;

  static final _id_forceLoad =
      jniAccessors.getMethodIDOf(_classRef, "forceLoad", "()V");

  /// from: public void forceLoad()
  ///
  /// Force an asynchronous load. Unlike \#startLoading() this will ignore a previously
  /// loaded data set and load a new one.  This simply calls through to the
  /// implementation's \#onForceLoad().  You generally should only call this
  /// when the loader is started -- that is, \#isStarted() returns true.
  ///
  /// Must be called from the process's main thread.
  void forceLoad() => jniAccessors.callMethodWithArgs(
      reference, _id_forceLoad, jni.JniType.voidType, []).check();

  static final _id_onForceLoad =
      jniAccessors.getMethodIDOf(_classRef, "onForceLoad", "()V");

  /// from: protected void onForceLoad()
  ///
  /// Subclasses must implement this to take care of requests to \#forceLoad().
  /// This will always be called from the process's main thread.
  void onForceLoad() => jniAccessors.callMethodWithArgs(
      reference, _id_onForceLoad, jni.JniType.voidType, []).check();

  static final _id_stopLoading =
      jniAccessors.getMethodIDOf(_classRef, "stopLoading", "()V");

  /// from: public void stopLoading()
  ///
  /// This function will normally be called for you automatically by
  /// android.app.LoaderManager when the associated fragment/activity
  /// is being stopped.  When using a Loader with android.app.LoaderManager,
  /// you _must not_ call this method yourself, or you will conflict
  /// with its management of the Loader.
  ///
  /// Stops delivery of updates until the next time \#startLoading() is called.
  /// Implementations should _not_ invalidate their data at this point --
  /// clients are still free to use the last data the loader reported.  They will,
  /// however, typically stop reporting new data if the data changes; they can
  /// still monitor for changes, but must not report them to the client until and
  /// if \#startLoading() is later called.
  ///
  /// This updates the Loader's internal state so that
  /// \#isStarted() will return the correct
  /// value, and then calls the implementation's \#onStopLoading().
  ///
  /// Must be called from the process's main thread.
  void stopLoading() => jniAccessors.callMethodWithArgs(
      reference, _id_stopLoading, jni.JniType.voidType, []).check();

  static final _id_onStopLoading =
      jniAccessors.getMethodIDOf(_classRef, "onStopLoading", "()V");

  /// from: protected void onStopLoading()
  ///
  /// Subclasses must implement this to take care of stopping their loader,
  /// as per \#stopLoading().  This is not called by clients directly,
  /// but as a result of a call to \#stopLoading().
  /// This will always be called from the process's main thread.
  void onStopLoading() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopLoading, jni.JniType.voidType, []).check();

  static final _id_abandon =
      jniAccessors.getMethodIDOf(_classRef, "abandon", "()V");

  /// from: public void abandon()
  ///
  /// This function will normally be called for you automatically by
  /// android.app.LoaderManager when restarting a Loader.  When using
  /// a Loader with android.app.LoaderManager,
  /// you _must not_ call this method yourself, or you will conflict
  /// with its management of the Loader.
  ///
  /// Tell the Loader that it is being abandoned.  This is called prior
  /// to \#reset to have it retain its current data but not report
  /// any new data.
  void abandon() => jniAccessors.callMethodWithArgs(
      reference, _id_abandon, jni.JniType.voidType, []).check();

  static final _id_onAbandon =
      jniAccessors.getMethodIDOf(_classRef, "onAbandon", "()V");

  /// from: protected void onAbandon()
  ///
  /// Subclasses implement this to take care of being abandoned.  This is
  /// an optional intermediate state prior to \#onReset() -- it means that
  /// the client is no longer interested in any new data from the loader,
  /// so the loader must not report any further updates.  However, the
  /// loader _must_ keep its last reported data valid until the final
  /// \#onReset() happens.  You can retrieve the current abandoned
  /// state with \#isAbandoned.
  void onAbandon() => jniAccessors.callMethodWithArgs(
      reference, _id_onAbandon, jni.JniType.voidType, []).check();

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// This function will normally be called for you automatically by
  /// android.app.LoaderManager when destroying a Loader.  When using
  /// a Loader with android.app.LoaderManager,
  /// you _must not_ call this method yourself, or you will conflict
  /// with its management of the Loader.
  ///
  /// Resets the state of the Loader.  The Loader should at this point free
  /// all of its resources, since it may never be called again; however, its
  /// \#startLoading() may later be called at which point it must be
  /// able to start running again.
  ///
  /// This updates the Loader's internal state so that
  /// \#isStarted() and \#isReset() will return the correct
  /// values, and then calls the implementation's \#onReset().
  ///
  /// Must be called from the process's main thread.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_onReset =
      jniAccessors.getMethodIDOf(_classRef, "onReset", "()V");

  /// from: protected void onReset()
  ///
  /// Subclasses must implement this to take care of resetting their loader,
  /// as per \#reset().  This is not called by clients directly,
  /// but as a result of a call to \#reset().
  /// This will always be called from the process's main thread.
  void onReset() => jniAccessors.callMethodWithArgs(
      reference, _id_onReset, jni.JniType.voidType, []).check();

  static final _id_takeContentChanged =
      jniAccessors.getMethodIDOf(_classRef, "takeContentChanged", "()Z");

  /// from: public boolean takeContentChanged()
  ///
  /// Take the current flag indicating whether the loader's content had
  /// changed while it was stopped.  If it had, true is returned and the
  /// flag is cleared.
  bool takeContentChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_takeContentChanged, jni.JniType.booleanType, []).boolean;

  static final _id_commitContentChanged =
      jniAccessors.getMethodIDOf(_classRef, "commitContentChanged", "()V");

  /// from: public void commitContentChanged()
  ///
  /// Commit that you have actually fully processed a content change that
  /// was returned by \#takeContentChanged.  This is for use with
  /// \#rollbackContentChanged() to handle situations where a load
  /// is cancelled.  Call this when you have completely processed a load
  /// without it being cancelled.
  void commitContentChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_commitContentChanged, jni.JniType.voidType, []).check();

  static final _id_rollbackContentChanged =
      jniAccessors.getMethodIDOf(_classRef, "rollbackContentChanged", "()V");

  /// from: public void rollbackContentChanged()
  ///
  /// Report that you have abandoned the processing of a content change that
  /// was returned by \#takeContentChanged() and would like to rollback
  /// to the state where there is again a pending content change.  This is
  /// to handle the case where a data load due to a content change has been
  /// canceled before its data was delivered back to the loader.
  void rollbackContentChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_rollbackContentChanged, jni.JniType.voidType, []).check();

  static final _id_onContentChanged =
      jniAccessors.getMethodIDOf(_classRef, "onContentChanged", "()V");

  /// from: public void onContentChanged()
  ///
  /// Called when ForceLoadContentObserver detects a change.  The
  /// default implementation checks to see if the loader is currently started;
  /// if so, it simply calls \#forceLoad(); otherwise, it sets a flag
  /// so that \#takeContentChanged() returns true.
  ///
  /// Must be called from the process's main thread.
  void onContentChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_onContentChanged, jni.JniType.voidType, []).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Loader's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer A PrintWriter to which the dump is to be set.
  ///@param args Additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();
}

/// from: android.content.Loader$OnLoadCompleteListener
///
/// Interface that is implemented to discover when a Loader has finished
/// loading its data.  You do not normally need to implement this yourself;
/// it is used in the implementation of android.app.LoaderManager
/// to find out when a Loader it is managing has completed so that this can
/// be reported to its client.  This interface should only be used if a
/// Loader is not being used in conjunction with LoaderManager.
///@deprecated Use android.support.v4.content.Loader.OnLoadCompleteListener
class Loader_OnLoadCompleteListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/Loader\$OnLoadCompleteListener");
  Loader_OnLoadCompleteListener.fromRef(jni.JObject ref) : super.fromRef(ref);
}

/// from: android.content.Loader$OnLoadCanceledListener
///
/// Interface that is implemented to discover when a Loader has been canceled
/// before it finished loading its data.  You do not normally need to implement
/// this yourself; it is used in the implementation of android.app.LoaderManager
/// to find out when a Loader it is managing has been canceled so that it
/// can schedule the next Loader.  This interface should only be used if a
/// Loader is not being used in conjunction with LoaderManager.
///@deprecated Use android.support.v4.content.Loader.OnLoadCanceledListener
class Loader_OnLoadCanceledListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/Loader\$OnLoadCanceledListener");
  Loader_OnLoadCanceledListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onLoadCanceled = jniAccessors.getMethodIDOf(
      _classRef, "onLoadCanceled", "(Landroid/content/Loader;)V");

  /// from: public abstract void onLoadCanceled(android.content.Loader<D> loader)
  ///
  /// Called on the thread that created the Loader when the load is canceled.
  ///@param loader the loader that canceled the load
  void onLoadCanceled(Loader loader) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onLoadCanceled,
      jni.JniType.voidType,
      [loader.reference]).check();
}

/// from: android.content.Loader$ForceLoadContentObserver
///
/// An implementation of a ContentObserver that takes care of connecting
/// it to the Loader to have the loader re-load its data when the observer
/// is told it has changed.  You do not normally need to use this yourself;
/// it is used for you by CursorLoader to take care of executing
/// an update when the cursor's backing data changes.
///@deprecated Use android.support.v4.content.Loader.ForceLoadContentObserver
class Loader_ForceLoadContentObserver extends contentobserver_.ContentObserver {
  static final _classRef = jniAccessors
      .getClassOf("android/content/Loader\$ForceLoadContentObserver");
  Loader_ForceLoadContentObserver.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Loader_ForceLoadContentObserver.ctor1()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, []).object);

  static final _id_deliverSelfNotifications =
      jniAccessors.getMethodIDOf(_classRef, "deliverSelfNotifications", "()Z");

  /// from: public boolean deliverSelfNotifications()
  bool deliverSelfNotifications() => jniAccessors.callMethodWithArgs(reference,
      _id_deliverSelfNotifications, jni.JniType.booleanType, []).boolean;

  static final _id_onChange =
      jniAccessors.getMethodIDOf(_classRef, "onChange", "(Z)V");

  /// from: public void onChange(boolean selfChange)
  void onChange(bool selfChange) => jniAccessors.callMethodWithArgs(
      reference, _id_onChange, jni.JniType.voidType, [selfChange]).check();
}
