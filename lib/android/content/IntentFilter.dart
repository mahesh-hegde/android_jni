// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/PatternMatcher.dart" as patternmatcher_;

import "../net/Uri.dart" as uri_;

import "ContentResolver.dart" as contentresolver_;

import "Intent.dart" as intent_;

import "../util/Printer.dart" as printer_;

import "../os/Parcel.dart" as parcel_;

import "../util/AndroidException.dart" as androidexception_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.IntentFilter
///
/// Structured description of Intent values to be matched.  An IntentFilter can
/// match against actions, categories, and data (either via its type, scheme,
/// and/or path) in an Intent.  It also includes a "priority" value which is
/// used to order multiple matching filters.
///
/// IntentFilter objects are often created in XML as part of a package's
/// android.R.styleable\#AndroidManifest AndroidManifest.xml file,
/// using android.R.styleable\#AndroidManifestIntentFilter intent-filter
/// tags.
///
/// There are three Intent characteristics you can filter on: the
/// _action_, _data_, and _categories_.  For each of these
/// characteristics you can provide
/// multiple possible matching values (via \#addAction,
/// \#addDataType, \#addDataScheme, \#addDataSchemeSpecificPart,
/// \#addDataAuthority, \#addDataPath, and \#addCategory, respectively).
/// For actions, the field
/// will not be tested if no values have been given (treating it as a wildcard);
/// if no data characteristics are specified, however, then the filter will
/// only match intents that contain no data.
///
/// The data characteristic is
/// itself divided into three attributes: type, scheme, authority, and path.
/// Any that are
/// specified must match the contents of the Intent.  If you specify a scheme
/// but no type, only Intent that does not have a type (such as mailto:) will
/// match; a content: URI will never match because they always have a MIME type
/// that is supplied by their content provider.  Specifying a type with no scheme
/// has somewhat special meaning: it will match either an Intent with no URI
/// field, or an Intent with a content: or file: URI.  If you specify neither,
/// then only an Intent with no data or type will match.  To specify an authority,
/// you must also specify one or more schemes that it is associated with.
/// To specify a path, you also must specify both one or more authorities and
/// one or more schemes it is associated with.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about how to create and resolve intents, read the
/// <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
/// developer guide.
///
/// </div>
///
/// <h3>Filter Rules</h3>
/// A match is based on the following rules.  Note that
/// for an IntentFilter to match an Intent, three conditions must hold:
/// the <strong>action</strong> and <strong>category</strong> must match, and
/// the data (both the <strong>data type</strong> and
/// <strong>data scheme+authority+path</strong> if specified) must match
/// (see \#match(ContentResolver, Intent, boolean, String) for more details
/// on how the data fields match).
///
/// <strong>Action</strong> matches if any of the given values match the
/// Intent action; if the filter specifies no actions, then it will only match
/// Intents that do not contain an action.
///
/// <strong>Data Type</strong> matches if any of the given values match the
/// Intent type.  The Intent
/// type is determined by calling Intent\#resolveType.  A wildcard can be
/// used for the MIME sub-type, in both the Intent and IntentFilter, so that the
/// type "audio/*" will match "audio/mpeg", "audio/aiff", "audio/*", etc.
/// _Note that MIME type matching here is __case sensitive__, unlike
/// formal RFC MIME types!_  You should thus always use lower case letters
/// for your MIME types.
///
/// <strong>Data Scheme</strong> matches if any of the given values match the
/// Intent data's scheme.
/// The Intent scheme is determined by calling Intent\#getData
/// and android.net.Uri\#getScheme on that URI.
/// _Note that scheme matching here is __case sensitive__, unlike
/// formal RFC schemes!_  You should thus always use lower case letters
/// for your schemes.
///
/// <strong>Data Scheme Specific Part</strong> matches if any of the given values match
/// the Intent's data scheme specific part _and_ one of the data schemes in the filter
/// has matched the Intent, _or_ no scheme specific parts were supplied in the filter.
/// The Intent scheme specific part is determined by calling
/// Intent\#getData and android.net.Uri\#getSchemeSpecificPart on that URI.
/// _Note that scheme specific part matching is __case sensitive__._
///
/// <strong>Data Authority</strong> matches if any of the given values match
/// the Intent's data authority _and_ one of the data schemes in the filter
/// has matched the Intent, _or_ no authories were supplied in the filter.
/// The Intent authority is determined by calling
/// Intent\#getData and android.net.Uri\#getAuthority on that URI.
/// _Note that authority matching here is __case sensitive__, unlike
/// formal RFC host names!_  You should thus always use lower case letters
/// for your authority.
///
/// <strong>Data Path</strong> matches if any of the given values match the
/// Intent's data path _and_ both a scheme and authority in the filter
/// has matched against the Intent, _or_ no paths were supplied in the
/// filter.  The Intent authority is determined by calling
/// Intent\#getData and android.net.Uri\#getPath on that URI.
///
/// <strong>Categories</strong> match if _all_ of the categories in
/// the Intent match categories given in the filter.  Extra categories in the
/// filter that are not in the Intent will not cause the match to fail.  Note
/// that unlike the action, an IntentFilter with no categories
/// will only match an Intent that does not have any categories.
class IntentFilter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/IntentFilter");
  IntentFilter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.IntentFilter> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int MATCH_ADJUSTMENT_MASK
  ///
  /// The part of a match constant that applies a quality adjustment to the
  /// basic category of match.  The value \#MATCH_ADJUSTMENT_NORMAL
  /// is no adjustment; higher numbers than that improve the quality, while
  /// lower numbers reduce it.
  static const MATCH_ADJUSTMENT_MASK = 65535;

  /// from: static public final int MATCH_ADJUSTMENT_NORMAL
  ///
  /// Quality adjustment applied to the category of match that signifies
  /// the default, base value; higher numbers improve the quality while
  /// lower numbers reduce it.
  static const MATCH_ADJUSTMENT_NORMAL = 32768;

  /// from: static public final int MATCH_CATEGORY_EMPTY
  ///
  /// The filter matched an intent that had no data specified.
  static const MATCH_CATEGORY_EMPTY = 1048576;

  /// from: static public final int MATCH_CATEGORY_HOST
  ///
  /// The filter matched an intent with the same data URI scheme and
  /// authority host.
  static const MATCH_CATEGORY_HOST = 3145728;

  /// from: static public final int MATCH_CATEGORY_MASK
  ///
  /// The part of a match constant that describes the category of match
  /// that occurred.  May be either \#MATCH_CATEGORY_EMPTY,
  /// \#MATCH_CATEGORY_SCHEME, \#MATCH_CATEGORY_SCHEME_SPECIFIC_PART,
  /// \#MATCH_CATEGORY_HOST, \#MATCH_CATEGORY_PORT,
  /// \#MATCH_CATEGORY_PATH, or \#MATCH_CATEGORY_TYPE.  Higher
  /// values indicate a better match.
  static const MATCH_CATEGORY_MASK = 268369920;

  /// from: static public final int MATCH_CATEGORY_PATH
  ///
  /// The filter matched an intent with the same data URI scheme,
  /// authority, and path.
  static const MATCH_CATEGORY_PATH = 5242880;

  /// from: static public final int MATCH_CATEGORY_PORT
  ///
  /// The filter matched an intent with the same data URI scheme and
  /// authority host and port.
  static const MATCH_CATEGORY_PORT = 4194304;

  /// from: static public final int MATCH_CATEGORY_SCHEME
  ///
  /// The filter matched an intent with the same data URI scheme.
  static const MATCH_CATEGORY_SCHEME = 2097152;

  /// from: static public final int MATCH_CATEGORY_SCHEME_SPECIFIC_PART
  ///
  /// The filter matched an intent with the same data URI scheme and
  /// scheme specific part.
  static const MATCH_CATEGORY_SCHEME_SPECIFIC_PART = 5767168;

  /// from: static public final int MATCH_CATEGORY_TYPE
  ///
  /// The filter matched an intent with the same data MIME type.
  static const MATCH_CATEGORY_TYPE = 6291456;

  /// from: static public final int NO_MATCH_ACTION
  ///
  /// The filter didn't match due to different actions.
  static const NO_MATCH_ACTION = -3;

  /// from: static public final int NO_MATCH_CATEGORY
  ///
  /// The filter didn't match because it required one or more categories
  /// that were not in the Intent.
  static const NO_MATCH_CATEGORY = -4;

  /// from: static public final int NO_MATCH_DATA
  ///
  /// The filter didn't match due to different data URIs.
  static const NO_MATCH_DATA = -2;

  /// from: static public final int NO_MATCH_TYPE
  ///
  /// The filter didn't match due to different MIME types.
  static const NO_MATCH_TYPE = -1;

  /// from: static public final int SYSTEM_HIGH_PRIORITY
  ///
  /// The filter \#setPriority value at which system high-priority
  /// receivers are placed; that is, receivers that should execute before
  /// application code. Applications should never use filters with this or
  /// higher priorities.
  ///@see \#setPriority
  static const SYSTEM_HIGH_PRIORITY = 1000;

  /// from: static public final int SYSTEM_LOW_PRIORITY
  ///
  /// The filter \#setPriority value at which system low-priority
  /// receivers are placed; that is, receivers that should execute after
  /// application code. Applications should never use filters with this or
  /// lower priorities.
  ///@see \#setPriority
  static const SYSTEM_LOW_PRIORITY = -1000;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// New empty IntentFilter.
  IntentFilter()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// New IntentFilter that matches a single action with no data.  If
  /// no data characteristics are subsequently specified, then the
  /// filter will only match intents that contain no data.
  ///@param action The action to match, such as Intent.ACTION_MAIN.
  IntentFilter.ctor1(jni.JniString action)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [action.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String action, java.lang.String dataType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// New IntentFilter that matches a single action and data type.
  ///
  /// _Note: MIME type matching in the Android framework is
  /// case-sensitive, unlike formal RFC MIME types.  As a result,
  /// you should always write your MIME types with lower case letters,
  /// and any MIME types you receive from outside of Android should be
  /// converted to lower case before supplying them here._
  ///
  ///
  /// Throws MalformedMimeTypeException if the given MIME type is
  /// not syntactically correct.
  ///@param action The action to match, such as Intent.ACTION_VIEW.
  ///@param dataType The type to match, such as "vnd.android.cursor.dir/person".
  IntentFilter.ctor2(jni.JniString action, jni.JniString dataType)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [action.reference, dataType.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/IntentFilter;)V");

  /// from: public void <init>(android.content.IntentFilter o)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// New IntentFilter containing a copy of an existing filter.
  ///@param o The original filter to copy.
  IntentFilter.ctor3(IntentFilter o)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [o.reference]).object);

  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/content/IntentFilter;");

  /// from: static public android.content.IntentFilter create(java.lang.String action, java.lang.String dataType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new IntentFilter instance with a specified action and MIME
  /// type, where you know the MIME type is correctly formatted.  This catches
  /// the MalformedMimeTypeException exception that the constructor
  /// can call and turns it into a runtime exception.
  ///@param action The action to match, such as Intent.ACTION_VIEW.
  ///@param dataType The type to match, such as "vnd.android.cursor.dir/person".
  ///@return A new IntentFilter for the given action and type.
  ///@see \#IntentFilter(String, String)
  static IntentFilter create(jni.JniString action, jni.JniString dataType) =>
      IntentFilter.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_create,
          jni.JniType.objectType,
          [action.reference, dataType.reference]).object);

  static final _id_setPriority =
      jniAccessors.getMethodIDOf(_classRef, "setPriority", "(I)V");

  /// from: public final void setPriority(int priority)
  ///
  /// Modify priority of this filter.  This only affects receiver filters.
  /// The priority of activity filters are set in XML and cannot be changed
  /// programatically. The default priority is 0. Positive values will be
  /// before the default, lower values will be after it. Applications should
  /// use a value that is larger than \#SYSTEM_LOW_PRIORITY and
  /// smaller than \#SYSTEM_HIGH_PRIORITY .
  ///@param priority The new priority value.
  ///@see \#getPriority
  ///@see \#SYSTEM_LOW_PRIORITY
  ///@see \#SYSTEM_HIGH_PRIORITY
  void setPriority(int priority) => jniAccessors.callMethodWithArgs(
      reference, _id_setPriority, jni.JniType.voidType, [priority]).check();

  static final _id_getPriority =
      jniAccessors.getMethodIDOf(_classRef, "getPriority", "()I");

  /// from: public final int getPriority()
  ///
  /// Return the priority of this filter.
  ///@return The priority of the filter.
  ///@see \#setPriority
  int getPriority() => jniAccessors.callMethodWithArgs(
      reference, _id_getPriority, jni.JniType.intType, []).integer;

  static final _id_addAction = jniAccessors.getMethodIDOf(
      _classRef, "addAction", "(Ljava/lang/String;)V");

  /// from: public final void addAction(java.lang.String action)
  ///
  /// Add a new Intent action to match against.  If any actions are included
  /// in the filter, then an Intent's action must be one of those values for
  /// it to match.  If no actions are included, the Intent action is ignored.
  ///@param action Name of the action to match, such as Intent.ACTION_VIEW.
  void addAction(jni.JniString action) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addAction,
      jni.JniType.voidType,
      [action.reference]).check();

  static final _id_countActions =
      jniAccessors.getMethodIDOf(_classRef, "countActions", "()I");

  /// from: public final int countActions()
  ///
  /// Return the number of actions in the filter.
  int countActions() => jniAccessors.callMethodWithArgs(
      reference, _id_countActions, jni.JniType.intType, []).integer;

  static final _id_getAction = jniAccessors.getMethodIDOf(
      _classRef, "getAction", "(I)Ljava/lang/String;");

  /// from: public final java.lang.String getAction(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an action in the filter.
  jni.JniString getAction(int index) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAction, jni.JniType.objectType, [index]).object);

  static final _id_hasAction = jniAccessors.getMethodIDOf(
      _classRef, "hasAction", "(Ljava/lang/String;)Z");

  /// from: public final boolean hasAction(java.lang.String action)
  ///
  /// Is the given action included in the filter?  Note that if the filter
  /// does not include any actions, false will _always_ be returned.
  ///@param action The action to look for.
  ///@return True if the action is explicitly mentioned in the filter.
  bool hasAction(jni.JniString action) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasAction,
      jni.JniType.booleanType,
      [action.reference]).boolean;

  static final _id_matchAction = jniAccessors.getMethodIDOf(
      _classRef, "matchAction", "(Ljava/lang/String;)Z");

  /// from: public final boolean matchAction(java.lang.String action)
  ///
  /// Match this filter against an Intent's action.  If the filter does not
  /// specify any actions, the match will always fail.
  ///@param action The desired action to look for.
  ///@return True if the action is listed in the filter.
  bool matchAction(jni.JniString action) => jniAccessors.callMethodWithArgs(
      reference,
      _id_matchAction,
      jni.JniType.booleanType,
      [action.reference]).boolean;

  static final _id_actionsIterator = jniAccessors.getMethodIDOf(
      _classRef, "actionsIterator", "()Ljava/util/Iterator;");

  /// from: public final java.util.Iterator<java.lang.String> actionsIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's actions.  If there are no actions,
  /// returns null.
  jni.JniObject actionsIterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_actionsIterator, jni.JniType.objectType, []).object);

  static final _id_addDataType = jniAccessors.getMethodIDOf(
      _classRef, "addDataType", "(Ljava/lang/String;)V");

  /// from: public final void addDataType(java.lang.String type)
  ///
  /// Add a new Intent data type to match against.  If any types are
  /// included in the filter, then an Intent's data must be _either_
  /// one of these types _or_ a matching scheme.  If no data types
  /// are included, then an Intent will only match if it specifies no data.
  ///
  /// _Note: MIME type matching in the Android framework is
  /// case-sensitive, unlike formal RFC MIME types.  As a result,
  /// you should always write your MIME types with lower case letters,
  /// and any MIME types you receive from outside of Android should be
  /// converted to lower case before supplying them here._
  ///
  ///
  /// Throws MalformedMimeTypeException if the given MIME type is
  /// not syntactically correct.
  ///@param type Name of the data type to match, such as "vnd.android.cursor.dir/person".
  ///@see \#matchData
  void addDataType(jni.JniString type) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addDataType,
      jni.JniType.voidType,
      [type.reference]).check();

  static final _id_hasDataType = jniAccessors.getMethodIDOf(
      _classRef, "hasDataType", "(Ljava/lang/String;)Z");

  /// from: public final boolean hasDataType(java.lang.String type)
  ///
  /// Is the given data type included in the filter?  Note that if the filter
  /// does not include any type, false will _always_ be returned.
  ///@param type The data type to look for.
  ///@return True if the type is explicitly mentioned in the filter.
  bool hasDataType(jni.JniString type) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasDataType,
      jni.JniType.booleanType,
      [type.reference]).boolean;

  static final _id_countDataTypes =
      jniAccessors.getMethodIDOf(_classRef, "countDataTypes", "()I");

  /// from: public final int countDataTypes()
  ///
  /// Return the number of data types in the filter.
  int countDataTypes() => jniAccessors.callMethodWithArgs(
      reference, _id_countDataTypes, jni.JniType.intType, []).integer;

  static final _id_getDataType = jniAccessors.getMethodIDOf(
      _classRef, "getDataType", "(I)Ljava/lang/String;");

  /// from: public final java.lang.String getDataType(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data type in the filter.
  jni.JniString getDataType(int index) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDataType, jni.JniType.objectType, [index]).object);

  static final _id_typesIterator = jniAccessors.getMethodIDOf(
      _classRef, "typesIterator", "()Ljava/util/Iterator;");

  /// from: public final java.util.Iterator<java.lang.String> typesIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data types.
  jni.JniObject typesIterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_typesIterator, jni.JniType.objectType, []).object);

  static final _id_addDataScheme = jniAccessors.getMethodIDOf(
      _classRef, "addDataScheme", "(Ljava/lang/String;)V");

  /// from: public final void addDataScheme(java.lang.String scheme)
  ///
  /// Add a new Intent data scheme to match against.  If any schemes are
  /// included in the filter, then an Intent's data must be _either_
  /// one of these schemes _or_ a matching data type.  If no schemes
  /// are included, then an Intent will match only if it includes no data.
  ///
  /// _Note: scheme matching in the Android framework is
  /// case-sensitive, unlike formal RFC schemes.  As a result,
  /// you should always write your schemes with lower case letters,
  /// and any schemes you receive from outside of Android should be
  /// converted to lower case before supplying them here._
  ///
  ///@param scheme Name of the scheme to match, such as "http".
  ///@see \#matchData
  void addDataScheme(jni.JniString scheme) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addDataScheme,
      jni.JniType.voidType,
      [scheme.reference]).check();

  static final _id_countDataSchemes =
      jniAccessors.getMethodIDOf(_classRef, "countDataSchemes", "()I");

  /// from: public final int countDataSchemes()
  ///
  /// Return the number of data schemes in the filter.
  int countDataSchemes() => jniAccessors.callMethodWithArgs(
      reference, _id_countDataSchemes, jni.JniType.intType, []).integer;

  static final _id_getDataScheme = jniAccessors.getMethodIDOf(
      _classRef, "getDataScheme", "(I)Ljava/lang/String;");

  /// from: public final java.lang.String getDataScheme(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data scheme in the filter.
  jni.JniString getDataScheme(int index) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDataScheme, jni.JniType.objectType, [index]).object);

  static final _id_hasDataScheme = jniAccessors.getMethodIDOf(
      _classRef, "hasDataScheme", "(Ljava/lang/String;)Z");

  /// from: public final boolean hasDataScheme(java.lang.String scheme)
  ///
  /// Is the given data scheme included in the filter?  Note that if the
  /// filter does not include any scheme, false will _always_ be
  /// returned.
  ///@param scheme The data scheme to look for.
  ///@return True if the scheme is explicitly mentioned in the filter.
  bool hasDataScheme(jni.JniString scheme) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasDataScheme,
      jni.JniType.booleanType,
      [scheme.reference]).boolean;

  static final _id_schemesIterator = jniAccessors.getMethodIDOf(
      _classRef, "schemesIterator", "()Ljava/util/Iterator;");

  /// from: public final java.util.Iterator<java.lang.String> schemesIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data schemes.
  jni.JniObject schemesIterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_schemesIterator, jni.JniType.objectType, []).object);

  static final _id_addDataSchemeSpecificPart = jniAccessors.getMethodIDOf(
      _classRef, "addDataSchemeSpecificPart", "(Ljava/lang/String;I)V");

  /// from: public final void addDataSchemeSpecificPart(java.lang.String ssp, int type)
  ///
  /// Add a new Intent data "scheme specific part" to match against.  The filter must
  /// include one or more schemes (via \#addDataScheme) for the
  /// scheme specific part to be considered.  If any scheme specific parts are
  /// included in the filter, then an Intent's data must match one of
  /// them.  If no scheme specific parts are included, then only the scheme must match.
  ///
  /// The "scheme specific part" that this matches against is the string returned
  /// by android.net.Uri\#getSchemeSpecificPart() Uri.getSchemeSpecificPart.
  /// For Uris that contain a path, this kind of matching is not generally of interest,
  /// since \#addDataAuthority(String, String) and
  /// \#addDataPath(String, int) can provide a better mechanism for matching
  /// them.  However, for Uris that do not contain a path, the authority and path
  /// are empty, so this is the only way to match against the non-scheme part.
  ///
  ///@param ssp Either a raw string that must exactly match the scheme specific part
  /// path, or a simple pattern, depending on <var>type</var>.
  ///@param type Determines how <var>ssp</var> will be compared to
  /// determine a match: either PatternMatcher\#PATTERN_LITERAL,
  /// PatternMatcher\#PATTERN_PREFIX, or
  /// PatternMatcher\#PATTERN_SIMPLE_GLOB.
  ///@see \#matchData
  ///@see \#addDataScheme
  void addDataSchemeSpecificPart(jni.JniString ssp, int type) =>
      jniAccessors.callMethodWithArgs(reference, _id_addDataSchemeSpecificPart,
          jni.JniType.voidType, [ssp.reference, type]).check();

  static final _id_countDataSchemeSpecificParts = jniAccessors.getMethodIDOf(
      _classRef, "countDataSchemeSpecificParts", "()I");

  /// from: public final int countDataSchemeSpecificParts()
  ///
  /// Return the number of data scheme specific parts in the filter.
  int countDataSchemeSpecificParts() => jniAccessors.callMethodWithArgs(
      reference,
      _id_countDataSchemeSpecificParts,
      jni.JniType.intType, []).integer;

  static final _id_getDataSchemeSpecificPart = jniAccessors.getMethodIDOf(
      _classRef, "getDataSchemeSpecificPart", "(I)Landroid/os/PatternMatcher;");

  /// from: public final android.os.PatternMatcher getDataSchemeSpecificPart(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data scheme specific part in the filter.
  patternmatcher_.PatternMatcher getDataSchemeSpecificPart(int index) =>
      patternmatcher_.PatternMatcher.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDataSchemeSpecificPart,
          jni.JniType.objectType,
          [index]).object);

  static final _id_hasDataSchemeSpecificPart = jniAccessors.getMethodIDOf(
      _classRef, "hasDataSchemeSpecificPart", "(Ljava/lang/String;)Z");

  /// from: public final boolean hasDataSchemeSpecificPart(java.lang.String data)
  ///
  /// Is the given data scheme specific part included in the filter?  Note that if the
  /// filter does not include any scheme specific parts, false will _always_ be
  /// returned.
  ///@param data The scheme specific part that is being looked for.
  ///@return Returns true if the data string matches a scheme specific part listed in the
  ///         filter.
  bool hasDataSchemeSpecificPart(jni.JniString data) =>
      jniAccessors.callMethodWithArgs(reference, _id_hasDataSchemeSpecificPart,
          jni.JniType.booleanType, [data.reference]).boolean;

  static final _id_schemeSpecificPartsIterator = jniAccessors.getMethodIDOf(
      _classRef, "schemeSpecificPartsIterator", "()Ljava/util/Iterator;");

  /// from: public final java.util.Iterator<android.os.PatternMatcher> schemeSpecificPartsIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data scheme specific parts.
  jni.JniObject schemeSpecificPartsIterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_schemeSpecificPartsIterator, jni.JniType.objectType, []).object);

  static final _id_addDataAuthority = jniAccessors.getMethodIDOf(
      _classRef, "addDataAuthority", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public final void addDataAuthority(java.lang.String host, java.lang.String port)
  ///
  /// Add a new Intent data authority to match against.  The filter must
  /// include one or more schemes (via \#addDataScheme) for the
  /// authority to be considered.  If any authorities are
  /// included in the filter, then an Intent's data must match one of
  /// them.  If no authorities are included, then only the scheme must match.
  ///
  /// _Note: host name in the Android framework is
  /// case-sensitive, unlike formal RFC host names.  As a result,
  /// you should always write your host names with lower case letters,
  /// and any host names you receive from outside of Android should be
  /// converted to lower case before supplying them here._
  ///
  ///@param host The host part of the authority to match.  May start with a
  ///             single '*' to wildcard the front of the host name.
  ///@param port Optional port part of the authority to match.  If null, any
  ///             port is allowed.
  ///@see \#matchData
  ///@see \#addDataScheme
  void addDataAuthority(jni.JniString host, jni.JniString port) =>
      jniAccessors.callMethodWithArgs(reference, _id_addDataAuthority,
          jni.JniType.voidType, [host.reference, port.reference]).check();

  static final _id_countDataAuthorities =
      jniAccessors.getMethodIDOf(_classRef, "countDataAuthorities", "()I");

  /// from: public final int countDataAuthorities()
  ///
  /// Return the number of data authorities in the filter.
  int countDataAuthorities() => jniAccessors.callMethodWithArgs(
      reference, _id_countDataAuthorities, jni.JniType.intType, []).integer;

  static final _id_getDataAuthority = jniAccessors.getMethodIDOf(_classRef,
      "getDataAuthority", "(I)Landroid/content/IntentFilter\$AuthorityEntry;");

  /// from: public final android.content.IntentFilter.AuthorityEntry getDataAuthority(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data authority in the filter.
  IntentFilter_AuthorityEntry getDataAuthority(int index) =>
      IntentFilter_AuthorityEntry.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDataAuthority,
          jni.JniType.objectType,
          [index]).object);

  static final _id_hasDataAuthority = jniAccessors.getMethodIDOf(
      _classRef, "hasDataAuthority", "(Landroid/net/Uri;)Z");

  /// from: public final boolean hasDataAuthority(android.net.Uri data)
  ///
  /// Is the given data authority included in the filter?  Note that if the
  /// filter does not include any authorities, false will _always_ be
  /// returned.
  ///@param data The data whose authority is being looked for.
  ///@return Returns true if the data string matches an authority listed in the
  ///         filter.
  bool hasDataAuthority(uri_.Uri data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasDataAuthority,
      jni.JniType.booleanType,
      [data.reference]).boolean;

  static final _id_authoritiesIterator = jniAccessors.getMethodIDOf(
      _classRef, "authoritiesIterator", "()Ljava/util/Iterator;");

  /// from: public final java.util.Iterator<android.content.IntentFilter.AuthorityEntry> authoritiesIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data authorities.
  jni.JniObject authoritiesIterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_authoritiesIterator, jni.JniType.objectType, []).object);

  static final _id_addDataPath = jniAccessors.getMethodIDOf(
      _classRef, "addDataPath", "(Ljava/lang/String;I)V");

  /// from: public final void addDataPath(java.lang.String path, int type)
  ///
  /// Add a new Intent data path to match against.  The filter must
  /// include one or more schemes (via \#addDataScheme) _and_
  /// one or more authorities (via \#addDataAuthority) for the
  /// path to be considered.  If any paths are
  /// included in the filter, then an Intent's data must match one of
  /// them.  If no paths are included, then only the scheme/authority must
  /// match.
  ///
  /// The path given here can either be a literal that must directly
  /// match or match against a prefix, or it can be a simple globbing pattern.
  /// If the latter, you can use '*' anywhere in the pattern to match zero
  /// or more instances of the previous character, '.' as a wildcard to match
  /// any character, and '\' to escape the next character.
  ///@param path Either a raw string that must exactly match the file
  /// path, or a simple pattern, depending on <var>type</var>.
  ///@param type Determines how <var>path</var> will be compared to
  /// determine a match: either PatternMatcher\#PATTERN_LITERAL,
  /// PatternMatcher\#PATTERN_PREFIX, or
  /// PatternMatcher\#PATTERN_SIMPLE_GLOB.
  ///@see \#matchData
  ///@see \#addDataScheme
  ///@see \#addDataAuthority
  void addDataPath(jni.JniString path, int type) =>
      jniAccessors.callMethodWithArgs(reference, _id_addDataPath,
          jni.JniType.voidType, [path.reference, type]).check();

  static final _id_countDataPaths =
      jniAccessors.getMethodIDOf(_classRef, "countDataPaths", "()I");

  /// from: public final int countDataPaths()
  ///
  /// Return the number of data paths in the filter.
  int countDataPaths() => jniAccessors.callMethodWithArgs(
      reference, _id_countDataPaths, jni.JniType.intType, []).integer;

  static final _id_getDataPath = jniAccessors.getMethodIDOf(
      _classRef, "getDataPath", "(I)Landroid/os/PatternMatcher;");

  /// from: public final android.os.PatternMatcher getDataPath(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data path in the filter.
  patternmatcher_.PatternMatcher getDataPath(int index) =>
      patternmatcher_.PatternMatcher.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDataPath, jni.JniType.objectType, [index]).object);

  static final _id_hasDataPath = jniAccessors.getMethodIDOf(
      _classRef, "hasDataPath", "(Ljava/lang/String;)Z");

  /// from: public final boolean hasDataPath(java.lang.String data)
  ///
  /// Is the given data path included in the filter?  Note that if the
  /// filter does not include any paths, false will _always_ be
  /// returned.
  ///@param data The data path to look for.  This is without the scheme
  ///             prefix.
  ///@return True if the data string matches a path listed in the
  ///         filter.
  bool hasDataPath(jni.JniString data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasDataPath,
      jni.JniType.booleanType,
      [data.reference]).boolean;

  static final _id_pathsIterator = jniAccessors.getMethodIDOf(
      _classRef, "pathsIterator", "()Ljava/util/Iterator;");

  /// from: public final java.util.Iterator<android.os.PatternMatcher> pathsIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data paths.
  jni.JniObject pathsIterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_pathsIterator, jni.JniType.objectType, []).object);

  static final _id_matchDataAuthority = jniAccessors.getMethodIDOf(
      _classRef, "matchDataAuthority", "(Landroid/net/Uri;)I");

  /// from: public final int matchDataAuthority(android.net.Uri data)
  ///
  /// Match this intent filter against the given Intent data.  This ignores
  /// the data scheme -- unlike \#matchData, the authority will match
  /// regardless of whether there is a matching scheme.
  ///@param data The data whose authority is being looked for.
  ///@return Returns either \#MATCH_CATEGORY_HOST,
  /// \#MATCH_CATEGORY_PORT, \#NO_MATCH_DATA.
  int matchDataAuthority(uri_.Uri data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_matchDataAuthority,
      jni.JniType.intType,
      [data.reference]).integer;

  static final _id_matchData = jniAccessors.getMethodIDOf(_classRef,
      "matchData", "(Ljava/lang/String;Ljava/lang/String;Landroid/net/Uri;)I");

  /// from: public final int matchData(java.lang.String type, java.lang.String scheme, android.net.Uri data)
  ///
  /// Match this filter against an Intent's data (type, scheme and path). If
  /// the filter does not specify any types and does not specify any
  /// schemes/paths, the match will only succeed if the intent does not
  /// also specify a type or data.  If the filter does not specify any schemes,
  /// it will implicitly match intents with no scheme, or the schemes "content:"
  /// or "file:" (basically performing a MIME-type only match).  If the filter
  /// does not specify any MIME types, the Intent also must not specify a MIME
  /// type.
  ///
  /// Be aware that to match against an authority, you must also specify a base
  /// scheme the authority is in.  To match against a data path, both a scheme
  /// and authority must be specified.  If the filter does not specify any
  /// types or schemes that it matches against, it is considered to be empty
  /// (any authority or data path given is ignored, as if it were empty as
  /// well).
  ///
  /// _Note: MIME type, Uri scheme, and host name matching in the
  /// Android framework is case-sensitive, unlike the formal RFC definitions.
  /// As a result, you should always write these elements with lower case letters,
  /// and normalize any MIME types or Uris you receive from
  /// outside of Android to ensure these elements are lower case before
  /// supplying them here._
  ///
  ///@param type The desired data type to look for, as returned by
  ///             Intent.resolveType().
  ///@param scheme The desired data scheme to look for, as returned by
  ///               Intent.getScheme().
  ///@param data The full data string to match against, as supplied in
  ///             Intent.data.
  ///@return Returns either a valid match constant (a combination of
  /// \#MATCH_CATEGORY_MASK and \#MATCH_ADJUSTMENT_MASK),
  /// or one of the error codes \#NO_MATCH_TYPE if the type didn't match
  /// or \#NO_MATCH_DATA if the scheme/path didn't match.
  ///@see \#match
  int matchData(jni.JniString type, jni.JniString scheme, uri_.Uri data) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_matchData,
          jni.JniType.intType,
          [type.reference, scheme.reference, data.reference]).integer;

  static final _id_addCategory = jniAccessors.getMethodIDOf(
      _classRef, "addCategory", "(Ljava/lang/String;)V");

  /// from: public final void addCategory(java.lang.String category)
  ///
  /// Add a new Intent category to match against.  The semantics of
  /// categories is the opposite of actions -- an Intent includes the
  /// categories that it requires, all of which must be included in the
  /// filter in order to match.  In other words, adding a category to the
  /// filter has no impact on matching unless that category is specified in
  /// the intent.
  ///@param category Name of category to match, such as Intent.CATEGORY_EMBED.
  void addCategory(jni.JniString category) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addCategory,
      jni.JniType.voidType,
      [category.reference]).check();

  static final _id_countCategories =
      jniAccessors.getMethodIDOf(_classRef, "countCategories", "()I");

  /// from: public final int countCategories()
  ///
  /// Return the number of categories in the filter.
  int countCategories() => jniAccessors.callMethodWithArgs(
      reference, _id_countCategories, jni.JniType.intType, []).integer;

  static final _id_getCategory = jniAccessors.getMethodIDOf(
      _classRef, "getCategory", "(I)Ljava/lang/String;");

  /// from: public final java.lang.String getCategory(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a category in the filter.
  jni.JniString getCategory(int index) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCategory, jni.JniType.objectType, [index]).object);

  static final _id_hasCategory = jniAccessors.getMethodIDOf(
      _classRef, "hasCategory", "(Ljava/lang/String;)Z");

  /// from: public final boolean hasCategory(java.lang.String category)
  ///
  /// Is the given category included in the filter?
  ///@param category The category that the filter supports.
  ///@return True if the category is explicitly mentioned in the filter.
  bool hasCategory(jni.JniString category) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasCategory,
      jni.JniType.booleanType,
      [category.reference]).boolean;

  static final _id_categoriesIterator = jniAccessors.getMethodIDOf(
      _classRef, "categoriesIterator", "()Ljava/util/Iterator;");

  /// from: public final java.util.Iterator<java.lang.String> categoriesIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's categories.
  ///@return Iterator if this filter has categories or {@code null} if none.
  jni.JniObject categoriesIterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_categoriesIterator, jni.JniType.objectType, []).object);

  static final _id_matchCategories = jniAccessors.getMethodIDOf(
      _classRef, "matchCategories", "(Ljava/util/Set;)Ljava/lang/String;");

  /// from: public final java.lang.String matchCategories(java.util.Set<java.lang.String> categories)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Match this filter against an Intent's categories.  Each category in
  /// the Intent must be specified by the filter; if any are not in the
  /// filter, the match fails.
  ///@param categories The categories included in the intent, as returned by
  ///                   Intent.getCategories().
  ///@return If all categories match (success), null; else the name of the
  ///         first category that didn't match.
  jni.JniString matchCategories(jni.JniObject categories) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_matchCategories,
          jni.JniType.objectType,
          [categories.reference]).object);

  static final _id_match = jniAccessors.getMethodIDOf(_classRef, "match",
      "(Landroid/content/ContentResolver;Landroid/content/Intent;ZLjava/lang/String;)I");

  /// from: public final int match(android.content.ContentResolver resolver, android.content.Intent intent, boolean resolve, java.lang.String logTag)
  ///
  /// Test whether this filter matches the given <var>intent</var>.
  ///@param intent The Intent to compare against.
  ///@param resolve If true, the intent's type will be resolved by calling
  ///                Intent.resolveType(); otherwise a simple match against
  ///                Intent.type will be performed.
  ///@param logTag Tag to use in debugging messages.
  ///@return Returns either a valid match constant (a combination of
  /// \#MATCH_CATEGORY_MASK and \#MATCH_ADJUSTMENT_MASK),
  /// or one of the error codes \#NO_MATCH_TYPE if the type didn't match,
  /// \#NO_MATCH_DATA if the scheme/path didn't match,
  /// \#NO_MATCH_ACTION if the action didn't match, or
  /// \#NO_MATCH_CATEGORY if one or more categories didn't match.
  ///@see \#match(String, String, String, android.net.Uri , Set, String)
  int match(contentresolver_.ContentResolver resolver, intent_.Intent intent,
          bool resolve, jni.JniString logTag) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_match, jni.JniType.intType, [
        resolver.reference,
        intent.reference,
        resolve,
        logTag.reference
      ]).integer;

  static final _id_match1 = jniAccessors.getMethodIDOf(_classRef, "match",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/net/Uri;Ljava/util/Set;Ljava/lang/String;)I");

  /// from: public final int match(java.lang.String action, java.lang.String type, java.lang.String scheme, android.net.Uri data, java.util.Set<java.lang.String> categories, java.lang.String logTag)
  ///
  /// Test whether this filter matches the given intent data.  A match is
  /// only successful if the actions and categories in the Intent match
  /// against the filter, as described in IntentFilter; in that case,
  /// the match result returned will be as per \#matchData.
  ///@param action The intent action to match against (Intent.getAction).
  ///@param type The intent type to match against (Intent.resolveType()).
  ///@param scheme The data scheme to match against (Intent.getScheme()).
  ///@param data The data URI to match against (Intent.getData()).
  ///@param categories The categories to match against
  ///                   (Intent.getCategories()).
  ///@param logTag Tag to use in debugging messages.
  ///@return Returns either a valid match constant (a combination of
  /// \#MATCH_CATEGORY_MASK and \#MATCH_ADJUSTMENT_MASK),
  /// or one of the error codes \#NO_MATCH_TYPE if the type didn't match,
  /// \#NO_MATCH_DATA if the scheme/path didn't match,
  /// \#NO_MATCH_ACTION if the action didn't match, or
  /// \#NO_MATCH_CATEGORY if one or more categories didn't match.
  ///@see \#matchData
  ///@see Intent\#getAction
  ///@see Intent\#resolveType
  ///@see Intent\#getScheme
  ///@see Intent\#getData
  ///@see Intent\#getCategories
  int match1(jni.JniString action, jni.JniString type, jni.JniString scheme,
          uri_.Uri data, jni.JniObject categories, jni.JniString logTag) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_match1, jni.JniType.intType, [
        action.reference,
        type.reference,
        scheme.reference,
        data.reference,
        categories.reference,
        logTag.reference
      ]).integer;

  static final _id_writeToXml = jniAccessors.getMethodIDOf(
      _classRef, "writeToXml", "(Lorg/xmlpull/v1/XmlSerializer;)V");

  /// from: public void writeToXml(org.xmlpull.v1.XmlSerializer serializer)
  ///
  /// Write the contents of the IntentFilter as an XML stream.
  void writeToXml(jni.JniObject serializer) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeToXml,
      jni.JniType.voidType,
      [serializer.reference]).check();

  static final _id_readFromXml = jniAccessors.getMethodIDOf(
      _classRef, "readFromXml", "(Lorg/xmlpull/v1/XmlPullParser;)V");

  /// from: public void readFromXml(org.xmlpull.v1.XmlPullParser parser)
  void readFromXml(jni.JniObject parser) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromXml,
      jni.JniType.voidType,
      [parser.reference]).check();

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Landroid/util/Printer;Ljava/lang/String;)V");

  /// from: public void dump(android.util.Printer du, java.lang.String prefix)
  void dump(printer_.Printer du, jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [du.reference, prefix.reference]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public final int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public final void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.content.IntentFilter$MalformedMimeTypeException
///
/// This exception is thrown when a given MIME type does not have a valid
/// syntax.
class IntentFilter_MalformedMimeTypeException
    extends androidexception_.AndroidException {
  static final _classRef = jniAccessors
      .getClassOf("android/content/IntentFilter\$MalformedMimeTypeException");
  IntentFilter_MalformedMimeTypeException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  IntentFilter_MalformedMimeTypeException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  IntentFilter_MalformedMimeTypeException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);
}

/// from: android.content.IntentFilter$AuthorityEntry
///
/// This is an entry for a single authority in the Iterator returned by
/// \#authoritiesIterator().
class IntentFilter_AuthorityEntry extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/IntentFilter\$AuthorityEntry");
  IntentFilter_AuthorityEntry.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String host, java.lang.String port)
  /// The returned object must be deleted after use, by calling the `delete` method.
  IntentFilter_AuthorityEntry(jni.JniString host, jni.JniString port)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [host.reference, port.reference]).object);

  static final _id_getHost =
      jniAccessors.getMethodIDOf(_classRef, "getHost", "()Ljava/lang/String;");

  /// from: public java.lang.String getHost()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getHost() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHost, jni.JniType.objectType, []).object);

  static final _id_getPort =
      jniAccessors.getMethodIDOf(_classRef, "getPort", "()I");

  /// from: public int getPort()
  int getPort() => jniAccessors.callMethodWithArgs(
      reference, _id_getPort, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_match =
      jniAccessors.getMethodIDOf(_classRef, "match", "(Landroid/net/Uri;)I");

  /// from: public int match(android.net.Uri data)
  ///
  /// Determine whether this AuthorityEntry matches the given data Uri.
  /// _Note that this comparison is case-sensitive, unlike formal
  /// RFC host names.  You thus should always normalize to lower-case._
  ///@param data The Uri to match.
  ///@return Returns either IntentFilter\#NO_MATCH_DATA,
  /// IntentFilter\#MATCH_CATEGORY_PORT, or
  /// IntentFilter\#MATCH_CATEGORY_HOST.
  int match(uri_.Uri data) => jniAccessors.callMethodWithArgs(
      reference, _id_match, jni.JniType.intType, [data.reference]).integer;
}
