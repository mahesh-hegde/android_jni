// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Context.dart" as context_;

import "../os/IBinder.dart" as ibinder_;

import "../accounts/Account.dart" as account_;

import "../os/Bundle.dart" as bundle_;

import "ContentProviderClient.dart" as contentproviderclient_;

import "SyncResult.dart" as syncresult_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.AbstractThreadedSyncAdapter
///
/// An abstract implementation of a SyncAdapter that spawns a thread to invoke a sync operation.
/// If a sync operation is already in progress when a sync request is received, an error will be
/// returned to the new request and the existing request will be allowed to continue.
/// However if there is no sync in progress then a thread will be spawned and \#onPerformSync
/// will be invoked on that thread.
///
/// Syncs can be cancelled at any time by the framework. For example a sync that was not
/// user-initiated and lasts longer than 30 minutes will be considered timed-out and cancelled.
/// Similarly the framework will attempt to determine whether or not an adapter is making progress
/// by monitoring its network activity over the course of a minute. If the network traffic over this
/// window is close enough to zero the sync will be cancelled. You can also request the sync be
/// cancelled via ContentResolver\#cancelSync(Account, String) or
/// ContentResolver\#cancelSync(SyncRequest).
///
/// A sync is cancelled by issuing a Thread\#interrupt() on the syncing thread. <strong>Either
/// your code in \#onPerformSync(Account, Bundle, String, ContentProviderClient, SyncResult)
/// must check Thread\#interrupted(), or you you must override one of
/// \#onSyncCanceled(Thread)/\#onSyncCanceled()</strong> (depending on whether or not
/// your adapter supports syncing of multiple accounts in parallel). If your adapter does not
/// respect the cancel issued by the framework you run the risk of your app's entire process being
/// killed.
///
/// In order to be a sync adapter one must extend this class, provide implementations for the
/// abstract methods and write a service that returns the result of \#getSyncAdapterBinder()
/// in the service's android.app.Service\#onBind(android.content.Intent) when invoked
/// with an intent with action <code>android.content.SyncAdapter</code>. This service
/// must specify the following intent filter and metadata tags in its AndroidManifest.xml file
/// <pre>
///   &lt;intent-filter&gt;
///     &lt;action android:name="android.content.SyncAdapter" /&gt;
///   &lt;/intent-filter&gt;
///   &lt;meta-data android:name="android.content.SyncAdapter"
///             android:resource="@xml/syncadapter" /&gt;
/// </pre>
/// The <code>android:resource</code> attribute must point to a resource that looks like:
/// <pre>
/// &lt;sync-adapter xmlns:android="http://schemas.android.com/apk/res/android"
///    android:contentAuthority="authority"
///    android:accountType="accountType"
///    android:userVisible="true|false"
///    android:supportsUploading="true|false"
///    android:allowParallelSyncs="true|false"
///    android:isAlwaysSyncable="true|false"
///    android:syncAdapterSettingsAction="ACTION_OF_SETTINGS_ACTIVITY"
/// /&gt;
/// </pre>
/// <ul>
/// <li>The <code>android:contentAuthority</code> and <code>android:accountType</code> attributes
/// indicate which content authority and for which account types this sync adapter serves.
/// <li><code>android:userVisible</code> defaults to true and controls whether or not this sync
/// adapter shows up in the Sync Settings screen.
/// <li><code>android:supportsUploading</code> defaults
/// to true and if true an upload-only sync will be requested for all syncadapters associated
/// with an authority whenever that authority's content provider does a
/// ContentResolver\#notifyChange(android.net.Uri, android.database.ContentObserver, boolean)
/// with syncToNetwork set to true.
/// <li><code>android:allowParallelSyncs</code> defaults to false and if true indicates that
/// the sync adapter can handle syncs for multiple accounts at the same time. Otherwise
/// the SyncManager will wait until the sync adapter is not in use before requesting that
/// it sync an account's data.
/// <li><code>android:isAlwaysSyncable</code> defaults to false and if true tells the SyncManager
/// to intialize the isSyncable state to 1 for that sync adapter for each account that is added.
/// <li><code>android:syncAdapterSettingsAction</code> defaults to null and if supplied it
/// specifies an Intent action of an activity that can be used to adjust the sync adapter's
/// sync settings. The activity must live in the same package as the sync adapter.
/// </ul>
class AbstractThreadedSyncAdapter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/AbstractThreadedSyncAdapter");
  AbstractThreadedSyncAdapter.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int LOG_SYNC_DETAILS
  ///
  /// Kernel event log tag.  Also listed in data/etc/event-log-tags.
  ///@deprecated Private constant.  May go away in the next release.
  static const LOG_SYNC_DETAILS = 2743;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Z)V");

  /// from: public void <init>(android.content.Context context, boolean autoInitialize)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an AbstractThreadedSyncAdapter.
  ///@param context the android.content.Context that this is running within.
  ///@param autoInitialize if true then sync requests that have
  /// ContentResolver\#SYNC_EXTRAS_INITIALIZE set will be internally handled by
  /// AbstractThreadedSyncAdapter by calling
  /// ContentResolver\#setIsSyncable(android.accounts.Account, String, int) with 1 if it
  /// is currently set to <0.
  AbstractThreadedSyncAdapter(context_.Context context, bool autoInitialize)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference, autoInitialize]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;ZZ)V");

  /// from: public void <init>(android.content.Context context, boolean autoInitialize, boolean allowParallelSyncs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an AbstractThreadedSyncAdapter.
  ///@param context the android.content.Context that this is running within.
  ///@param autoInitialize if true then sync requests that have
  /// ContentResolver\#SYNC_EXTRAS_INITIALIZE set will be internally handled by
  /// AbstractThreadedSyncAdapter by calling
  /// ContentResolver\#setIsSyncable(android.accounts.Account, String, int) with 1 if it
  /// is currently set to <0.
  ///@param allowParallelSyncs if true then allow syncs for different accounts to run
  /// at the same time, each in their own thread. This must be consistent with the setting
  /// in the SyncAdapter's configuration file.
  AbstractThreadedSyncAdapter.ctor1(
      context_.Context context, bool autoInitialize, bool allowParallelSyncs)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [context.reference, autoInitialize, allowParallelSyncs]).object);

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getSyncAdapterBinder = jniAccessors.getMethodIDOf(
      _classRef, "getSyncAdapterBinder", "()Landroid/os/IBinder;");

  /// from: public final android.os.IBinder getSyncAdapterBinder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return a reference to the IBinder of the SyncAdapter service.
  ibinder_.IBinder getSyncAdapterBinder() =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSyncAdapterBinder, jni.JniType.objectType, []).object);

  static final _id_onUnsyncableAccount =
      jniAccessors.getMethodIDOf(_classRef, "onUnsyncableAccount", "()Z");

  /// from: public boolean onUnsyncableAccount()
  ///
  /// Allows to defer syncing until all accounts are properly set up.
  ///
  /// Called when a account / authority pair
  /// <ul>
  /// <li>that can be handled by this adapter</li>
  /// <li>ContentResolver\#requestSync(SyncRequest) is synced</li>
  /// <li>and the account/provider ContentResolver\#getIsSyncable(Account, String) has
  /// unknown state (<0).</li>
  /// </ul>
  ///
  /// This might be called on a different service connection as \#onPerformSync.
  ///
  /// The system expects this method to immediately return. If the call stalls the system
  /// behaves as if this method returned {@code true}. If it is required to perform a longer task
  /// (such as interacting with the user), return {@code false} and proceed in a difference
  /// context, such as an android.app.Activity, or foreground service. The sync can then be
  /// rescheduled once the account becomes syncable.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@return If {@code false} syncing is deferred. Returns {@code true} by default, i.e. by
  ///         default syncing starts immediately.
  bool onUnsyncableAccount() => jniAccessors.callMethodWithArgs(
      reference, _id_onUnsyncableAccount, jni.JniType.booleanType, []).boolean;

  static final _id_onPerformSync = jniAccessors.getMethodIDOf(
      _classRef,
      "onPerformSync",
      "(Landroid/accounts/Account;Landroid/os/Bundle;Ljava/lang/String;Landroid/content/ContentProviderClient;Landroid/content/SyncResult;)V");

  /// from: public abstract void onPerformSync(android.accounts.Account account, android.os.Bundle extras, java.lang.String authority, android.content.ContentProviderClient provider, android.content.SyncResult syncResult)
  ///
  /// Perform a sync for this account. SyncAdapter-specific parameters may
  /// be specified in extras, which is guaranteed to not be null. Invocations
  /// of this method are guaranteed to be serialized.
  ///@param account the account that should be synced
  ///@param extras SyncAdapter-specific parameters
  ///@param authority the authority of this sync request
  ///@param provider a ContentProviderClient that points to the ContentProvider for this
  ///   authority
  ///@param syncResult SyncAdapter-specific parameters
  void onPerformSync(
          account_.Account account,
          bundle_.Bundle extras,
          jni.JniString authority,
          contentproviderclient_.ContentProviderClient provider,
          syncresult_.SyncResult syncResult) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onPerformSync, jni.JniType.voidType, [
        account.reference,
        extras.reference,
        authority.reference,
        provider.reference,
        syncResult.reference
      ]).check();

  static final _id_onSecurityException = jniAccessors.getMethodIDOf(
      _classRef,
      "onSecurityException",
      "(Landroid/accounts/Account;Landroid/os/Bundle;Ljava/lang/String;Landroid/content/SyncResult;)V");

  /// from: public void onSecurityException(android.accounts.Account account, android.os.Bundle extras, java.lang.String authority, android.content.SyncResult syncResult)
  ///
  /// Report that there was a security exception when opening the content provider
  /// prior to calling \#onPerformSync.  This will be treated as a sync
  /// database failure.
  ///@param account the account that attempted to sync
  ///@param extras SyncAdapter-specific parameters
  ///@param authority the authority of the failed sync request
  ///@param syncResult SyncAdapter-specific parameters
  void onSecurityException(account_.Account account, bundle_.Bundle extras,
          jni.JniString authority, syncresult_.SyncResult syncResult) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSecurityException, jni.JniType.voidType, [
        account.reference,
        extras.reference,
        authority.reference,
        syncResult.reference
      ]).check();

  static final _id_onSyncCanceled =
      jniAccessors.getMethodIDOf(_classRef, "onSyncCanceled", "()V");

  /// from: public void onSyncCanceled()
  ///
  /// Indicates that a sync operation has been canceled. This will be invoked on a separate
  /// thread than the sync thread and so you must consider the multi-threaded implications
  /// of the work that you do in this method.
  ///
  /// This will only be invoked when the SyncAdapter indicates that it doesn't support
  /// parallel syncs.
  void onSyncCanceled() => jniAccessors.callMethodWithArgs(
      reference, _id_onSyncCanceled, jni.JniType.voidType, []).check();

  static final _id_onSyncCanceled1 = jniAccessors.getMethodIDOf(
      _classRef, "onSyncCanceled", "(Ljava/lang/Thread;)V");

  /// from: public void onSyncCanceled(java.lang.Thread thread)
  ///
  /// Indicates that a sync operation has been canceled. This will be invoked on a separate
  /// thread than the sync thread and so you must consider the multi-threaded implications
  /// of the work that you do in this method.
  ///
  /// This will only be invoked when the SyncAdapter indicates that it does support
  /// parallel syncs.
  ///@param thread the Thread of the sync that is to be canceled.
  void onSyncCanceled1(jni.JniObject thread) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSyncCanceled1,
      jni.JniType.voidType,
      [thread.reference]).check();
}
