// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;

import "../net/Uri.dart" as uri_;

import "ContentProviderResult.dart" as contentproviderresult_;

import "ContentProvider.dart" as contentprovider_;

import "ContentValues.dart" as contentvalues_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.ContentProviderOperation
///
/// Represents a single operation to be performed as part of a batch of operations.
///@see ContentProvider\#applyBatch(ArrayList)
class ContentProviderOperation extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/ContentProviderOperation");
  ContentProviderOperation.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.ContentProviderOperation> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/ContentProviderOperation\$Builder;)V");

  /// from: void <init>(android.content.ContentProviderOperation.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ContentProviderOperation by copying the contents of a
  /// Builder.
  ContentProviderOperation(ContentProviderOperation_Builder builder)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [builder.reference]).object);

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_newInsert = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newInsert",
      "(Landroid/net/Uri;)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: static public android.content.ContentProviderOperation.Builder newInsert(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder suitable for building an insert ContentProviderOperation.
  ///@param uri The Uri that is the target of the insert.
  ///@return a Builder
  static ContentProviderOperation_Builder newInsert(uri_.Uri uri) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_newInsert,
              jni.JniType.objectType, [uri.reference]).object);

  static final _id_newUpdate = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newUpdate",
      "(Landroid/net/Uri;)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: static public android.content.ContentProviderOperation.Builder newUpdate(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder suitable for building an update ContentProviderOperation.
  ///@param uri The Uri that is the target of the update.
  ///@return a Builder
  static ContentProviderOperation_Builder newUpdate(uri_.Uri uri) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_newUpdate,
              jni.JniType.objectType, [uri.reference]).object);

  static final _id_newDelete = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newDelete",
      "(Landroid/net/Uri;)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: static public android.content.ContentProviderOperation.Builder newDelete(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder suitable for building a delete ContentProviderOperation.
  ///@param uri The Uri that is the target of the delete.
  ///@return a Builder
  static ContentProviderOperation_Builder newDelete(uri_.Uri uri) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_newDelete,
              jni.JniType.objectType, [uri.reference]).object);

  static final _id_newAssertQuery = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "newAssertQuery",
      "(Landroid/net/Uri;)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: static public android.content.ContentProviderOperation.Builder newAssertQuery(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder suitable for building a
  /// ContentProviderOperation to assert a set of values as provided
  /// through Builder\#withValues(ContentValues).
  static ContentProviderOperation_Builder newAssertQuery(uri_.Uri uri) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_newAssertQuery,
              jni.JniType.objectType, [uri.reference]).object);

  static final _id_getUri =
      jniAccessors.getMethodIDOf(_classRef, "getUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Uri for the target of the operation.
  uri_.Uri getUri() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getUri, jni.JniType.objectType, []).object);

  static final _id_isYieldAllowed =
      jniAccessors.getMethodIDOf(_classRef, "isYieldAllowed", "()Z");

  /// from: public boolean isYieldAllowed()
  ///
  /// Returns true if the operation allows yielding the database to other transactions
  /// if the database is contended.
  ///@see android.database.sqlite.SQLiteDatabase\#yieldIfContendedSafely()
  bool isYieldAllowed() => jniAccessors.callMethodWithArgs(
      reference, _id_isYieldAllowed, jni.JniType.booleanType, []).boolean;

  static final _id_isInsert =
      jniAccessors.getMethodIDOf(_classRef, "isInsert", "()Z");

  /// from: public boolean isInsert()
  ///
  /// Returns true if the operation represents an insertion.
  ///@see \#newInsert
  bool isInsert() => jniAccessors.callMethodWithArgs(
      reference, _id_isInsert, jni.JniType.booleanType, []).boolean;

  static final _id_isDelete =
      jniAccessors.getMethodIDOf(_classRef, "isDelete", "()Z");

  /// from: public boolean isDelete()
  ///
  /// Returns true if the operation represents a deletion.
  ///@see \#newDelete
  bool isDelete() => jniAccessors.callMethodWithArgs(
      reference, _id_isDelete, jni.JniType.booleanType, []).boolean;

  static final _id_isUpdate =
      jniAccessors.getMethodIDOf(_classRef, "isUpdate", "()Z");

  /// from: public boolean isUpdate()
  ///
  /// Returns true if the operation represents an update.
  ///@see \#newUpdate
  bool isUpdate() => jniAccessors.callMethodWithArgs(
      reference, _id_isUpdate, jni.JniType.booleanType, []).boolean;

  static final _id_isAssertQuery =
      jniAccessors.getMethodIDOf(_classRef, "isAssertQuery", "()Z");

  /// from: public boolean isAssertQuery()
  ///
  /// Returns true if the operation represents an assert query.
  ///@see \#newAssertQuery
  bool isAssertQuery() => jniAccessors.callMethodWithArgs(
      reference, _id_isAssertQuery, jni.JniType.booleanType, []).boolean;

  static final _id_isWriteOperation =
      jniAccessors.getMethodIDOf(_classRef, "isWriteOperation", "()Z");

  /// from: public boolean isWriteOperation()
  ///
  /// Returns true if the operation represents an insertion, deletion, or update.
  ///@see \#isInsert
  ///@see \#isDelete
  ///@see \#isUpdate
  bool isWriteOperation() => jniAccessors.callMethodWithArgs(
      reference, _id_isWriteOperation, jni.JniType.booleanType, []).boolean;

  static final _id_isReadOperation =
      jniAccessors.getMethodIDOf(_classRef, "isReadOperation", "()Z");

  /// from: public boolean isReadOperation()
  ///
  /// Returns true if the operation represents an assert query.
  ///@see \#isAssertQuery
  bool isReadOperation() => jniAccessors.callMethodWithArgs(
      reference, _id_isReadOperation, jni.JniType.booleanType, []).boolean;

  static final _id_apply = jniAccessors.getMethodIDOf(_classRef, "apply",
      "(Landroid/content/ContentProvider;[Landroid/content/ContentProviderResult;I)Landroid/content/ContentProviderResult;");

  /// from: public android.content.ContentProviderResult apply(android.content.ContentProvider provider, android.content.ContentProviderResult[] backRefs, int numBackRefs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Applies this operation using the given provider. The backRefs array is used to resolve any
  /// back references that were requested using
  /// Builder\#withValueBackReferences(ContentValues) and
  /// Builder\#withSelectionBackReference.
  ///@param provider the ContentProvider on which this batch is applied
  ///@param backRefs a ContentProviderResult array that will be consulted
  /// to resolve any requested back references.
  ///@param numBackRefs the number of valid results on the backRefs array.
  ///@return a ContentProviderResult that contains either the Uri of the inserted
  /// row if this was an insert otherwise the number of rows affected.
  ///@throws OperationApplicationException thrown if either the insert fails or
  /// if the number of rows affected didn't match the expected count
  contentproviderresult_.ContentProviderResult apply(
          contentprovider_.ContentProvider provider,
          jni.JniObject backRefs,
          int numBackRefs) =>
      contentproviderresult_.ContentProviderResult.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_apply, jni.JniType.objectType,
              [provider.reference, backRefs.reference, numBackRefs]).object);

  static final _id_resolveValueBackReferences = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveValueBackReferences",
      "([Landroid/content/ContentProviderResult;I)Landroid/content/ContentValues;");

  /// from: public android.content.ContentValues resolveValueBackReferences(android.content.ContentProviderResult[] backRefs, int numBackRefs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The ContentValues back references are represented as a ContentValues object where the
  /// key refers to a column and the value is an index of the back reference whose
  /// valued should be associated with the column.
  ///
  /// This is intended to be a private method but it is exposed for
  /// unit testing purposes
  ///@param backRefs an array of previous results
  ///@param numBackRefs the number of valid previous results in backRefs
  ///@return the ContentValues that should be used in this operation application after
  /// expansion of back references. This can be called if either mValues or mValuesBackReferences
  /// is null
  contentvalues_.ContentValues resolveValueBackReferences(
          jni.JniObject backRefs, int numBackRefs) =>
      contentvalues_.ContentValues.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveValueBackReferences,
          jni.JniType.objectType,
          [backRefs.reference, numBackRefs]).object);

  static final _id_resolveSelectionArgsBackReferences =
      jniAccessors.getMethodIDOf(
          _classRef,
          "resolveSelectionArgsBackReferences",
          "([Landroid/content/ContentProviderResult;I)[Ljava/lang/String;");

  /// from: public java.lang.String[] resolveSelectionArgsBackReferences(android.content.ContentProviderResult[] backRefs, int numBackRefs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The Selection Arguments back references are represented as a Map of Integer->Integer where
  /// the key is an index into the selection argument array (see Builder\#withSelection)
  /// and the value is the index of the previous result that should be used for that selection
  /// argument array slot.
  ///
  /// This is intended to be a private method but it is exposed for
  /// unit testing purposes
  ///@param backRefs an array of previous results
  ///@param numBackRefs the number of valid previous results in backRefs
  ///@return the ContentValues that should be used in this operation application after
  /// expansion of back references. This can be called if either mValues or mValuesBackReferences
  /// is null
  jni.JniObject resolveSelectionArgsBackReferences(
          jni.JniObject backRefs, int numBackRefs) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveSelectionArgsBackReferences,
          jni.JniType.objectType,
          [backRefs.reference, numBackRefs]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;
}

/// from: android.content.ContentProviderOperation$Builder
///
/// Used to add parameters to a ContentProviderOperation. The Builder is
/// first created by calling ContentProviderOperation\#newInsert(android.net.Uri),
/// ContentProviderOperation\#newUpdate(android.net.Uri),
/// ContentProviderOperation\#newDelete(android.net.Uri) or
/// ContentProviderOperation\#newAssertQuery(Uri). The withXXX methods
/// can then be used to add parameters to the builder. See the specific methods to find for
/// which Builder type each is allowed. Call \#build to create the
/// ContentProviderOperation once all the parameters have been supplied.
class ContentProviderOperation_Builder extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/content/ContentProviderOperation\$Builder");
  ContentProviderOperation_Builder.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(ILandroid/net/Uri;)V");

  /// from: void <init>(int type, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder of a given type. The uri must not be null.
  ContentProviderOperation_Builder(int type, uri_.Uri uri)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [type, uri.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/content/ContentProviderOperation;");

  /// from: public android.content.ContentProviderOperation build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a ContentProviderOperation from this Builder.
  ContentProviderOperation build() =>
      ContentProviderOperation.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);

  static final _id_withValueBackReferences = jniAccessors.getMethodIDOf(
      _classRef,
      "withValueBackReferences",
      "(Landroid/content/ContentValues;)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: public android.content.ContentProviderOperation.Builder withValueBackReferences(android.content.ContentValues backReferences)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a ContentValues of back references. The key is the name of the column
  /// and the value is an integer that is the index of the previous result whose
  /// value should be used for the column. The value is added as a String.
  /// A column value from the back references takes precedence over a value specified in
  /// \#withValues.
  /// This can only be used with builders of type insert, update, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withValueBackReferences(
          contentvalues_.ContentValues backReferences) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_withValueBackReferences,
          jni.JniType.objectType,
          [backReferences.reference]).object);

  static final _id_withValueBackReference = jniAccessors.getMethodIDOf(
      _classRef,
      "withValueBackReference",
      "(Ljava/lang/String;I)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: public android.content.ContentProviderOperation.Builder withValueBackReference(java.lang.String key, int previousResult)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a ContentValues back reference.
  /// A column value from the back references takes precedence over a value specified in
  /// \#withValues.
  /// This can only be used with builders of type insert, update, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withValueBackReference(
          jni.JniString key, int previousResult) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_withValueBackReference,
          jni.JniType.objectType,
          [key.reference, previousResult]).object);

  static final _id_withSelectionBackReference = jniAccessors.getMethodIDOf(
      _classRef,
      "withSelectionBackReference",
      "(II)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: public android.content.ContentProviderOperation.Builder withSelectionBackReference(int selectionArgIndex, int previousResult)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a back references as a selection arg. Any value at that index of the selection arg
  /// that was specified by \#withSelection will be overwritten.
  /// This can only be used with builders of type update, delete, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withSelectionBackReference(
          int selectionArgIndex, int previousResult) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_withSelectionBackReference,
          jni.JniType.objectType,
          [selectionArgIndex, previousResult]).object);

  static final _id_withValues = jniAccessors.getMethodIDOf(
      _classRef,
      "withValues",
      "(Landroid/content/ContentValues;)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: public android.content.ContentProviderOperation.Builder withValues(android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The ContentValues to use. This may be null. These values may be overwritten by
  /// the corresponding value specified by \#withValueBackReference or by
  /// future calls to \#withValues or \#withValue.
  /// This can only be used with builders of type insert, update, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withValues(
          contentvalues_.ContentValues values) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_withValues,
          jni.JniType.objectType,
          [values.reference]).object);

  static final _id_withValue = jniAccessors.getMethodIDOf(
      _classRef,
      "withValue",
      "(Ljava/lang/String;Ljava/lang/Object;)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: public android.content.ContentProviderOperation.Builder withValue(java.lang.String key, java.lang.Object value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A value to insert or update. This value may be overwritten by
  /// the corresponding value specified by \#withValueBackReference.
  /// This can only be used with builders of type insert, update, or assert.
  ///@param key the name of this value
  ///@param value the value itself. the type must be acceptable for insertion by
  /// ContentValues\#put
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withValue(
          jni.JniString key, jni.JniObject value) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_withValue,
          jni.JniType.objectType,
          [key.reference, value.reference]).object);

  static final _id_withSelection = jniAccessors.getMethodIDOf(
      _classRef,
      "withSelection",
      "(Ljava/lang/String;[Ljava/lang/String;)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: public android.content.ContentProviderOperation.Builder withSelection(java.lang.String selection, java.lang.String[] selectionArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The selection and arguments to use. An occurrence of '?' in the selection will be
  /// replaced with the corresponding occurence of the selection argument. Any of the
  /// selection arguments may be overwritten by a selection argument back reference as
  /// specified by \#withSelectionBackReference.
  /// This can only be used with builders of type update, delete, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withSelection(
          jni.JniString selection, jni.JniObject selectionArgs) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_withSelection,
          jni.JniType.objectType,
          [selection.reference, selectionArgs.reference]).object);

  static final _id_withExpectedCount = jniAccessors.getMethodIDOf(
      _classRef,
      "withExpectedCount",
      "(I)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: public android.content.ContentProviderOperation.Builder withExpectedCount(int count)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If set then if the number of rows affected by this operation does not match
  /// this count OperationApplicationException will be throw.
  /// This can only be used with builders of type update, delete, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withExpectedCount(int count) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_withExpectedCount,
          jni.JniType.objectType,
          [count]).object);

  static final _id_withYieldAllowed = jniAccessors.getMethodIDOf(
      _classRef,
      "withYieldAllowed",
      "(Z)Landroid/content/ContentProviderOperation\$Builder;");

  /// from: public android.content.ContentProviderOperation.Builder withYieldAllowed(boolean yieldAllowed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If set to true then the operation allows yielding the database to other transactions
  /// if the database is contended.
  ///@return this builder, to allow for chaining.
  ///@see android.database.sqlite.SQLiteDatabase\#yieldIfContendedSafely()
  ContentProviderOperation_Builder withYieldAllowed(bool yieldAllowed) =>
      ContentProviderOperation_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_withYieldAllowed,
          jni.JniType.objectType,
          [yieldAllowed]).object);
}
