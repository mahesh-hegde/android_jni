// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "res/AssetManager.dart" as assetmanager_;

import "res/Resources.dart" as resources_;

import "pm/PackageManager.dart" as packagemanager_;

import "ContentResolver.dart" as contentresolver_;

import "../os/Looper.dart" as looper_;

import "ComponentCallbacks.dart" as componentcallbacks_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "res/ColorStateList.dart" as colorstatelist_;

import "res/TypedArray.dart" as typedarray_;

import "../util/AttributeSet.dart" as attributeset_;

import "pm/ApplicationInfo.dart" as applicationinfo_;

import "SharedPreferences.dart" as sharedpreferences_;

import "../database/sqlite/SQLiteDatabase.dart" as sqlitedatabase_;

import "../database/DatabaseErrorHandler.dart" as databaseerrorhandler_;

import "../graphics/Bitmap.dart" as bitmap_;

import "Intent.dart" as intent_;

import "../os/Bundle.dart" as bundle_;

import "IntentSender.dart" as intentsender_;

import "BroadcastReceiver.dart" as broadcastreceiver_;

import "../os/Handler.dart" as handler_;

import "../os/UserHandle.dart" as userhandle_;

import "IntentFilter.dart" as intentfilter_;

import "ComponentName.dart" as componentname_;

import "ServiceConnection.dart" as serviceconnection_;

import "../net/Uri.dart" as uri_;

import "res/Configuration.dart" as configuration_;

import "../view/Display.dart" as display_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.Context
///
/// Interface to global information about an application environment.  This is
/// an abstract class whose implementation is provided by
/// the Android system.  It
/// allows access to application-specific resources and classes, as well as
/// up-calls for application-level operations such as launching activities,
/// broadcasting and receiving intents, etc.
class Context extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/content/Context");
  Context.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACCESSIBILITY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.accessibility.AccessibilityManager for giving the user
  /// feedback for UI events through the registered event listeners.
  ///@see \#getSystemService(String)
  ///@see android.view.accessibility.AccessibilityManager
  static const ACCESSIBILITY_SERVICE = "accessibility";

  /// from: static public final java.lang.String ACCOUNT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.accounts.AccountManager for receiving intents at a
  /// time of your choosing.
  ///@see \#getSystemService(String)
  ///@see android.accounts.AccountManager
  static const ACCOUNT_SERVICE = "account";

  /// from: static public final java.lang.String ACTIVITY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.ActivityManager for interacting with the global
  /// system state.
  ///@see \#getSystemService(String)
  ///@see android.app.ActivityManager
  static const ACTIVITY_SERVICE = "activity";

  /// from: static public final java.lang.String ALARM_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.AlarmManager for receiving intents at a
  /// time of your choosing.
  ///@see \#getSystemService(String)
  ///@see android.app.AlarmManager
  static const ALARM_SERVICE = "alarm";

  /// from: static public final java.lang.String APPWIDGET_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.appwidget.AppWidgetManager for accessing AppWidgets.
  ///@see \#getSystemService(String)
  static const APPWIDGET_SERVICE = "appwidget";

  /// from: static public final java.lang.String APP_OPS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.AppOpsManager for tracking application operations
  /// on the device.
  ///@see \#getSystemService(String)
  ///@see android.app.AppOpsManager
  static const APP_OPS_SERVICE = "appops";

  /// from: static public final java.lang.String AUDIO_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.AudioManager for handling management of volume,
  /// ringer modes and audio routing.
  ///@see \#getSystemService(String)
  ///@see android.media.AudioManager
  static const AUDIO_SERVICE = "audio";

  /// from: static public final java.lang.String BATTERY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.BatteryManager for managing battery state.
  ///@see \#getSystemService(String)
  static const BATTERY_SERVICE = "batterymanager";

  /// from: static public final int BIND_ABOVE_CLIENT
  ///
  /// Flag for \#bindService: indicates that the client application
  /// binding to this service considers the service to be more important than
  /// the app itself.  When set, the platform will try to have the out of
  /// memory killer kill the app before it kills the service it is bound to, though
  /// this is not guaranteed to be the case.
  static const BIND_ABOVE_CLIENT = 8;

  /// from: static public final int BIND_ADJUST_WITH_ACTIVITY
  ///
  /// Flag for \#bindService: If binding from an activity, allow the
  /// target service's process importance to be raised based on whether the
  /// activity is visible to the user, regardless whether another flag is
  /// used to reduce the amount that the client process's overall importance
  /// is used to impact it.
  static const BIND_ADJUST_WITH_ACTIVITY = 128;

  /// from: static public final int BIND_ALLOW_OOM_MANAGEMENT
  ///
  /// Flag for \#bindService: allow the process hosting the bound
  /// service to go through its normal memory management.  It will be
  /// treated more like a running service, allowing the system to
  /// (temporarily) expunge the process if low on memory or for some other
  /// whim it may have, and being more aggressive about making it a candidate
  /// to be killed (and restarted) if running for a long time.
  static const BIND_ALLOW_OOM_MANAGEMENT = 16;

  /// from: static public final int BIND_AUTO_CREATE
  ///
  /// Flag for \#bindService: automatically create the service as long
  /// as the binding exists.  Note that while this will create the service,
  /// its android.app.Service\#onStartCommand
  /// method will still only be called due to an
  /// explicit call to \#startService.  Even without that, though,
  /// this still provides you with access to the service object while the
  /// service is created.
  ///
  /// Note that prior to android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH,
  /// not supplying this flag would also impact how important the system
  /// consider's the target service's process to be.  When set, the only way
  /// for it to be raised was by binding from a service in which case it will
  /// only be important when that activity is in the foreground.  Now to
  /// achieve this behavior you must explicitly supply the new flag
  /// \#BIND_ADJUST_WITH_ACTIVITY.  For compatibility, old applications
  /// that don't specify \#BIND_AUTO_CREATE will automatically have
  /// the flags \#BIND_WAIVE_PRIORITY and
  /// \#BIND_ADJUST_WITH_ACTIVITY set for them in order to achieve
  /// the same result.
  static const BIND_AUTO_CREATE = 1;

  /// from: static public final int BIND_DEBUG_UNBIND
  ///
  /// Flag for \#bindService: include debugging help for mismatched
  /// calls to unbind.  When this flag is set, the callstack of the following
  /// \#unbindService call is retained, to be printed if a later
  /// incorrect unbind call is made.  Note that doing this requires retaining
  /// information about the binding that was made for the lifetime of the app,
  /// resulting in a leak -- this should only be used for debugging.
  static const BIND_DEBUG_UNBIND = 2;

  /// from: static public final int BIND_EXTERNAL_SERVICE
  ///
  /// Flag for \#bindService: The service being bound is an
  /// android.R.attr\#isolatedProcess isolated,
  /// android.R.attr\#externalService external service.  This binds the service into the
  /// calling application's package, rather than the package in which the service is declared.
  ///
  /// When using this flag, the code for the service being bound will execute under the calling
  /// application's package name and user ID.  Because the service must be an isolated process,
  /// it will not have direct access to the application's data, though.
  ///
  /// The purpose of this flag is to allow applications to provide services that are attributed
  /// to the app using the service, rather than the application providing the service.
  ///
  ///
  static const BIND_EXTERNAL_SERVICE = -2147483648;

  /// from: static public final int BIND_IMPORTANT
  ///
  /// Flag for \#bindService: this service is very important to
  /// the client, so should be brought to the foreground process level
  /// when the client is.  Normally a process can only be raised to the
  /// visibility level by a client, even if that client is in the foreground.
  static const BIND_IMPORTANT = 64;

  /// from: static public final int BIND_NOT_FOREGROUND
  ///
  /// Flag for \#bindService: don't allow this binding to raise
  /// the target service's process to the foreground scheduling priority.
  /// It will still be raised to at least the same memory priority
  /// as the client (so that its process will not be killable in any
  /// situation where the client is not killable), but for CPU scheduling
  /// purposes it may be left in the background.  This only has an impact
  /// in the situation where the binding client is a foreground process
  /// and the target service is in a background process.
  static const BIND_NOT_FOREGROUND = 4;

  /// from: static public final int BIND_WAIVE_PRIORITY
  ///
  /// Flag for \#bindService: don't impact the scheduling or
  /// memory management priority of the target service's hosting process.
  /// Allows the service's process to be managed on the background LRU list
  /// just like a regular application process in the background.
  static const BIND_WAIVE_PRIORITY = 32;

  /// from: static public final java.lang.String BLUETOOTH_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.bluetooth.BluetoothManager for using Bluetooth.
  ///@see \#getSystemService(String)
  static const BLUETOOTH_SERVICE = "bluetooth";

  /// from: static public final java.lang.String CAMERA_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.camera2.CameraManager for interacting with
  /// camera devices.
  ///@see \#getSystemService(String)
  ///@see android.hardware.camera2.CameraManager
  static const CAMERA_SERVICE = "camera";

  /// from: static public final java.lang.String CAPTIONING_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.accessibility.CaptioningManager for obtaining
  /// captioning properties and listening for changes in captioning
  /// preferences.
  ///@see \#getSystemService(String)
  ///@see android.view.accessibility.CaptioningManager
  static const CAPTIONING_SERVICE = "captioning";

  /// from: static public final java.lang.String CARRIER_CONFIG_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telephony.CarrierConfigManager for reading carrier configuration values.
  ///@see \#getSystemService(String)
  ///@see android.telephony.CarrierConfigManager
  static const CARRIER_CONFIG_SERVICE = "carrier_config";

  /// from: static public final java.lang.String CLIPBOARD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.ClipboardManager for accessing and modifying
  /// the contents of the global clipboard.
  ///@see \#getSystemService(String)
  ///@see android.content.ClipboardManager
  static const CLIPBOARD_SERVICE = "clipboard";

  /// from: static public final java.lang.String COMPANION_DEVICE_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.companion.CompanionDeviceManager for managing companion devices
  ///@see \#getSystemService(String)
  ///@see android.companion.CompanionDeviceManager
  static const COMPANION_DEVICE_SERVICE = "companiondevice";

  /// from: static public final java.lang.String CONNECTIVITY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.ConnectivityManager for handling management of
  /// network connections.
  ///@see \#getSystemService(String)
  ///@see android.net.ConnectivityManager
  static const CONNECTIVITY_SERVICE = "connectivity";

  /// from: static public final java.lang.String CONSUMER_IR_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.ConsumerIrManager for transmitting infrared
  /// signals from the device.
  ///@see \#getSystemService(String)
  ///@see android.hardware.ConsumerIrManager
  static const CONSUMER_IR_SERVICE = "consumer_ir";

  /// from: static public final int CONTEXT_IGNORE_SECURITY
  ///
  /// Flag for use with \#createPackageContext: ignore any security
  /// restrictions on the Context being requested, allowing it to always
  /// be loaded.  For use with \#CONTEXT_INCLUDE_CODE to allow code
  /// to be loaded into a process even when it isn't safe to do so.  Use
  /// with extreme care!
  static const CONTEXT_IGNORE_SECURITY = 2;

  /// from: static public final int CONTEXT_INCLUDE_CODE
  ///
  /// Flag for use with \#createPackageContext: include the application
  /// code with the context.  This means loading code into the caller's
  /// process, so that \#getClassLoader() can be used to instantiate
  /// the application's classes.  Setting this flags imposes security
  /// restrictions on what application context you can access; if the
  /// requested application can not be safely loaded into your process,
  /// java.lang.SecurityException will be thrown.  If this flag is not set,
  /// there will be no restrictions on the packages that can be loaded,
  /// but \#getClassLoader will always return the default system
  /// class loader.
  static const CONTEXT_INCLUDE_CODE = 1;

  /// from: static public final int CONTEXT_RESTRICTED
  ///
  /// Flag for use with \#createPackageContext: a restricted context may
  /// disable specific features. For instance, a View associated with a restricted
  /// context would ignore particular XML attributes.
  static const CONTEXT_RESTRICTED = 4;

  /// from: static public final java.lang.String CROSS_PROFILE_APPS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.pm.CrossProfileApps for cross profile operations.
  ///@see \#getSystemService(String)
  static const CROSS_PROFILE_APPS_SERVICE = "crossprofileapps";

  /// from: static public final java.lang.String DEVICE_POLICY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.admin.DevicePolicyManager for working with global
  /// device policy management.
  ///@see \#getSystemService(String)
  static const DEVICE_POLICY_SERVICE = "device_policy";

  /// from: static public final java.lang.String DISPLAY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.display.DisplayManager for interacting with display devices.
  ///@see \#getSystemService(String)
  ///@see android.hardware.display.DisplayManager
  static const DISPLAY_SERVICE = "display";

  /// from: static public final java.lang.String DOWNLOAD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.DownloadManager for requesting HTTP downloads.
  ///@see \#getSystemService(String)
  static const DOWNLOAD_SERVICE = "download";

  /// from: static public final java.lang.String DROPBOX_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.DropBoxManager instance for recording
  /// diagnostic logs.
  ///@see \#getSystemService(String)
  static const DROPBOX_SERVICE = "dropbox";

  /// from: static public final java.lang.String EUICC_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telephony.euicc.EuiccManager to manage the device eUICC (embedded SIM).
  ///@see \#getSystemService(String)
  ///@see android.telephony.euicc.EuiccManager
  static const EUICC_SERVICE = "euicc";

  /// from: static public final java.lang.String FINGERPRINT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.fingerprint.FingerprintManager for handling management
  /// of fingerprints.
  ///@see \#getSystemService(String)
  ///@see android.hardware.fingerprint.FingerprintManager
  static const FINGERPRINT_SERVICE = "fingerprint";

  /// from: static public final java.lang.String HARDWARE_PROPERTIES_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.HardwarePropertiesManager for accessing the hardware properties service.
  ///@see \#getSystemService(String)
  static const HARDWARE_PROPERTIES_SERVICE = "hardware_properties";

  /// from: static public final java.lang.String INPUT_METHOD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.inputmethod.InputMethodManager for accessing input
  /// methods.
  ///@see \#getSystemService(String)
  static const INPUT_METHOD_SERVICE = "input_method";

  /// from: static public final java.lang.String INPUT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.input.InputManager for interacting with input devices.
  ///@see \#getSystemService(String)
  ///@see android.hardware.input.InputManager
  static const INPUT_SERVICE = "input";

  /// from: static public final java.lang.String IPSEC_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.net.IpSecManager for encrypting Sockets or Networks with
  /// IPSec.
  ///@see \#getSystemService(String)
  static const IPSEC_SERVICE = "ipsec";

  /// from: static public final java.lang.String JOB_SCHEDULER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.job.JobScheduler instance for managing occasional
  /// background tasks.
  ///@see \#getSystemService(String)
  ///@see android.app.job.JobScheduler
  static const JOB_SCHEDULER_SERVICE = "jobscheduler";

  /// from: static public final java.lang.String KEYGUARD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.NotificationManager for controlling keyguard.
  ///@see \#getSystemService(String)
  ///@see android.app.KeyguardManager
  static const KEYGUARD_SERVICE = "keyguard";

  /// from: static public final java.lang.String LAUNCHER_APPS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.pm.LauncherApps for querying and monitoring launchable apps across
  /// profiles of a user.
  ///@see \#getSystemService(String)
  ///@see android.content.pm.LauncherApps
  static const LAUNCHER_APPS_SERVICE = "launcherapps";

  /// from: static public final java.lang.String LAYOUT_INFLATER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.LayoutInflater for inflating layout resources in this
  /// context.
  ///@see \#getSystemService(String)
  ///@see android.view.LayoutInflater
  static const LAYOUT_INFLATER_SERVICE = "layout_inflater";

  /// from: static public final java.lang.String LOCATION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.location.LocationManager for controlling location
  /// updates.
  ///@see \#getSystemService(String)
  ///@see android.location.LocationManager
  static const LOCATION_SERVICE = "location";

  /// from: static public final java.lang.String MEDIA_PROJECTION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.media.projection.MediaProjectionManager instance for managing
  /// media projection sessions.
  ///@see \#getSystemService(String)
  ///@see android.media.projection.MediaProjectionManager
  static const MEDIA_PROJECTION_SERVICE = "media_projection";

  /// from: static public final java.lang.String MEDIA_ROUTER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.MediaRouter for controlling and managing
  /// routing of media.
  ///@see \#getSystemService(String)
  ///@see android.media.MediaRouter
  static const MEDIA_ROUTER_SERVICE = "media_router";

  /// from: static public final java.lang.String MEDIA_SESSION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.session.MediaSessionManager for managing media Sessions.
  ///@see \#getSystemService(String)
  ///@see android.media.session.MediaSessionManager
  static const MEDIA_SESSION_SERVICE = "media_session";

  /// from: static public final java.lang.String MIDI_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.midi.MidiManager for accessing the MIDI service.
  ///@see \#getSystemService(String)
  static const MIDI_SERVICE = "midi";

  /// from: static public final int MODE_APPEND
  ///
  /// File creation mode: for use with \#openFileOutput, if the file
  /// already exists then write data to the end of the existing file
  /// instead of erasing it.
  ///@see \#openFileOutput
  static const MODE_APPEND = 32768;

  /// from: static public final int MODE_ENABLE_WRITE_AHEAD_LOGGING
  ///
  /// Database open flag: when set, the database is opened with write-ahead
  /// logging enabled by default.
  ///@see \#openOrCreateDatabase(String, int, CursorFactory)
  ///@see \#openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)
  ///@see SQLiteDatabase\#enableWriteAheadLogging
  static const MODE_ENABLE_WRITE_AHEAD_LOGGING = 8;

  /// from: static public final int MODE_MULTI_PROCESS
  ///
  /// SharedPreference loading flag: when set, the file on disk will
  /// be checked for modification even if the shared preferences
  /// instance is already loaded in this process.  This behavior is
  /// sometimes desired in cases where the application has multiple
  /// processes, all writing to the same SharedPreferences file.
  /// Generally there are better forms of communication between
  /// processes, though.
  ///
  /// This was the legacy (but undocumented) behavior in and
  /// before Gingerbread (Android 2.3) and this flag is implied when
  /// targetting such releases.  For applications targetting SDK
  /// versions _greater than_ Android 2.3, this flag must be
  /// explicitly set if desired.
  ///@see \#getSharedPreferences
  ///@deprecated MODE_MULTI_PROCESS does not work reliably in
  /// some versions of Android, and furthermore does not provide any
  /// mechanism for reconciling concurrent modifications across
  /// processes.  Applications should not attempt to use it.  Instead,
  /// they should use an explicit cross-process data management
  /// approach such as android.content.ContentProvider ContentProvider.
  static const MODE_MULTI_PROCESS = 4;

  /// from: static public final int MODE_NO_LOCALIZED_COLLATORS
  ///
  /// Database open flag: when set, the database is opened without support for
  /// localized collators.
  ///@see \#openOrCreateDatabase(String, int, CursorFactory)
  ///@see \#openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)
  ///@see SQLiteDatabase\#NO_LOCALIZED_COLLATORS
  static const MODE_NO_LOCALIZED_COLLATORS = 16;

  /// from: static public final int MODE_PRIVATE
  ///
  /// File creation mode: the default mode, where the created file can only
  /// be accessed by the calling application (or all applications sharing the
  /// same user ID).
  static const MODE_PRIVATE = 0;

  /// from: static public final int MODE_WORLD_READABLE
  ///
  /// File creation mode: allow all other applications to have read access to
  /// the created file.
  ///
  /// Starting from android.os.Build.VERSION_CODES\#N, attempting to use this
  /// mode throws a SecurityException.
  ///@deprecated Creating world-readable files is very dangerous, and likely
  ///             to cause security holes in applications. It is strongly
  ///             discouraged; instead, applications should use more formal
  ///             mechanism for interactions such as ContentProvider,
  ///             BroadcastReceiver, and android.app.Service.
  ///             There are no guarantees that this access mode will remain on
  ///             a file, such as when it goes through a backup and restore.
  ///@see android.support.v4.content.FileProvider
  ///@see Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  static const MODE_WORLD_READABLE = 1;

  /// from: static public final int MODE_WORLD_WRITEABLE
  ///
  /// File creation mode: allow all other applications to have write access to
  /// the created file.
  ///
  /// Starting from android.os.Build.VERSION_CODES\#N, attempting to use this
  /// mode will throw a SecurityException.
  ///@deprecated Creating world-writable files is very dangerous, and likely
  ///             to cause security holes in applications. It is strongly
  ///             discouraged; instead, applications should use more formal
  ///             mechanism for interactions such as ContentProvider,
  ///             BroadcastReceiver, and android.app.Service.
  ///             There are no guarantees that this access mode will remain on
  ///             a file, such as when it goes through a backup and restore.
  ///@see android.support.v4.content.FileProvider
  ///@see Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  static const MODE_WORLD_WRITEABLE = 2;

  /// from: static public final java.lang.String NETWORK_STATS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.usage.NetworkStatsManager for querying network usage stats.
  ///@see \#getSystemService(String)
  ///@see android.app.usage.NetworkStatsManager
  static const NETWORK_STATS_SERVICE = "netstats";

  /// from: static public final java.lang.String NFC_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.nfc.NfcManager for using NFC.
  ///@see \#getSystemService(String)
  static const NFC_SERVICE = "nfc";

  /// from: static public final java.lang.String NOTIFICATION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.NotificationManager for informing the user of
  /// background events.
  ///@see \#getSystemService(String)
  ///@see android.app.NotificationManager
  static const NOTIFICATION_SERVICE = "notification";

  /// from: static public final java.lang.String NSD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.nsd.NsdManager for handling management of network service
  /// discovery
  ///@see \#getSystemService(String)
  ///@see android.net.nsd.NsdManager
  static const NSD_SERVICE = "servicediscovery";

  /// from: static public final java.lang.String POWER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.PowerManager for controlling power management,
  /// including "wake locks," which let you keep the device on while
  /// you're running long tasks.
  static const POWER_SERVICE = "power";

  /// from: static public final java.lang.String PRINT_SERVICE
  ///
  /// android.print.PrintManager for printing and managing
  /// printers and print tasks.
  ///@see \#getSystemService(String)
  ///@see android.print.PrintManager
  static const PRINT_SERVICE = "print";

  /// from: static public final int RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///
  /// Flag for \#registerReceiver: The receiver can receive broadcasts from Instant Apps.
  static const RECEIVER_VISIBLE_TO_INSTANT_APPS = 1;

  /// from: static public final java.lang.String RESTRICTIONS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.RestrictionsManager for retrieving application restrictions
  /// and requesting permissions for restricted operations.
  ///@see \#getSystemService(String)
  ///@see android.content.RestrictionsManager
  static const RESTRICTIONS_SERVICE = "restrictions";

  /// from: static public final java.lang.String SEARCH_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.SearchManager for handling searches.
  ///
  ///
  /// Configuration\#UI_MODE_TYPE_WATCH does not support
  /// android.app.SearchManager.
  ///@see \#getSystemService
  ///@see android.app.SearchManager
  static const SEARCH_SERVICE = "search";

  /// from: static public final java.lang.String SENSOR_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.hardware.SensorManager for accessing sensors.
  ///@see \#getSystemService(String)
  ///@see android.hardware.SensorManager
  static const SENSOR_SERVICE = "sensor";

  /// from: static public final java.lang.String SHORTCUT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.pm.ShortcutManager for accessing the launcher shortcut service.
  ///@see \#getSystemService(String)
  ///@see android.content.pm.ShortcutManager
  static const SHORTCUT_SERVICE = "shortcut";

  /// from: static public final java.lang.String STORAGE_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.os.storage.StorageManager for accessing system storage
  /// functions.
  ///@see \#getSystemService(String)
  ///@see android.os.storage.StorageManager
  static const STORAGE_SERVICE = "storage";

  /// from: static public final java.lang.String STORAGE_STATS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.usage.StorageStatsManager for accessing system storage
  /// statistics.
  ///@see \#getSystemService(String)
  ///@see android.app.usage.StorageStatsManager
  static const STORAGE_STATS_SERVICE = "storagestats";

  /// from: static public final java.lang.String SYSTEM_HEALTH_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.health.SystemHealthManager for accessing system health (battery, power,
  /// memory, etc) metrics.
  ///@see \#getSystemService(String)
  static const SYSTEM_HEALTH_SERVICE = "systemhealth";

  /// from: static public final java.lang.String TELECOM_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telecom.TelecomManager to manage telecom-related features
  /// of the device.
  ///@see \#getSystemService(String)
  ///@see android.telecom.TelecomManager
  static const TELECOM_SERVICE = "telecom";

  /// from: static public final java.lang.String TELEPHONY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telephony.TelephonyManager for handling management the
  /// telephony features of the device.
  ///@see \#getSystemService(String)
  ///@see android.telephony.TelephonyManager
  static const TELEPHONY_SERVICE = "phone";

  /// from: static public final java.lang.String TELEPHONY_SUBSCRIPTION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telephony.SubscriptionManager for handling management the
  /// telephony subscriptions of the device.
  ///@see \#getSystemService(String)
  ///@see android.telephony.SubscriptionManager
  static const TELEPHONY_SUBSCRIPTION_SERVICE =
      "telephony_subscription_service";

  /// from: static public final java.lang.String TEXT_CLASSIFICATION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// TextClassificationManager for text classification services.
  ///@see \#getSystemService(String)
  ///@see TextClassificationManager
  static const TEXT_CLASSIFICATION_SERVICE = "textclassification";

  /// from: static public final java.lang.String TEXT_SERVICES_MANAGER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.textservice.TextServicesManager for accessing
  /// text services.
  ///@see \#getSystemService(String)
  static const TEXT_SERVICES_MANAGER_SERVICE = "textservices";

  /// from: static public final java.lang.String TV_INPUT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.tv.TvInputManager for interacting with TV inputs
  /// on the device.
  ///@see \#getSystemService(String)
  ///@see android.media.tv.TvInputManager
  static const TV_INPUT_SERVICE = "tv_input";

  /// from: static public final java.lang.String UI_MODE_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.UiModeManager for controlling UI modes.
  ///@see \#getSystemService(String)
  static const UI_MODE_SERVICE = "uimode";

  /// from: static public final java.lang.String USAGE_STATS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.usage.UsageStatsManager for querying device usage stats.
  ///@see \#getSystemService(String)
  ///@see android.app.usage.UsageStatsManager
  static const USAGE_STATS_SERVICE = "usagestats";

  /// from: static public final java.lang.String USB_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.hardware.usb.UsbManager for access to USB devices (as a USB host)
  /// and for controlling this device's behavior as a USB device.
  ///@see \#getSystemService(String)
  ///@see android.hardware.usb.UsbManager
  static const USB_SERVICE = "usb";

  /// from: static public final java.lang.String USER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.UserManager for managing users on devices that support multiple users.
  ///@see \#getSystemService(String)
  ///@see android.os.UserManager
  static const USER_SERVICE = "user";

  /// from: static public final java.lang.String VIBRATOR_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.os.Vibrator for interacting with the vibration hardware.
  ///@see \#getSystemService(String)
  ///@see android.os.Vibrator
  static const VIBRATOR_SERVICE = "vibrator";

  /// from: static public final java.lang.String WALLPAPER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// com.android.server.WallpaperService for accessing wallpapers.
  ///@see \#getSystemService(String)
  static const WALLPAPER_SERVICE = "wallpaper";

  /// from: static public final java.lang.String WIFI_AWARE_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.net.wifi.aware.WifiAwareManager for handling management of
  /// Wi-Fi Aware.
  ///@see \#getSystemService(String)
  ///@see android.net.wifi.aware.WifiAwareManager
  static const WIFI_AWARE_SERVICE = "wifiaware";

  /// from: static public final java.lang.String WIFI_P2P_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.wifi.p2p.WifiP2pManager for handling management of
  /// Wi-Fi peer-to-peer connections.
  ///@see \#getSystemService(String)
  ///@see android.net.wifi.p2p.WifiP2pManager
  static const WIFI_P2P_SERVICE = "wifip2p";

  /// from: static public final java.lang.String WIFI_RTT_RANGING_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.wifi.rtt.WifiRttManager for ranging devices with wifi
  ///
  /// Note: this is a replacement for WIFI_RTT_SERVICE above. It will
  /// be renamed once final implementation in place.
  ///@see \#getSystemService(String)
  ///@see android.net.wifi.rtt.WifiRttManager
  static const WIFI_RTT_RANGING_SERVICE = "wifirtt";

  /// from: static public final java.lang.String WIFI_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.wifi.WifiManager for handling management of
  /// Wi-Fi access.
  ///@see \#getSystemService(String)
  ///@see android.net.wifi.WifiManager
  static const WIFI_SERVICE = "wifi";

  /// from: static public final java.lang.String WINDOW_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.WindowManager for accessing the system's window
  /// manager.
  ///@see \#getSystemService(String)
  ///@see android.view.WindowManager
  static const WINDOW_SERVICE = "window";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Context()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getAssets = jniAccessors.getMethodIDOf(
      _classRef, "getAssets", "()Landroid/content/res/AssetManager;");

  /// from: public abstract android.content.res.AssetManager getAssets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an AssetManager instance for the application's package.
  ///
  /// <strong>Note:</strong> Implementations of this method should return
  /// an AssetManager instance that is consistent with the Resources instance
  /// returned by \#getResources(). For example, they should share the
  /// same Configuration object.
  ///@return an AssetManager instance for the application's package
  ///@see \#getResources()
  assetmanager_.AssetManager getAssets() =>
      assetmanager_.AssetManager.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAssets, jni.JniType.objectType, []).object);

  static final _id_getResources = jniAccessors.getMethodIDOf(
      _classRef, "getResources", "()Landroid/content/res/Resources;");

  /// from: public abstract android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Resources instance for the application's package.
  ///
  /// <strong>Note:</strong> Implementations of this method should return
  /// a Resources instance that is consistent with the AssetManager instance
  /// returned by \#getAssets(). For example, they should share the
  /// same Configuration object.
  ///@return a Resources instance for the application's package
  ///@see \#getAssets()
  resources_.Resources getResources() =>
      resources_.Resources.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getResources, jni.JniType.objectType, []).object);

  static final _id_getPackageManager = jniAccessors.getMethodIDOf(
      _classRef, "getPackageManager", "()Landroid/content/pm/PackageManager;");

  /// from: public abstract android.content.pm.PackageManager getPackageManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return PackageManager instance to find global package information.
  packagemanager_.PackageManager getPackageManager() =>
      packagemanager_.PackageManager.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPackageManager, jni.JniType.objectType, []).object);

  static final _id_getContentResolver = jniAccessors.getMethodIDOf(
      _classRef, "getContentResolver", "()Landroid/content/ContentResolver;");

  /// from: public abstract android.content.ContentResolver getContentResolver()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a ContentResolver instance for your application's package.
  contentresolver_.ContentResolver getContentResolver() =>
      contentresolver_.ContentResolver.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getContentResolver,
          jni.JniType.objectType, []).object);

  static final _id_getMainLooper = jniAccessors.getMethodIDOf(
      _classRef, "getMainLooper", "()Landroid/os/Looper;");

  /// from: public abstract android.os.Looper getMainLooper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Looper for the main thread of the current process.  This is
  /// the thread used to dispatch calls to application components (activities,
  /// services, etc).
  ///
  /// By definition, this method returns the same result as would be obtained
  /// by calling Looper\#getMainLooper() Looper.getMainLooper().
  ///
  ///
  ///@return The main looper.
  looper_.Looper getMainLooper() =>
      looper_.Looper.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMainLooper, jni.JniType.objectType, []).object);

  static final _id_getMainExecutor = jniAccessors.getMethodIDOf(
      _classRef, "getMainExecutor", "()Ljava/util/concurrent/Executor;");

  /// from: public java.util.concurrent.Executor getMainExecutor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an Executor that will run enqueued tasks on the main
  /// thread associated with this context. This is the thread used to dispatch
  /// calls to application components (activities, services, etc).
  jni.JniObject getMainExecutor() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMainExecutor, jni.JniType.objectType, []).object);

  static final _id_getApplicationContext = jniAccessors.getMethodIDOf(
      _classRef, "getApplicationContext", "()Landroid/content/Context;");

  /// from: public abstract android.content.Context getApplicationContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the context of the single, global Application object of the
  /// current process.  This generally should only be used if you need a
  /// Context whose lifecycle is separate from the current context, that is
  /// tied to the lifetime of the process rather than the current component.
  ///
  /// Consider for example how this interacts with
  /// \#registerReceiver(BroadcastReceiver, IntentFilter):
  /// <ul>
  /// <li> If used from an Activity context, the receiver is being registered
  /// within that activity.  This means that you are expected to unregister
  /// before the activity is done being destroyed; in fact if you do not do
  /// so, the framework will clean up your leaked registration as it removes
  /// the activity and log an error.  Thus, if you use the Activity context
  /// to register a receiver that is static (global to the process, not
  /// associated with an Activity instance) then that registration will be
  /// removed on you at whatever point the activity you used is destroyed.
  /// <li> If used from the Context returned here, the receiver is being
  /// registered with the global state associated with your application.  Thus
  /// it will never be unregistered for you.  This is necessary if the receiver
  /// is associated with static data, not a particular component.  However
  /// using the ApplicationContext elsewhere can easily lead to serious leaks
  /// if you forget to unregister, unbind, etc.
  /// </ul>
  Context getApplicationContext() =>
      Context.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getApplicationContext, jni.JniType.objectType, []).object);

  static final _id_registerComponentCallbacks = jniAccessors.getMethodIDOf(
      _classRef,
      "registerComponentCallbacks",
      "(Landroid/content/ComponentCallbacks;)V");

  /// from: public void registerComponentCallbacks(android.content.ComponentCallbacks callback)
  ///
  /// Add a new ComponentCallbacks to the base application of the
  /// Context, which will be called at the same times as the ComponentCallbacks
  /// methods of activities and other components are called.  Note that you
  /// _must_ be sure to use \#unregisterComponentCallbacks when
  /// appropriate in the future; this will not be removed for you.
  ///@param callback The interface to call.  This can be either a
  /// ComponentCallbacks or ComponentCallbacks2 interface.
  void registerComponentCallbacks(
          componentcallbacks_.ComponentCallbacks callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerComponentCallbacks,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_unregisterComponentCallbacks = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterComponentCallbacks",
      "(Landroid/content/ComponentCallbacks;)V");

  /// from: public void unregisterComponentCallbacks(android.content.ComponentCallbacks callback)
  ///
  /// Remove a ComponentCallbacks object that was previously registered
  /// with \#registerComponentCallbacks(ComponentCallbacks).
  void unregisterComponentCallbacks(
          componentcallbacks_.ComponentCallbacks callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterComponentCallbacks,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "(I)Ljava/lang/CharSequence;");

  /// from: public final java.lang.CharSequence getText(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized, styled CharSequence from the application's package's
  /// default string table.
  ///@param resId Resource id for the CharSequence text
  ///@return This value will never be {@code null}.
  jni.JniObject getText(int resId) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, [resId]).object);

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(I)Ljava/lang/String;");

  /// from: public final java.lang.String getString(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a localized string from the application's package's
  /// default string table.
  ///@param resId Resource id for the string
  ///@return The string data associated with the resource, stripped of styled
  ///         text information.
  ///
  /// This value will never be {@code null}.
  jni.JniString getString(int resId) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getString, jni.JniType.objectType, [resId]).object);

  static final _id_getString1 = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(I[Ljava/lang/Object;)Ljava/lang/String;");

  /// from: public final java.lang.String getString(int resId, java.lang.Object[] formatArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a localized formatted string from the application's package's
  /// default string table, substituting the format arguments as defined in
  /// java.util.Formatter and java.lang.String\#format.
  ///@param resId Resource id for the format string
  ///@param formatArgs The format arguments that will be used for
  ///                   substitution.
  ///@return The string data associated with the resource, formatted and
  ///         stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JniString getString1(int resId, jni.JniObject formatArgs) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getString1,
          jni.JniType.objectType,
          [resId, formatArgs.reference]).object);

  static final _id_getColor =
      jniAccessors.getMethodIDOf(_classRef, "getColor", "(I)I");

  /// from: public final int getColor(int id)
  ///
  /// Returns a color associated with a particular resource ID and styled for
  /// the current theme.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return A single color value in the form 0xAARRGGBB.
  ///@throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  int getColor(int id) => jniAccessors.callMethodWithArgs(
      reference, _id_getColor, jni.JniType.intType, [id]).integer;

  static final _id_getDrawable = jniAccessors.getMethodIDOf(
      _classRef, "getDrawable", "(I)Landroid/graphics/drawable/Drawable;");

  /// from: public final android.graphics.drawable.Drawable getDrawable(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a drawable object associated with a particular resource ID and
  /// styled for the current theme.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return An object that can be used to draw this resource.
  /// This value may be {@code null}.
  ///@throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  drawable_.Drawable getDrawable(int id) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDrawable, jni.JniType.objectType, [id]).object);

  static final _id_getColorStateList = jniAccessors.getMethodIDOf(_classRef,
      "getColorStateList", "(I)Landroid/content/res/ColorStateList;");

  /// from: public final android.content.res.ColorStateList getColorStateList(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a color state list associated with a particular resource ID and
  /// styled for the current theme.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return A color state list.
  /// This value will never be {@code null}.
  ///@throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  colorstatelist_.ColorStateList getColorStateList(int id) =>
      colorstatelist_.ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getColorStateList,
          jni.JniType.objectType,
          [id]).object);

  static final _id_setTheme =
      jniAccessors.getMethodIDOf(_classRef, "setTheme", "(I)V");

  /// from: public abstract void setTheme(int resid)
  ///
  /// Set the base theme for this context.  Note that this should be called
  /// before any views are instantiated in the Context (for example before
  /// calling android.app.Activity\#setContentView or
  /// android.view.LayoutInflater\#inflate).
  ///@param resid The style resource describing the theme.
  void setTheme(int resid) => jniAccessors.callMethodWithArgs(
      reference, _id_setTheme, jni.JniType.voidType, [resid]).check();

  static final _id_getTheme = jniAccessors.getMethodIDOf(
      _classRef, "getTheme", "()Landroid/content/res/Resources\$Theme;");

  /// from: public abstract android.content.res.Resources.Theme getTheme()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Theme object associated with this Context.
  resources_.Resources_Theme getTheme() =>
      resources_.Resources_Theme.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTheme, jni.JniType.objectType, []).object);

  static final _id_obtainStyledAttributes = jniAccessors.getMethodIDOf(
      _classRef,
      "obtainStyledAttributes",
      "([I)Landroid/content/res/TypedArray;");

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve styled attribute information in this Context's theme.  See
  /// android.content.res.Resources.Theme\#obtainStyledAttributes(int[])
  /// for more information.
  ///@see android.content.res.Resources.Theme\#obtainStyledAttributes(int[])
  typedarray_.TypedArray obtainStyledAttributes(jni.JniObject attrs) =>
      typedarray_.TypedArray.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_obtainStyledAttributes,
          jni.JniType.objectType,
          [attrs.reference]).object);

  static final _id_obtainStyledAttributes1 = jniAccessors.getMethodIDOf(
      _classRef,
      "obtainStyledAttributes",
      "(I[I)Landroid/content/res/TypedArray;");

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(int resid, int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve styled attribute information in this Context's theme.  See
  /// android.content.res.Resources.Theme\#obtainStyledAttributes(int, int[])
  /// for more information.
  ///@see android.content.res.Resources.Theme\#obtainStyledAttributes(int, int[])
  typedarray_.TypedArray obtainStyledAttributes1(
          int resid, jni.JniObject attrs) =>
      typedarray_.TypedArray.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_obtainStyledAttributes1,
          jni.JniType.objectType,
          [resid, attrs.reference]).object);

  static final _id_obtainStyledAttributes2 = jniAccessors.getMethodIDOf(
      _classRef,
      "obtainStyledAttributes",
      "(Landroid/util/AttributeSet;[I)Landroid/content/res/TypedArray;");

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet set, int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve styled attribute information in this Context's theme.  See
  /// android.content.res.Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  /// for more information.
  ///@see android.content.res.Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  typedarray_.TypedArray obtainStyledAttributes2(
          attributeset_.AttributeSet set0, jni.JniObject attrs) =>
      typedarray_.TypedArray.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_obtainStyledAttributes2,
          jni.JniType.objectType,
          [set0.reference, attrs.reference]).object);

  static final _id_obtainStyledAttributes3 = jniAccessors.getMethodIDOf(
      _classRef,
      "obtainStyledAttributes",
      "(Landroid/util/AttributeSet;[III)Landroid/content/res/TypedArray;");

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve styled attribute information in this Context's theme.  See
  /// android.content.res.Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  /// for more information.
  ///@see android.content.res.Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  typedarray_.TypedArray obtainStyledAttributes3(
          attributeset_.AttributeSet set0,
          jni.JniObject attrs,
          int defStyleAttr,
          int defStyleRes) =>
      typedarray_.TypedArray.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_obtainStyledAttributes3,
          jni.JniType.objectType,
          [set0.reference, attrs.reference, defStyleAttr, defStyleRes]).object);

  static final _id_getClassLoader = jniAccessors.getMethodIDOf(
      _classRef, "getClassLoader", "()Ljava/lang/ClassLoader;");

  /// from: public abstract java.lang.ClassLoader getClassLoader()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a class loader you can use to retrieve classes in this package.
  jni.JniObject getClassLoader() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClassLoader, jni.JniType.objectType, []).object);

  static final _id_getPackageName = jniAccessors.getMethodIDOf(
      _classRef, "getPackageName", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of this application's package.
  jni.JniString getPackageName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPackageName, jni.JniType.objectType, []).object);

  static final _id_getApplicationInfo = jniAccessors.getMethodIDOf(_classRef,
      "getApplicationInfo", "()Landroid/content/pm/ApplicationInfo;");

  /// from: public abstract android.content.pm.ApplicationInfo getApplicationInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full application info for this context's package.
  applicationinfo_.ApplicationInfo getApplicationInfo() =>
      applicationinfo_.ApplicationInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationInfo,
          jni.JniType.objectType, []).object);

  static final _id_getPackageResourcePath = jniAccessors.getMethodIDOf(
      _classRef, "getPackageResourcePath", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getPackageResourcePath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full path to this context's primary Android package.
  /// The Android package is a ZIP file which contains the application's
  /// primary resources.
  ///
  /// Note: this is not generally useful for applications, since they should
  /// not be directly accessing the file system.
  ///@return String Path to the resources.
  jni.JniString getPackageResourcePath() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPackageResourcePath, jni.JniType.objectType, []).object);

  static final _id_getPackageCodePath = jniAccessors.getMethodIDOf(
      _classRef, "getPackageCodePath", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getPackageCodePath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full path to this context's primary Android package.
  /// The Android package is a ZIP file which contains application's
  /// primary code and assets.
  ///
  /// Note: this is not generally useful for applications, since they should
  /// not be directly accessing the file system.
  ///@return String Path to the code and assets.
  jni.JniString getPackageCodePath() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPackageCodePath, jni.JniType.objectType, []).object);

  static final _id_getSharedPreferences = jniAccessors.getMethodIDOf(
      _classRef,
      "getSharedPreferences",
      "(Ljava/lang/String;I)Landroid/content/SharedPreferences;");

  /// from: public abstract android.content.SharedPreferences getSharedPreferences(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve and hold the contents of the preferences file 'name', returning
  /// a SharedPreferences through which you can retrieve and modify its
  /// values.  Only one instance of the SharedPreferences object is returned
  /// to any callers for the same name, meaning they will see each other's
  /// edits as soon as they are made.
  ///
  /// This method is thead-safe.
  ///@param name Desired preferences file. If a preferences file by this name
  /// does not exist, it will be created when you retrieve an
  /// editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).
  ///@param mode Operating mode.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_MULTI_PROCESS
  ///@return The single SharedPreferences instance that can be used
  ///         to retrieve and modify the preference values.
  ///@see \#MODE_PRIVATE
  sharedpreferences_.SharedPreferences getSharedPreferences(
          jni.JniString name, int mode) =>
      sharedpreferences_.SharedPreferences.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getSharedPreferences,
              jni.JniType.objectType, [name.reference, mode]).object);

  static final _id_moveSharedPreferencesFrom = jniAccessors.getMethodIDOf(
      _classRef,
      "moveSharedPreferencesFrom",
      "(Landroid/content/Context;Ljava/lang/String;)Z");

  /// from: public abstract boolean moveSharedPreferencesFrom(android.content.Context sourceContext, java.lang.String name)
  ///
  /// Move an existing shared preferences file from the given source storage
  /// context to this context. This is typically used to migrate data between
  /// storage locations after an upgrade, such as moving to device protected
  /// storage.
  ///@param sourceContext The source context which contains the existing
  ///            shared preferences to move.
  ///@param name The name of the shared preferences file.
  ///@return {@code true} if the move was successful or if the shared
  ///         preferences didn't exist in the source context, otherwise
  ///         {@code false}.
  ///@see \#createDeviceProtectedStorageContext()
  bool moveSharedPreferencesFrom(Context sourceContext, jni.JniString name) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_moveSharedPreferencesFrom,
          jni.JniType.booleanType,
          [sourceContext.reference, name.reference]).boolean;

  static final _id_deleteSharedPreferences = jniAccessors.getMethodIDOf(
      _classRef, "deleteSharedPreferences", "(Ljava/lang/String;)Z");

  /// from: public abstract boolean deleteSharedPreferences(java.lang.String name)
  ///
  /// Delete an existing shared preferences file.
  ///@param name The name (unique in the application package) of the shared
  ///            preferences file.
  ///@return {@code true} if the shared preferences file was successfully
  ///         deleted; else {@code false}.
  ///@see \#getSharedPreferences(String, int)
  bool deleteSharedPreferences(jni.JniString name) =>
      jniAccessors.callMethodWithArgs(reference, _id_deleteSharedPreferences,
          jni.JniType.booleanType, [name.reference]).boolean;

  static final _id_openFileInput = jniAccessors.getMethodIDOf(_classRef,
      "openFileInput", "(Ljava/lang/String;)Ljava/io/FileInputStream;");

  /// from: public abstract java.io.FileInputStream openFileInput(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a private file associated with this Context's application package
  /// for reading.
  ///@param name The name of the file to open; can not contain path
  ///             separators.
  ///@return The resulting FileInputStream.
  ///@see \#openFileOutput
  ///@see \#fileList
  ///@see \#deleteFile
  ///@see java.io.FileInputStream\#FileInputStream(String)
  jni.JniObject openFileInput(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_openFileInput, jni.JniType.objectType, [name.reference]).object);

  static final _id_openFileOutput = jniAccessors.getMethodIDOf(_classRef,
      "openFileOutput", "(Ljava/lang/String;I)Ljava/io/FileOutputStream;");

  /// from: public abstract java.io.FileOutputStream openFileOutput(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a private file associated with this Context's application package
  /// for writing. Creates the file if it doesn't already exist.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write the returned file.
  ///@param name The name of the file to open; can not contain path
  ///            separators.
  ///@param mode Operating mode.
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_APPEND
  ///@return The resulting FileOutputStream.
  ///@see \#MODE_APPEND
  ///@see \#MODE_PRIVATE
  ///@see \#openFileInput
  ///@see \#fileList
  ///@see \#deleteFile
  ///@see java.io.FileOutputStream\#FileOutputStream(String)
  jni.JniObject openFileOutput(jni.JniString name, int mode) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_openFileOutput,
          jni.JniType.objectType,
          [name.reference, mode]).object);

  static final _id_deleteFile = jniAccessors.getMethodIDOf(
      _classRef, "deleteFile", "(Ljava/lang/String;)Z");

  /// from: public abstract boolean deleteFile(java.lang.String name)
  ///
  /// Delete the given private file associated with this Context's
  /// application package.
  ///@param name The name of the file to delete; can not contain path
  ///             separators.
  ///@return {@code true} if the file was successfully deleted; else
  ///         {@code false}.
  ///@see \#openFileInput
  ///@see \#openFileOutput
  ///@see \#fileList
  ///@see java.io.File\#delete()
  bool deleteFile(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_deleteFile,
      jni.JniType.booleanType,
      [name.reference]).boolean;

  static final _id_getFileStreamPath = jniAccessors.getMethodIDOf(
      _classRef, "getFileStreamPath", "(Ljava/lang/String;)Ljava/io/File;");

  /// from: public abstract java.io.File getFileStreamPath(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path on the filesystem where a file created with
  /// \#openFileOutput is stored.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///@param name The name of the file for which you would like to get
  ///          its path.
  ///@return An absolute path to the given file.
  ///@see \#openFileOutput
  ///@see \#getFilesDir
  ///@see \#getDir
  jni.JniObject getFileStreamPath(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFileStreamPath,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getDataDir =
      jniAccessors.getMethodIDOf(_classRef, "getDataDir", "()Ljava/io/File;");

  /// from: public abstract java.io.File getDataDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the directory on the filesystem where all
  /// private files belonging to this app are stored. Apps should not use this
  /// path directly; they should instead use \#getFilesDir(),
  /// \#getCacheDir(), \#getDir(String, int), or other storage
  /// APIs on this class.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path.
  ///@see ApplicationInfo\#dataDir
  jni.JniObject getDataDir() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDataDir, jni.JniType.objectType, []).object);

  static final _id_getFilesDir =
      jniAccessors.getMethodIDOf(_classRef, "getFilesDir", "()Ljava/io/File;");

  /// from: public abstract java.io.File getFilesDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the directory on the filesystem where files
  /// created with \#openFileOutput are stored.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path.
  ///@return The path of the directory holding application files.
  ///@see \#openFileOutput
  ///@see \#getFileStreamPath
  ///@see \#getDir
  jni.JniObject getFilesDir() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFilesDir, jni.JniType.objectType, []).object);

  static final _id_getNoBackupFilesDir = jniAccessors.getMethodIDOf(
      _classRef, "getNoBackupFilesDir", "()Ljava/io/File;");

  /// from: public abstract java.io.File getNoBackupFilesDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the directory on the filesystem similar to
  /// \#getFilesDir(). The difference is that files placed under this
  /// directory will be excluded from automatic backup to remote storage. See
  /// android.app.backup.BackupAgent BackupAgent for a full discussion
  /// of the automatic backup mechanism in Android.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path.
  ///@return The path of the directory holding application files that will not
  ///         be automatically backed up to remote storage.
  ///@see \#openFileOutput
  ///@see \#getFileStreamPath
  ///@see \#getDir
  ///@see android.app.backup.BackupAgent
  jni.JniObject getNoBackupFilesDir() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNoBackupFilesDir, jni.JniType.objectType, []).object);

  static final _id_getExternalFilesDir = jniAccessors.getMethodIDOf(
      _classRef, "getExternalFilesDir", "(Ljava/lang/String;)Ljava/io/File;");

  /// from: public abstract java.io.File getExternalFilesDir(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the directory on the primary shared/external
  /// storage device where the application can place persistent files it owns.
  /// These files are internal to the applications, and not typically visible
  /// to the user as media.
  ///
  /// This is like \#getFilesDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// If a shared storage device is emulated (as determined by
  /// Environment\#isExternalStorageEmulated(File)), it's contents are
  /// backed by a private user data partition, which means there is little
  /// benefit to storing data here instead of the private directories returned
  /// by \#getFilesDir(), etc.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#KITKAT, no permissions
  /// are required to read or write to the returned path; it's always
  /// accessible to the calling app. This only applies to paths generated for
  /// package name of the calling application. To access paths belonging to
  /// other packages,
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE and/or
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE are required.
  ///
  /// On devices with multiple users (as described by UserManager),
  /// each user has their own isolated shared storage. Applications only have
  /// access to the shared storage for the user they're running as.
  ///
  /// The returned path may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///
  /// Here is an example of typical code to manipulate a file in an
  /// application's shared storage:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
  /// private_file}
  ///
  /// If you supply a non-null <var>type</var> to this function, the returned
  /// file will be a path to a sub-directory of the given type. Though these
  /// files are not automatically scanned by the media scanner, you can
  /// explicitly add them to the media database with
  /// android.media.MediaScannerConnection\#scanFile(Context, String[], String[], android.media.MediaScannerConnection.OnScanCompletedListener) MediaScannerConnection.scanFile. Note that this is not the same as
  /// android.os.Environment\#getExternalStoragePublicDirectory Environment.getExternalStoragePublicDirectory(), which provides
  /// directories of media shared by all applications. The directories returned
  /// here are owned by the application, and their contents will be removed
  /// when the application is uninstalled. Unlike
  /// android.os.Environment\#getExternalStoragePublicDirectory Environment.getExternalStoragePublicDirectory(), the directory returned
  /// here will be automatically created for you.
  ///
  /// Here is an example of typical code to manipulate a picture in an
  /// application's shared storage and add it to the media database:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
  /// private_picture}
  ///@param type The type of files directory to return. May be {@code null}
  ///            for the root of the files directory or one of the following
  ///            constants for a subdirectory:
  ///            android.os.Environment\#DIRECTORY_MUSIC,
  ///            android.os.Environment\#DIRECTORY_PODCASTS,
  ///            android.os.Environment\#DIRECTORY_RINGTONES,
  ///            android.os.Environment\#DIRECTORY_ALARMS,
  ///            android.os.Environment\#DIRECTORY_NOTIFICATIONS,
  ///            android.os.Environment\#DIRECTORY_PICTURES, or
  ///            android.os.Environment\#DIRECTORY_MOVIES.
  /// This value may be {@code null}.
  ///@return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  ///@see \#getFilesDir
  ///@see \#getExternalFilesDirs(String)
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalFilesDir(jni.JniString type) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getExternalFilesDir,
          jni.JniType.objectType,
          [type.reference]).object);

  static final _id_getExternalFilesDirs = jniAccessors.getMethodIDOf(
      _classRef, "getExternalFilesDirs", "(Ljava/lang/String;)[Ljava/io/File;");

  /// from: public abstract java.io.File[] getExternalFilesDirs(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place
  /// persistent files it owns. These files are internal to the application,
  /// and not typically visible to the user as media.
  ///
  /// This is like \#getFilesDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// If a shared storage device is emulated (as determined by
  /// Environment\#isExternalStorageEmulated(File)), it's contents are
  /// backed by a private user data partition, which means there is little
  /// benefit to storing data here instead of the private directories returned
  /// by \#getFilesDir(), etc.
  ///
  /// Shared storage devices returned here are considered a stable part of the
  /// device, including physical media slots under a protective cover. The
  /// returned paths do not include transient devices, such as USB flash drives
  /// connected to handheld devices.
  ///
  /// An application may store data on any or all of the returned devices. For
  /// example, an app may choose to store large files on the device with the
  /// most available space, as measured by StatFs.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path. Write access outside of these paths
  /// on secondary external storage devices is not available.
  ///
  /// The returned path may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///@param type The type of files directory to return. May be {@code null}
  ///            for the root of the files directory or one of the following
  ///            constants for a subdirectory:
  ///            android.os.Environment\#DIRECTORY_MUSIC,
  ///            android.os.Environment\#DIRECTORY_PODCASTS,
  ///            android.os.Environment\#DIRECTORY_RINGTONES,
  ///            android.os.Environment\#DIRECTORY_ALARMS,
  ///            android.os.Environment\#DIRECTORY_NOTIFICATIONS,
  ///            android.os.Environment\#DIRECTORY_PICTURES, or
  ///            android.os.Environment\#DIRECTORY_MOVIES.
  ///@return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         \#getExternalFilesDir(String).
  ///@see \#getExternalFilesDir(String)
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalFilesDirs(jni.JniString type) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getExternalFilesDirs,
          jni.JniType.objectType,
          [type.reference]).object);

  static final _id_getObbDir =
      jniAccessors.getMethodIDOf(_classRef, "getObbDir", "()Ljava/io/File;");

  /// from: public abstract java.io.File getObbDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the primary shared/external storage directory where this
  /// application's OBB files (if there are any) can be found. Note if the
  /// application does not have any OBB files, this directory may not exist.
  ///
  /// This is like \#getFilesDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// Starting in android.os.Build.VERSION_CODES\#KITKAT, no permissions
  /// are required to read or write to the path that this method returns.
  /// However, starting from android.os.Build.VERSION_CODES\#M,
  /// to read the OBB expansion files, you must declare the
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE permission in the app manifest and ask for
  /// permission at runtime as follows:
  ///
  ///
  ///
  /// {@code <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"
  /// android:maxSdkVersion="23" />}
  ///
  ///
  ///
  /// Starting from android.os.Build.VERSION_CODES\#N,
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE
  /// permission is not required, so don\u2019t ask for this
  /// permission at runtime. To handle both cases, your app must first try to read the OBB file,
  /// and if it fails, you must request
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE permission at runtime.
  ///
  ///
  ///
  ///
  /// The following code snippet shows how to do this:
  ///
  ///
  ///
  /// <pre>
  /// File obb = new File(obb_filename);
  /// boolean open_failed = false;
  ///
  /// try {
  ///     BufferedReader br = new BufferedReader(new FileReader(obb));
  ///     open_failed = false;
  ///     ReadObbFile(br);
  /// } catch (IOException e) {
  ///     open_failed = true;
  /// }
  ///
  /// if (open_failed) {
  ///     // request READ_EXTERNAL_STORAGE permission before reading OBB file
  ///     ReadObbFileWithPermission();
  /// }
  /// </pre>
  ///
  /// On devices with multiple users (as described by UserManager),
  /// multiple users may share the same OBB storage location. Applications
  /// should ensure that multiple instances running under different users don't
  /// interfere with each other.
  ///@return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  ///@see \#getObbDirs()
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getObbDir() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getObbDir, jni.JniType.objectType, []).object);

  static final _id_getObbDirs =
      jniAccessors.getMethodIDOf(_classRef, "getObbDirs", "()[Ljava/io/File;");

  /// from: public abstract java.io.File[] getObbDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application's OBB files (if
  /// there are any) can be found. Note if the application does not have any
  /// OBB files, these directories may not exist.
  ///
  /// This is like \#getFilesDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// Shared storage devices returned here are considered a stable part of the
  /// device, including physical media slots under a protective cover. The
  /// returned paths do not include transient devices, such as USB flash drives
  /// connected to handheld devices.
  ///
  /// An application may store data on any or all of the returned devices. For
  /// example, an app may choose to store large files on the device with the
  /// most available space, as measured by StatFs.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path. Write access outside of these paths
  /// on secondary external storage devices is not available.
  ///@return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         \#getObbDir()
  ///@see \#getObbDir()
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getObbDirs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getObbDirs, jni.JniType.objectType, []).object);

  static final _id_getCacheDir =
      jniAccessors.getMethodIDOf(_classRef, "getCacheDir", "()Ljava/io/File;");

  /// from: public abstract java.io.File getCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the application specific cache directory on
  /// the filesystem.
  ///
  /// The system will automatically delete files in this directory as disk
  /// space is needed elsewhere on the device. The system will always delete
  /// older files first, as reported by File\#lastModified(). If
  /// desired, you can exert more control over how files are deleted using
  /// StorageManager\#setCacheBehaviorGroup(File, boolean) and
  /// StorageManager\#setCacheBehaviorTombstone(File, boolean).
  ///
  /// Apps are strongly encouraged to keep their usage of cache space below the
  /// quota returned by
  /// StorageManager\#getCacheQuotaBytes(java.util.UUID). If your app
  /// goes above this quota, your cached files will be some of the first to be
  /// deleted when additional disk space is needed. Conversely, if your app
  /// stays under this quota, your cached files will be some of the last to be
  /// deleted when additional disk space is needed.
  ///
  /// Note that your cache quota will change over time depending on how
  /// frequently the user interacts with your app, and depending on how much
  /// system-wide disk space is used.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// Apps require no extra permissions to read or write to the returned path,
  /// since this path lives in their private storage.
  ///@return The path of the directory holding application cache files.
  ///@see \#openFileOutput
  ///@see \#getFileStreamPath
  ///@see \#getDir
  ///@see \#getExternalCacheDir
  jni.JniObject getCacheDir() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCacheDir, jni.JniType.objectType, []).object);

  static final _id_getCodeCacheDir = jniAccessors.getMethodIDOf(
      _classRef, "getCodeCacheDir", "()Ljava/io/File;");

  /// from: public abstract java.io.File getCodeCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the application specific cache directory on
  /// the filesystem designed for storing cached code.
  ///
  /// The system will delete any files stored in this location both when your
  /// specific application is upgraded, and when the entire platform is
  /// upgraded.
  ///
  /// This location is optimal for storing compiled or optimized code generated
  /// by your application at runtime.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// Apps require no extra permissions to read or write to the returned path,
  /// since this path lives in their private storage.
  ///@return The path of the directory holding application code cache files.
  jni.JniObject getCodeCacheDir() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCodeCacheDir, jni.JniType.objectType, []).object);

  static final _id_getExternalCacheDir = jniAccessors.getMethodIDOf(
      _classRef, "getExternalCacheDir", "()Ljava/io/File;");

  /// from: public abstract java.io.File getExternalCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute path to application-specific directory on the primary
  /// shared/external storage device where the application can place cache
  /// files it owns. These files are internal to the application, and not
  /// typically visible to the user as media.
  ///
  /// This is like \#getCacheDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>The platform does not always monitor the space available in shared
  /// storage, and thus may not automatically delete these files. Apps should
  /// always manage the maximum space used in this location. Currently the only
  /// time files here will be deleted by the platform is when running on
  /// android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1 or later and
  /// Environment\#isExternalStorageEmulated(File) returns true.
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// If a shared storage device is emulated (as determined by
  /// Environment\#isExternalStorageEmulated(File)), its contents are
  /// backed by a private user data partition, which means there is little
  /// benefit to storing data here instead of the private directory returned by
  /// \#getCacheDir().
  ///
  /// Starting in android.os.Build.VERSION_CODES\#KITKAT, no permissions
  /// are required to read or write to the returned path; it's always
  /// accessible to the calling app. This only applies to paths generated for
  /// package name of the calling application. To access paths belonging to
  /// other packages,
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE and/or
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE are required.
  ///
  /// On devices with multiple users (as described by UserManager),
  /// each user has their own isolated shared storage. Applications only have
  /// access to the shared storage for the user they're running as.
  ///
  /// The returned path may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///@return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  ///@see \#getCacheDir
  ///@see \#getExternalCacheDirs()
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalCacheDir() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getExternalCacheDir, jni.JniType.objectType, []).object);

  static final _id_getExternalCacheDirs = jniAccessors.getMethodIDOf(
      _classRef, "getExternalCacheDirs", "()[Ljava/io/File;");

  /// from: public abstract java.io.File[] getExternalCacheDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place cache
  /// files it owns. These files are internal to the application, and not
  /// typically visible to the user as media.
  ///
  /// This is like \#getCacheDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>The platform does not always monitor the space available in shared
  /// storage, and thus may not automatically delete these files. Apps should
  /// always manage the maximum space used in this location. Currently the only
  /// time files here will be deleted by the platform is when running on
  /// android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1 or later and
  /// Environment\#isExternalStorageEmulated(File) returns true.
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// If a shared storage device is emulated (as determined by
  /// Environment\#isExternalStorageEmulated(File)), it's contents are
  /// backed by a private user data partition, which means there is little
  /// benefit to storing data here instead of the private directory returned by
  /// \#getCacheDir().
  ///
  /// Shared storage devices returned here are considered a stable part of the
  /// device, including physical media slots under a protective cover. The
  /// returned paths do not include transient devices, such as USB flash drives
  /// connected to handheld devices.
  ///
  /// An application may store data on any or all of the returned devices. For
  /// example, an app may choose to store large files on the device with the
  /// most available space, as measured by StatFs.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path. Write access outside of these paths
  /// on secondary external storage devices is not available.
  ///
  /// The returned paths may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///@return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         \#getExternalCacheDir().
  ///@see \#getExternalCacheDir()
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalCacheDirs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getExternalCacheDirs, jni.JniType.objectType, []).object);

  static final _id_getExternalMediaDirs = jniAccessors.getMethodIDOf(
      _classRef, "getExternalMediaDirs", "()[Ljava/io/File;");

  /// from: public abstract java.io.File[] getExternalMediaDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place media
  /// files. These files are scanned and made available to other apps through
  /// MediaStore.
  ///
  /// This is like \#getExternalFilesDirs in that these files will be
  /// deleted when the application is uninstalled, however there are some
  /// important differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// Shared storage devices returned here are considered a stable part of the
  /// device, including physical media slots under a protective cover. The
  /// returned paths do not include transient devices, such as USB flash drives
  /// connected to handheld devices.
  ///
  /// An application may store data on any or all of the returned devices. For
  /// example, an app may choose to store large files on the device with the
  /// most available space, as measured by StatFs.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path. Write access outside of these paths
  /// on secondary external storage devices is not available.
  ///
  /// The returned paths may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///@return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available.
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalMediaDirs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getExternalMediaDirs, jni.JniType.objectType, []).object);

  static final _id_fileList = jniAccessors.getMethodIDOf(
      _classRef, "fileList", "()[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] fileList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of strings naming the private files associated with
  /// this Context's application package.
  ///@return Array of strings naming the private files.
  ///@see \#openFileInput
  ///@see \#openFileOutput
  ///@see \#deleteFile
  jni.JniObject fileList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_fileList, jni.JniType.objectType, []).object);

  static final _id_getDir = jniAccessors.getMethodIDOf(
      _classRef, "getDir", "(Ljava/lang/String;I)Ljava/io/File;");

  /// from: public abstract java.io.File getDir(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve, creating if needed, a new directory in which the application
  /// can place its own custom data files.  You can use the returned File
  /// object to create and access files in this directory.  Note that files
  /// created through a File object will only be accessible by your own
  /// application; you can only set the mode of the entire directory, not
  /// of individual files.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// Apps require no extra permissions to read or write to the returned path,
  /// since this path lives in their private storage.
  ///@param name Name of the directory to retrieve.  This is a directory
  /// that is created as part of your application data.
  ///@param mode Operating mode.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_APPEND
  ///@return A File object for the requested directory.  The directory
  /// will have been created if it does not already exist.
  ///@see \#openFileOutput(String, int)
  jni.JniObject getDir(jni.JniString name, int mode) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDir, jni.JniType.objectType, [name.reference, mode]).object);

  static final _id_openOrCreateDatabase = jniAccessors.getMethodIDOf(
      _classRef,
      "openOrCreateDatabase",
      "(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase\$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String name, int mode, android.database.sqlite.SQLiteDatabase.CursorFactory factory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a new private SQLiteDatabase associated with this Context's
  /// application package. Create the database file if it doesn't exist.
  ///@param name The name (unique in the application package) of the database.
  ///@param mode Operating mode.
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, android.content.Context\#MODE_ENABLE_WRITE_AHEAD_LOGGING, and android.content.Context\#MODE_NO_LOCALIZED_COLLATORS
  ///@param factory An optional factory class that is called to instantiate a
  ///            cursor when query is called.
  ///@return The contents of a newly created database with the given name.
  ///@throws android.database.sqlite.SQLiteException if the database file
  ///             could not be opened.
  ///@see \#MODE_PRIVATE
  ///@see \#MODE_ENABLE_WRITE_AHEAD_LOGGING
  ///@see \#MODE_NO_LOCALIZED_COLLATORS
  ///@see \#deleteDatabase
  sqlitedatabase_.SQLiteDatabase openOrCreateDatabase(jni.JniString name,
          int mode, sqlitedatabase_.SQLiteDatabase_CursorFactory factory0) =>
      sqlitedatabase_.SQLiteDatabase.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_openOrCreateDatabase,
          jni.JniType.objectType,
          [name.reference, mode, factory0.reference]).object);

  static final _id_openOrCreateDatabase1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openOrCreateDatabase",
      "(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase\$CursorFactory;Landroid/database/DatabaseErrorHandler;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String name, int mode, android.database.sqlite.SQLiteDatabase.CursorFactory factory, android.database.DatabaseErrorHandler errorHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a new private SQLiteDatabase associated with this Context's
  /// application package. Creates the database file if it doesn't exist.
  ///
  /// Accepts input param: a concrete instance of DatabaseErrorHandler
  /// to be used to handle corruption when sqlite reports database corruption.
  ///
  ///
  ///@param name The name (unique in the application package) of the database.
  ///@param mode Operating mode.
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, android.content.Context\#MODE_ENABLE_WRITE_AHEAD_LOGGING, and android.content.Context\#MODE_NO_LOCALIZED_COLLATORS
  ///@param factory An optional factory class that is called to instantiate a
  ///            cursor when query is called.
  ///@param errorHandler the DatabaseErrorHandler to be used when
  ///            sqlite reports database corruption. if null,
  ///            android.database.DefaultDatabaseErrorHandler is
  ///            assumed.
  /// This value may be {@code null}.
  ///@return The contents of a newly created database with the given name.
  ///@throws android.database.sqlite.SQLiteException if the database file
  ///             could not be opened.
  ///@see \#MODE_PRIVATE
  ///@see \#MODE_ENABLE_WRITE_AHEAD_LOGGING
  ///@see \#MODE_NO_LOCALIZED_COLLATORS
  ///@see \#deleteDatabase
  sqlitedatabase_.SQLiteDatabase openOrCreateDatabase1(
          jni.JniString name,
          int mode,
          sqlitedatabase_.SQLiteDatabase_CursorFactory factory0,
          databaseerrorhandler_.DatabaseErrorHandler errorHandler) =>
      sqlitedatabase_.SQLiteDatabase.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_openOrCreateDatabase1, jni.JniType.objectType, [
        name.reference,
        mode,
        factory0.reference,
        errorHandler.reference
      ]).object);

  static final _id_moveDatabaseFrom = jniAccessors.getMethodIDOf(_classRef,
      "moveDatabaseFrom", "(Landroid/content/Context;Ljava/lang/String;)Z");

  /// from: public abstract boolean moveDatabaseFrom(android.content.Context sourceContext, java.lang.String name)
  ///
  /// Move an existing database file from the given source storage context to
  /// this context. This is typically used to migrate data between storage
  /// locations after an upgrade, such as migrating to device protected
  /// storage.
  ///
  /// The database must be closed before being moved.
  ///@param sourceContext The source context which contains the existing
  ///            database to move.
  ///@param name The name of the database file.
  ///@return {@code true} if the move was successful or if the database didn't
  ///         exist in the source context, otherwise {@code false}.
  ///@see \#createDeviceProtectedStorageContext()
  bool moveDatabaseFrom(Context sourceContext, jni.JniString name) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_moveDatabaseFrom,
          jni.JniType.booleanType,
          [sourceContext.reference, name.reference]).boolean;

  static final _id_deleteDatabase = jniAccessors.getMethodIDOf(
      _classRef, "deleteDatabase", "(Ljava/lang/String;)Z");

  /// from: public abstract boolean deleteDatabase(java.lang.String name)
  ///
  /// Delete an existing private SQLiteDatabase associated with this Context's
  /// application package.
  ///@param name The name (unique in the application package) of the
  ///             database.
  ///@return {@code true} if the database was successfully deleted; else {@code false}.
  ///@see \#openOrCreateDatabase
  bool deleteDatabase(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_deleteDatabase,
      jni.JniType.booleanType,
      [name.reference]).boolean;

  static final _id_getDatabasePath = jniAccessors.getMethodIDOf(
      _classRef, "getDatabasePath", "(Ljava/lang/String;)Ljava/io/File;");

  /// from: public abstract java.io.File getDatabasePath(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path on the filesystem where a database created with
  /// \#openOrCreateDatabase is stored.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///@param name The name of the database for which you would like to get
  ///          its path.
  ///@return An absolute path to the given database.
  ///@see \#openOrCreateDatabase
  jni.JniObject getDatabasePath(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDatabasePath,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_databaseList = jniAccessors.getMethodIDOf(
      _classRef, "databaseList", "()[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] databaseList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of strings naming the private databases associated with
  /// this Context's application package.
  ///@return Array of strings naming the private databases.
  ///@see \#openOrCreateDatabase
  ///@see \#deleteDatabase
  jni.JniObject databaseList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_databaseList, jni.JniType.objectType, []).object);

  static final _id_getWallpaper = jniAccessors.getMethodIDOf(
      _classRef, "getWallpaper", "()Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getWallpaper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use android.app.WallpaperManager\#getDrawable WallpaperManager.get() instead.
  drawable_.Drawable getWallpaper() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWallpaper, jni.JniType.objectType, []).object);

  static final _id_peekWallpaper = jniAccessors.getMethodIDOf(
      _classRef, "peekWallpaper", "()Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable peekWallpaper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use android.app.WallpaperManager\#peekDrawable WallpaperManager.peek() instead.
  drawable_.Drawable peekWallpaper() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_peekWallpaper, jni.JniType.objectType, []).object);

  static final _id_getWallpaperDesiredMinimumWidth = jniAccessors.getMethodIDOf(
      _classRef, "getWallpaperDesiredMinimumWidth", "()I");

  /// from: public abstract int getWallpaperDesiredMinimumWidth()
  ///
  /// @deprecated Use android.app.WallpaperManager\#getDesiredMinimumWidth() WallpaperManager.getDesiredMinimumWidth() instead.
  int getWallpaperDesiredMinimumWidth() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getWallpaperDesiredMinimumWidth,
      jni.JniType.intType, []).integer;

  static final _id_getWallpaperDesiredMinimumHeight = jniAccessors
      .getMethodIDOf(_classRef, "getWallpaperDesiredMinimumHeight", "()I");

  /// from: public abstract int getWallpaperDesiredMinimumHeight()
  ///
  /// @deprecated Use android.app.WallpaperManager\#getDesiredMinimumHeight() WallpaperManager.getDesiredMinimumHeight() instead.
  int getWallpaperDesiredMinimumHeight() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getWallpaperDesiredMinimumHeight,
      jni.JniType.intType, []).integer;

  static final _id_setWallpaper = jniAccessors.getMethodIDOf(
      _classRef, "setWallpaper", "(Landroid/graphics/Bitmap;)V");

  /// from: public abstract void setWallpaper(android.graphics.Bitmap bitmap)
  ///
  /// @deprecated Use android.app.WallpaperManager\#setBitmap(Bitmap) WallpaperManager.set() instead.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  void setWallpaper(bitmap_.Bitmap bitmap) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWallpaper,
      jni.JniType.voidType,
      [bitmap.reference]).check();

  static final _id_setWallpaper1 = jniAccessors.getMethodIDOf(
      _classRef, "setWallpaper", "(Ljava/io/InputStream;)V");

  /// from: public abstract void setWallpaper(java.io.InputStream data)
  ///
  /// @deprecated Use android.app.WallpaperManager\#setStream(InputStream) WallpaperManager.set() instead.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  void setWallpaper1(jni.JniObject data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWallpaper1,
      jni.JniType.voidType,
      [data.reference]).check();

  static final _id_clearWallpaper =
      jniAccessors.getMethodIDOf(_classRef, "clearWallpaper", "()V");

  /// from: public abstract void clearWallpaper()
  ///
  /// @deprecated Use android.app.WallpaperManager\#clear WallpaperManager.clear() instead.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  void clearWallpaper() => jniAccessors.callMethodWithArgs(
      reference, _id_clearWallpaper, jni.JniType.voidType, []).check();

  static final _id_startActivity = jniAccessors.getMethodIDOf(
      _classRef, "startActivity", "(Landroid/content/Intent;)V");

  /// from: public abstract void startActivity(android.content.Intent intent)
  ///
  /// Same as \#startActivity(Intent, Bundle) with no options
  /// specified.
  ///@param intent The description of the activity to start.
  ///@throws ActivityNotFoundException &nbsp;
  ///`
  ///@see \#startActivity(Intent, Bundle)
  ///@see PackageManager\#resolveActivity
  void startActivity(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_startActivity,
      jni.JniType.voidType,
      [intent.reference]).check();

  static final _id_startActivity1 = jniAccessors.getMethodIDOf(_classRef,
      "startActivity", "(Landroid/content/Intent;Landroid/os/Bundle;)V");

  /// from: public abstract void startActivity(android.content.Intent intent, android.os.Bundle options)
  ///
  /// Launch a new activity.  You will not receive any information about when
  /// the activity exits.
  ///
  /// Note that if this method is being called from outside of an
  /// android.app.Activity Context, then the Intent must include
  /// the Intent\#FLAG_ACTIVITY_NEW_TASK launch flag.  This is because,
  /// without being started from an existing Activity, there is no existing
  /// task in which to place the new activity and thus it needs to be placed
  /// in its own separate task.
  ///
  /// This method throws ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intent The description of the activity to start.
  ///@param options Additional options for how the Activity should be started.
  /// May be null if there are no options.  See android.app.ActivityOptions
  /// for how to build the Bundle supplied here; there are no supported definitions
  /// for building it manually.
  ///
  /// This value may be {@code null}.
  ///@throws ActivityNotFoundException &nbsp;
  ///@see \#startActivity(Intent)
  ///@see PackageManager\#resolveActivity
  void startActivity1(intent_.Intent intent, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivity1,
          jni.JniType.voidType, [intent.reference, options.reference]).check();

  static final _id_startActivities = jniAccessors.getMethodIDOf(
      _classRef, "startActivities", "([Landroid/content/Intent;)V");

  /// from: public abstract void startActivities(android.content.Intent[] intents)
  ///
  /// Same as \#startActivities(Intent[], Bundle) with no options
  /// specified.
  ///@param intents An array of Intents to be started.
  ///@throws ActivityNotFoundException &nbsp;
  ///@see \#startActivities(Intent[], Bundle)
  ///@see PackageManager\#resolveActivity
  void startActivities(jni.JniObject intents) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivities,
          jni.JniType.voidType, [intents.reference]).check();

  static final _id_startActivities1 = jniAccessors.getMethodIDOf(_classRef,
      "startActivities", "([Landroid/content/Intent;Landroid/os/Bundle;)V");

  /// from: public abstract void startActivities(android.content.Intent[] intents, android.os.Bundle options)
  ///
  /// Launch multiple new activities.  This is generally the same as calling
  /// \#startActivity(Intent) for the first Intent in the array,
  /// that activity during its creation calling \#startActivity(Intent)
  /// for the second entry, etc.  Note that unlike that approach, generally
  /// none of the activities except the last in the array will be created
  /// at this point, but rather will be created when the user first visits
  /// them (due to pressing back from the activity on top).
  ///
  /// This method throws ActivityNotFoundException
  /// if there was no Activity found for _any_ given Intent.  In this
  /// case the state of the activity stack is undefined (some Intents in the
  /// list may be on it, some not), so you probably want to avoid such situations.
  ///@param intents An array of Intents to be started.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///@throws ActivityNotFoundException &nbsp;
  ///@see \#startActivities(Intent[])
  ///@see PackageManager\#resolveActivity
  void startActivities1(jni.JniObject intents, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivities1,
          jni.JniType.voidType, [intents.reference, options.reference]).check();

  static final _id_startIntentSender = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSender",
      "(Landroid/content/IntentSender;Landroid/content/Intent;III)V");

  /// from: public abstract void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  ///
  /// Same as \#startIntentSender(IntentSender, Intent, int, int, int, Bundle)
  /// with no options specified.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@param extraFlags Always set to 0.
  ///@see \#startActivity(Intent)
  ///@see \#startIntentSender(IntentSender, Intent, int, int, int, Bundle)
  void startIntentSender(
          intentsender_.IntentSender intent,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSender, jni.JniType.voidType, [
        intent.reference,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags
      ]).check();

  static final _id_startIntentSender1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startIntentSender",
      "(Landroid/content/IntentSender;Landroid/content/Intent;IIILandroid/os/Bundle;)V");

  /// from: public abstract void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Like \#startActivity(Intent, Bundle), but taking a IntentSender
  /// to start.  If the IntentSender is for an activity, that activity will be started
  /// as if you had called the regular \#startActivity(Intent)
  /// here; otherwise, its associated action will be executed (such as
  /// sending a broadcast) as if you had called
  /// IntentSender\#sendIntent IntentSender.sendIntent on it.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@param extraFlags Always set to 0.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.  If options
  /// have also been supplied by the IntentSender, options given here will
  /// override any that conflict with those given by the IntentSender.
  ///
  /// This value may be {@code null}.
  ///@see \#startActivity(Intent, Bundle)
  ///@see \#startIntentSender(IntentSender, Intent, int, int, int)
  void startIntentSender1(
          intentsender_.IntentSender intent,
          intent_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startIntentSender1, jni.JniType.voidType, [
        intent.reference,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags,
        options.reference
      ]).check();

  static final _id_sendBroadcast = jniAccessors.getMethodIDOf(
      _classRef, "sendBroadcast", "(Landroid/content/Intent;)V");

  /// from: public abstract void sendBroadcast(android.content.Intent intent)
  ///
  /// Broadcast the given intent to all interested BroadcastReceivers.  This
  /// call is asynchronous; it returns immediately, and you will continue
  /// executing while the receivers are run.  No results are propagated from
  /// receivers and receivers can not abort the broadcast. If you want
  /// to allow receivers to propagate results or abort the broadcast, you must
  /// send an ordered broadcast using
  /// \#sendOrderedBroadcast(Intent, String).
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see \#sendBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  void sendBroadcast(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendBroadcast,
      jni.JniType.voidType,
      [intent.reference]).check();

  static final _id_sendBroadcast1 = jniAccessors.getMethodIDOf(_classRef,
      "sendBroadcast", "(Landroid/content/Intent;Ljava/lang/String;)V");

  /// from: public abstract void sendBroadcast(android.content.Intent intent, java.lang.String receiverPermission)
  ///
  /// Broadcast the given intent to all interested BroadcastReceivers, allowing
  /// an optional required permission to be enforced.  This
  /// call is asynchronous; it returns immediately, and you will continue
  /// executing while the receivers are run.  No results are propagated from
  /// receivers and receivers can not abort the broadcast. If you want
  /// to allow receivers to propagate results or abort the broadcast, you must
  /// send an ordered broadcast using
  /// \#sendOrderedBroadcast(Intent, String).
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param receiverPermission (optional) String naming a permission that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendOrderedBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  void sendBroadcast1(
          intent_.Intent intent, jni.JniString receiverPermission) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendBroadcast1,
          jni.JniType.voidType,
          [intent.reference, receiverPermission.reference]).check();

  static final _id_sendOrderedBroadcast = jniAccessors.getMethodIDOf(_classRef,
      "sendOrderedBroadcast", "(Landroid/content/Intent;Ljava/lang/String;)V");

  /// from: public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String receiverPermission)
  ///
  /// Broadcast the given intent to all interested BroadcastReceivers, delivering
  /// them one at a time to allow more preferred receivers to consume the
  /// broadcast before it is delivered to less preferred receivers.  This
  /// call is asynchronous; it returns immediately, and you will continue
  /// executing while the receivers are run.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param receiverPermission (optional) String naming a permissions that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  void sendOrderedBroadcast(
          intent_.Intent intent, jni.JniString receiverPermission) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendOrderedBroadcast,
          jni.JniType.voidType,
          [intent.reference, receiverPermission.reference]).check();

  static final _id_sendOrderedBroadcast1 = jniAccessors.getMethodIDOf(
      _classRef,
      "sendOrderedBroadcast",
      "(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V");

  /// from: public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String receiverPermission, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  ///
  /// Version of \#sendBroadcast(Intent) that allows you to
  /// receive data back from the broadcast.  This is accomplished by
  /// supplying your own BroadcastReceiver when calling, which will be
  /// treated as a final receiver at the end of the broadcast -- its
  /// BroadcastReceiver\#onReceive method will be called with
  /// the result values collected from the other receivers.  The broadcast will
  /// be serialized in the same way as calling
  /// \#sendOrderedBroadcast(Intent, String).
  ///
  /// Like \#sendBroadcast(Intent), this method is
  /// asynchronous; it will return before
  /// resultReceiver.onReceive() is called.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  /// This value must never be {@code null}.
  ///@param receiverPermission String naming a permissions that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  /// This value may be {@code null}.
  ///@param resultReceiver Your own BroadcastReceiver to treat as the final
  ///                       receiver of the broadcast.
  /// This value may be {@code null}.
  ///@param scheduler A custom Handler with which to schedule the
  ///                  resultReceiver callback; if null it will be
  ///                  scheduled in the Context's main thread.
  /// This value may be {@code null}.
  ///@param initialCode An initial value for the result code.  Often
  ///                    Activity.RESULT_OK.
  ///@param initialData An initial value for the result data.  Often
  ///                    null.
  /// This value may be {@code null}.
  ///@param initialExtras An initial value for the result extras.  Often
  ///                      null.
  ///
  /// This value may be {@code null}.
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String)
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see android.app.Activity\#RESULT_OK
  void sendOrderedBroadcast1(
          intent_.Intent intent,
          jni.JniString receiverPermission,
          broadcastreceiver_.BroadcastReceiver resultReceiver,
          handler_.Handler scheduler,
          int initialCode,
          jni.JniString initialData,
          bundle_.Bundle initialExtras) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendOrderedBroadcast1, jni.JniType.voidType, [
        intent.reference,
        receiverPermission.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference
      ]).check();

  static final _id_sendBroadcastAsUser = jniAccessors.getMethodIDOf(
      _classRef,
      "sendBroadcastAsUser",
      "(Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Version of \#sendBroadcast(Intent) that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS
  ///@param intent The intent to broadcast
  ///@param user UserHandle to send the intent to.
  ///@see \#sendBroadcast(Intent)
  void sendBroadcastAsUser(
          intent_.Intent intent, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendBroadcastAsUser,
          jni.JniType.voidType, [intent.reference, user.reference]).check();

  static final _id_sendBroadcastAsUser1 = jniAccessors.getMethodIDOf(
      _classRef,
      "sendBroadcastAsUser",
      "(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;)V");

  /// from: public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, java.lang.String receiverPermission)
  ///
  /// Version of \#sendBroadcast(Intent, String) that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param user UserHandle to send the intent to.
  ///@param receiverPermission (optional) String naming a permission that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see \#sendBroadcast(Intent, String)
  void sendBroadcastAsUser1(intent_.Intent intent, userhandle_.UserHandle user,
          jni.JniString receiverPermission) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendBroadcastAsUser1, jni.JniType.voidType, [
        intent.reference,
        user.reference,
        receiverPermission.reference
      ]).check();

  static final _id_sendOrderedBroadcastAsUser = jniAccessors.getMethodIDOf(
      _classRef,
      "sendOrderedBroadcastAsUser",
      "(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V");

  /// from: public abstract void sendOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, java.lang.String receiverPermission, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  ///
  /// Version of
  /// \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  /// that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param user UserHandle to send the intent to.
  ///@param receiverPermission String naming a permissions that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  /// This value may be {@code null}.
  ///@param resultReceiver Your own BroadcastReceiver to treat as the final
  ///                       receiver of the broadcast.
  ///@param scheduler A custom Handler with which to schedule the
  ///                  resultReceiver callback; if null it will be
  ///                  scheduled in the Context's main thread.
  /// This value may be {@code null}.
  ///@param initialCode An initial value for the result code.  Often
  ///                    Activity.RESULT_OK.
  ///@param initialData An initial value for the result data.  Often
  ///                    null.
  /// This value may be {@code null}.
  ///@param initialExtras An initial value for the result extras.  Often
  ///                      null.
  ///
  /// This value may be {@code null}.
  ///@see \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  void sendOrderedBroadcastAsUser(
          intent_.Intent intent,
          userhandle_.UserHandle user,
          jni.JniString receiverPermission,
          broadcastreceiver_.BroadcastReceiver resultReceiver,
          handler_.Handler scheduler,
          int initialCode,
          jni.JniString initialData,
          bundle_.Bundle initialExtras) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendOrderedBroadcastAsUser, jni.JniType.voidType, [
        intent.reference,
        user.reference,
        receiverPermission.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference
      ]).check();

  static final _id_sendStickyBroadcast = jniAccessors.getMethodIDOf(
      _classRef, "sendStickyBroadcast", "(Landroid/content/Intent;)V");

  /// from: public abstract void sendStickyBroadcast(android.content.Intent intent)
  ///
  /// Perform a \#sendBroadcast(Intent) that is "sticky," meaning the
  /// Intent you are sending stays around after the broadcast is complete,
  /// so that others can quickly retrieve that data through the return
  /// value of \#registerReceiver(BroadcastReceiver, IntentFilter).  In
  /// all other ways, this behaves the same as
  /// \#sendBroadcast(Intent).
  ///
  /// Requires android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent to broadcast; all receivers matching this
  /// Intent will receive the broadcast, and the Intent will be held to
  /// be re-broadcast to future receivers.
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
  void sendStickyBroadcast(intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendStickyBroadcast,
          jni.JniType.voidType, [intent.reference]).check();

  static final _id_sendStickyOrderedBroadcast = jniAccessors.getMethodIDOf(
      _classRef,
      "sendStickyOrderedBroadcast",
      "(Landroid/content/Intent;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V");

  /// from: public abstract void sendStickyOrderedBroadcast(android.content.Intent intent, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  ///
  /// Version of \#sendStickyBroadcast that allows you to
  /// receive data back from the broadcast.  This is accomplished by
  /// supplying your own BroadcastReceiver when calling, which will be
  /// treated as a final receiver at the end of the broadcast -- its
  /// BroadcastReceiver\#onReceive method will be called with
  /// the result values collected from the other receivers.  The broadcast will
  /// be serialized in the same way as calling
  /// \#sendOrderedBroadcast(Intent, String).
  ///
  /// Like \#sendBroadcast(Intent), this method is
  /// asynchronous; it will return before
  /// resultReceiver.onReceive() is called.  Note that the sticky data
  /// stored is only the data you initially supply to the broadcast, not
  /// the result of any changes made by the receivers.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// Requires android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param resultReceiver Your own BroadcastReceiver to treat as the final
  ///                       receiver of the broadcast.
  ///@param scheduler A custom Handler with which to schedule the
  ///                  resultReceiver callback; if null it will be
  ///                  scheduled in the Context's main thread.
  /// This value may be {@code null}.
  ///@param initialCode An initial value for the result code.  Often
  ///                    Activity.RESULT_OK.
  ///@param initialData An initial value for the result data.  Often
  ///                    null.
  /// This value may be {@code null}.
  ///@param initialExtras An initial value for the result extras.  Often
  ///                      null.
  ///
  /// This value may be {@code null}.
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String)
  ///@see \#sendStickyBroadcast(Intent)
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see android.app.Activity\#RESULT_OK
  void sendStickyOrderedBroadcast(
          intent_.Intent intent,
          broadcastreceiver_.BroadcastReceiver resultReceiver,
          handler_.Handler scheduler,
          int initialCode,
          jni.JniString initialData,
          bundle_.Bundle initialExtras) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendStickyOrderedBroadcast, jni.JniType.voidType, [
        intent.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference
      ]).check();

  static final _id_removeStickyBroadcast = jniAccessors.getMethodIDOf(
      _classRef, "removeStickyBroadcast", "(Landroid/content/Intent;)V");

  /// from: public abstract void removeStickyBroadcast(android.content.Intent intent)
  ///
  /// Remove the data previously sent with \#sendStickyBroadcast,
  /// so that it is as if the sticky broadcast had never happened.
  ///
  /// Requires android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent that was previously broadcast.
  ///@see \#sendStickyBroadcast
  void removeStickyBroadcast(intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeStickyBroadcast,
          jni.JniType.voidType, [intent.reference]).check();

  static final _id_sendStickyBroadcastAsUser = jniAccessors.getMethodIDOf(
      _classRef,
      "sendStickyBroadcastAsUser",
      "(Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public abstract void sendStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Version of \#sendStickyBroadcast(Intent) that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS and android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent to broadcast; all receivers matching this
  /// Intent will receive the broadcast, and the Intent will be held to
  /// be re-broadcast to future receivers.
  ///@param user UserHandle to send the intent to.
  ///@see \#sendBroadcast(Intent)
  void sendStickyBroadcastAsUser(
          intent_.Intent intent, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendStickyBroadcastAsUser,
          jni.JniType.voidType, [intent.reference, user.reference]).check();

  static final _id_sendStickyOrderedBroadcastAsUser = jniAccessors.getMethodIDOf(
      _classRef,
      "sendStickyOrderedBroadcastAsUser",
      "(Landroid/content/Intent;Landroid/os/UserHandle;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V");

  /// from: public abstract void sendStickyOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  ///
  /// Version of
  /// \#sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
  /// that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS and android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param user UserHandle to send the intent to.
  ///@param resultReceiver Your own BroadcastReceiver to treat as the final
  ///                       receiver of the broadcast.
  ///@param scheduler A custom Handler with which to schedule the
  ///                  resultReceiver callback; if null it will be
  ///                  scheduled in the Context's main thread.
  /// This value may be {@code null}.
  ///@param initialCode An initial value for the result code.  Often
  ///                    Activity.RESULT_OK.
  ///@param initialData An initial value for the result data.  Often
  ///                    null.
  /// This value may be {@code null}.
  ///@param initialExtras An initial value for the result extras.  Often
  ///                      null.
  ///
  /// This value may be {@code null}.
  ///@see \#sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
  void sendStickyOrderedBroadcastAsUser(
          intent_.Intent intent,
          userhandle_.UserHandle user,
          broadcastreceiver_.BroadcastReceiver resultReceiver,
          handler_.Handler scheduler,
          int initialCode,
          jni.JniString initialData,
          bundle_.Bundle initialExtras) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_sendStickyOrderedBroadcastAsUser, jni.JniType.voidType, [
        intent.reference,
        user.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference
      ]).check();

  static final _id_removeStickyBroadcastAsUser = jniAccessors.getMethodIDOf(
      _classRef,
      "removeStickyBroadcastAsUser",
      "(Landroid/content/Intent;Landroid/os/UserHandle;)V");

  /// from: public abstract void removeStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Version of \#removeStickyBroadcast(Intent) that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// You must hold the android.Manifest.permission\#BROADCAST_STICKY
  /// permission in order to use this API.  If you do not hold that
  /// permission, SecurityException will be thrown.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS and android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent that was previously broadcast.
  ///@param user UserHandle to remove the sticky broadcast from.
  ///@see \#sendStickyBroadcastAsUser
  void removeStickyBroadcastAsUser(
          intent_.Intent intent, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeStickyBroadcastAsUser,
          jni.JniType.voidType,
          [intent.reference, user.reference]).check();

  static final _id_registerReceiver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerReceiver",
      "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;");

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Register a BroadcastReceiver to be run in the main activity thread.  The
  /// <var>receiver</var> will be called with any broadcast Intent that
  /// matches <var>filter</var>, in the main application thread.
  ///
  /// The system may broadcast Intents that are "sticky" -- these stay
  /// around after the broadcast has finished, to be sent to any later
  /// registrations. If your IntentFilter matches one of these sticky
  /// Intents, that Intent will be returned by this function
  /// <strong>and</strong> sent to your <var>receiver</var> as if it had just
  /// been broadcast.
  ///
  /// There may be multiple sticky Intents that match <var>filter</var>,
  /// in which case each of these will be sent to <var>receiver</var>.  In
  /// this case, only one of these can be returned directly by the function;
  /// which of these that is returned is arbitrarily decided by the system.
  ///
  /// If you know the Intent your are registering for is sticky, you can
  /// supply null for your <var>receiver</var>.  In this case, no receiver is
  /// registered -- the function simply returns the sticky Intent that
  /// matches <var>filter</var>.  In the case of multiple matches, the same
  /// rules as described above apply.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// As of android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH, receivers
  /// registered with this method will correctly respect the
  /// Intent\#setPackage(String) specified for an Intent being broadcast.
  /// Prior to that, it would be ignored and delivered to all matching registered
  /// receivers.  Be careful if using this for security.
  ///
  ///
  /// <p class="note">Note: this method _cannot be called from a
  /// BroadcastReceiver component;_ that is, from a BroadcastReceiver
  /// that is declared in an application's manifest.  It is okay, however, to call
  /// this method from another BroadcastReceiver that has itself been registered
  /// at run time with \#registerReceiver, since the lifetime of such a
  /// registered BroadcastReceiver is tied to the object that registered it.
  ///
  ///@param receiver The BroadcastReceiver to handle the broadcast.
  /// This value may be {@code null}.
  ///@param filter Selects the Intent broadcasts to be received.
  ///@return The first sticky intent found that matches <var>filter</var>,
  ///         or null if there are none.
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
  ///@see \#sendBroadcast
  ///@see \#unregisterReceiver
  intent_.Intent registerReceiver(broadcastreceiver_.BroadcastReceiver receiver,
          intentfilter_.IntentFilter filter) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_registerReceiver,
          jni.JniType.objectType,
          [receiver.reference, filter.reference]).object);

  static final _id_registerReceiver1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerReceiver",
      "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;I)Landroid/content/Intent;");

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Register to receive intent broadcasts, with the receiver optionally being
  /// exposed to Instant Apps. See
  /// \#registerReceiver(BroadcastReceiver, IntentFilter) for more
  /// information. By default Instant Apps cannot interact with receivers in other
  /// applications, this allows you to expose a receiver that Instant Apps can
  /// interact with.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// As of android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH, receivers
  /// registered with this method will correctly respect the
  /// Intent\#setPackage(String) specified for an Intent being broadcast.
  /// Prior to that, it would be ignored and delivered to all matching registered
  /// receivers.  Be careful if using this for security.
  ///
  ///@param receiver The BroadcastReceiver to handle the broadcast.
  /// This value may be {@code null}.
  ///@param filter Selects the Intent broadcasts to be received.
  ///@param flags Additional options for the receiver. May be 0 or
  ///      \#RECEIVER_VISIBLE_TO_INSTANT_APPS.
  ///
  /// Value is either <code>0</code> or android.content.Context\#RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@return The first sticky intent found that matches <var>filter</var>,
  ///         or null if there are none.
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter)
  ///@see \#sendBroadcast
  ///@see \#unregisterReceiver
  intent_.Intent registerReceiver1(
          broadcastreceiver_.BroadcastReceiver receiver,
          intentfilter_.IntentFilter filter,
          int flags) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_registerReceiver1,
          jni.JniType.objectType,
          [receiver.reference, filter.reference, flags]).object);

  static final _id_registerReceiver2 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerReceiver",
      "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;)Landroid/content/Intent;");

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, java.lang.String broadcastPermission, android.os.Handler scheduler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Register to receive intent broadcasts, to run in the context of
  /// <var>scheduler</var>.  See
  /// \#registerReceiver(BroadcastReceiver, IntentFilter) for more
  /// information.  This allows you to enforce permissions on who can
  /// broadcast intents to your receiver, or have the receiver run in
  /// a different thread than the main application thread.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// As of android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH, receivers
  /// registered with this method will correctly respect the
  /// Intent\#setPackage(String) specified for an Intent being broadcast.
  /// Prior to that, it would be ignored and delivered to all matching registered
  /// receivers.  Be careful if using this for security.
  ///
  ///@param receiver The BroadcastReceiver to handle the broadcast.
  ///@param filter Selects the Intent broadcasts to be received.
  ///@param broadcastPermission String naming a permissions that a
  ///      broadcaster must hold in order to send an Intent to you.  If null,
  ///      no permission is required.
  /// This value may be {@code null}.
  ///@param scheduler Handler identifying the thread that will receive
  ///      the Intent.  If null, the main thread of the process will be used.
  ///
  /// This value may be {@code null}.
  ///@return The first sticky intent found that matches <var>filter</var>,
  ///         or null if there are none.
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter)
  ///@see \#sendBroadcast
  ///@see \#unregisterReceiver
  intent_.Intent registerReceiver2(
          broadcastreceiver_.BroadcastReceiver receiver,
          intentfilter_.IntentFilter filter,
          jni.JniString broadcastPermission,
          handler_.Handler scheduler) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_registerReceiver2, jni.JniType.objectType, [
        receiver.reference,
        filter.reference,
        broadcastPermission.reference,
        scheduler.reference
      ]).object);

  static final _id_registerReceiver3 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerReceiver",
      "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;I)Landroid/content/Intent;");

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, java.lang.String broadcastPermission, android.os.Handler scheduler, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Register to receive intent broadcasts, to run in the context of
  /// <var>scheduler</var>. See
  /// \#registerReceiver(BroadcastReceiver, IntentFilter, int) and
  /// \#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
  /// for more information.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// As of android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH, receivers
  /// registered with this method will correctly respect the
  /// Intent\#setPackage(String) specified for an Intent being broadcast.
  /// Prior to that, it would be ignored and delivered to all matching registered
  /// receivers.  Be careful if using this for security.
  ///
  ///@param receiver The BroadcastReceiver to handle the broadcast.
  ///@param filter Selects the Intent broadcasts to be received.
  ///@param broadcastPermission String naming a permissions that a
  ///      broadcaster must hold in order to send an Intent to you.  If null,
  ///      no permission is required.
  /// This value may be {@code null}.
  ///@param scheduler Handler identifying the thread that will receive
  ///      the Intent.  If null, the main thread of the process will be used.
  /// This value may be {@code null}.
  ///@param flags Additional options for the receiver. May be 0 or
  ///      \#RECEIVER_VISIBLE_TO_INSTANT_APPS.
  ///
  /// Value is either <code>0</code> or android.content.Context\#RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@return The first sticky intent found that matches <var>filter</var>,
  ///         or null if there are none.
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter, int)
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
  ///@see \#sendBroadcast
  ///@see \#unregisterReceiver
  intent_.Intent registerReceiver3(
          broadcastreceiver_.BroadcastReceiver receiver,
          intentfilter_.IntentFilter filter,
          jni.JniString broadcastPermission,
          handler_.Handler scheduler,
          int flags) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_registerReceiver3, jni.JniType.objectType, [
        receiver.reference,
        filter.reference,
        broadcastPermission.reference,
        scheduler.reference,
        flags
      ]).object);

  static final _id_unregisterReceiver = jniAccessors.getMethodIDOf(_classRef,
      "unregisterReceiver", "(Landroid/content/BroadcastReceiver;)V");

  /// from: public abstract void unregisterReceiver(android.content.BroadcastReceiver receiver)
  ///
  /// Unregister a previously registered BroadcastReceiver.  _All_
  /// filters that have been registered for this BroadcastReceiver will be
  /// removed.
  ///@param receiver The BroadcastReceiver to unregister.
  ///@see \#registerReceiver
  void unregisterReceiver(broadcastreceiver_.BroadcastReceiver receiver) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterReceiver,
          jni.JniType.voidType, [receiver.reference]).check();

  static final _id_startService = jniAccessors.getMethodIDOf(
      _classRef,
      "startService",
      "(Landroid/content/Intent;)Landroid/content/ComponentName;");

  /// from: public abstract android.content.ComponentName startService(android.content.Intent service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request that a given application service be started.  The Intent
  /// should either contain the complete class name of a specific service
  /// implementation to start, or a specific package name to target.  If the
  /// Intent is less specified, it logs a warning about this.  In this case any of the
  /// multiple matching services may be used.  If this service
  /// is not already running, it will be instantiated and started (creating a
  /// process for it if needed); if it is running then it remains running.
  ///
  /// Every call to this method will result in a corresponding call to
  /// the target service's android.app.Service\#onStartCommand method,
  /// with the <var>intent</var> given here.  This provides a convenient way
  /// to submit jobs to a service without having to bind and call on to its
  /// interface.
  ///
  /// Using startService() overrides the default service lifetime that is
  /// managed by \#bindService: it requires the service to remain
  /// running until \#stopService is called, regardless of whether
  /// any clients are connected to it.  Note that calls to startService()
  /// do not nest: no matter how many times you call startService(),
  /// a single call to \#stopService will stop it.
  ///
  /// The system attempts to keep running services around as much as
  /// possible.  The only time they should be stopped is if the current
  /// foreground application is using so many resources that the service needs
  /// to be killed.  If any errors happen in the service's process, it will
  /// automatically be restarted.
  ///
  /// This function will throw SecurityException if you do not
  /// have permission to start the given service.
  ///
  /// <p class="note"><strong>Note:</strong> Each call to startService()
  /// results in significant work done by the system to manage service
  /// lifecycle surrounding the processing of the intent, which can take
  /// multiple milliseconds of CPU time. Due to this cost, startService()
  /// should not be used for frequent intent delivery to a service, and only
  /// for scheduling significant work. Use \#bindService bound services
  /// for high frequency calls.
  ///
  ///
  ///@param service Identifies the service to be started.  The Intent must be
  ///      fully explicit (supplying a component name).  Additional values
  ///      may be included in the Intent extras to supply arguments along with
  ///      this specific start call.
  ///@return If the service is being started or is already running, the
  /// ComponentName of the actual service that was started is
  /// returned; else if the service does not exist null is returned.
  ///@throws SecurityException If the caller does not have permission to access the service
  /// or the service can not be found.
  ///@throws IllegalStateException If the application is in a state where the service
  /// can not be started (such as not in the foreground in a state when services are allowed).
  ///@see \#stopService
  ///@see \#bindService
  componentname_.ComponentName startService(intent_.Intent service) =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startService,
          jni.JniType.objectType,
          [service.reference]).object);

  static final _id_startForegroundService = jniAccessors.getMethodIDOf(
      _classRef,
      "startForegroundService",
      "(Landroid/content/Intent;)Landroid/content/ComponentName;");

  /// from: public abstract android.content.ComponentName startForegroundService(android.content.Intent service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Similar to \#startService(Intent), but with an implicit promise that the
  /// Service will call android.app.Service\#startForeground(int, android.app.Notification) startForeground(int, android.app.Notification) once it begins running.  The service is given
  /// an amount of time comparable to the ANR interval to do this, otherwise the system
  /// will automatically stop the service and declare the app ANR.
  ///
  /// Unlike the ordinary \#startService(Intent), this method can be used
  /// at any time, regardless of whether the app hosting the service is in a foreground
  /// state.
  ///@param service Identifies the service to be started.  The Intent must be
  ///      fully explicit (supplying a component name).  Additional values
  ///      may be included in the Intent extras to supply arguments along with
  ///      this specific start call.
  ///@return If the service is being started or is already running, the
  /// ComponentName of the actual service that was started is
  /// returned; else if the service does not exist null is returned.
  ///@throws SecurityException If the caller does not have permission to access the service
  /// or the service can not be found.
  ///@see \#stopService
  ///@see android.app.Service\#startForeground(int, android.app.Notification)
  componentname_.ComponentName startForegroundService(intent_.Intent service) =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_startForegroundService,
          jni.JniType.objectType,
          [service.reference]).object);

  static final _id_stopService = jniAccessors.getMethodIDOf(
      _classRef, "stopService", "(Landroid/content/Intent;)Z");

  /// from: public abstract boolean stopService(android.content.Intent service)
  ///
  /// Request that a given application service be stopped.  If the service is
  /// not running, nothing happens.  Otherwise it is stopped.  Note that calls
  /// to startService() are not counted -- this stops the service no matter
  /// how many times it was started.
  ///
  /// Note that if a stopped service still has ServiceConnection
  /// objects bound to it with the \#BIND_AUTO_CREATE set, it will
  /// not be destroyed until all of these bindings are removed.  See
  /// the android.app.Service documentation for more details on a
  /// service's lifecycle.
  ///
  /// This function will throw SecurityException if you do not
  /// have permission to stop the given service.
  ///@param service Description of the service to be stopped.  The Intent must be either
  ///      fully explicit (supplying a component name) or specify a specific package
  ///      name it is targetted to.
  ///@return If there is a service matching the given Intent that is already
  /// running, then it is stopped and {@code true} is returned; else {@code false} is returned.
  ///@throws SecurityException If the caller does not have permission to access the service
  /// or the service can not be found.
  ///@throws IllegalStateException If the application is in a state where the service
  /// can not be started (such as not in the foreground in a state when services are allowed).
  ///@see \#startService
  bool stopService(intent_.Intent service) => jniAccessors.callMethodWithArgs(
      reference,
      _id_stopService,
      jni.JniType.booleanType,
      [service.reference]).boolean;

  static final _id_bindService = jniAccessors.getMethodIDOf(
      _classRef,
      "bindService",
      "(Landroid/content/Intent;Landroid/content/ServiceConnection;I)Z");

  /// from: public abstract boolean bindService(android.content.Intent service, android.content.ServiceConnection conn, int flags)
  ///
  /// Connect to an application service, creating it if needed.  This defines
  /// a dependency between your application and the service.  The given
  /// <var>conn</var> will receive the service object when it is created and be
  /// told if it dies and restarts.  The service will be considered required
  /// by the system only for as long as the calling context exists.  For
  /// example, if this Context is an Activity that is stopped, the service will
  /// not be required to continue running until the Activity is resumed.
  ///
  /// If the service does not support binding, it may return {@code null} from
  /// its android.app.Service\#onBind(Intent) onBind() method.  If it does, then
  /// the ServiceConnection's
  /// ServiceConnection\#onNullBinding(ComponentName) onNullBinding() method
  /// will be invoked instead of
  /// ServiceConnection\#onServiceConnected(ComponentName, IBinder) onServiceConnected().
  ///
  /// This method will throw SecurityException if the calling app does not
  /// have permission to bind to the given service.
  ///
  /// <p class="note">Note: this method _cannot be called from a
  /// BroadcastReceiver component_.  A pattern you can use to
  /// communicate from a BroadcastReceiver to a Service is to call
  /// \#startService with the arguments containing the command to be
  /// sent, with the service calling its
  /// android.app.Service\#stopSelf(int) method when done executing
  /// that command.  See the API demo App/Service/Service Start Arguments
  /// Controller for an illustration of this.  It is okay, however, to use
  /// this method from a BroadcastReceiver that has been registered with
  /// \#registerReceiver, since the lifetime of this BroadcastReceiver
  /// is tied to another object (the one that registered it).
  ///
  ///@param service Identifies the service to connect to.  The Intent must
  ///      specify an explicit component name.
  ///@param conn Receives information as the service is started and stopped.
  ///      This must be a valid ServiceConnection object; it must not be null.
  /// This value must never be {@code null}.
  ///@param flags Operation options for the binding.  May be 0,
  ///          \#BIND_AUTO_CREATE, \#BIND_DEBUG_UNBIND,
  ///          \#BIND_NOT_FOREGROUND, \#BIND_ABOVE_CLIENT,
  ///          \#BIND_ALLOW_OOM_MANAGEMENT, or
  ///          \#BIND_WAIVE_PRIORITY.
  /// Value is either <code>0</code> or a combination of android.content.Context\#BIND_AUTO_CREATE, android.content.Context\#BIND_DEBUG_UNBIND, android.content.Context\#BIND_NOT_FOREGROUND, android.content.Context\#BIND_ABOVE_CLIENT, android.content.Context\#BIND_ALLOW_OOM_MANAGEMENT, android.content.Context\#BIND_WAIVE_PRIORITY, android.content.Context\#BIND_IMPORTANT, and android.content.Context\#BIND_ADJUST_WITH_ACTIVITY
  ///@return {@code true} if the system is in the process of bringing up a
  ///         service that your client has permission to bind to; {@code false}
  ///         if the system couldn't find the service or if your client doesn't
  ///         have permission to bind to it. If this value is {@code true}, you
  ///         should later call \#unbindService to release the
  ///         connection.
  ///@throws SecurityException If the caller does not have permission to access the service
  /// or the service can not be found.
  ///@see \#unbindService
  ///@see \#startService
  ///@see \#BIND_AUTO_CREATE
  ///@see \#BIND_DEBUG_UNBIND
  ///@see \#BIND_NOT_FOREGROUND
  bool bindService(intent_.Intent service,
          serviceconnection_.ServiceConnection conn, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_bindService,
          jni.JniType.booleanType,
          [service.reference, conn.reference, flags]).boolean;

  static final _id_unbindService = jniAccessors.getMethodIDOf(
      _classRef, "unbindService", "(Landroid/content/ServiceConnection;)V");

  /// from: public abstract void unbindService(android.content.ServiceConnection conn)
  ///
  /// Disconnect from an application service.  You will no longer receive
  /// calls as the service is restarted, and the service is now allowed to
  /// stop at any time.
  ///@param conn The connection interface previously supplied to
  ///             bindService().  This parameter must not be null.
  ///
  /// This value must never be {@code null}.
  ///@see \#bindService
  void unbindService(serviceconnection_.ServiceConnection conn) =>
      jniAccessors.callMethodWithArgs(reference, _id_unbindService,
          jni.JniType.voidType, [conn.reference]).check();

  static final _id_startInstrumentation = jniAccessors.getMethodIDOf(
      _classRef,
      "startInstrumentation",
      "(Landroid/content/ComponentName;Ljava/lang/String;Landroid/os/Bundle;)Z");

  /// from: public abstract boolean startInstrumentation(android.content.ComponentName className, java.lang.String profileFile, android.os.Bundle arguments)
  ///
  /// Start executing an android.app.Instrumentation class.  The given
  /// Instrumentation component will be run by killing its target application
  /// (if currently running), starting the target process, instantiating the
  /// instrumentation component, and then letting it drive the application.
  ///
  /// This function is not synchronous -- it returns as soon as the
  /// instrumentation has started and while it is running.
  ///
  /// Instrumentation is normally only allowed to run against a package
  /// that is either unsigned or signed with a signature that the
  /// the instrumentation package is also signed with (ensuring the target
  /// trusts the instrumentation).
  ///@param className Name of the Instrumentation component to be run.
  /// This value must never be {@code null}.
  ///@param profileFile Optional path to write profiling data as the
  /// instrumentation runs, or null for no profiling.
  /// This value may be {@code null}.
  ///@param arguments Additional optional arguments to pass to the
  /// instrumentation, or null.
  ///
  /// This value may be {@code null}.
  ///@return {@code true} if the instrumentation was successfully started,
  /// else {@code false} if it could not be found.
  bool startInstrumentation(componentname_.ComponentName className,
          jni.JniString profileFile, bundle_.Bundle arguments) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startInstrumentation, jni.JniType.booleanType, [
        className.reference,
        profileFile.reference,
        arguments.reference
      ]).boolean;

  static final _id_getSystemService = jniAccessors.getMethodIDOf(
      _classRef, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");

  /// from: public abstract java.lang.Object getSystemService(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the handle to a system-level service by name. The class of the
  /// returned object varies by the requested name. Currently available names
  /// are:
  ///
  /// <dl>
  ///  <dt> \#WINDOW_SERVICE ("window")
  ///  <dd> The top-level window manager in which you can place custom
  ///  windows.  The returned object is a android.view.WindowManager.
  ///  <dt> \#LAYOUT_INFLATER_SERVICE ("layout_inflater")
  ///  <dd> A android.view.LayoutInflater for inflating layout resources
  ///  in this context.
  ///  <dt> \#ACTIVITY_SERVICE ("activity")
  ///  <dd> A android.app.ActivityManager for interacting with the
  ///  global activity state of the system.
  ///  <dt> \#POWER_SERVICE ("power")
  ///  <dd> A android.os.PowerManager for controlling power
  ///  management.
  ///  <dt> \#ALARM_SERVICE ("alarm")
  ///  <dd> A android.app.AlarmManager for receiving intents at the
  ///  time of your choosing.
  ///  <dt> \#NOTIFICATION_SERVICE ("notification")
  ///  <dd> A android.app.NotificationManager for informing the user
  ///   of background events.
  ///  <dt> \#KEYGUARD_SERVICE ("keyguard")
  ///  <dd> A android.app.KeyguardManager for controlling keyguard.
  ///  <dt> \#LOCATION_SERVICE ("location")
  ///  <dd> A android.location.LocationManager for controlling location
  ///   (e.g., GPS) updates.
  ///  <dt> \#SEARCH_SERVICE ("search")
  ///  <dd> A android.app.SearchManager for handling search.
  ///  <dt> \#VIBRATOR_SERVICE ("vibrator")
  ///  <dd> A android.os.Vibrator for interacting with the vibrator
  ///  hardware.
  ///  <dt> \#CONNECTIVITY_SERVICE ("connection")
  ///  <dd> A android.net.ConnectivityManager ConnectivityManager for
  ///  handling management of network connections.
  ///  <dt> \#IPSEC_SERVICE ("ipsec")
  ///  <dd> A android.net.IpSecManager IpSecManager for managing IPSec on
  ///  sockets and networks.
  ///  <dt> \#WIFI_SERVICE ("wifi")
  ///  <dd> A android.net.wifi.WifiManager WifiManager for management of Wi-Fi
  ///  connectivity.  On releases before NYC, it should only be obtained from an application
  ///  context, and not from any other derived context to avoid memory leaks within the calling
  ///  process.
  ///  <dt> \#WIFI_AWARE_SERVICE ("wifiaware")
  ///  <dd> A android.net.wifi.aware.WifiAwareManager WifiAwareManager for management of
  /// Wi-Fi Aware discovery and connectivity.
  ///  <dt> \#WIFI_P2P_SERVICE ("wifip2p")
  ///  <dd> A android.net.wifi.p2p.WifiP2pManager WifiP2pManager for management of
  /// Wi-Fi Direct connectivity.
  /// <dt> \#INPUT_METHOD_SERVICE ("input_method")
  /// <dd> An android.view.inputmethod.InputMethodManager InputMethodManager
  /// for management of input methods.
  /// <dt> \#UI_MODE_SERVICE ("uimode")
  /// <dd> An android.app.UiModeManager for controlling UI modes.
  /// <dt> \#DOWNLOAD_SERVICE ("download")
  /// <dd> A android.app.DownloadManager for requesting HTTP downloads
  /// <dt> \#BATTERY_SERVICE ("batterymanager")
  /// <dd> A android.os.BatteryManager for managing battery state
  /// <dt> \#JOB_SCHEDULER_SERVICE ("taskmanager")
  /// <dd>  A android.app.job.JobScheduler for managing scheduled tasks
  /// <dt> \#NETWORK_STATS_SERVICE ("netstats")
  /// <dd> A android.app.usage.NetworkStatsManager NetworkStatsManager for querying network
  /// usage statistics.
  /// <dt> \#HARDWARE_PROPERTIES_SERVICE ("hardware_properties")
  /// <dd> A android.os.HardwarePropertiesManager for accessing hardware properties.
  /// </dl>
  ///
  /// Note:  System services obtained via this API may be closely associated with
  /// the Context in which they are obtained from.  In general, do not share the
  /// service objects between various different contexts (Activities, Applications,
  /// Services, Providers, etc.)
  ///
  /// Note: Instant apps, for which PackageManager\#isInstantApp() returns true,
  /// don't have access to the following system services: \#DEVICE_POLICY_SERVICE,
  /// \#FINGERPRINT_SERVICE, \#SHORTCUT_SERVICE, \#USB_SERVICE,
  /// \#WALLPAPER_SERVICE, \#WIFI_P2P_SERVICE, \#WIFI_SERVICE,
  /// \#WIFI_AWARE_SERVICE. For these services this method will return <code>null</code>.
  /// Generally, if you are running as an instant app you should always check whether the result
  /// of this method is null.
  ///@param name The name of the desired service.
  ///
  /// Value is android.content.Context\#POWER_SERVICE, android.content.Context\#WINDOW_SERVICE, android.content.Context\#LAYOUT_INFLATER_SERVICE, android.content.Context\#ACCOUNT_SERVICE, android.content.Context\#ACTIVITY_SERVICE, android.content.Context\#ALARM_SERVICE, android.content.Context\#NOTIFICATION_SERVICE, android.content.Context\#ACCESSIBILITY_SERVICE, android.content.Context\#CAPTIONING_SERVICE, android.content.Context\#KEYGUARD_SERVICE, android.content.Context\#LOCATION_SERVICE, android.content.Context\#SEARCH_SERVICE, android.content.Context\#SENSOR_SERVICE, android.content.Context\#STORAGE_SERVICE, android.content.Context\#STORAGE_STATS_SERVICE, android.content.Context\#WALLPAPER_SERVICE, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, android.content.Context\#VIBRATOR_SERVICE, android.content.Context\#CONNECTIVITY_SERVICE, android.content.Context\#IPSEC_SERVICE, android.content.Context\#NETWORK_STATS_SERVICE, android.content.Context\#WIFI_SERVICE, android.content.Context\#WIFI_AWARE_SERVICE, android.content.Context\#WIFI_P2P_SERVICE, android.content.Context.WIFI_SCANNING_SERVICE, android.content.Context\#WIFI_RTT_RANGING_SERVICE, android.content.Context\#NSD_SERVICE, android.content.Context\#AUDIO_SERVICE, android.content.Context\#FINGERPRINT_SERVICE, android.content.Context\#MEDIA_ROUTER_SERVICE, android.content.Context\#TELEPHONY_SERVICE, android.content.Context\#TELEPHONY_SUBSCRIPTION_SERVICE, android.content.Context\#CARRIER_CONFIG_SERVICE, android.content.Context\#TELECOM_SERVICE, android.content.Context\#CLIPBOARD_SERVICE, android.content.Context\#INPUT_METHOD_SERVICE, android.content.Context\#TEXT_SERVICES_MANAGER_SERVICE, android.content.Context\#TEXT_CLASSIFICATION_SERVICE, android.content.Context\#APPWIDGET_SERVICE, android.content.Context\#DROPBOX_SERVICE, android.content.Context\#DEVICE_POLICY_SERVICE, android.content.Context\#UI_MODE_SERVICE, android.content.Context\#DOWNLOAD_SERVICE, android.content.Context\#NFC_SERVICE, android.content.Context\#BLUETOOTH_SERVICE, android.content.Context\#USB_SERVICE, android.content.Context\#LAUNCHER_APPS_SERVICE, android.content.Context\#INPUT_SERVICE, android.content.Context\#DISPLAY_SERVICE, android.content.Context\#USER_SERVICE, android.content.Context\#RESTRICTIONS_SERVICE, android.content.Context\#APP_OPS_SERVICE, android.content.Context\#CAMERA_SERVICE, android.content.Context\#PRINT_SERVICE, android.content.Context\#CONSUMER_IR_SERVICE, android.content.Context\#TV_INPUT_SERVICE, android.content.Context\#USAGE_STATS_SERVICE, android.content.Context\#MEDIA_SESSION_SERVICE, android.content.Context\#BATTERY_SERVICE, android.content.Context\#JOB_SCHEDULER_SERVICE, android.content.Context\#MEDIA_PROJECTION_SERVICE, android.content.Context\#MIDI_SERVICE, android.content.Context.RADIO_SERVICE, android.content.Context\#HARDWARE_PROPERTIES_SERVICE, android.content.Context\#SHORTCUT_SERVICE, android.content.Context\#SYSTEM_HEALTH_SERVICE, android.content.Context\#COMPANION_DEVICE_SERVICE, or android.content.Context\#CROSS_PROFILE_APPS_SERVICE
  /// This value must never be {@code null}.
  ///@return The service or null if the name does not exist.
  ///@see \#WINDOW_SERVICE
  ///@see android.view.WindowManager
  ///@see \#LAYOUT_INFLATER_SERVICE
  ///@see android.view.LayoutInflater
  ///@see \#ACTIVITY_SERVICE
  ///@see android.app.ActivityManager
  ///@see \#POWER_SERVICE
  ///@see android.os.PowerManager
  ///@see \#ALARM_SERVICE
  ///@see android.app.AlarmManager
  ///@see \#NOTIFICATION_SERVICE
  ///@see android.app.NotificationManager
  ///@see \#KEYGUARD_SERVICE
  ///@see android.app.KeyguardManager
  ///@see \#LOCATION_SERVICE
  ///@see android.location.LocationManager
  ///@see \#SEARCH_SERVICE
  ///@see android.app.SearchManager
  ///@see \#SENSOR_SERVICE
  ///@see android.hardware.SensorManager
  ///@see \#STORAGE_SERVICE
  ///@see android.os.storage.StorageManager
  ///@see \#VIBRATOR_SERVICE
  ///@see android.os.Vibrator
  ///@see \#CONNECTIVITY_SERVICE
  ///@see android.net.ConnectivityManager
  ///@see \#WIFI_SERVICE
  ///@see android.net.wifi.WifiManager
  ///@see \#AUDIO_SERVICE
  ///@see android.media.AudioManager
  ///@see \#MEDIA_ROUTER_SERVICE
  ///@see android.media.MediaRouter
  ///@see \#TELEPHONY_SERVICE
  ///@see android.telephony.TelephonyManager
  ///@see \#TELEPHONY_SUBSCRIPTION_SERVICE
  ///@see android.telephony.SubscriptionManager
  ///@see \#CARRIER_CONFIG_SERVICE
  ///@see android.telephony.CarrierConfigManager
  ///@see \#INPUT_METHOD_SERVICE
  ///@see android.view.inputmethod.InputMethodManager
  ///@see \#UI_MODE_SERVICE
  ///@see android.app.UiModeManager
  ///@see \#DOWNLOAD_SERVICE
  ///@see android.app.DownloadManager
  ///@see \#BATTERY_SERVICE
  ///@see android.os.BatteryManager
  ///@see \#JOB_SCHEDULER_SERVICE
  ///@see android.app.job.JobScheduler
  ///@see \#NETWORK_STATS_SERVICE
  ///@see android.app.usage.NetworkStatsManager
  ///@see android.os.HardwarePropertiesManager
  ///@see \#HARDWARE_PROPERTIES_SERVICE
  jni.JniObject getSystemService(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSystemService,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getSystemServiceName = jniAccessors.getMethodIDOf(_classRef,
      "getSystemServiceName", "(Ljava/lang/Class;)Ljava/lang/String;");

  /// from: public abstract java.lang.String getSystemServiceName(java.lang.Class<?> serviceClass)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the name of the system-level service that is represented by the specified class.
  ///@param serviceClass The class of the desired service.
  /// This value must never be {@code null}.
  ///@return The service name or null if the class is not a supported system service.
  jni.JniString getSystemServiceName(jni.JniObject serviceClass) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSystemServiceName,
          jni.JniType.objectType,
          [serviceClass.reference]).object);

  static final _id_checkPermission = jniAccessors.getMethodIDOf(
      _classRef, "checkPermission", "(Ljava/lang/String;II)I");

  /// from: public abstract int checkPermission(java.lang.String permission, int pid, int uid)
  ///
  /// Determine whether the given permission is allowed for a particular
  /// process and user ID running in the system.
  ///@param permission The name of the permission being checked.
  /// This value must never be {@code null}.
  ///@param pid The process ID being checked against.  Must be > 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@return PackageManager\#PERMISSION_GRANTED if the given
  /// pid/uid is allowed that permission, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#checkCallingPermission
  int checkPermission(jni.JniString permission, int pid, int uid) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkPermission,
          jni.JniType.intType, [permission.reference, pid, uid]).integer;

  static final _id_checkCallingPermission = jniAccessors.getMethodIDOf(
      _classRef, "checkCallingPermission", "(Ljava/lang/String;)I");

  /// from: public abstract int checkCallingPermission(java.lang.String permission)
  ///
  /// Determine whether the calling process of an IPC you are handling has been
  /// granted a particular permission.  This is basically the same as calling
  /// \#checkPermission(String, int, int) with the pid and uid returned
  /// by android.os.Binder\#getCallingPid and
  /// android.os.Binder\#getCallingUid.  One important difference
  /// is that if you are not currently processing an IPC, this function
  /// will always fail.  This is done to protect against accidentally
  /// leaking permissions; you can use \#checkCallingOrSelfPermission
  /// to avoid this protection.
  ///@param permission The name of the permission being checked.
  ///
  /// This value must never be {@code null}.
  ///@return PackageManager\#PERMISSION_GRANTED if the calling
  /// pid/uid is allowed that permission, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#checkPermission
  ///@see \#checkCallingOrSelfPermission
  int checkCallingPermission(jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkCallingPermission,
          jni.JniType.intType, [permission.reference]).integer;

  static final _id_checkCallingOrSelfPermission = jniAccessors.getMethodIDOf(
      _classRef, "checkCallingOrSelfPermission", "(Ljava/lang/String;)I");

  /// from: public abstract int checkCallingOrSelfPermission(java.lang.String permission)
  ///
  /// Determine whether the calling process of an IPC _or you_ have been
  /// granted a particular permission.  This is the same as
  /// \#checkCallingPermission, except it grants your own permissions
  /// if you are not currently processing an IPC.  Use with care!
  ///@param permission The name of the permission being checked.
  ///
  /// This value must never be {@code null}.
  ///@return PackageManager\#PERMISSION_GRANTED if the calling
  /// pid/uid is allowed that permission, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#checkPermission
  ///@see \#checkCallingPermission
  int checkCallingOrSelfPermission(jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_checkCallingOrSelfPermission,
          jni.JniType.intType,
          [permission.reference]).integer;

  static final _id_checkSelfPermission = jniAccessors.getMethodIDOf(
      _classRef, "checkSelfPermission", "(Ljava/lang/String;)I");

  /// from: public abstract int checkSelfPermission(java.lang.String permission)
  ///
  /// Determine whether _you_ have been granted a particular permission.
  ///@param permission The name of the permission being checked.
  ///
  /// This value must never be {@code null}.
  ///@return PackageManager\#PERMISSION_GRANTED if you have the
  /// permission, or PackageManager\#PERMISSION_DENIED if not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#checkCallingPermission(String)
  int checkSelfPermission(jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkSelfPermission,
          jni.JniType.intType, [permission.reference]).integer;

  static final _id_enforcePermission = jniAccessors.getMethodIDOf(_classRef,
      "enforcePermission", "(Ljava/lang/String;IILjava/lang/String;)V");

  /// from: public abstract void enforcePermission(java.lang.String permission, int pid, int uid, java.lang.String message)
  ///
  /// If the given permission is not allowed for a particular process
  /// and user ID running in the system, throw a SecurityException.
  ///@param permission The name of the permission being checked.
  /// This value must never be {@code null}.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param message A message to include in the exception if it is thrown.
  ///
  /// This value may be {@code null}.
  ///@see \#checkPermission(String, int, int)
  void enforcePermission(
          jni.JniString permission, int pid, int uid, jni.JniString message) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enforcePermission,
          jni.JniType.voidType,
          [permission.reference, pid, uid, message.reference]).check();

  static final _id_enforceCallingPermission = jniAccessors.getMethodIDOf(
      _classRef,
      "enforceCallingPermission",
      "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public abstract void enforceCallingPermission(java.lang.String permission, java.lang.String message)
  ///
  /// If the calling process of an IPC you are handling has not been
  /// granted a particular permission, throw a SecurityException.  This is basically the same as calling
  /// \#enforcePermission(String, int, int, String) with the
  /// pid and uid returned by android.os.Binder\#getCallingPid
  /// and android.os.Binder\#getCallingUid.  One important
  /// difference is that if you are not currently processing an IPC,
  /// this function will always throw the SecurityException.  This is
  /// done to protect against accidentally leaking permissions; you
  /// can use \#enforceCallingOrSelfPermission to avoid this
  /// protection.
  ///@param permission The name of the permission being checked.
  /// This value must never be {@code null}.
  ///@param message A message to include in the exception if it is thrown.
  ///
  /// This value may be {@code null}.
  ///@see \#checkCallingPermission(String)
  void enforceCallingPermission(
          jni.JniString permission, jni.JniString message) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enforceCallingPermission,
          jni.JniType.voidType,
          [permission.reference, message.reference]).check();

  static final _id_enforceCallingOrSelfPermission = jniAccessors.getMethodIDOf(
      _classRef,
      "enforceCallingOrSelfPermission",
      "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public abstract void enforceCallingOrSelfPermission(java.lang.String permission, java.lang.String message)
  ///
  /// If neither you nor the calling process of an IPC you are
  /// handling has been granted a particular permission, throw a
  /// SecurityException.  This is the same as \#enforceCallingPermission, except it grants your own
  /// permissions if you are not currently processing an IPC.  Use
  /// with care!
  ///@param permission The name of the permission being checked.
  /// This value must never be {@code null}.
  ///@param message A message to include in the exception if it is thrown.
  ///
  /// This value may be {@code null}.
  ///@see \#checkCallingOrSelfPermission(String)
  void enforceCallingOrSelfPermission(
          jni.JniString permission, jni.JniString message) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enforceCallingOrSelfPermission,
          jni.JniType.voidType,
          [permission.reference, message.reference]).check();

  static final _id_grantUriPermission = jniAccessors.getMethodIDOf(_classRef,
      "grantUriPermission", "(Ljava/lang/String;Landroid/net/Uri;I)V");

  /// from: public abstract void grantUriPermission(java.lang.String toPackage, android.net.Uri uri, int modeFlags)
  ///
  /// Grant permission to access a specific Uri to another package, regardless
  /// of whether that package has general permission to access the Uri's
  /// content provider.  This can be used to grant specific, temporary
  /// permissions, typically in response to user interaction (such as the
  /// user opening an attachment that you would like someone else to
  /// display).
  ///
  /// Normally you should use Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION or
  /// Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION with the Intent being used to
  /// start an activity instead of this function directly.  If you use this
  /// function directly, you should be sure to call
  /// \#revokeUriPermission when the target should no longer be allowed
  /// to access it.
  ///
  /// To succeed, the content provider owning the Uri must have set the
  /// android.R.styleable\#AndroidManifestProvider_grantUriPermissions grantUriPermissions attribute in its manifest or included the
  /// android.R.styleable\#AndroidManifestGrantUriPermission &lt;grant-uri-permissions&gt; tag.
  ///@param toPackage The package you would like to allow to access the Uri.
  ///@param uri The Uri you would like to grant access to.
  ///@param modeFlags The desired access modes.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION
  ///@see \#revokeUriPermission
  void grantUriPermission(
          jni.JniString toPackage, uri_.Uri uri, int modeFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_grantUriPermission,
          jni.JniType.voidType,
          [toPackage.reference, uri.reference, modeFlags]).check();

  static final _id_revokeUriPermission = jniAccessors.getMethodIDOf(
      _classRef, "revokeUriPermission", "(Landroid/net/Uri;I)V");

  /// from: public abstract void revokeUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Remove all permissions to access a particular content provider Uri
  /// that were previously added with \#grantUriPermission or _any other_ mechanism.
  /// The given Uri will match all previously granted Uris that are the same or a
  /// sub-path of the given Uri.  That is, revoking "content://foo/target" will
  /// revoke both "content://foo/target" and "content://foo/target/sub", but not
  /// "content://foo".  It will not remove any prefix grants that exist at a
  /// higher level.
  ///
  /// Prior to android.os.Build.VERSION_CODES\#LOLLIPOP, if you did not have
  /// regular permission access to a Uri, but had received access to it through
  /// a specific Uri permission grant, you could not revoke that grant with this
  /// function and a SecurityException would be thrown.  As of
  /// android.os.Build.VERSION_CODES\#LOLLIPOP, this function will not throw a security
  /// exception, but will remove whatever permission grants to the Uri had been given to the app
  /// (or none).
  ///
  ///
  /// Unlike \#revokeUriPermission(String, Uri, int), this method impacts all permission
  /// grants matching the given Uri, for any package they had been granted to, through any
  /// mechanism this had happened (such as indirectly through the clipboard, activity launch,
  /// service start, etc).  That means this can be potentially dangerous to use, as it can
  /// revoke grants that another app could be strongly expecting to stick around.
  ///
  ///@param uri The Uri you would like to revoke access to.
  ///@param modeFlags The access modes to revoke.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@see \#grantUriPermission
  void revokeUriPermission(uri_.Uri uri, int modeFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_revokeUriPermission,
          jni.JniType.voidType, [uri.reference, modeFlags]).check();

  static final _id_revokeUriPermission1 = jniAccessors.getMethodIDOf(_classRef,
      "revokeUriPermission", "(Ljava/lang/String;Landroid/net/Uri;I)V");

  /// from: public abstract void revokeUriPermission(java.lang.String toPackage, android.net.Uri uri, int modeFlags)
  ///
  /// Remove permissions to access a particular content provider Uri
  /// that were previously added with \#grantUriPermission for a specific target
  /// package.  The given Uri will match all previously granted Uris that are the same or a
  /// sub-path of the given Uri.  That is, revoking "content://foo/target" will
  /// revoke both "content://foo/target" and "content://foo/target/sub", but not
  /// "content://foo".  It will not remove any prefix grants that exist at a
  /// higher level.
  ///
  /// Unlike \#revokeUriPermission(Uri, int), this method will _only_
  /// revoke permissions that had been explicitly granted through \#grantUriPermission
  /// and only for the package specified.  Any matching grants that have happened through
  /// other mechanisms (clipboard, activity launching, service starting, etc) will not be
  /// removed.
  ///
  ///@param toPackage The package you had previously granted access to.
  ///@param uri The Uri you would like to revoke access to.
  ///@param modeFlags The access modes to revoke.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@see \#grantUriPermission
  void revokeUriPermission1(
          jni.JniString toPackage, uri_.Uri uri, int modeFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_revokeUriPermission1,
          jni.JniType.voidType,
          [toPackage.reference, uri.reference, modeFlags]).check();

  static final _id_checkUriPermission = jniAccessors.getMethodIDOf(
      _classRef, "checkUriPermission", "(Landroid/net/Uri;III)I");

  /// from: public abstract int checkUriPermission(android.net.Uri uri, int pid, int uid, int modeFlags)
  ///
  /// Determine whether a particular process and user ID has been granted
  /// permission to access a specific URI.  This only checks for permissions
  /// that have been explicitly granted -- if the given process/uid has
  /// more general access to the URI's content provider then this check will
  /// always fail.
  ///@param uri The uri that is being checked.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param modeFlags The access modes to check.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@return PackageManager\#PERMISSION_GRANTED if the given
  /// pid/uid is allowed to access that uri, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see \#checkCallingUriPermission
  int checkUriPermission(uri_.Uri uri, int pid, int uid, int modeFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkUriPermission,
          jni.JniType.intType, [uri.reference, pid, uid, modeFlags]).integer;

  static final _id_checkCallingUriPermission = jniAccessors.getMethodIDOf(
      _classRef, "checkCallingUriPermission", "(Landroid/net/Uri;I)I");

  /// from: public abstract int checkCallingUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Determine whether the calling process and user ID has been
  /// granted permission to access a specific URI.  This is basically
  /// the same as calling \#checkUriPermission(Uri, int, int,
  /// int) with the pid and uid returned by android.os.Binder\#getCallingPid and android.os.Binder\#getCallingUid.  One important difference is
  /// that if you are not currently processing an IPC, this function
  /// will always fail.
  ///@param uri The uri that is being checked.
  ///@param modeFlags The access modes to check.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@return PackageManager\#PERMISSION_GRANTED if the caller
  /// is allowed to access that uri, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see \#checkUriPermission(Uri, int, int, int)
  int checkCallingUriPermission(uri_.Uri uri, int modeFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkCallingUriPermission,
          jni.JniType.intType, [uri.reference, modeFlags]).integer;

  static final _id_checkCallingOrSelfUriPermission = jniAccessors.getMethodIDOf(
      _classRef, "checkCallingOrSelfUriPermission", "(Landroid/net/Uri;I)I");

  /// from: public abstract int checkCallingOrSelfUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Determine whether the calling process of an IPC _or you_ has been granted
  /// permission to access a specific URI.  This is the same as
  /// \#checkCallingUriPermission, except it grants your own permissions
  /// if you are not currently processing an IPC.  Use with care!
  ///@param uri The uri that is being checked.
  ///@param modeFlags The access modes to check.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@return PackageManager\#PERMISSION_GRANTED if the caller
  /// is allowed to access that uri, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see \#checkCallingUriPermission
  int checkCallingOrSelfUriPermission(uri_.Uri uri, int modeFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_checkCallingOrSelfUriPermission,
          jni.JniType.intType,
          [uri.reference, modeFlags]).integer;

  static final _id_checkUriPermission1 = jniAccessors.getMethodIDOf(
      _classRef,
      "checkUriPermission",
      "(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;III)I");

  /// from: public abstract int checkUriPermission(android.net.Uri uri, java.lang.String readPermission, java.lang.String writePermission, int pid, int uid, int modeFlags)
  ///
  /// Check both a Uri and normal permission.  This allows you to perform
  /// both \#checkPermission and \#checkUriPermission in one
  /// call.
  ///@param uri The Uri whose permission is to be checked, or null to not
  /// do this check.
  /// This value may be {@code null}.
  ///@param readPermission The permission that provides overall read access,
  /// or null to not do this check.
  /// This value may be {@code null}.
  ///@param writePermission The permission that provides overall write
  /// access, or null to not do this check.
  /// This value may be {@code null}.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param modeFlags The access modes to check.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@return PackageManager\#PERMISSION_GRANTED if the caller
  /// is allowed to access that uri or holds one of the given permissions, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  int checkUriPermission1(uri_.Uri uri, jni.JniString readPermission,
          jni.JniString writePermission, int pid, int uid, int modeFlags) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_checkUriPermission1, jni.JniType.intType, [
        uri.reference,
        readPermission.reference,
        writePermission.reference,
        pid,
        uid,
        modeFlags
      ]).integer;

  static final _id_enforceUriPermission = jniAccessors.getMethodIDOf(_classRef,
      "enforceUriPermission", "(Landroid/net/Uri;IIILjava/lang/String;)V");

  /// from: public abstract void enforceUriPermission(android.net.Uri uri, int pid, int uid, int modeFlags, java.lang.String message)
  ///
  /// If a particular process and user ID has not been granted
  /// permission to access a specific URI, throw SecurityException.  This only checks for permissions that have
  /// been explicitly granted -- if the given process/uid has more
  /// general access to the URI's content provider then this check
  /// will always fail.
  ///@param uri The uri that is being checked.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param modeFlags The access modes to enforce.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@param message A message to include in the exception if it is thrown.
  ///@see \#checkUriPermission(Uri, int, int, int)
  void enforceUriPermission(uri_.Uri uri, int pid, int uid, int modeFlags,
          jni.JniString message) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enforceUriPermission,
          jni.JniType.voidType,
          [uri.reference, pid, uid, modeFlags, message.reference]).check();

  static final _id_enforceCallingUriPermission = jniAccessors.getMethodIDOf(
      _classRef,
      "enforceCallingUriPermission",
      "(Landroid/net/Uri;ILjava/lang/String;)V");

  /// from: public abstract void enforceCallingUriPermission(android.net.Uri uri, int modeFlags, java.lang.String message)
  ///
  /// If the calling process and user ID has not been granted
  /// permission to access a specific URI, throw SecurityException.  This is basically the same as calling
  /// \#enforceUriPermission(Uri, int, int, int, String) with
  /// the pid and uid returned by android.os.Binder\#getCallingPid and android.os.Binder\#getCallingUid.  One important difference is
  /// that if you are not currently processing an IPC, this function
  /// will always throw a SecurityException.
  ///@param uri The uri that is being checked.
  ///@param modeFlags The access modes to enforce.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@param message A message to include in the exception if it is thrown.
  ///@see \#checkCallingUriPermission(Uri, int)
  void enforceCallingUriPermission(
          uri_.Uri uri, int modeFlags, jni.JniString message) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enforceCallingUriPermission,
          jni.JniType.voidType,
          [uri.reference, modeFlags, message.reference]).check();

  static final _id_enforceCallingOrSelfUriPermission =
      jniAccessors.getMethodIDOf(_classRef, "enforceCallingOrSelfUriPermission",
          "(Landroid/net/Uri;ILjava/lang/String;)V");

  /// from: public abstract void enforceCallingOrSelfUriPermission(android.net.Uri uri, int modeFlags, java.lang.String message)
  ///
  /// If the calling process of an IPC _or you_ has not been
  /// granted permission to access a specific URI, throw SecurityException.  This is the same as \#enforceCallingUriPermission, except it grants your own
  /// permissions if you are not currently processing an IPC.  Use
  /// with care!
  ///@param uri The uri that is being checked.
  ///@param modeFlags The access modes to enforce.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@param message A message to include in the exception if it is thrown.
  ///@see \#checkCallingOrSelfUriPermission(Uri, int)
  void enforceCallingOrSelfUriPermission(
          uri_.Uri uri, int modeFlags, jni.JniString message) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enforceCallingOrSelfUriPermission,
          jni.JniType.voidType,
          [uri.reference, modeFlags, message.reference]).check();

  static final _id_enforceUriPermission1 = jniAccessors.getMethodIDOf(
      _classRef,
      "enforceUriPermission",
      "(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;IIILjava/lang/String;)V");

  /// from: public abstract void enforceUriPermission(android.net.Uri uri, java.lang.String readPermission, java.lang.String writePermission, int pid, int uid, int modeFlags, java.lang.String message)
  ///
  /// Enforce both a Uri and normal permission.  This allows you to perform
  /// both \#enforcePermission and \#enforceUriPermission in one
  /// call.
  ///@param uri The Uri whose permission is to be checked, or null to not
  /// do this check.
  /// This value may be {@code null}.
  ///@param readPermission The permission that provides overall read access,
  /// or null to not do this check.
  /// This value may be {@code null}.
  ///@param writePermission The permission that provides overall write
  /// access, or null to not do this check.
  /// This value may be {@code null}.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param modeFlags The access modes to enforce.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@param message A message to include in the exception if it is thrown.
  ///
  /// This value may be {@code null}.
  ///@see \#checkUriPermission(Uri, String, String, int, int, int)
  void enforceUriPermission1(
          uri_.Uri uri,
          jni.JniString readPermission,
          jni.JniString writePermission,
          int pid,
          int uid,
          int modeFlags,
          jni.JniString message) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_enforceUriPermission1, jni.JniType.voidType, [
        uri.reference,
        readPermission.reference,
        writePermission.reference,
        pid,
        uid,
        modeFlags,
        message.reference
      ]).check();

  static final _id_createPackageContext = jniAccessors.getMethodIDOf(_classRef,
      "createPackageContext", "(Ljava/lang/String;I)Landroid/content/Context;");

  /// from: public abstract android.content.Context createPackageContext(java.lang.String packageName, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the given application name.  This
  /// Context is the same as what the named application gets when it is
  /// launched, containing the same resources and class loader.  Each call to
  /// this method returns a new instance of a Context object; Context objects
  /// are not shared, however they share common state (Resources, ClassLoader,
  /// etc) so the Context instance itself is fairly lightweight.
  ///
  /// Throws android.content.pm.PackageManager.NameNotFoundException if there is no
  /// application with the given package name.
  ///
  /// Throws java.lang.SecurityException if the Context requested
  /// can not be loaded into the caller's process for security reasons (see
  /// \#CONTEXT_INCLUDE_CODE for more information}.
  ///@param packageName Name of the application's package.
  ///@param flags Option flags.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#CONTEXT_INCLUDE_CODE, android.content.Context\#CONTEXT_IGNORE_SECURITY, android.content.Context\#CONTEXT_RESTRICTED, android.content.Context.CONTEXT_DEVICE_PROTECTED_STORAGE, android.content.Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE, and android.content.Context.CONTEXT_REGISTER_PACKAGE
  ///@return A Context for the application.
  ///@throws SecurityException &nbsp;
  ///@throws PackageManager.NameNotFoundException if there is no application with
  /// the given package name.
  Context createPackageContext(jni.JniString packageName, int flags) =>
      Context.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createPackageContext,
          jni.JniType.objectType,
          [packageName.reference, flags]).object);

  static final _id_createContextForSplit = jniAccessors.getMethodIDOf(_classRef,
      "createContextForSplit", "(Ljava/lang/String;)Landroid/content/Context;");

  /// from: public abstract android.content.Context createContextForSplit(java.lang.String splitName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the given split name. The new Context has a ClassLoader and
  /// Resources object that can access the split's and all of its dependencies' code/resources.
  /// Each call to this method returns a new instance of a Context object;
  /// Context objects are not shared, however common state (ClassLoader, other Resources for
  /// the same split) may be so the Context itself can be fairly lightweight.
  ///@param splitName The name of the split to include, as declared in the split's
  ///                  <code>AndroidManifest.xml</code>.
  ///@return A Context with the given split's code and/or resources loaded.
  Context createContextForSplit(jni.JniString splitName) =>
      Context.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createContextForSplit,
          jni.JniType.objectType,
          [splitName.reference]).object);

  static final _id_createConfigurationContext = jniAccessors.getMethodIDOf(
      _classRef,
      "createConfigurationContext",
      "(Landroid/content/res/Configuration;)Landroid/content/Context;");

  /// from: public abstract android.content.Context createConfigurationContext(android.content.res.Configuration overrideConfiguration)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the current Context but whose resources
  /// are adjusted to match the given Configuration.  Each call to this method
  /// returns a new instance of a Context object; Context objects are not
  /// shared, however common state (ClassLoader, other Resources for the
  /// same configuration) may be so the Context itself can be fairly lightweight.
  ///@param overrideConfiguration A Configuration specifying what
  /// values to modify in the base Configuration of the original Context's
  /// resources.  If the base configuration changes (such as due to an
  /// orientation change), the resources of this context will also change except
  /// for those that have been explicitly overridden with a value here.
  ///
  /// This value must never be {@code null}.
  ///@return A Context with the given configuration override.
  Context createConfigurationContext(
          configuration_.Configuration overrideConfiguration) =>
      Context.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createConfigurationContext,
          jni.JniType.objectType,
          [overrideConfiguration.reference]).object);

  static final _id_createDisplayContext = jniAccessors.getMethodIDOf(
      _classRef,
      "createDisplayContext",
      "(Landroid/view/Display;)Landroid/content/Context;");

  /// from: public abstract android.content.Context createDisplayContext(android.view.Display display)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the current Context but whose resources
  /// are adjusted to match the metrics of the given Display.  Each call to this method
  /// returns a new instance of a Context object; Context objects are not
  /// shared, however common state (ClassLoader, other Resources for the
  /// same configuration) may be so the Context itself can be fairly lightweight.
  ///
  /// The returned display Context provides a WindowManager
  /// (see \#getSystemService(String)) that is configured to show windows
  /// on the given display.  The WindowManager's WindowManager\#getDefaultDisplay
  /// method can be used to retrieve the Display from the returned Context.
  ///@param display A Display object specifying the display
  /// for whose metrics the Context's resources should be tailored and upon which
  /// new windows should be shown.
  ///
  /// This value must never be {@code null}.
  ///@return A Context for the display.
  Context createDisplayContext(display_.Display display) =>
      Context.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createDisplayContext,
          jni.JniType.objectType,
          [display.reference]).object);

  static final _id_createDeviceProtectedStorageContext =
      jniAccessors.getMethodIDOf(_classRef,
          "createDeviceProtectedStorageContext", "()Landroid/content/Context;");

  /// from: public abstract android.content.Context createDeviceProtectedStorageContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the current Context but whose storage
  /// APIs are backed by device-protected storage.
  ///
  /// On devices with direct boot, data stored in this location is encrypted
  /// with a key tied to the physical device, and it can be accessed
  /// immediately after the device has booted successfully, both
  /// _before and after_ the user has authenticated with their
  /// credentials (such as a lock pattern or PIN).
  ///
  /// Because device-protected data is available without user authentication,
  /// you should carefully limit the data you store using this Context. For
  /// example, storing sensitive authentication tokens or passwords in the
  /// device-protected area is strongly discouraged.
  ///
  /// If the underlying device does not have the ability to store
  /// device-protected and credential-protected data using different keys, then
  /// both storage areas will become available at the same time. They remain as
  /// two distinct storage locations on disk, and only the window of
  /// availability changes.
  ///
  /// Each call to this method returns a new instance of a Context object;
  /// Context objects are not shared, however common state (ClassLoader, other
  /// Resources for the same configuration) may be so the Context itself can be
  /// fairly lightweight.
  ///@see \#isDeviceProtectedStorage()
  Context createDeviceProtectedStorageContext() =>
      Context.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createDeviceProtectedStorageContext,
          jni.JniType.objectType, []).object);

  static final _id_isRestricted =
      jniAccessors.getMethodIDOf(_classRef, "isRestricted", "()Z");

  /// from: public boolean isRestricted()
  ///
  /// Indicates whether this Context is restricted.
  ///@return {@code true} if this Context is restricted, {@code false} otherwise.
  ///@see \#CONTEXT_RESTRICTED
  bool isRestricted() => jniAccessors.callMethodWithArgs(
      reference, _id_isRestricted, jni.JniType.booleanType, []).boolean;

  static final _id_isDeviceProtectedStorage =
      jniAccessors.getMethodIDOf(_classRef, "isDeviceProtectedStorage", "()Z");

  /// from: public abstract boolean isDeviceProtectedStorage()
  ///
  /// Indicates if the storage APIs of this Context are backed by
  /// device-protected storage.
  ///@see \#createDeviceProtectedStorageContext()
  bool isDeviceProtectedStorage() => jniAccessors.callMethodWithArgs(reference,
      _id_isDeviceProtectedStorage, jni.JniType.booleanType, []).boolean;
}
