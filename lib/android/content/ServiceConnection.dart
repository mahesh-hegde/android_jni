// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ComponentName.dart" as componentname_;

import "../os/IBinder.dart" as ibinder_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.ServiceConnection
///
/// Interface for monitoring the state of an application service.  See
/// android.app.Service and
/// Context\#bindService Context.bindService() for more information.
/// Like many callbacks from the system, the methods on this class are called
/// from the main thread of your process.
class ServiceConnection extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/ServiceConnection");
  ServiceConnection.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onServiceConnected = jniAccessors.getMethodIDOf(
      _classRef,
      "onServiceConnected",
      "(Landroid/content/ComponentName;Landroid/os/IBinder;)V");

  /// from: public abstract void onServiceConnected(android.content.ComponentName name, android.os.IBinder service)
  ///
  /// Called when a connection to the Service has been established, with
  /// the android.os.IBinder of the communication channel to the
  /// Service.
  ///
  /// <p class="note">__Note:__ If the system has started to bind your
  /// client app to a service, it's possible that your app will never receive
  /// this callback. Your app won't receive a callback if there's an issue with
  /// the service, such as the service crashing while being created.
  ///@param name The concrete component name of the service that has
  /// been connected.
  ///@param service The IBinder of the Service's communication channel,
  /// which you can now make calls on.
  void onServiceConnected(
          componentname_.ComponentName name, ibinder_.IBinder service) =>
      jniAccessors.callMethodWithArgs(reference, _id_onServiceConnected,
          jni.JniType.voidType, [name.reference, service.reference]).check();

  static final _id_onServiceDisconnected = jniAccessors.getMethodIDOf(
      _classRef, "onServiceDisconnected", "(Landroid/content/ComponentName;)V");

  /// from: public abstract void onServiceDisconnected(android.content.ComponentName name)
  ///
  /// Called when a connection to the Service has been lost.  This typically
  /// happens when the process hosting the service has crashed or been killed.
  /// This does _not_ remove the ServiceConnection itself -- this
  /// binding to the service will remain active, and you will receive a call
  /// to \#onServiceConnected when the Service is next running.
  ///@param name The concrete component name of the service whose
  /// connection has been lost.
  void onServiceDisconnected(componentname_.ComponentName name) =>
      jniAccessors.callMethodWithArgs(reference, _id_onServiceDisconnected,
          jni.JniType.voidType, [name.reference]).check();

  static final _id_onBindingDied = jniAccessors.getMethodIDOf(
      _classRef, "onBindingDied", "(Landroid/content/ComponentName;)V");

  /// from: default public void onBindingDied(android.content.ComponentName name)
  ///
  /// Called when the binding to this connection is dead.  This means the
  /// interface will never receive another connection.  The application will
  /// need to unbind and rebind the connection to activate it again.  This may
  /// happen, for example, if the application hosting the service it is bound to
  /// has been updated.
  ///@param name The concrete component name of the service whose
  /// connection is dead.
  void onBindingDied(componentname_.ComponentName name) =>
      jniAccessors.callMethodWithArgs(reference, _id_onBindingDied,
          jni.JniType.voidType, [name.reference]).check();

  static final _id_onNullBinding = jniAccessors.getMethodIDOf(
      _classRef, "onNullBinding", "(Landroid/content/ComponentName;)V");

  /// from: default public void onNullBinding(android.content.ComponentName name)
  ///
  /// Called when the service being bound has returned {@code null} from its
  /// android.app.Service\#onBind(Intent) onBind() method.  This indicates
  /// that the attempting service binding represented by this ServiceConnection
  /// will never become usable.
  ///
  /// <p class="note">The app which requested the binding must still call
  /// Context\#unbindService(ServiceConnection) to release the tracking
  /// resources associated with this ServiceConnection even if this callback was
  /// invoked following Context\#bindService Context.bindService() bindService().
  ///@param name The concrete component name of the service whose binding
  ///     has been rejected by the Service implementation.
  void onNullBinding(componentname_.ComponentName name) =>
      jniAccessors.callMethodWithArgs(reference, _id_onNullBinding,
          jni.JniType.voidType, [name.reference]).check();
}
