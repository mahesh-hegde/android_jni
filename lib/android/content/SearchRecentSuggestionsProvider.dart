// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ContentProvider.dart" as contentprovider_;

import "../net/Uri.dart" as uri_;

import "ContentValues.dart" as contentvalues_;

import "../database/Cursor.dart" as cursor_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.SearchRecentSuggestionsProvider
///
/// This superclass can be used to create a simple search suggestions provider for your application.
/// It creates suggestions (as the user types) based on recent queries and/or recent views.
///
/// In order to use this class, you must do the following.
///
/// <ul>
/// <li>Implement and test query search, as described in android.app.SearchManager.  (This
/// provider will send any suggested queries via the standard
/// android.content.Intent\#ACTION_SEARCH ACTION_SEARCH Intent, which you'll already
/// support once you have implemented and tested basic searchability.)</li>
/// <li>Create a Content Provider within your application by extending
/// android.content.SearchRecentSuggestionsProvider.  The class you create will be
/// very simple - typically, it will have only a constructor.  But the constructor has a very
/// important responsibility:  When it calls \#setupSuggestions(String, int), it
/// <i>configures</i> the provider to match the requirements of your searchable activity.</li>
/// <li>Create a manifest entry describing your provider.  Typically this would be as simple
/// as adding the following lines:
/// <pre class="prettyprint">
///     &lt;!-- Content provider for search suggestions --&gt;
///     &lt;provider android:name="YourSuggestionProviderClass"
///               android:authorities="your.suggestion.authority" /&gt;</pre>
/// </li>
/// <li>Please note that you <i>do not</i> instantiate this content provider directly from within
/// your code.  This is done automatically by the system Content Resolver, when the search dialog
/// looks for suggestions.</li>
/// <li>In order for the Content Resolver to do this, you must update your searchable activity's
/// XML configuration file with information about your content provider.  The following additions
/// are usually sufficient:
/// <pre class="prettyprint">
///     android:searchSuggestAuthority="your.suggestion.authority"
///     android:searchSuggestSelection=" ? "</pre>
/// </li>
/// <li>In your searchable activities, capture any user-generated queries and record them
/// for future searches by calling android.provider.SearchRecentSuggestions\#saveRecentQuery SearchRecentSuggestions.saveRecentQuery().</li>
/// </ul>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about using search suggestions in your application, read the
/// <a href="{@docRoot}guide/topics/search/index.html">Search</a> developer guide.
///
/// </div>
///@see android.provider.SearchRecentSuggestions
class SearchRecentSuggestionsProvider extends contentprovider_.ContentProvider {
  static final _classRef = jniAccessors
      .getClassOf("android/content/SearchRecentSuggestionsProvider");
  SearchRecentSuggestionsProvider.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DATABASE_MODE_2LINES
  ///
  /// This mode bit configures the database to include a 2nd annotation line with each entry.
  /// <i>optional</i>
  ///@see \#setupSuggestions(String, int)
  static const DATABASE_MODE_2LINES = 2;

  /// from: static public final int DATABASE_MODE_QUERIES
  ///
  /// This mode bit configures the database to record recent queries.  <i>required</i>
  ///@see \#setupSuggestions(String, int)
  static const DATABASE_MODE_QUERIES = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SearchRecentSuggestionsProvider()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setupSuggestions = jniAccessors.getMethodIDOf(
      _classRef, "setupSuggestions", "(Ljava/lang/String;I)V");

  /// from: protected void setupSuggestions(java.lang.String authority, int mode)
  ///
  /// In order to use this class, you must extend it, and call this setup function from your
  /// constructor.  In your application or activities, you must provide the same values when
  /// you create the android.provider.SearchRecentSuggestions helper.
  ///@param authority This must match the authority that you've declared in your manifest.
  ///@param mode You can use mode flags here to determine certain functional aspects of your
  /// database.  Note, this value should not change from run to run, because when it does change,
  /// your suggestions database may be wiped.
  ///@see \#DATABASE_MODE_QUERIES
  ///@see \#DATABASE_MODE_2LINES
  void setupSuggestions(jni.JniString authority, int mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_setupSuggestions,
          jni.JniType.voidType, [authority.reference, mode]).check();

  static final _id_delete1 = jniAccessors.getMethodIDOf(_classRef, "delete",
      "(Landroid/net/Uri;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public int delete(android.net.Uri uri, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  int delete1(
          uri_.Uri uri, jni.JniString selection, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_delete1, jni.JniType.intType, [
        uri.reference,
        selection.reference,
        selectionArgs.reference
      ]).integer;

  static final _id_getType = jniAccessors.getMethodIDOf(
      _classRef, "getType", "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: public java.lang.String getType(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  jni.JniString getType(uri_.Uri uri) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getType, jni.JniType.objectType, [uri.reference]).object);

  static final _id_insert = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(Landroid/net/Uri;Landroid/content/ContentValues;)Landroid/net/Uri;");

  /// from: public android.net.Uri insert(android.net.Uri uri, android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  uri_.Uri insert(uri_.Uri uri, contentvalues_.ContentValues values) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference, _id_insert,
          jni.JniType.objectType, [uri.reference, values.reference]).object);

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()Z");

  /// from: public boolean onCreate()
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  bool onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.booleanType, []).boolean;

  static final _id_query = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  cursor_.Cursor query(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference
      ]).object);

  static final _id_update = jniAccessors.getMethodIDOf(_classRef, "update",
      "(Landroid/net/Uri;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  int update(uri_.Uri uri, contentvalues_.ContentValues values,
          jni.JniString selection, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_update, jni.JniType.intType, [
        uri.reference,
        values.reference,
        selection.reference,
        selectionArgs.reference
      ]).integer;
}
