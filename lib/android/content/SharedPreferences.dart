// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.SharedPreferences
///
/// Interface for accessing and modifying preference data returned by Context\#getSharedPreferences.  For any particular set of preferences,
/// there is a single instance of this class that all clients share.
/// Modifications to the preferences must go through an Editor object
/// to ensure the preference values remain in a consistent state and control
/// when they are committed to storage.  Objects that are returned from the
/// various <code>get</code> methods must be treated as immutable by the application.
///
/// Note: This class provides strong consistency guarantees. It is using expensive operations
/// which might slow down an app. Frequently changing properties or properties where loss can be
/// tolerated should use other mechanisms. For more details read the comments on
/// Editor\#commit() and Editor\#apply().
///
/// _Note: This class does not support use across multiple processes._
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using SharedPreferences, read the
/// <a href="{@docRoot}guide/topics/data/data-storage.html\#pref">Data Storage</a>
/// developer guide.
///</div>
///@see Context\#getSharedPreferences
class SharedPreferences extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/SharedPreferences");
  SharedPreferences.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getAll =
      jniAccessors.getMethodIDOf(_classRef, "getAll", "()Ljava/util/Map;");

  /// from: public abstract java.util.Map<java.lang.String,?> getAll()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all values from the preferences.
  ///
  /// Note that you _must not_ modify the collection returned
  /// by this method, or alter any of its contents.  The consistency of your
  /// stored data is not guaranteed if you do.
  ///@return Returns a map containing a list of pairs key/value representing
  /// the preferences.
  ///@throws NullPointerException
  jni.JniObject getAll() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAll, jni.JniType.objectType, []).object);

  static final _id_getString = jniAccessors.getMethodIDOf(_classRef,
      "getString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public abstract java.lang.String getString(java.lang.String key, java.lang.String defValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a String value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///
  /// This value may be {@code null}.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// a String.
  ///
  /// This value may be {@code null}.
  ///@throws ClassCastException
  jni.JniString getString(jni.JniString key, jni.JniString defValue) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getString,
          jni.JniType.objectType,
          [key.reference, defValue.reference]).object);

  static final _id_getStringSet = jniAccessors.getMethodIDOf(_classRef,
      "getStringSet", "(Ljava/lang/String;Ljava/util/Set;)Ljava/util/Set;");

  /// from: public abstract java.util.Set<java.lang.String> getStringSet(java.lang.String key, java.util.Set<java.lang.String> defValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a set of String values from the preferences.
  ///
  /// Note that you _must not_ modify the set instance returned
  /// by this call.  The consistency of the stored data is not guaranteed
  /// if you do, nor is your ability to modify the instance at all.
  ///@param key The name of the preference to retrieve.
  ///@param defValues Values to return if this preference does not exist.
  ///
  /// This value may be {@code null}.
  ///@return Returns the preference values if they exist, or defValues.
  /// Throws ClassCastException if there is a preference with this name
  /// that is not a Set.
  ///
  /// This value may be {@code null}.
  ///@throws ClassCastException
  jni.JniObject getStringSet(jni.JniString key, jni.JniObject defValues) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStringSet,
          jni.JniType.objectType,
          [key.reference, defValues.reference]).object);

  static final _id_getInt =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "(Ljava/lang/String;I)I");

  /// from: public abstract int getInt(java.lang.String key, int defValue)
  ///
  /// Retrieve an int value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// an int.
  ///@throws ClassCastException
  int getInt(jni.JniString key, int defValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getInt,
          jni.JniType.intType, [key.reference, defValue]).integer;

  static final _id_getLong = jniAccessors.getMethodIDOf(
      _classRef, "getLong", "(Ljava/lang/String;J)J");

  /// from: public abstract long getLong(java.lang.String key, long defValue)
  ///
  /// Retrieve a long value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// a long.
  ///@throws ClassCastException
  int getLong(jni.JniString key, int defValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getLong,
          jni.JniType.longType, [key.reference, defValue]).long;

  static final _id_getFloat = jniAccessors.getMethodIDOf(
      _classRef, "getFloat", "(Ljava/lang/String;F)F");

  /// from: public abstract float getFloat(java.lang.String key, float defValue)
  ///
  /// Retrieve a float value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// a float.
  ///@throws ClassCastException
  double getFloat(jni.JniString key, double defValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFloat,
          jni.JniType.floatType, [key.reference, defValue]).float;

  static final _id_getBoolean = jniAccessors.getMethodIDOf(
      _classRef, "getBoolean", "(Ljava/lang/String;Z)Z");

  /// from: public abstract boolean getBoolean(java.lang.String key, boolean defValue)
  ///
  /// Retrieve a boolean value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// a boolean.
  ///@throws ClassCastException
  bool getBoolean(jni.JniString key, bool defValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getBoolean,
          jni.JniType.booleanType, [key.reference, defValue]).boolean;

  static final _id_contains = jniAccessors.getMethodIDOf(
      _classRef, "contains", "(Ljava/lang/String;)Z");

  /// from: public abstract boolean contains(java.lang.String key)
  ///
  /// Checks whether the preferences contains a preference.
  ///@param key The name of the preference to check.
  ///@return Returns true if the preference exists in the preferences,
  ///         otherwise false.
  bool contains(jni.JniString key) => jniAccessors.callMethodWithArgs(reference,
      _id_contains, jni.JniType.booleanType, [key.reference]).boolean;

  static final _id_edit = jniAccessors.getMethodIDOf(
      _classRef, "edit", "()Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor edit()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Editor for these preferences, through which you can make
  /// modifications to the data in the preferences and atomically commit those
  /// changes back to the SharedPreferences object.
  ///
  /// Note that you _must_ call Editor\#commit to have any
  /// changes you perform in the Editor actually show up in the
  /// SharedPreferences.
  ///@return Returns a new instance of the Editor interface, allowing
  /// you to modify the values in this SharedPreferences object.
  SharedPreferences_Editor edit() =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_edit, jni.JniType.objectType, []).object);

  static final _id_registerOnSharedPreferenceChangeListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "registerOnSharedPreferenceChangeListener",
          "(Landroid/content/SharedPreferences\$OnSharedPreferenceChangeListener;)V");

  /// from: public abstract void registerOnSharedPreferenceChangeListener(android.content.SharedPreferences.OnSharedPreferenceChangeListener listener)
  ///
  /// Registers a callback to be invoked when a change happens to a preference.
  ///
  /// <p class="caution"><strong>Caution:</strong> The preference manager does
  /// not currently store a strong reference to the listener. You must store a
  /// strong reference to the listener, or it will be susceptible to garbage
  /// collection. We recommend you keep a reference to the listener in the
  /// instance data of an object that will exist as long as you need the
  /// listener.
  ///
  ///@param listener The callback that will run.
  ///@see \#unregisterOnSharedPreferenceChangeListener
  void registerOnSharedPreferenceChangeListener(
          SharedPreferences_OnSharedPreferenceChangeListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerOnSharedPreferenceChangeListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_unregisterOnSharedPreferenceChangeListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "unregisterOnSharedPreferenceChangeListener",
          "(Landroid/content/SharedPreferences\$OnSharedPreferenceChangeListener;)V");

  /// from: public abstract void unregisterOnSharedPreferenceChangeListener(android.content.SharedPreferences.OnSharedPreferenceChangeListener listener)
  ///
  /// Unregisters a previous callback.
  ///@param listener The callback that should be unregistered.
  ///@see \#registerOnSharedPreferenceChangeListener
  void unregisterOnSharedPreferenceChangeListener(
          SharedPreferences_OnSharedPreferenceChangeListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterOnSharedPreferenceChangeListener,
          jni.JniType.voidType,
          [listener.reference]).check();
}

/// from: android.content.SharedPreferences$OnSharedPreferenceChangeListener
///
/// Interface definition for a callback to be invoked when a shared
/// preference is changed.
class SharedPreferences_OnSharedPreferenceChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/content/SharedPreferences\$OnSharedPreferenceChangeListener");
  SharedPreferences_OnSharedPreferenceChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onSharedPreferenceChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onSharedPreferenceChanged",
      "(Landroid/content/SharedPreferences;Ljava/lang/String;)V");

  /// from: public abstract void onSharedPreferenceChanged(android.content.SharedPreferences sharedPreferences, java.lang.String key)
  ///
  /// Called when a shared preference is changed, added, or removed. This
  /// may be called even if a preference is set to its existing value.
  ///
  /// This callback will be run on your main thread.
  ///@param sharedPreferences The SharedPreferences that received
  ///            the change.
  ///@param key The key of the preference that was changed, added, or
  ///            removed.
  void onSharedPreferenceChanged(
          SharedPreferences sharedPreferences, jni.JniString key) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSharedPreferenceChanged,
          jni.JniType.voidType,
          [sharedPreferences.reference, key.reference]).check();
}

/// from: android.content.SharedPreferences$Editor
///
/// Interface used for modifying values in a SharedPreferences
/// object.  All changes you make in an editor are batched, and not copied
/// back to the original SharedPreferences until you call \#commit
/// or \#apply
class SharedPreferences_Editor extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/SharedPreferences\$Editor");
  SharedPreferences_Editor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_putString = jniAccessors.getMethodIDOf(
      _classRef,
      "putString",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor putString(java.lang.String key, java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a String value in the preferences editor, to be written back once
  /// \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.  Passing {@code null}
  ///    for this argument is equivalent to calling \#remove(String) with
  ///    this key.
  ///
  /// This value may be {@code null}.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putString(jni.JniString key, jni.JniString value) =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putString,
          jni.JniType.objectType,
          [key.reference, value.reference]).object);

  static final _id_putStringSet = jniAccessors.getMethodIDOf(
      _classRef,
      "putStringSet",
      "(Ljava/lang/String;Ljava/util/Set;)Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor putStringSet(java.lang.String key, java.util.Set<java.lang.String> values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a set of String values in the preferences editor, to be written
  /// back once \#commit or \#apply is called.
  ///@param key The name of the preference to modify.
  ///@param values The set of new values for the preference.  Passing {@code null}
  ///    for this argument is equivalent to calling \#remove(String) with
  ///    this key.
  /// This value may be {@code null}.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putStringSet(
          jni.JniString key, jni.JniObject values) =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putStringSet,
          jni.JniType.objectType,
          [key.reference, values.reference]).object);

  static final _id_putInt = jniAccessors.getMethodIDOf(_classRef, "putInt",
      "(Ljava/lang/String;I)Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor putInt(java.lang.String key, int value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an int value in the preferences editor, to be written back once
  /// \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putInt(jni.JniString key, int value) =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putInt,
          jni.JniType.objectType,
          [key.reference, value]).object);

  static final _id_putLong = jniAccessors.getMethodIDOf(_classRef, "putLong",
      "(Ljava/lang/String;J)Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor putLong(java.lang.String key, long value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a long value in the preferences editor, to be written back once
  /// \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putLong(jni.JniString key, int value) =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putLong,
          jni.JniType.objectType,
          [key.reference, value]).object);

  static final _id_putFloat = jniAccessors.getMethodIDOf(_classRef, "putFloat",
      "(Ljava/lang/String;F)Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor putFloat(java.lang.String key, float value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a float value in the preferences editor, to be written back once
  /// \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putFloat(jni.JniString key, double value) =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putFloat,
          jni.JniType.objectType,
          [key.reference, value]).object);

  static final _id_putBoolean = jniAccessors.getMethodIDOf(
      _classRef,
      "putBoolean",
      "(Ljava/lang/String;Z)Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor putBoolean(java.lang.String key, boolean value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a boolean value in the preferences editor, to be written back
  /// once \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putBoolean(jni.JniString key, bool value) =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putBoolean,
          jni.JniType.objectType,
          [key.reference, value]).object);

  static final _id_remove = jniAccessors.getMethodIDOf(_classRef, "remove",
      "(Ljava/lang/String;)Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor remove(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Mark in the editor that a preference value should be removed, which
  /// will be done in the actual preferences once \#commit is
  /// called.
  ///
  /// Note that when committing back to the preferences, all removals
  /// are done first, regardless of whether you called remove before
  /// or after put methods on this editor.
  ///@param key The name of the preference to remove.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor remove(jni.JniString key) =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_remove,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_clear = jniAccessors.getMethodIDOf(
      _classRef, "clear", "()Landroid/content/SharedPreferences\$Editor;");

  /// from: public abstract android.content.SharedPreferences.Editor clear()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Mark in the editor to remove _all_ values from the
  /// preferences.  Once commit is called, the only remaining preferences
  /// will be any that you have defined in this editor.
  ///
  /// Note that when committing back to the preferences, the clear
  /// is done first, regardless of whether you called clear before
  /// or after put methods on this editor.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor clear() =>
      SharedPreferences_Editor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clear, jni.JniType.objectType, []).object);

  static final _id_commit =
      jniAccessors.getMethodIDOf(_classRef, "commit", "()Z");

  /// from: public abstract boolean commit()
  ///
  /// Commit your preferences changes back from this Editor to the
  /// SharedPreferences object it is editing.  This atomically
  /// performs the requested modifications, replacing whatever is currently
  /// in the SharedPreferences.
  ///
  /// Note that when two editors are modifying preferences at the same
  /// time, the last one to call commit wins.
  ///
  /// If you don't care about the return value and you're
  /// using this from your application's main thread, consider
  /// using \#apply instead.
  ///@return Returns true if the new values were successfully written
  /// to persistent storage.
  bool commit() => jniAccessors.callMethodWithArgs(
      reference, _id_commit, jni.JniType.booleanType, []).boolean;

  static final _id_apply =
      jniAccessors.getMethodIDOf(_classRef, "apply", "()V");

  /// from: public abstract void apply()
  ///
  /// Commit your preferences changes back from this Editor to the
  /// SharedPreferences object it is editing.  This atomically
  /// performs the requested modifications, replacing whatever is currently
  /// in the SharedPreferences.
  ///
  /// Note that when two editors are modifying preferences at the same
  /// time, the last one to call apply wins.
  ///
  /// Unlike \#commit, which writes its preferences out
  /// to persistent storage synchronously, \#apply
  /// commits its changes to the in-memory
  /// SharedPreferences immediately but starts an
  /// asynchronous commit to disk and you won't be notified of
  /// any failures.  If another editor on this
  /// SharedPreferences does a regular \#commit
  /// while a \#apply is still outstanding, the
  /// \#commit will block until all async commits are
  /// completed as well as the commit itself.
  ///
  /// As SharedPreferences instances are singletons within
  /// a process, it's safe to replace any instance of \#commit with
  /// \#apply if you were already ignoring the return value.
  ///
  /// You don't need to worry about Android component
  /// lifecycles and their interaction with <code>apply()</code>
  /// writing to disk.  The framework makes sure in-flight disk
  /// writes from <code>apply()</code> complete before switching
  /// states.
  ///
  /// <p class='note'>The SharedPreferences.Editor interface
  /// isn't expected to be implemented directly.  However, if you
  /// previously did implement it and are now getting errors
  /// about missing <code>apply()</code>, you can simply call
  /// \#commit from <code>apply()</code>.
  void apply() => jniAccessors.callMethodWithArgs(
      reference, _id_apply, jni.JniType.voidType, []).check();
}
